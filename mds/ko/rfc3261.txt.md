

```text
Network Working Group                                       J. Rosenberg
Request for Comments: 3261                                   dynamicsoft
Obsoletes: 2543                                           H. Schulzrinne
Category: Standards Track                                    Columbia U.
                                                            G. Camarillo
                                                                Ericsson
                                                             A. Johnston
                                                                WorldCom
                                                             J. Peterson
                                                                 Neustar
                                                               R. Sparks
                                                             dynamicsoft
                                                              M. Handley
                                                                    ICIR
                                                             E. Schooler
                                                                    AT&T
                                                               June 2002

                    SIP: Session Initiation Protocol
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2002\). 판권 소유.

---
# **Abstract**

이 문서에서는 하나 이상의 참가자와의 세션을 생성, 수정 및 종료하기 위한 애플리케이션 계층 제어\(신호\) 프로토콜인 SIP\(Session Initiation Protocol\)에 대해 설명합니다. 이러한 세션에는 인터넷 전화 통화, 멀티미디어 배포 및 멀티미디어 회의가 포함됩니다.

세션을 생성하는 데 사용되는 SIP 초대에는 참가자가 호환 가능한 미디어 유형 집합에 동의할 수 있도록 하는 세션 설명이 포함되어 있습니다. SIP는 프록시 서버라는 요소를 사용하여 요청을 사용자의 현재 위치로 라우팅하고, 서비스에 대해 사용자를 인증 및 승인하고, 공급자 통화 라우팅 정책을 구현하고, 사용자에게 기능을 제공합니다. SIP는 또한 사용자가 프록시 서버에서 사용할 현재 위치를 업로드할 수 있는 등록 기능을 제공합니다. SIP는 여러 가지 전송 프로토콜 위에서 실행됩니다.

---
# **Table of Contents**

```text
   1          Introduction ........................................    8
   2          Overview of SIP Functionality .......................    9
   3          Terminology .........................................   10
   4          Overview of Operation ...............................   10
   5          Structure of the Protocol ...........................   18
   6          Definitions .........................................   20
   7          SIP Messages ........................................   26
   7.1        Requests ............................................   27
   7.2        Responses ...........................................   28
   7.3        Header Fields .......................................   29
   7.3.1      Header Field Format .................................   30
   7.3.2      Header Field Classification .........................   32
   7.3.3      Compact Form ........................................   32
   7.4        Bodies ..............................................   33
   7.4.1      Message Body Type ...................................   33
   7.4.2      Message Body Length .................................   33
   7.5        Framing SIP Messages ................................   34
   8          General User Agent Behavior .........................   34
   8.1        UAC Behavior ........................................   35
   8.1.1      Generating the Request ..............................   35
   8.1.1.1    Request-URI .........................................   35
   8.1.1.2    To ..................................................   36
   8.1.1.3    From ................................................   37
   8.1.1.4    Call-ID .............................................   37
   8.1.1.5    CSeq ................................................   38
   8.1.1.6    Max-Forwards ........................................   38
   8.1.1.7    Via .................................................   39
   8.1.1.8    Contact .............................................   40
   8.1.1.9    Supported and Require ...............................   40
   8.1.1.10   Additional Message Components .......................   41
   8.1.2      Sending the Request .................................   41
   8.1.3      Processing Responses ................................   42
   8.1.3.1    Transaction Layer Errors ............................   42
   8.1.3.2    Unrecognized Responses ..............................   42
   8.1.3.3    Vias ................................................   43
   8.1.3.4    Processing 3xx Responses ............................   43
   8.1.3.5    Processing 4xx Responses ............................   45
   8.2        UAS Behavior ........................................   46
   8.2.1      Method Inspection ...................................   46
   8.2.2      Header Inspection ...................................   46
   8.2.2.1    To and Request-URI ..................................   46
   8.2.2.2    Merged Requests .....................................   47
   8.2.2.3    Require .............................................   47
   8.2.3      Content Processing ..................................   48
   8.2.4      Applying Extensions .................................   49
   8.2.5      Processing the Request ..............................   49
   8.2.6      Generating the Response .............................   49
   8.2.6.1    Sending a Provisional Response ......................   49
   8.2.6.2    Headers and Tags ....................................   50
   8.2.7      Stateless UAS Behavior ..............................   50
   8.3        Redirect Servers ....................................   51
   9          Canceling a Request .................................   53
   9.1        Client Behavior .....................................   53
   9.2        Server Behavior .....................................   55
   10         Registrations .......................................   56
   10.1       Overview ............................................   56
   10.2       Constructing the REGISTER Request ...................   57
   10.2.1     Adding Bindings .....................................   59
   10.2.1.1   Setting the Expiration Interval of Contact Addresses    60
   10.2.1.2   Preferences among Contact Addresses .................   61
   10.2.2     Removing Bindings ...................................   61
   10.2.3     Fetching Bindings ...................................   61
   10.2.4     Refreshing Bindings .................................   61
   10.2.5     Setting the Internal Clock ..........................   62
   10.2.6     Discovering a Registrar .............................   62
   10.2.7     Transmitting a Request ..............................   62
   10.2.8     Error Responses .....................................   63
   10.3       Processing REGISTER Requests ........................   63
   11         Querying for Capabilities ...........................   66
   11.1       Construction of OPTIONS Request .....................   67
   11.2       Processing of OPTIONS Request .......................   68
   12         Dialogs .............................................   69
   12.1       Creation of a Dialog ................................   70
   12.1.1     UAS behavior ........................................   70
   12.1.2     UAC Behavior ........................................   71
   12.2       Requests within a Dialog ............................   72
   12.2.1     UAC Behavior ........................................   73
   12.2.1.1   Generating the Request ..............................   73
   12.2.1.2   Processing the Responses ............................   75
   12.2.2     UAS Behavior ........................................   76
   12.3       Termination of a Dialog .............................   77
   13         Initiating a Session ................................   77
   13.1       Overview ............................................   77
   13.2       UAC Processing ......................................   78
   13.2.1     Creating the Initial INVITE .........................   78
   13.2.2     Processing INVITE Responses .........................   81
   13.2.2.1   1xx Responses .......................................   81
   13.2.2.2   3xx Responses .......................................   81
   13.2.2.3   4xx, 5xx and 6xx Responses ..........................   81
   13.2.2.4   2xx Responses .......................................   82
   13.3       UAS Processing ......................................   83
   13.3.1     Processing of the INVITE ............................   83
   13.3.1.1   Progress ............................................   84
   13.3.1.2   The INVITE is Redirected ............................   84
   13.3.1.3   The INVITE is Rejected ..............................   85
   13.3.1.4   The INVITE is Accepted ..............................   85
   14         Modifying an Existing Session .......................   86
   14.1       UAC Behavior ........................................   86
   14.2       UAS Behavior ........................................   88
   15         Terminating a Session ...............................   89
   15.1       Terminating a Session with a BYE Request ............   90
   15.1.1     UAC Behavior ........................................   90
   15.1.2     UAS Behavior ........................................   91
   16         Proxy Behavior ......................................   91
   16.1       Overview ............................................   91
   16.2       Stateful Proxy ......................................   92
   16.3       Request Validation ..................................   94
   16.4       Route Information Preprocessing .....................   96
   16.5       Determining Request Targets .........................   97
   16.6       Request Forwarding ..................................   99
   16.7       Response Processing .................................  107
   16.8       Processing Timer C ..................................  114
   16.9       Handling Transport Errors ...........................  115
   16.10      CANCEL Processing ...................................  115
   16.11      Stateless Proxy .....................................  116
   16.12      Summary of Proxy Route Processing ...................  118
   16.12.1    Examples ............................................  118
   16.12.1.1  Basic SIP Trapezoid .................................  118
   16.12.1.2  Traversing a Strict-Routing Proxy ...................  120
   16.12.1.3  Rewriting Record-Route Header Field Values ..........  121
   17         Transactions ........................................  122
   17.1       Client Transaction ..................................  124
   17.1.1     INVITE Client Transaction ...........................  125
   17.1.1.1   Overview of INVITE Transaction ......................  125
   17.1.1.2   Formal Description ..................................  125
   17.1.1.3   Construction of the ACK Request .....................  129
   17.1.2     Non-INVITE Client Transaction .......................  130
   17.1.2.1   Overview of the non-INVITE Transaction ..............  130
   17.1.2.2   Formal Description ..................................  131
   17.1.3     Matching Responses to Client Transactions ...........  132
   17.1.4     Handling Transport Errors ...........................  133
   17.2       Server Transaction ..................................  134
   17.2.1     INVITE Server Transaction ...........................  134
   17.2.2     Non-INVITE Server Transaction .......................  137
   17.2.3     Matching Requests to Server Transactions ............  138
   17.2.4     Handling Transport Errors ...........................  141
   18         Transport ...........................................  141
   18.1       Clients .............................................  142
   18.1.1     Sending Requests ....................................  142
   18.1.2     Receiving Responses .................................  144
   18.2       Servers .............................................  145
   18.2.1     Receiving Requests ..................................  145
   18.2.2     Sending Responses ...................................  146
   18.3       Framing .............................................  147
   18.4       Error Handling ......................................  147
   19         Common Message Components ...........................  147
   19.1       SIP and SIPS Uniform Resource Indicators ............  148
   19.1.1     SIP and SIPS URI Components .........................  148
   19.1.2     Character Escaping Requirements .....................  152
   19.1.3     Example SIP and SIPS URIs ...........................  153
   19.1.4     URI Comparison ......................................  153
   19.1.5     Forming Requests from a URI .........................  156
   19.1.6     Relating SIP URIs and tel URLs ......................  157
   19.2       Option Tags .........................................  158
   19.3       Tags ................................................  159
   20         Header Fields .......................................  159
   20.1       Accept ..............................................  161
   20.2       Accept-Encoding .....................................  163
   20.3       Accept-Language .....................................  164
   20.4       Alert-Info ..........................................  164
   20.5       Allow ...............................................  165
   20.6       Authentication-Info .................................  165
   20.7       Authorization .......................................  165
   20.8       Call-ID .............................................  166
   20.9       Call-Info ...........................................  166
   20.10      Contact .............................................  167
   20.11      Content-Disposition .................................  168
   20.12      Content-Encoding ....................................  169
   20.13      Content-Language ....................................  169
   20.14      Content-Length ......................................  169
   20.15      Content-Type ........................................  170
   20.16      CSeq ................................................  170
   20.17      Date ................................................  170
   20.18      Error-Info ..........................................  171
   20.19      Expires .............................................  171
   20.20      From ................................................  172
   20.21      In-Reply-To .........................................  172
   20.22      Max-Forwards ........................................  173
   20.23      Min-Expires .........................................  173
   20.24      MIME-Version ........................................  173
   20.25      Organization ........................................  174
   20.26      Priority ............................................  174
   20.27      Proxy-Authenticate ..................................  174
   20.28      Proxy-Authorization .................................  175
   20.29      Proxy-Require .......................................  175
   20.30      Record-Route ........................................  175
   20.31      Reply-To ............................................  176
   20.32      Require .............................................  176
   20.33      Retry-After .........................................  176
   20.34      Route ...............................................  177
   20.35      Server ..............................................  177
   20.36      Subject .............................................  177
   20.37      Supported ...........................................  178
   20.38      Timestamp ...........................................  178
   20.39      To ..................................................  178
   20.40      Unsupported .........................................  179
   20.41      User-Agent ..........................................  179
   20.42      Via .................................................  179
   20.43      Warning .............................................  180
   20.44      WWW-Authenticate ....................................  182
   21         Response Codes ......................................  182
   21.1       Provisional 1xx .....................................  182
   21.1.1     100 Trying ..........................................  183
   21.1.2     180 Ringing .........................................  183
   21.1.3     181 Call Is Being Forwarded .........................  183
   21.1.4     182 Queued ..........................................  183
   21.1.5     183 Session Progress ................................  183
   21.2       Successful 2xx ......................................  183
   21.2.1     200 OK ..............................................  183
   21.3       Redirection 3xx .....................................  184
   21.3.1     300 Multiple Choices ................................  184
   21.3.2     301 Moved Permanently ...............................  184
   21.3.3     302 Moved Temporarily ...............................  184
   21.3.4     305 Use Proxy .......................................  185
   21.3.5     380 Alternative Service .............................  185
   21.4       Request Failure 4xx .................................  185
   21.4.1     400 Bad Request .....................................  185
   21.4.2     401 Unauthorized ....................................  185
   21.4.3     402 Payment Required ................................  186
   21.4.4     403 Forbidden .......................................  186
   21.4.5     404 Not Found .......................................  186
   21.4.6     405 Method Not Allowed ..............................  186
   21.4.7     406 Not Acceptable ..................................  186
   21.4.8     407 Proxy Authentication Required ...................  186
   21.4.9     408 Request Timeout .................................  186
   21.4.10    410 Gone ............................................  187
   21.4.11    413 Request Entity Too Large ........................  187
   21.4.12    414 Request-URI Too Long ............................  187
   21.4.13    415 Unsupported Media Type ..........................  187
   21.4.14    416 Unsupported URI Scheme ..........................  187
   21.4.15    420 Bad Extension ...................................  187
   21.4.16    421 Extension Required ..............................  188
   21.4.17    423 Interval Too Brief ..............................  188
   21.4.18    480 Temporarily Unavailable .........................  188
   21.4.19    481 Call/Transaction Does Not Exist .................  188
   21.4.20    482 Loop Detected ...................................  188
   21.4.21    483 Too Many Hops ...................................  189
   21.4.22    484 Address Incomplete ..............................  189
   21.4.23    485 Ambiguous .......................................  189
   21.4.24    486 Busy Here .......................................  189
   21.4.25    487 Request Terminated ..............................  190
   21.4.26    488 Not Acceptable Here .............................  190
   21.4.27    491 Request Pending .................................  190
   21.4.28    493 Undecipherable ..................................  190
   21.5       Server Failure 5xx ..................................  190
   21.5.1     500 Server Internal Error ...........................  190
   21.5.2     501 Not Implemented .................................  191
   21.5.3     502 Bad Gateway .....................................  191
   21.5.4     503 Service Unavailable .............................  191
   21.5.5     504 Server Time-out .................................  191
   21.5.6     505 Version Not Supported ...........................  192
   21.5.7     513 Message Too Large ...............................  192
   21.6       Global Failures 6xx .................................  192
   21.6.1     600 Busy Everywhere .................................  192
   21.6.2     603 Decline .........................................  192
   21.6.3     604 Does Not Exist Anywhere .........................  192
   21.6.4     606 Not Acceptable ..................................  192
   22         Usage of HTTP Authentication ........................  193
   22.1       Framework ...........................................  193
   22.2       User-to-User Authentication .........................  195
   22.3       Proxy-to-User Authentication ........................  197
   22.4       The Digest Authentication Scheme ....................  199
   23         S/MIME ..............................................  201
   23.1       S/MIME Certificates .................................  201
   23.2       S/MIME Key Exchange .................................  202
   23.3       Securing MIME bodies ................................  205
   23.4       SIP Header Privacy and Integrity using S/MIME:
              Tunneling SIP .......................................  207
   23.4.1     Integrity and Confidentiality Properties of SIP
              Headers .............................................  207
   23.4.1.1   Integrity ...........................................  207
   23.4.1.2   Confidentiality .....................................  208
   23.4.2     Tunneling Integrity and Authentication ..............  209
   23.4.3     Tunneling Encryption ................................  211
   24         Examples ............................................  213
   24.1       Registration ........................................  213
   24.2       Session Setup .......................................  214
   25         Augmented BNF for the SIP Protocol ..................  219
   25.1       Basic Rules .........................................  219
   26         Security Considerations: Threat Model and Security
              Usage Recommendations ...............................  232
   26.1       Attacks and Threat Models ...........................  233
   26.1.1     Registration Hijacking ..............................  233
   26.1.2     Impersonating a Server ..............................  234
   26.1.3     Tampering with Message Bodies .......................  235
   26.1.4     Tearing Down Sessions ...............................  235
   26.1.5     Denial of Service and Amplification .................  236
   26.2       Security Mechanisms .................................  237
   26.2.1     Transport and Network Layer Security ................  238
   26.2.2     SIPS URI Scheme .....................................  239
   26.2.3     HTTP Authentication .................................  240
   26.2.4     S/MIME ..............................................  240
   26.3       Implementing Security Mechanisms ....................  241
   26.3.1     Requirements for Implementers of SIP ................  241
   26.3.2     Security Solutions ..................................  242
   26.3.2.1   Registration ........................................  242
   26.3.2.2   Interdomain Requests ................................  243
   26.3.2.3   Peer-to-Peer Requests ...............................  245
   26.3.2.4   DoS Protection ......................................  246
   26.4       Limitations .........................................  247
   26.4.1     HTTP Digest .........................................  247
   26.4.2     S/MIME ..............................................  248
   26.4.3     TLS .................................................  249
   26.4.4     SIPS URIs ...........................................  249
   26.5       Privacy .............................................  251
   27         IANA Considerations .................................  252
   27.1       Option Tags .........................................  252
   27.2       Warn-Codes ..........................................  252
   27.3       Header Field Names ..................................  253
   27.4       Method and Response Codes ...........................  253
   27.5       The "message/sip" MIME type.  .......................  254
   27.6       New Content-Disposition Parameter Registrations .....  255
   28         Changes From RFC 2543 ...............................  255
   28.1       Major Functional Changes ............................  255
   28.2       Minor Functional Changes ............................  260
   29         Normative References ................................  261
   30         Informative References ..............................  262
   A          Table of Timer Values ...............................  265
   Acknowledgments ................................................  266
   Authors' Addresses .............................................  267
   Full Copyright Statement .......................................  269
```

---
# **1 Introduction**

세션을 생성하고 관리해야 하는 인터넷 응용 프로그램이 많이 있으며, 여기서 세션은 참가자 협회 간의 데이터 교환으로 간주됩니다. 이러한 애플리케이션의 구현은 참가자의 관행으로 인해 복잡합니다. 사용자는 끝점 간에 이동할 수 있고 여러 이름으로 주소를 지정할 수 있으며 여러 다른 미디어에서 때로는 동시에 통신할 수 있습니다. 음성, 비디오 또는 문자 메시지와 같은 다양한 형태의 실시간 멀티미디어 세션 데이터를 전달하는 수많은 프로토콜이 작성되었습니다. SIP\(Session Initiation Protocol\)는 다음과 같은 프로토콜과 함께 작동합니다.

인터넷 엔드포인트\(사용자 에이전트라고 함\)가 서로를 발견하고 공유하려는 세션의 특성에 동의할 수 있도록 합니다. 잠재 세션 참가자 찾기 및 기타 기능을 위해 SIP를 사용하면 사용자 에이전트가 등록, 세션 초대 및 기타 요청을 보낼 수 있는 네트워크 호스트\(프록시 서버라고 함\) 인프라를 생성할 수 있습니다. SIP는 기본 전송 프로토콜과 독립적으로 작동하며 설정 중인 세션 유형에 의존하지 않고 세션을 생성, 수정 및 종료하기 위한 민첩한 범용 도구입니다.

---
# **2 Overview of SIP Functionality**

SIP는 인터넷 전화 통화와 같은 멀티미디어 세션\(회의\)을 설정, 수정 및 종료할 수 있는 애플리케이션 계층 제어 프로토콜입니다. SIP는 멀티캐스트 회의와 같은 기존 세션에 참가자를 초대할 수도 있습니다. 기존 세션에 미디어를 추가하거나 제거할 수 있습니다. SIP는 개인 이동성을 지원하는 이름 매핑 및 리디렉션 서비스를 투명하게 지원합니다\[27\]. 사용자는 네트워크 위치에 관계없이 외부에서 볼 수 있는 단일 식별자를 유지할 수 있습니다.

SIP는 멀티미디어 통신 설정 및 종료의 5가지 측면을 지원합니다.

```text
      User location: determination of the end system to be used for
           communication;

      User availability: determination of the willingness of the called
           party to engage in communications;

      User capabilities: determination of the media and media parameters
           to be used;

      Session setup: "ringing", establishment of session parameters at
           both called and calling party;
```

세션 관리: 전송 및 종료 포함

- 세션, 세션 매개변수 수정 및 서비스 호출.

SIP는 수직적으로 통합된 통신 시스템이 아닙니다. SIP는 완전한 멀티미디어 아키텍처를 구축하기 위해 다른 IETF 프로토콜과 함께 사용할 수 있는 구성 요소입니다. 일반적으로 이러한 아키텍처에는 실시간 데이터를 전송하고 QoS 피드백을 제공하기 위한 RTP\(실시간 전송 프로토콜\)\(RFC 1889\[28\]\), 실시간 스트리밍 프로토콜\(RTSP\)\(RFC 2326\[29\]\)과 같은 프로토콜이 포함됩니다. \]\) 스트리밍 미디어 전달을 제어하기 위해 미디어

PSTN\(Public Switched Telephone Network\)에 대한 게이트웨이를 제어하기 위한 MEGACO\(Gateway Control Protocol\)\(RFC 3015 \[30\]\) 및 멀티미디어 세션을 설명하기 위한 SDP\(Session Description Protocol\)\(RFC 2327 \[1\]\). 따라서 SIP는 사용자에게 완전한 서비스를 제공하기 위해 다른 프로토콜과 함께 사용해야 합니다. 그러나 SIP의 기본 기능과 작동은 이러한 프로토콜에 의존하지 않습니다.

SIP는 서비스를 제공하지 않습니다. 오히려 SIP는 다양한 서비스를 구현하는 데 사용할 수 있는 기본 요소를 제공합니다. 예를 들어, SIP는 사용자의 위치를 ​​찾아 불투명한 개체를 현재 위치로 전달할 수 있습니다. 예를 들어 이 프리미티브가 SDP로 작성된 세션 설명을 전달하는 데 사용되는 경우 엔드포인트는 세션 매개변수에 동의할 수 있습니다. 동일한 프리미티브를 사용하여 발신자의 사진과 세션 설명을 전달하면 "발신자 ID" 서비스를 쉽게 구현할 수 있습니다. 이 예에서 볼 수 있듯이 단일 기본 요소는 일반적으로 여러 가지 다른 서비스를 제공하는 데 사용됩니다.

SIP는 플로어 제어 또는 투표와 같은 회의 제어 서비스를 제공하지 않으며 회의 관리 방법을 규정하지 않습니다. SIP는 다른 회의 제어 프로토콜을 사용하는 세션을 시작하는 데 사용될 수 있습니다. SIP 메시지와 이들이 설정한 세션은 완전히 다른 네트워크를 통과할 수 있으므로 SIP는 어떤 종류의 네트워크 리소스 예약 기능도 제공할 수 없으며 제공하지도 않습니다.

제공되는 서비스의 특성상 보안이 특히 중요합니다. 이를 위해 SIP는 서비스 거부 방지, 인증\(사용자 간 및 사용자 간 프록시 모두\), 무결성 보호, 암호화 및 개인 정보 보호 서비스를 포함하는 일련의 보안 서비스를 제공합니다.

SIP는 IPv4 및 IPv6 모두에서 작동합니다.

---
# **3 Terminology**

본 문서에서는 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY"라는 키워드를 사용합니다. 및 "OPTIONAL"은 BCP 14, RFC 2119 \[2\]에 설명된 대로 해석되며 호환 SIP 구현을 위한 요구 사항 수준을 나타냅니다.\(MUST NOT\)

---
# **4 Overview of Operation**

이 섹션에서는 간단한 예를 사용하여 SIP의 기본 작업을 소개합니다. 이 섹션은 본질적으로 튜토리얼이며 규범적인 설명을 포함하지 않습니다.

첫 번째 예는 SIP의 기본 기능\(종료점 위치, 통신 욕구 신호, 세션 설정을 위한 세션 매개변수 협상, 설정된 세션 해제\)을 보여줍니다.

그림 1은 Alice와 Bob이라는 두 사용자 간의 SIP 메시지 교환의 일반적인 예를 보여줍니다. \(각 메시지에는 문자 "F"와 텍스트 참조용 숫자가 표시되어 있습니다.\) 이 예에서 Alice는 자신의 PC\(소프트폰이라고 함\)에서 SIP 응용 프로그램을 사용하여 인터넷을 통해 SIP 전화로 Bob에게 전화를 겁니다. . 또한 세션 설정을 용이하게 하기 위해 Alice와 Bob을 대신하여 작동하는 두 개의 SIP 프록시 서버가 표시됩니다. 이러한 일반적인 배열은 그림 1에서 점선의 기하학적 모양으로 표시된 것처럼 "SIP 사다리꼴"이라고도 합니다.

Alice는 SIP URI라고 하는 URI\(Uniform Resource Identifier\) ​​유형인 SIP ID를 사용하여 Bob에게 "전화"합니다. SIP URI는 섹션 19.1에 정의되어 있습니다. 이는 일반적으로 사용자 이름과 호스트 이름을 포함하는 이메일 주소와 유사한 형식을 갖습니다. 이 경우 sip:bob@biloxi.com입니다. 여기서 biloxi.com은 Bob의 SIP 서비스 공급자의 도메인입니다. Alice의 SIP URI는 sip:alice@atlanta.com입니다. Alice는 Bob의 URI를 입력했을 수도 있고 하이퍼링크나 주소록 항목을 클릭했을 수도 있습니다. SIP는 SIPS URI라는 보안 URI도 제공합니다. 예를 들면 sips:bob@biloxi.com입니다. SIPS URI에 대한 호출은 발신자의 모든 SIP 메시지를 수신자의 도메인으로 전달하는 데 안전하고 암호화된 전송\(즉, TLS\)이 사용되도록 보장합니다. 여기에서 요청은 수신자에게 안전하게 전송되지만 수신자의 도메인 정책에 따라 달라지는 보안 메커니즘을 사용합니다.

SIP는 HTTP와 유사한 요청/응답 트랜잭션 모델을 기반으로 합니다. 각 트랜잭션은 서버의 특정 메서드나 함수를 호출하는 요청과 하나 이상의 응답으로 구성됩니다. 이 예에서 트랜잭션은 Alice의 소프트폰이 Bob의 SIP URI로 주소가 지정된 INVITE 요청을 보내는 것으로 시작됩니다. INVITE는 요청자\(Alice\)가 서버\(Bob\)가 수행하기를 원하는 작업을 지정하는 SIP 메서드의 예입니다. INVITE 요청에는 여러 헤더 필드가 포함되어 있습니다. 헤더 필드는 메시지에 대한 추가 정보를 제공하는 명명된 속성입니다. INVITE에 존재하는 것에는 통화에 대한 고유 식별자, 대상 주소, Alice의 주소 및 Alice가 Bob과 설정하려는 세션 유형에 대한 정보가 포함됩니다. INVITE\(그림 1의 메시지 F1\)는 다음과 같습니다.

```text
                     atlanta.com  . . . biloxi.com
                 .      proxy              proxy     .
               .                                       .
       Alice's  . . . . . . . . . . . . . . . . . . . .  Bob's
      softphone                                        SIP Phone
         |                |                |                |
         |    INVITE F1   |                |                |
         |--------------->|    INVITE F2   |                |
         |  100 Trying F3 |--------------->|    INVITE F4   |
         |<---------------|  100 Trying F5 |--------------->|
         |                |<-------------- | 180 Ringing F6 |
         |                | 180 Ringing F7 |<---------------|
         | 180 Ringing F8 |<---------------|     200 OK F9  |
         |<---------------|    200 OK F10  |<---------------|
         |    200 OK F11  |<---------------|                |
         |<---------------|                |                |
         |                       ACK F12                    |
         |------------------------------------------------->|
         |                   Media Session                  |
         |<================================================>|
         |                       BYE F13                    |
         |<-------------------------------------------------|
         |                     200 OK F14                   |
         |------------------------------------------------->|
         |                                                  |
```

- 그림 1: SIP 사다리꼴을 사용한 SIP 세션 설정 예

```text
      INVITE sip:bob@biloxi.com SIP/2.0
      Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bK776asdhds
      Max-Forwards: 70
      To: Bob <sip:bob@biloxi.com>
      From: Alice <sip:alice@atlanta.com>;tag=1928301774
      Call-ID: a84b4c76e66710@pc33.atlanta.com
      CSeq: 314159 INVITE
      Contact: <sip:alice@pc33.atlanta.com>
      Content-Type: application/sdp
      Content-Length: 142

      (Alice's SDP not shown)
```

텍스트로 인코딩된 메시지의 첫 번째 줄에는 메서드 이름\(INVITE\)이 포함됩니다. 다음 줄은 헤더 필드 목록입니다. 이 예에는 최소 필수 세트가 포함되어 있습니다. 헤더 필드는 아래에 간략하게 설명되어 있습니다.

Via에는 Alice가 이 요청에 대한 응답을 받을 것으로 예상하는 주소\(pc33.atlanta.com\)가 포함되어 있습니다. 또한 이 트랜잭션을 식별하는 분기 매개변수도 포함되어 있습니다.

요청이 원래 전달된 표시 이름\(Bob\)과 SIP 또는 SIPS URI\(sip:bob@biloxi.com\)를 포함합니다. 표시 이름은 RFC 2822 \[3\]에 설명되어 있습니다.

From에는 요청 보낸 사람을 나타내는 표시 이름\(Alice\)과 SIP 또는 SIPS URI\(sip:alice@atlanta.com\)도 포함되어 있습니다. 이 헤더 필드에는 소프트폰에 의해 URI에 추가된 임의의 문자열\(1928301774\)이 포함된 태그 매개변수도 있습니다. 식별 목적으로 사용됩니다.

Call-ID에는 임의의 문자열과 소프트폰의 호스트 이름 또는 IP 주소의 조합으로 생성된 이 통화에 대한 전역적으로 고유한 식별자가 포함되어 있습니다. To 태그, From 태그 및 Call-ID의 조합은 Alice와 Bob 간의 P2P SIP 관계를 완전히 정의하며 이를 대화라고 합니다.

CSeq 또는 명령 시퀀스에는 정수와 메서드 이름이 포함됩니다. CSeq 번호는 대화 상자 내에서 새로운 요청이 있을 때마다 증가하며 기존 시퀀스 번호입니다.

연락처에는 Alice에게 연락하기 위한 직접 경로를 나타내는 SIP 또는 SIPS URI가 포함되어 있으며 일반적으로 FQDN\(정규화된 도메인 이름\)의 사용자 이름으로 구성됩니다. FQDN이 선호되지만 많은 최종 시스템에는 등록된 도메인 이름이 없으므로 IP 주소가 허용됩니다. Via 헤더 필드는 다른 요소에 응답을 보낼 위치를 알려주는 반면, Contact 헤더 필드는 다른 요소에 향후 요청을 보낼 위치를 알려줍니다.

Max-Forwards는 요청이 목적지까지 가는 동안 만들 수 있는 홉 수를 제한하는 역할을 합니다. 각 홉에서 1씩 감소하는 정수로 구성됩니다.

Content-Type에는 메시지 본문에 대한 설명이 포함되어 있습니다\(표시되지 않음\).

Content-Length에는 메시지 본문의 옥텟\(바이트\) 수가 포함됩니다.

SIP 헤더 필드의 전체 세트는 섹션 20에 정의되어 있습니다.

미디어 유형, 코덱, 샘플링 속도 등 세션 세부 정보는 SIP를 사용하여 설명되지 않습니다. 오히려 SIP 메시지 본문에는 다른 프로토콜 형식으로 인코딩된 세션 설명이 포함되어 있습니다. 그러한 형식 중 하나가 SDP\(Session Description Protocol\)\(RFC 2327 \[1\]\)입니다. 이 SDP 메시지\(그림에는 표시되지 않음\)

예\)는 이메일 메시지에 문서 첨부 파일이 전달되거나 HTTP 메시지에 웹 페이지가 전달되는 것과 유사한 방식으로 SIP 메시지에 의해 전달됩니다.

소프트폰은 Bob의 위치나 biloxi.com 도메인의 SIP 서버를 모르기 때문에 INVITE를 Alice의 도메인인 atlanta.com에 서비스를 제공하는 SIP 서버로 보냅니다. 예를 들어 atlanta.com SIP 서버의 주소는 Alice의 소프트폰에서 구성되었을 수도 있고 DHCP에서 검색되었을 수도 있습니다.

atlanta.com SIP 서버는 프록시 서버로 알려진 SIP 서버 유형입니다. 프록시 서버는 SIP 요청을 수신하고 요청자를 대신하여 전달합니다. 이 예에서 프록시 서버는 INVITE 요청을 수신하고 100\(시도 중\) 응답을 Alice의 소프트폰으로 다시 보냅니다. 100\(시도 중\) 응답은 INVITE가 수신되었으며 프록시가 그녀를 대신하여 INVITE를 대상으로 라우팅하고 있음을 나타냅니다. SIP의 응답은 3자리 코드와 설명 문구를 사용합니다. 이 응답에는 Via의 INVITE와 동일한 To, From, Call-ID, CSeq 및 분기 매개 변수가 포함되어 있어 Alice의 소프트폰이 이 응답을 전송된 INVITE와 연관시킬 수 있습니다. atlanta.com 프록시 서버는 biloxi.com 도메인을 제공하는 SIP 서버를 찾기 위해 특정 유형의 DNS\(도메인 이름 서비스\) 조회를 수행하여 biloxi.com에서 프록시 서버를 찾습니다. 이는 \[4\]에 설명되어 있습니다. 결과적으로 biloxi.com 프록시 서버의 IP 주소를 획득하고 그곳으로 INVITE 요청을 전달하거나 프록시합니다. 요청을 전달하기 전에 atlanta.com 프록시 서버는 자체 주소가 포함된 추가적인 Via 헤더 필드 값을 추가합니다\(INVITE에는 이미 첫 번째 Via에 Alice의 주소가 포함되어 있습니다\). biloxi.com 프록시 서버는 INVITE를 수신하고 atlanta.com 프록시 서버에 100\(시도 중\) 응답으로 응답하여 INVITE를 수신했으며 요청을 처리 중임을 나타냅니다. 프록시 서버는 일반적으로 위치 서비스라고 불리는 Bob의 현재 IP 주소가 포함된 데이터베이스를 참조합니다. \(이 데이터베이스가 어떻게 채워질 수 있는지 다음 섹션에서 살펴보겠습니다.\) biloxi.com 프록시 서버는 자체 주소가 포함된 또 다른 Via 헤더 필드 값을 INVITE에 추가하고 이를 Bob의 SIP 전화로 프록시합니다.

Bob의 SIP 전화는 INVITE를 수신하고 Bob이 전화에 응답할지 여부를 결정할 수 있도록 Alice로부터 걸려오는 전화를 Bob에게 알립니다. 즉, Bob의 전화 벨이 울립니다. Bob의 SIP 전화는 이를 180\(벨소리\) 응답으로 표시하며 이는 반대 방향으로 두 프록시를 통해 다시 라우팅됩니다. 각 프록시는 Via 헤더 필드를 사용하여 응답을 보낼 위치를 결정하고 위에서 자체 주소를 제거합니다. 결과적으로 초기 INVITE를 라우팅하기 위해 DNS 및 위치 서비스 조회가 필요했지만 조회나 상태 확인 없이 180\(벨소리\) 응답이 호출자에게 반환될 수 있습니다.

프록시에서 유지됩니다. 이는 또한 INVITE를 보는 각 프록시가 INVITE에 대한 모든 응답도 볼 수 있다는 바람직한 속성을 가지고 있습니다.

Alice의 소프트폰은 180\(벨소리\) 응답을 받으면 오디오 통화 연결음을 사용하거나 Alice의 화면에 메시지를 표시하여 이 정보를 Alice에게 전달합니다.

이 예에서 Bob은 전화에 응답하기로 결정합니다. 그가 수화기를 들면 그의 SIP 전화는 200\(OK\) 응답을 보내 전화에 응답했음을 나타냅니다. 200\(OK\)에는 Bob이 Alice와 설정하려는 세션 유형에 대한 SDP 미디어 설명이 포함된 메시지 본문이 포함되어 있습니다. 결과적으로 SDP 메시지는 2단계로 교환됩니다. Alice는 하나를 Bob에게 보내고 Bob은 하나를 Alice에게 다시 보냈습니다. 이 2단계 교환은 기본적인 협상 기능을 제공하며 SDP 교환의 간단한 제안/응답 모델을 기반으로 합니다. Bob이 전화에 응답하고 싶지 않거나 다른 통화 중이라면 200\(OK\) 대신 오류 응답이 전송되어 미디어 세션이 설정되지 않습니다. SIP 응답 코드의 전체 목록은 섹션 21에 있습니다. Bob이 보낼 때 200\(OK\)\(그림 1의 메시지 F9\)은 다음과 같습니다.

```text
      SIP/2.0 200 OK
      Via: SIP/2.0/UDP server10.biloxi.com
         ;branch=z9hG4bKnashds8;received=192.0.2.3
      Via: SIP/2.0/UDP bigbox3.site3.atlanta.com
         ;branch=z9hG4bK77ef4c2312983.1;received=192.0.2.2
      Via: SIP/2.0/UDP pc33.atlanta.com
         ;branch=z9hG4bK776asdhds ;received=192.0.2.1
      To: Bob <sip:bob@biloxi.com>;tag=a6c85cf
      From: Alice <sip:alice@atlanta.com>;tag=1928301774
      Call-ID: a84b4c76e66710@pc33.atlanta.com
      CSeq: 314159 INVITE
      Contact: <sip:bob@192.0.2.4>
      Content-Type: application/sdp
      Content-Length: 131

      (Bob's SDP not shown)
```

응답의 첫 번째 줄에는 응답 코드\(200\)와 이유 문구\(OK\)가 포함됩니다. 나머지 줄에는 헤더 필드가 포함되어 있습니다. Via, To, From, Call-ID 및 CSeq 헤더 필드는 INVITE 요청에서 복사됩니다. \(세 개의 Via 헤더 필드 값이 있습니다. 하나는 Alice의 SIP 전화에 의해 추가되고, 하나는 atlanta.com 프록시에 의해 추가되고, 다른 하나는 biloxi.com 프록시에 의해 추가됩니다.\) Bob의 SIP 전화는 To 헤더 필드에 태그 매개변수를 추가했습니다. 이 태그는 두 엔드포인트 모두에 의해 대화 상자에 통합되며 향후 모든 엔드포인트에 포함됩니다.

이 통화의 요청 및 응답입니다. 연락처 헤더 필드에는 Bob이 SIP 전화에서 직접 연결할 수 있는 URI가 포함되어 있습니다. Content-Type 및 Content-Length는 Bob의 SDP 미디어 정보가 포함된 메시지 본문\(표시되지 않음\)을 나타냅니다.

이 예에 표시된 DNS 및 위치 서비스 조회 외에도 프록시 서버는 요청을 보낼 위치를 결정하기 위해 유연한 "라우팅 결정"을 내릴 수 있습니다. 예를 들어 Bob의 SIP 전화가 486\(Busy Here\) 응답을 반환한 경우 biloxi.com 프록시 서버는 INVITE를 Bob의 음성 메일 서버로 프록시할 수 있습니다. 프록시 서버는 동시에 여러 위치에 INVITE를 보낼 수도 있습니다. 이러한 유형의 병렬 검색을 분기라고 합니다.

이 경우 200\(OK\)은 두 프록시를 통해 다시 라우팅되고 Alice의 소프트폰에 수신됩니다. 그러면 통화 연결음이 중지되고 전화에 응답했음을 나타냅니다. 마지막으로 Alice의 소프트폰은 승인 메시지인 ACK를 Bob의 SIP 전화기로 보내 최종 응답\(200\(OK\)\) 수신을 확인합니다. 이 예에서 ACK는 두 프록시를 우회하여 Alice의 소프트폰에서 Bob의 SIP 전화로 직접 전송됩니다. 이는 엔드포인트가 INVITE/200\(OK\) 교환을 통해 연락처 헤더 필드에서 서로의 주소를 학습했기 때문에 발생하며 이는 초기 INVITE가 전송될 때 알려지지 않았습니다. 두 프록시에 의해 수행된 조회는 더 이상 필요하지 않으므로 프록시는 호출 흐름에서 제외됩니다. 이로써 SIP 세션을 설정하는 데 사용되는 INVITE/200/ACK 3방향 핸드셰이크가 완료됩니다. 세션 설정에 대한 자세한 내용은 섹션 13에 나와 있습니다.

이제 Alice와 Bob의 미디어 세션이 시작되었으며 그들은 SDP 교환에서 동의한 형식을 사용하여 미디어 패킷을 보냅니다. 일반적으로 종단 간 미디어 패킷은 SIP 신호 메시지와 다른 경로를 사용합니다.

세션 중에 Alice나 Bob은 미디어 세션의 특성을 변경하기로 결정할 수 있습니다. 이는 새 미디어 설명이 포함된 re-INVITE를 전송하여 수행됩니다. re-INVITE는 기존 대화를 참조하여 상대방이 새 세션을 설정하는 대신 기존 세션을 수정한다는 것을 알 수 있도록 합니다. 상대방은 변경 사항을 수락하기 위해 200\(OK\)을 보냅니다. 요청자는 ACK로 200\(OK\)에 응답합니다. 상대방이 변경 사항을 수락하지 않으면 488\(여기에서는 허용되지 않음\)과 같은 오류 응답을 보내고 ACK도 받습니다. 그러나 re-INVITE 실패로 인해 기존 호출이 실패하지는 않습니다. 세션은 이전에 협상된 특성을 사용하여 계속됩니다. 세션 수정에 대한 자세한 내용은 섹션 14에 나와 있습니다.

통화가 끝나면 Bob은 먼저 연결을 끊고\(전화를 끊고\) BYE 메시지를 생성합니다. 이 BYE는 다시 프록시를 우회하여 Alice의 소프트폰으로 직접 라우팅됩니다. Alice는 200\(OK\) 응답으로 BYE 수신을 확인하고 세션과 BYE 트랜잭션을 종료합니다. ACK가 전송되지 않습니다. ACK는 INVITE 요청에 대한 응답으로만 전송됩니다. INVITE를 특별하게 처리하는 이유는 나중에 설명하겠지만 SIP의 신뢰성 메커니즘, 벨이 울리는 전화에 응답하는 데 걸리는 시간 및 분기와 관련이 있습니다. 이러한 이유로 SIP의 요청 처리는 INVITE 이외의 다른 모든 방법을 참조하여 INVITE 또는 비INVITE로 분류되는 경우가 많습니다. 세션 종료에 대한 자세한 내용은 섹션 15에 나와 있습니다.

섹션 24.2에서는 그림 1에 표시된 메시지를 전체적으로 설명합니다.

어떤 경우에는 SIP 신호 경로의 프록시가 세션 기간 동안 엔드포인트 간의 모든 메시징을 보는 것이 유용할 수 있습니다. 예를 들어, biloxi.com 프록시 서버가 초기 INVITE 이후 SIP 메시징 경로에 남아 있기를 원하는 경우 호스트 이름 또는 IP 주소로 확인되는 URI가 포함된 Record-Route라는 필수 라우팅 헤더 필드를 INVITE에 추가합니다. 프록시의. 이 정보는 Bob의 SIP 전화와 \(Record-Route 헤더 필드가 200\(OK\)로 다시 전달되기 때문에\) Alice의 소프트폰 모두에 의해 수신되고 대화 기간 동안 저장됩니다. 그런 다음 biloxi.com 프록시 서버는 ACK, BYE 및 200\(OK\)을 수신하여 BYE로 프록시합니다. 각 프록시는 독립적으로 후속 메시지 수신을 결정할 수 있으며 해당 메시지는 해당 메시지를 수신하기로 선택한 모든 프록시를 통과합니다. 이 기능은 통화 중간 기능을 제공하는 프록시에 자주 사용됩니다.

등록은 SIP의 또 다른 일반적인 작업입니다. 등록은 biloxi.com 서버가 Bob의 현재 위치를 알 수 있는 한 가지 방법입니다. 초기화 시, 그리고 정기적인 간격으로 Bob의 SIP 전화는 SIP 등록자로 알려진 biloxi.com 도메인의 서버에 REGISTER 메시지를 보냅니다. REGISTER 메시지는 Bob의 SIP 또는 SIPS URI\(sip:bob@biloxi.com\)를 Bob이 현재 로그인되어 있는 컴퓨터\(연락처 헤더 필드에 SIP 또는 SIPS URI로 전달됨\)와 연결합니다. 등록 기관은 바인딩이라고도 하는 이 연결을 위치 서비스라고 하는 데이터베이스에 기록합니다. 이 연결은 biloxi.com 도메인의 프록시에서 사용할 수 있습니다. 도메인의 등록 서버가 해당 도메인의 프록시와 같은 위치에 있는 경우가 많습니다. SIP 서버 유형 간의 구별은 물리적이지 않고 논리적이라는 것이 중요한 개념입니다.

Bob은 단일 장치에서만 등록할 수 있는 것으로 제한되지 않습니다. 예를 들어 집에 있는 SIP 전화와 사무실에 있는 SIP 전화 모두 등록을 보낼 수 있습니다. 이 정보는 다음 위치에 함께 저장됩니다.

서비스를 제공하며 프록시가 Bob을 찾기 위해 다양한 유형의 검색을 수행할 수 있도록 합니다. 마찬가지로, 하나의 장치에 동시에 두 명 이상의 사용자를 등록할 수 있습니다.

위치 서비스는 추상적인 개념일 뿐이다. 여기에는 일반적으로 프록시가 URI를 입력하고 프록시에게 요청을 보낼 위치를 알려주는 0개 이상의 URI 집합을 수신할 수 있도록 하는 정보가 포함되어 있습니다. 등록은 이 정보를 생성하는 한 가지 방법이지만 유일한 방법은 아닙니다. 관리자의 재량에 따라 임의의 매핑 기능을 구성할 수 있습니다.

마지막으로, SIP에서 등록은 들어오는 SIP 요청을 라우팅하는 데 사용되며 나가는 요청을 승인하는 역할은 없다는 점에 유의하는 것이 중요합니다. 권한 부여 및 인증은 챌린지/응답 메커니즘을 사용하여 요청별로 또는 섹션 26에 설명된 하위 계층 체계를 사용하여 SIP에서 처리됩니다.

이 등록 예제에 대한 전체 SIP 메시지 세부 정보는 섹션 24.1에 있습니다.

OPTIONS를 사용하여 SIP 서버 또는 클라이언트의 기능을 쿼리하거나 CANCEL을 사용하여 보류 중인 요청을 취소하는 등 SIP의 추가 작업은 이후 섹션에서 소개됩니다.

---
# **5 Structure of the Protocol**

SIP는 계층화된 프로토콜로 구성됩니다. 즉, SIP의 동작은 각 단계 간의 느슨한 결합만 포함하는 상당히 독립적인 처리 단계 세트의 측면에서 설명됩니다. 프로토콜 동작은 프레젠테이션 목적으로 레이어로 설명되어 단일 섹션의 요소 전체에 공통적인 기능을 설명할 수 있습니다. 어떤 식으로든 구현을 지시하지는 않습니다. 요소가 레이어를 "포함"한다고 말하는 것은 해당 요소가 해당 레이어에서 정의한 일련의 규칙을 준수한다는 의미입니다.

프로토콜에 의해 지정된 모든 요소가 모든 레이어를 포함하는 것은 아닙니다. 또한 SIP에서 지정하는 요소는 물리적 요소가 아닌 논리적 요소입니다. 물리적 실현은 트랜잭션별로 다른 논리적 요소로 작동하도록 선택할 수 있습니다.

SIP의 가장 낮은 계층은 구문과 인코딩입니다. 해당 인코딩은 보강된 Backus-Naur Form 문법\(BNF\)을 사용하여 지정됩니다. 완전한 BNF는 섹션 25에 명시되어 있습니다. SIP 메시지 구조의 개요는 섹션 7에서 확인할 수 있습니다.

두 번째 계층은 전송 계층입니다. 클라이언트가 요청을 보내고 응답을 받는 방법과 서버가 요청을 받고 네트워크를 통해 응답을 보내는 방법을 정의합니다. 모든 SIP 요소에는 전송 계층이 포함되어 있습니다. 전송 계층은 섹션 18에 설명되어 있습니다.

세 번째 계층은 트랜잭션 계층입니다. 트랜잭션은 SIP의 기본 구성 요소입니다. 트랜잭션은 클라이언트 트랜잭션\(전송 계층 사용\)이 서버 트랜잭션으로 보낸 요청이며, 서버 트랜잭션에서 다시 클라이언트로 보낸 해당 요청에 대한 모든 응답입니다. 트랜잭션 계층은 애플리케이션 계층 재전송, 요청에 대한 응답 일치 및 애플리케이션 계층 시간 초과를 처리합니다. UAC\(사용자 에이전트 클라이언트\)가 수행하는 모든 작업은 일련의 트랜잭션을 사용하여 수행됩니다. 트랜잭션에 대한 논의는 섹션 17에서 찾을 수 있습니다. 사용자 에이전트는 상태 저장 프록시와 마찬가지로 트랜잭션 계층을 포함합니다. 상태 비저장 프록시에는 트랜잭션 계층이 포함되어 있지 않습니다. 트랜잭션 계층에는 클라이언트 구성 요소\(클라이언트 트랜잭션이라고 함\)와 서버 구성 요소\(서버 트랜잭션이라고 함\)가 있으며, 각 구성 요소는 특정 요청을 처리하도록 구성된 유한 상태 머신으로 표시됩니다.

트랜잭션 계층 위의 계층을 트랜잭션 사용자\(TU\)라고 합니다. 상태 비저장 프록시를 제외한 각 SIP 엔터티는 트랜잭션 사용자입니다. TU가 요청을 보내려고 할 때 클라이언트 트랜잭션 인스턴스를 생성하고 요청을 보낼 대상 IP 주소, 포트 및 전송과 함께 요청을 전달합니다. 클라이언트 트랜잭션을 생성한 TU는 이를 취소할 수도 있습니다. 클라이언트가 트랜잭션을 취소하면 서버에 추가 처리를 중지하고 트랜잭션이 시작되기 전의 상태로 되돌리고 해당 트랜잭션에 대한 특정 오류 응답을 생성하도록 요청합니다. 이는 자체 트랜잭션을 구성하지만 취소할 트랜잭션을 참조하는 CANCEL 요청을 통해 수행됩니다\(섹션 9\).

SIP 요소, 즉 사용자 에이전트 클라이언트 및 서버, 상태 비저장 및 상태 저장 프록시 및 등록자는 서로를 구별하는 핵심을 포함합니다. 상태 비저장 프록시를 제외한 코어는 트랜잭션 사용자입니다. UAC 및 UAS 코어의 동작은 방법에 따라 다르지만 모든 방법에 대한 몇 가지 공통 규칙이 있습니다\(섹션 8\). UAC의 경우 이러한 규칙이 요청 구성에 적용됩니다. UAS의 경우 요청 처리 및 응답 생성을 관리합니다. 등록은 SIP에서 중요한 역할을 하기 때문에 REGISTER를 처리하는 UAS에는 등록자라는 특수 이름이 부여됩니다. 섹션 10에서는 REGISTER 메서드에 대한 UAC 및 UAS 핵심 동작을 설명합니다. 섹션 11에서는 UA의 기능을 결정하는 데 사용되는 OPTIONS 방법에 대한 UAC 및 UAS 핵심 동작을 설명합니다.

특정 다른 요청은 대화 상자 내에서 전송됩니다. 대화는 한동안 지속되는 두 사용자 에이전트 간의 P2P SIP 관계입니다. 대화 상자는 메시지 순서 지정과 사용자 에이전트 간 요청의 적절한 라우팅을 용이하게 합니다. INVITE 메소드는 이 사양에서 대화 상자를 설정하기 위해 정의된 유일한 방법입니다. UAC가 대화 컨텍스트 내에서 요청을 보낼 때 섹션 8에 설명된 일반적인 UAC 규칙뿐만 아니라 중간 대화 요청에 대한 규칙도 따릅니다. 섹션 12에서는 대화 상자에 대해 논의하고 대화 상자 내의 요청 구성 외에도 구성 및 유지 관리 절차를 제시합니다.

SIP에서 가장 중요한 방법은 참여자 간 세션을 설정하는 데 사용되는 INVITE 방법입니다. 세션은 의사소통을 목적으로 하는 참가자들의 집합이자 그들 사이의 미디어 스트림입니다. 섹션 13에서는 세션이 시작되어 하나 이상의 SIP 대화 상자가 나타나는 방법에 대해 설명합니다. 섹션 14에서는 대화 내에서 INVITE 요청을 사용하여 해당 세션의 특성을 수정하는 방법을 설명합니다. 마지막으로 섹션 15에서는 세션이 종료되는 방법에 대해 설명합니다.

섹션 8, 10, 11, 12, 13, 14 및 15의 절차는 전적으로 UA 코어를 다룹니다\(섹션 9에서는 UA 코어와 프록시 코어 모두에 적용되는 취소에 대해 설명합니다\). 섹션 16에서는 사용자 에이전트 간의 메시지 라우팅을 용이하게 하는 프록시 요소에 대해 설명합니다.

---
# **6 Definitions**

다음 용어는 SIP에 특별한 의미를 갖습니다.

- 레코드 주소: AOR\(레코드 주소\)은 사용자가 사용할 수 있는 다른 URI에 URI를 매핑할 수 있는 위치 서비스가 있는 도메인을 가리키는 SIP 또는 SIPS URI입니다. 일반적으로 위치 서비스는 등록을 통해 채워집니다. AOR은 종종 사용자의 "공개 주소"로 간주됩니다.

- 연속 사용자 에이전트\(Back-to-Back User Agent\): B2BUA\(Back-to-Back User Agent\)는 요청을 수신하고 이를 UAS\(사용자 에이전트 서버\)로 처리하는 논리적 개체입니다. 요청에 응답하는 방법을 결정하기 위해 UAC\(사용자 에이전트 클라이언트\) 역할을 하며 요청을 생성합니다. 프록시 서버와 달리 대화 상자 상태를 유지하며 설정된 대화 상자에 전송된 모든 요청에 ​​참여해야 합니다. 이는 UAC와 UAS의 연결이므로 해당 동작에 대한 명시적인 정의가 필요하지 않습니다.

- 통화: 통화는 일반적으로 멀티미디어 대화를 목적으로 설정된 피어 간의 통신을 나타내는 비공식적 용어입니다.

- Call Leg: 대화 상자의 또 다른 이름\[31\]; 이 사양에서는 더 이상 사용되지 않습니다.

- 통화 상태 저장: 시작 INVITE부터 종료 BYE 요청까지 대화 상태를 유지하는 경우 프록시는 통화 상태 저장입니다. 통화 상태 저장 프록시는 항상 트랜잭션 상태 저장이지만 그 반대가 반드시 사실인 것은 아닙니다.

- 클라이언트: 클라이언트는 SIP 요청을 보내고 SIP 응답을 받는 네트워크 요소입니다. 클라이언트는 인간 사용자와 직접 상호 작용할 수도 있고 그렇지 않을 수도 있습니다. 사용자 에이전트 클라이언트와 프록시는 클라이언트입니다.

- 회의: 여러 참가자가 포함된 멀티미디어 세션\(아래 참조\)입니다.

- 코어: 코어는 특정 유형의 SIP 엔터티, 즉 상태 저장 또는 상태 비저장 프록시, 사용자 에이전트 또는 등록자에 특정한 기능을 지정합니다. 상태 비저장 프록시를 제외한 모든 코어는 트랜잭션 사용자입니다.

- 대화: 대화는 일정 시간 동안 지속되는 두 UA 간의 P2P SIP 관계입니다. 대화 상자는 INVITE 요청에 대한 2xx 응답과 같은 SIP 메시지에 의해 설정됩니다. 대화는 호출 식별자, 로컬 태그 및 원격 태그로 식별됩니다. 이전에는 RFC 2543에서 대화를 호출 레그\(call Leg\)라고 했습니다.

- 다운스트림: 사용자 에이전트 클라이언트에서 사용자 에이전트 서버로의 요청 흐름 방향을 나타내는 트랜잭션 내 메시지 전달 방향입니다.

- 최종 응답: SIP 트랜잭션을 종료하지 않는 임시 응답과 달리 SIP 트랜잭션을 종료하는 응답입니다. 모든 2xx, 3xx, 4xx, 5xx 및 6xx 응답은 최종 응답입니다.

- 헤더: 헤더는 메시지에 대한 정보를 전달하는 SIP 메시지의 구성 요소입니다. 이는 일련의 헤더 필드로 구성됩니다.

- 헤더 필드: 헤더 필드는 SIP 메시지 헤더의 구성 요소입니다. 헤더 필드는 하나 이상의 헤더 필드 행으로 나타날 수 있습니다. 헤더 필드 행은 헤더 필드 이름과 0개 이상의 헤더 필드 값으로 구성됩니다. 여러 헤더 필드 값

- 주어진 헤더 필드 행은 쉼표로 구분됩니다. 일부 헤더 필드는 단일 헤더 필드 값만 가질 수 있으며 결과적으로 항상 단일 헤더 필드 행으로 표시됩니다.

- 헤더 필드 값: 헤더 필드 값은 단일 값입니다. 헤더 필드는 0개 이상의 헤더 필드 값으로 구성됩니다.

홈 도메인: SIP 사용자에게 서비스를 제공하는 도메인입니다.

- 일반적으로 이는 등록 레코드 주소의 URI에 있는 도메인입니다.

- 정보응답: 잠정응답과 동일합니다.

- 개시자, 발신자, 발신자: INVITE 요청으로 세션\(및 대화\)을 시작하는 당사자입니다. 호출자는 대화를 설정한 초기 INVITE를 보낸 시점부터 해당 대화가 종료될 때까지 이 역할을 유지합니다.

- 초대: INVITE 요청입니다.

- 초대 대상자, 초대 사용자, 수신자, 수신자: 새로운 세션을 생성하기 위해 INVITE 요청을 받은 당사자입니다. 호출 수신자는 INVITE를 수신한 시점부터 해당 INVITE에 의해 설정된 대화가 종료될 때까지 이 역할을 유지합니다.

- 위치 서비스: 위치 서비스는 SIP 리디렉션 또는 프록시 서버에서 수신자의 가능한 위치에 대한 정보를 얻는 데 사용됩니다. 여기에는 0개 이상의 연락처 주소에 대한 레코드 주소 키 바인딩 목록이 포함되어 있습니다. 바인딩은 다양한 방법으로 생성하고 제거할 수 있습니다. 이 사양은 바인딩을 업데이트하는 REGISTER 메서드를 정의합니다.

- 루프: 프록시에 도착하여 전달되고 나중에 동일한 프록시에 다시 도착하는 요청입니다. 두 번째로 도착하면 해당 요청-URI는 처음과 동일하고 프록시 작업에 영향을 미치는 기타 헤더 필드는 변경되지 않으므로 프록시는 처음에 요청한 요청에 대해 동일한 처리 결정을 내립니다. 반복되는 요청은 오류이며 이를 감지하고 처리하는 절차는 프로토콜에 설명되어 있습니다.

- 느슨한 라우팅\(Loose Routing\): 프록시가 Route 헤더 필드 처리를 위해 본 사양에 정의된 절차를 따르는 경우 프록시는 느슨한 라우팅이라고 합니다. 이러한 절차는 요청 대상\(Request-URI에 있음\)을 다음과 구분합니다.

- 도중에 방문해야 하는 프록시 세트\(경로 헤더 필드에 있음\) 이러한 메커니즘을 준수하는 프록시를 느슨한 라우터라고도 합니다.

- 메시지: 프로토콜의 일부로 SIP 요소 간에 전송되는 데이터입니다. SIP 메시지는 요청이거나 응답입니다.

- 메소드: 메소드는 요청이 서버에서 호출되는 기본 기능입니다. 메소드는 요청 메시지 자체에 포함됩니다. 예제 메소드는 INVITE 및 BYE입니다.

- 아웃바운드 프록시: 요청-URI에 의해 해결된 서버가 아닐지라도 클라이언트로부터 요청을 받는 프록시입니다. 일반적으로 UA는 아웃바운드 프록시를 사용하여 수동으로 구성되거나 자동 구성 프로토콜을 통해 이에 대해 학습할 수 있습니다.

- 병렬 검색: 병렬 검색에서는 프록시가 들어오는 요청을 받으면 가능한 사용자 위치에 여러 요청을 보냅니다. 병렬 검색은 하나의 요청을 발행한 후 다음 요청을 발행하기 전에 최종 응답을 기다리는 순차적 검색과 달리 이전 요청의 결과를 기다리지 않고 요청을 발행합니다.

- 임시 응답: 진행 상황을 나타내기 위해 서버에서 사용하는 응답이지만 SIP 트랜잭션을 종료하지는 않습니다. 1xx 응답은 잠정적이며 다른 응답은 최종 응답으로 간주됩니다.

- 프록시, 프록시 서버: 다른 클라이언트를 대신하여 요청을 수행할 목적으로 서버와 클라이언트 역할을 모두 수행하는 중개 개체입니다. 프록시 서버는 주로 라우팅 역할을 합니다. 즉, 해당 작업은 요청이 대상 사용자에게 "가까운" 다른 엔터티로 전송되도록 하는 것입니다. 프록시는 정책을 시행하는 데도 유용합니다\(예: 사용자가 전화를 걸 수 있는지 확인\). 프록시는 요청 메시지를 전달하기 전에 요청 메시지의 특정 부분을 해석하고 필요한 경우 다시 작성합니다.

- 재귀: 클라이언트는 응답의 연락처 헤더 필드에 있는 하나 이상의 URI에 대한 새 요청을 생성할 때 3xx 응답에서 재귀합니다.

- 리디렉션 서버: 리디렉션 서버는 수신한 요청에 대해 3xx 응답을 생성하여 클라이언트가 대체 URI 세트에 연결하도록 지시하는 사용자 에이전트 서버입니다.

- 등록 기관: 등록 기관은 REGISTER 요청을 수락하고 해당 요청에서 받은 정보를 자신이 처리하는 도메인의 위치 서비스에 배치하는 서버입니다.

- 일반 트랜잭션: 일반 트랜잭션은 INVITE, ACK, CANCEL 이외의 방법으로 수행되는 모든 트랜잭션을 의미합니다.

- 요청: 특정 작업을 호출할 목적으로 클라이언트에서 서버로 전송되는 SIP 메시지입니다.

- 응답: 클라이언트에서 서버로 보낸 요청의 상태를 나타내기 위해 서버에서 클라이언트로 보낸 SIP 메시지입니다.

- 링백\(Ringback\): 링백\(Ringback\)은 발신자에게 알림\(벨이 울림\)이 발생했음을 나타내는 발신자의 애플리케이션에서 생성되는 신호음입니다.

- 경로 세트: 경로 세트는 특정 요청을 보낼 때 통과해야 하는 프록시 목록을 나타내는 순서가 지정된 SIP 또는 SIPS URI의 모음입니다. 경로 세트는 Record-Route와 같은 헤더를 통해 학습하거나 구성할 수 있습니다.

- 서버: 서버는 서비스를 제공하기 위해 요청을 수신하고 해당 요청에 대한 응답을 다시 보내는 네트워크 요소입니다. 서버의 예로는 프록시, 사용자 에이전트 서버, 리디렉션 서버 및 등록 기관이 있습니다.

- 순차 검색: 순차 검색에서는 프록시 서버가 각 연락처 주소를 순차적으로 시도하고 이전 주소가 최종 응답을 생성한 후에만 다음 주소로 진행합니다. 2xx 또는 6xx 클래스 최종 응답은 항상 순차 검색을 종료합니다.

- 세션: SDP 사양에서: "멀티미디어 세션은 멀티미디어 발신자와 수신자의 집합이며 발신자에서 수신자로 흐르는 데이터 스트림입니다. 멀티미디어 회의는 멀티미디어 세션의 예입니다." \(RFC 2327 \[1\]\) \(SDP에 대해 정의된 세션은 하나 이상의 RTP 세션으로 구성될 수 있습니다.\) 정의된 대로 수신자는 서로 다른 통화를 통해 동일한 세션에 여러 번 초대될 수 있습니다. SDP를 사용하는 경우 세션은 SDP 사용자 이름, 세션 ID, 네트워크 유형, 주소 유형 및 원본 필드의 주소 요소를 연결하여 정의됩니다.

- SIP 트랜잭션: SIP 트랜잭션은 클라이언트와 서버 간에 발생하며 클라이언트에서 서버로 전송된 첫 번째 요청부터 최종\(1xx가 아닌\) 응답까지 모든 메시지로 구성됩니다.

- 서버에서 클라이언트로 전송됩니다. 요청이 INVITE이고 최종 응답이 2xx가 아닌 경우 트랜잭션에는 응답에 대한 ACK도 포함됩니다. INVITE 요청에 대한 2xx 응답에 대한 ACK는 별도의 트랜잭션입니다.

- 나선형: 나선형은 프록시로 라우팅되고 전달된 후 해당 프록시에 다시 도착하는 SIP 요청이지만 이번에는 원래 요청과 다른 처리 결정을 내리는 방식이 다릅니다. 일반적으로 이는 요청의 Request-URI가 이전 도착과 다르다는 것을 의미합니다. 나선형은 루프와 달리 오류 조건이 아닙니다. 이에 대한 일반적인 원인은 착신 전환입니다. 사용자가 joe@example.com으로 전화합니다. example.com 프록시는 이를 Joe의 PC로 전달하고 Joe의 PC는 이를 bob@example.com으로 전달합니다. 이 요청은 example.com 프록시로 다시 프록시됩니다. 그러나 이것은 루프가 아닙니다. 요청이 다른 사용자를 대상으로 하기 때문에 이는 나선형으로 간주되며 유효한 조건입니다.

- 상태 저장 프록시: 요청을 처리하는 동안 이 사양에 의해 정의된 클라이언트 및 서버 트랜잭션 상태 머신을 유지하는 논리적 개체로, 트랜잭션 상태 저장 프록시라고도 합니다. 상태 저장 프록시의 동작은 섹션 16에서 자세히 정의됩니다. \(트랜잭션\) 상태 저장 프록시는 호출 상태 저장 프록시와 동일하지 않습니다.

- Stateless Proxy: 요청을 처리할 때 본 사양에 정의된 클라이언트 또는 서버 트랜잭션 상태 머신을 유지하지 않는 논리적 개체입니다. 상태 비저장 프록시는 다운스트림으로 수신하는 모든 요청과 업스트림으로 수신하는 모든 응답을 전달합니다.

- 엄격한 라우팅: 프록시가 RFC 2543의 경로 처리 규칙과 이 RFC의 진행 중인 많은 이전 작업 버전을 따르는 경우 프록시는 엄격한 라우팅이라고 합니다. 이 규칙으로 인해 Route 헤더 필드가 있을 때 프록시가 Request-URI의 내용을 파기하게 되었습니다. 이 사양에서는 느슨한 라우팅 동작을 위해 엄격한 라우팅 동작을 사용하지 않습니다. 엄격한 라우팅을 수행하는 프록시는 엄격한 라우터라고도 합니다.

- 대상 새로 고침 요청: 대화 상자 내에서 전송되는 대상 새로 고침 요청은 대화 상자의 원격 대상을 수정할 수 있는 요청으로 정의됩니다.

- 트랜잭션 사용자\(TU\): 트랜잭션 계층 위에 있는 프로토콜 처리 계층입니다. 트랜잭션 사용자에는 UAC 코어, UAS 코어 및 프록시 코어가 포함됩니다.

- 업스트림: 사용자 에이전트 서버에서 다시 사용자 에이전트 클라이언트로 응답이 흐르는 방향을 나타내는 트랜잭션 내의 메시지 전달 방향입니다.

- URL 인코딩: RFC 2396, 섹션 2.4 \[5\]에 따라 인코딩된 문자열입니다.

- UAC\(사용자 에이전트 클라이언트\): 사용자 에이전트 클라이언트는 새 요청을 생성한 다음 클라이언트 트랜잭션 상태 기계를 사용하여 이를 보내는 논리적 엔터티입니다. UAC의 역할은 해당 트랜잭션 기간 동안에만 지속됩니다. 즉, 소프트웨어가 요청을 시작하면 해당 트랜잭션이 진행되는 동안 UAC 역할을 합니다. 나중에 요청을 받으면 해당 트랜잭션 처리를 위한 사용자 에이전트 서버의 역할을 맡습니다.

- UAC Core: 트랜잭션 및 전송 계층 위에 있는 UAC에 필요한 처리 기능 집합입니다.

- UAS\(사용자 에이전트 서버\): 사용자 에이전트 서버는 SIP 요청에 대한 응답을 생성하는 논리적 엔터티입니다. 응답은 요청을 수락, 거부 또는 리디렉션합니다. 이 역할은 해당 트랜잭션 기간 동안만 지속됩니다. 즉, 소프트웨어가 요청에 응답하면 해당 트랜잭션이 진행되는 동안 UAS 역할을 합니다. 나중에 요청을 생성하면 해당 트랜잭션 처리를 위한 사용자 에이전트 클라이언트의 역할을 맡습니다.

- UAS 코어: 트랜잭션 및 전송 계층 위에 있는 UAS에 필요한 처리 기능 집합입니다.

- 사용자 에이전트\(UA\): 사용자 에이전트 클라이언트와 사용자 에이전트 서버 역할을 모두 수행할 수 있는 논리적 개체입니다.

UAC와 UAS, 프록시 및 리디렉션 서버의 역할은 트랜잭션별로 정의됩니다. 예를 들어 통화를 시작하는 사용자 에이전트는 초기 INVITE 요청을 보낼 때 UAC 역할을 하고, 수신자로부터 BYE 요청을 받을 때 UAS 역할을 합니다. 마찬가지로 동일한 소프트웨어가 한 요청에 대한 프록시 서버 역할을 하고 다음 요청에 대한 리디렉션 서버 역할을 할 수 있습니다.

위에 정의된 프록시, 위치 및 등록 서버는 논리적 엔터티입니다. 구현에서는 이를 단일 애플리케이션으로 결합할 수 있습니다.\(MAY\)

---
# **7 SIP Messages**

SIP는 텍스트 기반 프로토콜이며 UTF-8 문자 집합\(RFC 2279 \[7\]\)을 사용합니다.

SIP 메시지는 클라이언트에서 서버로의 요청이거나 서버에서 클라이언트로의 응답입니다.

요청\(섹션 7.1\) 및 응답\(섹션 7.2\) 메시지는 모두 RFC 2822 \[3\]의 기본 형식을 사용합니다. 비록 구문이 문자 집합과 구문 세부 사항에서 다르지만 말입니다. \(예를 들어 SIP는 유효한 RFC 2822 헤더 필드가 아닌 헤더 필드를 허용합니다.\) 두 가지 메시지 유형 모두 시작 줄, 하나 이상의 헤더 필드, 헤더 필드의 끝을 나타내는 빈 줄 및 선택 사항으로 구성됩니다. 메시지 본문.

```text
         generic-message  =  start-line
                             *message-header
                             CRLF
                             [ message-body ]
         start-line       =  Request-Line / Status-Line
```

시작 라인, 각 메시지 헤더 라인 및 빈 라인은 CRLF\(캐리지 리턴 라인 피드 시퀀스\)로 종료되어야 합니다. 메시지 본문이 없더라도 빈 줄이 있어야 합니다.\(MUST, MUST\)

위의 문자 집합 차이를 제외하면 SIP의 메시지 및 헤더 필드 구문의 대부분은 HTTP/1.1과 동일합니다. 여기서 구문과 의미를 반복하는 대신 \[HX.Y\]를 사용하여 현재 HTTP/1.1 사양\(RFC 2616 \[8\]\)의 X.Y 섹션을 참조합니다.

그러나 SIP는 HTTP의 확장이 아닙니다.

---
## **7.1 Requests**

SIP 요청은 시작 라인에 대한 요청 라인을 가짐으로써 구별됩니다. 요청 라인에는 단일 공백\(SP\) 문자로 구분된 메서드 이름, 요청 URI 및 프로토콜 버전이 포함됩니다.

요청 라인은 CRLF로 끝납니다. 줄 끝 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다. 모든 요소에는 선형 공백\(LWS\)이 허용되지 않습니다.

```text
         Request-Line  =  Method SP Request-URI SP SIP-Version CRLF
```

- 방법: 이 사양은 연락처 정보 등록을 위한 REGISTER, 세션 설정을 위한 INVITE, ACK 및 CANCEL, 세션 종료를 위한 BYE, 서버의 기능에 대해 쿼리하는 OPTIONS 등 6가지 방법을 정의합니다. 표준 트랙 RFC에 문서화된 SIP 확장은 추가 방법을 정의할 수 있습니다.

- 요청-URI: 요청-URI는 섹션 19.1에 설명된 SIP 또는 SIPS URI 또는 ​​일반 URI\(RFC 2396 \[5\]\)입니다. 이 요청이 처리되는 사용자 또는 서비스를 나타냅니다. 요청-URI는 이스케이프되지 않은 공백이나 제어 문자를 포함해서는 안 되며 "<\>"로 묶어서는 안 됩니다.\(MUST NOT\)

- SIP 요소는 "sip" 및 "sips" 이외의 구성표를 사용하여 요청-URI를 지원할 수 있습니다\(예: RFC 2806 \[9\]의 "tel" URI 구성표\). SIP 요소는 임의의 메커니즘을 사용하여 비SIP URI를 변환할 수 있으며 이로 인해 SIP URI, SIPS URI 또는 ​​기타 체계가 생성될 수 있습니다.\(MAY, MAY\)

- SIP-버전: 요청 및 응답 메시지 모두 사용 중인 SIP 버전을 포함하며, 버전 순서, 규정 준수 요구 사항 및 관련 사항은 \[H3.1\]\(HTTP는 SIP로 대체, HTTP/1.1은 SIP/2.0으로 대체\)을 따릅니다. 버전 번호 업그레이드. 이 사양을 준수하려면 SIP 메시지를 보내는 애플리케이션에 "SIP/2.0"의 SIP 버전이 포함되어야 합니다. SIP 버전 문자열은 대소문자를 구분하지 않지만 구현에서는 대문자를 전송해야 합니다.\(MUST, MUST\)

- HTTP/1.1과 달리 SIP는 버전 번호를 리터럴 문자열로 처리합니다. 실제로는 아무런 차이가 없습니다.

---
## **7.2 Responses**

SIP 응답은 상태 표시줄을 시작 표시줄로 하여 요청과 구별됩니다. 상태 표시줄은 프로토콜 버전, 숫자 상태 코드, 관련 텍스트 문구로 구성되며 각 요소는 단일 SP 문자로 구분됩니다.

최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다.

```text
      Status-Line  =  SIP-Version SP Status-Code SP Reason-Phrase CRLF
```

상태 코드는 요청을 이해하고 만족시키려는 시도의 결과를 나타내는 3자리 정수 결과 코드입니다. Reason-Phrase는 상태 코드에 대한 간단한 텍스트 설명을 제공하기 위한 것입니다. Status-Code는 오토마타에서 사용하기 위한 반면 Reason-Phrase는 인간 사용자를 위한 것입니다. 클라이언트는 이유 문구를 검사하거나 표시할 필요가 없습니다.

이 사양은 이유 문구에 대한 특정 표현을 제안하지만 구현에서는 요청의 Accept-Language 헤더 필드에 표시된 언어 등의 다른 텍스트를 선택할 수 있습니다.\(MAY\)

상태 코드의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 이러한 이유로 100에서 199 사이의 상태 코드가 있는 응답은 "1xx 응답"이라고 하고, 200에서 299 사이의 상태 코드가 있는 응답은 "2xx 응답"이라고 합니다. SIP/2.0에서는 첫 번째 숫자에 6개의 값을 허용합니다.

```text
      1xx: Provisional -- request received, continuing to process the
           request;

      2xx: Success -- the action was successfully received, understood,
           and accepted;

      3xx: Redirection -- further action needs to be taken in order to
           complete the request;

      4xx: Client Error -- the request contains bad syntax or cannot be
           fulfilled at this server;

      5xx: Server Error -- the server failed to fulfill an apparently
           valid request;
```

- 6xx: 전역 실패 - 요청이 어떤 서버에서도 이행될 수 없습니다.

섹션 21에서는 이러한 클래스를 정의하고 개별 코드를 설명합니다.

---
## **7.3 Header Fields**

SIP 헤더 필드는 구문과 의미 모두에서 HTTP 헤더 필드와 유사합니다. 특히 SIP 헤더 필드는 메시지 헤더 구문의 \[H4.2\] 정의와 헤더 필드를 여러 줄로 확장하는 규칙을 따릅니다. 그러나 후자는 암시적 공백과 접기를 사용하여 HTTP에 지정됩니다. 이 사양은 RFC 2234 \[10\]을 따르며 문법의 필수 부분으로 명시적인 공백과 접기를 사용합니다.

\[H4.2\]는 또한 값이 쉼표로 구분된 목록인 동일한 필드 이름의 여러 헤더 필드를 하나의 헤더 필드로 결합할 수 있음을 지정합니다. 이는 SIP에도 적용되지만 문법이 다르기 때문에 구체적인 규칙이 다릅니다. 특히 문법이 다음 형식인 모든 SIP 헤더입니다.

```text
      header  =  "header-name" HCOLON header-value *(COMMA header-value)
```

동일한 이름의 헤더 필드를 쉼표로 구분된 목록으로 결합할 수 있습니다. 연락처 헤더 필드는 헤더 필드 값이 "\*"가 아닌 한 쉼표로 구분된 목록을 허용합니다.

---
### **7.3.1 Header Field Format**

헤더 필드는 RFC 2822 \[3\]의 섹션 2.2에 제공된 것과 동일한 일반 헤더 형식을 따릅니다. 각 헤더 필드는 필드 이름, 콜론\(":"\) 및 필드 값으로 구성됩니다.

```text
      field-name: field-value
```

섹션 25에 지정된 메시지 헤더의 공식 문법은 콜론 양쪽에 임의의 양의 공백을 허용합니다. 그러나 구현에서는 필드 이름과 콜론 사이에 공백을 피하고 콜론과 필드 값 사이에 단일 공백\(SP\)을 사용해야 합니다.

```text
      Subject:            lunch
      Subject      :      lunch
      Subject            :lunch
      Subject: lunch
```

따라서 위의 내용은 모두 유효하고 동일하지만 마지막 형식이 선호되는 형식입니다.

헤더 필드는 각 추가 줄 앞에 최소한 하나의 SP 또는 가로 탭\(HT\)을 추가하여 여러 줄로 확장할 수 있습니다. 줄 바꿈과 다음 줄 시작 부분의 공백은 단일 SP 문자로 처리됩니다. 따라서 다음은 동일합니다.

```text
      Subject: I know you're there, pick up the phone and talk to me!
      Subject: I know you're there,
               pick up the phone
               and talk to me!
```

필드 이름이 다른 헤더 필드의 상대적 순서는 중요하지 않습니다. 그러나 프록시 처리에 필요한 헤더 필드\(예: Via, Route, Record-Route, Proxy-Require, Max-Forwards 및 Proxy-Authorization\)는 빠른 구문 분석을 용이하게 하기 위해 메시지 상단에 표시되는 것이 좋습니다. . 필드 이름이 동일한 헤더 필드 행의 상대적 순서가 중요합니다. 동일한 field-name을 가진 여러 헤더 필드 행은 해당 헤더 필드의 전체 field-value가 쉼표로 구분된 목록으로 정의된 경우\(즉, 섹션 7.3에 정의된 문법을 따르는 경우\)에만 메시지에 존재할 수 있습니다. . 메시지의 의미를 변경하지 않고 여러 헤더 필드 행을 하나의 "필드-이름: 필드-값" 쌍으로 결합하는 것이 가능해야 하며, 각 후속 필드 값을 첫 번째 항목에 추가하고 각각을 쉼표로 구분해야 합니다. 이 규칙의 예외는 WWW-Authenticate, Authorization, Proxy-Authenticate 및 Proxy-Authorization 헤더 필드입니다. 다중 헤더\(SHOULD, MAY, MUST\)

이러한 이름을 가진 필드 행은 메시지에 존재할 수 있지만 해당 문법은 섹션 7.3에 나열된 일반 형식을 따르지 않으므로 단일 헤더 필드 행으로 결합해서는 안 됩니다.\(MUST NOT\)

구현은 줄당 단일 값 또는 쉼표로 구분된 값 형식의 조합에서 동일한 이름을 가진 여러 헤더 필드 행을 처리할 수 있어야 합니다\(MUST\).\(MUST\)

다음 헤더 필드 행 그룹은 유효하며 동일합니다.

```text
      Route: <sip:alice@atlanta.com>
      Subject: Lunch
      Route: <sip:bob@biloxi.com>
      Route: <sip:carol@chicago.com>

      Route: <sip:alice@atlanta.com>, <sip:bob@biloxi.com>
      Route: <sip:carol@chicago.com>
      Subject: Lunch

      Subject: Lunch
      Route: <sip:alice@atlanta.com>, <sip:bob@biloxi.com>,
             <sip:carol@chicago.com>
```

다음 각 블록은 유효하지만 다른 블록과 동일하지는 않습니다.

```text
      Route: <sip:alice@atlanta.com>
      Route: <sip:bob@biloxi.com>
      Route: <sip:carol@chicago.com>

      Route: <sip:bob@biloxi.com>
      Route: <sip:alice@atlanta.com>
      Route: <sip:carol@chicago.com>

      Route: <sip:alice@atlanta.com>,<sip:carol@chicago.com>,
             <sip:bob@biloxi.com>
```

헤더 필드 값의 형식은 헤더 이름별로 정의됩니다. 항상 TEXT-UTF8 옥텟의 불투명 시퀀스이거나 공백, 토큰, 구분 기호 및 인용 문자열의 조합입니다. 많은 기존 헤더 필드는 값 뒤에 세미콜론으로 구분된 매개변수-이름, 매개변수-값 쌍의 시퀀스가 ​​오는 일반적인 형식을 따릅니다.

```text
         field-name: field-value *(;parameter-name=parameter-value)
```

임의의 수의 매개변수 쌍이 헤더 필드 값에 첨부될 수 있더라도 주어진 매개변수 이름은 두 번 이상 나타나서는 안 됩니다.\(MUST NOT\)

헤더 필드를 비교할 때 필드 이름은 항상 대소문자를 구분하지 않습니다. 특정 헤더 필드의 정의에 달리 명시되지 않는 한, 필드 값, 매개변수 이름 및 매개변수 값은 대소문자를 구분하지 않습니다. 토큰은 항상 대소문자를 구분합니다. 달리 지정하지 않는 한, 따옴표로 묶인 문자열로 표현된 값은 대소문자를 구분합니다. 예를 들어,

```text
      Contact: <sip:alice@atlanta.com>;expires=3600
```

는 다음과 같습니다

```text
      CONTACT: <sip:alice@atlanta.com>;ExPiReS=3600

   and

      Content-Disposition: session;handling=optional
```

는 다음과 같습니다

```text
      content-disposition: Session;HANDLING=OPTIONAL
```

다음 두 헤더 필드는 동일하지 않습니다.

```text
      Warning: 370 devnull "Choose a bigger pipe"
      Warning: 370 devnull "CHOOSE A BIGGER PIPE"
```

---
### **7.3.2 Header Field Classification**

일부 헤더 필드는 요청이나 응답에서만 의미가 있습니다. 이를 각각 요청 헤더 필드와 응답 헤더 필드라고 합니다. 헤더 필드가 해당 카테고리\(예: 응답의 요청 헤더 필드\)와 일치하지 않는 메시지에 나타나면 무시해야 합니다. 섹션 20에서는 각 헤더 필드의 분류를 정의합니다.\(MUST\)

---
### **7.3.3 Compact Form**

SIP는 공통 헤더 필드 이름을 축약된 형식으로 나타내는 메커니즘을 제공합니다. 이는 메시지가 너무 커서 사용 가능한 전송을 통해 전달되지 않을 때 유용할 수 있습니다\(예를 들어 UDP를 사용할 때 최대 전송 단위\(MTU\)를 초과하는 경우\). 이러한 압축 형식은 섹션 20에 정의되어 있습니다. 메시지의 의미를 변경하지 않고 언제든지 헤더 필드 이름의 긴 형식을 압축 형식으로 대체할 수 있습니다. 헤더\(MAY\)

필드 이름은 동일한 메시지 내에서 긴 형식과 짧은 형식으로 모두 나타날 수 있습니다. 구현에서는 각 헤더 이름의 긴 형식과 짧은 형식을 모두 허용해야 합니다\(MUST\).\(MAY, MUST\)

---
## **7.4 Bodies**

이 사양의 확장에 정의된 새 요청을 포함한 요청에는 달리 명시되지 않는 한 메시지 본문이 포함될 수 있습니다. 본문의 해석은 요청 방법에 따라 다릅니다.\(MAY\)

응답 메시지의 경우 요청 방법과 응답 상태 코드에 따라 메시지 본문의 유형과 해석이 결정됩니다. 모든 응답에는 본문이 포함될 수 있습니다.\(MAY\)

---
### **7.4.1 Message Body Type**

메시지 본문의 인터넷 미디어 유형은 Content-Type 헤더 필드에 의해 제공되어야 합니다. 본문이 압축과 같은 인코딩을 거친 경우 이는 Content-Encoding 헤더 필드로 표시되어야 합니다. 그렇지 않으면 Content-Encoding을 생략해야 합니다. 해당되는 경우 메시지 본문의 문자 집합은 Content-Type 헤더 필드 값의 일부로 표시됩니다.\(MUST, MUST\)

RFC 2046 \[11\]에 정의된 "다중 부분" MIME 유형은 메시지 본문 내에서 사용될 수 있습니다. 멀티파트 메시지 본문을 포함하는 요청을 보내는 구현은 원격 구현이 멀티파트를 포함하지 않는 Accept 헤더 필드를 통해 이를 요청하는 경우 비멀티파트 메시지 본문으로 세션 설명을 보내야 합니다.\(MAY, MUST\)

SIP 메시지에는 바이너리 본문이나 본문 부분이 포함될 수 있습니다. 보낸 사람이 명시적인 charset 매개변수를 제공하지 않으면 "text" 유형의 미디어 하위 유형은 "UTF-8"의 기본 charset 값을 갖도록 정의됩니다.\(MAY\)

---
### **7.4.2 Message Body Length**

본문 길이\(바이트\)는 Content-Length 헤더 필드에서 제공됩니다. 20.14절에서는 이 헤더 필드에 필요한 내용을 자세히 설명합니다.

HTTP/1.1의 "청크" 전송 인코딩은 SIP에 사용되어서는 안 됩니다. \(참고: 청크 인코딩은 메시지 본문을 수정하여 각각 고유한 크기 표시기가 있는 일련의 청크로 전송합니다.\)\(MUST NOT\)

---
## **7.5 Framing SIP Messages**

HTTP와 달리 SIP 구현은 UDP 또는 기타 신뢰할 수 없는 데이터그램 프로토콜을 사용할 수 있습니다. 이러한 각 데이터그램은 하나의 요청 또는 응답을 전달합니다. 신뢰할 수 없는 전송 사용에 대한 제한 사항은 섹션 18을 참조하세요.

스트림 지향 전송을 통해 SIP 메시지를 처리하는 구현은 시작 라인 \[H4.1\] 앞에 나타나는 모든 CRLF를 무시해야 합니다.\(MUST\)

- Content-Length 헤더 필드 값은 스트림에서 각 SIP 메시지의 끝을 찾는 데 사용됩니다. SIP 메시지가 스트림 지향 전송을 통해 전송될 때 항상 존재합니다.

---
# **8 General User Agent Behavior**

사용자 에이전트는 최종 시스템을 나타냅니다. 여기에는 요청을 생성하는 사용자 에이전트 클라이언트\(UAC\)와 요청에 응답하는 사용자 에이전트 서버\(UAS\)가 포함됩니다. UAC는 외부 자극\(사용자가 버튼을 클릭하거나 PSTN 회선의 신호\)을 기반으로 요청을 생성하고 응답을 처리할 수 있습니다. UAS는 요청을 수신하고 사용자 입력, 외부 자극, 프로그램 실행 결과 또는 기타 메커니즘을 기반으로 응답을 생성할 수 있습니다.

UAC가 요청을 보내면 해당 요청은 여러 프록시 서버를 통과하여 UAS로 요청을 전달합니다. UAS가 응답을 생성하면 응답이 UAC로 전달됩니다.

UAC 및 UAS 절차는 두 가지 요소에 크게 좌우됩니다. 첫째, 요청 또는 응답이 대화 상자 내부인지 외부인지에 따라 결정되고, 두 번째는 요청 방법에 따라 결정됩니다. 대화 상자는 섹션 12에서 자세히 논의됩니다. 이는 사용자 에이전트 간의 P2P 관계를 나타내며 INVITE와 같은 특정 SIP 방법으로 설정됩니다.

이 섹션에서는 대화 상자 외부에 있는 요청을 처리할 때 UAC 및 UAS 동작에 대한 메서드 독립적 규칙에 대해 설명합니다. 물론 여기에는 자체적으로 대화를 설정하는 요청도 포함됩니다.

대화 상자 외부의 요청 및 응답에 대한 보안 절차는 섹션 26에 설명되어 있습니다. 특히 UAS와 UAC가 상호 인증을 위한 메커니즘이 존재합니다. S/MIME을 사용한 본문 암호화를 통해 제한된 개인 정보 보호 기능도 지원됩니다.

---
## **8.1 UAC Behavior**

이 섹션에서는 대화 상자 외부의 UAC 동작을 다룹니다.

---
### **8.1.1 Generating the Request**

UAC에 의해 공식화된 유효한 SIP 요청에는 최소한 To, From, CSeq, Call-ID, Max-Forwards 및 Via 헤더 필드가 포함되어야 합니다. 이러한 헤더 필드는 모두 모든 SIP 요청에서 필수입니다. 이 6개 헤더 필드는 메시지 주소 지정, 응답 라우팅, 메시지 전파 제한, 메시지 순서 지정, 메시지 고유 식별 등 대부분의 중요한 메시지 라우팅 서비스를 공동으로 제공하므로 SIP 메시지의 기본 구성 블록입니다. 업무. 이러한 헤더 필드는 메소드, 요청-URI 및 SIP 버전을 포함하는 필수 요청 라인에 추가됩니다.\(MUST\)

대화 외부에서 전송되는 요청의 예로는 세션을 설정하기 위한 INVITE\(섹션 13\) 및 기능을 쿼리하기 위한 OPTIONS\(섹션 11\)가 있습니다.

---
#### **8.1.1.1 Request-URI**

메시지의 초기 Request-URI는 To 필드의 URI 값으로 설정되어야 합니다. 주목할만한 예외 중 하나는 REGISTER 메서드입니다. REGISTER의 Request-URI를 설정하는 동작은 섹션 10에 나와 있습니다. 또한 이러한 필드를 동일한 값으로 설정하는 것은 개인 정보 보호나 편의상 바람직하지 않을 수도 있습니다\(특히 발신 UA가 전송 중에 Request-URI가 변경될 것으로 예상하는 경우\). \).\(SHOULD\)

일부 특별한 상황에서는 기존 경로 세트가 있으면 메시지의 요청-URI에 영향을 미칠 수 있습니다. 기존 경로 세트는 UAC가 대화 외부에 있는 나가는 요청을 보내는 서버 체인을 식별하는 순서가 지정된 URI 세트입니다. 일반적으로 사용자나 서비스 공급자가 수동으로 또는 기타 SIP가 아닌 메커니즘을 통해 UA에서 구성합니다. 공급자가 아웃바운드 프록시로 UA를 구성하려는 경우 아웃바운드 프록시의 단일 URI로 설정된 기존 경로를 제공하여 이를 수행하는 것이 권장됩니다.\(SHOULD\)

기존 경로 세트가 있는 경우 원하는 Request-URI를 원격 대상으로 사용하여 섹션 12.2.1.1에 자세히 설명된 Request-URI 및 Route 헤더 필드를 채우는 절차를 따라야 합니다\(대화 상자가 없더라도\). URI.\(MUST\)

---
#### **8.1.1.2 To**

To 헤더 필드는 무엇보다도 요청의 원하는 "논리적" 수신자 또는 이 요청의 대상인 사용자 또는 리소스의 레코드 주소를 지정합니다. 이는 요청의 최종 수신자일 수도 있고 아닐 수도 있습니다. To 헤더 필드에는 SIP 또는 SIPS URI가 포함될 수 있지만 적절한 경우 다른 URI 체계\(예: 전화 URL\(RFC 2806 \[9\]\)\)를 사용할 수도 있습니다. 모든 SIP 구현은 SIP URI 체계를 지원해야 합니다. TLS를 지원하는 모든 구현은 SIPS URI 체계를 지원해야 합니다. To 헤더 필드에는 표시 이름이 허용됩니다.\(MAY, MUST, MUST\)

UAC는 다양한 방법으로 특정 요청에 대한 To 헤더 필드를 채우는 방법을 학습할 수 있습니다. 일반적으로 사용자는 수동으로 URI를 입력하거나 일종의 주소록에서 선택하는 등 휴먼 인터페이스를 통해 To 헤더 필드를 제안합니다. 사용자는 완전한 URI를 입력하지 않고 숫자나 문자로 구성된 문자열\(예: "bob"\)을 입력하는 경우가 많습니다. 이 입력을 해석하는 방법을 선택하는 것은 UA의 재량입니다. 문자열을 사용하여 SIP URI의 사용자 부분을 형성한다는 것은 UA가 도메인에서 SIP URI의 at 기호 오른쪽\(RHS\)에 있는 이름을 확인하기를 원한다는 것을 의미합니다\(예: sip:bob\). @example.com\). 문자열을 사용하여 SIPS URI의 사용자 부분을 형성한다는 것은 UA가 안전하게 통신하기를 원하며 이름이 도메인에서 at-sign의 RHS로 확인되어야 함을 의미합니다. RHS는 요청자의 홈 도메인이 되는 경우가 많으므로 홈 도메인이 나가는 요청을 처리할 수 있습니다. 이는 홈 도메인의 사용자 부분을 해석해야 하는 "단축 다이얼"과 같은 기능에 유용합니다. 전화 URL은 UA가 사용자가 입력한 전화번호를 해석해야 하는 도메인을 지정하고 싶지 않을 때 사용될 수 있습니다. 오히려 요청이 통과하는 각 도메인에 해당 기회가 제공됩니다. 예를 들어, 공항에 있는 사용자가 로그인하여 공항의 아웃바운드 프록시를 통해 요청을 보낼 수 있습니다. "411"\(미국 내 지역 안내 전화번호\)을 입력하면 사용자의 홈 도메인이 아닌 공항에 있는 아웃바운드 프록시가 이를 해석하고 처리해야 합니다. 이 경우 tel:411이 올바른 선택입니다.

대화 상자 외부의 요청에는 To 태그가 포함되어서는 안 됩니다. 요청의 To 필드에 있는 태그는 대화의 피어를 식별합니다. 대화 상자가 설정되지 않았으므로 태그가 없습니다.\(MUST NOT\)

To 헤더 필드에 대한 자세한 내용은 섹션 20.39를 참조하세요. 다음은 유효한 To 헤더 필드의 예입니다.

```text
      To: Carol <sip:carol@chicago.com>
```

---
#### **8.1.1.3 From**

From 헤더 필드는 요청 개시자의 논리적 ID, 즉 사용자의 레코드 주소를 나타냅니다. To 헤더 필드와 마찬가지로 여기에는 URI와 선택적으로 표시 이름이 포함됩니다. 이는 요청에 적용할 처리 규칙\(예: 자동 통화 거부\)을 결정하기 위해 SIP 요소에서 사용됩니다. 따라서 From URI에는 UA가 실행 중인 호스트의 IP 주소나 FQDN이 포함되지 않는 것이 매우 중요합니다. 이는 논리적 이름이 아니기 때문입니다.

From 헤더 필드에는 표시 이름이 허용됩니다. UAC는 클라이언트의 ID를 숨긴 상태로 유지하려는 경우 구문적으로는 정확하지만 의미가 없는 URI\(예: sip:thisis@anonymous.invalid\)와 함께 표시 이름 "Anonymous"를 사용해야 합니다.\(SHOULD\)

일반적으로 특정 UA에서 생성된 요청의 From 헤더 필드를 채우는 값은 사용자 또는 사용자 로컬 도메인의 관리자가 미리 프로비저닝합니다. 특정 UA를 여러 사용자가 사용하는 경우 프로파일링된 사용자의 ID에 해당하는 URI를 포함하는 전환 가능한 프로필이 있을 수 있습니다. 요청 수신자는 자신이 From 헤더 필드에서 주장하는 사람이 누구인지 확인하기 위해 요청 발신자를 인증할 수 있습니다\(인증에 대한 자세한 내용은 섹션 22 참조\).

보낸 사람 필드에는 UAC에서 선택한 새로운 "태그" 매개변수가 포함되어야 합니다. 태그 선택에 대한 자세한 내용은 섹션 19.3을 참조하세요.\(MUST\)

From 헤더 필드에 대한 자세한 내용은 섹션 20.20을 참조하세요. 예:

```text
      From: "Bob" <sips:bob@biloxi.com> ;tag=a48s
      From: sip:+12125551212@phone2net.com;tag=887s
      From: Anonymous <sip:c8oqz84zk7z@privacy.org>;tag=hyh8
```

---
#### **8.1.1.4 Call-ID**

Call-ID 헤더 필드는 일련의 메시지를 그룹화하는 고유 식별자 역할을 합니다. 대화 상자에서 두 UA가 보낸 모든 요청과 응답에 대해 동일해야 합니다. 이는 UA의 각 등록에서 동일해야 합니다.\(MUST, SHOULD\)

대화 상자 외부에서 UAC에 의해 생성된 새 요청에서 Call-ID 헤더 필드는 메서드별 동작에 의해 재정의되지 않는 한 UAC에 의해 공간 및 시간에 걸쳐 전역적으로 고유한 식별자로 선택되어야 합니다. 모든 SIP UA에는 자신이 생성하는 Call-ID 헤더 필드가 다른 UA에 의해 실수로 생성되지 않도록 보장하는 수단이 있어야 합니다. 특정 이후에 요청이 재시도되는 경우\(MUST\)

요청에 대한 수정\(예: 인증 요청\)을 요청하는 실패 응답, 이러한 재시도 요청은 새 요청으로 간주되지 않으므로 새 Call-ID 헤더 필드가 필요하지 않습니다. 섹션 8.1.3.5를 참조하십시오.

Call-ID 생성 시 암호화된 무작위 식별자\(RFC 1750 \[12\]\)를 사용하는 것이 권장됩니다. 구현에서는 "localid@host" 형식을 사용할 수 있습니다. 호출 ID는 대소문자를 구분하며 단순히 바이트 단위로 비교됩니다.\(SHOULD, MAY\)

암호화된 무작위 식별자를 사용하면 다음과 같은 이점을 얻을 수 있습니다.

- 세션 하이재킹으로부터 보호하고 의도하지 않은 Call-ID 충돌 가능성을 줄입니다.

요청에 대한 Call-ID 헤더 필드 값을 선택하는 데 프로비저닝이나 휴먼 인터페이스가 필요하지 않습니다.

Call-ID 헤더 필드에 대한 자세한 내용은 섹션 20.8을 참조하세요.

```text
   Example:

      Call-ID: f81d4fae-7dec-11d0-a765-00a0c91e6bf6@foo.bar.com
```

---
#### **8.1.1.5 CSeq**

CSeq 헤더 필드는 트랜잭션을 식별하고 주문하는 방법으로 사용됩니다. 시퀀스 번호와 메소드로 구성됩니다. 메서드는 요청의 메서드와 일치해야 합니다. 대화 상자 외부의 REGISTER 요청이 아닌 경우 시퀀스 번호 값은 임의적입니다. 시퀀스 번호 값은 32비트 부호 없는 정수로 표현 가능해야 하며 2\*\*31보다 작아야 합니다. 위의 지침을 따르는 한 클라이언트는 CSeq 헤더 필드 값을 선택하기 위해 원하는 메커니즘을 사용할 수 있습니다.\(MUST, MUST\)

섹션 12.2.1.1에서는 대화 상자 내 요청에 대한 CSeq 구성을 논의합니다.

```text
   Example:

      CSeq: 4711 INVITE
```

---
#### **8.1.1.6 Max-Forwards**

Max-Forwards 헤더 필드는 요청이 대상으로 가는 도중에 전송할 수 있는 홉 수를 제한하는 역할을 합니다. 각 홉에서 1씩 감소하는 정수로 구성됩니다. 요청이 대상에 도달하기 전에 Max-Forwards 값이 0에 도달하면 483\(Too Many Hops\) 오류 응답과 함께 거부됩니다.

UAC는 70이어야 하는 값으로 시작되는 각 요청에 Max-Forwards 헤더 필드를 삽입해야 합니다. 이 숫자는 루프가 없을 때 SIP 네트워크에서 요청이 삭제되지 않도록 보장할 만큼 충분히 큰 것으로 선택되었습니다. 그러나 루프가 발생할 때 프록시 리소스를 소비할 만큼 크지는 않습니다. 낮은 값은 주의해서 사용해야 하며 UA에서 토폴로지를 알고 있는 네트워크에서만 사용해야 합니다.\(MUST\)

---
#### **8.1.1.7 Via**

Via 헤더 필드는 트랜잭션에 사용되는 전송을 나타내며 응답이 전송될 위치를 식별합니다. Via 헤더 필드 값은 다음 홉에 도달하는 데 사용될 전송이 선택된 후에만 추가됩니다\(\[4\]의 절차 사용이 포함될 수 있음\).

UAC가 요청을 생성할 때 해당 요청에 Via를 삽입해야 합니다. 헤더 필드의 프로토콜 이름과 프로토콜 버전은 각각 SIP와 2.0이어야 합니다. Via 헤더 필드 값은 분기 매개변수를 포함해야 합니다. 이 매개변수는 해당 요청에 의해 생성된 트랜잭션을 식별하는 데 사용됩니다. 이 매개변수는 클라이언트와 서버 모두에서 사용됩니다.\(MUST, MUST, MUST\)

분기 매개변수 값은 UA가 보낸 모든 요청에 ​​대해 공간과 시간에 걸쳐 고유해야 합니다. 이 규칙의 예외는 2xx가 아닌 응답에 대한 CANCEL 및 ACK입니다. 아래에서 설명하는 것처럼 CANCEL 요청은 취소하는 요청과 동일한 분기 매개변수 값을 갖습니다. 섹션 17.1.1.3에서 논의된 것처럼, 2xx가 아닌 응답에 대한 ACK는 응답을 승인한 INVITE와 동일한 분기 ID를 갖습니다.\(MUST\)

- 거래 ID로 쉽게 사용할 수 있도록 지점 ID 매개변수의 고유성 속성은 RFC 2543의 일부가 아닙니다.

이 사양을 준수하는 요소에 의해 삽입된 분기 ID는 항상 "z9hG4bK" 문자로 시작해야 합니다. 이 7개의 문자는 매직 쿠키로 사용됩니다\(7개는 이전 RFC 2543 구현이 이러한 값을 선택하지 않도록 보장하기에 충분한 것으로 간주됨\). 요청을 받는 서버는 지점 ID가 이 설명된 방식으로 구성되었는지 확인할 수 있습니다.\(MUST\)

사양\(즉, 전역적으로 고유함\). 이 요구 사항 외에도 분기 토큰의 정확한 형식은 구현에 따라 정의됩니다.

Via 헤더 maddr, ttl 및 sent-by 구성요소는 요청이 전송 계층\(섹션 18\)에 의해 처리될 때 설정됩니다.

프록시에 대한 처리를 통해 섹션 16.6 항목 8 및 섹션 16.7 항목 3에 설명되어 있습니다.

---
#### **8.1.1.8 Contact**

연락처 헤더 필드는 후속 요청을 위해 UA의 특정 인스턴스에 연결하는 데 사용할 수 있는 SIP 또는 SIPS URI를 제공합니다. 연락처 헤더 필드는 반드시 존재해야 하며 대화 상자를 설정할 수 있는 모든 요청에 ​​정확히 하나의 SIP 또는 SIPS URI를 포함해야 합니다. 이 사양에 정의된 메서드의 경우 INVITE 요청만 포함됩니다. 이러한 요청의 경우 연락처 범위는 전역입니다. 즉, Contact 헤더 필드 값에는 UA가 요청을 수신하려는 URI가 포함되어 있으며, 이 URI는 대화 상자 외부의 후속 요청에 사용되는 경우에도 유효해야 합니다.\(MUST, MUST\)

요청-URI 또는 ​​상위 경로 헤더 필드 값에 SIPS URI가 포함된 경우 연락처 헤더 필드에도 SIPS URI가 포함되어야 합니다.\(MUST\)

연락처 헤더 필드에 대한 자세한 내용은 섹션 20.10을 참조하세요.

---
#### **8.1.1.9 Supported and Require**

UAC가 서버가 응답에 적용할 수 있는 SIP 확장을 지원하는 경우 UAC는 해당 확장에 대한 옵션 태그\(섹션 19.2\)를 나열하는 요청에 Supported 헤더 필드를 포함해야 합니다.\(SHOULD\)

나열된 옵션 태그는 표준 추적 RFC에 정의된 확장만 참조해야 합니다. 이는 서버가 클라이언트가 서비스를 받기 위해 비표준, 공급업체 정의 기능을 구현하도록 요구하는 것을 방지하기 위한 것입니다. 실험적이고 정보를 제공하는 RFC에 의해 정의된 확장은 공급업체가 정의한 확장을 문서화하는 데 자주 사용되기 때문에 요청의 Supported 헤더 필드와 함께 사용되지 않도록 명시적으로 제외됩니다.\(MUST\)

UAC가 요청을 처리하기 위해 UAC가 요청에 적용할 확장을 UAS가 이해하도록 주장하려는 경우 해당 확장에 대한 옵션 태그를 나열하는 요청에 Require 헤더 필드를 삽입해야 합니다. UAC가 요청에 연장을 적용하고 다음과 같은 프록시가 필요하다고 주장하는 경우\(MUST\)

해당 확장을 이해하려면 해당 확장에 대한 옵션 태그를 나열하는 요청에 Proxy-Require 헤더 필드를 삽입해야 합니다.\(MUST\)

Supported 헤더 필드와 마찬가지로 Require 및 Proxy-Require 헤더 필드의 옵션 태그는 표준 추적 RFC에 정의된 확장만 참조해야 합니다.\(MUST\)

---
#### **8.1.1.10 Additional Message Components**

새 요청이 생성되고 위에 설명된 헤더 필드가 적절하게 구성된 후에는 메서드와 관련된 헤더 필드와 마찬가지로 추가적인 선택적 헤더 필드가 추가됩니다.

SIP 요청에는 MIME 인코딩된 메시지 본문이 포함될 수 있습니다. 요청에 포함된 본문 유형에 관계없이 본문 내용을 특성화하기 위해 특정 헤더 필드를 공식화해야 합니다. 이러한 헤더 필드에 대한 자세한 내용은 섹션 20.11\~20.15를 참조하세요.\(MAY\)

---
### **8.1.2 Sending the Request**

그런 다음 요청 대상이 계산됩니다. 달리 지정하는 로컬 정책이 없는 한, 다음과 같이 \[4\]에 설명된 DNS 절차를 적용하여 대상을 결정해야 합니다. 경로 세트의 첫 번째 요소가 엄격한 라우터를 나타내는 경우\(섹션 12.2.1.1에 설명된 대로 요청을 형성하는 결과\) 절차는 요청의 요청-URI에 적용되어야 합니다. 그렇지 않은 경우 절차는 요청의 첫 번째 Route 헤더 필드 값\(존재하는 경우\)에 적용되거나 Route 헤더 필드가 없는 경우 요청의 Request-URI에 적용됩니다. 이러한 절차를 통해 시도할 주소, 포트 및 전송의 순서가 지정된 집합이 생성됩니다. \[4\]의 절차에 대한 입력으로 어떤 URI가 사용되는지에 관계없이 요청-URI가 SIPS 리소스를 지정하는 경우 UAC는 입력 URI가 SIPS URI인 것처럼 \[4\]의 절차를 따라야 합니다.\(MUST, MUST, MUST\)

로컬 정책은 시도할 대체 대상 세트를 지정할 수 있습니다. 요청-URI에 SIPS URI가 포함되어 있는 경우 모든 대체 대상은 TLS를 통해 연결되어야 합니다. 그 외에도 요청에 경로 헤더 필드가 포함되어 있지 않은 경우 대체 대상에 대한 제한은 없습니다. 이는 아웃바운드 프록시를 지정하는 방법으로 기존 경로 세트에 대한 간단한 대안을 제공합니다. 그러나 아웃바운드 프록시를 구성하는 이러한 접근 방식은 권장되지 않습니다. 대신 단일 URI로 설정된 기존 경로를 사용해야 합니다. 요청에 경로 헤더 필드가 포함된 경우 요청은 최상위 값에서 파생된 위치로 전송되어야 하지만 UA가 이 문서에 지정된 경로 및 요청-URI 정책을 준수할 것이라고 확신하는 모든 서버로 전송될 수 있습니다. RFC 2543의 내용과 반대\). 특히 아웃바운드 프록시로 구성된 UAC는 반드시\(MAY, MUST, SHOULD NOT, SHOULD, SHOULD\)

모든 메시지를 아웃바운드 프록시로 보내는 정책을 채택하는 대신 첫 번째 경로 헤더 필드 값에 표시된 위치로 요청을 보내려고 합니다.

- 이렇게 하면 Record-Route 헤더 필드 값을 추가하지 않는 아웃바운드 프록시가 후속 요청 경로에서 삭제됩니다. 이를 통해 첫 번째 경로 URI를 확인할 수 없는 엔드포인트가 해당 작업을 아웃바운드 프록시에 위임할 수 있습니다.

UAC는 상태 저장 요소에 대해 \[4\]에 정의된 절차를 따라 서버에 연결될 때까지 각 주소를 시도해야 합니다. 각 시도는 새로운 트랜잭션을 구성하므로 각 시도는 새로운 분기 매개변수와 함께 서로 다른 최상위 Via 헤더 필드 값을 전달합니다. 또한 Via 헤더 필드의 전송 값은 대상 서버에 대해 결정된 전송으로 설정됩니다.\(SHOULD\)

---
### **8.1.3 Processing Responses**

응답은 먼저 전송 계층에서 처리된 다음 트랜잭션 계층으로 전달됩니다. 트랜잭션 계층은 처리를 수행한 다음 응답을 TU에 전달합니다. TU의 대부분의 응답 처리는 방법별로 다릅니다. 그러나 메서드와 관계없이 몇 가지 일반적인 동작이 있습니다.

---
#### **8.1.3.1 Transaction Layer Errors**

어떤 경우에는 트랜잭션 계층에서 반환된 응답이 SIP 메시지가 아니라 트랜잭션 계층 오류가 됩니다. 트랜잭션 계층에서 시간 초과 오류가 수신되면 408\(요청 시간 초과\) 상태 코드가 수신된 것처럼 처리되어야 합니다. 전송 계층에서 치명적인 전송 오류가 보고되는 경우\(일반적으로 UDP의 치명적인 ICMP 오류 또는 TCP의 연결 실패로 인해\) 해당 조건은 503\(서비스를 사용할 수 없음\) 상태 코드로 처리되어야 합니다.\(MUST, MUST\)

---
#### **8.1.3.2 Unrecognized Responses**

UAC는 인식하지 못하는 모든 최종 응답을 해당 클래스의 x00 응답 코드와 동일하게 처리해야 하며 모든 클래스에 대해 x00 응답 코드를 처리할 수 있어야 합니다\(MUST\). 예를 들어, UAC가 인식할 수 없는 응답 코드 431을 수신하면 요청에 문제가 있다고 안전하게 가정하고 응답을 400\(잘못된 요청\) 응답 코드를 수신한 것처럼 처리할 수 있습니다. UAC는 183\(세션 진행률\)으로 인식되지 않는 100과 다른 임시 응답을 처리해야 합니다. UAC는 100 및 183개의 응답을 처리할 수 있어야 합니다.\(MUST, MUST, MUST\)

---
#### **8.1.3.3 Vias**

응답에 둘 이상의 Via 헤더 필드 값이 있는 경우 UAC는 메시지를 삭제해야 합니다.\(SHOULD\)

- 요청 발신자 앞에 추가 Via 헤더 필드 값이 있으면 메시지가 잘못 라우팅되었거나 손상되었을 수 있음을 나타냅니다.

---
#### **8.1.3.4 Processing 3xx Responses**

리디렉션 응답\(예: 301 응답 상태 코드\)을 수신하면 클라이언트는 연락처 헤더 필드의 URI를 사용하여 리디렉션된 요청을 기반으로 하나 이상의 새로운 요청을 작성해야 합니다. 이 프로세스는 섹션 16.5 및 16.6에 자세히 설명된 대로 3xx 클래스 응답에서 반복되는 프록시의 프로세스와 유사합니다. 클라이언트는 원래 요청의 요청-URI인 정확히 하나의 URI를 포함하는 초기 대상 세트로 시작합니다. 클라이언트가 해당 요청에 대한 3xx 클래스 응답을 기반으로 새 요청을 공식화하려는 경우 대상 세트에 시도할 URI를 배치합니다. 이 사양의 제한 사항에 따라 클라이언트는 대상 세트에 배치할 연락처 URI를 선택할 수 있습니다. 프록시 재귀와 마찬가지로 3xx 클래스 응답을 처리하는 클라이언트는 지정된 URI를 대상 세트에 두 번 이상 추가해서는 안 됩니다. 원래 요청의 Request-URI에 SIPS URI가 있는 경우 클라이언트는 SIPS가 아닌 URI로 재귀하도록 선택할 수 있지만 사용자에게 안전하지 않은 URI로의 리디렉션을 알려야 합니다.\(SHOULD, MUST NOT, SHOULD\)

- 모든 새로운 요청은 원래 URI를 연락처로 포함하는 3xx 응답을 받을 수 있습니다. 서로 리디렉션되도록 두 위치를 구성할 수 있습니다. 지정된 URI를 대상 세트에 한 번만 배치하면 무한 리디렉션 루프가 방지됩니다.

대상 세트가 증가함에 따라 클라이언트는 순서에 관계없이 URI에 대한 새로운 요청을 생성할 수 있습니다. 일반적인 메커니즘은 연락처 헤더 필드 값에서 "q" 매개변수 값으로 집합을 정렬하는 것입니다. URI에 대한 요청은 직렬 또는 병렬로 생성될 수 있습니다. 한 가지 접근 방식은 q-값이 감소하는 그룹을 순차적으로 처리하고 각 q-값 그룹의 URI를 병렬로 처리하는 것입니다. 또 다른 방법은 q 값이 감소하는 순서로 직렬 처리만 수행하고 q 값이 동일한 접점 중에서 임의로 선택하는 것입니다.\(MAY, MAY\)

다음 단락에 정의된 대로 목록의 주소에 연결하면 오류가 발생하는 경우 목록이 소진될 때까지 요소는 목록의 다음 주소로 이동합니다. 목록이 모두 소진되면 요청이 실패한 것입니다.

실패는 실패 응답 코드\(399보다 큰 코드\)를 통해 감지되어야 합니다. 네트워크 오류의 경우 클라이언트 트랜잭션은 전송 계층 오류를 트랜잭션 사용자에게 보고합니다. 일부 응답 코드\(8.1.3.5에 자세히 설명\)는 요청을 재시도할 수 있음을 나타냅니다. 재시도되는 요청은 실패로 간주되어서는 안 됩니다.\(SHOULD\)

특정 연락처 주소에 대한 실패가 수신되면 클라이언트는 다음 연락처 주소를 시도해야 합니다. 여기에는 새 요청을 전달하기 위해 새 클라이언트 트랜잭션을 생성하는 작업이 포함됩니다.\(SHOULD\)

3xx 응답의 연락처 주소를 기반으로 요청을 생성하려면 UAC는 "method-param" 및 "header" URI 매개변수를 제외하고 대상 세트의 전체 URI를 요청-URI로 복사해야 합니다\(섹션 참조\). 이러한 매개변수의 정의는 19.1.1 참조\). "헤더" 매개변수를 사용하여 새 요청에 대한 헤더 필드 값을 생성하고 섹션 19.1.5의 지침에 따라 리디렉션된 요청과 관련된 헤더 필드 값을 덮어씁니다.\(MUST\)

어떤 경우에는 연락처 주소로 전달된 헤더 필드가 원래 리디렉션된 요청의 기존 요청 헤더 필드에 대신 추가될 수 있습니다. 일반적으로 헤더 필드가 쉼표로 구분된 값 목록을 허용할 수 있는 경우 새 헤더 필드 값은 원래 리디렉션된 요청의 기존 값에 추가될 수 있습니다. 헤더 필드가 여러 값을 허용하지 않는 경우 원래 리디렉션된 요청의 값을 연락처 주소로 전달된 헤더 필드 값으로 덮어쓸 수 있습니다. 예를 들어 연락처 주소가 다음 값으로 반환되는 경우:\(MAY, MAY\)

```text
      sip:user@host?Subject=foo&Call-Info=<http://www.foo.com>
```

그런 다음 원래 리디렉션된 요청의 모든 Subject 헤더 필드를 덮어쓰지만 HTTP URL은 기존 Call-Info 헤더 필드 값에 추가될 뿐입니다.

UAC는 원래 리디렉션된 요청에 사용된 동일한 To, From 및 Call-ID를 재사용하는 것이 권장되지만 UAC는 예를 들어 새 요청에 대한 Call-ID 헤더 필드 값을 업데이트하도록 선택할 수도 있습니다.\(SHOULD\)

마지막으로 새 요청이 구성되면 새 클라이언트 트랜잭션을 사용하여 전송되므로 섹션 8.1.1.7에서 설명한 대로 상단 Via 필드에 새 분기 ID가 있어야 합니다.\(MUST\)

다른 모든 측면에서 리디렉션 응답 수신 시 전송된 요청은 원래 요청의 헤더 필드와 본문을 재사용해야 합니다.\(SHOULD\)

경우에 따라 연락처 헤더 필드 값은 수신된 상태 코드 및 만료 간격의 존재 여부에 따라 일시적으로 또는 영구적으로 UAC에 캐시될 수 있습니다. 섹션 21.3.2 및 21.3.3을 참조하십시오.

---
#### **8.1.3.5 Processing 4xx Responses**

특정 4xx 응답 코드에는 방법과 관계없이 특정 UA 처리가 필요합니다.

401\(인증되지 않음\) 또는 407\(프록시 인증 필요\) 응답이 수신되면 UAC는 섹션 22.2 및 섹션 22.3의 인증 절차에 따라 자격 증명을 사용하여 요청을 재시도해야 합니다.\(SHOULD\)

413\(요청 엔터티가 너무 큼\) 응답이 수신된 경우\(섹션 21.4.11\) UAS가 수락할 수 있는 것보다 긴 본문이 요청에 포함된 것입니다. 가능하다면 UAC는 본문을 생략하거나 더 짧은 길이의 본문을 사용하여 요청을 다시 시도해야 합니다.\(SHOULD\)

415\(지원되지 않는 미디어 유형\) 응답이 수신되면\(섹션 21.4.13\) 요청에 UAS에서 지원하지 않는 미디어 유형이 포함된 것입니다. UAC는 요청 전송을 다시 시도해야 합니다. 이번에는 응답의 Accept 헤더 필드에 나열된 유형, 응답의 Accept-Encoding 헤더 필드에 나열된 인코딩 및 Accept-Language에 나열된 언어가 있는 콘텐츠만 사용하여 요청을 보내야 합니다. 응답.\(SHOULD\)

416\(Unsupported URI Scheme\) 응답이 수신된 경우\(섹션 21.4.14\) Request-URI는 서버에서 지원하지 않는 URI 스키마를 사용했습니다. 클라이언트는 이번에는 SIP URI를 사용하여 요청을 재시도해야 합니다.\(SHOULD\)

420\(잘못된 확장\) 응답이 수신된 경우\(섹션 21.4.15\) 요청에는 프록시 또는 UAS에서 지원하지 않는 기능에 대한 옵션 태그를 나열하는 Require 또는 Proxy-Require 헤더 필드가 포함되어 있습니다. UAC는 요청을 재시도해야 하며, 이번에는 응답의 지원되지 않는 헤더 필드에 나열된 모든 확장자를 생략해야 합니다.\(SHOULD\)

위의 모든 경우에 적절하게 수정하여 새 요청을 생성하여 요청을 재시도합니다. 이 새로운 요청은 새로운 트랜잭션을 구성하며 이전 요청의 Call-ID, To 및 From 값과 동일해야 하지만 CSeq에는 이전 요청보다 하나 더 높은 새 시퀀스 번호가 포함되어야 합니다.\(SHOULD\)

아직 정의되지 않은 응답을 포함하여 다른 4xx 응답의 경우 방법 및 사용 사례에 따라 재시도가 가능할 수도 있고 불가능할 수도 있습니다.

---
## **8.2 UAS Behavior**

대화 상자 외부의 요청이 UAS에 의해 처리될 때 메서드와 관계없이 따르는 처리 규칙 집합이 있습니다. 섹션 12에서는 요청이 대화 상자 내부에 있는지 외부에 있는지 UAS가 어떻게 알 수 있는지에 대한 지침을 제공합니다.

요청 처리는 원자성입니다. 요청이 수락되면 이와 관련된 모든 상태 변경이 수행되어야 합니다. 거부되면 모든 상태 변경을 수행해서는 안 됩니다.\(MUST, MUST NOT\)

UAS는 이 섹션에 나오는 단계의 순서대로 요청을 처리해야 합니다\(즉, 인증부터 시작하여 이 섹션의 나머지 부분 전체에서 메서드, 헤더 필드 등을 검사합니다\).\(SHOULD\)

---
### **8.2.1 Method Inspection**

요청이 인증되면\(또는 인증을 건너뛰면\) UAS는 요청 방법을 검사해야 합니다. UAS가 요청 방법을 인식하지만 지원하지 않는 경우 405\(허용되지 않는 방법\) 응답을 생성해야 합니다. 응답 생성 절차는 섹션 8.2.6에 설명되어 있습니다. UAS는 또한 405\(허용되지 않는 방법\) 응답에 Allow 헤더 필드를 추가해야 합니다. Allow 헤더 필드에는 메시지를 생성하는 UAS가 지원하는 메서드 집합이 나열되어야 합니다. Allow 헤더 필드는 섹션 20.5에 나와 있습니다.\(MUST, MUST, MUST, MUST\)

방법이 서버에서 지원되는 방법이면 처리가 계속됩니다.

---
### **8.2.2 Header Inspection**

UAS가 요청의 헤더 필드를 이해하지 못하는 경우\(즉, 헤더 필드가 이 사양이나 지원되는 확장에 정의되지 않은 경우\) 서버는 해당 헤더 필드를 무시하고 메시지 처리를 계속해야 합니다. UAS는 요청 처리에 필요하지 않은 잘못된 헤더 필드를 무시해야 합니다.\(MUST, SHOULD\)

---
#### **8.2.2.1 To and Request-URI**

To 헤더 필드는 From 필드에서 식별된 사용자가 지정한 요청의 원래 수신자를 식별합니다. 원래 수신자는 착신 전환이나 기타 프록시 작업으로 인해 요청을 처리하는 UAS일 수도 있고 아닐 수도 있습니다. UAS는 To가 수신될 때 요청을 수락할지 여부를 결정하기 위해 원하는 정책을 적용할 수 있습니다.\(MAY\)

헤더 필드는 UAS의 ID가 아닙니다. 그러나 To 헤더 필드에서 URI 체계\(예: tel: URI\)를 인식하지 못하거나 To 헤더 필드가 이 알려진 사용자 또는 현재 사용자를 지정하지 않는 경우에도 UAS가 요청을 수락하는 것이 좋습니다. UAS. 반면에 UAS가 요청을 거부하기로 결정한 경우 403\(금지\) 상태 코드가 포함된 응답을 생성하고 이를 서버 트랜잭션에 전달하여 전송해야 합니다.\(SHOULD, SHOULD\)

그러나 요청-URI는 요청을 처리할 UAS를 식별합니다. Request-URI가 UAS에서 지원하지 않는 체계를 사용하는 경우 416\(지원되지 않는 URI 체계\) 응답으로 요청을 거부해야 합니다. 요청-URI가 UAS가 요청을 수락하려는 주소를 식별하지 못하는 경우 404\(찾을 수 없음\) 응답으로 요청을 거부해야 합니다. 일반적으로 REGISTER 메서드를 사용하여 레코드 주소를 특정 연락처 주소에 바인딩하는 UA는 요청 URI가 해당 연락처 주소와 동일한 요청을 보게 됩니다. 수신된 요청-URI의 다른 잠재적 소스에는 대화 상자를 설정하거나 새로 고치는 UA가 전송한 요청 및 응답의 연락처 헤더 필드가 포함됩니다.\(SHOULD, SHOULD\)

---
#### **8.2.2.2 Merged Requests**

요청의 To 헤더 필드에 태그가 없으면 UAS 코어는 진행 중인 트랜잭션에 대해 요청을 확인해야 합니다. From 태그, Call-ID 및 CSeq가 진행 중인 트랜잭션과 관련된 것과 정확하게 일치하지만 요청이 해당 트랜잭션과 일치하지 않는 경우\(섹션 17.2.3의 일치 규칙을 기반으로 함\) UAS 코어는 482\(루프\)를 생성해야 합니다. Detected\) 응답을 받아 서버 트랜잭션에 전달합니다.\(MUST, SHOULD\)

- 동일한 요청이 서로 다른 경로를 따라 두 번 이상 UAS에 도착했는데, 이는 분기로 인해 발생했을 가능성이 높습니다. UAS는 수신된 첫 번째 요청을 처리하고 나머지 요청에는 482\(루프 감지\)로 응답합니다.

---
#### **8.2.2.3 Require**

UAS는 요청을 처리하는 데 적합한 요소라고 판단한다고 가정하고 Require 헤더 필드\(있는 경우\)를 검사합니다.

Require 헤더 필드는 UAC가 요청을 적절하게 처리하기 위해 UAS가 지원할 것으로 예상하는 SIP 확장에 대해 UAS에 알리는 데 사용됩니다. 그 형식은 섹션 20.32에 설명되어 있습니다. UAS가 Require 헤더 필드에 나열된 옵션 태그를 이해하지 못하는 경우 상태 코드 420\(잘못된 확장\)으로 응답을 생성하여 응답해야 합니다. UAS는 지원되지 않는 헤더 필드를 추가해야 하며 요청의 Require 헤더 필드에 있는 옵션 중에서 이해하지 못하는 옵션을 나열해야 합니다.\(MUST, MUST\)

Require 및 Proxy-Require는 SIP CANCEL 요청이나 2xx가 아닌 응답에 대해 전송된 ACK 요청에 사용되어서는 안 됩니다. 이러한 헤더 필드가 이러한 요청에 있는 경우 무시해야 합니다.\(MUST NOT, MUST\)

2xx 응답에 대한 ACK 요청에는 초기 요청에 있었던 Require 및 Proxy-Require 값만 포함되어야 합니다.\(MUST\)

```text
   Example:

      UAC->UAS:   INVITE sip:watson@bell-telephone.com SIP/2.0
                  Require: 100rel

      UAS->UAC:   SIP/2.0 420 Bad Extension
                  Unsupported: 100rel
```

- 이 동작은 양쪽이 모든 옵션을 이해할 때 클라이언트-서버 상호 작용이 지연 없이 진행되도록 보장하고 옵션이 이해되지 않는 경우에만 속도가 느려집니다\(위의 예에서와 같이\). 잘 일치하는 클라이언트-서버 쌍의 경우 상호 작용이 빠르게 진행되어 협상 메커니즘에 필요한 왕복 시간이 절약됩니다. 또한 서버가 이해하지 못하는 기능을 클라이언트가 요구할 때 모호성을 제거합니다. 통화 처리 필드와 같은 일부 기능은 최종 시스템에만 관심이 있습니다.

---
### **8.2.3 Content Processing**

UAS가 클라이언트에 필요한 확장을 이해한다고 가정하면 UAS는 메시지 본문과 메시지를 설명하는 헤더 필드를 검사합니다. 유형\(Content-Type으로 표시됨\), 언어\(Content-Language로 표시됨\) 또는 인코딩\(Content-Encoding으로 표시됨\)을 이해할 수 없는 본문이 있고 해당 본문 부분이 선택 사항이 아닌 경우\(다음으로 표시됨\) Content-Disposition 헤더 필드\), UAS는 415\(지원되지 않는 미디어 유형\) 응답으로 요청을 거부해야 합니다. 요청에 UAS에서 지원하지 않는 유형의 본문이 포함된 경우 응답에는 이해하는 모든 본문 유형을 나열하는 Accept 헤더 필드가 포함되어야 합니다. 요청에 UAS가 이해하지 못하는 콘텐츠 인코딩이 포함된 경우 응답에는 UAS가 이해하는 인코딩을 나열하는 Accept-Encoding 헤더 필드가 포함되어야 합니다. 요청에 UAS가 이해하지 못하는 언어가 포함된 콘텐츠가 포함된 경우 응답에는 UAS가 이해하는 언어를 나타내는 Accept-Language 헤더 필드가 포함되어야 합니다. 이러한 검사 외에도 본문 처리는 방법과 유형에 따라 다릅니다. 콘텐츠별 헤더 필드 처리에 대한 자세한 내용은 섹션 7.4와 섹션 20.11부터 20.15를 참조하세요.\(MUST, MUST, MUST, MUST\)

---
### **8.2.4 Applying Extensions**

응답을 생성할 때 일부 확장을 적용하려는 UAS는 해당 확장에 대한 지원이 요청의 Supported 헤더 필드에 표시되지 않는 한 그렇게 해서는 안 됩니다. 원하는 확장이 지원되지 않는 경우 서버는 기본 SIP 및 클라이언트가 지원하는 기타 확장에만 의존해야 합니다. 서버가 확장 없이 요청을 처리할 수 없는 드문 상황에서 서버는 421\(확장 필요\) 응답을 보낼 수 있습니다. 이 응답은 특정 확장을 지원하지 않으면 적절한 응답을 생성할 수 없음을 나타냅니다. 필요한 확장은 응답의 Require 헤더 필드에 포함되어야 합니다. 이 동작은 일반적으로 상호 운용성을 손상시키므로 권장되지 않습니다.\(MUST NOT, SHOULD, MAY, MUST, SHOULD NOT\)

421이 아닌 응답에 적용된 모든 확장은 응답에 포함된 Require 헤더 필드에 나열되어야 합니다. 물론 서버는 요청의 Supported 헤더 필드에 나열되지 않은 확장을 적용해서는 안 됩니다. 결과적으로 응답의 Require 헤더 필드에는 표준 추적 RFC에 정의된 옵션 태그만 포함됩니다.\(MUST, MUST NOT\)

---
### **8.2.5 Processing the Request**

이전 하위 섹션의 모든 검사가 통과되었다고 가정하면 UAS 처리는 방법별로 달라집니다. 섹션 10은 REGISTER 요청을 다루고, 섹션 11은 OPTIONS 요청을 다루고, 섹션 13은 INVITE 요청을 다루고, 섹션 15는 BYE 요청을 다루고 있습니다.

---
### **8.2.6 Generating the Response**

UAS가 요청에 대한 응답을 구성하려는 경우 다음 하위 섹션에 자세히 설명된 일반 절차를 따릅니다. 이 섹션에 자세히 설명되지 않은 문제의 응답 코드와 관련된 추가 동작이 필요할 수도 있습니다.

응답 생성과 관련된 모든 절차가 완료되면 UAS는 요청을 받은 서버 트랜잭션에 응답을 다시 전달합니다.

---
#### **8.2.6.1 Sending a Provisional Response**

응답 생성에 대한 비방법별 지침 중 하나는 UAS가 비INVITE 요청에 대해 임시 응답을 발행해서는 안 된다는 것입니다. 오히려 UAS는 가능한 한 빨리 비INVITE 요청에 대한 최종 응답을 생성해야 합니다.\(SHOULD NOT, SHOULD\)

100\(Trying\) 응답이 생성되면 요청에 있는 모든 타임스탬프 헤더 필드를 이 100\(Trying\) 응답에 복사해야 합니다. 응답 생성이 지연되는 경우 UAS는 응답의 타임스탬프 값에 지연 값을 추가해야 합니다. 이 값에는 응답 전송 시간과 요청 수신 시간 간의 차이\(초 단위\)가 포함되어야 합니다.\(MUST, SHOULD, MUST\)

---
#### **8.2.6.2 Headers and Tags**

응답의 From 필드는 요청의 From 헤더 필드와 동일해야 합니다. 응답의 Call-ID 헤더 필드는 요청의 Call-ID 헤더 필드와 동일해야 합니다. 응답의 CSeq 헤더 필드는 요청의 CSeq 필드와 동일해야 합니다. 응답의 Via 헤더 필드 값은 요청의 Via 헤더 필드 값과 동일해야 하며 동일한 순서를 유지해야 합니다\(MUST\).\(MUST, MUST, MUST, MUST\)

요청의 요청에 To 태그가 포함된 경우 응답의 To 헤더 필드는 요청의 헤더 필드와 동일해야 합니다. 그러나 요청의 To 헤더 필드에 태그가 포함되어 있지 않은 경우 응답의 To 헤더 필드에 있는 URI는 To 헤더 필드에 있는 URI와 동일해야 합니다. 또한 UAS는 응답의 To 헤더 필드에 태그를 추가해야 합니다\(태그가 존재할 수 있는 100\(Trying\) 응답 제외\). 이는 응답하는 UAS를 식별하는 데 사용되며 대화 상자 ID의 구성 요소가 될 수 있습니다. 해당 요청에 대한 모든 응답\(최종 및 임시\)에 동일한 태그를 사용해야 합니다\(다시 100\(시도 중\) 제외\). 태그 생성 절차는 섹션 19.3에 정의되어 있습니다.\(MUST, MUST, MUST\)

---
### **8.2.7 Stateless UAS Behavior**

상태 비저장 UAS는 트랜잭션 상태를 유지하지 않는 UAS입니다. 요청에 정상적으로 응답하지만 응답이 전송된 후 UAS가 일반적으로 유지하는 모든 상태를 삭제합니다. 상태 비저장 UAS가 요청의 재전송을 받으면 마치 요청의 첫 번째 인스턴스에 응답하는 것처럼 응답을 다시 생성하여 다시 보냅니다. UAS는 해당 메서드에 대한 요청 처리가 요청이 동일한 경우 항상 동일한 응답을 초래하지 않는 한 상태 비저장일 수 없습니다. 예를 들어 이는 무국적 등록기관을 배제합니다. 상태 비저장 UAS는 트랜잭션 계층을 사용하지 않습니다. 전송 계층에서 직접 요청을 받고 전송 계층에 직접 응답을 보냅니다.

상태 비저장 UAS 역할은 주로 챌린지 응답이 발행되는 인증되지 않은 요청을 처리하는 데 필요합니다. 인증되지 않은 요청이 상태 그대로 처리되면 인증되지 않은 요청의 악의적인 홍수로 인해 엄청난 양의 오류가 발생할 수 있습니다.

UAS의 호출 처리를 느리게 하거나 완전히 중단하여 효과적으로 서비스 거부 조건을 생성할 수 있는 트랜잭션 상태 자세한 내용은 섹션 26.1.5를 참조하세요.

상태 비저장 UAS의 가장 중요한 동작은 다음과 같습니다.

- o 무상태 UAS는 임시\(1xx\) 응답을 보내서는 안 됩니다.\(MUST NOT\)

- o 무상태 UAS는 응답을 재전송해서는 안 됩니다.\(MUST NOT\)

- o 상태 비저장 UAS는 ACK 요청을 무시해야 합니다.\(MUST\)

- o 상태 비저장 UAS는 취소 요청을 무시해야 합니다.\(MUST\)

- o 응답에 대해 헤더 태그는 상태 비저장 방식으로, 즉 동일한 요청에 대해 동일한 태그를 일관되게 생성하는 방식으로 생성되어야 합니다. 태그 구성에 대한 자세한 내용은 섹션 19.3을 참조하세요.\(MUST\)

다른 모든 측면에서 상태 비저장 UAS는 상태 저장 UAS와 동일한 방식으로 작동합니다. UAS는 각각의 새로운 요청에 대해 상태 저장 모드 또는 상태 비저장 모드에서 작동할 수 있습니다.

---
## **8.3 Redirect Servers**

일부 아키텍처에서는 리디렉션을 사용하여 요청 라우팅을 담당하는 프록시 서버의 처리 부하를 줄이고 신호 경로 견고성을 향상시키는 것이 바람직할 수 있습니다.

리디렉션을 사용하면 서버가 클라이언트에 대한 응답으로 요청에 대한 라우팅 정보를 다시 푸시할 수 있으므로 요청 대상을 찾는 데 도움을 주면서 이 트랜잭션에 대한 추가 메시징 루프에서 스스로 벗어날 수 있습니다. 요청을 보낸 사람이 리디렉션을 받으면 받은 URI를 기반으로 새 요청을 보냅니다. 리디렉션은 네트워크의 핵심에서 가장자리로 URI를 전파함으로써 상당한 네트워크 확장성을 허용합니다.

리디렉션 서버는 논리적으로 서버 트랜잭션 계층과 일종의 위치 서비스에 액세스할 수 있는 트랜잭션 사용자로 구성됩니다\(등록자 및 위치 서비스에 대한 자세한 내용은 섹션 10 참조\). 이 위치 서비스는 사실상 단일 URI와 해당 URI의 대상을 찾을 수 있는 하나 이상의 대체 위치 집합 간의 매핑을 포함하는 데이터베이스입니다.

리디렉션 서버는 자체 SIP 요청을 발행하지 않습니다. CANCEL 이외의 요청을 받은 후 서버는 요청을 거부하거나 대체 위치 목록을 수집합니다.

위치 서비스를 제공하고 클래스 3xx의 최종 응답을 반환합니다. 올바른 형식의 CANCEL 요청의 경우 2xx 응답을 반환해야 합니다. 이 응답으로 SIP 트랜잭션이 종료됩니다. 리디렉션 서버는 전체 SIP 트랜잭션에 대한 트랜잭션 상태를 유지합니다. 리디렉션 서버 간의 전달 루프를 감지하는 것은 클라이언트의 책임입니다.\(SHOULD\)

리디렉션 서버가 요청에 대해 3xx 응답을 반환하면 하나 이상의 대체 위치 목록을 연락처 헤더 필드에 채웁니다. 연락처 헤더 필드 값에 대한 "만료" 매개변수는 연락처 데이터의 수명을 나타내기 위해 제공될 수도 있습니다.

연락처 헤더 필드에는 시도할 새 위치나 사용자 이름을 제공하는 URI가 포함되어 있거나 단순히 추가 전송 매개변수를 지정할 수 있습니다. 301\(영구적으로 이동됨\) 또는 302\(일시적으로 이동됨\) 응답은 초기 요청의 대상과 동일한 위치 및 사용자 이름을 제공할 수도 있지만 시도할 다른 서버 또는 멀티캐스트 주소나 SIP 전송 변경과 같은 추가 전송 매개변수를 지정할 수도 있습니다. UDP에서 TCP로 또는 그 반대로.

그러나 리디렉션 서버는 Request-URI에 있는 것과 동일한 URI로 요청을 리디렉션하면 안 됩니다. 대신, URI가 자신을 가리키지 않는 경우 서버는 요청을 대상 URI로 프록시하거나 404로 거부할 수 있습니다.\(MUST NOT\)

- 클라이언트가 아웃바운드 프록시를 사용하고 있고 해당 프록시가 실제로 요청을 리디렉션하는 경우 무한 리디렉션 루프가 발생할 가능성이 있습니다.

```text
   Note that a Contact header field value MAY also refer to a different
   resource than the one originally called.  For example, a SIP call
   connected to PSTN gateway may need to deliver a special informational
   announcement such as "The number you have dialed has been changed."
```

연락처 응답 헤더 필드에는 SIP URI에 국한되지 않고 수신자에게 연결할 수 있는 위치를 나타내는 적절한 URI가 포함될 수 있습니다. 예를 들어, 전화, 팩스 또는 irc\(정의된 경우\) 또는 mailto:\(RFC 2368 \[32\]\) URL에 대한 URI를 포함할 수 있습니다. 섹션 26.4.4에서는 SIPS URI를 SIPS가 아닌 URI로 리디렉션하는 것의 의미와 제한 사항에 대해 설명합니다.

연락처 헤더 필드 값의 "만료" 매개변수는 URI가 유효한 기간을 나타냅니다. 매개변수의 값은 초를 나타내는 숫자입니다. 이 매개변수가 제공되지 않으면 Expires 헤더 필드의 값에 따라 URI가 유효한 기간이 결정됩니다. 잘못된 값은 3600과 동일하게 처리되어야 합니다\(SHOULD\).\(SHOULD\)

- 이는 이 헤더 필드에 절대 시간을 허용하는 RFC 2543과의 적당한 수준의 이전 버전 호환성을 제공합니다. 절대 시간을 수신하면 잘못된 형식으로 처리되며 기본값은 3600입니다.

리디렉션 서버는 이해되지 않는 기능\(인식할 수 없는 헤더 필드, Require의 알 수 없는 옵션 태그 또는 메서드 이름 포함\)을 무시하고 문제의 요청 리디렉션을 진행해야 합니다.\(MUST\)

---
# **9 Canceling a Request**

이전 섹션에서는 모든 메서드의 요청에 대한 요청을 생성하고 응답을 처리하는 일반적인 UA 동작에 대해 설명했습니다. 이 섹션에서는 CANCEL이라는 범용 메서드에 대해 설명합니다.

CANCEL 요청은 이름에서 알 수 있듯이 클라이언트가 보낸 이전 요청을 취소하는 데 사용됩니다. 특히 UAS에 요청 처리를 중단하고 해당 요청에 대한 오류 응답을 생성하도록 요청합니다. CANCEL은 UAS가 이미 최종 응답을 제공한 요청에는 영향을 미치지 않습니다. 이 때문에 서버가 응답하는 데 오랜 시간이 걸릴 수 있는 요청을 취소하는 것이 가장 유용합니다. 이러한 이유로 CANCEL은 응답을 생성하는 데 오랜 시간이 걸릴 수 있는 INVITE 요청에 가장 적합합니다. 해당 사용법에서 INVITE에 대한 CANCEL 요청을 수신했지만 아직 최종 응답을 보내지 않은 UAS는 "벨소리를 중지"한 다음 특정 오류 응답\(487\)으로 INVITE에 응답합니다.

CANCEL 요청은 프록시와 사용자 에이전트 클라이언트 모두에서 구성하고 보낼 수 있습니다. 섹션 15에서는 UAC가 INVITE 요청을 취소하는 조건에 대해 설명하고 섹션 16.10에서는 CANCEL의 프록시 사용에 대해 설명합니다.

상태 저장 프록시는 단순히 다운스트림 요소로부터 수신할 응답을 전달하는 것이 아니라 CANCEL에 응답합니다. 이러한 이유로 CANCEL은 각 상태 저장 프록시 홉에서 응답되므로 "홉별" 요청이라고 합니다.

---
## **9.1 Client Behavior**

INVITE 이외의 요청을 취소하기 위해 CANCEL 요청을 전송해서는 안 됩니다.\(SHOULD NOT\)

- INVITE 이외의 요청은 즉시 응답되므로 INVITE가 아닌 요청에 대해 CANCEL을 보내면 항상 경쟁 조건이 발생합니다.

다음 절차는 CANCEL 요청을 생성하는 데 사용됩니다. CANCEL 요청의 Request-URI, Call-ID, To, CSeq의 숫자 부분 및 From 헤더 필드는 태그를 포함하여 취소되는 요청의 필드와 동일해야 합니다. 클라이언트가 생성한 CANCEL에는 취소되는 요청의 상위 Via 값과 일치하는 단일 Via 헤더 필드 값만 있어야 합니다. 이러한 헤더 필드에 동일한 값을 사용하면 CANCEL이 취소하는 요청과 일치될 수 있습니다\(9.2절에 이러한 일치가 발생하는 방법이 나와 있습니다\). 그러나 CSeq 헤더 필드의 메소드 부분은 CANCEL 값을 가져야 합니다. 이를 통해 자체적으로 거래로 식별되고 처리될 수 있습니다\(섹션 17 참조\).\(MUST, MUST, MUST\)

취소되는 요청에 경로 헤더 필드가 포함되어 있는 경우 CANCEL 요청에는 해당 경로 헤더 필드의 값이 포함되어야 합니다.\(MUST\)

- 이는 상태 비저장 프록시가 CANCEL 요청을 적절하게 라우팅할 수 있도록 하기 위해 필요합니다.

CANCEL 요청에는 Require 또는 Proxy-Require 헤더 필드가 포함되어서는 안 됩니다.\(MUST NOT\)

CANCEL이 구성되면 클라이언트는 취소되는 요청\(여기서는 "원래 요청"이라고 함\)에 대한 응답\(임시 또는 최종\)을 수신했는지 여부를 확인해야 합니다.\(SHOULD\)

임시 응답이 수신되지 않은 경우 CANCEL 요청을 보내서는 안 됩니다. 오히려 클라이언트는 요청을 보내기 전에 임시 응답이 도착할 때까지 기다려야 합니다. 원래 요청이 최종 응답을 생성한 경우 CANCEL은 전송되어서는 안 됩니다. CANCEL은 이미 최종 응답을 생성한 요청에 영향을 주지 않기 때문에 효과적인 무작동\(no-op\)이기 때문입니다. 클라이언트가 CANCEL을 보내기로 결정하면 CANCEL에 대한 클라이언트 트랜잭션을 생성하고 대상 주소, 포트 및 전송과 함께 CANCEL 요청을 전달합니다. CANCEL의 대상 주소, 포트 및 전송은 원래 요청을 보내는 데 사용된 것과 동일해야 합니다.\(MUST NOT, SHOULD NOT, MUST\)

- 이전 요청에 대한 응답을 받기 전에 CANCEL을 보내는 것이 허용된 경우 서버는 원래 요청 전에 CANCEL을 받을 수 있습니다.

원래 요청에 해당하는 트랜잭션과 CANCEL 트랜잭션은 모두 독립적으로 완료됩니다. 그러나 요청을 취소하는 UAC는 원래 요청에 대한 487\(요청 종료됨\) 응답 수신에 의존할 수 없습니다. RFC 2543 호환 UAS는 그러한 응답을 생성하지 않기 때문입니다. 64\*T1초 내에 원래 요청에 대한 최종 응답이 없는 경우\(T1은

섹션 17.1.1.1에 정의됨\) 클라이언트는 취소된 원래 트랜잭션을 고려해야 하며 원래 요청을 처리하는 클라이언트 트랜잭션을 파기해야 합니다.\(SHOULD\)

---
## **9.2 Server Behavior**

CANCEL 메소드는 서버 측의 TU가 보류 중인 트랜잭션을 취소하도록 요청합니다. TU는 CANCEL 요청을 받은 후 요청 방법이 CANCEL 또는 ACK가 아닌 것으로 가정하고 섹션 17.2.3의 트랜잭션 일치 절차를 적용하여 취소할 트랜잭션을 결정합니다. 일치하는 거래가 취소될 거래입니다.

서버에서의 CANCEL 요청 처리는 서버 유형에 따라 다릅니다. 상태 비저장 프록시는 이를 전달하고 상태 저장 프록시는 이에 응답하여 자체적으로 일부 CANCEL 요청을 생성할 수 있으며 UAS는 이에 응답합니다. CANCEL의 대리 처리에 대해서는 섹션 16.10을 참조하십시오.

UAS는 먼저 섹션 8.2에 설명된 일반 UAS 처리에 따라 CANCEL 요청을 처리합니다. 그러나 CANCEL 요청은 홉별로 이루어지며 다시 제출할 수 없으므로 Authorization 헤더 필드에서 적절한 자격 증명을 얻기 위해 서버에서 요청을 요청할 수 없습니다. 또한 CANCEL 요청에는 Require 헤더 필드가 포함되어 있지 않습니다.

UAS가 위 절차에 따라 CANCEL에 일치하는 트랜잭션을 찾지 못한 경우 481\(Call Leg/Transaction Does Not Exist\)로 CANCEL에 응답해야 합니다. 원래 요청에 대한 트랜잭션이 여전히 존재하는 경우 취소 요청을 받을 때 UAS의 동작은 원래 요청에 대한 최종 응답을 이미 보냈는지 여부에 따라 달라집니다. 그렇다면 CANCEL 요청은 원래 요청 처리, 세션 상태 및 원래 요청에 대해 생성된 응답에 영향을 주지 않습니다. UAS가 원래 요청에 대한 최종 응답을 발행하지 않은 경우 해당 동작은 원래 요청 방법에 따라 달라집니다. 원래 요청이 INVITE인 경우 UAS는 즉시 487\(요청 종료됨\)로 INVITE에 응답해야 합니다. CANCEL 요청은 이 사양에 정의된 다른 방법을 사용한 트랜잭션 처리에 영향을 미치지 않습니다.\(SHOULD, SHOULD\)

원래 요청의 방법에 관계없이 CANCEL이 기존 트랜잭션과 일치하는 한 UAS는 CANCEL 요청 자체에 200\(OK\) 응답으로 응답합니다. 이 응답은 CANCEL에 대한 응답의 To 태그와 원래 요청에 대한 응답의 To 태그가 동일해야 한다는 점을 지적하는 섹션 8.2.6에 설명된 절차에 따라 구성됩니다. CANCEL에 대한 응답은 전송을 위해 서버 트랜잭션으로 전달됩니다.\(SHOULD\)

---
# **10 Registrations**
---
## **10.1 Overview**

SIP는 검색 기능을 제공합니다. 사용자가 다른 사용자와 세션을 시작하려는 경우 SIP는 대상 사용자가 연결할 수 있는 현재 호스트를 검색해야 합니다. 이 검색 프로세스는 요청 수신을 담당하는 프록시 서버 및 리디렉션 서버와 같은 SIP 네트워크 요소에 의해 자주 수행되며, 사용자 위치에 대한 지식을 기반으로 요청을 보낼 위치를 결정한 다음 해당 위치로 보냅니다. 이를 위해 SIP 네트워크 요소는 특정 도메인에 대한 주소 바인딩을 제공하는 위치 서비스라는 추상 서비스를 참조합니다. 이러한 주소 바인딩은 들어오는 SIP 또는 SIPS URI\(예: sip:bob@biloxi.com\)를 원하는 사용자에게 "더 가까운" 하나 이상의 URI\(예: sip:bob@engineering.biloxi.com\)에 매핑합니다. . 궁극적으로 프록시는 수신된 URI를 원하는 수신자가 현재 거주하고 있는 사용자 에이전트에 매핑하는 위치 서비스를 참조합니다.

등록하면 레코드 주소 URI를 하나 이상의 연락처 주소와 연결하는 특정 도메인에 대한 위치 서비스에 바인딩이 생성됩니다. 따라서 해당 도메인의 프록시가 요청 URI가 레코드 주소와 일치하는 요청을 받으면 프록시는 해당 레코드 주소에 등록된 연락처 주소로 요청을 전달합니다. 일반적으로 해당 레코드 주소에 대한 요청이 해당 도메인으로 라우팅되는 경우 도메인의 위치 서비스에 레코드 주소를 등록하는 것이 합리적입니다. 대부분의 경우 이는 등록 도메인이 레코드 주소 URI의 도메인과 일치해야 함을 의미합니다.

위치 서비스의 내용을 확립하는 방법에는 여러 가지가 있습니다. 한 가지 방법은 행정적입니다. 위의 예에서 Bob은 회사 데이터베이스에 대한 액세스를 통해 엔지니어링 부서의 구성원인 것으로 알려져 있습니다. 그러나 SIP는 UA가 명시적으로 바인딩을 생성할 수 있는 메커니즘을 제공합니다. 이 메커니즘을 등록이라고 합니다.

등록에는 등록기관으로 알려진 특별한 유형의 UAS에 REGISTER 요청을 보내는 작업이 수반됩니다. 등록자는 REGISTER 요청의 내용을 기반으로 매핑을 읽고 쓰는 도메인 위치 서비스의 프런트 엔드 역할을 합니다. 이 위치 서비스는 일반적으로 해당 도메인에 대한 요청 라우팅을 담당하는 프록시 서버에서 참조됩니다.

전체 등록 프로세스는 그림 2에 나와 있습니다. 등록자와 프록시 서버는 네트워크의 단일 장치에서 수행할 수 있는 논리적 역할입니다. 목적을 위해

이 그림에서는 두 가지가 명확하게 구분되어 있습니다. 또한 두 요소가 별도의 요소인 경우 UA는 등록 기관에 도달하기 위해 프록시 서버를 통해 요청을 보낼 수 있습니다.

SIP는 위치 서비스 구현을 위한 특정 메커니즘을 요구하지 않습니다. 유일한 요구 사항은 일부 도메인의 등록자가 위치 서비스에 대한 데이터를 읽고 쓸 수 있어야 하며 해당 도메인의 프록시 또는 리디렉션 서버가 동일한 데이터를 읽을 수 있어야 한다는 것입니다. 등록자는 동일한 도메인에 대해 특정 SIP 프록시 서버와 같은 위치에 있을 수 있습니다.\(MUST, MAY\)

---
## **10.2 Constructing the REGISTER Request**

REGISTER는 바인딩 추가, 제거 및 쿼리를 요청합니다. REGISTER 요청은 기록 주소와 하나 이상의 연락처 주소 사이에 새로운 바인딩을 추가할 수 있습니다. 특정 기록 주소를 대신하여 등록은 적절하게 승인된 제3자에 의해 수행될 수 있습니다. 클라이언트는 이전 바인딩을 제거하거나 레코드 주소에 대해 현재 어떤 바인딩이 있는지 확인하기 위해 쿼리할 수도 있습니다.

명시된 경우를 제외하고 REGISTER 요청의 구성과 REGISTER 요청을 보내는 클라이언트의 동작은 섹션 8.1 및 섹션 17.1에 설명된 일반적인 UAC 동작과 동일합니다.

REGISTER 요청은 대화 상자를 설정하지 않습니다. UAC는 섹션 8.1에 설명된 대로 기존 경로 집합을 기반으로 REGISTER 요청에 경로 헤더 필드를 포함할 수 있습니다. Record-Route 헤더 필드는 REGISTER 요청이나 응답에서 의미가 없으며 존재하는 경우 무시해야 합니다. 특히, UAC는 REGISTER 요청에 대한 응답에서 Record-Route 헤더 필드의 유무에 따라 새로운 경로 세트를 생성해서는 안 됩니다.\(MAY, MUST, MUST NOT\)

Contact를 제외한 다음 헤더 필드는 REGISTER 요청에 포함되어야 합니다. 연락처 헤더 필드는 다음과 같이 포함될 수 있습니다.\(MUST, MAY\)

- 요청-URI: 요청-URI는 등록이 의미되는 위치 서비스의 도메인 이름을 지정합니다\(예: "sip:chicago.com"\). SIP URI의 "userinfo" 및 "@" 구성 요소는 존재해서는 안 됩니다.\(MUST NOT\)

- To: To 헤더 필드에는 등록이 생성, 쿼리 또는 수정될 레코드의 주소가 포함됩니다. To 헤더 필드와 Request-URI 필드는 일반적으로 전자에 사용자 이름이 포함되어 있으므로 다릅니다. 이 레코드 주소는 SIP URI 또는 ​​SIPS URI여야 합니다.\(MUST\)

- From: From 헤더 필드에는 등록 담당자의 기록 주소가 포함됩니다. 요청이 제3자 등록이 아닌 이상 값은 To 헤더 필드와 동일합니다.

- Call-ID: UAC의 모든 등록은 특정 등록기관에 전송된 등록에 대해 동일한 Call-ID 헤더 필드 값을 사용해야 합니다.\(SHOULD\)

- 동일한 클라이언트가 다른 Call-ID 값을 사용하는 경우 등록자는 지연된 REGISTER 요청이 순서에 맞지 않게 도착했는지 여부를 감지할 수 없습니다.

- CSeq: CSeq 값은 REGISTER 요청의 올바른 순서를 보장합니다. UA는 동일한 Call-ID를 가진 각 REGISTER 요청에 대해 CSeq 값을 1씩 증가시켜야 합니다.\(MUST\)

- 연락처: REGISTER 요청에는 주소 바인딩을 포함하는 0개 이상의 값이 있는 연락처 헤더 필드가 포함될 수 있습니다.\(MAY\)

UA는 등록 기관으로부터 이전 항목에 대한 최종 응답을 수신하거나 이전 REGISTER 요청이 시간 초과될 때까지 새 등록\(즉, 재전송이 아닌 새 연락처 헤더 필드 값 포함\)을 보내서는 안 됩니다.\(MUST NOT\)

```text
                                                 bob
                                               +----+
                                               | UA |
                                               |    |
                                               +----+
                                                  |
                                                  |3)INVITE
                                                  |   carol@chicago.com
         chicago.com        +--------+            V
         +---------+ 2)Store|Location|4)Query +-----+
         |Registrar|=======>| Service|<=======|Proxy|sip.chicago.com
         +---------+        +--------+=======>+-----+
               A                      5)Resp      |
               |                                  |
               |                                  |
     1)REGISTER|                                  |
               |                                  |
            +----+                                |
            | UA |<-------------------------------+
   cube2214a|    |                            6)INVITE
            +----+                    carol@cube2214a.chicago.com
             carol

                      Figure 2: REGISTER example
```

- 다음 연락처 헤더 매개변수는 REGISTER 요청에서 특별한 의미를 갖습니다.

- action: RFC 2543의 "action" 매개변수는 더 이상 사용되지 않습니다. UAC는 "action" 매개변수를 사용해서는 안 됩니다.\(SHOULD NOT\)

- 만료: "만료" 매개변수는 UA가 바인딩이 유효하기를 원하는 기간을 나타냅니다. 값은 초를 나타내는 숫자입니다. 이 매개변수가 제공되지 않으면 Expires 헤더 필드의 값이 대신 사용됩니다. 구현에서는 2\*\*32-1\(4294967295초 또는 136년\)보다 큰 값을 2\*\*32-1과 동일하게 처리할 수 있습니다\(MAY\). 잘못된 값은 3600과 동일하게 처리되어야 합니다\(SHOULD\).\(MAY, SHOULD\)

---
### **10.2.1 Adding Bindings**

등록 대행자에게 전송된 REGISTER 요청에는 레코드 주소에 대한 SIP 요청이 전달되어야 하는 연락처 주소가 포함되어 있습니다. 레코드 주소는 REGISTER 요청의 To 헤더 필드에 포함됩니다.

요청의 연락처 헤더 필드 값은 일반적으로 특정 SIP 끝점을 식별하는 SIP 또는 SIPS URI로 구성되지만\(예: "sip:carol@cube2214a.chicago.com"\) 모든 URI 체계를 사용할 수 있습니다. 예를 들어, SIP UA는 전화번호\(tel URL, RFC 2806 \[9\] 포함\) 또는 이메일 주소\(mailto URL, RFC 2368 \[32\]\)를 기록 주소에 대한 연락처로 등록하도록 선택할 수 있습니다.\(MAY\)

예를 들어, 기록 주소가 "sip:carol@chicago.com"인 Carol은 도메인 Chicago.com의 SIP 등록 기관에 등록합니다. 그런 다음 그녀의 등록은 Chicago.com 도메인의 프록시 서버에서 Carol의 레코드 주소에 대한 요청을 그녀의 SIP 끝점으로 라우팅하는 데 사용됩니다.

클라이언트가 등록 기관에서 바인딩을 설정하면 필요에 따라 새로운 바인딩이나 기존 바인딩에 대한 수정 사항이 포함된 후속 등록을 보낼 수 있습니다. REGISTER 요청에 대한 2xx 응답의 연락처 헤더 필드에는 이 등록 기관에서 이 레코드 주소에 대해 등록된 전체 바인딩 목록이 포함됩니다.\(MAY\)

REGISTER 요청의 To 헤더 필드에 있는 레코드 주소가 SIPS URI인 경우 요청의 연락처 헤더 필드 값도 SIPS URI여야 합니다. 클라이언트는 연락처 주소로 표시되는 리소스의 보안이 다른 방법으로 보장되는 경우 SIPS 레코드 주소 아래에 SIPS가 아닌 URI만 등록해야 합니다. 이는 SIP 이외의 프로토콜을 호출하는 URI 또는 ​​TLS 이외의 프로토콜로 보호되는 SIP 장치에 적용될 수 있습니다.\(SHOULD\)

등록 시 모든 바인딩을 업데이트할 필요는 없습니다. 일반적으로 UA는 자체 연락처 주소만 업데이트합니다.

---
#### **10.2.1.1 Setting the Expiration Interval of Contact Addresses**

클라이언트가 REGISTER 요청을 보낼 때 클라이언트가 등록이 유효하기를 원하는 기간을 나타내는 만료 간격을 제안할 수 있습니다. \(섹션 10.3에 설명된 대로 등록자는 로컬 정책에 따라 실제 시간 간격을 선택합니다.\)\(MAY\)

클라이언트가 바인딩에 대한 만료 간격을 제안할 수 있는 방법에는 Expires 헤더 필드 또는 "expires" 연락처 헤더 매개변수를 통한 두 가지 방법이 있습니다. 후자는 단일 REGISTER 요청에 둘 이상의 바인딩이 제공되는 경우 바인딩별로 만료 간격을 제안하는 반면, 전자는 "만료" 매개변수를 포함하지 않는 모든 연락처 헤더 필드 값에 대한 만료 간격을 제안합니다.

제안된 만료 시간을 표현하는 메커니즘이 REGISTER에 없으면 클라이언트는 서버가 선택하기를 원하는 것을 나타냅니다.

---
#### **10.2.1.2 Preferences among Contact Addresses**

REGISTER 요청에서 둘 이상의 연락처가 전송되는 경우 등록 UA는 이러한 연락처 헤더 필드 값의 모든 URI를 To 필드에 있는 레코드 주소와 연결하려고 합니다. 이 목록은 연락처 헤더 필드의 "q" 매개변수를 사용하여 우선순위를 지정할 수 있습니다. "q" 매개변수는 이 레코드 주소에 대한 다른 바인딩과 비교하여 특정 연락처 헤더 필드 값에 대한 상대적 선호도를 나타냅니다. 섹션 16.6에서는 프록시 서버가 이 기본 설정 표시를 사용하는 방법을 설명합니다.

---
### **10.2.2 Removing Bindings**

등록은 소프트 상태이며 새로 고치지 않으면 만료되지만 명시적으로 제거할 수도 있습니다. 클라이언트는 섹션 10.2.1에 설명된 대로 등록자가 선택한 만료 간격에 영향을 주려고 시도할 수 있습니다. UA는 REGISTER 요청에서 해당 연락처 주소에 대해 만료 간격을 "0"으로 지정하여 바인딩을 즉시 제거하도록 요청합니다. UA는 만료 간격이 지나기 전에 바인딩을 제거할 수 있도록 이 메커니즘을 지원해야 합니다.\(SHOULD\)

REGISTER별 Contact 헤더 필드 값 "\*"은 모든 등록에 적용되지만 Expires 헤더 필드가 "0" 값으로 존재하지 않는 한 이를 사용해서는 안 됩니다.\(MUST NOT\)

- "\*" 연락처 헤더 필드 값을 사용하면 등록하는 UA가 정확한 값을 알지 못해도 레코드 주소와 관련된 모든 바인딩을 제거할 수 있습니다.

---
### **10.2.3 Fetching Bindings**

REGISTER 요청에 대한 성공 응답에는 요청에 연락처 헤더 필드가 포함되어 있는지 여부에 관계없이 기존 바인딩의 전체 목록이 포함됩니다. REGISTER 요청에 Contact 헤더 필드가 없으면 바인딩 목록은 변경되지 않은 채로 유지됩니다.

---
### **10.2.4 Refreshing Bindings**

각 UA는 이전에 설정한 바인딩을 새로 고치는 일을 담당합니다. UA는 다른 UA가 설정한 바인딩을 새로 고쳐서는 안 됩니다.\(SHOULD NOT\)

등록자의 200\(OK\) 응답에는 현재 바인딩을 모두 나열하는 연락처 필드 목록이 포함되어 있습니다. UA는 섹션 19.1.4의 비교 규칙을 사용하여 각 연락처 주소를 비교하여 연락처 주소를 생성했는지 확인합니다. 그렇다면 만료 매개변수에 따라 만료 시간 간격을 업데이트하고, 없는 경우 만료 필드 값을 업데이트합니다. 그런 다음 UA는 만료 간격이 경과하기 전에 각 바인딩에 대해 REGISTER 요청을 발행합니다. 여러 업데이트를 하나의 REGISTER 요청으로 결합할 수 있습니다.\(MAY\)

UA는 단일 부팅 주기 동안 모든 등록에 대해 동일한 호출 ID를 사용해야 합니다. 리디렉션되지 않는 한 등록 새로 고침은 원래 등록과 동일한 네트워크 주소로 전송되어야 합니다.\(SHOULD, SHOULD\)

---
### **10.2.5 Setting the Internal Clock**

REGISTER 요청에 대한 응답에 Date 헤더 필드가 포함되어 있는 경우 클라이언트는 내부 시계를 설정하기 위해 이 헤더 필드를 사용하여 현재 시간을 학습할 수 있습니다.\(MAY\)

---
### **10.2.6 Discovering a Registrar**

UA는 등록을 보낼 주소를 결정하기 위해 구성, 레코드 주소 사용, 멀티캐스트 등 세 가지 방법을 사용할 수 있습니다. UA는 등록자 주소를 사용하여 이 사양의 범위를 벗어나는 방식으로 구성될 수 있습니다. 구성된 등록자 주소가 없는 경우 UA는 레코드 주소의 호스트 부분을 요청-URI로 사용하고 일반적인 SIP 서버 위치 메커니즘\[4\]을 사용하여 거기에서 요청을 처리해야 합니다. 예를 들어 사용자 "sip:carol@chicago.com"에 대한 UA는 REGISTER 요청을 "sip:chicago.com"으로 지정합니다.\(SHOULD\)

마지막으로 멀티캐스트를 사용하도록 UA를 구성할 수 있습니다. 멀티캐스트 등록은 잘 알려진 "모든 SIP 서버" 멀티캐스트 주소 "sip.mcast.net"\(IPv4의 경우 224.0.1.75\)으로 주소가 지정됩니다. 잘 알려진 IPv6 멀티캐스트 주소가 할당되지 않았습니다. 그러한 할당은 필요할 때 별도로 문서화됩니다. SIP UA는 해당 주소를 수신하고 이를 사용하여 다른 로컬 사용자의 위치를 ​​인식할 수 있습니다\(\[33\] 참조\). 그러나 요청에 응답하지 않습니다.\(MAY\)

- 멀티캐스트 등록은 일부 환경\(예: 여러 기업이 동일한 LAN을 공유하는 경우\)에서는 부적절할 수 있습니다.

---
### **10.2.7 Transmitting a Request**

REGISTER 메서드가 구성되고 메시지 대상이 식별되면 UAC는 섹션 8.1.2에 설명된 절차에 따라 REGISTER를 트랜잭션 계층으로 전달합니다.

REGISTER가 응답을 생성하지 않아 트랜잭션 계층이 시간 초과 오류를 반환하는 경우 UAC는 동일한 등록자에 대한 등록을 즉시 다시 시도해서는 안 됩니다.\(SHOULD NOT\)

- 즉시 재시도해도 시간 초과가 발생할 수 있습니다. 시간 초과가 수정되는 조건에 대해 합리적인 시간 간격을 기다리면 네트워크의 불필요한 부하가 줄어듭니다. 특정 간격이 필수는 아닙니다.

---
### **10.2.8 Error Responses**

UA가 423\(간격이 너무 짧음\) 응답을 수신하는 경우 REGISTER 요청의 모든 연락처 주소의 만료 간격을 423의 Min-Expires 헤더 필드 내 만료 간격보다 크거나 같게 만든 후 등록을 재시도할 수 있습니다. 간격이 너무 짧음\) 응답.\(MAY\)

---
## **10.3 Processing REGISTER Requests**

등록자는 REGISTER 요청에 응답하고 관리 도메인 내의 프록시 서버 및 리디렉션 서버에 액세스할 수 있는 바인딩 목록을 유지 관리하는 UAS입니다. 레지스트라는 섹션 8.2 및 섹션 17.2에 따라 요청을 처리하지만 REGISTER 요청만 허용합니다. 등록자는 6xx 응답을 생성해서는 안 됩니다.\(MUST\)

등록자는 REGISTER 요청을 적절하게 리디렉션할 수 있습니다. 일반적인 사용법 중 하나는 멀티캐스트 인터페이스를 수신하는 등록자가 멀티캐스트 REGISTER 요청을 302\(임시 이동\) 응답을 사용하여 자체 유니캐스트 인터페이스로 리디렉션하는 것입니다.\(MAY\)

등록 기관은 REGISTER 요청에 Record-Route 헤더 필드가 포함된 경우 해당 필드를 무시해야 합니다. 등록 기관은 REGISTER 요청에 대한 응답에 Record-Route 헤더 필드를 포함해서는 안 됩니다.\(MUST, MUST NOT\)

- 등록자는 REGISTER를 알 수 없는 요청으로 처리하고 Record-Route 헤더 필드 값을 추가하는 프록시를 통과하는 요청을 수신할 수 있습니다.

등록자는 바인딩을 유지 관리하는 도메인 집합을 알아야 합니다\(예: 구성을 통해\). REGISTER 요청은 수신된 순서대로 등록기관에 의해 처리되어야 합니다. REGISTER 요청은 또한 원자적으로 처리되어야 합니다. 즉, 특정 REGISTER 요청은 완전히 처리되거나 전혀 처리되지 않습니다. 각 REGISTER 메시지는 다른 등록 또는 바인딩 변경과 독립적으로 처리되어야 합니다.\(MUST, MUST, MUST\)

REGISTER 요청을 받으면 등록기관은 다음 단계를 따릅니다.

- 1. 등록자는 Request-URI에서 식별된 도메인에 대한 바인딩에 액세스할 수 있는지 확인하기 위해 Request-URI를 검사합니다. 그렇지 않고 서버가 프록시 서버 역할도 하는 경우 서버는 섹션 16에 설명된 프록시 메시지에 대한 일반적인 동작에 따라 주소가 지정된 도메인으로 요청을 전달해야 합니다.\(SHOULD\)

2. 등록기관이 필요한 모든 지원을 보장하기 위해

- 확장, 등록자는 섹션 8.2.2에서 UAS에 대해 설명된 대로 요구 헤더 필드 값을 처리해야 합니다.\(MUST\)

- 3. 등록자는 UAC를 인증해야 합니다. SIP 사용자 에이전트 인증 메커니즘은 섹션 22에 설명되어 있습니다. 등록 동작은 결코 SIP의 일반 인증 프레임워크를 재정의하지 않습니다. 인증 메커니즘을 사용할 수 없는 경우 등록 기관은 요청 발신자의 주장된 신원으로 보낸 사람 주소를 사용할 수 있습니다.\(SHOULD, MAY\)

- 4. 등록기관은 인증된 사용자가 이 기록 주소에 대한 등록을 수정할 권한이 있는지 확인해야 합니다. 예를 들어, 등록 기관은 사용자 이름을 해당 사용자가 바인딩 수정 권한을 가지고 있는 기록 주소 목록에 매핑하는 권한 데이터베이스를 참조할 수 있습니다. 인증된 사용자에게 바인딩 수정 권한이 없는 경우 등록 기관은 403\(금지됨\)을 반환하고 나머지 단계를 건너뛰어야 합니다.\(SHOULD, MUST\)

- 제3자 등록을 지원하는 아키텍처에서는 한 개체가 여러 기록 주소와 관련된 등록을 업데이트하는 일을 담당할 수 있습니다.

- 5. 등록자는 요청의 To 헤더 필드에서 레코드 주소를 추출합니다. 요청-URI의 도메인에 대한 레코드 주소가 유효하지 않은 경우 등록 기관은 404\(찾을 수 없음\) 응답을 보내고 나머지 단계를 건너뛰어야 합니다. 그러면 URI는 정식 형식으로 변환되어야 합니다. 이를 위해서는 모든 URI 매개변수\(user-param 포함\)를 제거해야 하며, 이스케이프된 모든 문자를 이스케이프되지 않은 형식으로 변환해야 합니다. 결과는 바인딩 목록에 대한 색인 역할을 합니다.\(MUST, MUST, MUST\)

- 6. 등록자는 요청에 연락처 헤더 필드가 포함되어 있는지 확인합니다. 그렇지 않은 경우 마지막 단계로 건너뜁니다. 연락처 헤더 필드가 있는 경우 등록자는 특수 값 "\*"과 만료 필드를 포함하는 연락처 필드 값이 하나 있는지 확인합니다. 요청에 추가 연락처 필드가 있거나 0이 아닌 만료 시간이 있는 경우 요청은 유효하지 않으며 서버는 400\(잘못된 요청\)을 반환하고 나머지 단계를 건너뛰어야 합니다. 그렇지 않은 경우 등록자는 Call-ID가 각 바인딩에 대해 저장된 값과 일치하는지 확인합니다. 그렇지 않은 경우 바인딩을 제거해야 합니다. 동의하는 경우 요청의 CSeq가 해당 바인딩에 대해 저장된 값보다 높은 경우에만 바인딩을 제거해야 합니다. 그렇지 않으면 업데이트가 중단되어야 하며 요청이 실패합니다.\(MUST, MUST, MUST, MUST\)

- 7. 이제 등록자는 연락처 헤더 필드의 각 연락처 주소를 차례로 처리합니다. 각 주소에 대해 다음과 같이 만료 간격을 결정합니다.

- - 필드 값에 "만료" 매개변수가 있는 경우 해당 값은 요청된 만료로 간주되어야 합니다.\(MUST\)

- - 그러한 매개변수는 없지만 요청에 Expires 헤더 필드가 있는 경우 해당 값은 요청된 만료로 간주되어야 합니다.\(MUST\)

- - 둘 다 없으면 로컬로 구성된 기본값을 요청된 만료로 사용해야 합니다.\(MUST\)

- 등록자는 요청된 만료 간격보다 짧은 만료를 선택할 수 있습니다. 요청된 만료 간격이 0보다 크고 1시간보다 작으며 등록 기관이 구성한 최소값보다 작은 경우에만 등록 기관은 423\(간격이 너무 짧음\) 응답으로 등록을 거부할 수 있습니다. 이 응답에는 등록자가 준수하려는 최소 만료 간격을 명시하는 Min-Expires 헤더 필드가 포함되어야 합니다. 그런 다음 나머지 단계를 건너뜁니다.\(MAY, MAY, MUST\)

- 등록자가 등록 간격을 설정하도록 허용하면 지나치게 빈번한 등록 새로 고침으로부터 등록자를 보호하는 동시에 유지해야 하는 상태를 제한하고 등록이 오래될 가능성을 줄입니다. 등록 만료 간격은 서비스 생성에 자주 사용됩니다. 사용자가 짧은 기간 동안만 터미널에서 사용할 수 있는 팔로우미 서비스를 예로 들 수 있습니다. 따라서 등록기관은 간단한 등록을 수락해야 합니다. 간격이 너무 짧아 새로 고침으로 인해 등록 기관 성능이 저하되는 경우에만 요청을 거부해야 합니다.

- 각 주소에 대해 등록자는 URI 비교 규칙을 사용하여 현재 바인딩 목록을 검색합니다. 바인딩이 존재하지 않으면 임시로 추가됩니다. 바인딩이 존재하는 경우 등록자는 Call-ID 값을 확인합니다. 기존 바인딩의 Call-ID 값이 요청의 Call-ID 값과 다른 경우 만료 시간이 0이면 바인딩을 제거하고 그렇지 않으면 업데이트해야 합니다. 동일한 경우 등록자는 CSeq 값을 비교합니다. 값이 기존 바인딩보다 높은 경우 위와 같이 바인딩을 업데이트하거나 제거해야 합니다. 그렇지 않은 경우 업데이트를 중단해야 하며 요청이 실패합니다.\(MUST, MUST, MUST\)

- 이 알고리즘은 동일한 UA의 순서가 잘못된 요청이 무시되도록 보장합니다.

- 각 바인딩 레코드는 요청의 Call-ID 및 CSeq 값을 기록합니다.

- 바인딩 업데이트는 모든 바인딩 업데이트 및 추가가 성공한 경우에만 커밋되어야 합니다\(즉, 프록시 또는 리디렉션 서버에 표시되어야 함\). 그 중 하나라도 실패하면\(예를 들어 백엔드 데이터베이스 커밋이 실패했기 때문에\) 요청은 500\(서버 오류\) 응답으로 실패해야 하며 모든 임시 바인딩 업데이트를 제거해야 합니다.\(MUST, MUST\)

- 8. 등록자는 200\(OK\) 응답을 반환합니다. 응답에는 모든 현재 바인딩을 열거하는 연락처 헤더 필드 값이 포함되어야 합니다. 각 연락처 값에는 등록자가 선택한 만료 간격을 나타내는 "만료" 매개변수가 있어야 합니다. 응답에는 날짜 헤더 필드가 포함되어야 합니다.\(MUST, MUST, SHOULD\)

---
# **11 Querying for Capabilities**

SIP 방법 OPTIONS를 사용하면 UA가 다른 UA 또는 프록시 서버에 해당 기능에 대해 쿼리할 수 있습니다. 이를 통해 클라이언트는 상대방에게 "벨을 울리지" 않고 지원되는 방법, 콘텐츠 유형, 확장, 코덱 등에 대한 정보를 검색할 수 있습니다. 예를 들어 클라이언트가 대상 UAS가 지원하는지 확실하지 않은 옵션을 나열하는 INVITE에 Require 헤더 필드를 삽입하기 전에 클라이언트는 OPTIONS를 사용하여 대상 UAS를 쿼리하여 이 옵션이 지원되는 헤더 필드에 반환되는지 확인할 수 있습니다. 모든 UA는 OPTIONS 메서드를 지원해야 합니다.\(MUST\)

OPTIONS 요청의 대상은 다른 UA 또는 SIP 서버를 식별할 수 있는 Request-URI로 식별됩니다. OPTIONS가 프록시 서버로 지정되는 경우 Request-URI는 REGISTER 요청에 대해 Request-URI가 설정되는 방식과 유사하게 사용자 부분 없이 설정됩니다.

대안으로 Max-Forwards 헤더 필드 값이 0인 OPTIONS 요청을 수신하는 서버는 Request-URI에 관계없이 요청에 응답할 수 있습니다.\(MAY\)

- 이 동작은 HTTP/1.1에서 일반적입니다. 이 동작은 Max-Forwards 값이 증가된 일련의 OPTIONS 요청을 보내 개별 홉 서버의 기능을 확인하는 "traceroute" 기능으로 사용할 수 있습니다.

일반적인 UA 동작의 경우와 마찬가지로 트랜잭션 계층은 OPTIONS가 응답을 생성하지 않으면 시간 초과 오류를 반환할 수 있습니다. 이는 대상에 도달할 수 없으므로 사용할 수 없음을 나타낼 수 있습니다.

OPTIONS 요청은 나중에 대화에서 활용될 수 있는 기능에 대해 피어에게 쿼리하기 위해 설정된 대화의 일부로 전송될 수 있습니다.\(MAY\)

---
## **11.1 Construction of OPTIONS Request**

OPTIONS 요청은 섹션 8.1.1에 설명된 대로 SIP 요청에 대한 표준 규칙을 사용하여 구성됩니다.

연락처 헤더 필드는 OPTIONS에 존재할 수 있습니다.\(MAY\)

UAC가 응답에서 수신하기를 원하는 메시지 본문 유형을 나타내기 위해 Accept 헤더 필드가 포함되어야 합니다. 일반적으로 이는 SDP\(application/sdp\)와 같은 UA의 미디어 기능을 설명하는 데 사용되는 형식으로 설정됩니다.\(SHOULD\)

OPTIONS 요청에 대한 응답은 원래 요청의 Request-URI로 범위가 지정되는 것으로 가정됩니다. 그러나 OPTIONS가 설정된 대화의 일부로 전송되는 경우에만 OPTIONS 응답을 생성한 서버가 향후 요청을 수신한다는 것이 보장됩니다.

```text
   Example OPTIONS request:

      OPTIONS sip:carol@chicago.com SIP/2.0
      Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKhjhs8ass877
      Max-Forwards: 70
      To: <sip:carol@chicago.com>
      From: Alice <sip:alice@atlanta.com>;tag=1928301774
      Call-ID: a84b4c76e66710
      CSeq: 63104 OPTIONS
      Contact: <sip:alice@pc33.atlanta.com>
      Accept: application/sdp
      Content-Length: 0
```

---
## **11.2 Processing of OPTIONS Request**

OPTIONS에 대한 응답은 섹션 8.2.6에서 설명한 SIP 응답에 대한 표준 규칙을 사용하여 구성됩니다. 선택한 응답 코드는 요청이 INVITE인 경우 선택되었을 응답 코드와 동일해야 합니다. 즉, UAS가 통화를 수락할 준비가 되면 200\(OK\)이 반환되고, UAS가 통화 중이면 486\(Busy Here\)이 반환됩니다. 이를 통해 OPTIONS 요청을 사용하여 기본 요청을 결정할 수 있습니다. 이는 UAS가 INVITE 요청을 수락할지 여부를 나타낼 수 있는 UAS 상태입니다.\(MUST\)

대화 상자 내에서 수신된 OPTIONS 요청은 대화 상자 외부에서 구성된 응답과 동일하고 대화 상자에 영향을 주지 않는 200\(OK\) 응답을 생성합니다.

이러한 OPTIONS 사용에는 OPTIONS 및 INVITE 요청의 프록시 처리 차이로 인해 제한이 있습니다. 분기된 INVITE는 여러 개의 200\(OK\) 응답을 반환할 수 있지만 분기된 OPTIONS는 비INVITE 처리를 사용하는 프록시에서 처리되므로 단일 200\(OK\) 응답만 반환합니다. 규범적인 세부사항은 섹션 16.7을 참조하십시오.

OPTIONS에 대한 응답이 프록시 서버에 의해 생성되면 프록시는 서버의 기능을 나열하는 200\(OK\)을 반환합니다. 응답에 메시지 본문이 포함되어 있지 않습니다.

Allow, Accept, Accept-Encoding, Accept-Language 및 Supported 헤더 필드는 OPTIONS 요청에 대한 200\(OK\) 응답에 있어야 합니다. 응답이 프록시에 의해 생성된 경우 프록시는 메소드에 구애받지 않으므로 모호하므로 Allow 헤더 필드를 생략해야 합니다. 연락처 헤더 필드는 200\(OK\) 응답에 존재할 수 있으며 3xx 응답과 동일한 의미를 가질 수 있습니다. 즉, 대체 이름과 사용자에게 접근하는 방법을 나열할 수 있습니다. 경고 헤더 필드가 존재할 수 있습니다.\(SHOULD, SHOULD, MAY, MAY\)

메시지 본문이 전송될 수 있으며, 그 유형은 OPTIONS 요청의 Accept 헤더 필드에 의해 결정됩니다\(Accept 헤더 필드가 없는 경우 application/sdp가 기본값입니다\). 유형에 미디어 기능을 설명할 수 있는 유형이 포함된 경우 UAS는 해당 목적을 위한 응답에 본문을 포함해야 합니다. application/sdp의 경우 이러한 몸체의 구성에 대한 자세한 내용은 \[13\]에 설명되어 있습니다.\(MAY, SHOULD\)

UAS에 의해 생성된 OPTIONS 응답 예시\(섹션 11.1의 요청에 해당\):

```text
      SIP/2.0 200 OK
      Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKhjhs8ass877
       ;received=192.0.2.4
      To: <sip:carol@chicago.com>;tag=93810874
      From: Alice <sip:alice@atlanta.com>;tag=1928301774
      Call-ID: a84b4c76e66710
      CSeq: 63104 OPTIONS
      Contact: <sip:carol@chicago.com>
      Contact: <mailto:carol@chicago.com>
      Allow: INVITE, ACK, CANCEL, OPTIONS, BYE
      Accept: application/sdp
      Accept-Encoding: gzip
      Accept-Language: en
      Supported: foo
      Content-Type: application/sdp
      Content-Length: 274

      (SDP not shown)
```

---
# **12 Dialogs**

사용자 에이전트의 주요 개념은 대화 상자의 개념입니다. 대화 상자는 한동안 지속되는 두 사용자 에이전트 간의 P2P SIP 관계를 나타냅니다. 대화 상자는 사용자 에이전트 간의 메시지 순서 지정과 둘 사이의 적절한 요청 라우팅을 용이하게 합니다. 대화 상자는 SIP 메시지를 해석하는 컨텍스트를 나타냅니다. 섹션 8에서는 대화 외부의 요청 및 응답에 대한 방법 독립적인 UA 처리에 대해 논의했습니다. 이 섹션에서는 이러한 요청과 응답을 사용하여 대화 상자를 구성하는 방법과 후속 요청 및 응답이 대화 상자 내에서 전송되는 방법에 대해 설명합니다.

대화는 호출 ID 값, 로컬 태그 및 원격 태그로 구성된 대화 ID를 사용하여 각 UA에서 식별됩니다. 대화에 관련된 각 UA의 대화 ID는 동일하지 않습니다. 특히 한 UA의 로컬 태그는 피어 UA의 원격 태그와 동일합니다. 태그는 고유한 대화 ID 생성을 용이하게 하는 불투명 토큰입니다.

대화 ID는 모든 응답 및 받는 사람 필드에 태그가 포함된 요청과도 연결됩니다. 메시지의 대화 ID를 계산하는 규칙은 SIP 요소가 UAC인지 UAS인지에 따라 달라집니다. UAC의 경우 대화 ID의 Call-ID 값은 메시지의 Call-ID로 설정되고, 원격 태그는 메시지의 To 필드에 있는 태그로 설정되며, 로컬 태그는 메시지의 To 필드에 있는 태그로 설정됩니다. 에서

메시지 필드\(이 규칙은 요청과 응답 모두에 적용됩니다\). UAS에서 예상할 수 있듯이 대화 ID의 Call-ID 값은 메시지의 Call-ID로 설정되고 원격 태그는 메시지의 From 필드에 있는 태그로 설정되며 로컬 태그는 설정됩니다. 메시지의 받는 사람 필드에 있는 태그에 추가합니다.

대화 상자에는 대화 상자 내에서 추가 메시지 전송에 필요한 특정 상태가 포함되어 있습니다. 이 상태는 대화 ID, 로컬 시퀀스 번호\(UA에서 피어로 요청을 정렬하는 데 사용됨\), 원격 시퀀스 번호\(피어에서 UA로 요청을 정렬하는 데 사용됨\), 로컬 URI, 원격 URI로 구성됩니다. 원격 대상, "secure"라는 부울 플래그, 순서가 지정된 URI 목록인 경로 세트입니다. 경로 세트는 피어에게 요청을 보내기 위해 통과해야 하는 서버 목록입니다. 대화는 임시 응답으로 생성될 때 발생하는 "초기" 상태에 있을 수 있으며, 2xx 최종 응답이 도착하면 "확인" 상태로 전환됩니다. 다른 응답의 경우 또는 해당 대화 상자에 전혀 응답이 도착하지 않으면 초기 대화가 종료됩니다.

---
## **12.1 Creation of a Dialog**

특정 메소드를 사용하여 요청에 대한 무실패 응답 생성을 통해 대화 상자가 생성됩니다. 이 사양 내에서 요청이 INVITE인 To 태그가 있는 2xx 및 101-199 응답만 대화 상자를 설정합니다. 요청에 대한 최종이 아닌 응답으로 설정된 대화는 "초기" 상태에 있으며 이를 초기 대화라고 합니다. 확장은 대화 상자를 생성하기 위한 다른 수단을 정의할 수 있습니다. 섹션 13에서는 INVITE 메서드와 관련된 자세한 내용을 제공합니다. 여기에서는 메소드에 의존하지 않는 대화 상태를 생성하는 프로세스를 설명합니다.\(MAY\)

UA는 아래 설명된 대로 대화 ID 구성 요소에 값을 할당해야 합니다.\(MUST\)

---
### **12.1.1 UAS behavior**

UAS가 대화 상자\(예: INVITE에 대한 2xx\)를 설정하는 응답으로 요청에 응답할 때 UAS는 요청의 모든 Record-Route 헤더 필드 값\(URI, URI 매개변수 및 모든 항목 포함\)을 응답에 복사해야 합니다. UAS에 알려졌는지 알려지지 않았는지에 관계없이 Record-Route 헤더 필드 매개변수\) 및 해당 값의 순서를 유지해야 합니다. UAS는 응답에 Contact 헤더 필드를 추가해야 합니다. 연락처 헤더 필드에는 대화 상자의 후속 요청\(INVITE의 경우 2xx 응답에 대한 ACK 포함\)에 대해 UAS가 연결되기를 원하는 주소가 포함되어 있습니다. 일반적으로 이 URI의 호스트 부분은 호스트의 IP 주소 또는 FQDN입니다. 연락처 헤더 필드에 제공된 URI는 SIP 또는 SIPS URI여야 합니다. 대화 상자를 시작한 요청에 다음이 포함된 경우\(MUST, MUST, MUST\)

Request-URI 또는 ​​최상위 Record-Route 헤더 필드 값\(있는 경우\)의 SIPS URI, Record-Route 헤더 필드가 없는 경우 Contact 헤더 필드, 응답의 Contact 헤더 필드는 SIPS URI여야 합니다. . URI는 전역 범위를 가져야 합니다\(즉, 이 대화 상자 외부의 메시지에 동일한 URI를 사용할 수 있음\). 마찬가지로 INVITE의 Contact 헤더 필드에 있는 URI의 범위도 이 대화 상자로 제한되지 않습니다. 따라서 이 대화 상자 외부에서도 UAC에 보내는 메시지에 사용할 수 있습니다.\(MUST, SHOULD\)

그런 다음 UAS는 대화 상자의 상태를 구성합니다. 이 상태는 대화 기간 동안 유지되어야 합니다.\(MUST\)

요청이 TLS를 통해 도착했고 요청-URI에 SIPS URI가 포함된 경우 "보안" 플래그가 TRUE로 설정됩니다.

경로 세트는 요청의 Record-Route 헤더 필드에 있는 URI 목록으로 설정되어야 하며, 순서대로 취해지고 모든 URI 매개변수를 보존해야 합니다. 요청에 Record-Route 헤더 필드가 없으면 경로 세트는 빈 세트로 설정되어야 합니다. 이 경로 집합은 비어 있더라도 이 대화 상자의 향후 요청에 대해 설정된 기존 경로를 재정의합니다. 원격 대상은 요청의 연락처 헤더 필드에 있는 URI로 설정되어야 합니다.\(MUST, MUST, MUST\)

원격 시퀀스 번호는 요청의 CSeq 헤더 필드에 있는 시퀀스 번호 값으로 설정되어야 합니다. 로컬 시퀀스 번호는 비어 있어야 합니다. 대화 ID의 통화 식별자 구성 요소는 요청의 Call-ID 값으로 설정되어야 합니다. 대화 상자 ID의 로컬 태그 구성 요소는 요청에 대한 응답\(항상 태그 포함\)의 To 필드에 있는 태그로 설정되어야 하며, 대화 상자 ID의 원격 태그 구성 요소는 From의 태그로 설정되어야 합니다. 요청의 필드입니다. UAS는 From 필드에 태그 없이 요청을 수신할 준비가 되어 있어야 합니다. 이 경우 태그는 null 값을 갖는 것으로 간주됩니다.\(MUST, MUST, MUST, MUST, MUST\)

- 이는 From 태그를 의무화하지 않은 RFC 2543과의 하위 호환성을 유지하기 위한 것입니다.

원격 URI는 보낸 사람 필드의 URI로 설정되어야 하며, 로컬 URI는 받는 사람 필드의 URI로 설정되어야 합니다.\(MUST\)

---
### **12.1.2 UAC Behavior**

UAC가 대화 상자\(예: INVITE\)를 설정할 수 있는 요청을 보낼 때 연락처 헤더 필드에 전역 범위의 SIP 또는 SIPS URI\(즉, 이 대화 상자 외부의 메시지에 동일한 SIP URI를 사용할 수 있음\)를 제공해야 합니다. 요청. 요청에 Request-URI 또는 ​​SIPS URI가 포함된 최상위 경로 헤더 필드 값이 있는 경우 연락처 헤더 필드에는 SIPS URI가 포함되어야 합니다.\(MUST, MUST\)

UAC는 대화 상자를 설정하는 응답을 받으면 대화 상자의 상태를 구성합니다. 이 상태는 대화 기간 동안 유지되어야 합니다.\(MUST\)

요청이 TLS를 통해 전송되었고 요청-URI에 SIPS URI가 포함된 경우 "보안" 플래그가 TRUE로 설정됩니다.

경로 세트는 응답의 Record-Route 헤더 필드에 있는 URI 목록으로 설정되어야 하며, 역순으로 취해지고 모든 URI 매개변수를 보존해야 합니다. 응답에 Record-Route 헤더 필드가 없으면 경로 세트는 빈 세트로 설정되어야 합니다. 이 경로 집합은 비어 있더라도 이 대화 상자의 향후 요청에 대해 설정된 기존 경로를 재정의합니다. 원격 대상은 응답의 연락처 헤더 필드에 있는 URI로 설정되어야 합니다.\(MUST, MUST, MUST\)

로컬 시퀀스 번호는 요청의 CSeq 헤더 필드에 있는 시퀀스 번호 값으로 설정되어야 합니다. 원격 시퀀스 번호는 비어 있어야 합니다\(원격 UA가 대화 상자 내에서 요청을 보낼 때 설정됨\). 대화 ID의 통화 식별자 구성 요소는 요청의 Call-ID 값으로 설정되어야 합니다. 대화 상자 ID의 로컬 태그 구성 요소는 요청의 보낸 사람 필드에 있는 태그로 설정되어야 하며, 대화 상자 ID의 원격 태그 구성 요소는 응답의 받는 사람 필드에 있는 태그로 설정되어야 합니다. UAC는 To 필드에 태그 없이 응답을 수신할 준비가 되어 있어야 합니다. 이 경우 태그는 null 값을 갖는 것으로 간주됩니다.\(MUST, MUST, MUST, MUST, MUST\)

- 이는 To 태그를 의무화하지 않은 RFC 2543과의 하위 호환성을 유지하기 위한 것입니다.

원격 URI는 To 필드의 URI로 설정되어야 하며, 로컬 URI는 From 필드의 URI로 설정되어야 합니다.\(MUST\)

---
## **12.2 Requests within a Dialog**

두 UA 간에 대화가 설정되면 둘 중 하나가 대화 내에서 필요에 따라 새 트랜잭션을 시작할 수 있습니다. 요청을 보내는 UA는 트랜잭션에 대한 UAC 역할을 맡습니다. 요청을 받은 UA는 UAS 역할을 맡게 됩니다. 이는 대화를 설정한 트랜잭션 중에 보유한 UA와는 다른 역할일 수 있습니다.\(MAY\)

대화 상자 내의 요청에는 Record-Route 및 Contact 헤더 필드가 포함될 수 있습니다. 그러나 이러한 요청으로 인해 원격 대상 URI가 수정될 수는 있지만 대화의 경로 집합이 수정되지는 않습니다. 특히 대상 새로 고침 요청이 아닌 요청은 대화 상자의 원격 대상 URI를 수정하지 않으며 대상 새로 고침 요청인 요청은 수정합니다. 다음으로 설정된 대화 상자의 경우\(MAY\)

INVITE, 정의된 유일한 대상 새로 고침 요청은 re-INVITE입니다\(섹션 14 참조\). 다른 확장은 다른 방식으로 설정된 대화 상자에 대해 다른 대상 새로 고침 요청을 정의할 수 있습니다.

- ACK는 대상 새로 고침 요청이 아닙니다.

대상 새로 고침 요청은 대화 상자의 원격 대상 URI만 업데이트하고 Record-Route에서 형성된 경로 세트는 업데이트하지 않습니다. 후자를 업데이트하면 RFC 2543 호환 시스템에 심각한 하위 호환성 문제가 발생합니다.

---
### **12.2.1 UAC Behavior**
---
#### **12.2.1.1 Generating the Request**

대화 상자 내의 요청은 대화 상자의 일부로 저장된 상태의 많은 구성 요소를 사용하여 구성됩니다.

요청의 To 필드에 있는 URI는 대화 상태의 원격 URI로 설정되어야 합니다. 요청의 To 헤더 필드에 있는 태그는 대화 ID의 원격 태그로 설정되어야 합니다. 요청의 From URI는 대화 상태의 로컬 URI로 설정되어야 합니다. 요청의 From 헤더 필드에 있는 태그는 대화 ID의 로컬 태그로 설정되어야 합니다. 원격 또는 로컬 태그의 값이 null인 경우 태그 매개변수는 각각 To 또는 From 헤더 필드에서 생략되어야 합니다.\(MUST, MUST, MUST, MUST, MUST\)

- 후속 요청 내 원래 요청의 To 및 From 필드에서 URI를 사용하는 것은 대화 식별을 위해 URI를 사용한 RFC 2543과의 역호환성을 위해 수행됩니다. 본 사양에서는 대화 상자 식별을 위해 태그만 사용됩니다. 중간 대화 요청에서 원래 To 및 From URI의 필수 반영은 이 사양의 후속 개정에서 더 이상 사용되지 않을 것으로 예상됩니다.

요청의 Call-ID는 대화의 Call-ID로 설정되어야 합니다. 대화 내 요청은 각 방향에서 엄격하게 단조롭게 증가하고 연속적인 CSeq 시퀀스 번호\(1씩 증가\)를 포함해야 합니다\(물론 ACK 및 CANCEL은 제외, 해당 숫자는 승인되거나 취소되는 요청과 동일함\). 따라서 로컬 시퀀스 번호가 비어 있지 않은 경우 로컬 시퀀스 번호의 값은 1씩 증가해야 하며 이 값은 CSeq 헤더 필드에 배치되어야 합니다. 로컬 시퀀스 번호가 비어 있으면 섹션 8.1.1.5의 지침을 사용하여 초기 값을 선택해야 합니다. CSeq 헤더 필드 값의 메소드 필드는 요청 메소드와 일치해야 합니다.\(MUST, MUST, MUST, MUST, MUST\)

- 32비트 길이를 사용하면 클라이언트는 단일 호출 내에서 랩어라운드가 필요하기 전까지 약 136년 동안 초당 하나의 요청을 생성할 수 있습니다. 동일한 호출 내의 후속 요청이 랩어라운드되지 않도록 시퀀스 번호의 초기 값이 선택됩니다. 0이 아닌 초기 값을 사용하면 클라이언트가 시간 기반 초기 시퀀스 번호를 사용할 수 있습니다. 예를 들어 클라이언트는 32비트 두 번째 클록의 최상위 31비트를 초기 시퀀스 번호로 선택할 수 있습니다.

UAC는 원격 대상 및 경로 집합을 사용하여 요청의 Request-URI 및 경로 헤더 필드를 작성합니다.

경로 집합이 비어 있으면 UAC는 원격 대상 URI를 요청-URI에 배치해야 합니다. UAC는 요청에 경로 헤더 필드를 추가해서는 안 됩니다.\(MUST, MUST NOT\)

경로 집합이 비어 있지 않고 경로 집합의 첫 번째 URI에 lr 매개변수\(섹션 19.1.1 참조\)가 포함된 경우 UAC는 원격 대상 URI를 요청-URI에 배치해야 하며 다음을 포함하는 경로 헤더 필드를 포함해야 합니다. 모든 매개변수를 포함하여 설정 값을 순서대로 라우팅합니다.\(MUST\)

경로 집합이 비어 있지 않고 첫 번째 URI에 lr 매개 변수가 포함되어 있지 않은 경우 UAC는 경로 집합의 첫 번째 URI를 요청-URI에 배치하고 요청-URI에서 허용되지 않는 모든 매개 변수를 제거해야 합니다. UAC는 모든 매개변수를 포함하여 나머지 경로 설정 값을 순서대로 포함하는 경로 헤더 필드를 추가해야 합니다. 그런 다음 UAC는 원격 대상 URI를 경로 헤더 필드에 마지막 값으로 배치해야 합니다.\(MUST, MUST, MUST\)

예를 들어, 원격 대상이 sip:user@remoteua이고 경로 세트에 다음이 포함된 경우:

```text
      <sip:proxy1>,<sip:proxy2>,<sip:proxy3;lr>,<sip:proxy4>
```

요청은 다음과 같은 Request-URI 및 Route 헤더 필드로 구성됩니다.

```text
   METHOD sip:proxy1
   Route: <sip:proxy2>,<sip:proxy3;lr>,<sip:proxy4>,<sip:user@remoteua>
```

경로 집합의 첫 번째 URI에 lr이 포함되어 있지 않은 경우

- 매개변수, 표시된 프록시는 이 문서에 설명된 라우팅 메커니즘을 이해하지 못하고 RFC 2543에 지정된 대로 작동하여 요청-URI를 메시지를 전달하는 동안 수신한 첫 번째 경로 헤더 필드 값으로 바꿉니다. Route 헤더 필드 끝에 Request-URI를 배치하면

- 엄격한 라우터를 통한 해당 요청-URI의 정보\(요청이 느슨한 라우터에 도달하면 요청-URI로 반환됩니다\).

UAC는 대화 상자 내의 모든 대상 새로 고침 요청에 연락처 헤더 필드를 포함해야 하며, 이를 변경할 필요가 없는 한 URI는 대화 상자 내의 이전 요청에 사용된 것과 동일해야 합니다. "secure" 플래그가 true인 경우 해당 URI는 SIPS URI여야 합니다. 섹션 12.2.2에서 설명한 대로 대상 새로 고침 요청의 연락처 헤더 필드는 원격 대상 URI를 업데이트합니다. 이를 통해 UA는 대화 기간 동안 주소가 변경될 경우 새 연락처 주소를 제공할 수 있습니다.\(SHOULD, MUST\)

그러나 대상 새로 고침 요청이 아닌 요청은 대화의 원격 대상 URI에 영향을 주지 않습니다.

요청의 나머지 부분은 섹션 8.1.1에 설명된 대로 구성됩니다.

요청이 구성되면 대화 상자 외부의 요청에 대해 동일한 절차를 사용하여 서버의 주소가 계산되고 요청이 전송됩니다\(섹션 8.1.2\).

- 섹션 8.1.2의 절차는 일반적으로 최상위 경로 헤더 필드 값이 나타내는 주소로 요청이 전송되거나 경로 헤더 필드가 없는 경우 Request-URI로 전송됩니다. 특정 제한 사항에 따라 요청이 대체 주소\(예: 경로 세트에 표시되지 않은 기본 아웃바운드 프록시\)로 전송되도록 허용합니다.

---
#### **12.2.1.2 Processing the Responses**

UAC는 트랜잭션 계층의 요청에 대한 응답을 받습니다. 클라이언트 트랜잭션이 시간 초과를 반환하는 경우 이는 408\(요청 시간 초과\) 응답으로 처리됩니다.

대화 상자 내에서 전송된 요청에 대해 3xx 응답을 수신하는 UAC의 동작은 요청이 대화 상자 외부에서 전송된 것과 동일합니다. 이 동작은 섹션 8.1.3.4에 설명되어 있습니다.

- 그러나 UAC가 대체 위치를 시도할 때 여전히 대화 상자에 설정된 경로를 사용하여 요청의 경로 헤더를 작성합니다.

UAC가 대상 새로 고침 요청에 대한 2xx 응답을 수신하면 대화 상자의 원격 대상 URI를 해당 응답의 연락처 헤더 필드에 있는 URI\(있는 경우\)로 바꿔야 합니다.\(MUST\)

대화 상자 내의 요청에 대한 응답이 481\(호출/트랜잭션이 존재하지 않음\) 또는 408\(요청 시간 초과\)인 경우 UAC는 대화를 종료해야 합니다. UAC는 요청에 대한 응답이 전혀 수신되지 않는 경우에도 대화를 종료해야 합니다\(클라이언트 트랜잭션은 시간 초과에 대해 TU에 알립니다.\)\(SHOULD, SHOULD\)

- INVITE로 시작된 대화의 경우 대화 종료는 BYE 전송으로 구성됩니다.

---
### **12.2.2 UAS Behavior**

다른 요청과 마찬가지로 대화 상자 내에서 전송된 요청은 원자성입니다. UAS가 특정 요청을 수락하면 이와 관련된 모든 상태 변경이 수행됩니다. 요청이 거부되면 상태 변경이 전혀 수행되지 않습니다.

- INVITE와 같은 일부 요청은 여러 상태에 영향을 미칩니다.

UAS는 트랜잭션 계층으로부터 요청을 받습니다. 요청의 To 헤더 필드에 태그가 있는 경우 UAS 코어는 요청에 해당하는 대화 상자 식별자를 계산하고 이를 기존 대화와 비교합니다. 일치하는 항목이 있으면 이는 중간 대화 요청입니다. 이 경우 UAS는 먼저 섹션 8.2에서 설명한 대화 상자 외부의 요청에 대해 동일한 처리 규칙을 적용합니다.

요청의 To 헤더 필드에 태그가 있지만 대화 상자 식별자가 기존 대화 상자와 일치하지 않는 경우 UAS가 충돌하여 다시 시작되었거나 다른\(실패할 수 있는\) UAS에 대한 요청을 받았을 수 있습니다\(UAS는 UAS가 해당 태그가 복구를 제공하는 UAS용인지 식별할 수 있도록 To 태그를 구성합니다. 또 다른 가능성은 들어오는 요청이 단순히 잘못 라우팅되었다는 것입니다. To 태그에 따라 UAS는 요청을 수락하거나 거부할 수 있습니다. 허용되는 To 태그에 대한 요청을 수락하면 견고성이 제공되므로 충돌이 발생하더라도 대화 상자가 지속될 수 있습니다. 이 기능을 지원하려는 UA는 재부팅 후에도 단조롭게 증가하는 CSeq 시퀀스 번호 선택, 경로 세트 재구성, 범위를 벗어난 RTP 타임스탬프 및 시퀀스 번호 허용과 같은 몇 가지 문제를 고려해야 합니다.\(MAY\)

UAS가 대화 상자를 다시 만들고 싶지 않기 때문에 요청을 거부하려는 경우 481\(통화/트랜잭션이 존재하지 않음\) 상태 코드로 요청에 응답하고 이를 서버 트랜잭션에 전달해야 합니다.\(MUST\)

대화 상자 상태가 어떤 식으로든 변경되지 않는 요청은 대화 상자 내에서 수신될 수 있습니다\(예: OPTIONS 요청\). 이는 대화 상자 외부에서 수신된 것처럼 처리됩니다.

원격 시퀀스 번호가 비어 있는 경우 요청의 CSeq 헤더 필드 값에 있는 시퀀스 번호 값으로 설정되어야 합니다. 원격 시퀀스 번호가 비어 있지 않았지만 요청의 시퀀스 번호가 원격 시퀀스 번호보다 낮은 경우 요청은 순서가 잘못되었으며 500\(서버 내부 오류\) 응답으로 거부되어야 합니다. 원격 시퀀스 번호가 비어 있지 않았고 요청의 시퀀스 번호가 원격 시퀀스 번호보다 큰 경우 요청이 올바른 것입니다. CSeq 시퀀스 번호는 원격 시퀀스 번호보다 1 이상 높을 수 있습니다. 이는 오류 조건이 아니며 UAS는 이전에 수신된 요청보다 1보다 높은 CSeq 값을 가진 요청을 수신하고 처리할 준비가 되어 있어야 합니다. 그런 다음 UAS는 원격 시퀀스 번호를 요청의 CSeq 헤더 필드 값에 있는 시퀀스 번호 값으로 설정해야 합니다.\(MUST, MUST, SHOULD, MUST\)

- 프록시가 UAC에서 생성된 요청에 대해 질문하는 경우 UAC는 자격 증명과 함께 요청을 다시 제출해야 합니다. 다시 제출된 요청에는 새로운 CSeq 번호가 부여됩니다. UAS는 첫 번째 요청을 볼 수 없으므로 CSeq 번호 공간에 차이가 있음을 알 수 있습니다. 이러한 간격은 오류 상태를 나타내지 않습니다.

UAS가 대상 새로 고침 요청을 수신하면 대화 상자의 원격 대상 URI를 해당 요청의 연락처 헤더 필드에 있는 URI\(있는 경우\)로 바꿔야 합니다.\(MUST\)

---
## **12.3 Termination of a Dialog**

메서드와 관계없이 대화 외부의 요청이 2xx가 아닌 최종 응답을 생성하는 경우 해당 요청에 대한 임시 응답을 통해 생성된 모든 초기 대화가 종료됩니다. 확인된 대화 상자를 종료하는 메커니즘은 방법에 따라 다릅니다. 이 사양에서 BYE 메서드는 세션 및 이와 관련된 대화를 종료합니다. 자세한 내용은 섹션 15를 참조하세요.

---
# **13 Initiating a Session**
---
## **13.1 Overview**

사용자 에이전트 클라이언트가 세션\(예: 오디오, 비디오 또는 게임\)을 시작하려고 하면 INVITE 요청을 작성합니다. INVITE 요청은 서버에 세션 설정을 요청합니다. 이 요청은 프록시에 의해 전달되어 결국 초대를 수락할 수 있는 하나 이상의 UAS에 도착할 수 있습니다. 이러한 UAS는 사용자에게 수락 여부를 자주 쿼리해야 합니다.

초대. 얼마 후 해당 UAS는 2xx 응답을 보내 초대를 수락할 수 있습니다\(세션이 설정됨을 의미\). 초대가 수락되지 않으면 거부 이유에 따라 3xx, 4xx, 5xx 또는 6xx 응답이 전송됩니다. 최종 응답을 보내기 전에 UAS는 임시 응답\(1xx\)을 보내 호출된 사용자에게 연락하는 진행 상황을 UAC에 알릴 수도 있습니다.

하나 이상의 임시 응답을 받은 후 UAC는 하나 이상의 2xx 응답 또는 하나의 2xx가 아닌 최종 응답을 받게 됩니다. INVITE에 대한 최종 응답을 받는 데 오랜 시간이 걸릴 수 있기 때문에 INVITE 트랜잭션의 신뢰성 메커니즘은 OPTIONS와 같은 다른 요청의 신뢰성 메커니즘과 다릅니다. 최종 응답을 받으면 UAC는 수신하는 모든 최종 응답에 대해 ACK를 보내야 합니다. 이 ACK를 보내는 절차는 응답 유형에 따라 다릅니다. 300에서 699 사이의 최종 응답의 경우 ACK 처리는 트랜잭션 계층에서 수행되며 한 가지 규칙 세트를 따릅니다\(섹션 17 참조\). 2xx 응답의 경우 ACK는 UAC 코어에 의해 생성됩니다.

INVITE에 대한 2xx 응답은 세션을 설정하고 INVITE를 발행한 UA와 2xx 응답을 생성한 UA 간의 대화도 생성합니다. 따라서 여러 원격 UA로부터 여러 2xx 응답이 수신되면\(INVITE 분기로 인해\) 각 2xx는 서로 다른 대화를 설정합니다. 이러한 모든 대화 상자는 동일한 호출의 일부입니다.

이 섹션에서는 INVITE를 사용하여 세션을 설정하는 방법에 대해 자세히 설명합니다. INVITE를 지원하는 UA는 ACK, CANCEL 및 BYE도 지원해야 합니다.\(MUST\)

---
## **13.2 UAC Processing**
---
### **13.2.1 Creating the Initial INVITE**

초기 INVITE는 대화 상자 외부의 요청을 나타내기 때문에 해당 구성은 섹션 8.1.1의 절차를 따릅니다. INVITE의 특정 경우에는 추가 처리가 필요합니다.

Allow 헤더 필드\(섹션 20.5\)는 INVITE에 있어야 합니다. 이는 대화 기간 동안 INVITE를 보내는 UA에서 대화 내에서 호출할 수 있는 메서드를 나타냅니다. 예를 들어, 대화 상자 내에서 INFO 요청을 수신할 수 있는 UA는 INFO 메서드를 나열하는 Allow 헤더 필드를 포함해야 합니다.\(SHOULD, SHOULD\)

지원되는 헤더 필드\(섹션 20.37\)가 INVITE에 있어야 합니다. UAC가 이해하는 모든 확장을 열거합니다.\(SHOULD\)

Accept\(Section 20.1\) 헤더 필드는 INVITE에 존재할 수 있습니다. 이는 수신된 응답과 INVITE에 의해 설정된 대화 상자 내에서 전송된 후속 요청 모두에서 UA가 허용할 수 있는 콘텐츠 유형을 나타냅니다. Accept 헤더 필드는 다양한 세션 설명 형식 지원을 나타내는 데 특히 유용합니다.\(MAY\)

UAC는 초대의 유효성을 제한하기 위해 Expires 헤더 필드\(섹션 20.19\)를 추가할 수 있습니다. Expires 헤더 필드에 표시된 시간에 도달하고 INVITE에 대한 최종 응답이 수신되지 않은 경우 UAC 코어는 섹션 9에 따라 INVITE에 대한 CANCEL 요청을 생성해야 합니다.\(MAY, SHOULD\)

UAC는 또한 제목\(섹션 20.36\), 조직\(섹션 20.25\) 및 User-Agent\(섹션 20.41\) 헤더 필드를 추가하는 것이 유용하다는 것을 알 수 있습니다. 여기에는 모두 INVITE와 관련된 정보가 포함되어 있습니다.\(MAY\)

UAC는 INVITE에 메시지 본문을 추가하도록 선택할 수 있습니다. 섹션 8.1.1.10에서는 메시지 본문을 설명하는 데 필요한 헤더 필드\(Content-Type\)를 구성하는 방법을 다룹니다.\(MAY\)

세션 설명이 포함된 메시지 본문에는 특별한 규칙이 있습니다. 해당 내용 처리는 "세션"입니다. SIP는 하나의 UA가 제안된 세션 설명이 포함된 제안이라는 세션 설명을 보내는 제안/응답 모델을 사용합니다. 제안에는 원하는 통신 수단\(오디오, 비디오, 게임\), 해당 수단의 매개변수\(예: 코덱 유형\) 및 응답자로부터 미디어를 수신하기 위한 주소가 표시됩니다. 다른 UA는 응답이라고 하는 또 다른 세션 설명으로 응답합니다. 이는 어떤 통신 수단이 허용되는지, 해당 수단에 적용되는 매개변수, 제공자로부터 미디어를 수신하기 위한 주소를 나타냅니다. 제안/답변 교환은 대화의 컨텍스트 내에서 이루어지므로 SIP INVITE로 인해 여러 대화가 발생하는 경우 각 대화는 별도의 제안/답변 교환입니다. 제안/응답 모델은 제안 및 답변이 가능한 시기에 대한 제한 사항을 정의합니다\(예를 들어 제안이 진행 중인 동안에는 새 제안을 할 수 없습니다\). 이로 인해 제안 및 답변이 SIP 메시지에 나타날 수 있는 위치가 제한됩니다. 이 사양에서 제안과 답변은 INVITE 요청과 응답, ACK에만 나타날 수 있습니다. 제안 및 답변의 사용이 더욱 제한됩니다. 초기 INVITE 트랜잭션의 경우 규칙은 다음과 같습니다.

- o 초기 제안은 INVITE에 있어야 하며, 그렇지 않은 경우 UAS에서 UAC로 돌아가는 첫 번째 신뢰할 수 있는 비실패 메시지에 있어야 합니다. 이 사양에서는 이것이 최종 2xx 응답입니다.\(MUST\)

- o 초기 제안이 INVITE에 있는 경우 응답은 UAS에서 해당 INVITE와 상관 관계가 있는 UAC로 돌아가는 신뢰할 수 있는 비실패 메시지에 있어야 합니다. 이 사양의 경우 해당 INVITE에 대한 최종 2xx 응답일 뿐입니다. 동일한 정확한 답변은 답변 이전에 전송된 임시 응답에도 포함될 수 있습니다. UAC는 수신한 첫 번째 세션 설명을 응답으로 처리해야 하며, 초기 INVITE에 대한 후속 응답의 모든 세션 설명을 무시해야 합니다.\(MUST, MAY, MUST\)

- o 초기 제안이 UAS에서 UAC로 다시 신뢰할 수 있는 첫 번째 비실패 메시지에 있는 경우 응답은 해당 메시지에 대한 승인에 있어야 합니다\(이 사양에서는 2xx 응답에 대한 ACK\).\(MUST\)

- o 첫 번째 제안에 대한 답변을 보내거나 받은 후 UAC는 해당 방법에 대해 지정된 규칙에 따라 요청에서 후속 제안을 생성할 수 있습니다. 단, 이전 제안에 대한 답변을 받았고 해당 제안을 보내지 않은 경우에만 가능합니다. 그것은 대답을 얻지 못했습니다.\(MAY\)

- o UAS가 초기 제안에 대한 응답을 보내거나 받은 후에는 초기 INVITE에 대한 응답에서 후속 제안을 생성해서는 안 됩니다. 이는 이 사양만으로는 초기 트랜잭션이 완료될 때까지 후속 제안을 생성할 수 없음을 의미합니다.\(MUST NOT\)

구체적으로 위의 규칙은 이 사양만 준수하는 UA에 대해 두 개의 교환을 지정합니다. 제안은 INVITE에 있고 답변은 2xx\(동일한 값을 가진 1xx에도 가능\)에 있거나 제안이 2xx이고 답은 ACK에 있습니다. INVITE를 지원하는 모든 사용자 에이전트는 이 두 가지 교환을 지원해야 합니다.\(MUST\)

세션 설명 프로토콜\(SDP\)\(RFC 2327 \[1\]\)은 세션을 설명하는 수단으로 모든 사용자 에이전트에서 지원되어야 하며 제안 및 답변 구성을 위한 사용법은 \[13\]에 정의된 절차를 따라야 합니다.\(MUST\)

방금 설명한 제안-응답 모델의 제한 사항은 Content-Disposition 헤더 필드 값이 "session"인 본문에만 적용됩니다. 따라서 INVITE와 ACK 모두 본문 메시지를 포함할 수 있습니다\(예를 들어 INVITE는 사진\(Content-Disposition: 렌더링\)을 전달하고 ACK는 세션 설명\(Content-Disposition: 세션\)을 전달함\).

Content-Disposition 헤더 필드가 누락된 경우 Content-Type 애플리케이션/sdp의 본문은 처리 "세션"을 암시하는 반면 다른 콘텐츠 유형은 "렌더링"을 암시합니다.

INVITE가 생성되면 UAC는 대화 상자 외부로 요청을 보내기 위해 정의된 절차를 따릅니다\(섹션 8\). 그 결과 궁극적으로 요청을 보내고 UAC에 응답을 전달하는 클라이언트 트랜잭션이 구성됩니다.

---
### **13.2.2 Processing INVITE Responses**

INVITE가 INVITE 클라이언트 트랜잭션으로 전달되면 UAC는 INVITE에 대한 응답을 기다립니다. INVITE 클라이언트 트랜잭션이 응답이 아닌 시간 초과를 반환하는 경우 TU는 섹션 8.1.3에 설명된 대로 408\(요청 시간 초과\) 응답이 수신된 것처럼 작동합니다.

---
#### **13.2.2.1 1xx Responses**

하나 이상의 최종 응답이 수신되기 전에 0개, 하나 또는 여러 개의 임시 응답이 도착할 수 있습니다. INVITE 요청에 대한 임시 응답은 "초기 대화"를 생성할 수 있습니다. 임시 응답의 To 필드에 태그가 있고 응답의 대화 ID가 기존 대화와 일치하지 않는 경우 섹션 12.1.2에 정의된 절차를 사용하여 구성됩니다.

초기 대화는 초기 INVITE 트랜잭션이 완료되기 전에 UAC가 대화 내 피어에게 요청을 보내야 하는 경우에만 필요합니다. 임시 응답에 있는 헤더 필드는 대화가 초기 상태에 있는 한 적용 가능합니다\(예를 들어 임시 응답의 Allow 헤더 필드에는 초기 상태에 있는 동안 대화에서 사용할 수 있는 메서드가 포함되어 있습니다\).

---
#### **13.2.2.2 3xx Responses**

3xx 응답에는 수신자에게 연락할 수 있는 새 주소를 제공하는 하나 이상의 연락처 헤더 필드 값이 포함될 수 있습니다. 3xx 응답의 상태 코드\(섹션 21.3 참조\)에 따라 UAC는 새 주소를 시도하도록 선택할 수 있습니다.\(MAY\)

---
#### **13.2.2.3 4xx, 5xx and 6xx Responses**

INVITE에 대해 2xx가 아닌 단일 최종 응답이 수신될 수 있습니다. 4xx, 5xx 및 6xx 응답에는 오류에 대한 추가 정보를 찾을 수 있는 위치를 나타내는 연락처 헤더 필드 값이 포함될 수 있습니다. 후속 최종 응답\(오류 조건에서만 도착\)은 무시되어야 합니다.\(MUST\)

모든 초기 대화는 2xx가 아닌 최종 응답을 수신하면 종료된 것으로 간주됩니다.

2xx가 아닌 최종 응답을 받은 후 UAC 코어는 INVITE 트랜잭션이 완료된 것으로 간주합니다. INVITE 클라이언트 트랜잭션은 응답에 대한 ACK 생성을 처리합니다\(섹션 17 참조\).

---
#### **13.2.2.4 2xx Responses**

분기 프록시로 인해 단일 INVITE 요청에 대해 여러 2xx 응답이 UAC에 도착할 수 있습니다. 각 응답은 To 헤더 필드의 태그 매개변수로 구별되며 각각은 고유한 대화 상자 식별자를 사용하여 고유한 대화 상자를 나타냅니다.

2xx 응답의 대화 식별자가 기존 대화의 대화 식별자와 일치하는 경우 대화는 "확인된" 상태로 전환되어야 하며 대화에 대한 경로 세트는 섹션 12.2의 절차를 사용하여 2xx 응답을 기반으로 다시 계산되어야 합니다. .1.2. 그렇지 않으면 섹션 12.1.2의 절차를 사용하여 "확인된" 상태의 새 대화 상자를 구성해야 합니다.\(MUST, MUST\)

- 재계산되는 유일한 상태는 경로 세트입니다. 대화 상자 내에서 전송된 가장 높은 시퀀스 번호\(원격 및 로컬\)와 같은 다른 상태 부분은 다시 계산되지 않습니다. 이전 버전과의 호환성을 위해 경로 세트만 다시 계산됩니다. RFC 2543은 1xx에서 Record-Route 헤더 필드의 미러링을 요구하지 않고 2xx에서만 요구합니다. 그러나 중간 대화 요청이 초기 대화 내에서 전송되어 예를 들어 시퀀스 번호를 수정했을 수 있으므로 대화의 전체 상태를 업데이트할 수 없습니다.

UAC 코어는 트랜잭션 계층에서 수신된 각 2xx에 대해 ACK 요청을 생성해야 합니다. ACK의 헤더 필드는 인증과 관련된 CSeq 및 헤더 필드를 제외하고 대화 상자 내에서 전송된 모든 요청과 동일한 방식으로 구성됩니다\(섹션 12 참조\). CSeq 헤더 필드의 시퀀스 번호는 확인되는 INVITE와 동일해야 하지만 CSeq 방법은 ACK여야 합니다. ACK에는 INVITE와 동일한 자격 증명이 포함되어야 합니다. 2xx에 제안이 포함된 경우\(위 규칙에 따라\) ACK의 본문에 응답이 포함되어야 합니다. 2xx 응답의 제안이 허용되지 않는 경우 UAC 코어는 ACK에서 유효한 응답을 생성한 다음 즉시 BYE를 보내야 합니다.\(MUST, MUST, MUST, MUST, MUST\)

ACK가 구성되면 \[4\]의 절차를 사용하여 대상 주소, 포트 및 전송을 결정합니다. 그러나 요청은 클라이언트 트랜잭션이 아닌 전송을 위해 직접 전송 계층으로 전달됩니다. 이는 트랜잭션 계층이 아닌 UAC 코어가 ACK 재전송을 처리하기 때문입니다. ACK는 ACK를 트리거한 2xx 최종 응답의 재전송이 도착할 때마다 클라이언트 전송으로 전달되어야 합니다.\(MUST\)

UAC 코어는 첫 번째 2xx 응답을 수신한 후 64\*T1초 후에 INVITE 트랜잭션이 완료된 것으로 간주합니다. 이 시점에서 기존 대화 상자로 전환되지 않은 모든 초기 대화 상자는 종료됩니다. UAC 코어에서 INVITE 트랜잭션이 완료된 것으로 간주되면 더 이상 새로운 2xx 응답이 도착하지 않을 것으로 예상됩니다.

INVITE에 대한 2xx 응답을 확인한 후 UAC가 해당 대화를 계속하기를 원하지 않으면 UAC는 섹션 15에 설명된 대로 BYE 요청을 보내 대화를 종료해야 합니다.\(MUST\)

---
## **13.3 UAS Processing**
---
### **13.3.1 Processing of the INVITE**

UAS 코어는 트랜잭션 계층으로부터 INVITE 요청을 받습니다. 먼저 대화 상자 내부 및 외부 요청 모두에 적용되는 섹션 8.2의 요청 처리 절차를 수행합니다.

이러한 처리 상태가 응답을 생성하지 않고 완료되었다고 가정하면 UAS 코어는 추가 처리 단계를 수행합니다.

- 1. 요청이 Expires 헤더 필드를 포함하는 INVITE인 경우 UAS 코어는 헤더 필드 값에 표시된 시간\(초\) 동안 타이머를 설정합니다. 타이머가 실행되면 초대가 만료된 것으로 간주됩니다. UAS가 최종 응답을 생성하기 전에 초대가 만료되면 487\(요청 종료됨\) 응답이 생성되어야 합니다.\(SHOULD\)

- 2. 요청이 중간 대화 요청인 경우 12.2.2절에 설명된 방법 독립적인 처리가 먼저 적용됩니다. 세션을 수정할 수도 있습니다. 섹션 14에 자세한 내용이 나와 있습니다.

- 3. 요청의 To 헤더 필드에 태그가 있지만 대화 상자 식별자가 기존 대화 상자와 일치하지 않는 경우 UAS가 충돌하여 다시 시작되었거나 다른\(실패할 수 있는\) UAS에 대한 요청을 받았을 수 있습니다. 섹션 12.2.2에서는 이러한 상황에서 강력한 동작을 달성하기 위한 지침을 제공합니다.

여기 이후의 처리에서는 INVITE가 대화 상자 외부에 있으므로 새 세션을 설정하기 위한 것이라고 가정합니다.

INVITE에는 세션 설명이 포함될 수 있으며, 이 경우 UAS는 해당 세션에 대한 제안을 제공합니다. INVITE가 대화 상자 외부에 있더라도 사용자가 이미 해당 세션에 참여하고 있을 수 있습니다. 이는 다른 여러 참가자가 동일한 멀티캐스트 회의에 사용자를 초대한 경우 발생할 수 있습니다. 원하는 경우 UAS는 세션 설명 내의 식별자를 사용하여 이러한 중복을 감지할 수 있습니다. 예를 들어, SDP\(MAY\)

원본\(o\) 필드에 세션 ID와 버전 번호가 포함되어 있습니다. 사용자가 이미 세션의 구성원이고 세션 설명에 포함된 세션 매개 변수가 변경되지 않은 경우 UAS는 자동으로 INVITE를 수락할 수 있습니다\(즉, 사용자에게 메시지를 표시하지 않고 2xx 응답을 보냅니다\).\(MAY\)

INVITE에 세션 설명이 포함되어 있지 않으면 UAS가 세션에 참여하도록 요청되고 UAC는 UAS가 세션 제안을 제공하도록 요청한 것입니다. UAC에 다시 실패하지 않고 신뢰할 수 있는 첫 번째 메시지로 제안을 제공해야 합니다. 이 사양에서는 INVITE에 대한 2xx 응답입니다.\(MUST\)

UAS는 진행 상황을 표시하고 초대를 수락, 리디렉션 또는 거부할 수 있습니다. 이러한 모든 경우에 섹션 8.2.6에 설명된 절차를 사용하여 응답을 공식화합니다.

---
#### **13.3.1.1 Progress**

UAS가 초대에 즉시 응답할 수 없는 경우 UAC에 진행 상황\(예: 전화 벨이 울리고 있음 표시\)을 표시하도록 선택할 수 있습니다. 이는 101과 199 사이의 임시 응답으로 수행됩니다. 이러한 임시 응답은 초기 대화를 설정하므로 섹션 8.2.6의 절차 외에 섹션 12.1.1의 절차를 따릅니다. UAS는 원하는 만큼 임시 응답을 보낼 수 있습니다. 이들 각각은 동일한 대화 ID를 나타내야 합니다. 그러나 이러한 내용은 안정적으로 전달되지 않습니다.\(MAY, MUST\)

UAS가 INVITE에 응답하기 위해 연장된 시간을 원하는 경우 프록시가 트랜잭션을 취소하는 것을 방지하기 위해 "연장"을 요청해야 합니다. 프록시는 트랜잭션 응답 사이에 3분의 간격이 있을 때 트랜잭션을 취소할 수 있는 옵션을 가지고 있습니다. 취소를 방지하기 위해 UAS는 임시 응답 손실 가능성을 처리하기 위해 매분마다 100이 아닌 임시 응답을 보내야 합니다.\(MUST\)

- INVITE 거래는 사용자가 대기 상태에 있을 때나 전화를 받지 않고도 통신이 가능한 PSTN 시스템과 연동할 때 장기간 지속될 수 있습니다. 후자는 IVR\(대화형 음성 응답\) 시스템에서 일반적입니다.

---
#### **13.3.1.2 The INVITE is Redirected**

UAS가 통화를 리디렉션하기로 결정하면 3xx 응답이 전송됩니다. 300\(다중 선택\), 301\(영구적으로 이동됨\) 또는 302\(일시적으로 이동됨\) 응답에는 연락처 헤더 필드가 포함되어야 합니다.\(SHOULD\)

시도할 새 주소의 URI가 하나 이상 포함되어 있습니다. 응답은 재전송을 처리하는 INVITE 서버 트랜잭션으로 전달됩니다.

---
#### **13.3.1.3 The INVITE is Rejected**

일반적인 시나리오는 호출 수신자가 현재 이 최종 시스템에서 추가 호출을 받을 의향이 없거나 받을 수 없을 때 발생합니다. 이러한 시나리오에서는 486\(Busy Here\)이 반환되어야 합니다. UAS가 다른 최종 시스템이 이 호출을 수락할 수 없다는 것을 알고 있는 경우 대신 600\(Busy Everywhere\) 응답을 보내야 합니다. 그러나 UAS가 이를 일반적으로 알 수 있는 가능성은 낮으므로 이 응답은 일반적으로 사용되지 않습니다. 응답은 재전송을 처리하는 INVITE 서버 트랜잭션으로 전달됩니다.\(SHOULD, SHOULD\)

INVITE에 포함된 제안을 거부하는 UAS는 488\(여기에서는 허용되지 않음\) 응답을 반환해야 합니다. 이러한 응답에는 제안이 거부된 이유를 설명하는 경고 헤더 필드 값이 포함되어야 합니다.\(SHOULD, SHOULD\)

---
#### **13.3.1.4 The INVITE is Accepted**

UAS 코어는 2xx 응답을 생성합니다. 이 응답은 대화 상자를 설정하므로 섹션 8.2.6의 절차 외에도 섹션 12.1.1의 절차를 따릅니다.

INVITE에 대한 2xx 응답은 Allow 헤더 필드와 Supported 헤더 필드를 포함해야 하며 Accept 헤더 필드를 포함할 수 있습니다. 이러한 헤더 필드를 포함하면 UAC는 탐색 없이 통화 기간 동안 UAS가 지원하는 기능과 확장을 결정할 수 있습니다.\(SHOULD\)

INVITE 요청에 제안이 포함되어 있고 UAS가 아직 답변을 보내지 않은 경우 2xx에는 답변이 포함되어야 합니다. INVITE에 제안이 포함되지 않은 경우 UAS가 아직 제안을 보내지 않은 경우 2xx에는 제안이 포함되어야 합니다.\(MUST, MUST\)

응답이 구성되면 INVITE 서버 트랜잭션으로 전달됩니다. 그러나 INVITE 서버 트랜잭션은 이 최종 응답을 수신하여 전송에 전달하는 즉시 폐기됩니다. 따라서 ACK가 도착할 때까지 주기적으로 응답을 직접 전송으로 전달해야 합니다. 2xx 응답은 T1초에 시작하여 T2초에 도달할 때까지 각 재전송에 대해 두 배로 증가하는 간격으로 전송에 전달됩니다\(T1 및 T2는 섹션 17에 정의되어 있음\). 응답에 대한 ACK 요청이 수신되면 응답 재전송이 중단됩니다. 이는 응답을 보내는 데 사용되는 전송 프로토콜과 무관합니다.

- 2xx는 end-to-end로 재전송되므로 UAS와 UDP인 UAC 사이에 홉이 있을 수 있습니다. 이러한 홉 전체에서 안정적인 전달을 보장하기 위해 UAS에서의 전송이 신뢰할 수 있는 경우에도 응답이 주기적으로 재전송됩니다.

서버가 ACK를 받지 않고 64\*T1초 동안 2xx 응답을 재전송하는 경우 대화는 확인되지만 세션은 종료되어야 합니다. 이는 섹션 15에 설명된 대로 BYE를 통해 수행됩니다.\(SHOULD\)

---
# **14 Modifying an Existing Session**

성공적인 INVITE 요청\(섹션 13 참조\)은 두 사용자 에이전트 간의 대화와 제안-응답 모델을 사용하는 세션을 모두 설정합니다. 섹션 12에서는 대상 새로 고침 요청을 사용하여 기존 대화를 수정하는 방법\(예: 대화 상자의 원격 대상 URI 변경\)을 설명합니다. 이 섹션에서는 실제 세션을 수정하는 방법을 설명합니다. 이러한 수정에는 주소나 포트 변경, 미디어 스트림 추가, 미디어 스트림 삭제 등이 포함될 수 있습니다. 이는 세션을 설정한 동일한 대화 상자 내에서 새 INVITE 요청을 전송하여 수행됩니다. 기존 대화 내에서 전송된 INVITE 요청을 re-INVITE라고 합니다.

- 한 번의 re-INVITE로 대화 상자와 세션 매개변수를 동시에 수정할 수 있습니다.

발신자나 수신자는 기존 세션을 수정할 수 있습니다.

미디어 오류 감지 시 UA의 동작은 로컬 정책의 문제입니다. 그러나 혼잡이 있을 때 네트워크에 트래픽이 넘쳐나는 것을 방지하기 위해 자동으로 re-INVITE 또는 BYE를 생성하는 것은 권장되지 않습니다. 어떤 경우든 이러한 메시지가 자동으로 전송된다면 임의의 간격을 두고 전송되어야 합니다.\(SHOULD NOT, SHOULD\)

- 위 단락은 자동으로 생성된 BYE 및 re-INVITE를 나타냅니다. 사용자가 미디어 오류로 인해 전화를 끊으면 UA는 평소와 같이 BYE 요청을 보냅니다.

---
## **14.1 UAC Behavior**

INVITE\(섹션 13.2.1\)의 세션 설명에 적용되는 동일한 제안-응답 모델이 re-INVITE에도 적용됩니다. 결과적으로, 예를 들어 미디어 스트림을 추가하려는 UAC는 이 미디어 스트림을 포함하는 새 제안을 생성하고 이를 INVITE 요청으로 피어에게 보냅니다. 변경 사항뿐만 아니라 세션에 대한 전체 설명이 전송된다는 점에 유의하는 것이 중요합니다. 이는 다양한 요소에서 상태 비저장 세션 처리를 지원하고 장애 조치 및 복구 기능을 지원합니다. 물론 UAC는 다음을 수행할 수 있습니다.\(MAY\)

세션 설명 없이 re-INVITE를 보냅니다. 이 경우 re-INVITE에 대한 신뢰할 수 있는 첫 번째 비실패 응답에 제안이 포함됩니다\(이 사양에서는 2xx 응답\).

세션 설명 형식에 버전 번호 기능이 있는 경우 제공자는 세션 설명 버전이 변경되었음을 나타내야 합니다.\(SHOULD\)

re-INVITE의 To, From, Call-ID, CSeq 및 Request-URI는 섹션 12에 설명된 기존 대화 상자 내의 일반 요청과 동일한 규칙에 따라 설정됩니다.

UAC는 일반적으로 re-INVITE 수신 시 UAS가 사용자에게 경고하지 않기 때문에 Alert-Info 헤더 필드 또는 Content-Disposition "경고"가 포함된 본문을 re-INVITE에 추가하지 않도록 선택할 수 있습니다.\(MAY\)

분기할 수 있는 INVITE와 달리 re-INVITE는 분기되지 않으므로 단일 최종 응답만 생성합니다. re-INVITE가 포크되지 않는 이유는 Request-URI가 사용자의 레코드 주소를 식별하는 대신 대화 상자를 설정한 UA 인스턴스로 대상을 식별하기 때문입니다.

UAC는 다른 INVITE 트랜잭션이 어느 방향에서든 진행 중인 동안 대화 상자 내에서 새로운 INVITE 트랜잭션을 시작해서는 안 됩니다.\(MUST NOT\)

- 1. 진행 중인 INVITE 클라이언트 트랜잭션이 있는 경우 TU는 새로운 INVITE를 시작하기 전에 트랜잭션이 완료 또는 종료 상태에 도달할 때까지 기다려야 합니다.\(MUST\)

- 2. 진행 중인 INVITE 서버 트랜잭션이 있는 경우 TU는 새로운 INVITE를 시작하기 전에 트랜잭션이 확인 또는 종료 상태에 도달할 때까지 기다려야 합니다.\(MUST\)

그러나 UA는 INVITE 트랜잭션이 진행되는 동안 일반 트랜잭션을 시작할 수 있습니다. UA는 일반 트랜잭션이 진행되는 동안 INVITE 트랜잭션을 시작할 수도 있습니다.\(MAY, MAY\)

UA가 re-INVITE에 대한 2xx가 아닌 최종 응답을 수신하는 경우 마치 re-INVITE가 발행되지 않은 것처럼 세션 매개변수는 변경되지 않은 상태로 유지되어야 합니다. 섹션 12.2.1.2에 명시된 대로 2xx가 아닌 최종 응답이 481\(통화/트랜잭션이 존재하지 않음\) 또는 408\(요청 시간 초과\)이거나 re-INVITE에 대한 응답이 전혀 수신되지 않는 경우에 유의하세요. \(즉, INVITE 클라이언트 트랜잭션에서 시간 초과가 반환됨\) UAC는 대화 상자를 종료합니다.\(MUST\)

UAC가 re-INVITE에 대한 491 응답을 수신하면 다음과 같이 선택된 값 T로 타이머를 시작해야 합니다.\(SHOULD\)

- 1. UAC가 대화 ID의 Call-ID 소유자인 경우\(값을 생성했음을 의미\) T는 10ms 단위로 2.1\~4초 사이에서 임의로 선택된 값을 갖습니다.

- 2. UAC가 대화 ID의 Call-ID 소유자가 아닌 경우 T는 10ms 단위로 0\~2초 사이에서 임의로 선택된 값을 갖습니다.

타이머가 실행되면 UAC는 여전히 해당 세션 수정이 이루어지기를 원하는 경우 re-INVITE를 한 번 더 시도해야 합니다. 예를 들어 통화가 이미 BYE로 끊어진 경우 re-INVITE는 발생하지 않습니다.\(SHOULD\)

re-INVITE를 전송하고 re-INVITE에 대한 2xx 응답에 대한 ACK를 생성하는 규칙은 초기 INVITE\(섹션 13.2.1\)와 동일합니다.

---
## **14.2 UAS Behavior**

섹션 13.3.1에서는 들어오는 re-INVITE를 들어오는 초기 INVITE와 구별하고 기존 대화에 대한 re-INVITE를 처리하는 절차를 설명합니다.

동일한 대화 상자에서 더 낮은 CSeq 시퀀스 번호를 사용하여 첫 번째 INVITE에 최종 응답을 보내기 전에 두 번째 INVITE를 수신하는 UAS는 두 번째 INVITE에 500\(서버 내부 오류\) 응답을 반환해야 하며 Retry-After 헤더 필드를 포함해야 합니다. 0\~10초 사이에서 무작위로 선택된 값입니다.\(MUST\)

대화 상자에서 보낸 INVITE가 진행 중인 동안 대화 상자에서 INVITE를 수신하는 UAS는 수신된 INVITE에 491\(요청 보류 중\) 응답을 반환해야 합니다.\(MUST\)

UA가 기존 대화에 대한 re-INVITE를 수신하는 경우 세션 설명의 버전 식별자를 확인해야 하며, 버전 식별자가 없는 경우 세션 설명의 콘텐츠가 변경되었는지 확인해야 합니다. 세션 설명이 변경된 경우 UAS는 사용자에게 확인을 요청한 후 이에 따라 세션 매개변수를 조정해야 합니다.\(MUST, MUST\)

- 세션 설명의 버전 관리를 사용하여 회의에 새로 참석한 사람의 기능을 수용하고, 미디어를 추가 또는 삭제하거나, 유니캐스트에서 멀티캐스트 회의로 변경할 수 있습니다.

새 세션 설명이 허용되지 않는 경우 UAS는 re-INVITE에 대해 488\(여기에서는 허용되지 않음\) 응답을 반환하여 이를 거부할 수 있습니다. 이 응답에는 경고 헤더 필드가 포함되어야 합니다.\(SHOULD\)

UAS가 2xx 응답을 생성하고 ACK를 전혀 수신하지 못하는 경우 대화를 종료하려면 BYE를 생성해야 합니다.\(SHOULD\)

UAS는 일반적으로 UAC가 사용자에게 이 정보를 제공하지 않기 때문에 re-INVITE에 대해 180\(벨소리\) 응답을 생성하지 않도록 선택할 수 있습니다. 같은 이유로 UAS는 re-INVITE에 대한 응답으로 Alert-Info 헤더 필드나 Content-Disposition "alert"가 포함된 본문을 사용하지 않도록 선택할 수 있습니다.\(MAY, MAY\)

2xx에서 제안을 제공하는 UAS\(INVITE에 제안이 포함되어 있지 않기 때문에\)는 UAS가 완전히 새로운 전화를 거는 것처럼 제안을 구성해야 하며, 에 설명된 대로 기존 세션을 업데이트하는 제안을 보내는 제약 조건이 적용됩니다. \[13\] SDP의 경우. 구체적으로 이는 UA가 지원하고자 하는 만큼의 미디어 형식과 미디어 유형을 포함해야 함을 의미합니다. UAS는 세션 설명이 미디어 형식, 전송 또는 피어의 지원이 필요한 기타 매개변수의 이전 세션 설명과 겹치는지 확인해야 합니다. 이는 피어가 세션 설명을 거부할 필요를 피하기 위한 것입니다. 그러나 UAC가 이를 받아들일 수 없는 경우 UAC는 유효한 세션 설명이 포함된 응답을 생성한 다음 BYE를 보내 세션을 종료해야 합니다.\(SHOULD, SHOULD, MUST, SHOULD\)

---
# **15 Terminating a Session**

이 섹션에서는 SIP에 의해 설정된 세션을 종료하는 절차를 설명합니다. 세션 상태와 대화 상자 상태는 매우 밀접하게 관련되어 있습니다. INVITE로 세션이 시작되면 고유한 UAS의 각 1xx 또는 2xx 응답이 대화 상자를 생성하고, 해당 응답이 제안/응답 교환을 완료하면 세션도 생성됩니다. 결과적으로 각 세션은 단일 대화 상자\(해당 대화 상자가 생성된 대화 상자\)와 "연결"됩니다. 초기 INVITE가 2xx가 아닌 최종 응답을 생성하는 경우 요청에 대한 응답을 통해 생성된 모든 세션\(있는 경우\)과 모든 대화\(있는 경우\)가 종료됩니다. 트랜잭션 완료 덕분에 2xx가 아닌 최종 응답은 INVITE의 결과로 추가 세션이 생성되는 것을 방지합니다. BYE 요청은 특정 세션 또는 시도된 세션을 종료하는 데 사용됩니다. 이 경우 특정 세션은 대화 상자 반대편에 피어 UA가 있는 세션입니다. 대화 상자에서 BYE가 수신되면 해당 대화 상자와 관련된 모든 세션이 종료되어야 합니다. UA는 대화 외부에서 BYE를 보내면 안 됩니다. 발신자의 UA는 확인된 대화 또는 초기 대화에 대해 BYE를 보낼 수 있으며, 수신자의 UA는 확인된 대화에 대해 BYE를 보낼 수 있지만 초기 대화에 대해서는 BYE를 보내서는 안 됩니다.\(SHOULD, MUST NOT, MUST NOT\)

그러나 피호출자의 UA는 2xx 응답에 대한 ACK를 수신하거나 서버 트랜잭션 시간이 초과될 때까지 확인된 대화 상자에서 BYE를 보내서는 안 됩니다. SIP 확장이 대화 상자와 연관된 다른 애플리케이션 계층 상태를 정의하지 않은 경우 BYE도 대화 상자를 종료합니다.\(MUST NOT\)

INVITE에 대한 2xx가 아닌 최종 응답이 대화 및 세션에 미치는 영향으로 인해 CANCEL 사용이 매력적입니다. CANCEL은 INVITE\(특히 487\)에 대해 2xx가 아닌 응답을 강제로 시도합니다. 따라서 UAC가 통화 시도를 완전히 포기하려는 경우 CANCEL을 보낼 수 있습니다. INVITE 결과 INVITE에 대한 2xx개의 최종 응답이 발생하는 경우 이는 취소가 진행 중인 동안 UAS가 초대를 수락했음을 의미합니다. UAC는 2xx 응답에 의해 설정된 세션을 계속하거나 BYE로 종료할 수 있습니다.\(MAY\)

- "전화 끊기"라는 개념은 SIP 내에서 잘 정의되어 있지 않습니다. 이는 공통적이지만 특정 사용자 인터페이스에만 해당됩니다. 일반적으로 사용자가 전화를 끊는 것은 세션 설정 시도를 종료하고 이미 생성된 모든 세션을 종료하려는 의미입니다. 발신자의 UA의 경우 초기 INVITE가 최종 응답을 생성하지 않은 경우 CANCEL 요청을 의미하고 최종 응답 후 확인된 모든 대화 상자에 대한 BYE를 의미합니다. 호출 수신자의 UA의 경우 일반적으로 BYE를 의미합니다. 아마도 사용자가 전화를 받았을 때 2xx가 생성되었으므로 전화를 끊으면 ACK가 수신된 후 BYE가 발생할 것입니다. 이는 사용자가 ACK를 받기 전에 전화를 끊을 수 없다는 의미가 아니라, 적절하게 정리하기 위해 전화기의 소프트웨어가 잠시 동안 상태를 유지해야 한다는 의미일 뿐입니다. 특정 UI에서 사용자가 전화를 받기 전에 전화를 거부할 수 있도록 허용하는 경우 403\(금지됨\)이 이를 표현하는 좋은 방법입니다. 위의 규칙에 따라 BYE를 보낼 수 없습니다.

---
## **15.1 Terminating a Session with a BYE Request**
---
### **15.1.1 UAC Behavior**

BYE 요청은 섹션 12에 설명된 대로 대화 상자 내의 다른 요청과 마찬가지로 구성됩니다.

BYE가 구성되면 UAC 코어는 새로운 비INVITE 클라이언트 트랜잭션을 생성하고 이를 BYE 요청에 전달합니다. UAC는 BYE 요청이 클라이언트 트랜잭션에 전달되는 즉시 세션이 종료된 것으로 간주해야 합니다\(따라서 미디어 전송 또는 수신이 중지됨\). BYE에 대한 응답이 481\(통화/트랜잭션이 존재하지 않음\) 또는 408\(요청 시간 초과\)이거나 아니요인 경우\(MUST\)

BYE에 대한 응답이 수신되면\(즉, 클라이언트 트랜잭션에서 시간 초과가 반환됨\) UAC는 세션과 대화 종료를 고려해야 합니다.\(MUST\)

---
### **15.1.2 UAS Behavior**

UAS는 먼저 섹션 8.2에 설명된 일반 UAS 처리에 따라 BYE 요청을 처리합니다. BYE 요청을 받은 UAS 코어는 기존 대화와 일치하는지 확인합니다. BYE가 기존 대화 상자와 일치하지 않으면 UAS 코어는 481\(통화/트랜잭션이 존재하지 않음\) 응답을 생성하고 이를 서버 트랜잭션에 전달해야 합니다.\(SHOULD\)

- 이 규칙은 UAC가 태그 없이 전송한 BYE가 거부됨을 의미합니다. 이는 태그 없이 BYE를 허용하는 RFC 2543의 변경 사항입니다.

기존 대화에 대한 BYE 요청을 수신하는 UAS 코어는 요청을 처리하기 위해 섹션 12.2.2의 절차를 따라야 합니다. 완료되면 UAS는 세션을 종료해야 합니다\(그러므로 미디어 전송 및 수신을 중지해야 합니다\). 멀티캐스트 세션을 선택하지 않을 수 있는 유일한 경우는 대화의 다른 참가자가 세션 참여를 종료한 경우에도 참여가 가능한 경우입니다. 세션 참여 종료 여부에 관계없이 UAS 코어는 BYE에 대한 2xx 응답을 생성해야 하며 전송을 위해 이를 서버 트랜잭션에 전달해야 합니다.\(MUST, SHOULD, MUST\)

UAS는 해당 대화에 대해 수신된 보류 중인 요청에 계속 응답해야 합니다. 보류 중인 요청에 대해 487\(요청 종료됨\) 응답을 생성하는 것이 좋습니다.\(MUST, SHOULD\)

---
# **16 Proxy Behavior**
---
## **16.1 Overview**

SIP 프록시는 SIP 요청을 사용자 에이전트 서버로 라우팅하고 SIP 응답을 사용자 에이전트 클라이언트로 라우팅하는 요소입니다. 요청은 UAS로 가는 도중에 여러 프록시를 통과할 수 있습니다. 각각은 라우팅 결정을 내리고 요청을 다음 요소로 전달하기 전에 수정합니다. 응답은 요청이 역순으로 통과한 동일한 프록시 세트를 통해 라우팅됩니다.

프록시가 되는 것은 SIP 요소의 논리적 역할입니다. 요청이 도착하면 프록시 역할을 할 수 있는 요소가 먼저 요청에 자체적으로 응답해야 하는지 결정합니다. 예를 들어, 요청의 형식이 잘못되었거나 요소가 프록시로 작동하기 전에 클라이언트의 자격 증명이 필요할 수 있습니다. 요소는 다음과 같이 응답할 수 있습니다.\(MAY\)

적절한 오류 코드. 요청에 직접 응답할 때 요소는 UAS 역할을 수행하며 섹션 8.2에 설명된 대로 동작해야 합니다.\(MUST\)

프록시는 각각의 새로운 요청에 대해 상태 저장 모드 또는 상태 비저장 모드에서 작동할 수 있습니다. 상태 비저장인 경우 프록시는 단순 전달 요소 역할을 합니다. 요청을 기반으로 타겟팅 및 라우팅 결정을 내려 결정된 단일 요소로 각 요청 다운스트림을 전달합니다. 단순히 업스트림으로 수신한 모든 응답을 전달합니다. 상태 비저장 프록시는 메시지가 전달되면 메시지에 대한 정보를 삭제합니다. 상태 저장 프록시는 들어오는 각 요청과 들어오는 요청을 처리한 결과로 보내는 모든 요청에 ​​대한 정보\(특히 트랜잭션 상태\)를 기억합니다. 이 정보를 사용하여 해당 요청과 관련된 향후 메시지 처리에 영향을 줍니다. 상태 저장 프록시는 요청을 "포크"하여 여러 대상으로 라우팅하도록 선택할 수 있습니다. 둘 이상의 위치로 전달되는 모든 요청은 상태를 유지하여 처리되어야 합니다.\(MAY, MUST\)

어떤 경우에는 프록시가 트랜잭션 상태를 유지하지 않고 상태 저장 전송\(TCP 등\)을 사용하여 요청을 전달할 수도 있습니다. 예를 들어, 프록시는 요청이 도착한 동일한 연결로 응답을 전달할 수 있을 만큼 메시지에 충분한 정보를 저장하는 한 하나의 TCP 연결에서 다른 트랜잭션으로 요청을 무상태로 전달할 수 있습니다. 프록시의 TU가 전송 중 하나에서 안정적인 전달을 보장하기 위해 적극적인 역할을 수행해야 하는 다양한 유형의 전송 간에 전달되는 요청은 트랜잭션을 상태별로 전달해야 합니다.\(MAY, MAY, MUST\)

상태 저장 프록시는 초기에 상태 비저장을 방지하는 작업\(예: 포크 또는 100 응답 생성\)을 수행하지 않는 한 요청을 처리하는 동안 언제든지 상태 비저장 작업으로 전환할 수 있습니다. 이러한 전환을 수행하면 모든 상태가 삭제됩니다. 프록시는 CANCEL 요청을 시작해서는 안 됩니다.\(MAY, SHOULD NOT\)

요청에 대해 상태 비저장 또는 상태 저장 작업을 수행할 때 관련된 처리의 대부분은 동일합니다. 다음 여러 하위 섹션은 상태 저장 프록시의 관점에서 작성되었습니다. 마지막 섹션에서는 상태 비저장 프록시가 다르게 동작하는 위치를 설명합니다.

---
## **16.2 Stateful Proxy**

상태가 유지되는 경우 프록시는 순전히 SIP 트랜잭션 처리 엔진입니다. 그 동작은 섹션 17에 정의된 서버 및 클라이언트 트랜잭션 측면에서 모델링됩니다. 상태 저장 프록시에는 프록시 코어로 알려진 상위 계층 프록시 처리 구성 요소\(그림 3 참조\)에 의해 하나 이상의 클라이언트 트랜잭션과 연결된 서버 트랜잭션이 있습니다. . 들어오는 요청은 서버에 의해 처리됩니다.

거래. 서버 트랜잭션의 요청은 프록시 코어로 전달됩니다. 프록시 코어는 하나 이상의 다음 홉 위치를 선택하여 요청을 라우팅할 위치를 결정합니다. 각 다음 홉 위치에 대한 나가는 요청은 자체 관련 클라이언트 트랜잭션에 의해 처리됩니다. 프록시 코어는 클라이언트 트랜잭션으로부터 응답을 수집하고 이를 사용하여 서버 트랜잭션에 응답을 보냅니다.

상태 저장 프록시는 수신된 각 새 요청에 대해 새 서버 트랜잭션을 생성합니다. 그런 다음 요청의 재전송은 섹션 17에 따라 해당 서버 트랜잭션에 의해 처리됩니다. 프록시 코어는 섹션 8.2.6에 설명된 대로 해당 서버 트랜잭션\(예: 100 Trying\)에 대한 즉각적인 임시 전송과 관련하여 UAS로 작동해야 합니다. 따라서 상태 저장 프록시는 INVITE가 아닌 요청에 대해 100\(시도\) 응답을 생성해서는 안 됩니다.\(MUST, SHOULD NOT\)

이는 소프트웨어가 아닌 프록시 동작 모델입니다. 구현 시 이 모델이 정의하는 외부 동작을 복제하는 접근 방식을 자유롭게 취할 수 있습니다.

알 수 없는 방법을 포함한 모든 새로운 요청의 경우 요청을 프록시하려는 요소는 다음을 수행해야 합니다.\(MUST\)

```text
      1. Validate the request (Section 16.3)

      2. Preprocess routing information (Section 16.4)

      3. Determine target(s) for the request (Section 16.5)

            +--------------------+
            |                    | +---+
            |                    | | C |
            |                    | | T |
            |                    | +---+
      +---+ |       Proxy        | +---+   CT = Client Transaction
      | S | |  "Higher" Layer    | | C |
      | T | |                    | | T |   ST = Server Transaction
      +---+ |                    | +---+
            |                    | +---+
            |                    | | C |
            |                    | | T |
            |                    | +---+
            +--------------------+

               Figure 3: Stateful Proxy Model

      4. Forward the request to each target (Section 16.6)

      5. Process all responses (Section 16.7)
```

---
## **16.3 Request Validation**

요소가 요청을 프록시하려면 먼저 메시지의 유효성을 확인해야 합니다. 유효한 메시지는 다음 검사를 통과해야 합니다.\(MUST\)

```text
      1. Reasonable Syntax

      2. URI scheme

      3. Max-Forwards

      4. (Optional) Loop Detection

      5. Proxy-Require

      6. Proxy-Authorization
```

이러한 검사 중 하나라도 실패하면 요소는 사용자 에이전트 서버\(섹션 8.2 참조\)로 작동하고 오류 코드로 응답해야 합니다.\(MUST\)

병합된 요청을 감지하는 데 프록시가 필요하지 않으며 병합된 요청을 오류 조건으로 처리해서는 안 됩니다. 요청을 수신하는 엔드포인트는 섹션 8.2.2.2에 설명된 대로 병합을 해결합니다.\(MUST NOT\)

```text
   1. Reasonable syntax check
```

- 요청은 서버 트랜잭션으로 처리될 수 있을 만큼 충분히 형식적이어야 합니다. 이러한 요청 유효성 검사 단계의 나머지 부분이나 요청 전달 섹션과 관련된 모든 구성 요소는 올바른 형식이어야 합니다. 형식이 올바른지 여부에 관계없이 다른 모든 구성 요소는 무시되어야 하며 메시지가 전달될 때 변경되지 않은 상태로 유지되어야 합니다. 예를 들어 요소는 잘못된 날짜 헤더 필드로 인해 요청을 거부하지 않습니다. 마찬가지로 프록시는 요청을 전달하기 전에 잘못된 날짜 헤더 필드를 제거하지 않습니다.\(MUST, MUST, SHOULD\)

- 이 프로토콜은 확장되도록 설계되었습니다. 향후 확장에서는 언제든지 새로운 메서드와 헤더 필드를 정의할 수 있습니다. 요소는 자신이 알지 못하는 메소드나 헤더 필드를 포함하고 있기 때문에 요청 프록시를 거부해서는 안 됩니다.\(MUST NOT\)

```text
   2. URI scheme check
```

- 요청-URI에 프록시가 이해할 수 없는 스키마가 있는 경우 프록시는 416\(지원되지 않는 URI 스키마\) 응답으로 요청을 거부해야 합니다.\(SHOULD\)

```text
   3. Max-Forwards check
```

- Max-Forwards 헤더 필드\(섹션 20.22\)는 SIP 요청이 통과할 수 있는 요소 수를 제한하는 데 사용됩니다.

- 요청에 Max-Forwards 헤더 필드가 포함되어 있지 않으면 이 검사가 통과됩니다.

- 요청에 필드 값이 0보다 큰 Max-Forwards 헤더 필드가 포함되어 있으면 검사가 통과됩니다.

- 요청에 필드 값이 0인 Max-Forwards 헤더 필드가 포함된 경우 요소는 요청을 전달해서는 안 됩니다. 요청이 OPTIONS에 대한 것인 경우 요소는 최종 수신자 역할을 하고 섹션 11에 따라 응답할 수 있습니다. 그렇지 않으면 요소는 483\(너무 많은 홉\) 응답을 반환해야 합니다.\(MUST NOT, MAY, MUST\)

```text
   4. Optional Loop Detection check
```

- 요소는 요청을 전달하기 전에 전달 루프를 확인할 수 있습니다. 요청에 프록시가 이전 요청에 배치한 값과 동일한 보낸 사람 값이 있는 Via 헤더 필드가 포함되어 있는 경우 해당 요청은 이전에 이 요소에 의해 전달된 것입니다. 요청이 반복되었거나 요소를 통해 합법적으로 나선형으로 이동하고 있습니다. 요청이 루프되었는지 확인하기 위해 요소는 이 메시지에 대해 섹션 16.6의 8단계에 설명된 분기 매개변수 계산을 수행하고 이를 해당 Via 헤더 필드에서 수신된 매개변수와 비교할 수 있습니다. 매개변수가 일치하면 요청이 루프된 것입니다. 서로 다른 경우 요청이 급증하고 처리가 계속됩니다. 루프가 감지되면 요소는 482\(루프 감지\) 응답을 반환할 수 있습니다.\(MAY, MAY, MAY\)

```text
   5. Proxy-Require check
```

- 이 프로토콜의 향후 확장에는 프록시의 특별한 처리가 필요한 기능이 도입될 수 있습니다. 엔드포인트는 이러한 기능을 사용하는 요청에 Proxy-Require 헤더 필드를 포함하여 기능이 이해되지 않는 한 요청을 처리하지 않도록 프록시에 지시합니다.

- 요청에 이 요소가 이해하지 못하는 하나 이상의 옵션 태그가 있는 Proxy-Require 헤더 필드\(섹션 20.29\)가 포함되어 있는 경우 요소는 420\(잘못된 확장\) 응답을 반환해야 합니다. 응답에는 요소가 이해하지 못한 옵션 태그를 나열하는 지원되지 않는\(섹션 20.40\) 헤더 필드가 포함되어야 합니다.\(MUST, MUST\)

```text
   6. Proxy-Authorization check
```

- 요청을 전달하기 전에 요소에 자격 증명이 필요한 경우 섹션 22.3에 설명된 대로 요청을 검사해야 합니다. 해당 섹션은 검사가 실패할 경우 요소가 수행해야 하는 작업도 정의합니다.\(MUST\)

---
## **16.4 Route Information Preprocessing**

프록시는 요청의 Request-URI를 검사해야 합니다. 요청의 Request-URI에 이 프록시가 이전에 Record-Route 헤더 필드에 배치한 값이 포함된 경우\(섹션 16.6 항목 4 참조\), 프록시는 요청의 Request-URI를 Route 헤더 필드의 마지막 값으로 대체해야 합니다. 을 클릭하고 Route 헤더 필드에서 해당 값을 제거하세요. 그런 다음 프록시는 수정된 요청을 받은 것처럼 진행해야 합니다.\(MUST, MUST, MUST\)

- 이는 요청을 프록시\(엔드포인트일 수 있음\)로 보내는 요소가 엄격한 라우터인 경우에만 발생합니다. 해당 요소와의 하위 호환성을 활성화하려면 수신 시 다시 작성해야 합니다. 또한 이 사양을 따르는 요소는 엄격한 라우팅 프록시를 통해 Request-URI를 보존할 수 있습니다\(섹션 12.2.1.1 참조\).

- 이 요구 사항은 이전에 Record-Route 헤더 필드에 배치된 URI를 감지하기 위해 프록시가 상태를 유지하도록 의무화하지 않습니다. 대신, 프록시는 해당 URI에 나중에 나타날 때 제공한 값으로 인식할 만큼 충분한 정보만 배치하면 됩니다.

요청-URI에 maddr 매개변수가 포함된 경우 프록시는 해당 값이 프록시가 담당하도록 구성된 주소 또는 도메인 집합에 있는지 확인해야 합니다. Request-URI에 프록시가 담당하는 값이 있는 maddr 매개변수가 있고 요청이 Request-URI에 표시된\(명시적으로 또는 기본적으로\) 포트 및 전송을 사용하여 수신된 경우 프록시는 maddr 및 기타 모든 매개변수를 제거해야 합니다. -기본 포트 또는 전송 매개변수를 선택하고 해당 값이 요청에 없는 것처럼 처리를 계속합니다.\(MUST, MUST\)

- 요청은 프록시와 일치하는 maddr로 도착할 수 있지만 URI에 표시된 것과 다른 포트나 전송에 있을 수 있습니다. 이러한 요청은 표시된 포트와 전송을 사용하여 프록시로 전달되어야 합니다.

Route 헤더 필드의 첫 번째 값이 이 프록시를 나타내는 경우 프록시는 요청에서 해당 값을 제거해야 합니다.\(MUST\)

---
## **16.5 Determining Request Targets**

다음으로 프록시는 요청 대상을 계산합니다. 대상 세트는 요청 내용에 따라 미리 결정되거나 추상 위치 서비스에서 획득됩니다. 세트의 각 대상은 URI로 표시됩니다.

요청의 Request-URI에 maddr 매개변수가 포함된 경우 Request-URI는 유일한 대상 URI로 대상 세트에 배치되어야 하며 프록시는 섹션 16.6으로 진행해야 합니다.\(MUST\)

Request-URI의 도메인이 이 요소가 담당하지 않는 도메인을 나타내는 경우 Request-URI는 유일한 대상으로 대상 세트에 배치되어야 하며 요소는 요청 전달 작업\(16.6절\)으로 진행해야 합니다.\(MUST\)

- 프록시가 자신이 담당하지 않는 도메인에 대한 요청을 받을 수 있는 상황이 많이 있습니다. 나가는 호출을 처리하는 방화벽 프록시\(HTTP 프록시가 나가는 요청을 처리하는 방식\)는 이러한 일이 발생할 가능성이 있는 예입니다.

요청에 대한 대상 세트가 위에 설명된 대로 미리 결정되지 않은 경우 이는 요소가 Request-URI의 도메인을 담당하고 요소가 요청을 보낼 위치를 결정하기 위해 원하는 모든 메커니즘을 사용할 수 있음을 의미합니다. 이러한 메커니즘은 모두 추상 위치 서비스에 액세스하는 것으로 모델링될 수 있습니다. 이는 SIP 등록자가 생성한 위치 서비스에서 정보 획득, 데이터베이스 읽기, 존재 서버 컨설팅, 다른 프로토콜 활용 또는 단순히 요청-URI에 대한 알고리즘 대체 수행으로 구성될 수 있습니다. 등록자가 구성한 위치 서비스에 액세스할 때 Request-URI는 인덱스로 사용되기 전에 먼저 섹션 10.3에 설명된 대로 정규화되어야 합니다. 이러한 메커니즘의 출력은 대상 세트를 구성하는 데 사용됩니다.\(MAY, MUST\)

요청-URI가 프록시가 대상 세트를 결정하는 데 충분한 정보를 제공하지 않는 경우 485\(모호함\) 응답을 반환해야 합니다\(SHOULD\). 이 응답에는 시도할 새 주소의 URI가 포함된 연락처 헤더 필드가 포함되어야 합니다. 예를 들어 INVITE\(SHOULD, SHOULD\)

sip:John.Smith@company.com은 위치 서비스에 여러 John Smith가 나열되어 있는 프록시에서는 모호할 수 있습니다. 자세한 내용은 섹션 21.4.23을 참조하세요.

요청 또는 요소의 현재 환경에 대한 모든 정보는 대상 세트 구성에 사용될 수 있습니다. 예를 들어, 헤더 필드와 본문의 내용이나 존재 여부, 요청 도착 시간, 요청이 도착한 인터페이스, 이전 요청의 실패 또는 요소의 현재 활용 수준에 따라 서로 다른 세트가 구성될 수 있습니다. .\(MAY\)

이러한 서비스를 통해 잠재적인 대상을 찾으면 해당 URI가 대상 세트에 추가됩니다. 대상은 대상 세트에 한 번만 배치할 수 있습니다. 대상 URI가 이미 집합에 존재하는 경우\(URI 유형에 대한 동일성 정의에 따라\) 다시 추가하면 안 됩니다.\(MUST NOT\)

원래 요청의 Request-URI가 이 프록시가 담당하는 리소스를 나타내지 않는 경우 프록시는 대상 세트에 추가 대상을 추가해서는 안 됩니다.\(MUST NOT\)

- 프록시는 해당 URI를 담당하는 경우 전달 중에 요청의 요청-URI만 변경할 수 있습니다. 프록시가 해당 URI를 담당하지 않는 경우 아래 설명된 대로 3xx 또는 416 응답에서 반복되지 않습니다.

원래 요청의 Request-URI가 이 프록시가 담당하는 리소스를 나타내는 경우 프록시는 요청 전달을 시작한 후 세트에 대상을 계속 추가할 수 있습니다. 새로운 목표를 결정하기 위해 해당 처리 중에 얻은 정보를 사용할 수 있습니다. 예를 들어 프록시는 리디렉션 응답\(3xx\)에서 얻은 연락처를 대상 세트에 통합하도록 선택할 수 있습니다. 프록시가 대상 세트를 구축하는 동안 동적 정보 소스를 사용하는 경우\(예: SIP 등록 기관에 문의하는 경우\) 요청을 처리하는 동안 해당 소스를 모니터링해야 합니다. 새로운 위치가 사용 가능해지면 대상 세트에 추가해야 합니다. 위와 마찬가지로 특정 URI를 세트에 두 번 이상 추가하면 안 됩니다.\(MAY, MAY, SHOULD, SHOULD, MUST NOT\)

URI가 세트에 한 번만 추가되도록 허용하면 감소합니다.

- 불필요한 네트워크 트래픽 및 리디렉션 요청의 연락처를 통합하는 경우 무한 재귀를 방지합니다.

예를 들어, 간단한 위치 서비스는 대상 URI가 들어오는 요청 URI와 동일한 "no-op"입니다. 추가 처리를 위해 요청이 특정 다음 홉 프록시로 전송됩니다. 요청시

섹션 16.6, 항목 6을 전달하면 SIP 또는 SIPS URI로 표현되는 다음 홉의 ID가 요청의 최상위 경로 헤더 필드 값으로 삽입됩니다.

요청-URI가 존재하지 않는 이 프록시의 리소스를 나타내는 경우 프록시는 404\(찾을 수 없음\) 응답을 반환해야 합니다.\(MUST\)

위의 사항을 모두 적용한 후에도 대상 세트가 비어 있는 경우 프록시는 480\(일시적으로 사용할 수 없음\) 응답이어야 하는 오류 응답을 반환해야 합니다.\(MUST\)

---
## **16.6 Request Forwarding**

대상 세트가 비어 있지 않은 즉시 프록시는 요청 전달을 시작할 수 있습니다. 상태 저장 프록시는 어떤 순서로든 집합을 처리할 수 있습니다. 여러 대상을 순차적으로 처리하여 각 클라이언트 트랜잭션이 다음 트랜잭션을 시작하기 전에 완료되도록 할 수 있습니다. 모든 대상과 동시에 클라이언트 트랜잭션을 시작할 수 있습니다. 또한 세트를 임의로 그룹으로 나누어 그룹을 직렬로 처리하고 각 그룹의 대상을 병렬로 처리할 수도 있습니다.\(MAY, MAY, MAY, MAY, MAY\)

일반적인 순서 메커니즘은 연락처 헤더 필드에서 얻은 대상의 qvalue 매개변수를 사용하는 것입니다\(섹션 20.10 참조\). 대상은 가장 높은 q값에서 가장 낮은 값으로 처리됩니다. 동일한 q값을 가진 대상은 병렬로 처리될 수 있습니다.

상태 저장 프록시에는 응답이 수신될 때 대상 세트를 유지하고 전달된 각 요청에 대한 응답을 원래 요청과 연결하는 메커니즘이 있어야 합니다. 이 모델의 목적에 따라 이 메커니즘은 첫 번째 요청을 전달하기 전에 프록시 계층에서 생성된 "응답 컨텍스트"입니다.

각 대상에 대해 프록시는 다음 단계에 따라 요청을 전달합니다.

- 1. 접수된 요청의 사본을 만듭니다.

- 2. 요청-URI 업데이트

- 3. Max-Forwards 헤더 필드 업데이트

- 4. 선택적으로 레코드 경로 헤더 필드 값을 추가합니다.

```text
      5.  Optionally add additional header fields

      6.  Postprocess routing information
```

- 7. 다음 홉 주소, 포트 및 전송을 결정합니다.

- 8. Via 헤더 필드 값을 추가합니다.

- 9. 필요한 경우 Content-Length 헤더 필드를 추가합니다.

- 10. 새로운 요청 전달

```text
      11. Set timer C
```

각 단계는 아래에 자세히 설명되어 있습니다.

```text
      1. Copy request
```

- 프록시는 수신된 요청의 복사본으로 시작됩니다. 사본은 처음에 수신된 요청의 모든 헤더 필드를 포함해야 합니다. 아래 설명된 처리에 자세히 설명되지 않은 필드는 제거하면 안 됩니다. 복사본은 수신된 요청에서와 같이 헤더 필드의 순서를 유지해야 합니다\(SHOULD\). 프록시는 공통 필드 이름으로 필드 값을 재정렬해서는 안 됩니다\(섹션 7.3.1 참조\). 프록시는 메시지 본문을 추가, 수정 또는 제거해서는 안 됩니다.\(MUST, MUST NOT, SHOULD, MUST NOT, MUST NOT\)

- 실제 구현에서는 복사를 수행할 필요가 없습니다. 기본 요구 사항은 각 다음 홉에 대한 처리가 동일한 요청으로 시작된다는 것입니다.

```text
      2. Request-URI
```

- 사본의 시작 줄에 있는 Request-URI는 이 대상에 대한 URI로 대체되어야 합니다. URI에 Request-URI에서 허용되지 않는 매개변수가 포함되어 있으면 해당 매개변수를 제거해야 합니다.\(MUST, MUST\)

- 이것이 대리 역할의 본질이다. 이는 프록시가 요청을 대상으로 라우팅하는 메커니즘입니다.

- 어떤 경우에는 수신된 Request-URI가 수정되지 않고 대상 세트에 배치됩니다. 해당 대상의 경우 위의 교체는 사실상 무작동입니다.

```text
      3. Max-Forwards
```

- 복사본에 Max-Forwards 헤더 필드가 포함된 경우 프록시는 해당 값을 1씩 줄여야 합니다.\(MUST\)

- 복사본에 Max-Forwards 헤더 필드가 포함되어 있지 않은 경우 프록시는 필드 값이 70이어야 하는 헤더 필드를 추가해야 합니다.\(MUST\)

- 일부 기존 UA는 요청에 Max-Forwards 헤더 필드를 제공하지 않습니다.

```text
      4. Record-Route
```

- 이 프록시가 이 요청에 의해 생성된 대화 상자에서 향후 요청 경로에 남아 있으려면\(요청이 대화 상자를 생성한다고 가정\) 기존 Record-Route 헤더 필드 앞에 Record-Route 헤더 필드 값을 복사본에 삽입해야 합니다. Route 헤더 필드가 이미 존재하는 경우에도 마찬가지입니다.\(MUST\)

- 대화 상자 설정 요청에는 미리 로드된 경로 헤더 필드가 포함될 수 있습니다.

- 이 요청이 이미 대화 상자의 일부인 경우 프록시는 대화 상자의 향후 요청 경로에 남아 있으려면 Record-Route 헤더 필드 값을 삽입해야 합니다. 섹션 12에 설명된 대로 일반적인 끝점 작업에서 이러한 Record-Route 헤더 필드 값은 끝점에서 사용되는 경로 집합에 어떤 영향도 미치지 않습니다.\(SHOULD\)

- 이미 대화의 일부인 요청에 Record-Route 헤더 필드 값을 삽입하지 않기로 선택한 경우 프록시는 경로에 남아 있습니다. 그러나 실패한 엔드포인트가 대화를 재구성하면 경로에서 제거됩니다.

- 프록시는 요청에 Record-Route 헤더 필드 값을 삽입할 수 있습니다. 요청이 대화를 시작하지 않으면 엔드포인트는 값을 무시합니다. 엔드포인트가 Record-Route 헤더 필드 값을 사용하여 경로 헤더 필드를 구성하는 방법에 대한 자세한 내용은 섹션 12를 참조하세요.\(MAY\)

- 요청 경로의 각 프록시는 Record-Route 헤더 필드 값을 독립적으로 추가할지 여부를 선택합니다. 요청에 Record-Route 헤더 필드가 있다고 해서 이 프록시가 값을 추가해야 하는 것은 아닙니다.

- Record-Route 헤더 필드 값에 있는 URI는 SIP 또는 SIPS URI여야 합니다. 이 URI는 lr 매개변수를 포함해야 합니다\(섹션 19.1.1 참조\). 이 URI는 요청이 전달되는 각 대상마다 다를 수 있습니다. 프록시가 후속 요청 경로에 있을 다음 다운스트림 요소가 해당 전송을 지원한다는 사실을 프록시가 알지 못하는 경우\(예: 개인 네트워크에서\) URI는 전송 매개변수를 포함해서는 안 됩니다.\(MUST, MUST, MAY, SHOULD NOT\)

- 이 프록시가 제공하는 URI는 다른 요소에서 라우팅 결정을 내리는 데 사용됩니다. 일반적으로 이 프록시는 해당 요소의 기능을 알 수 있는 방법이 없으므로 SIP 구현의 필수 요소인 SIP URI와 TCP 또는 UDP 전송으로 제한되어야 합니다.

- Record-Route 헤더 필드에 배치된 URI는 \[4\]의 서버 위치 절차가 적용될 때 이를 삽입하는 요소\(또는 적절한 대체 요소\)로 해석되어야 후속 요청이 동일한 SIP 요소에 도달할 수 있습니다. 요청-URI에 SIPS URI가 포함되어 있거나 최상위 경로 헤더 필드 값\(글머리 기호 6의 사후 처리 후\)에 SIPS URI가 포함되어 있는 경우 레코드-경로 헤더 필드에 배치된 URI는 SIPS URI여야 합니다. 또한 요청이 TLS를 통해 수신되지 않은 경우 프록시는 Record-Route 헤더 필드를 삽입해야 합니다. 비슷한 방식으로 TLS를 통해 요청을 수신하지만 요청-URI 또는 ​​최상위 경로 헤더 필드 값\(6번 항목의 사후 처리 후\)에 SIPS URI 없이 요청을 생성하는 프록시는 반드시 Record-Route 헤더를 삽입해야 합니다. SIPS URI가 아닌 필드입니다.\(MUST, MUST, MUST, MUST\)

- 보안 경계의 프록시는 대화 전체에서 경계에 남아 있어야 합니다.

- Record-Route 헤더 필드에 있는 URI가 응답을 다시 통과할 때 다시 작성되어야 하는 경우 URI는 해당 시점에 찾을 수 있을 만큼 충분히 구별되어야 합니다. \(요청이 이 프록시를 통해 나선형으로 진행되어 둘 이상의 Record-Route 헤더 필드 값이 추가될 수 있습니다.\) 섹션 16.7의 항목 8에서는 URI를 충분히 구별할 수 있는 메커니즘을 권장합니다.\(MUST\)

- 프록시는 Record-Route 헤더 필드 값에 매개변수를 포함할 수 있습니다. 이는 INVITE에 대한 200\(OK\) 응답과 같은 요청에 대한 일부 응답에 반영됩니다. 이러한 매개변수는 프록시가 아닌 메시지의 상태를 유지하는 데 유용할 수 있습니다.\(MAY\)

- 프록시가 모든 유형의 대화 경로\(예: 방화벽을 가로지르는 경로\)에 있어야 하는 경우, 해당 메소드에 대화가 있을 수 있으므로 이해하지 못하는 메소드를 사용하여 모든 요청에 ​​Record-Route 헤더 필드 값을 추가해야 합니다. 의미론.\(SHOULD\)

- 프록시가 Record-Route 헤더 필드에 배치한 URI는 해당 대화가 발생한 트랜잭션에 의해 생성된 모든 대화의 수명 동안에만 유효합니다. 예를 들어, 대화 상자 상태 프록시는 대화가 종료된 후 Request-URI에 해당 값이 있는 향후 요청 수락을 거부할 수 있습니다. 물론 비대화 상태 유지 프록시는 대화가 언제 종료되는지에 대한 개념이 없지만 값에 충분한 정보를 인코딩하여 향후 요청의 대화 식별자와 비교할 수 있으며 해당 정보와 일치하지 않는 요청을 거부할 수 있습니다. 엔드포인트는 제공된 대화 상자 외부의 Record-Route 헤더 필드에서 얻은 URI를 사용해서는 안 됩니다. 보다\(MAY, MAY, MUST NOT\)

- 엔드포인트의 Record-Route 헤더 필드 사용에 대한 자세한 내용은 섹션 12를 참조하세요.

- 프록시가 대화 상자의 모든 메시지를 관찰해야 하는 특정 서비스에서는 기록 라우팅이 필요할 수 있습니다. 그러나 처리 속도가 느려지고 확장성이 손상되므로 프록시는 특정 서비스에 필요한 경우에만 기록 경로를 지정해야 합니다.

- Record-Route 프로세스는 대화를 시작하는 모든 SIP 요청에 대해 작동하도록 설계되었습니다. INVITE는 이 사양에서 유일한 요청이지만 프로토콜 확장은 다른 요청을 정의할 수도 있습니다.\(MAY\)

```text
      5. Add Additional Header Fields
```

- 프록시는 이 시점에서 복사본에 다른 적절한 헤더 필드를 추가할 수 있습니다.\(MAY\)

```text
      6. Postprocess routing information
```

- 프록시에는 요청이 대상으로 전달되기 전에 특정 프록시 집합을 방문하도록 요구하는 로컬 정책이 있을 수 있습니다. 프록시는 이러한 모든 프록시가 느슨한 라우터인지 확인해야 합니다. 일반적으로 이는 프록시가 동일한 관리 도메인 내에 있는 경우에만 확실하게 알 수 있습니다. 이 프록시 세트는 URI 세트\(각각 lr 매개변수 포함\)로 표시됩니다. 이 세트는 기존 값\(있는 경우\)보다 먼저 복사본의 경로 헤더 필드에 푸시되어야 합니다. Route 헤더 필드가 없으면 해당 URI 목록을 포함하여 추가해야 합니다.\(MAY, MUST, MUST, MUST\)

- 프록시에 요청이 하나의 특정 프록시를 방문하도록 요구하는 로컬 정책이 있는 경우 Route 헤더 필드에 Route 값을 푸시하는 대신 아래 항목 10의 전달 논리를 우회하고 대신 해당 주소로 요청을 보내는 것입니다. , 포트 및 해당 특정 프록시에 대한 전송. 요청에 Route 헤더 필드가 있는 경우 다음 홉 프록시가 느슨한 라우터라는 것이 알려지지 않는 한 이 대안을 사용해서는 안 됩니다. 그렇지 않으면 이 접근 방식을 사용할 수 있지만 위의 경로 삽입 메커니즘은 견고성, 유연성, 일반성 및 작업 일관성 때문에 선호됩니다. 또한 요청-URI에 SIPS URI가 포함되어 있는 경우 해당 프록시와 통신하려면 TLS를 사용해야 합니다.\(MUST NOT, MAY, MUST\)

- 복사본에 Route 헤더 필드가 포함된 경우 프록시는 첫 번째 값에서 URI를 검사해야 합니다. 해당 URI에 lr 매개변수가 포함되어 있지 않으면 프록시는 다음과 같이 복사본을 수정해야 합니다.\(MUST, MUST\)

- - 프록시는 Request-URI를 Route 헤더 필드의 마지막 값으로 배치해야 합니다.\(MUST\)

- - 프록시는 첫 번째 Route 헤더 필드 값을 Request-URI에 배치하고 Route 헤더 필드에서 해당 값을 제거해야 합니다.\(MUST\)

- Route 헤더 필드에 Request-URI를 추가하는 것은 엄격한 라우팅 요소를 통해 해당 Request-URI의 정보를 전달하는 데 사용되는 메커니즘의 일부입니다. 첫 번째 Route 헤더 필드 값을 Request-URI에 "팝핑"하면 엄격한 라우팅 요소가 수신할 것으로 예상되는 방식으로 메시지 형식이 지정됩니다\(요청-URI의 자체 URI와 첫 번째 Route 헤더 필드에 방문할 다음 위치 포함\). 값\).

- 7. 다음 홉 주소, 포트 및 전송 결정

- 프록시는 경로 및 요청-URI의 값에 관계없이 특정 IP 주소, 포트 및 전송으로 요청을 보내는 로컬 정책을 가질 수 있습니다. 프록시가 IP 주소, 포트 및 전송이 느슨한 라우터인 서버에 해당하는지 확실하지 않은 경우 이러한 정책을 사용해서는 안 됩니다. 그러나 특정 다음 홉을 통해 요청을 보내는 이 메커니즘은 권장되지 않습니다. 대신 위에서 설명한 대로 경로 헤더 필드를 해당 목적으로 사용해야 합니다.\(MAY, MUST NOT, SHOULD NOT\)

- 이러한 우선적 메커니즘이 없는 경우 프록시는 요청을 보낼 위치를 결정하기 위해 다음과 같이 \[4\]에 나열된 절차를 적용합니다. 프록시가 위의 6단계에 설명된 대로 엄격한 라우팅 요소로 보내기 위해 요청을 다시 포맷한 경우 프록시는 해당 절차를 요청의 요청-URI에 적용해야 합니다. 그렇지 않은 경우 프록시는 경로 헤더 필드의 첫 번째 값\(있는 경우\)에 절차를 적용해야 하며, 그렇지 않은 경우에는 Request-URI를 적용해야 합니다. 절차는 순서가 지정된 \(주소, 포트, 전송\) 튜플 세트를 생성합니다. 어떤 URI가 \[4\]의 절차에 대한 입력으로 사용되는지와 관계없이 요청-URI가 SIPS 리소스를 지정하는 경우 프록시는 입력 URI가 SIPS URI인 것처럼 \[4\]의 절차를 따라야 합니다.\(MUST, MUST, MUST\)

- \[4\]에 설명된 대로 프록시는 해당 집합의 첫 번째 튜플에 메시지 전달을 시도해야 하며 전달 시도가 성공할 때까지 집합을 순서대로 진행해야 합니다.\(MUST\)

- 시도된 각 튜플에 대해 프록시는 튜플에 맞게 메시지 형식을 지정하고 8\~10단계에 자세히 설명된 대로 새 클라이언트 트랜잭션을 사용하여 요청을 보내야 합니다.\(MUST\)

- 각 시도는 새로운 클라이언트 트랜잭션을 사용하므로 새로운 분기를 나타냅니다. 따라서 8단계에서 삽입된 Via 헤더 필드와 함께 제공되는 분기 매개변수는 각 시도마다 달라야 합니다.\(MUST\)

- 클라이언트 트랜잭션이 요청 전송 실패 또는 상태 머신의 시간 초과를 보고하는 경우 프록시는 순서가 지정된 세트의 다음 주소로 계속 진행합니다. 주문된 세트가 소진되면 요청을 대상 세트의 이 요소로 전달할 수 없습니다. 프록시는 응답 컨텍스트에 아무 것도 배치할 필요가 없지만 그렇지 않으면 대상 세트의 이 요소가 408\(요청 시간 초과\) 최종 응답을 반환한 것처럼 작동합니다.

- 8. Via 헤더 필드 값을 추가합니다.

- 프록시는 기존 Via 헤더 필드 값 앞에 Via 헤더 필드 값을 복사본에 삽입해야 합니다. 이 값의 구성은 섹션 8.1.1.7의 동일한 지침을 따릅니다. 이는 프록시가 해당 분기에 대해 전역적으로 고유하고 필요한 매직 쿠키를 포함하는 자체 분기 매개변수를 계산한다는 것을 의미합니다. 이는 프록시를 통한 나선형 또는 루프형 요청의 인스턴스마다 분기 매개변수가 다르다는 것을 의미합니다.\(MUST\)

- 루프를 감지하도록 선택한 프록시에는 분기 매개변수 구성에 사용하는 값에 추가 제약이 있습니다. 루프를 감지하도록 선택하는 프록시는 구현에 따라 두 부분으로 분리할 수 있는 분기 매개변수를 생성해야 합니다\(SHOULD\). 첫 번째 부분은 위에서 설명한 대로 섹션 8.1.1.7의 제약 조건을 충족해야 합니다. 두 번째는 루프 감지를 수행하고 루프와 나선을 구별하는 데 사용됩니다.\(SHOULD, MUST\)

- 루프 감지는 요청이 프록시로 반환될 때 요청 처리에 영향을 미치는 필드가 변경되지 않았는지 확인하여 수행됩니다. 분기 매개변수의 이 부분에 있는 값은 해당 필드\(Route, Proxy-Require 및 Proxy-Authorization 헤더 필드 포함\)를 모두 반영해야 합니다. 이는 요청이 프록시로 다시 라우팅되고 해당 필드 중 하나가 변경되면 루프가 아닌 나선형으로 처리되도록 하기 위한 것입니다\(섹션 16.3 참조\). 이 값을 생성하는 일반적인 방법은 To 태그, From 태그, Call-ID 헤더 필드, 수신된 요청의 Request-URI\(번역 전\), 최상위 Via 헤더 및 시퀀스 번호의 암호화 해시를 계산하는 것입니다. 존재할 수 있는 모든 Proxy-Require 및 Proxy-Authorization 헤더 필드 외에 CSeq 헤더 필드. 그만큼\(SHOULD\)

- 해시를 계산하는 데 사용되는 알고리즘은 구현에 따라 다르지만 16진수로 표현되는 MD5\(RFC 1321 \[35\]\)가 합리적인 선택입니다. \(토큰에는 Base64가 허용되지 않습니다.\)

- 프록시가 루프를 감지하려는 경우 프록시가 제공하는 "branch" 매개변수는 들어오는 요청-URI 및 요청 승인 또는 라우팅에 영향을 미치는 모든 헤더 필드를 포함하여 요청 처리에 영향을 미치는 모든 정보에 의존해야 합니다. 이는 이 서버로 반환되기 전에 라우팅 매개변수가 변경된 요청과 루프된 요청을 구별하는 데 필요합니다.\(MUST\)

- 요청 방법은 분기 매개변수 계산에 포함되어서는 안 됩니다. 특히 CANCEL 및 ACK 요청\(2xx가 아닌 응답의 경우\)은 취소하거나 확인하는 해당 요청과 동일한 분기 값을 가져야 합니다. 분기 매개변수는 요청을 처리하는 서버에서 해당 요청을 연관시키는 데 사용됩니다\(섹션 17.2.3 및 9.2 참조\).\(MUST NOT, MUST\)

- 9. 필요한 경우 Content-Length 헤더 필드를 추가합니다.

- 요청이 스트림 기반 전송을 사용하여 다음 홉으로 전송되고 복사본에 Content-Length 헤더 필드가 포함되어 있지 않은 경우 프록시는 요청 본문에 대한 올바른 값이 있는 헤더 필드를 삽입해야 합니다\(섹션 20.14 참조\).\(MUST\)

```text
      10. Forward Request
```

- 상태 저장 프록시는 섹션 17.1에 설명된 대로 이 요청에 대한 새로운 클라이언트 트랜잭션을 생성해야 하며 트랜잭션이 7단계에서 결정된 주소, 포트 및 전송을 사용하여 요청을 보내도록 지시해야 합니다.\(MUST\)

```text
      11. Set timer C
```

- INVITE 요청이 최종 응답을 생성하지 않는 경우를 처리하기 위해 TU는 타이머 C라고 하는 타이머를 사용합니다. INVITE 요청이 프록시될 때 각 클라이언트 트랜잭션에 대해 타이머 C를 설정해야 합니다. 타이머는 3분보다 커야 합니다. 섹션 16.7 글머리 기호 2에서는 이 타이머가 임시 응답으로 업데이트되는 방법을 설명하고 섹션 16.8에서는 타이머가 실행될 때 처리하는 방법을 설명합니다.\(MUST, MUST\)

---
## **16.7 Response Processing**

요소가 응답을 받으면 먼저 응답과 일치하는 클라이언트 트랜잭션\(17.1.3 단원\)을 찾으려고 시도합니다. 아무 것도 발견되지 않으면 요소는 응답\(정보 응답인 경우에도\)을 무상태 프록시\(아래 설명\)로 처리해야 합니다. 일치하는 항목이 발견되면 응답이 클라이언트 트랜잭션으로 전달됩니다.\(MUST\)

- 클라이언트 트랜잭션\(또는 더 일반적으로 관련 요청을 보낸 것에 대한 지식\)이 발견되지 않은 응답을 전달하면 견고성이 향상됩니다. 특히 INVITE 요청에 대한 "지연" 2xx 응답이 올바르게 전달되도록 보장합니다.

클라이언트 트랜잭션이 프록시 계층에 응답을 전달할 때 다음 처리가 이루어져야 합니다.\(MUST\)

- 1. 적절한 응답 컨텍스트 찾기

- 2. 임시 응답을 위한 타이머 C 업데이트

- 3. 최상위 Via를 제거합니다.

- 4. 응답 컨텍스트에 응답을 추가합니다.

- 5. 이 응답을 즉시 전달해야 하는지 확인하세요.

- 6. 필요한 경우 응답 컨텍스트에서 가장 적합한 최종 응답을 선택합니다.

응답 컨텍스트와 관련된 모든 클라이언트 트랜잭션이 종료된 후 최종 응답이 전달되지 않은 경우 프록시는 지금까지 본 응답 중에서 "최상의" 응답을 선택하여 전달해야 합니다.

전달되는 각 응답에 대해 다음 처리를 수행해야 합니다. 각 요청에 대해 둘 이상의 응답\(적어도 각각의 임시 응답과 하나의 최종 응답\)이 전달될 가능성이 높습니다.\(MUST\)

- 7. 필요한 경우 인증 헤더 필드 값을 집계합니다.

```text
      8.  Optionally rewrite Record-Route header field values
```

- 9. 응답 전달

```text
      10. Generate any necessary CANCEL requests
```

위의 각 단계는 아래에 자세히 설명되어 있습니다.

```text
      1.  Find Context
```

- 프록시는 섹션 16.6에 설명된 키를 사용하여 원래 요청을 전달하기 전에 생성된 "응답 컨텍스트"를 찾습니다. 나머지 처리 단계는 이 컨텍스트에서 수행됩니다.

- 2. 임시 응답을 위한 타이머 C 업데이트

- INVITE 트랜잭션의 경우 응답이 상태 코드 101\~199\(즉, 100 제외\)를 포함하는 임시 응답인 경우 프록시는 해당 클라이언트 트랜잭션에 대해 타이머 C를 재설정해야 합니다. 타이머는 다른 값으로 재설정될 수 있지만 이 값은 3분보다 커야 합니다.\(MUST, MUST\)

```text
      3.  Via
```

- 프록시는 응답에서 최상위 Via 헤더 필드 값을 제거합니다.

- 응답에 Via 헤더 필드 값이 남아 있지 않으면 응답은 이 요소에 대한 것이므로 전달되어서는 안 됩니다. 이 섹션에 설명된 나머지 처리는 이 메시지에 대해 수행되지 않으며 대신 섹션 8.1.3에 설명된 UAC 처리 규칙을 따릅니다\(전송 계층 처리가 이미 발생했습니다\).\(MUST NOT\)

- 예를 들어 요소가 섹션 10에 설명된 대로 CANCEL 요청을 생성하는 경우 이러한 상황이 발생합니다.

- 4. 상황에 대한 응답 추가

- 수신된 최종 응답은 이 컨텍스트와 연관된 서버 트랜잭션에서 최종 응답이 생성될 때까지 응답 컨텍스트에 저장됩니다. 응답은 해당 서버 트랜잭션에서 반환될 최상의 최종 응답 후보일 수 있습니다. 이 응답을 선택하지 않더라도 최선의 응답을 형성하려면 이 응답에서 얻은 정보가 필요할 수 있습니다.

- 프록시가 3xx 응답의 모든 연락처를 대상 세트에 추가하여 반복하도록 선택한 경우 응답을 응답 컨텍스트에 추가하기 전에 응답에서 해당 연락처를 제거해야 합니다. 그러나 원래 요청의 Request-URI가 SIPS URI인 경우 프록시는 SIPS가 아닌 URI로 반복되어서는 안 됩니다. 만약에\(MUST, SHOULD NOT\)

- 프록시는 3xx 응답의 모든 연락처에서 반복되며, 프록시는 결과 비접촉 응답을 응답 컨텍스트에 추가해서는 안 됩니다.\(SHOULD NOT\)

- 응답 컨텍스트에 응답을 추가하기 전에 연락처를 제거하면 업스트림의 다음 요소가 이 프록시가 이미 시도한 위치를 다시 시도하는 것을 방지할 수 있습니다.

- 3xx 응답에는 SIP, SIPS 및 비SIP URI가 혼합되어 포함될 수 있습니다. 프록시는 SIP 및 SIPS URI에서 반복되도록 선택하고 나머지를 잠재적으로 최종 응답에서 반환되도록 응답 컨텍스트에 배치할 수 있습니다.

- 요청-URI 체계가 SIP가 아니었지만 원래 수신된 요청의 체계가 SIP 또는 SIPS인 요청에 대해 프록시가 416\(지원되지 않는 URI 체계\) 응답을 수신하는 경우\(즉, 프록시가 체계를 SIP 또는 SIPS에서 변경한 경우\) 요청을 프록시할 때 다른 항목으로\) 프록시는 대상 세트에 새 URI를 추가해야 합니다. 이 URI는 방금 시도한 비 SIP URI의 SIP URI 버전이어야 합니다. 전화 URL의 경우 전화 URL의 전화 가입자 부분을 SIP URI의 사용자 부분에 배치하고 호스트 부분을 이전 요청이 전송된 도메인으로 설정하여 이를 수행합니다. 전화 URL에서 SIP URI를 구성하는 방법에 대한 자세한 내용은 섹션 19.1.6을 참조하세요.\(SHOULD, SHOULD\)

- 3xx 응답과 마찬가지로 프록시가 SIP 또는 SIPS URI를 대신 시도하여 416에서 "반복"하는 경우 416 응답을 응답 컨텍스트에 추가하면 안 됩니다.\(SHOULD NOT\)

- 5. 전달에 대한 응답 확인

- 서버 트랜잭션에서 최종 응답이 전송될 때까지 다음 응답을 즉시 전달해야 합니다.\(MUST\)

```text
         -  Any provisional response other than 100 (Trying)

         -  Any 2xx response
```

- 6xx 응답이 수신되면 즉시 전달되지 않지만 상태 저장 프록시는 섹션 10에 설명된 대로 클라이언트 보류 중인 모든 트랜잭션을 취소해야 하며 이 컨텍스트에서 새 분기를 생성해서는 안 됩니다.\(MUST NOT\)

- 이는 프록시가 6xx 응답을 즉시 전달하도록 요구하는 RFC 2543의 변경 사항입니다. INVITE 트랜잭션의 경우 이 접근 방식에는 2xx 응답이 다른 분기에 도착할 수 있다는 문제가 있었습니다. 이 경우 프록시는

- 2xx를 전달해야 합니다. 결과적으로 UAC는 6xx 응답을 수신한 후 2xx 응답을 수신할 수 있었으며, 이는 절대 허용되어서는 안 됩니다. 새로운 규칙에 따라 6xx를 수신하면 프록시는 CANCEL 요청을 발행합니다. 이 요청은 일반적으로 모든 미해결 클라이언트 트랜잭션에서 487 응답을 가져온 다음 해당 시점에서 6xx가 업스트림으로 전달됩니다.

- 서버 트랜잭션에서 최종 응답이 전송된 후 다음 응답을 즉시 전달해야 합니다.\(MUST\)

- - INVITE 요청에 대한 모든 2xx 응답

- 상태 저장 프록시는 다른 응답을 즉시 전달해서는 안 됩니다. 특히 상태 저장 프록시는 100\(시도 중\) 응답을 전달해서는 안 됩니다. 나중에 "최상의" 응답으로 전달할 후보 응답은 "컨텍스트에 응답 추가" 단계에 설명된 대로 수집되었습니다.\(MUST NOT, MUST NOT\)

- 즉시 전달을 위해 선택된 모든 응답은 "기록 경로"를 통해 "집계 인증 헤더 필드 값" 단계에 설명된 대로 처리되어야 합니다.\(MUST\)

- 다음 단계와 결합된 이 단계는 상태 저장 프록시가 비INVITE 요청에 대해 정확히 하나의 최종 응답을 전달하고 INVITE 요청에 대해 정확히 하나의 비-2xx 응답 또는 하나 이상의 2xx 응답을 전달하도록 보장합니다.

- 6. 최선의 응답 선택

- 위의 규칙에 따라 최종 응답이 즉시 전달되지 않고 이 응답 컨텍스트의 모든 클라이언트 트랜잭션이 종료된 경우 상태 저장 프록시는 응답 컨텍스트의 서버 트랜잭션에 최종 응답을 보내야 합니다.\(MUST\)

- 상태 저장 프록시는 응답 컨텍스트에서 수신되고 저장된 응답 중에서 "최상의" 최종 응답을 선택해야 합니다.\(MUST\)

- 컨텍스트에 최종 응답이 없는 경우 프록시는 서버 트랜잭션에 408\(요청 시간 초과\) 응답을 보내야 합니다.\(MUST\)

- 그렇지 않으면 프록시는 응답 컨텍스트에 저장된 응답의 응답을 전달해야 합니다. 컨텍스트에 존재하는 경우 6xx 클래스 응답 중에서 선택해야 합니다. 6xx 클래스 응답이 없으면 프록시는 응답 컨텍스트에 저장된 가장 낮은 응답 클래스에서 선택해야 합니다. 프록시는 선택한 클래스 내의 모든 응답을 선택할 수 있습니다. 프록시는 다음과 같습니다.\(MUST, MUST, SHOULD, MAY, SHOULD\)

- 4xx 클래스가 선택된 경우 401, 407, 415, 420 및 484와 같이 이 요청의 재제출에 영향을 미치는 정보를 제공하는 응답을 우선적으로 사용합니다.

- 503\(서비스를 사용할 수 없음\) 응답을 수신한 프록시는 자신이 프록시할 수 있는 후속 요청도 503을 생성할 것이라고 판단할 수 없는 한 이를 업스트림으로 전달해서는 안 됩니다. 즉, 503을 전달한다는 것은 프록시가 어떤 서비스도 제공할 수 없다는 것을 알고 있음을 의미합니다. 503을 생성한 요청의 Request-URI에 대한 요청만이 아닙니다. 수신된 유일한 응답이 503인 경우 프록시는 500 응답을 생성하고 해당 업스트림을 전달해야 합니다\(SHOULD\).\(SHOULD NOT, SHOULD\)

- 전달된 응답은 "기록-경로"를 통해 "집계 인증 헤더 필드 값" 단계에 설명된 대로 처리되어야 합니다.\(MUST\)

- 예를 들어 프록시가 요청을 4개 위치로 전달하고 503, 407, 501 및 404 응답을 받은 경우 407\(프록시 인증 필요\) 응답을 전달하도록 선택할 수 있습니다.

- 1xx 및 2xx 응답이 대화 설정에 포함될 수 있습니다. 요청에 To 태그가 포함되어 있지 않으면 UAC는 응답의 To 태그를 사용하여 대화 상자 생성 요청에 대한 여러 응답을 구별합니다. 요청에 태그가 포함되어 있지 않은 경우 프록시는 1xx 또는 2xx 응답의 To 헤더 필드에 태그를 삽입해서는 안 됩니다. 프록시는 1xx 또는 2xx 응답의 To 헤더 필드에 있는 태그를 수정해서는 안 됩니다.\(MUST NOT, MUST NOT\)

- 프록시는 태그가 포함되지 않은 요청에 대한 1xx 응답의 To 헤더 필드에 태그를 삽입할 수 없으므로 자체적으로 100이 아닌 임시 응답을 발행할 수 없습니다. 그러나 요청을 프록시와 동일한 요소를 공유하는 UAS로 분기할 수 있습니다. 이 UAS는 요청 개시자와 초기 대화를 시작하여 자체 임시 응답을 반환할 수 있습니다. UAS는 프록시의 신중한 프로세스일 필요는 없습니다. 이는 프록시와 동일한 코드 공간에 구현된 가상 UAS일 수 있습니다.

- 3-6xx 응답은 hop-by-hop으로 전달됩니다. 3-6xx 응답을 발행할 때 요소는 일반적으로 다운스트림 요소로부터 수신된 응답을 기반으로 자체 응답을 발행하는 UAS 역할을 효과적으로 수행합니다. To 태그가 포함되지 않은 요청에 3-6xx 응답을 단순히 전달할 때 요소는 To 태그를 유지해야 합니다.\(SHOULD\)

- 프록시는 To 태그가 포함된 요청에 전달된 응답에서 To 태그를 수정해서는 안 됩니다.\(MUST NOT\)

- 프록시가 전달된 3-6xx 응답에서 To 태그를 교체한 경우 업스트림 요소에는 차이가 없지만 원래 태그를 유지하면 디버깅에 도움이 될 수 있습니다.

프록시가 여러 정보를 집계하는 경우

- 응답 중에서 To 태그를 선택하는 것은 임의적이며 새 To 태그를 생성하면 디버깅이 더 쉬워질 수 있습니다. 예를 들어 401\(무단 인증\) 및 407\(프록시 인증 필요\) 문제를 결합하거나 암호화되지 않은 및 인증되지 않은 3xx 응답의 연락처 값을 결합하는 경우 이런 일이 발생합니다.

```text
      7.  Aggregate Authorization Header Field Values
```

- 선택한 응답이 401\(권한 없음\) 또는 407\(프록시 인증 필요\)인 경우 프록시는 수신된 다른 모든 401\(권한 없음\) 및 407\(프록시 인증 필요\) 응답에서 WWW 인증 및 프록시 인증 헤더 필드 값을 수집해야 합니다. 지금까지 이 응답 컨텍스트에서 전달하기 전에 수정하지 않고 이 응답에 추가하세요. 결과 401\(권한 없음\) 또는 407\(프록시 인증 필요\) 응답에는 여러 개의 WWW-인증 및 프록시-인증 헤더 필드 값이 있을 수 있습니다.\(MUST\)

- 요청이 전달된 대상 중 일부 또는 전체가 자격 증명을 요청했을 수 있으므로 이는 필요합니다. 클라이언트는 요청을 재시도할 때 이러한 모든 챌린지를 수신하고 각 챌린지에 대한 자격 증명을 제공해야 합니다. 이 행동에 대한 동기는 섹션 26에 나와 있습니다.

```text
      8.  Record-Route
```

- 선택한 응답에 이 프록시가 원래 제공한 Record-Route 헤더 필드 값이 포함되어 있는 경우 프록시는 응답을 전달하기 전에 값을 다시 쓰도록 선택할 수 있습니다. 이를 통해 프록시는 다음 업스트림 및 다운스트림 요소에 자체적으로 다른 URI를 제공할 수 있습니다. 프록시는 어떤 이유로든 이 메커니즘을 사용하도록 선택할 수 있습니다. 예를 들어 다중 홈 호스트에 유용합니다.\(MAY\)

- 프록시가 TLS를 통해 요청을 수신하고 비 TLS 연결을 통해 전송한 경우 프록시는 Record-Route 헤더 필드의 URI를 SIPS URI로 다시 작성해야 합니다. 프록시가 TLS가 아닌 연결을 통해 요청을 수신하고 TLS를 통해 전송한 경우 프록시는 Record-Route 헤더 필드의 URI를 SIP URI로 다시 작성해야 합니다.\(MUST, MUST\)

- 프록시가 제공하는 새로운 URI는 다음 수정을 통해 요청의 Record-Route 헤더 필드\(섹션 16.6의 4단계 참조\)에 배치된 URI에 대한 동일한 제약 조건을 충족해야 합니다.\(MUST\)

- 프록시가 후속 요청 경로에 있을 다음 업스트림\(다운스트림과 반대\) 요소가 해당 전송을 지원한다는 사실을 알지 못하는 한 URI는 전송 매개변수를 포함해서는 안 됩니다.\(SHOULD NOT\)

- 프록시가 응답의 Record-Route 헤더 필드를 수정하기로 결정한 경우 수행하는 작업 중 하나는 삽입된 Record-Route 값을 찾는 것입니다. 요청이 나선형으로 바뀌고 프록시가 나선형의 각 반복에 Record-Route 값을 삽입한 경우 응답에서 올바른 값\(역방향으로 적절한 반복이어야 함\)을 찾는 것이 까다롭습니다. 위의 규칙은 Record-Route 헤더 필드 값을 다시 작성하려는 프록시가 Record-Route 헤더 필드에 충분히 구별되는 URI를 삽입하여 다시 쓰기 위해 올바른 항목을 선택할 수 있도록 권장합니다. 이를 달성하기 위한 권장 메커니즘은 프록시가 프록시 인스턴스의 고유 식별자를 URI의 사용자 부분에 추가하는 것입니다.\(SHOULD\)

- 응답이 도착하면 프록시는 식별자가 프록시 인스턴스와 일치하는 첫 번째 레코드 경로를 수정합니다. 수정하면 URI의 사용자 부분에 이 데이터 조각이 추가되지 않은 URI가 생성됩니다. 다음 반복 시 동일한 알고리즘\(매개변수로 최상위 Record-Route 헤더 필드 값 찾기\)은 해당 프록시에 의해 삽입된 다음 Record-Route 헤더 필드 값을 올바르게 추출합니다.

- 프록시가 Record-Route 헤더 필드 값을 추가하는 요청에 대한 모든 응답에 Record-Route 헤더 필드가 포함되는 것은 아닙니다. 응답에 Record-Route 헤더 필드가 포함되어 있으면 프록시가 추가한 값이 포함됩니다.

```text
      9.  Forward response
```

- "기록 경로"를 통해 "권한 부여 헤더 필드 값 집계" 단계에 설명된 처리를 수행한 후 프록시는 선택한 응답에 대해 특정 기능 조작을 수행할 수 있습니다. 프록시는 메시지 본문을 추가, 수정 또는 제거해서는 안 됩니다. 달리 지정하지 않는 한, 프록시는 섹션 16.7 항목 3에서 논의된 Via 헤더 필드 값 이외의 헤더 필드 값을 제거해서는 안 됩니다. 특히, 프록시는 "수신된" 매개변수를 제거해서는 안 됩니다.\(MAY, MUST NOT, MUST NOT, MUST NOT\)

- 이 응답과 관련된 요청을 처리하는 동안 다음 Via 헤더 필드 값에 추가되었을 수 있습니다. 프록시는 응답 컨텍스트와 관련된 서버 트랜잭션에 응답을 전달해야 합니다. 그러면 응답이 현재 최상위 Via 헤더 필드 값에 표시된 위치로 전송됩니다. 서버 트랜잭션이 더 이상 전송을 처리할 수 없는 경우 요소는 응답을 서버 전송으로 보내 상태 없이 응답을 전달해야 합니다. 서버 트랜잭션은 응답 전송 실패를 나타내거나 해당 상태 머신에서 시간 초과 신호를 보낼 수 있습니다. 이러한 오류는 적절한 진단 목적으로 기록되지만 프로토콜에는 프록시의 해결 조치가 필요하지 않습니다.\(MUST, MUST\)

- 프록시는 최종 응답을 전달한 후에도 관련 트랜잭션이 모두 종료될 때까지 응답 컨텍스트를 유지해야 합니다.\(MUST\)

```text
      10. Generate CANCELs
```

- 전달된 응답이 최종 응답인 경우 프록시는 이 응답 컨텍스트와 관련된 보류 중인 모든 클라이언트 트랜잭션에 대해 CANCEL 요청을 생성해야 합니다. 또한 프록시는 6xx 응답을 수신할 때 이 응답 컨텍스트와 연관된 모든 보류 중인 클라이언트 트랜잭션에 대해 CANCEL 요청을 생성해야 합니다. 보류 중인 클라이언트 트랜잭션은 임시 응답을 받았지만 최종 응답이 없고\(진행 상태에 있음\) 관련된 CANCEL이 생성되지 않은 트랜잭션입니다. CANCEL 요청 생성은 섹션 9.1에 설명되어 있습니다.\(MUST, SHOULD\)

- 최종 응답을 전달할 때 보류 중인 클라이언트 트랜잭션을 취소해야 한다는 요구 사항은 엔드포인트가 INVITE에 대한 여러 200\(OK\) 응답을 수신하지 않는다는 것을 보장하지 않습니다. CANCEL 요청을 전송하고 처리하기 전에 둘 이상의 분기에서 200\(OK\) 응답이 생성될 수 있습니다. 또한 향후 확장이 취소 요청을 발행하기 위한 이 요구 사항을 무시할 수 있다고 예상하는 것이 합리적입니다.

---
## **16.8 Processing Timer C**

타이머 C가 실행되어야 하는 경우 프록시는 선택한 값으로 타이머를 재설정하거나 클라이언트 트랜잭션을 종료해야 합니다. 클라이언트 트랜잭션이 임시 응답을 수신한 경우 프록시는 해당 트랜잭션과 일치하는 CANCEL 요청을 생성해야 합니다. 클라이언트 트랜잭션이 임시 응답을 수신하지 못한 경우 프록시는 트랜잭션이 408\(요청 시간 초과\) 응답을 수신한 것처럼 동작해야 합니다.\(MUST, MUST, MUST\)

프록시가 타이머를 재설정하도록 허용하면 타이머가 실행될 때 프록시가 현재 조건\(예: 활용률\)을 기반으로 트랜잭션의 수명을 동적으로 연장할 수 있습니다.

---
## **16.9 Handling Transport Errors**

전송 계층이 요청을 전달하려고 시도할 때 프록시에 오류를 알리면\(18.4절 참조\) 프록시는 전달된 요청이 503\(서비스를 사용할 수 없음\) 응답을 수신한 것처럼 동작해야 합니다.\(MUST\)

응답을 전달할 때 프록시에 오류가 통보되면 응답을 삭제합니다. 프록시는 이 알림으로 인해 이 응답 컨텍스트와 관련된 미해결 클라이언트 트랜잭션을 취소해서는 안 됩니다.\(SHOULD NOT\)

- 프록시가 미해결 클라이언트 트랜잭션을 취소하는 경우 단일 악의적이거나 오작동하는 클라이언트로 인해 Via 헤더 필드를 통해 모든 트랜잭션이 실패할 수 있습니다.

---
## **16.10 CANCEL Processing**

상태 저장 프록시는 언제든지 자신이 생성한 다른 요청에 대해 취소를 생성할 수 있습니다\(섹션 9.1에 설명된 대로 해당 요청에 대한 임시 응답을 수신하는 경우\). 프록시는 일치하는 CANCEL 요청을 수신할 때 응답 컨텍스트와 관련된 보류 중인 클라이언트 트랜잭션을 모두 취소해야 합니다.\(MAY, MUST\)

상태 유지 프록시는 INVITE의 Expires 헤더 필드에 지정된 기간 경과에 따라 보류 중인 INVITE 클라이언트 트랜잭션에 대한 CANCEL 요청을 생성할 수 있습니다. 그러나 관련된 엔드포인트가 트랜잭션 종료 신호를 처리하므로 이는 일반적으로 불필요합니다.\(MAY\)

CANCEL 요청이 자체 서버 트랜잭션에 의해 상태 저장 프록시에서 처리되는 동안 이에 대한 새 응답 컨텍스트가 생성되지 않습니다. 대신, 프록시 계층은 이 CANCEL과 관련된 요청을 처리하는 서버 트랜잭션에 대한 기존 응답 컨텍스트를 검색합니다. 일치하는 응답 컨텍스트가 발견되면 요소는 CANCEL 요청에 대해 즉시 200\(OK\) 응답을 반환해야 합니다. 이 경우 요소는 섹션 8.2에 정의된 대로 사용자 에이전트 서버 역할을 합니다. 또한 요소는 섹션 16.7의 10단계에 설명된 대로 컨텍스트에서 보류 중인 모든 클라이언트 트랜잭션에 대해 CANCEL 요청을 생성해야 합니다.\(MUST, MUST\)

응답 컨텍스트를 찾을 수 없는 경우 요소에는 CANCEL을 적용할 요청에 대한 지식이 없습니다. CANCEL 요청을 상태 없이 전달해야 합니다\(이전에 관련 요청을 상태 없이 전달했을 수 있음\).\(MUST\)

---
## **16.11 Stateless Proxy**

상태 없이 작동할 때 프록시는 간단한 메시지 전달자입니다. 무상태로 작동할 때 수행되는 처리의 대부분은 상태로 작동할 때와 동일합니다. 차이점은 여기에 자세히 설명되어 있습니다.

상태 비저장 프록시에는 트랜잭션 또는 상태 저장 프록시 동작을 설명하는 데 사용되는 응답 컨텍스트에 대한 개념이 없습니다. 대신, 상태 비저장 프록시는 전송 계층에서 직접 요청 및 응답 메시지를 가져옵니다\(섹션 18 참조\). 결과적으로 상태 비저장 프록시는 자체적으로 메시지를 재전송하지 않습니다. 그러나 수신한 모든 재전송은 전달합니다\(원본 메시지와 재전송을 구별할 수는 없습니다\). 또한 상태 없는 요청을 처리할 때 요소는 자체 100\(시도 중\) 또는 기타 임시 응답을 생성해서는 안 됩니다.\(MUST NOT\)

무상태 프록시는 섹션 16.3에 설명된 대로 요청을 검증해야 합니다\(MUST\).\(MUST\)

상태 비저장 프록시는 다음 예외를 제외하고 섹션 16.4\~16.5에 설명된 요청 처리 단계를 따라야 합니다.\(MUST\)

- o 상태 비저장 프록시는 대상 세트에서 단 하나의 대상만 선택해야 합니다. 이 선택은 메시지의 필드와 서버의 시불변 속성에만 의존해야 합니다. 특히 재전송된 요청은 처리될 때마다 동일한 대상으로 전달되어야 합니다. 또한 CANCEL 및 라우팅되지 않은 ACK 요청은 연관된 INVITE와 동일한 선택을 생성해야 합니다.\(MUST, MUST, MUST, MUST\)

상태 비저장 프록시는 다음 예외를 제외하고 섹션 16.6에 설명된 요청 처리 단계를 따라야 합니다.\(MUST\)

- o 공간과 시간에 걸쳐 고유한 지점 ID에 대한 요구 사항은 무상태 프록시에도 적용됩니다. 그러나 무상태 프록시는 섹션 16.6 글머리 기호 8에 설명된 대로 단순히 난수 생성기를 사용하여 지점 ID의 첫 번째 구성 요소를 계산할 수 없습니다. 이는 요청 재전송이 동일한 값을 가져야 하고 무상태 프록시는 이를 알 수 없기 때문입니다. 원래 요청의 재전송. 그러므로 이를 고유하게 만드는 분기 매개변수의 구성요소는 재전송된 요청이 전달될 때마다 동일해야 합니다. 따라서 무상태 프록시의 경우 분기 매개변수는 재전송 시 변하지 않는 메시지 매개변수의 조합 함수로 계산되어야 합니다.\(MUST, MUST\)

- 상태 비저장 프록시는 트랜잭션 전반에 걸쳐 지점 ID의 고유성을 보장하기 위해 원하는 기술을 사용할 수 있습니다. 그러나 다음 절차를 권장합니다. 프록시는 수신된 요청의 맨 위 Via 헤더 필드에서 분기 ID를 검사합니다. 매직 쿠키로 시작하는 경우 나가는 요청의 분기 ID의 첫 번째 구성 요소는 수신된 분기 ID의 해시로 계산됩니다. 그렇지 않은 경우 지점 ID의 첫 번째 구성 요소는 최상위 Via의 해시, To 헤더 필드의 태그, From 헤더 필드의 태그, Call-ID 헤더 필드, CSeq 번호\(메서드 아님\)로 계산됩니다. 및 수신된 요청의 Request-URI입니다. 이러한 필드 중 하나는 항상 두 개의 서로 다른 트랜잭션에 따라 달라집니다.\(MAY, SHOULD\)

- o 섹션 16.6에 지정된 다른 모든 메시지 변환은 재전송된 요청의 동일한 변환을 초래해야 합니다. 특히, 프록시가 Record-Route 값을 삽입하거나 URI를 Route 헤더 필드에 푸시하는 경우 요청 재전송에 동일한 값을 배치해야 합니다. Via 분기 매개변수의 경우 이는 변환이 요청의 시불변 구성 또는 재전송 불변 속성을 기반으로 해야 함을 의미합니다.\(MUST, MUST, MUST\)

- o 상태 비저장 프록시는 섹션 16.6 항목 10의 상태 저장 프록시에 대해 설명된 대로 요청을 전달할 위치를 결정합니다. 요청은 클라이언트 트랜잭션을 통하지 않고 전송 계층으로 직접 전송됩니다.

- 상태 비저장 프록시는 재전송된 요청을 동일한 대상으로 전달하고 각 요청에 동일한 분기 매개변수를 추가해야 하기 때문에 해당 계산을 위해 메시지 자체의 정보와 시불변 구성 데이터만 사용할 수 있습니다. 구성 상태가 시불변이 아닌 경우\(예: 라우팅 테이블이 업데이트되는 경우\) 변경의 영향을 받을 수 있는 모든 요청은 변경 전후의 트랜잭션 제한 시간 창과 동일한 간격 동안 상태 없이 전달되지 않을 수 있습니다. 해당 간격에 영향을 받는 요청을 처리하는 방법은 구현 결정입니다. 일반적인 해결책은 상태를 유지하여 트랜잭션을 전달하는 것입니다.

상태 비저장 프록시는 CANCEL 요청에 대해 특수 처리를 수행해서는 안 됩니다. 이는 다른 요청과 마찬가지로 위의 규칙에 따라 처리됩니다. 특히, 상태 비저장 프록시는 다른 요청에 적용하는 것과 동일한 경로 헤더 필드 처리를 CANCEL 요청에 적용합니다.\(MUST NOT\)

섹션 16.7에 설명된 응답 처리는 무상태로 동작하는 프록시에는 적용되지 않습니다. 응답이 상태 비저장 프록시에 도착하면 프록시는 첫 번째\(최상위\) Via 헤더 필드 값에서 보낸 사람 값을 검사해야 합니다. 해당 주소가 프록시와 일치하는 경우\(이 프록시가 이전 요청에 삽입한 값과 동일\) 프록시는 응답에서 해당 헤더 필드 값을 제거하고 결과를 다음 Via 헤더 필드 값에 표시된 위치로 전달해야 합니다. 프록시는 메시지 본문을 추가, 수정 또는 제거해서는 안 됩니다. 달리 지정하지 않는 한 프록시는 다른 헤더 필드 값을 제거해서는 안 됩니다. 주소가 프록시와 일치하지 않으면 메시지는 자동으로 삭제되어야 합니다.\(MUST, MUST, MUST NOT, MUST NOT, MUST\)

---
## **16.12 Summary of Proxy Route Processing**

이에 반대되는 로컬 정책이 없는 경우 경로 헤더 필드가 포함된 요청에 대해 프록시가 수행하는 처리는 다음 단계로 요약될 수 있습니다.

- 1. 프록시가 요청-URI를 검사합니다. 이 프록시가 소유한 리소스를 나타내는 경우 프록시는 이를 위치 서비스 실행 결과로 대체합니다. 그렇지 않으면 프록시는 요청-URI를 변경하지 않습니다.

- 2. 프록시는 최상위 경로 헤더 필드 값에서 URI를 검사합니다. 이 프록시를 나타내는 경우 프록시는 경로 헤더 필드에서 이를 제거합니다\(이 경로 노드에 도달함\).

- 3. 프록시는 최상위 경로 헤더 필드 값의 URI 또는 ​​경로 헤더 필드가 없는 경우 Request-URI에 표시된 리소스로 요청을 전달합니다. 프록시는 해당 URI에 \[4\]의 절차를 적용하여 요청을 전달할 때 사용할 주소, 포트 및 전송을 결정합니다.

요청 경로에서 엄격한 라우팅 요소가 발견되지 않으면 요청-URI는 항상 요청 대상을 나타냅니다.

---
### **16.12.1 Examples**
---
#### **16.12.1.1 Basic SIP Trapezoid**

이 시나리오는 두 프록시가 모두 기록 라우팅되는 기본 SIP 사다리꼴인 U1 -\> P1 -\> P2 -\> U2입니다. 흐름은 다음과 같습니다.

```text
   U1 sends:

      INVITE sip:callee@domain.com SIP/2.0
      Contact: sip:caller@u1.example.com
```

P1으로. P1은 아웃바운드 프록시입니다. P1은 domain.com에 대한 책임이 없으므로 DNS에서 찾아보고 그곳으로 보냅니다. 또한 Record-Route 헤더 필드 값을 추가합니다.

```text
      INVITE sip:callee@domain.com SIP/2.0
      Contact: sip:caller@u1.example.com
      Record-Route: <sip:p1.example.com;lr>
```

P2가 이것을 얻습니다. domain.com을 담당하므로 위치 서비스를 실행하고 요청-URI를 다시 작성합니다. 또한 Record-Route 헤더 필드 값을 추가합니다. Route 헤더 필드가 없으므로 새 Request-URI를 확인하여 요청을 보낼 위치를 결정합니다.

```text
      INVITE sip:callee@u2.domain.com SIP/2.0
      Contact: sip:caller@u1.example.com
      Record-Route: <sip:p2.domain.com;lr>
      Record-Route: <sip:p1.example.com;lr>
```

u2.domain.com의 수신자는 이를 수신하고 200 OK로 응답합니다.

```text
      SIP/2.0 200 OK
      Contact: sip:callee@u2.domain.com
      Record-Route: <sip:p2.domain.com;lr>
      Record-Route: <sip:p1.example.com;lr>
```

u2의 호출 수신자는 대화 상태의 원격 대상 URI를 sip:caller@u1.example.com으로 설정하고 해당 경로를 다음과 같이 설정합니다.

```text
      (<sip:p2.domain.com;lr>,<sip:p1.example.com;lr>)
```

이는 정상적으로 P2에서 P1, U1로 전달됩니다. 이제 U1은 대화 상태의 원격 대상 URI를 sip:callee@u2.domain.com으로 설정하고 해당 경로를 다음으로 설정합니다.

```text
      (<sip:p1.example.com;lr>,<sip:p2.domain.com;lr>)
```

모든 경로 세트 요소에는 lr 매개변수가 포함되어 있으므로 U1은 다음 BYE 요청을 구성합니다.

```text
      BYE sip:callee@u2.domain.com SIP/2.0
      Route: <sip:p1.example.com;lr>,<sip:p2.domain.com;lr>
```

다른 요소\(프록시 포함\)와 마찬가지로 DNS를 사용하여 최상위 경로 헤더 필드 값의 URI를 확인하여 요청을 보낼 위치를 결정합니다. 이것은 P1으로 이동합니다. P1은 Request-URI에 표시된 리소스에 대해 책임이 없다는 것을 알고 이를 변경하지 않습니다. Route 헤더 필드의 첫 번째 값임을 확인하고 해당 값을 제거하고 요청을 P2로 전달합니다.

```text
      BYE sip:callee@u2.domain.com SIP/2.0
      Route: <sip:p2.domain.com;lr>
```

P2는 또한 Request-URI에 표시된 리소스\(u2.domain.com이 아닌 domain.com에 대한 책임\)에 대해 책임이 없다는 것을 알아차리고 이를 변경하지 않습니다. 첫 번째 Route 헤더 필드 값에서 자체적으로 확인되므로 이를 제거하고 Request-URI에 대한 DNS 조회를 기반으로 다음을 u2.domain.com으로 전달합니다.

```text
      BYE sip:callee@u2.domain.com SIP/2.0
```

---
#### **16.12.1.2 Traversing a Strict-Routing Proxy**

이 시나리오에서는 각각 Record-Route 헤더 필드 값을 추가하는 4개의 프록시에 걸쳐 대화 상자가 설정됩니다. 세 번째 프록시는 RFC 2543에 지정된 엄격한 라우팅 절차와 진행 중인 많은 작업을 구현합니다.

```text
      U1->P1->P2->P3->P4->U2
```

U2에 도착하는 INVITE에는 다음이 포함됩니다.

```text
      INVITE sip:callee@u2.domain.com SIP/2.0
      Contact: sip:caller@u1.example.com
      Record-Route: <sip:p4.domain.com;lr>
      Record-Route: <sip:p3.middle.com>
      Record-Route: <sip:p2.example.com;lr>
      Record-Route: <sip:p1.example.com;lr>
```

U2는 200 OK로 응답합니다. 이후 U2는 첫 번째 Route 헤더 필드 값을 기반으로 P4에 다음 BYE 요청을 보냅니다.

```text
      BYE sip:caller@u1.example.com SIP/2.0
      Route: <sip:p4.domain.com;lr>
      Route: <sip:p3.middle.com>
      Route: <sip:p2.example.com;lr>
      Route: <sip:p1.example.com;lr>
```

P4는 Request-URI에 표시된 리소스에 대해 책임을 지지 않으므로 그대로 둡니다. 첫 번째 Route 헤더 필드 값의 요소임을 확인하여 제거합니다. 그런 다음 sip:p3.middle.com의 첫 번째 Route 헤더 필드 값을 기반으로 요청 전송을 준비하지만 이 URI에 lr 매개변수가 포함되어 있지 않음을 확인하므로 전송하기 전에 요청 형식을 다음과 같이 다시 지정합니다.

```text
      BYE sip:p3.middle.com SIP/2.0
      Route: <sip:p2.example.com;lr>
      Route: <sip:p1.example.com;lr>
      Route: <sip:caller@u1.example.com>
```

P3은 엄격한 라우터이므로 다음을 P2에 전달합니다.

```text
      BYE sip:p2.example.com;lr SIP/2.0
      Route: <sip:p1.example.com;lr>
      Route: <sip:caller@u1.example.com>
```

P2는 request-URI가 Record-Route 헤더 필드에 배치된 값임을 확인하므로 추가 처리 전에 요청을 다음과 같이 다시 작성합니다.

```text
      BYE sip:caller@u1.example.com SIP/2.0
      Route: <sip:p1.example.com;lr>
```

P2는 u1.example.com에 대한 책임이 없으므로 Route 헤더 필드 값의 확인을 기반으로 P1에 요청을 보냅니다.

P1은 최상위 Route 헤더 필드 값에서 자신을 발견하고 이를 제거하여 다음과 같은 결과를 초래합니다.

```text
      BYE sip:caller@u1.example.com SIP/2.0
```

P1은 u1.example.com에 대한 책임이 없고 Route 헤더 필드가 없으므로 P1은 Request-URI를 기반으로 u1.example.com으로 요청을 전달합니다.

---
#### **16.12.1.3 Rewriting Record-Route Header Field Values**

이 시나리오에서 U1과 U2는 서로 다른 개인 네임스페이스에 있으며 네임스페이스 간의 게이트웨이 역할을 하는 프록시 P1을 통해 대화 상자에 들어갑니다.

```text
      U1->P1->U2

   U1 sends:

      INVITE sip:callee@gateway.leftprivatespace.com SIP/2.0
      Contact: <sip:caller@u1.leftprivatespace.com>
```

P1은 위치 서비스를 사용하여 다음을 U2로 보냅니다.

```text
      INVITE sip:callee@rightprivatespace.com SIP/2.0
      Contact: <sip:caller@u1.leftprivatespace.com>
      Record-Route: <sip:gateway.rightprivatespace.com;lr>
```

U2는 이 200\(OK\)을 P1로 다시 보냅니다.

```text
      SIP/2.0 200 OK
      Contact: <sip:callee@u2.rightprivatespace.com>
      Record-Route: <sip:gateway.rightprivatespace.com;lr>
```

P1은 Record-Route 헤더 매개변수를 다시 작성하여 U1이 유용하다고 생각하는 값을 제공하고 다음을 U1에 보냅니다.

```text
      SIP/2.0 200 OK
      Contact: <sip:callee@u2.rightprivatespace.com>
      Record-Route: <sip:gateway.leftprivatespace.com;lr>
```

나중에 U1은 P1에 다음 BYE 요청을 보냅니다.

```text
      BYE sip:callee@u2.rightprivatespace.com SIP/2.0
      Route: <sip:gateway.leftprivatespace.com;lr>
```

P1은 다음과 같이 U2에 전달합니다.

```text
      BYE sip:callee@u2.rightprivatespace.com SIP/2.0
```

---
# **17 Transactions**

SIP는 트랜잭션 프로토콜입니다. 구성 요소 간의 상호 작용은 일련의 독립적인 메시지 교환에서 발생합니다. 특히 SIP 트랜잭션은 단일 요청과 해당 요청에 대한 응답으로 구성됩니다. 여기에는 0개 이상의 임시 응답과 하나 이상의 최종 응답이 포함됩니다. 요청이 INVITE\(INVITE 트랜잭션이라고도 함\)인 트랜잭션의 경우 최종 응답이 2xx 응답이 아닌 경우에만 트랜잭션에 ACK도 포함됩니다. 응답이 2xx인 경우 ACK는 트랜잭션의 일부로 간주되지 않습니다.

- 이러한 분리의 이유는 INVITE에 대한 모든 200\(OK\) 응답을 UAC에 전달하는 것이 중요하기 때문입니다. 모든 것을 UAC에 전달하려면 UAS만이 책임을 집니다.

- 이를 재전송하기 위해\(섹션 13.3.1.4 참조\) UAC만이 ACK로 이를 승인하는 책임을 집니다\(섹션 13.2.2.4 참조\). 이 ACK는 UAC에 의해서만 재전송되므로 사실상 자체 트랜잭션으로 간주됩니다.

트랜잭션에는 클라이언트 측과 서버 측이 있습니다. 클라이언트 측은 클라이언트 트랜잭션으로, 서버 측은 서버 트랜잭션으로 알려져 있습니다. 클라이언트 트랜잭션은 요청을 보내고, 서버 트랜잭션은 응답을 보냅니다. 클라이언트 및 서버 트랜잭션은 여러 요소에 내장된 논리적 기능입니다. 특히 사용자 에이전트와 상태 저장 프록시 서버 내에 존재합니다. 섹션 4의 예를 고려하십시오. 이 예에서 UAC는 클라이언트 트랜잭션을 실행하고 해당 아웃바운드 프록시는 서버 트랜잭션을 실행합니다. 아웃바운드 프록시는 또한 인바운드 프록시의 서버 트랜잭션에 요청을 보내는 클라이언트 트랜잭션을 실행합니다. 또한 해당 프록시는 클라이언트 트랜잭션을 실행하며, 클라이언트 트랜잭션은 UAS의 서버 트랜잭션에 요청을 보냅니다. 이는 그림 4에 나와 있습니다.

```text
   +---------+        +---------+        +---------+        +---------+
   |      +-+|Request |+-+   +-+|Request |+-+   +-+|Request |+-+      |
   |      |C||------->||S|   |C||------->||S|   |C||------->||S|      |
   |      |l||        ||e|   |l||        ||e|   |l||        ||e|      |
   |      |i||        ||r|   |i||        ||r|   |i||        ||r|      |
   |      |e||        ||v|   |e||        ||v|   |e||        ||v|      |
   |      |n||        ||e|   |n||        ||e|   |n||        ||e|      |
   |      |t||        ||r|   |t||        ||r|   |t||        ||r|      |
   |      | ||        || |   | ||        || |   | ||        || |      |
   |      |T||        ||T|   |T||        ||T|   |T||        ||T|      |
   |      |r||        ||r|   |r||        ||r|   |r||        ||r|      |
   |      |a||        ||a|   |a||        ||a|   |a||        ||a|      |
   |      |n||        ||n|   |n||        ||n|   |n||        ||n|      |
   |      |s||Response||s|   |s||Response||s|   |s||Response||s|      |
   |      +-+|<-------|+-+   +-+|<-------|+-+   +-+|<-------|+-+      |
   +---------+        +---------+        +---------+        +---------+
      UAC               Outbound           Inbound              UAS
                        Proxy               Proxy

                  Figure 4: Transaction relationships
```

상태 비저장 프록시에는 클라이언트 또는 서버 트랜잭션이 포함되어 있지 않습니다. 트랜잭션은 한쪽의 UA 또는 상태 저장 프록시와 다른 쪽의 UA 또는 상태 저장 프록시 사이에 존재합니다. SIP 트랜잭션과 관련하여 무상태 프록시는 사실상 투명합니다. 클라이언트 트랜잭션의 목적은 클라이언트가 포함된 요소\(이 요소를 "트랜잭션 사용자" 또는 TU라고 부르며 UA 또는 상태 저장 프록시일 수 있음\)로부터 요청을 수신하고 요청을 안정적으로 전달하는 것입니다. 서버 거래.

클라이언트 트랜잭션은 또한 응답을 수신하여 이를 TU에 전달하고 응답 재전송 또는 허용되지 않는 응답\(예: ACK에 대한 응답\)을 필터링하는 일을 담당합니다. 또한 INVITE 요청의 경우 클라이언트 트랜잭션은 2xx 응답을 수락하는 최종 응답에 대한 ACK 요청을 생성하는 역할을 담당합니다.

마찬가지로, 서버 트랜잭션의 목적은 전송 계층으로부터 요청을 수신하여 이를 TU에 전달하는 것입니다. 서버 트랜잭션은 네트워크로부터의 모든 요청 재전송을 필터링합니다. 서버 트랜잭션은 TU의 응답을 수락하고 네트워크를 통한 전송을 위해 이를 전송 계층으로 전달합니다. INVITE 트랜잭션의 경우 2xx 응답을 제외한 모든 최종 응답에 대한 ACK 요청을 흡수합니다.

2xx 응답과 해당 ACK는 특별한 처리를 받습니다. 이 응답은 UAS에 의해서만 재전송되며 해당 ACK는 UAC에 의해서만 생성됩니다. 발신자가 통화를 수락한 전체 사용자 집합을 알 수 있도록 하려면 이러한 엔드투엔드 처리가 필요합니다. 이러한 특수 처리로 인해 2xx 응답의 재전송은 트랜잭션 계층이 아닌 UA 코어에 의해 처리됩니다. 마찬가지로 2xx에 대한 ACK 생성은 UA 코어에 의해 처리됩니다. 경로에 있는 각 프록시는 각 2xx 응답을 INVITE 및 해당 ACK로 전달합니다.

---
## **17.1 Client Transaction**

클라이언트 트랜잭션은 상태 머신의 유지 관리를 통해 기능을 제공합니다.

TU는 간단한 인터페이스를 통해 클라이언트 트랜잭션과 통신합니다. TU가 새로운 트랜잭션을 시작하려고 할 때 클라이언트 트랜잭션을 생성하고 이를 보낼 SIP 요청과 이를 보낼 IP 주소, 포트 및 전송을 전달합니다. 클라이언트 트랜잭션이 상태 머신의 실행을 시작합니다. 클라이언트 트랜잭션에서 유효한 응답이 TU로 전달됩니다.

TU가 전달한 요청 방법에 따라 두 가지 유형의 클라이언트 트랜잭션 상태 머신이 있습니다. 하나는 INVITE 요청에 대한 클라이언트 트랜잭션을 처리합니다. 이러한 유형의 머신을 INVITE 클라이언트 트랜잭션이라고 합니다. 또 다른 유형은 INVITE 및 ACK를 제외한 모든 요청에 ​​대한 클라이언트 트랜잭션을 처리합니다. 이를 비INVITE 클라이언트 트랜잭션이라고 합니다. ACK에 대한 클라이언트 트랜잭션이 없습니다. TU가 ACK를 전송하려는 경우 전송을 위해 ACK를 전송 계층으로 직접 전달합니다.

INVITE 트랜잭션은 지속 시간이 길다는 점에서 다른 방법과 다릅니다. 일반적으로 INVITE에 응답하려면 사람의 입력이 필요합니다. 응답 전송에 예상되는 긴 지연으로 인해 3방향 핸드셰이크가 필요합니다. 반면, 다른 방식의 요청은 빠르게 완료될 것으로 예상됩니다. 비INVITE 트랜잭션은 양방향 핸드셰이크에 의존하기 때문에 TU는 비INVITE 요청에 즉시 응답해야 합니다.\(SHOULD\)

---
### **17.1.1 INVITE Client Transaction**
---
#### **17.1.1.1 Overview of INVITE Transaction**

INVITE 트랜잭션은 3방향 핸드셰이크로 구성됩니다. 클라이언트 트랜잭션은 INVITE를 보내고, 서버 트랜잭션은 응답을 보내고, 클라이언트 트랜잭션은 ACK를 보냅니다. 신뢰할 수 없는 전송\(예: UDP\)의 경우 클라이언트 트랜잭션은 T1초에 시작하여 재전송할 때마다 두 배로 증가하는 간격으로 요청을 재전송합니다. T1은 왕복 시간\(RTT\)의 추정치이며 기본값은 500ms입니다. 여기에 설명된 거의 모든 트랜잭션 타이머는 T1에 따라 확장되며 T1을 변경하면 해당 값이 조정됩니다. 요청은 안정적인 전송을 통해 재전송되지 않습니다. 1xx 응답을 받은 후 모든 재전송이 완전히 중단되고 클라이언트는 추가 응답을 기다립니다. 서버 트랜잭션은 서버 트랜잭션에 의해 안정적으로 전송되지 않는 추가 1xx 응답을 보낼 수 있습니다. 결국 서버 트랜잭션은 최종 응답을 보내기로 결정합니다. 신뢰할 수 없는 전송의 경우 해당 응답은 주기적으로 재전송되고, 신뢰할 수 있는 전송의 경우 해당 응답은 한 번 전송됩니다. 클라이언트 트랜잭션에서 수신된 각 최종 응답에 대해 클라이언트 트랜잭션은 ACK를 보냅니다. 그 목적은 응답 재전송을 중단하는 것입니다.

---
#### **17.1.1.2 Formal Description**

INVITE 클라이언트 트랜잭션에 대한 상태 머신은 그림 5에 나와 있습니다. TU가 INVITE 요청으로 새 클라이언트 트랜잭션을 시작할 때 초기 상태인 "호출"을 입력해야 합니다. 클라이언트 트랜잭션은 전송을 위해 요청을 전송 계층으로 전달해야 합니다\(섹션 18 참조\). 신뢰할 수 없는 전송이 사용되는 경우 클라이언트 트랜잭션은 T1 값으로 타이머 A를 시작해야 합니다. 신뢰할 수 있는 전송이 사용되는 경우 클라이언트 트랜잭션은 타이머 A를 시작해서는 안 됩니다\(타이머 A는 요청 재전송을 제어합니다\). 모든 전송에 대해 클라이언트 트랜잭션은 64\*T1초 값으로 타이머 B를 시작해야 합니다\(타이머 B는 트랜잭션 시간 초과를 제어합니다\).\(MUST, MUST, MUST, SHOULD NOT, MUST\)

타이머 A가 실행되면 클라이언트 트랜잭션은 요청을 전송 계층으로 전달하여 요청을 재전송해야 하며 타이머를 2\*T1 값으로 재설정해야 합니다. 재전송의 공식적인 정의\(MUST\)

트랜잭션 계층의 컨텍스트 내에서는 이전에 전송 계층으로 전송된 메시지를 가져와 다시 전송 계층으로 전달하는 것입니다.

타이머 A가 2\*T1초 후에 실행되면 요청이 다시 재전송되어야 합니다\(클라이언트 트랜잭션이 여전히 이 상태에 있다고 가정\). 이 프로세스는 각 전송 후 두 배의 간격으로 요청이 재전송되도록 계속되어야 합니다. 이러한 재전송은 클라이언트 트랜잭션이 "호출" 상태에 있는 동안에만 수행되어야 합니다.\(MUST, MUST, SHOULD\)

T1의 기본값은 500ms입니다. T1은 클라이언트와 서버 트랜잭션 간의 RTT 추정치입니다. 요소는 일반 인터넷 연결을 허용하지 않는 폐쇄된 개인 네트워크 내에서 더 작은 T1 값을 사용할 수 있습니다\(권장되지는 않음\). T1은 더 크게 선택될 수 있으며, RTT가 더 크다는 것이 미리 알려진 경우\(예: 대기 시간이 높은 액세스 링크에서\) 권장됩니다. T1의 값이 무엇이든 이 섹션에 설명된 재전송에 대한 지수 백오프를 사용해야 합니다.\(SHOULD NOT, SHOULD, MUST\)

타이머 B가 실행될 때 클라이언트 트랜잭션이 여전히 "Calling" 상태에 있는 경우 클라이언트 트랜잭션은 타임아웃이 발생했음을 TU에 알려야 합니다. 클라이언트 트랜잭션은 ACK를 생성해서는 안 됩니다. 64\*T1 값은 신뢰할 수 없는 전송의 경우 7개의 요청을 보내는 데 필요한 시간과 같습니다.\(SHOULD, MUST NOT\)

클라이언트 트랜잭션이 "Calling" 상태에 있는 동안 임시 응답을 받으면 "Proceeding" 상태로 전환됩니다. "진행 중" 상태에서 클라이언트 트랜잭션은 더 이상 요청을 재전송해서는 안 됩니다. 또한, 임시 응답은 TU에 전달되어야 합니다. 추가 임시 응답은 "진행 중" 상태에 있는 동안 TU에 전달되어야 합니다.\(SHOULD NOT, MUST, MUST\)

"Calling" 또는 "Proceeding" 상태에 있을 때 300-699의 상태 코드가 포함된 응답을 수신하면 클라이언트 트랜잭션이 "Completed"로 전환되어야 합니다. 클라이언트 트랜잭션은 수신된 응답을 TU까지 전달해야 하며, 클라이언트 트랜잭션은 전송이 신뢰할 수 있는 경우에도 ACK 요청을 생성해야 합니다\(응답에서 ACK를 구성하기 위한 지침은 섹션 17.1.1.3에 제공됨\). 전송을 위해 전송 계층에 ACK를 보냅니다. ACK는 원래 요청이 전송된 것과 동일한 주소, 포트 및 전송으로 전송되어야 합니다. 클라이언트 트랜잭션은 신뢰할 수 없는 전송의 경우 최소 32초 값, 신뢰할 수 있는 전송의 경우 0초 값을 사용하여 "완료" 상태에 들어갈 때 타이머 D를 시작해야 합니다. 타이머 D는 신뢰할 수 없는 전송이 사용될 때 서버 트랜잭션이 "완료" 상태로 유지될 수 있는 시간을 반영합니다. 이는 INVITE 서버 트랜잭션의 타이머 H와 동일합니다.\(MUST, MUST, MUST, SHOULD\)

기본값은 64\*T1입니다. 그러나 클라이언트 트랜잭션은 서버 트랜잭션에서 사용 중인 T1 값을 모르므로 T1에 타이머 D를 적용하는 대신 절대 최소값 32초가 사용됩니다.

"완료" 상태에 있는 동안 수신된 최종 응답의 재전송으로 인해 ACK가 재전송을 위해 전송 계층으로 재전송되어야 하지만 새로 수신된 응답이 TU까지 전달되어서는 안 됩니다. 응답의 재전송은 섹션 17.1.3의 규칙에 따라 동일한 클라이언트 트랜잭션과 일치하는 모든 응답으로 정의됩니다.\(MUST NOT\)

```text
                               |INVITE from TU
             Timer A fires     |INVITE sent
             Reset A,          V                      Timer B fires
             INVITE sent +-----------+                or Transport Err.
               +---------|           |---------------+inform TU
               |         |  Calling  |               |
               +-------->|           |-------------->|
                         +-----------+ 2xx           |
                            |  |       2xx to TU     |
                            |  |1xx                  |
    300-699 +---------------+  |1xx to TU            |
   ACK sent |                  |                     |
resp. to TU |  1xx             V                     |
            |  1xx to TU  -----------+               |
            |  +---------|           |               |
            |  |         |Proceeding |-------------->|
            |  +-------->|           | 2xx           |
            |            +-----------+ 2xx to TU     |
            |       300-699    |                     |
            |       ACK sent,  |                     |
            |       resp. to TU|                     |
            |                  |                     |      NOTE:
            |  300-699         V                     |
            |  ACK sent  +-----------+Transport Err. |  transitions
            |  +---------|           |Inform TU      |  labeled with
            |  |         | Completed |-------------->|  the event
            |  +-------->|           |               |  over the action
            |            +-----------+               |  to take
            |              ^   |                     |
            |              |   | Timer D fires       |
            +--------------+   | -                   |
                               |                     |
                               V                     |
                         +-----------+               |
                         |           |               |
                         | Terminated|<--------------+
                         |           |
                         +-----------+

                 Figure 5: INVITE client transaction
```

클라이언트 트랜잭션이 "완료" 상태에 있는 동안 타이머 D가 실행되면 클라이언트 트랜잭션은 종료된 상태로 이동해야 합니다.\(MUST\)

"Calling" 또는 "Proceeding" 상태에 있는 경우 2xx 응답을 수신하면 클라이언트 트랜잭션이 "Terminating" 상태로 들어가야 하며 응답은 TU로 전달되어야 합니다. 이 응답의 처리는 TU가 프록시인지 여부에 따라 다릅니다.\(MUST\)

코어 또는 UAC 코어. UAC 코어는 이 응답에 대한 ACK 생성을 처리하는 반면, 프록시 코어는 항상 200\(OK\) 업스트림을 전달합니다. 프록시와 UAC 간의 200\(OK\) 처리가 다르기 때문에 트랜잭션 계층에서 처리가 이루어지지 않습니다.

클라이언트 트랜잭션은 "종료됨" 상태에 들어가는 즉시 파기되어야 합니다. 이는 실제로 올바른 작동을 보장하는 데 필요합니다. 그 이유는 INVITE에 대한 2xx 응답이 다르게 처리되기 때문입니다. 각각은 프록시에 의해 전달되며 UAC의 ACK 처리는 다릅니다. 따라서 각 2xx는 프록시 코어\(전달될 수 있도록\) 및 UAC 코어\(승인될 수 있도록\)로 전달되어야 합니다. 트랜잭션 계층 처리가 발생하지 않습니다. 전송에서 응답을 수신할 때마다 전송 계층에서 일치하는 클라이언트 트랜잭션을 찾지 못한 경우\(섹션 17.1.3의 규칙 사용\) 응답이 코어로 직접 전달됩니다. 일치하는 클라이언트 트랜잭션은 첫 번째 2xx에 의해 삭제되므로 후속 2xx에서는 일치하는 항목을 찾지 못하여 코어로 전달됩니다.\(MUST\)

---
#### **17.1.1.3 Construction of the ACK Request**

이 섹션에서는 클라이언트 트랜잭션 내에서 전송된 ACK 요청의 구성을 지정합니다. 2xx에 대한 ACK를 생성하는 UAC 코어는 대신 섹션 13에 설명된 규칙을 따라야 합니다.\(MUST\)

클라이언트 트랜잭션에 의해 생성된 ACK 요청에는 클라이언트 트랜잭션에 의해 전송에 전달된 요청의 헤더 필드 값과 동일한 Call-ID, From 및 Request-URI 값이 포함되어야 합니다\(이를 "원본"이라고 함\). 요구"\). ACK의 To 헤더 필드는 승인되는 응답의 To 헤더 필드와 동일해야 하며, 따라서 일반적으로 태그 매개변수를 추가하여 원래 요청의 To 헤더 필드와 다릅니다. ACK에는 단일 Via 헤더 필드가 포함되어야 하며 이는 원래 요청의 최상위 Via 헤더 필드와 동일해야 합니다. ACK의 CSeq 헤더 필드는 원래 요청에 있었던 것과 동일한 시퀀스 번호 값을 포함해야 하지만 메서드 매개변수는 "ACK"와 동일해야 합니다.\(MUST, MUST, MUST, MUST\)

응답이 확인되는 INVITE 요청에 경로 헤더 필드가 있는 경우 해당 헤더 필드는 ACK에 나타나야 합니다. 이는 다운스트림 무상태 프록시를 통해 ACK가 적절하게 라우팅될 수 있도록 하기 위한 것입니다.\(MUST\)

모든 요청에는 본문이 포함될 수 있지만 ACK의 본문은 본문을 이해하지 못하면 요청을 거부할 수 없기 때문에 특별합니다. 따라서 2xx가 아닌 경우 ACK에 본문을 배치하는 것은 권장되지 않지만, 수행된 경우 INVITE에 대한 응답이 415가 아니라는 가정 하에 본문 유형이 INVITE에 나타난 것으로 제한됩니다. ACK는 415의 Accept 헤더 필드에 나열된 모든 유형일 수 있습니다.\(MAY, SHOULD NOT, MAY\)

예를 들어 다음 요청을 고려해보세요.

```text
   INVITE sip:bob@biloxi.com SIP/2.0
   Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKkjshdyff
   To: Bob <sip:bob@biloxi.com>
   From: Alice <sip:alice@atlanta.com>;tag=88sja8x
   Max-Forwards: 70
   Call-ID: 987asjd97y7atg
   CSeq: 986759 INVITE
```

이 요청에 대한 2xx가 아닌 최종 응답에 대한 ACK 요청은 다음과 같습니다.

```text
   ACK sip:bob@biloxi.com SIP/2.0
   Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKkjshdyff
   To: Bob <sip:bob@biloxi.com>;tag=99sa0xk
   From: Alice <sip:alice@atlanta.com>;tag=88sja8x
   Max-Forwards: 70
   Call-ID: 987asjd97y7atg
   CSeq: 986759 ACK
```

---
### **17.1.2 Non-INVITE Client Transaction**
---
#### **17.1.2.1 Overview of the non-INVITE Transaction**

INVITE가 아닌 트랜잭션은 ACK를 사용하지 않습니다. 이는 단순한 요청-응답 상호작용입니다. 신뢰할 수 없는 전송의 경우 요청은 T1에서 시작하여 T2에 도달할 때까지 두 배가 되는 간격으로 재전송됩니다. 임시 응답을 수신하면 신뢰할 수 없는 전송에 대해 T2 간격으로 재전송이 계속됩니다. 서버 트랜잭션은 요청의 재전송이 수신된 경우에만 임시 또는 최종 응답일 수 있는 마지막 응답을 재전송합니다. 이것이 임시 응답 후에도 요청 재전송이 계속되어야 하는 이유입니다. 이는 최종 응답의 안정적인 전달을 보장하기 위한 것입니다.

INVITE 트랜잭션과 달리 비INVITE 트랜잭션에는 2xx 응답에 대한 특별한 처리가 없습니다. 결과적으로 비INVITE에 대한 단일 2xx 응답만 UAC에 전달됩니다.

---
#### **17.1.2.2 Formal Description**

비INVITE 클라이언트 트랜잭션의 상태 머신은 그림 6에 나와 있습니다. 이는 INVITE의 상태 머신과 매우 유사합니다.

TU가 요청으로 새로운 클라이언트 트랜잭션을 시작할 때 "시도 중" 상태로 들어갑니다. 이 상태에 들어갈 때 클라이언트 트랜잭션은 타이머 F가 64\*T1초 내에 실행되도록 설정해야 합니다. 요청은 전송을 위해 전송 계층으로 전달되어야 합니다. 신뢰할 수 없는 전송이 사용 중인 경우 클라이언트 트랜잭션은 T1초 내에 타이머 E가 실행되도록 설정해야 합니다. 이 상태에 있는 동안 타이머 E가 실행되면 타이머가 재설정되지만 이번에는 값이 MIN\(2\*T1, T2\)입니다. 타이머가 다시 실행되면 MIN\(4\*T1, T2\)으로 재설정됩니다. 이 프로세스는 T2에 도달하는 기하급수적으로 증가하는 간격으로 재전송이 발생하도록 계속됩니다. T2의 기본값은 4초이며, 이는 INVITE가 아닌 서버 트랜잭션이 즉시 응답하지 않는 경우 요청에 응답하는 데 걸리는 시간을 나타냅니다. T1 및 T2의 기본값의 경우 간격은 500ms, 1초, 2초, 4초, 4초, 4초 등이 됩니다.\(SHOULD, MUST, MUST\)

클라이언트 트랜잭션이 여전히 "시도 중" 상태에 있는 동안 타이머 F가 실행되면 클라이언트 트랜잭션은 TU에 타임아웃에 대해 알려야 하며 그런 다음 "종료됨" 상태로 들어가야 합니다. "Trying" 상태에 있는 동안 임시 응답이 수신되면 응답은 TU로 전달되어야 하며 클라이언트 트랜잭션은 "Proceeding" 상태로 이동해야 합니다. "Trying" 상태에 있는 동안 최종 응답\(상태 코드 200-699\)이 수신되면 응답은 TU로 전달되어야 하며 클라이언트 트랜잭션은 "Completed" 상태로 전환되어야 합니다.\(SHOULD, MUST, MUST\)

타이머 E가 "진행 중" 상태에 있는 동안 실행되면 요청은 재전송을 위해 전송 계층으로 전달되어야 하며 타이머 E는 T2초 값으로 재설정되어야 합니다. "진행 중" 상태에 있는 동안 타이머 F가 실행되면 TU에 시간 초과를 알려야 하며 클라이언트 트랜잭션은 종료 상태로 전환해야 합니다. "Proceeding" 상태에 있는 동안 최종 응답\(상태 코드 200-699\)이 수신되면 응답은 TU로 전달되어야 하며 클라이언트 트랜잭션은 "Completed" 상태로 전환되어야 합니다.\(MUST, MUST, MUST\)

클라이언트 트랜잭션이 "완료" 상태에 들어가면 신뢰할 수 없는 전송의 경우 T4초 내에 실행되고 신뢰할 수 있는 전송의 경우 0초 내에 실행되도록 타이머 K를 설정해야 합니다. "완료" 상태는 수신될 수 있는 추가 응답 재전송을 버퍼링하기 위해 존재합니다\(이것이 클라이언트 트랜잭션이 해당 상태로 유지되는 이유입니다\).\(MUST\)

신뢰할 수 없는 전송\). T4는 네트워크가 클라이언트와 서버 트랜잭션 간의 메시지를 지우는 데 걸리는 시간을 나타냅니다. T4의 기본값은 5초입니다. 응답은 섹션 17.1.3에 지정된 규칙을 사용하여 동일한 트랜잭션과 일치할 때 재전송됩니다. 이 상태에 있는 동안 타이머 K가 실행되면 클라이언트 트랜잭션은 "종료됨" 상태로 전환되어야 합니다.\(MUST\)

트랜잭션이 종료된 상태가 되면 즉시 파기되어야 합니다.\(MUST\)

---
### **17.1.3 Matching Responses to Client Transactions**

클라이언트의 전송 계층이 응답을 받으면 섹션 17.1.1 및 17.1.2의 처리가 수행될 수 있도록 응답을 처리할 클라이언트 트랜잭션을 결정해야 합니다. 이 목적으로 상단 Via 헤더 필드의 분기 매개변수가 사용됩니다. 응답은 다음 두 가지 조건에서 클라이언트 트랜잭션과 일치합니다.

- 1. 응답의 상단 Via 헤더 필드에 있는 분기 매개변수 값이 트랜잭션을 생성한 요청의 상단 Via 헤더 필드에 있는 분기 매개변수 값과 동일한 경우.

- 2. CSeq 헤더 필드의 메소드 매개변수가 트랜잭션을 생성한 요청의 메소드와 일치하는 경우. CANCEL 요청은 다른 트랜잭션을 구성하지만 동일한 분기 매개변수 값을 공유하므로 이 메서드가 필요합니다.

멀티캐스트를 통해 요청이 전송되면 서로 다른 서버에서 여러 응답이 생성될 수 있습니다. 이러한 응답은 모두 최상위 Via에 동일한 분기 매개변수를 갖지만 To 태그는 다릅니다. 위의 규칙에 따라 수신된 첫 번째 응답이 사용되고 다른 응답은 재전송으로 간주됩니다. 그것은 오류가 아닙니다. 멀티캐스트 SIP는 단일 응답 처리로 제한되는 기본적인 "단일 홉 검색과 유사한" 서비스만 제공합니다. 자세한 내용은 섹션 18.1.1을 참조하세요.

---
### **17.1.4 Handling Transport Errors**

```text
                                   |Request from TU
                                   |send request
               Timer E             V
               send request  +-----------+
                   +---------|           |-------------------+
                   |         |  Trying   |  Timer F          |
                   +-------->|           |  or Transport Err.|
                             +-----------+  inform TU        |
                200-699         |  |                         |
                resp. to TU     |  |1xx                      |
                +---------------+  |resp. to TU              |
                |                  |                         |
                |   Timer E        V       Timer F           |
                |   send req +-----------+ or Transport Err. |
                |  +---------|           | inform TU         |
                |  |         |Proceeding |------------------>|
                |  +-------->|           |-----+             |
                |            +-----------+     |1xx          |
                |              |      ^        |resp to TU   |
                | 200-699      |      +--------+             |
                | resp. to TU  |                             |
                |              |                             |
                |              V                             |
                |            +-----------+                   |
                |            |           |                   |
                |            | Completed |                   |
                |            |           |                   |
                |            +-----------+                   |
                |              ^   |                         |
                |              |   | Timer K                 |
                +--------------+   | -                       |
                                   |                         |
                                   V                         |
             NOTE:           +-----------+                   |
                             |           |                   |
         transitions         | Terminated|<------------------+
         labeled with        |           |
         the event           +-----------+
         over the action
         to take

                 Figure 6: non-INVITE client transaction
```

클라이언트 트랜잭션이 전송 계층에 요청을 보낼 때 전송 계층에서 실패를 나타내는 경우 다음 절차를 따릅니다.

클라이언트 트랜잭션은 전송 실패가 발생했음을 TU에 알려야 하며 클라이언트 트랜잭션은 "종료됨" 상태로 직접 전환해야 합니다. TU는 \[4\]에 설명된 장애 조치 메커니즘을 처리합니다.\(SHOULD\)

---
## **17.2 Server Transaction**

서버 트랜잭션은 TU에 대한 요청 전달과 안정적인 응답 전송을 담당합니다. 이는 상태 머신을 통해 수행됩니다. 서버 트랜잭션은 요청이 수신될 때 코어에 의해 생성되며 해당 요청에 대한 트랜잭션 처리가 필요합니다\(항상 그런 것은 아닙니다\).

클라이언트 트랜잭션과 마찬가지로 상태 머신은 수신된 요청이 INVITE 요청인지 여부에 따라 달라집니다.

---
### **17.2.1 INVITE Server Transaction**

INVITE 서버 트랜잭션의 상태 다이어그램은 그림 7에 나와 있습니다.

요청에 대해 서버 트랜잭션이 구성되면 "진행 중" 상태로 들어갑니다. 서버 트랜잭션은 TU가 200ms 이내에 임시 또는 최종 응답을 생성할 것이라는 것을 알지 않는 한 100\(시도 중\) 응답을 생성해야 하며, 이 경우 100\(시도 중\) 응답을 생성할 수 있습니다. 이 임시 응답은 네트워크 정체를 피하기 위해 요청 재전송을 신속하게 중단하는 데 필요합니다. 100\(시도\) 응답은 응답의 To 헤더 필드에 태그 삽입\(요청에 아무 것도 없을 때\)이 MAY에서 SHOULD NOT으로 다운그레이드된다는 점을 제외하고 섹션 8.2.6의 절차에 따라 구성됩니다. 요청은 TU로 전달되어야 합니다.\(MUST, SHOULD NOT, MUST\)

TU는 서버 트랜잭션에 임의 개수의 임시 응답을 전달합니다. 서버 트랜잭션이 "진행 중" 상태인 한, 이들 각각은 전송을 위해 전송 계층으로 전달되어야 합니다. 트랜잭션 계층에서 안정적으로 전송되지 않으며\(재전송되지 않음\) 서버 트랜잭션 상태를 변경하지 않습니다. "Proceeding\(진행 중\)" 상태에 있는 동안 요청 재전송이 수신되면 TU로부터 수신된 가장 최근의 임시 응답이 재전송을 위해 전송 계층으로 전달되어야 합니다. 섹션 17.2.3의 규칙에 따라 동일한 서버 트랜잭션과 일치하는 경우 요청은 재전송입니다.\(MUST, MUST\)

"진행 중" 상태에 있는 동안 TU가 서버 트랜잭션에 2xx 응답을 전달하는 경우 서버 트랜잭션은 전송을 위해 이 응답을 전송 계층에 전달해야 합니다. 그렇지 않다\(MUST\)

서버 트랜잭션에 의해 재전송됩니다. 2xx 응답의 재전송은 TU에 의해 처리됩니다. 그런 다음 서버 트랜잭션은 "종료됨" 상태로 전환되어야 합니다.\(MUST\)

"Proceeding" 상태에 있는 동안 TU가 300\~699의 상태 코드가 포함된 응답을 서버 트랜잭션에 전달하는 경우 응답은 전송을 위해 전송 계층으로 전달되어야 하며 상태 머신은 "Completed" 상태로 들어가야 합니다. 신뢰할 수 없는 전송의 경우 타이머 G는 T1초에 실행되도록 설정되고 신뢰할 수 있는 전송에 대해서는 실행되도록 설정되지 않습니다.\(MUST\)

- 이는 안정적인 전송을 통해서도 응답이 항상 재전송되는 RFC 2543에서 변경된 사항입니다.

"완료" 상태에 들어가면 타이머 H는 모든 전송에 대해 64\*T1초 내에 실행되도록 설정되어야 합니다. 타이머 H는 서버 트랜잭션이 응답 재전송을 포기하는 시기를 결정합니다. 해당 값은 클라이언트 트랜잭션이 요청 전송을 계속 재시도하는 시간인 타이머 B와 동일하도록 선택됩니다. 타이머 G가 실행되면 응답은 재전송을 위해 다시 한 번 전송 계층으로 전달되고 타이머 G는 MIN\(2\*T1, T2\)초 내에 실행되도록 설정됩니다. 그 이후부터 타이머 G가 실행되면 응답은 전송을 위해 다시 전송으로 전달되고 타이머 G는 두 배의 값으로 재설정됩니다. 단, 해당 값이 T2를 초과하지 않는 한 T2 값으로 재설정됩니다. 이는 비INVITE 클라이언트 트랜잭션의 "시도 중" 상태에 있는 요청에 대한 재전송 동작과 동일합니다. 또한 "완료" 상태에 있는 동안 요청 재전송이 수신되면 서버는 재전송을 위한 전송에 응답을 전달해야 합니다.\(MUST, SHOULD\)

서버 트랜잭션이 "Completed" 상태에 있는 동안 ACK가 수신되면 서버 트랜잭션은 "Confirmed" 상태로 전환되어야 합니다. 이 상태에서는 타이머 G가 무시되므로 응답 재전송이 중단됩니다.\(MUST\)

"완료" 상태에 있는 동안 타이머 H가 실행되면 이는 ACK가 수신되지 않았음을 의미합니다. 이 경우, 서버 트랜잭션은 "Terminating" 상태로 전환되어야 하며\(MUST\) 트랜잭션 실패가 발생했음을 TU에 표시해야 합니다.\(MUST\)

```text
                               |INVITE
                               |pass INV to TU
            INVITE             V send 100 if TU won't in 200ms
            send response+-----------+
                +--------|           |--------+101-199 from TU
                |        | Proceeding|        |send response
                +------->|           |<-------+
                         |           |          Transport Err.
                         |           |          Inform TU
                         |           |--------------->+
                         +-----------+                |
            300-699 from TU |     |2xx from TU        |
            send response   |     |send response      |
                            |     +------------------>+
                            |                         |
            INVITE          V          Timer G fires  |
            send response+-----------+ send response  |
                +--------|           |--------+       |
                |        | Completed |        |       |
                +------->|           |<-------+       |
                         +-----------+                |
                            |     |                   |
                        ACK |     |                   |
                        -   |     +------------------>+
                            |        Timer H fires    |
                            V        or Transport Err.|
                         +-----------+  Inform TU     |
                         |           |                |
                         | Confirmed |                |
                         |           |                |
                         +-----------+                |
                               |                      |
                               |Timer I fires         |
                               |-                     |
                               |                      |
                               V                      |
                         +-----------+                |
                         |           |                |
                         | Terminated|<---------------+
                         |           |
                         +-----------+

              Figure 7: INVITE server transaction
```

"확인됨" 상태의 목적은 최종 응답의 재전송에서 트리거되어 도착하는 추가 ACK 메시지를 흡수하는 것입니다. 이 상태에 들어가면 타이머 I은 신뢰할 수 없는 전송의 경우 T4초 내에 실행되고 신뢰할 수 있는 전송의 경우 0초 내에 실행되도록 설정됩니다. 타이머가 실행되면 서버는 반드시 "종료됨" 상태로 전환되어야 합니다.\(MUST\)

거래가 "종료됨" 상태가 되면 즉시 파기되어야 합니다. 클라이언트 트랜잭션과 마찬가지로 이는 INVITE에 대한 2xx 응답의 신뢰성을 보장하는 데 필요합니다.\(MUST\)

---
### **17.2.2 Non-INVITE Server Transaction**

비INVITE 서버 트랜잭션의 상태 머신은 그림 8에 나와 있습니다.

상태 머신은 "Trying" 상태로 초기화되며 초기화 시 INVITE 또는 ACK 이외의 요청이 전달됩니다. 이 요청은 TU로 전달됩니다. "시도 중" 상태가 되면 추가 요청 재전송은 모두 삭제됩니다. 섹션 17.2.3에 지정된 규칙을 사용하여 동일한 서버 트랜잭션과 일치하는 경우 요청은 재전송입니다.

"시도 중" 상태에 있는 동안 TU가 서버 트랜잭션에 임시 응답을 전달하면 서버 트랜잭션은 "진행 중" 상태로 들어가야 합니다. 응답은 전송을 위해 전송 계층으로 전달되어야 합니다. "진행 중" 상태에 있는 동안 TU로부터 수신된 추가 임시 응답은 전송을 위해 전송 계층으로 전달되어야 합니다. "Proceeding" 상태에 있는 동안 요청의 재전송이 수신되면 가장 최근에 전송된 임시 응답이 재전송을 위해 전송 계층으로 전달되어야 합니다. TU가 "Proceeding" 상태에 있는 동안 서버에 최종 응답\(상태 코드 200-699\)을 전달하는 경우 트랜잭션은 "Completed" 상태로 들어가야 하며 응답은 전송을 위해 전송 계층으로 전달되어야 합니다.\(MUST, MUST, MUST, MUST, MUST\)

서버 트랜잭션이 "완료" 상태에 들어갈 때 신뢰할 수 없는 전송의 경우 64\*T1초 내에 실행되고 신뢰할 수 있는 전송의 경우 0초 내에 실행되도록 타이머 J를 설정해야 합니다. "완료" 상태에 있는 동안 서버 트랜잭션은 요청의 재전송이 수신될 때마다 재전송을 위해 전송 계층에 최종 응답을 전달해야 합니다. TU가 서버 트랜잭션으로 전달한 다른 모든 최종 응답은 "완료" 상태에 있는 동안 폐기되어야 합니다. 서버 트랜잭션은 타이머 J가 실행될 때까지 이 상태로 유지되며, 이 시점에서 반드시 "종료됨" 상태로 전환되어야 합니다.\(MUST, MUST, MUST, MUST\)

서버 트랜잭션은 "종료됨" 상태에 들어가는 즉시 파기되어야 합니다.\(MUST\)

---
### **17.2.3 Matching Requests to Server Transactions**

서버가 네트워크로부터 요청을 받으면 기존 트랜잭션과 일치해야 합니다. 이는 다음과 같은 방식으로 수행됩니다.

요청의 최상위 Via 헤더 필드에 있는 분기 매개변수가 검사됩니다. 존재하고 매직 쿠키 "z9hG4bK"로 시작하는 경우 요청은 이 사양을 준수하는 클라이언트 트랜잭션에 의해 생성된 것입니다. 따라서 분기 매개변수는 해당 클라이언트가 보낸 모든 트랜잭션에서 고유합니다. 다음과 같은 경우 요청이 거래와 일치합니다.

- 1. 요청의 분기 매개변수는 트랜잭션을 생성한 요청의 상단 Via 헤더 필드에 있는 매개변수와 동일합니다.

- 2. 요청의 상단 Via에 있는 sent-by 값은 트랜잭션을 생성한 요청의 값과 동일합니다.

- 3. 요청 방법은 트랜잭션을 생성한 요청 방법이 INVITE인 ACK를 제외하고 트랜잭션을 생성한 방법과 일치합니다.

이 일치 규칙은 INVITE 및 비INVITE 거래 모두에 동일하게 적용됩니다.

- 다른 클라이언트의 분기 매개변수가 실수로 또는 악의적으로 중복될 수 있으므로 보낸 사람 값은 일치 프로세스의 일부로 사용됩니다.

상단 Via 헤더 필드에 분기 매개변수가 없거나 매직 쿠키가 포함되어 있지 않은 경우 다음 절차가 사용됩니다. 이는 RFC 2543 호환 구현과의 하위 호환성을 처리하기 위해 존재합니다.

INVITE 요청은 Request-URI, To 태그, From 태그, Call-ID, CSeq 및 최상위 Via 헤더 필드가 트랜잭션을 생성한 INVITE 요청의 필드와 일치하는 경우 트랜잭션과 일치합니다. 이 경우 INVITE는 트랜잭션을 생성한 원본의 재전송입니다. Request-URI, From 태그, Call-ID, CSeq 번호\(메서드 아님\) 및 최상위 Via 헤더 필드가 트랜잭션을 생성한 INVITE 요청의 필드와 ACK의 To 태그와 일치하는 경우 ACK 요청은 트랜잭션과 일치합니다. 서버 트랜잭션이 보낸 응답의 To 태그와 일치합니다. 일치는 각 헤더 필드에 대해 정의된 일치 규칙을 기반으로 수행됩니다. ACK 일치 프로세스의 To 헤더 필드에 태그를 포함하면 2xx에 대한 ACK와 다른 응답에 대한 ACK를 명확하게 하는 데 도움이 됩니다.

두 응답을 모두 전달했을 수 있는 프록시에서\(이는 비정상적인 상황에서 발생할 수 있습니다. 특히 프록시가 요청을 분기한 다음 충돌하는 경우 응답이 다른 프록시로 전달될 수 있으며 이로 인해 여러 응답이 업스트림으로 전달될 수 있습니다\). 이전 ACK와 일치하는 INVITE 트랜잭션과 일치하는 ACK 요청은 이전 ACK의 재전송으로 간주됩니다.

```text
                                  |Request received
                                  |pass to TU
                                  V
                            +-----------+
                            |           |
                            | Trying    |-------------+
                            |           |             |
                            +-----------+             |200-699 from TU
                                  |                   |send response
                                  |1xx from TU        |
                                  |send response      |
                                  |                   |
               Request            V      1xx from TU  |
               send response+-----------+send response|
                   +--------|           |--------+    |
                   |        | Proceeding|        |    |
                   +------->|           |<-------+    |
            +<--------------|           |             |
            |Trnsprt Err    +-----------+             |
            |Inform TU            |                   |
            |                     |                   |
            |                     |200-699 from TU    |
            |                     |send response      |
            |  Request            V                   |
            |  send response+-----------+             |
            |      +--------|           |             |
            |      |        | Completed |<------------+
            |      +------->|           |
            +<--------------|           |
            |Trnsprt Err    +-----------+
            |Inform TU            |
            |                     |Timer J fires
            |                     |-
            |                     |
            |                     V
            |               +-----------+
            |               |           |
            +-------------->| Terminated|
                            |           |
                            +-----------+

                Figure 8: non-INVITE server transaction
```

다른 모든 요청 방법의 경우 Request-URI, To 태그, From 태그, Call-ID, CSeq\(메서드 포함\) 및 상단 Via 헤더 필드가 트랜잭션을 생성한 요청과 일치하면 요청이 트랜잭션과 일치됩니다. . 매칭은 매칭을 기반으로 이루어집니다.

각 헤더 필드에 대해 정의된 규칙입니다. INVITE가 아닌 요청이 기존 트랜잭션과 일치하는 경우 해당 트랜잭션을 생성한 요청이 재전송됩니다.

일치 규칙에는 Request-URI가 포함되어 있으므로 서버는 트랜잭션에 대한 응답을 일치시킬 수 없습니다. TU가 서버 트랜잭션에 응답을 전달할 때 이를 응답의 대상이 되는 특정 서버 트랜잭션에 전달해야 합니다.

---
### **17.2.4 Handling Transport Errors**

서버 트랜잭션이 전송할 전송 계층에 응답을 보낼 때 전송 계층에서 실패를 나타내는 경우 다음 절차를 따릅니다.

먼저 백업에 대한 응답 전달을 시도하는 \[4\]의 절차를 따릅니다. \[4\]의 실패 정의에 따라 모두 실패하는 경우 서버 트랜잭션은 TU에 실패가 발생했음을 알리고 종료된 상태로 전환해야 합니다\(SHOULD\).\(SHOULD\)

---
# **18 Transport**

전송 계층은 네트워크 전송을 통한 요청 및 응답의 실제 전송을 담당합니다. 여기에는 연결 지향 전송의 경우 요청 또는 응답에 사용할 연결 결정이 포함됩니다.

전송 계층은 TCP 및 SCTP와 같은 전송 프로토콜에 대한 영구 연결을 관리하거나 전송 계층에 개방된 프로토콜을 포함하여 TLS를 관리하는 역할을 담당합니다. 여기에는 클라이언트 또는 서버 전송에 의해 열린 연결이 포함되므로 클라이언트와 서버 전송 기능 간에 연결이 공유됩니다. 이러한 연결은 연결의 맨 끝에 있는 주소, 포트 및 전송 프로토콜로 구성된 튜플에 의해 색인화됩니다. 전송 계층에서 연결이 열리면 이 인덱스는 대상 IP, 포트 및 전송으로 설정됩니다. 전송 계층에서 연결이 승인되면 이 인덱스는 소스 IP 주소, 포트 번호 및 전송으로 설정됩니다. 소스 포트는 임시적인 경우가 많지만 \[4\]의 절차를 통해 임시인지 선택되었는지 알 수 없기 때문에 전송 계층에서 허용한 연결이 재사용되지 않는 경우가 많습니다. 결과적으로 연결 지향 전송을 사용하는 "피어링" 관계에 있는 두 프록시는 각 방향에서 시작된 트랜잭션에 대해 하나씩 두 개의 연결을 사용하게 되는 경우가 많습니다.

마지막 메시지가 해당 연결을 통해 전송되거나 수신된 후 구현에 정의된 일정 기간 동안 연결을 열어 두는 것이 권장됩니다. 이 기간은 최소한 트랜잭션을 인스턴스화에서 종료 상태로 가져오기 위해 요소에 필요한 가장 긴 시간과 같아야 합니다. 이는 트랜잭션이 시작된 것과 동일한 연결을 통해 트랜잭션이 완료될 가능성을 높이기 위한 것입니다\(예: 요청, 응답 및 INVITE의 경우 2xx가 아닌 응답에 대한 ACK\). 이는 일반적으로 최소 64\*T1을 의미합니다\(T1의 정의는 섹션 17.1.1.1 참조\). 그러나 예를 들어 타이머 C\(섹션 16.6의 글머리 기호 11\)에 대해 큰 값을 사용하는 TU가 있는 요소에서는 이 값이 더 클 수 있습니다.\(SHOULD, SHOULD\)

모든 SIP 요소는 UDP 및 TCP를 구현해야 합니다. SIP 요소는 다른 프로토콜을 구현할 수 있습니다.\(MUST, MAY\)

- UA에 TCP를 필수로 만드는 것은 RFC 2543에서 상당한 변화입니다. 이는 아래에서 설명하는 것처럼 TCP를 사용해야 하는 더 큰 메시지를 처리해야 할 필요성 때문에 발생했습니다. 따라서 요소가 큰 메시지를 보내지 않더라도 메시지를 받을 수 있으며 이를 처리할 수 있어야 합니다.\(MUST\)

---
## **18.1 Clients**
---
### **18.1.1 Sending Requests**

전송 계층의 클라이언트 측은 요청을 보내고 응답을 받는 역할을 담당합니다. 전송 계층의 사용자는 요청, IP 주소, 포트, 전송 및 멀티캐스트 대상에 대한 TTL을 클라이언트 전송에 전달합니다.

요청이 경로 MTU의 200바이트 내에 있거나 1300바이트보다 크고 경로 MTU를 알 수 없는 경우 요청은 TCP와 같은 RFC 2914\[43\] 혼잡 제어 전송 프로토콜을 사용하여 전송되어야 합니다. 이로 인해 상단 Via에 표시된 전송 프로토콜이 변경되면 상단 Via의 값을 변경해야 합니다. 이는 UDP를 통한 메시지 조각화를 방지하고 더 큰 메시지에 대한 혼잡 제어를 제공합니다. 그러나 구현은 최대 데이터그램 패킷 크기까지 메시지를 처리할 수 있어야 합니다\(MUST\). UDP의 경우 이 크기는 IP 및 UDP 헤더를 포함하여 65,535바이트입니다.\(MUST, MUST, MUST\)

- 메시지 크기와 MTU 사이의 200바이트 "버퍼"는 SIP의 응답이 요청보다 클 수 있다는 사실을 수용합니다. 예를 들어, 이는 INVITE에 대한 응답에 Record-Route 헤더 필드 값을 추가하기 때문에 발생합니다. 추가 버퍼를 사용하면 응답이 요청보다 약 170바이트 더 커질 수 있으며 IPv4에서는 여전히 조각화되지 않습니다\(약 30바이트\).

- IPSec가 없다고 가정하면 IP/UDP에서 사용됩니다. 1500바이트 이더넷 MTU를 가정하여 경로 MTU를 알 수 없는 경우 1300이 선택됩니다.

이러한 메시지 크기 제약으로 인해 요소가 TCP를 통해 요청을 보내고 해당 요청이 UDP를 통해 전송되었을 경우, 연결 설정 시도로 인해 지원되지 않는 ICMP 프로토콜이 생성되거나 TCP 재설정이 발생하는 경우 요소는 UDP를 사용하여 요청을 재시도해야 합니다\(SHOULD\). 이는 TCP를 지원하지 않는 RFC 2543 호환 구현과의 하위 호환성을 제공하기 위한 것입니다. 이 동작은 이 사양의 향후 개정판에서 더 이상 사용되지 않을 것으로 예상됩니다.\(SHOULD\)

멀티캐스트 주소로 요청을 보내는 클라이언트는 대상 멀티캐스트 주소가 포함된 Via 헤더 필드 값에 "maddr" 매개변수를 추가해야 하며, IPv4의 경우 값이 1인 "ttl" 매개변수를 추가해야 합니다. IPv6 멀티캐스트 사용법 본 사양에서는 정의되지 않았으며 향후 필요 시 표준화의 대상이 될 것입니다.\(MUST\)

이러한 규칙으로 인해 SIP의 멀티캐스트가 의도적으로 제한됩니다. 주요 기능은 "단일 홉 검색과 유사한" 서비스를 제공하여 동종 서버 그룹에 요청을 전달하는 것입니다. 여기서는 그 중 하나의 응답만 처리하면 됩니다. 이 기능은 등록에 가장 유용합니다. 실제로 섹션 17.1.3의 트랜잭션 처리 규칙에 따라 클라이언트 트랜잭션은 첫 번째 응답을 수락하고 다른 응답은 모두 동일한 Via 분기 식별자를 포함하기 때문에 재전송으로 간주합니다.

요청이 전송되기 전에 클라이언트 전송은 "sent-by" 필드의 값을 Via 헤더 필드에 삽입해야 합니다. 이 필드에는 IP 주소 또는 호스트 이름과 포트가 포함됩니다. FQDN 사용을 권장합니다. 이 필드는 아래 설명된 특정 조건에서 응답을 보내는 데 사용됩니다. 포트가 없는 경우 기본값은 전송에 따라 다릅니다. UDP, TCP, SCTP의 경우 5060, TLS의 경우 5061입니다.\(MUST, SHOULD\)

안정적인 전송을 위해 응답은 일반적으로 요청이 수신된 연결에서 전송됩니다. 따라서 클라이언트 전송은 요청을 보내는 데 사용된 것과 동일한 연결에서 응답을 수신할 준비를 해야 합니다. 오류 상황에서 서버는 응답을 보내기 위해 새 연결을 열려고 시도할 수 있습니다. 이 경우를 처리하려면 전송 계층도 요청이 전송된 소스 IP 주소와 "sent-by" 필드의 포트 번호에서 들어오는 연결을 수신할 준비를 해야 합니다. 또한\(MUST, MUST\)

\[4\]의 섹션 5에 설명된 절차에 따라 서버가 선택한 모든 주소 및 포트에서 들어오는 연결을 수신할 준비를 해야 합니다.\(MUST\)

신뢰할 수 없는 유니캐스트 전송의 경우 클라이언트 전송은 요청이 전송되는 소스 IP 주소\(응답이 소스 주소로 다시 전송됨\)와 "sent-by" 필드의 포트 번호에서 응답을 수신할 준비를 해야 합니다. 또한 신뢰할 수 있는 전송과 마찬가지로 어떤 경우에는 응답이 다른 곳으로 전송됩니다. 클라이언트는 \[4\]의 섹션 5에 설명된 절차에 따라 서버가 선택한 모든 주소와 포트에서 응답을 수신할 준비를 해야 합니다.\(MUST, MUST\)

멀티캐스트의 경우 클라이언트 전송은 요청이 전송된 동일한 멀티캐스트 그룹 및 포트에서 응답을 수신할 준비가 되어 있어야 합니다\(즉, 요청을 보낸 멀티캐스트 그룹의 구성원이어야 합니다\).\(MUST\)

요청이 기존 연결이 열려 있는 IP 주소, 포트 및 전송을 대상으로 하는 경우 요청을 보내는 데 이 연결을 사용하는 것이 권장되지만 다른 연결을 열어 사용할 수도 있습니다.\(SHOULD\)

멀티캐스트를 사용하여 요청을 보내는 경우 전송 사용자가 제공한 그룹 주소, 포트 및 TTL로 전송됩니다. 신뢰할 수 없는 유니캐스트 전송을 사용하여 요청을 보내는 경우 해당 요청은 전송 사용자가 제공한 IP 주소와 포트로 전송됩니다.

---
### **18.1.2 Receiving Responses**

응답이 수신되면 클라이언트 전송은 최상위 Via 헤더 필드 값을 검사합니다. 해당 헤더 필드 값의 "sent-by" 매개변수 값이 클라이언트 전송이 요청에 삽입하도록 구성된 값과 일치하지 않는 경우 응답은 자동으로 폐기되어야 합니다.\(MUST\)

존재하는 클라이언트 트랜잭션이 있는 경우 클라이언트 전송은 섹션 17.1.3의 일치 절차를 사용하여 기존 트랜잭션에 대한 응답을 일치시키려고 시도합니다. 일치하는 항목이 있으면 응답이 해당 트랜잭션으로 전달되어야 합니다. 그렇지 않으면 추가 처리를 위해 응답을 코어\(상태 비저장 프록시, 상태 저장 프록시 또는 UA인지 여부\)로 전달해야 합니다. 이러한 "스트레스" 응답 처리는 코어에 따라 다릅니다\(예를 들어 프록시는 응답을 전달하고 UA는 삭제합니다\).\(MUST, MUST\)

---
## **18.2 Servers**
---
### **18.2.1 Receiving Requests**

서버는 해당 서버와 통신할 목적으로 전달되는 SIP 또는 SIPS URI\[4\]에 대한 DNS 조회의 결과일 수 있는 모든 IP 주소, 포트 및 전송 조합에 대한 요청을 수신할 준비를 해야 합니다. 이 맥락에서 "전달"에는 REGISTER 요청이나 리디렉션 응답의 연락처 헤더 필드 또는 요청이나 응답의 Record-Route 헤더 필드에 URI를 배치하는 것이 포함됩니다. URI는 웹페이지나 명함에 배치하여 "전달"할 수도 있습니다. 또한 서버가 모든 공용 인터페이스의 기본 SIP 포트\(TCP 및 UDP의 경우 5060, TLS over TCP의 경우 5061\)에서 요청을 수신하는 것이 좋습니다. 일반적인 예외는 개인 네트워크이거나 여러 서버 인스턴스가 동일한 호스트에서 실행되는 경우입니다. 서버가 UDP를 수신하는 모든 포트와 인터페이스의 경우, TCP도 동일한 포트와 인터페이스에서 수신해야 합니다. 메시지가 너무 큰 경우 UDP가 아닌 TCP를 사용하여 메시지를 보내야 할 수도 있기 때문입니다. 결과적으로 그 반대는 사실이 아닙니다. 서버는 동일한 주소와 포트에서 TCP를 수신하고 있다고 해서 특정 주소와 포트에서 UDP를 수신할 필요가 없습니다. 물론 서버가 특정 주소와 포트에서 UDP를 수신해야 하는 다른 이유가 있을 수 있습니다.\(SHOULD, SHOULD, MUST\)

서버 전송이 전송을 통해 요청을 수신하면 상단 Via 헤더 필드 값의 "sent-by" 매개변수 값을 검사해야 합니다. "sent-by" 매개변수의 호스트 부분에 도메인 이름이 포함되어 있거나 패킷 소스 주소와 다른 IP 주소가 포함되어 있는 경우 서버는 해당 Via 헤더 필드 값에 "received" 매개변수를 추가해야 합니다. 이 매개변수는 패킷이 수신된 소스 주소를 포함해야 합니다. 이는 요청이 발생한 소스 IP 주소로 응답을 전송해야 하기 때문에 서버 전송 계층에서 응답을 보내는 데 도움이 됩니다.\(MUST, MUST, MUST\)

부분적으로 다음과 같은 서버 전송에서 수신된 요청을 생각해 보세요.

```text
      INVITE sip:bob@Biloxi.com SIP/2.0
      Via: SIP/2.0/UDP bobspc.biloxi.com:5060
```

요청은 소스 IP 주소 192.0.2.4로 수신됩니다. 요청을 전달하기 전에 전송은 "received" 매개변수를 추가하므로 요청은 부분적으로 다음과 같습니다.

```text
      INVITE sip:bob@Biloxi.com SIP/2.0
      Via: SIP/2.0/UDP bobspc.biloxi.com:5060;received=192.0.2.4
```

다음으로 서버 전송은 요청을 서버 트랜잭션과 일치시키려고 시도합니다. 이는 섹션 17.2.3에 설명된 일치 규칙을 사용하여 수행됩니다. 일치하는 서버 트랜잭션이 발견되면 처리를 위해 요청이 해당 트랜잭션으로 전달됩니다. 일치하는 항목이 없으면 요청이 코어로 전달되며 코어는 해당 요청에 대한 새 서버 트랜잭션을 구성하기로 결정할 수 있습니다. UAS 코어가 INVITE에 2xx 응답을 보내면 서버 트랜잭션이 삭제됩니다. 즉, ACK가 도착하면 일치하는 서버 트랜잭션이 없으며 이 규칙에 따라 ACK가 UAS 코어로 전달되어 처리됩니다.

---
### **18.2.2 Sending Responses**

서버 전송은 응답을 보낼 위치를 결정하기 위해 상단 Via 헤더 필드의 값을 사용합니다. 반드시 다음 프로세스를 따라야 합니다.\(MUST\)

- o "전송 프로토콜"이 TCP, SCTP 또는 이에 대한 TLS와 같은 신뢰할 수 있는 전송 프로토콜인 경우, 해당 연결이 다음과 같은 경우 트랜잭션을 생성한 원래 요청 소스에 대한 기존 연결을 사용하여 응답을 전송해야 합니다. 아직 열려 있습니다. 이를 위해서는 서버 트랜잭션과 전송 연결 간의 연결을 유지하기 위해 서버 전송이 필요합니다. 해당 연결이 더 이상 열려 있지 않으면 서버는 "sent-by" 값의 포트를 사용하여 "received" 매개변수의 IP 주소\(있는 경우\)에 대한 연결을 열어야 하며, 그렇지 않은 경우 해당 전송의 기본 포트를 사용해야 합니다. 포트가 지정되었습니다. 해당 연결 시도가 실패하면 서버는 연결을 열고 응답을 보낼 IP 주소와 포트를 결정하기 위해 서버에 대해 \[4\]의 절차를 사용해야 합니다.\(MUST, SHOULD, SHOULD\)

- o 그렇지 않고 Via 헤더 필드 값에 "maddr" 매개변수가 포함된 경우 응답은 "sent-by"에 표시된 포트를 사용하거나 포트 5060\(아무것도 없으면 포트 5060\)을 사용하여 거기에 나열된 주소로 전달되어야 합니다. 주소가 멀티캐스트 주소인 경우 "ttl" 매개변수에 표시된 TTL을 사용하여 응답을 전송해야 하며 해당 매개변수가 없으면 TTL 1을 사용하여 전송해야 합니다.\(MUST, SHOULD\)

- o 그렇지 않고\(신뢰할 수 없는 유니캐스트 전송의 경우\) 최상위 Via에 "received" 매개변수가 있는 경우 응답은 "sent-by" 값에 표시된 포트를 사용하여 "received" 매개변수의 주소로 전송되어야 합니다. 명시적으로 지정되지 않은 경우 포트 5060을 사용합니다. 예를 들어 이것이 실패하여 ICMP "포트 도달 불가능" 응답이 도출되면 \[4\]의 섹션 5의 절차를 사용하여 응답을 보낼 위치를 결정해야 합니다.\(MUST, SHOULD\)

- o 그렇지 않고 수신자 태그가 지정되지 않은 경우 응답은 \[4\]의 섹션 5의 절차를 사용하여 "sent-by" 값으로 표시된 주소로 전송되어야 합니다.\(MUST\)

---
## **18.3 Framing**

메시지 지향 전송\(예: UDP\)의 경우 메시지에 Content-Length 헤더 필드가 있으면 메시지 본문에 그만큼의 바이트가 포함된 것으로 가정됩니다. 전송 패킷에 본문 끝을 넘어서는 추가 바이트가 있는 경우 이를 폐기해야 합니다. 메시지 본문이 끝나기 전에 전송 패킷이 끝나면 오류로 간주됩니다. 메시지가 응답이면 폐기해야 합니다. 메시지가 요청인 경우 요소는 400\(잘못된 요청\) 응답을 생성해야 합니다. 메시지에 Content-Length 헤더 필드가 없으면 메시지 본문은 전송 패킷의 끝에서 끝나는 것으로 간주됩니다.\(MUST, MUST, SHOULD\)

TCP와 같은 스트림 지향 전송의 경우 Content-Length 헤더 필드는 본문의 크기를 나타냅니다. Content-Length 헤더 필드는 스트림 지향 전송과 함께 사용해야 합니다.\(MUST\)

---
## **18.4 Error Handling**

오류 처리는 메시지가 요청인지 응답인지에 관계없이 이루어집니다.

전송 사용자가 신뢰할 수 없는 전송을 통해 메시지를 보내도록 요청하고 결과가 ICMP 오류인 경우 동작은 ICMP 오류 유형에 따라 달라집니다. 호스트, 네트워크, 포트 또는 프로토콜에 도달할 수 없는 오류 또는 매개변수 문제 오류로 인해 전송 계층은 전송 사용자에게 전송 실패를 알려야 합니다. 소스 냉각 및 TTL 초과 ICMP 오류는 무시되어야 합니다.\(SHOULD, SHOULD\)

전송 사용자가 신뢰할 수 있는 전송을 통해 요청을 보내도록 요청하고 그 결과가 연결 실패인 경우 전송 계층은 전송 사용자에게 전송 실패를 알려야 합니다.\(SHOULD\)

---
# **19 Common Message Components**

별도의 논의가 필요한 SIP 메시지 내\(때로는 메시지 외부\)의 다양한 위치에 나타나는 SIP 메시지의 특정 구성 요소가 있습니다.

---
## **19.1 SIP and SIPS Uniform Resource Indicators**

SIP 또는 SIPS URI는 통신 리소스를 식별합니다. 모든 URI와 마찬가지로 SIP 및 SIPS URI는 웹 페이지, 이메일 메시지 또는 인쇄 문헌에 배치될 수 있습니다. 여기에는 리소스와의 통신 세션을 시작하고 유지하는 데 충분한 정보가 포함되어 있습니다.

통신 자원의 예는 다음과 같습니다.

- o 온라인 서비스 사용자

- o 다중 회선 전화에 등장

- o 메시징 시스템의 사서함

- o 게이트웨이 서비스의 PSTN 번호

- o 조직 내 그룹\(예: "영업" 또는 "헬프데스크"\)

SIPS URI는 리소스에 안전하게 연결되도록 지정합니다. 이는 특히 UAC와 URI를 소유한 도메인 간에 TLS가 사용된다는 것을 의미합니다. 여기에서 사용자에게 접근하기 위해 보안 통신이 사용되며, 여기서 특정 보안 메커니즘은 도메인 정책에 따라 달라집니다. SIP URI로 설명되는 모든 리소스는 해당 리소스와 안전하게 통신하려는 경우 구성표를 변경하여 SIPS URI로 "업그레이드"할 수 있습니다.

---
### **19.1.1 SIP and SIPS URI Components**

"sip:" 및 "sips:" 구성표는 RFC 2396 \[5\]의 지침을 따릅니다. mailto URL과 유사한 형식을 사용하여 SIP 요청 헤더 필드와 SIP 메시지 본문을 지정할 수 있습니다. 이를 통해 웹 페이지나 이메일 메시지에서 URI를 사용하여 시작된 세션의 제목, 미디어 유형 또는 긴급성을 지정할 수 있습니다. SIP 또는 SIPS URI의 공식 구문은 섹션 25에 나와 있습니다. SIP URI의 경우 일반 형식은 다음과 같습니다.

```text
      sip:user:password@host:port;uri-parameters?headers
```

SIPS URI의 형식은 구성표가 sip 대신 "sips"라는 점을 제외하면 동일합니다. 이러한 토큰과 확장팩의 일부 토큰은 다음과 같은 의미를 갖습니다.

- 사용자: 주소가 지정된 호스트에 있는 특정 리소스의 식별자입니다. 이 문맥에서 "호스트"라는 용어는 도메인을 의미하는 경우가 많습니다. URI의 "userinfo"는 이 사용자 필드, 비밀번호 필드 및 그 뒤에 오는 @ 기호로 구성됩니다. URI의 userinfo 부분은 선택 사항이며 다음과 같은 경우에는 없을 수 있습니다.\(MAY\)

- 대상 호스트에는 사용자 개념이 없거나 호스트 자체가 식별되는 리소스인 경우. @ 기호가 SIP 또는 SIPS URI에 있는 경우 사용자 필드는 비어 있으면 안 됩니다.\(MUST NOT\)

- 주소가 지정되는 호스트가 인터넷 전화 게이트웨이와 같이 전화 번호를 처리할 수 있는 경우 RFC 2806 \[9\]에 정의된 전화 가입자 필드를 사용하여 사용자 필드를 채울 수 있습니다. 섹션 19.1.2에 설명된 SIP 및 SIPS URI의 전화-가입자 필드를 인코딩하기 위한 특별한 이스케이프 규칙이 있습니다.\(MAY\)

- 비밀번호: 사용자와 관련된 비밀번호입니다. SIP 및 SIPS URI 구문을 사용하면 이 필드가 존재할 수 있지만 해당 필드를 사용하는 것은 권장되지 않습니다. 인증 정보를 일반 텍스트\(예: URI\)로 전달하는 것이 거의 모든 경우에 보안 위험이 있는 것으로 입증되었기 때문입니다. . 예를 들어, 이 필드에 PIN 번호를 전송하면 PIN이 노출됩니다.\(SHOULD NOT\)

- 비밀번호 필드는 사용자 부분의 확장일 뿐입니다. 필드의 비밀번호 부분에 특별한 의미를 부여하기를 원하지 않는 구현에서는 단순히 "user:password"를 단일 문자열로 처리할 수 있습니다.\(MAY\)

- 호스트: SIP 리소스를 제공하는 호스트입니다. 호스트 부분에는 정규화된 도메인 이름이나 숫자 IPv4 또는 IPv6 주소가 포함됩니다. 가능하면 정규화된 도메인 이름 형식을 사용하는 것이 좋습니다.\(SHOULD\)

- 포트: 요청을 보낼 포트 번호입니다.

- URI 매개변수: URI에서 구성된 요청에 영향을 미치는 매개변수입니다.

- URI 매개변수는 호스트포트 구성요소 뒤에 추가되며 세미콜론으로 구분됩니다.

- URI 매개변수는 다음 형식을 취합니다.

```text
            parameter-name "=" parameter-value
```

- 임의 개수의 URI 매개변수가 URI에 포함될 수 있더라도 주어진 매개변수 이름은 두 번 이상 나타나서는 안 됩니다.\(MUST NOT\)

- 이 확장 가능한 메커니즘에는 전송, maddr, ttl, 사용자, 메소드 및 lr 매개변수가 포함됩니다.

- 전송 매개변수는 \[4\]에 지정된 대로 SIP 메시지 전송에 사용되는 전송 메커니즘을 결정합니다. SIP는 모든 네트워크 전송 프로토콜을 사용할 수 있습니다. 매개변수 이름은 UDP\(RFC 768 \[14\]\), TCP\(RFC 761 \[15\]\) 및 SCTP\(RFC 2960 \[16\]\)에 대해 정의됩니다. SIPS URI의 경우 전송 매개변수는 신뢰할 수 있는 전송을 나타내야 합니다.\(MUST\)

maddr 매개변수는 서버 주소를 나타냅니다.

- 이 사용자에 대해 연락하여 호스트 필드에서 파생된 모든 주소를 재정의합니다. maddr 매개변수가 있는 경우 URI의 포트 및 전송 구성요소는 maddr 매개변수 값에 표시된 주소에 적용됩니다. \[4\]는 요청을 보내기 위한 대상 주소, 포트 및 전송을 얻기 위해 전송, maddr 및 호스트 포트의 적절한 해석을 설명합니다.

- maddr 필드는 느슨한 소스 라우팅의 간단한 형태로 사용되었습니다. 이를 통해 URI는 대상으로 가는 도중에 통과해야 하는 프록시를 지정할 수 있습니다. 이 방식으로 maddr 매개변수를 계속 사용하는 것은 권장되지 않습니다\(이를 활성화하는 메커니즘은 더 이상 사용되지 않음\). 대신 구현에서는 이 문서에 설명된 경로 메커니즘을 사용하여 필요한 경우 기존 경로 집합을 설정해야 합니다\(섹션 8.1.1.1 참조\). 이는 통과할 노드를 설명하는 전체 URI를 제공합니다.

- ttl 매개변수는 UDP 멀티캐스트 패킷의 TTL\(time-to-live\) 값을 결정하며 maddr이 멀티캐스트 주소이고 전송 프로토콜이 UDP인 경우에만 사용해야 합니다. 예를 들어, ttl이 15인 239.255.255.1에 대한 멀티캐스트를 사용하여 alice@atlanta.com에 대한 호출을 지정하려면 다음 URI가 사용됩니다.\(MUST\)

```text
            sip:alice@atlanta.com;maddr=239.255.255.1;ttl=15
```

- 유효한 전화-가입자 문자열 집합은 유효한 사용자 문자열의 하위 집합입니다. 사용자 URI 매개변수는 전화번호처럼 보이는 사용자 이름과 전화번호를 구별하기 위해 존재합니다. 사용자 문자열에 전화 가입자 형식의 전화번호가 포함되어 있는 경우 사용자 매개변수 값 "phone"이 있어야 합니다. 이 매개변수가 없더라도 SIP 및 SIPS URI 수신자는 사용자 이름의 네임스페이스에 대한 로컬 제한이 허용하는 경우 pre-@ 부분을 전화번호로 해석할 수 있습니다.\(SHOULD, MAY\)

- URI에서 생성된 SIP 요청의 방법은 method 매개변수를 사용하여 지정할 수 있습니다.

- lr 매개변수가 있는 경우 이 리소스를 담당하는 요소가 이 문서에 지정된 라우팅 메커니즘을 구현함을 나타냅니다. 이 매개변수는 URI 프록시 위치에서 Record-Route 헤더 필드 값에 사용되며 기존 경로 세트의 URI에 나타날 수 있습니다.

- 이 매개변수는 RFC 2543의 엄격한 라우팅 메커니즘과 bis-05까지의 rfc2543bis 초안을 구현하는 시스템과의 하위 호환성을 달성하는 데 사용됩니다. 이 매개변수를 포함하지 않는 URI를 기반으로 요청 전송을 준비하는 요소는 수신 요소가 엄격한 라우팅을 구현한다고 가정하고 요청-URI의 정보를 보존하기 위해 메시지 형식을 다시 지정할 수 있습니다.

- URI 매개변수 메커니즘은 확장 가능하므로 SIP 요소는 이해하지 못하는 모든 URI 매개변수를 자동으로 무시해야 합니다.\(MUST\)

- 헤더: URI에서 생성된 요청에 포함될 헤더 필드입니다.

- SIP 요청의 헤더 필드는 "?"로 지정할 수 있습니다. URI 내의 메커니즘. 헤더 이름과 값은 앰퍼샌드로 구분된 hname = hvalue 쌍으로 인코딩됩니다. 특수 hname "body"는 연관된 hvalue가 SIP 요청의 메시지 본문임을 나타냅니다.

표 1에는 URI가 나타나는 컨텍스트를 기반으로 SIP 및 SIPS URI 구성 요소의 사용이 요약되어 있습니다. 외부 열은 SIP 메시지 외부\(예: 웹 페이지 또는 명함\) 어디에나 나타나는 URI를 설명합니다. "m"으로 표시된 항목은 필수사항, "o"로 표시된 항목은 선택사항, "-"로 표시된 항목은 허용되지 않습니다. URI를 처리하는 요소는 허용되지 않는 구성 요소가 있는 경우 무시해야 합니다. 두 번째 열은 선택적 요소가 없는 경우 해당 요소의 기본값을 나타냅니다. "--"는 요소가 선택사항이 아니거나 기본값이 없음을 나타냅니다.\(SHOULD\)

연락처 헤더 필드의 URI에는 헤더 필드가 나타나는 컨텍스트에 따라 다른 제한 사항이 있습니다. 한 세트는 대화 상자\(INVITE 및 해당 200\(OK\) 응답\)를 설정하고 유지하는 메시지에 적용됩니다. 다른 하나는 등록 및 리디렉션 메시지\(REGISTER, 200\(OK\) 응답 및 모든 메서드에 대한 3xx 클래스 응답\)에 적용됩니다.

---
### **19.1.2 Character Escaping Requirements**

```text
                                                       dialog
                                          reg./redir. Contact/
              default  Req.-URI  To  From  Contact   R-R/Route  external
user          --          o      o    o       o          o         o
password      --          o      o    o       o          o         o
host          --          m      m    m       m          m         m
port          (1)         o      -    -       o          o         o
user-param    ip          o      o    o       o          o         o
method        INVITE      -      -    -       -          -         o
maddr-param   --          o      -    -       o          o         o
ttl-param     1           o      -    -       o          -         o
transp.-param (2)         o      -    -       o          o         o
lr-param      --          o      -    -       -          o         o
other-param   --          o      o    o       o          o         o
headers       --          -      -    -       o          -         o
```

\(1\): 기본 포트 값은 전송 및 구성표에 따라 다릅니다. UDP, TCP 또는 SCTP를 사용하는 sip의 기본값은 5060입니다. sip: TLS over TCP 및 sips: over TCP 사용의 기본값은 5061입니다.

\(2\): 기본 전송은 체계에 따라 다릅니다. sip:의 경우 UDP입니다. sips:의 경우 TCP입니다.

표 1: SIP 헤더 필드 값, 요청-URI 및 참조에 대한 URI 구성 요소의 사용 및 기본값

SIP는 SIP URI에서 이스케이프해야 하는 문자 집합을 정의할 때 RFC 2396\[5\]의 요구 사항과 지침을 따르고 이스케이프를 위해 ""%" HEX HEX" 메커니즘을 사용합니다. RFC 2396 \[5\]에서:

- 특정 URI 구성 요소 내에 실제로 예약된 문자 집합은 해당 구성 요소에 의해 정의됩니다. 일반적으로 문자가 이스케이프된 US-ASCII 인코딩으로 대체되는 경우 URI의 의미가 변경되면 문자가 예약됩니다\[5\]. 공백, 제어 문자, URI 구분 기호로 사용되는 문자 등 제외된 US-ASCII 문자\(RFC 2396 \[5\]\)도 이스케이프해야 합니다. URI에는 이스케이프되지 않은 공백과 제어 문자가 포함되어서는 안 됩니다.\(MUST, MUST NOT\)

각 구성요소에 대해 유효한 BNF 확장 세트는 이스케이프되지 않은 것으로 나타날 수 있는 문자를 정확하게 정의합니다. 다른 모든 문자는 이스케이프되어야 합니다.\(MUST\)

예를 들어, "@"는 사용자 구성 요소의 문자 집합에 없으므로 "j@s0n" 사용자는 "j%40s0n"에서와 같이 인코딩된 @ 기호를 최소한 가지고 있어야 합니다.

섹션 25의 hname 및 hvalue 토큰을 확장하면 헤더 필드 이름 및 값의 모든 URI 예약 문자를 이스케이프해야 함을 알 수 있습니다.\(MUST\)

사용자 구성 요소의 전화 가입자 하위 집합에는 특별한 이스케이프 고려 사항이 있습니다. 전화 가입자에 대한 RFC 2806 \[9\] 설명에 예약되지 않은 문자 세트에는 SIP URI에서 사용될 때 이스케이프해야 하는 다양한 구문 요소의 문자 수가 포함되어 있습니다. 사용자 규칙에 대한 BNF 확장에 나타나지 않는 전화 가입자에서 발생하는 모든 문자는 이스케이프되어야 합니다.\(MUST\)

SIP 또는 SIPS URI의 호스트 구성 요소에서는 문자 이스케이프가 허용되지 않습니다\(확장 시 % 문자는 유효하지 않음\). 이는 국제화된 도메인 이름에 대한 요구 사항이 최종 확정됨에 따라 향후 변경될 가능성이 높습니다. 현재 구현은 호스트 구성 요소에서 수신된 이스케이프 문자를 문자 그대로 이스케이프되지 않은 문자와 동일하게 처리하여 견고성을 향상시키려고 시도해서는 안 됩니다. IDN 요구 사항을 충족하는 데 필요한 동작은 상당히 다를 수 있습니다.\(MUST NOT\)

---
### **19.1.3 Example SIP and SIPS URIs**

```text
   sip:alice@atlanta.com
   sip:alice:secretword@atlanta.com;transport=tcp
   sips:alice@atlanta.com?subject=project%20x&priority=urgent
   sip:+1-212-555-1212:1234@gateway.com;user=phone
   sips:1212@gateway.com
   sip:alice@192.0.2.4
   sip:atlanta.com;method=REGISTER?to=alice%40atlanta.com
   sip:alice;day=tuesday@atlanta.com
```

위의 마지막 샘플 URI에는 "alice;day=tuesday"라는 사용자 필드 값이 있습니다. 위에 정의된 이스케이프 규칙을 사용하면 이 필드에서 세미콜론이 이스케이프되지 않은 상태로 표시될 수 있습니다. 이 프로토콜의 목적에 따라 필드는 불투명합니다. 해당 값의 구조는 리소스를 담당하는 SIP 요소에만 유용합니다.

---
### **19.1.4 URI Comparison**

이 사양의 일부 작업에서는 두 개의 SIP 또는 SIPS URI가 동일한지 확인해야 합니다. 이 사양에서 등록자는 REGISTER 요청의 연락처 URI에 있는 바인딩을 비교해야 합니다\(섹션 10.3 참조\). SIP 및 SIPS URI는 다음 규칙에 따라 동일한지 비교됩니다.

- o SIP와 SIPS URI는 동일하지 않습니다.

- o SIP와 SIPS URI의 사용자 정보 비교는 대소문자를 구분합니다. 여기에는 비밀번호를 포함하거나 전화 가입자로 형식화된 사용자 정보가 포함됩니다. URI의 다른 모든 구성요소 비교는 달리 명시적으로 정의되지 않는 한 대소문자를 구분하지 않습니다.

- o SIP와 SIPS URI를 비교할 때 매개변수와 헤더 필드의 순서는 중요하지 않습니다.

- o "예약된" 세트\(RFC 2396 \[5\] 참조\) 이외의 문자는 ""%" HEX HEX" 인코딩과 동일합니다.

- o 호스트 이름에 대한 DNS 조회 결과인 IP 주소가 해당 호스트 이름과 일치하지 않습니다.

- o 두 URI가 동일하려면 사용자, 비밀번호, 호스트 및 포트 구성 요소가 일치해야 합니다.

- 사용자 구성요소를 생략한 URI는 사용자 구성요소를 포함하는 URI와 일치하지 않습니다. 비밀번호 구성요소를 생략한 URI는 비밀번호 구성요소를 포함하는 URI와 일치하지 않습니다.

- 기본값이 있는 구성 요소를 생략한 URI는 기본값이 있는 해당 구성 요소를 명시적으로 포함하는 URI와 일치하지 않습니다. 예를 들어 선택적 포트 구성 요소를 생략한 URI는 포트 5060을 명시적으로 선언하는 URI와 일치하지 않습니다. 전송 매개 변수, ttl 매개 변수, 사용자 매개 변수 및 메서드 구성 요소의 경우에도 마찬가지입니다.

sip:user@host를 다음과 동일하지 않도록 정의

- sip:user@host:5060은 RFC 2543에서 변경된 사항입니다. URI에서 주소를 파생할 때 동일한 URI에서 동일한 주소가 예상됩니다. URI sip:user@host:5060은 항상 포트 5060으로 확인됩니다. URI sip:user@host는 \[4\]에 자세히 설명된 DNS SRV 메커니즘을 통해 다른 포트로 확인될 수 있습니다.

- o URI URI 매개변수 구성요소는 다음과 같이 비교됩니다.

- - 두 URI에 나타나는 모든 URI 매개변수는 일치해야 합니다.

- - 하나의 URI에만 나타나는 사용자, ttl 또는 메소드 uri-매개변수는 기본값이 포함되어 있어도 절대 일치하지 않습니다.

- - maddr 매개변수가 포함된 URI는 maddr 매개변수가 포함되지 않은 URI와 일치하지 않습니다.

- - 하나의 URI에만 나타나는 다른 모든 URI 매개변수는 URI를 비교할 때 무시됩니다.

- o URI 헤더 구성 요소는 무시되지 않습니다. 현재 헤더 구성 요소는 URI와 일치하는 URI 모두에 있어야 합니다. 일치 규칙은 섹션 20의 각 헤더 필드에 대해 정의됩니다.\(MUST\)

다음 각 세트 내의 URI는 동일합니다.

```text
   sip:%61lice@atlanta.com;transport=TCP
   sip:alice@AtLanTa.CoM;Transport=tcp

   sip:carol@chicago.com
   sip:carol@chicago.com;newparam=5
   sip:carol@chicago.com;security=on

   sip:biloxi.com;transport=tcp;method=REGISTER?to=sip:bob%40biloxi.com
   sip:biloxi.com;method=REGISTER;transport=tcp?to=sip:bob%40biloxi.com

   sip:alice@atlanta.com?subject=project%20x&priority=urgent
   sip:alice@atlanta.com?priority=urgent&subject=project%20x
```

다음 각 세트 내의 URI는 동일하지 않습니다.

```text
   SIP:ALICE@AtLanTa.CoM;Transport=udp             (different usernames)
   sip:alice@AtLanTa.CoM;Transport=UDP

   sip:bob@biloxi.com                   (can resolve to different ports)
   sip:bob@biloxi.com:5060

   sip:bob@biloxi.com              (can resolve to different transports)
   sip:bob@biloxi.com;transport=udp

   sip:bob@biloxi.com     (can resolve to different port and transports)
   sip:bob@biloxi.com:6000;transport=tcp

   sip:carol@chicago.com                    (different header component)
   sip:carol@chicago.com?Subject=next%20meeting

   sip:bob@phone21.boxesbybob.com   (even though that's what
   sip:bob@192.0.2.4                 phone21.boxesbybob.com resolves to)
```

동등성은 전이적이지 않습니다.

- o sip:carol@chicago.com 및 sip:carol@chicago.com;security=on은 동일합니다.

- o sip:carol@chicago.com 및 sip:carol@chicago.com;security=off는 동일합니다.

o sip:carol@chicago.com;security=on 및

- sip:carol@chicago.com;security=off는 동일하지 않습니다.

---
### **19.1.5 Forming Requests from a URI**

구현에서는 URI에서 직접 요청을 구성할 때 주의해야 합니다. 명함, 웹 페이지, 심지어 등록된 연락처와 같은 프로토콜 내부 소스의 URI에는 부적절한 헤더 필드나 본문 부분이 포함될 수 있습니다.

구현에는 제공된 요청의 요청-URI에 제공된 전송, maddr, ttl 또는 사용자 매개변수가 포함되어야 합니다. URI에 메소드 매개변수가 포함된 경우 해당 값을 요청 메소드로 사용해야 합니다. 메소드 매개변수는 Request-URI에 배치되어서는 안 됩니다. 알 수 없는 URI 매개변수는 메시지의 요청-URI에 있어야 합니다.\(MUST, MUST, MUST NOT, MUST\)

구현에서는 URI에 있는 헤더나 본문 부분을 메시지에 포함시키려는 의도로 처리해야 하며 구성 요소별로 요청을 수락하도록 선택해야 합니다.\(SHOULD\)

구현은 From, Call-ID, CSeq, Via 및 Record-Route와 같이 명백히 위험한 헤더 필드를 존중해서는 안 됩니다.\(SHOULD NOT\)

구현은 악의적인 공격에서 무의식적인 에이전트로 사용되지 않도록 요청된 경로 헤더 필드 값을 존중해서는 안 됩니다.\(SHOULD NOT\)

구현은 위치나 기능을 허위로 광고하게 만들 수 있는 헤더 필드를 포함하라는 요청을 수락해서는 안 됩니다. 여기에는 Accept, Accept-Encoding, Accept-Language, Allow, Contact\(대화 상자 사용 시\), Organization, Supported 및 User-Agent가 포함됩니다.\(SHOULD NOT\)

구현에서는 Content-Disposition, Content-Encoding, Content-Language, Content-Length, Content-Type, Date, Mime-Version 및 Timestamp를 포함하여 요청된 모든 설명 헤더 필드의 정확성을 확인해야 합니다.\(SHOULD\)

지정된 URI에서 메시지를 구성하여 형성된 요청이 유효한 SIP 요청이 아닌 경우 해당 URI는 유효하지 않습니다. 구현은 요청 전송을 진행해서는 안 됩니다. 대신 발생하는 컨텍스트에서 유효하지 않은 URI로 인해 조치 과정을 추구해야 합니다.\(MUST NOT\)

- 구성된 요청은 여러 면에서 유효하지 않을 수 있습니다. 여기에는 헤더 필드의 구문 오류, 잘못된 URI 매개변수 조합, 메시지 본문의 잘못된 설명 등이 포함되지만 이에 국한되지는 않습니다.

지정된 URI에서 구성된 요청을 보내려면 구현에 사용할 수 없는 기능이 필요할 수 있습니다. 예를 들어 URI는 구현되지 않은 전송 또는 확장의 사용을 나타낼 수 있습니다. 구현은 해당 요청의 기능에 맞게 수정하는 대신 이러한 요청 전송을 거부해야 합니다\(SHOULD\). 구현은 지원하지 않는 확장을 요구하는 요청을 보내서는 안 됩니다.\(SHOULD, MUST NOT\)

- 예를 들어, 이러한 요청은 알 수 없거나 명시적으로 지원되지 않는 값을 가진 Require 헤더 매개변수 또는 메소드 URI 매개변수의 존재를 통해 형성될 수 있습니다.

---
### **19.1.6 Relating SIP URIs and tel URLs**

전화 URL\(RFC 2806 \[9\]\)이 SIP 또는 SIPS URI로 변환되면 매개변수를 포함하여 전화 URL의 전체 전화 가입자 부분이 SIP 또는 SIPS URI의 userinfo 부분에 배치됩니다.

```text
   Thus, tel:+358-555-1234567;postd=pp22 becomes

      sip:+358-555-1234567;postd=pp22@foo.com;user=phone

   or
      sips:+358-555-1234567;postd=pp22@foo.com;user=phone

   not
      sip:+358-555-1234567@foo.com;postd=pp22;user=phone

   or

      sips:+358-555-1234567@foo.com;postd=pp22;user=phone
```

일반적으로 이러한 방식으로 SIP 또는 SIPS URI로 변환된 동등한 "전화" URL은 동등한 SIP 또는 SIPS URI를 생성하지 않을 수 있습니다. SIP 및 SIPS URI의 사용자 정보는 대소문자를 구분하는 문자열로 비교됩니다. 전화 URL에서 대소문자를 구분하지 않는 부분의 차이와 전화 URL 매개변수의 순서 변경은 전화 URL 동등성에 영향을 주지 않지만, 이로부터 형성된 SIP URI의 동등성에는 영향을 미칩니다.

예를 들어,

```text
      tel:+358-555-1234567;postd=pp22
      tel:+358-555-1234567;POSTD=PP22
```

동등하지만

```text
      sip:+358-555-1234567;postd=pp22@foo.com;user=phone
      sip:+358-555-1234567;POSTD=PP22@foo.com;user=phone
```

그렇지 않습니다.

```text
   Likewise,

      tel:+358-555-1234567;postd=pp22;isub=1411
      tel:+358-555-1234567;isub=1411;postd=pp22
```

동등하지만

```text
      sip:+358-555-1234567;postd=pp22;isub=1411@foo.com;user=phone
      sip:+358-555-1234567;isub=1411;postd=pp22@foo.com;user=phone
```

그렇지 않습니다.

이 문제를 완화하려면 SIP 또는 SIPS URI의 userinfo 부분에 배치할 전화 가입자 필드를 구성하는 요소는 전화 가입자의 대소문자를 구분하지 않는 부분을 소문자로 접어야 하고 전화 가입자 매개변수를 매개변수 이름별로 사전적으로 정렬해야 합니다. 단, isdn-subaddress와 post-dial은 먼저 해당 순서로 발생합니다. \(미래 확장 매개변수를 제외한 전화 URL의 모든 구성요소는 대소문자를 구분하지 않고 비교되도록 정의됩니다.\)\(SHOULD\)

이 제안에 따라 두 사람 모두

```text
      tel:+358-555-1234567;postd=pp22
      tel:+358-555-1234567;POSTD=PP22

      become

        sip:+358-555-1234567;postd=pp22@foo.com;user=phone
```

그리고 둘 다

```text
        tel:+358-555-1234567;tsp=a.b;phone-context=5
        tel:+358-555-1234567;phone-context=5;tsp=a.b

      become

        sip:+358-555-1234567;phone-context=5;tsp=a.b@foo.com;user=phone
```

---
## **19.2 Option Tags**

옵션 태그는 SIP에서 새 옵션\(확장\)을 지정하는 데 사용되는 고유 식별자입니다. 이러한 태그는 Require\(섹션 20.32\), Proxy-Require\(섹션 20.29\), Supported\(섹션 20.37\) 및 Unsupported\(섹션 20.40\) 헤더 필드에 사용됩니다. 이러한 옵션은 option-tag = token 형식의 해당 헤더 필드에 매개변수로 나타납니다\(토큰 정의는 섹션 25 참조\).

옵션 태그는 표준 트랙 RFC에 정의되어 있습니다. 이는 과거 관행에서 변경된 것이며 지속적인 다중 공급업체 상호 운용성을 보장하기 위해 제정되었습니다\(섹션 20.32 및 섹션 20.37의 논의 참조\). 쉽게 참조할 수 있도록 옵션 태그의 IANA 레지스트리가 사용됩니다.

---
## **19.3 Tags**

"tag" 매개변수는 SIP 메시지의 To 및 From 헤더 필드에 사용됩니다. 이는 대화의 각 참가자로부터 하나씩 두 개의 태그와 Call-ID의 조합인 대화를 식별하는 일반적인 메커니즘으로 사용됩니다. UA가 대화 상자 외부에서 요청을 보내는 경우 대화 상자 ID의 "절반"을 제공하는 From 태그만 포함됩니다. 대화는 각각 To 헤더 필드의 후반부를 구성하는 응답에서 완료됩니다. SIP 요청을 분기한다는 것은 단일 요청에서 여러 대화를 설정할 수 있음을 의미합니다. 이는 또한 양면 대화 식별자의 필요성을 설명합니다. 수신자의 기여 없이는 발신자는 단일 요청에서 설정된 여러 대화를 명확하게 할 수 없습니다.

요청이나 응답에 삽입하기 위해 UA에 의해 태그가 생성된 경우 태그는 전역적으로 고유해야 하며 최소 32비트 무작위성을 갖춘 암호화 방식으로 무작위여야 합니다. 이 선택 요구 사항의 속성은 UA가 동일한 INVITE에 대한 응답의 To 헤더에 배치하는 것과 다른 태그를 INVITE의 From 헤더에 배치한다는 것입니다. 이는 UA가 자신을 세션에 초대하기 위해 필요하며, 이는 PSTN 게이트웨이에서 통화를 "헤어핀"하는 일반적인 경우입니다. 마찬가지로, 서로 다른 통화에 대한 두 개의 INVITE에는 서로 다른 From 태그가 있고, 서로 다른 통화에 대한 두 개의 응답에는 서로 다른 To 태그가 있습니다.\(MUST\)

전역 고유성에 대한 요구 사항 외에도 태그 생성 알고리즘은 구현에 따라 다릅니다. 태그는 오류 발생 후 대체 서버에서 대화 상자가 복구되는 내결함성 시스템에 유용합니다. UAS는 백업이 요청을 실패한 서버의 대화 상자의 일부로 인식할 수 있는 방식으로 태그를 선택할 수 있으므로 대화 상자 및 이와 관련된 다른 상태를 복구해야 한다고 결정할 수 있습니다.

---
# **20 Header Fields**

헤더 필드의 일반 구문은 섹션 7.3에서 다룹니다. 이 섹션에는 구문, 의미 및 사용법에 대한 참고 사항과 함께 전체 헤더 필드 세트가 나열되어 있습니다. 이 섹션 전체에서 \[HX.Y\]를 사용하여 현재 HTTP/1.1 사양 RFC 2616 \[8\]의 X.Y 섹션을 참조합니다. 각 헤더 필드의 예가 제공됩니다.

메소드 및 프록시 처리와 관련된 헤더 필드에 대한 정보는 표 2 및 3에 요약되어 있습니다.

"where" 열은 헤더 필드가 사용될 수 있는 요청 및 응답 유형을 설명합니다. 이 열의 값은 다음과 같습니다.

```text
      R: header field may only appear in requests;

      r: header field may only appear in responses;

      2xx, 4xx, etc.: A numerical value or range indicates response
           codes with which the header field can be used;
```

- c: 헤더 필드가 요청에서 응답으로 복사됩니다.

- "where" 열의 빈 항목은 헤더 필드가 모든 요청 및 응답에 존재할 수 있음을 나타냅니다.

"프록시" 열은 프록시가 헤더 필드에서 수행할 수 있는 작업을 설명합니다.

- a: 프록시는 헤더 필드가 없는 경우 헤더 필드를 추가하거나 연결할 수 있습니다.

- m: 프록시는 기존 헤더 필드 값을 수정할 수 있습니다.

- d: 프록시는 헤더 필드 값을 삭제할 수 있습니다.

- r: 프록시는 헤더 필드를 읽을 수 있어야 하므로 이 헤더 필드는 암호화될 수 없습니다.

다음 6개 열은 메소드의 헤더 필드 존재 여부와 관련됩니다.

- c: 조건부; 헤더 필드의 요구 사항은 메시지의 컨텍스트에 따라 달라집니다.

- m: 헤더 필드는 필수입니다.

- m\*: 헤더 필드를 전송해야 하지만 클라이언트/서버는 해당 헤더 필드 없이 메시지를 수신할 준비가 되어 있어야 합니다.\(SHOULD\)

- o: 헤더 필드는 선택사항입니다.

- t: 헤더 필드를 전송해야 하지만 클라이언트/서버는 해당 헤더 필드 없이 메시지를 수신할 준비가 되어 있어야 합니다.\(SHOULD\)

- 스트림 기반 프로토콜\(예: TCP\)이 전송으로 사용되는 경우 헤더 필드를 전송해야 합니다.\(MUST\)

- \*: 메시지 본문이 비어 있지 않은 경우 헤더 필드가 필요합니다. 자세한 내용은 섹션 20.14, 20.15 및 7.4를 참조하십시오.

- -: 헤더 필드가 적용되지 않습니다.

"선택적"은 요소가 요청 또는 응답에 헤더 필드를 포함할 수 있으며 UA가 요청 또는 응답에 헤더 필드가 있는 경우 해당 헤더 필드를 무시할 수 있음을 의미합니다\(이 규칙의 예외는 20.32에서 논의된 Require 헤더 필드입니다\). "필수" 헤더 필드는 요청에 있어야 하며 요청을 수신하는 UAS가 이해해야 합니다. 응답에는 필수 응답 헤더 필드가 있어야 하며, 응답을 처리하는 UAC는 헤더 필드를 이해해야 합니다. "해당 사항 없음"은 헤더 필드가 요청에 있어서는 안 된다는 의미입니다. 실수로 요청에 포함된 경우 요청을 수신하는 UAS는 이를 무시해야 합니다. 마찬가지로, 응답에 대해 "적용할 수 없음"이라고 표시된 헤더 필드는 UAS가 응답에 헤더 필드를 배치해서는 안 되며 UAC가 응답의 헤더 필드를 무시해야 함을 의미합니다.\(MAY, MUST, MUST, MUST NOT, MUST, MUST NOT\)

UA는 이해되지 않는 확장 헤더 매개변수를 무시해야 합니다.\(SHOULD\)

전체 메시지 크기가 문제가 될 때 사용하기 위해 일부 공통 헤더 필드 이름의 압축 형식도 정의됩니다.

Contact, From 및 To 헤더 필드에는 URI가 포함되어 있습니다. URI에 쉼표, 물음표 또는 세미콜론이 포함된 경우 URI를 꺾쇠 괄호\(< 및 \>\)로 묶어야 합니다. 모든 URI 매개변수는 이 대괄호 안에 포함됩니다. URI가 꺾쇠 괄호로 묶이지 않은 경우 세미콜론으로 구분된 모든 매개변수는 URI 매개변수가 아닌 헤더 매개변수입니다.\(MUST\)

---
## **20.1 Accept**

Accept 헤더 필드는 \[H14.1\]에 정의된 구문을 따른다. Accept 헤더 필드가 없는 경우 서버는 기본값인 application/sdp를 가정해야 한다는 점을 제외하면 의미도 동일합니다.\(SHOULD\)

비어 있는 Accept 헤더 필드는 허용되는 형식이 없음을 의미합니다.

```text
   Example:

      Header field          where   proxy ACK BYE CAN INV OPT REG
      ___________________________________________________________
      Accept                  R            -   o   -   o   m*  o
      Accept                 2xx           -   -   -   o   m*  o
      Accept                 415           -   c   -   c   c   c
      Accept-Encoding         R            -   o   -   o   o   o
      Accept-Encoding        2xx           -   -   -   o   m*  o
      Accept-Encoding        415           -   c   -   c   c   c
      Accept-Language         R            -   o   -   o   o   o
      Accept-Language        2xx           -   -   -   o   m*  o
      Accept-Language        415           -   c   -   c   c   c
      Alert-Info              R      ar    -   -   -   o   -   -
      Alert-Info             180     ar    -   -   -   o   -   -
      Allow                   R            -   o   -   o   o   o
      Allow                  2xx           -   o   -   m*  m*  o
      Allow                   r            -   o   -   o   o   o
      Allow                  405           -   m   -   m   m   m
      Authentication-Info    2xx           -   o   -   o   o   o
      Authorization           R            o   o   o   o   o   o
      Call-ID                 c       r    m   m   m   m   m   m
      Call-Info                      ar    -   -   -   o   o   o
      Contact                 R            o   -   -   m   o   o
      Contact                1xx           -   -   -   o   -   -
      Contact                2xx           -   -   -   m   o   o
      Contact                3xx      d    -   o   -   o   o   o
      Contact                485           -   o   -   o   o   o
      Content-Disposition                  o   o   -   o   o   o
      Content-Encoding                     o   o   -   o   o   o
      Content-Language                     o   o   -   o   o   o
      Content-Length                 ar    t   t   t   t   t   t
      Content-Type                         *   *   -   *   *   *
      CSeq                    c       r    m   m   m   m   m   m
      Date                            a    o   o   o   o   o   o
      Error-Info           300-699    a    -   o   o   o   o   o
      Expires                              -   -   -   o   -   o
      From                    c       r    m   m   m   m   m   m
      In-Reply-To             R            -   -   -   o   -   -
      Max-Forwards            R      amr   m   m   m   m   m   m
      Min-Expires            423           -   -   -   -   -   m
      MIME-Version                         o   o   -   o   o   o
      Organization                   ar    -   -   -   o   o   o

             Table 2: Summary of header fields, A--O

   Header field              where       proxy ACK BYE CAN INV OPT REG
   ___________________________________________________________________
   Priority                    R          ar    -   -   -   o   -   -
   Proxy-Authenticate         407         ar    -   m   -   m   m   m
   Proxy-Authenticate         401         ar    -   o   o   o   o   o
   Proxy-Authorization         R          dr    o   o   -   o   o   o
   Proxy-Require               R          ar    -   o   -   o   o   o
   Record-Route                R          ar    o   o   o   o   o   -
   Record-Route             2xx,18x       mr    -   o   o   o   o   -
   Reply-To                                     -   -   -   o   -   -
   Require                                ar    -   c   -   c   c   c
   Retry-After          404,413,480,486         -   o   o   o   o   o
                            500,503             -   o   o   o   o   o
                            600,603             -   o   o   o   o   o
   Route                       R          adr   c   c   c   c   c   c
   Server                      r                -   o   o   o   o   o
   Subject                     R                -   -   -   o   -   -
   Supported                   R                -   o   o   m*  o   o
   Supported                  2xx               -   o   o   m*  m*  o
   Timestamp                                    o   o   o   o   o   o
   To                        c(1)          r    m   m   m   m   m   m
   Unsupported                420               -   m   -   m   m   m
   User-Agent                                   o   o   o   o   o   o
   Via                         R          amr   m   m   m   m   m   m
   Via                        rc          dr    m   m   m   m   m   m
   Warning                     r                -   o   o   o   o   o
   WWW-Authenticate           401         ar    -   m   -   m   m   m
   WWW-Authenticate           407         ar    -   o   -   o   o   o
```

표 3: 헤더 필드 요약, P--Z; \(1\): 태그 추가 가능 복사

```text
      Accept: application/sdp;level=1, application/x-private, text/html
```

---
## **20.2 Accept-Encoding**

Accept-Encoding 헤더 필드는 Accept와 유사하지만 응답에서 허용되는 콘텐츠 코딩 \[H3.5\]을 제한합니다. \[H14.3\]을 참조하세요. SIP의 의미는 \[H14.3\]에 정의된 것과 동일합니다.

빈 Accept-Encoding 헤더 필드가 허용됩니다. 이는 Accept-Encoding과 동일합니다. 즉, ID 인코딩만 허용됩니다. 즉, 인코딩이 허용되지 않습니다.

Accept-Encoding 헤더 필드가 없으면 서버는 기본값인 ID를 가정해야 합니다.\(SHOULD\)

이는 존재하지 않는 경우 모든 인코딩을 사용할 수 있지만 ID 인코딩이 선호됨을 나타내는 HTTP 정의와 약간 다릅니다.

```text
   Example:

      Accept-Encoding: gzip
```

---
## **20.3 Accept-Language**

Accept-Language 헤더 필드는 요청에서 응답의 메시지 본문으로 전달되는 이유 문구, 세션 설명 또는 상태 응답에 대한 기본 언어를 표시하는 데 사용됩니다. Accept-Language 헤더 필드가 없으면 서버는 클라이언트가 모든 언어를 허용한다고 가정해야 합니다.\(SHOULD\)

Accept-Language 헤더 필드는 \[H14.4\]에 정의된 구문을 따른다. "q" 매개변수를 기반으로 언어를 정렬하는 규칙은 SIP에도 적용됩니다.

```text
   Example:

      Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

---
## **20.4 Alert-Info**

INVITE 요청에 있는 경우 Alert-Info 헤더 필드는 UAS에 대한 대체 벨소리를 지정합니다. 180\(Ringing\) 응답에 있는 경우 Alert-Info 헤더 필드는 UAC에 대한 대체 통화 연결음을 지정합니다. 일반적인 사용법은 프록시가 이 헤더 필드를 삽입하여 벨소리 구별 기능을 제공하는 것입니다.

Alert-Info 헤더 필드는 보안 위험을 초래할 수 있습니다. 이러한 위험과 이를 처리하는 방법은 위험이 동일하므로 Call-Info 헤더 필드를 논의하는 섹션 20.9에서 논의됩니다.

또한 사용자는 이 기능을 선택적으로 비활성화할 수 있어야 합니다\(SHOULD\).\(SHOULD\)

- 이는 신뢰할 수 없는 요소가 이 헤더 필드를 사용함으로써 발생할 수 있는 중단을 방지하는 데 도움이 됩니다.

```text
   Example:

      Alert-Info: <http://www.example.com/sounds/moo.wav>
```

---
## **20.5 Allow**

Allow 헤더 필드에는 메시지를 생성하는 UA가 지원하는 메서드 집합이 나열됩니다.

UA가 이해하는 ACK 및 CANCEL을 포함한 모든 메소드는 존재하는 경우 Allow 헤더 필드의 메소드 목록에 포함되어야 합니다. Allow 헤더 필드가 없다고 해서 메시지를 보내는 UA가 메서드를 지원하지 않는다는 의미로 해석해서는 안 됩니다. 오히려 이는 UA가 어떤 방법을 지원하는지에 대한 정보를 제공하지 않는다는 것을 의미합니다.\(MUST, MUST NOT\)

OPTIONS 이외의 메소드에 대한 응답으로 Allow 헤더 필드를 제공하면 필요한 메시지 수가 줄어듭니다.

```text
   Example:

      Allow: INVITE, ACK, OPTIONS, CANCEL, BYE
```

---
## **20.6 Authentication-Info**

Authentication-Info 헤더 필드는 HTTP Digest와의 상호 인증을 제공합니다. UAS는 Authorization 헤더 필드를 기반으로 한 다이제스트를 사용하여 성공적으로 인증된 요청에 대한 2xx 응답에 이 헤더 필드를 포함할 수 있습니다.\(MAY\)

구문과 의미는 RFC 2617 \[17\]에 지정된 내용을 따릅니다.

```text
   Example:

      Authentication-Info: nextnonce="47364c23432d2e131a5fb210812c"
```

---
## **20.7 Authorization**

Authorization 헤더 필드에는 UA의 인증 자격 증명이 포함됩니다. 섹션 22.2에서는 Authorization 헤더 필드의 사용에 대해 간략히 설명하고, 섹션 22.4에서는 HTTP 인증과 함께 사용될 때의 구문과 의미를 설명합니다.

Proxy-Authorization과 함께 이 헤더 필드는 여러 헤더 필드 값에 대한 일반 규칙을 위반합니다. 쉼표로 구분된 목록은 아니지만 이 헤더 필드 이름은 여러 번 나타날 수 있으며 섹션 7.3에 설명된 일반적인 규칙을 사용하여 단일 헤더 라인으로 결합해서는 안 됩니다.\(MUST NOT\)

아래 예에서는 Digest 매개변수 주위에 따옴표가 없습니다.

```text
      Authorization: Digest username="Alice", realm="atlanta.com",
       nonce="84a4cc6f3082121f32b42a2187831a9e",
       response="7587245234b3434cc3412213e5f113a5432"
```

---
## **20.8 Call-ID**

Call-ID 헤더 필드는 특정 클라이언트의 특정 초대 또는 모든 등록을 고유하게 식별합니다. 예를 들어, 사용자가 동일한\(장기 실행\) 회의에 한 개인을 여러 번 초대하는 경우 단일 멀티미디어 회의에서 서로 다른 통화 ID를 사용하여 여러 통화가 발생할 수 있습니다. 호출 ID는 대소문자를 구분하며 단순히 바이트 단위로 비교됩니다.

Call-ID 헤더 필드의 압축 형식은 다음과 같습니다. i.

```text
   Examples:

      Call-ID: f81d4fae-7dec-11d0-a765-00a0c91e6bf6@biloxi.com
      i:f81d4fae-7dec-11d0-a765-00a0c91e6bf6@192.0.2.4
```

---
## **20.9 Call-Info**

Call-Info 헤더 필드는 요청 또는 응답에서 발견되는지 여부에 따라 발신자 또는 수신자에 대한 추가 정보를 제공합니다. URI의 목적은 "목적" 매개변수로 설명됩니다. "icon" 매개변수는 발신자 또는 수신자를 상징적으로 표현하는 데 적합한 이미지를 지정합니다. "info" 매개변수는 웹페이지 등을 통해 일반적으로 발신자 또는 수신자를 설명합니다. "카드" 매개변수는 예를 들어 vCard \[36\] 또는 LDIF \[37\] 형식의 명함을 제공합니다. IANA 및 섹션 27의 절차를 사용하여 추가 토큰을 등록할 수 있습니다.

Call-Info 헤더 필드를 사용하면 보안 위험이 발생할 수 있습니다. 호출 수신자가 악의적인 호출자가 제공한 URI를 가져오는 경우 호출 수신자는 부적절하거나 공격적인 콘텐츠, 위험하거나 불법적인 콘텐츠 등을 표시할 위험에 처할 수 있습니다. 따라서 UA는 헤더 필드를 생성한 요소의 신뢰성을 확인할 수 있고 해당 요소를 신뢰하는 경우에만 Call-Info 헤더 필드의 정보를 렌더링하는 것이 좋습니다. 이는 피어 UA일 필요는 없습니다. 프록시는 이 헤더 필드를 요청에 삽입할 수 있습니다.\(SHOULD\)

```text
   Example:

   Call-Info: <http://wwww.example.com/alice/photo.jpg> ;purpose=icon,
     <http://www.example.com/alice/> ;purpose=info
```

---
## **20.10 Contact**

연락처 헤더 필드 값은 요청 또는 응답 유형에 따라 의미가 달라지는 URI를 제공합니다.

연락처 헤더 필드 값에는 표시 이름, URI 매개변수가 있는 URI, 헤더 매개변수가 포함될 수 있습니다.

이 문서는 연락처 매개변수 "q" 및 "만료"를 정의합니다. 이러한 매개변수는 REGISTER 요청이나 응답 또는 3xx 응답에 연락처가 있는 경우에만 사용됩니다. 추가적인 매개변수는 다른 사양에서 정의될 수 있습니다.

헤더 필드 값에 표시 이름이 포함된 경우 모든 URI 매개변수를 포함하는 URI가 "<" 및 "\>"로 묶입니다. "<" 및 "\>"가 없으면 URI 뒤의 모든 매개변수는 URI 매개변수가 아닌 헤더 매개변수입니다. 표시 이름은 토큰일 수도 있고 더 큰 문자 집합이 필요한 경우 따옴표로 묶은 문자열일 수도 있습니다.

"display-name"이 비어 있더라도 "addr-spec"에 쉼표, 세미콜론 또는 물음표가 포함되어 있으면 "name-addr" 형식을 사용해야 합니다. 표시 이름과 "<" 사이에 LWS가 있을 수도 있고 없을 수도 있습니다.\(MUST\)

표시 이름, URI 및 URI 매개변수, 헤더 매개변수를 구문 분석하기 위한 이러한 규칙은 헤더 필드 To 및 From에도 적용됩니다.

- Contact 헤더 필드는 HTTP의 Location 헤더 필드와 유사한 역할을 합니다. 그러나 HTTP 헤더 필드는 따옴표가 없는 하나의 주소만 허용합니다. URI에는 예약 문자로 쉼표와 세미콜론이 포함될 수 있으므로 각각 헤더 또는 매개변수 구분 기호로 오해될 수 있습니다.

연락처 헤더 필드의 압축 형식은 m\("이동됨"\)입니다.

```text
   Examples:

      Contact: "Mr. Watson" <sip:watson@worcester.bell-telephone.com>
         ;q=0.7; expires=3600,
         "Mr. Watson" <mailto:watson@bell-telephone.com> ;q=0.1
      m: <sips:bob@192.0.2.4>;expires=60
```

---
## **20.11 Content-Disposition**

Content-Disposition 헤더 필드는 메시지 본문 또는 다중 부분 메시지의 경우 메시지 본문 부분이 UAC 또는 UAS에서 해석되는 방식을 설명합니다. 이 SIP 헤더 필드는 MIME Content-Type\(RFC 2183 \[18\]\)을 확장합니다.

Content-Disposition 헤더의 몇 가지 새로운 "처리 유형"이 SIP에 의해 정의됩니다. "세션" 값은 본문 부분이 통화 또는 초기\(통화 전\) 미디어에 대한 세션을 설명함을 나타냅니다. "render" 값은 본문 부분이 사용자에게 표시되거나 렌더링되어야 함을 나타냅니다. MIME 본문이 전체 메시지 렌더링의 일부로 표시된다는 의미를 피하기 위해 "인라인" 대신 "렌더링" 값이 사용됩니다\(SIP 메시지의 MIME 본문은 종종 사용자에게 표시되지 않기 때문\). 이전 버전과의 호환성을 위해 Content-Disposition 헤더 필드가 누락된 경우 서버는 Content-Type 애플리케이션/sdp의 본문이 "세션" 처리이고 다른 콘텐츠 유형은 "렌더링"이라고 가정해야 합니다.\(SHOULD\)

배치 유형 "icon"은 본문 부분에 메시지가 수신될 때 또는 대화가 발생하는 동안 지속적으로 사용자 에이전트에 의해 정보로 렌더링될 수 있는 발신자 또는 수신자의 아이콘 표현으로 적합한 이미지가 포함되어 있음을 나타냅니다. "alert" 값은 본문 부분에 요청\(일반적으로 대화를 시작하는 요청\) 수신을 사용자에게 경고하기 위해 사용자 에이전트가 렌더링해야 하는 오디오 클립과 같은 정보가 포함되어 있음을 나타냅니다. 예를 들어 이 경고 본문은 180 Ringing 임시 응답이 전송된 후 전화 통화에 대한 벨소리로 렌더링될 수 있습니다.

사용자에게 콘텐츠를 렌더링하는 "disposition-type"이 있는 MIME 본문은 메시지가 적절하게 인증된 경우에만 처리되어야 합니다.

처리 매개변수인 Handling-param은 UAS가 이해할 수 없는 콘텐츠 유형이나 처리 유형의 메시지 본문을 수신하는 경우 UAS가 어떻게 반응해야 하는지를 설명합니다. 매개변수에는 "선택사항" 및 "필수" 값이 정의되어 있습니다. 처리 매개변수가 누락된 경우 "필수" 값을 가정해야 합니다. 처리 매개변수는 RFC 3204 \[19\]에 설명되어 있습니다.\(SHOULD\)

이 헤더 필드가 누락된 경우 MIME 유형에 따라 기본 콘텐츠 처리가 결정됩니다. 아무것도 없으면 "렌더링"이 가정됩니다.

```text
   Example:

      Content-Disposition: session
```

---
## **20.12 Content-Encoding**

Content-Encoding 헤더 필드는 "media-type"에 대한 수정자로 사용됩니다. 존재하는 경우 해당 값은 Entity-Body에 어떤 추가 콘텐츠 코딩이 적용되었는지를 나타내며, 따라서 Content-Type 헤더 필드에서 참조하는 미디어 유형을 얻기 위해 어떤 디코딩 메커니즘을 적용해야 하는지를 나타냅니다. Content-Encoding은 기본 미디어 유형의 ID를 잃지 않고 본문을 압축할 수 있도록 하는 데 주로 사용됩니다.\(MUST\)

여러 인코딩이 엔터티 본문에 적용된 경우 콘텐츠 코딩은 적용된 순서대로 나열되어야 합니다.\(MUST\)

모든 콘텐츠 코딩 값은 대소문자를 구분하지 않습니다. IANA는 콘텐츠 코딩 가치 토큰을 위한 등록소 역할을 합니다. 콘텐츠 코딩 구문의 정의는 \[H3.5\]를 참조하세요.

클라이언트는 요청 본문에 콘텐츠 인코딩을 적용할 수 있습니다. 서버는 응답의 본문에 콘텐츠 인코딩을 적용할 수 있습니다. 서버는 요청의 Accept-Encoding 헤더 필드에 나열된 인코딩만 사용해야 합니다.\(MAY, MAY, MUST\)

Content-Encoding 헤더 필드의 압축 형식은 다음과 같습니다. 예:

```text
      Content-Encoding: gzip
      e: tar
```

---
## **20.13 Content-Language**

```text
   See [H14.12]. Example:

      Content-Language: fr
```

---
## **20.14 Content-Length**

Content-Length 헤더 필드는 수신자에게 전송되는 메시지 본문의 크기를 십진수 옥텟으로 나타냅니다. 애플리케이션은 엔터티의 미디어 유형에 관계없이 전송될 메시지 본문의 크기를 나타내기 위해 이 필드를 사용해야 합니다. 스트림 기반 프로토콜\(예: TCP\)이 전송으로 사용되는 경우 헤더 필드를 사용해야 합니다.\(SHOULD, MUST\)

메시지 본문의 크기에는 헤더 필드와 본문을 구분하는 CRLF가 포함되지 않습니다. 0보다 크거나 같은 모든 Content-Length는 유효한 값입니다. 메시지에 본문이 없으면 Content-Length 헤더 필드 값을 0으로 설정해야 합니다.\(MUST\)

- Content-Length를 생략하는 기능은 응답을 동적으로 생성하는 CGI와 유사한 스크립트 생성을 단순화합니다.

헤더 필드의 압축 형식은 l입니다.

```text
   Examples:

      Content-Length: 349
      l: 173
```

---
## **20.15 Content-Type**

Content-Type 헤더 필드는 수신자에게 전송된 메시지 본문의 미디어 유형을 나타냅니다. "media-type" 요소는 \[H3.7\]에 정의되어 있습니다. 본문이 비어 있지 않으면 Content-Type 헤더 필드가 있어야 합니다. 본문이 비어 있고 Content-Type 헤더 필드가 있는 경우 특정 유형의 본문 길이가 0임을 나타냅니다\(예: 빈 오디오 파일\).\(MUST\)

헤더 필드의 압축 형식은 c입니다.

```text
   Examples:

      Content-Type: application/sdp
      c: text/html; charset=ISO-8859-4
```

---
## **20.16 CSeq**

요청의 CSeq 헤더 필드에는 단일 10진수 시퀀스 번호와 요청 메서드가 포함됩니다. 시퀀스 번호는 32비트 부호 없는 정수로 표현 가능해야 합니다. CSeq의 메서드 부분은 대소문자를 구분합니다. CSeq 헤더 필드는 대화 상자 내에서 트랜잭션 순서를 지정하고, 트랜잭션을 고유하게 식별하는 수단을 제공하고, 새 요청과 요청 재전송을 구별하는 데 사용됩니다. 시퀀스 번호와 요청 방법이 동일한 경우 두 CSeq 헤더 필드는 동일한 것으로 간주됩니다. 예:\(MUST\)

```text
      CSeq: 4711 INVITE
```

---
## **20.17 Date**

날짜 헤더 필드에는 날짜와 시간이 포함됩니다. HTTP/1.1과 달리 SIP는 날짜에 대해 최신 RFC 1123 \[20\] 형식만 지원합니다. \[H3.3\]에서와 같이 SIP는 SIP-date의 시간대를 "GMT"로 제한하는 반면 RFC 1123은 모든 시간대를 허용합니다. RFC 1123 날짜는 대소문자를 구분합니다.

날짜 헤더 필드는 요청 또는 응답이 처음 전송된 시간을 반영합니다.

- 날짜 헤더 필드는 배터리 지원 시계가 없는 간단한 최종 시스템에서 현재 시간의 개념을 획득하는 데 사용할 수 있습니다. 그러나 GMT 형식에서는 클라이언트가 GMT와의 오프셋을 알아야 합니다.

```text
   Example:

      Date: Sat, 13 Nov 2010 23:29:00 GMT
```

---
## **20.18 Error-Info**

Error-Info 헤더 필드는 오류 상태 응답에 대한 추가 정보에 대한 포인터를 제공합니다.

- SIP UAC는 PC 소프트 클라이언트의 팝업 창 및 오디오부터 게이트웨이를 통해 연결된 엔드포인트 또는 "검은색" 전화기의 오디오 전용까지 다양한 사용자 인터페이스 기능을 갖추고 있습니다. 오류를 생성하는 서버가 자세한 이유 문구와 함께 오류 상태 코드를 보내는 것과 오디오 녹음을 재생하는 것 중에서 선택하도록 강요하는 대신 Error-Info 헤더 필드를 사용하면 두 가지 모두를 보낼 수 있습니다. 그런 다음 UAC는 호출자에게 렌더링할 오류 표시기를 선택할 수 있습니다.

UAC는 오류 정보 헤더 필드의 SIP 또는 SIPS URI를 리디렉션의 연락처인 것처럼 처리하고 새 INVITE를 생성하여 녹음된 알림 세션이 설정될 수 있습니다. SIP가 아닌 URI가 사용자에게 렌더링될 수 있습니다.\(MAY, MAY\)

```text
   Examples:
```

SIP/2.0 404 지금 거신 전화번호는 현재 사용중인 전화번호가 아닙니다.

- 오류 정보: <sip:not-in-service-recording@atlanta.com\>

---
## **20.19 Expires**

Expires 헤더 필드는 메시지\(또는 콘텐츠\)가 만료되는 상대적 시간을 제공합니다.

이것의 정확한 의미는 방법에 따라 다릅니다.

INVITE의 만료 시간은 초대로 인해 발생할 수 있는 실제 세션 기간에 영향을 주지 않습니다. 그러나 세션 설명 프로토콜은 세션 기간에 대한 시간 제한을 표현하는 기능을 제공할 수 있습니다.

이 필드의 값은 요청 수신 시 측정된 0과 \(2\*\*32\)-1 사이의 정수\(십진수\)입니다.

```text
   Example:

      Expires: 5
```

---
## **20.20 From**

From 헤더 필드는 요청 개시자를 나타냅니다. 이는 대화의 시작자와 다를 수 있습니다. 호출 수신자가 호출자에게 보낸 요청은 From 헤더 필드에 있는 호출 수신자의 주소를 사용합니다.

선택적 "display-name"은 인간 사용자 인터페이스에 의해 렌더링됩니다. 클라이언트의 신원을 숨긴 상태로 유지하려면 시스템은 표시 이름 "Anonymous"를 사용해야 합니다. "display-name"이 비어 있더라도 "addr-spec"에 쉼표, 물음표 또는 세미콜론이 포함되어 있으면 "name-addr" 형식을 사용해야 합니다. 구문 문제는 섹션 7.3.1에서 논의됩니다.\(SHOULD, MUST\)

두 From 헤더 필드는 URI가 일치하고 매개변수가 일치하는 경우 동일합니다. 한 헤더 필드의 확장 매개변수는 다른 헤더 필드에 존재하지 않으며 비교를 위해 무시됩니다. 이는 표시 이름과 꺾쇠 괄호의 유무가 일치에 영향을 미치지 않음을 의미합니다.

표시 이름, URI 및 URI 매개변수, 헤더 필드 매개변수를 구문 분석하는 규칙은 섹션 20.10을 참조하세요.

From 헤더 필드의 압축 형식은 f입니다.

```text
   Examples:

      From: "A. G. Bell" <sip:agb@bell-telephone.com> ;tag=a48s
      From: sip:+12125551212@server.phone2net.com;tag=887s
      f: Anonymous <sip:c8oqz84zk7z@privacy.org>;tag=hyh8
```

---
## **20.21 In-Reply-To**

In-Reply-To 헤더 필드는 이 호출이 참조하거나 반환하는 Call-ID를 열거합니다. 이러한 Call-ID는 클라이언트에 의해 캐시된 다음 반환 호출의 이 헤더 필드에 포함될 수 있습니다.

- 이를 통해 자동 통화 분배 시스템이 첫 번째 통화의 발신자에게 회신 전화를 라우팅할 수 있습니다. 또한 수신자는 통화를 필터링하여 자신이 시작한 통화에 대한 반환 통화만 허용되도록 할 수도 있습니다. 이 필드는 요청 인증을 대체하지 않습니다.

```text
   Example:

      In-Reply-To: 70710@saturn.bell-tel.com, 17320@saturn.bell-tel.com
```

---
## **20.22 Max-Forwards**

Max-Forwards 헤더 필드는 요청을 다음 다운스트림 서버로 전달할 수 있는 프록시 또는 게이트웨이 수를 제한하기 위해 SIP 방법과 함께 사용해야 합니다. 이는 클라이언트가 중간 체인에서 실패하거나 반복되는 것으로 보이는 요청 체인을 추적하려고 할 때에도 유용할 수 있습니다.

Max-Forwards 값은 이 요청 메시지가 전달되도록 허용된 남은 횟수를 나타내는 0-255 범위의 정수입니다. 이 수는 요청을 전달하는 각 서버에 의해 감소됩니다. 권장되는 초기값은 70입니다.

이 헤더 필드는 루프 감지를 보장할 수 없는 요소에 의해 삽입되어야 합니다. 예를 들어 B2BUA는 Max-Forwards 헤더 필드를 삽입해야 합니다.

```text
   Example:

      Max-Forwards: 6
```

---
## **20.23 Min-Expires**

Min-Expires 헤더 필드는 해당 서버에서 관리하는 소프트 상태 요소에 대해 지원되는 최소 새로 고침 간격을 전달합니다. 여기에는 등록자가 저장한 연락처 헤더 필드가 포함됩니다. 헤더 필드에는 0부터 \(2\*\*32\)-1까지의 십진 정수\(초\)가 포함됩니다. 423\(간격이 너무 짧음\) 응답에서 헤더 필드의 사용은 섹션 10.2.8, 10.3 및 21.4.17에 설명되어 있습니다.

```text
   Example:

      Min-Expires: 60
```

---
## **20.24 MIME-Version**

```text
   See [H19.4.1].

   Example:

      MIME-Version: 1.0
```

---
## **20.25 Organization**

조직 헤더 필드는 요청 또는 응답을 발행하는 SIP 요소가 속한 조직의 이름을 전달합니다.

- 이 필드는 클라이언트 소프트웨어에서 통화를 필터링하는 데 사용될 수 있습니다.\(MAY\)

```text
   Example:
```

- 구성 : Boxes by Bob

---
## **20.26 Priority**

Priority 헤더 필드는 클라이언트가 인식한 요청의 긴급성을 나타냅니다. 우선순위 헤더 필드는 SIP 요청이 수신자 또는 해당 에이전트에 대해 가져야 하는 우선순위를 설명합니다. 예를 들어 통화 라우팅 및 수락에 대한 결정에 영향을 미칠 수 있습니다. 이러한 결정의 경우 Priority 헤더 필드가 포함되지 않은 메시지는 "normal"의 우선순위를 지정한 것처럼 처리되어야 합니다. Priority 헤더 필드는 라우터의 패킷 전달 우선 순위나 PSTN 게이트웨이의 회로에 대한 액세스와 같은 통신 리소스의 사용에 영향을 주지 않습니다. 헤더 필드에는 "비긴급", "보통", "긴급" 및 "긴급" 값이 있을 수 있지만 다른 곳에서 추가 값을 정의할 수 있습니다. "긴급" 값은 생명, 신체 또는 재산이 급박한 위험에 처한 경우에만 사용하는 것이 좋습니다. 그렇지 않으면 이 헤더 필드에 대해 정의된 의미가 없습니다.\(SHOULD, SHOULD\)

- 이는 "긴급"이 추가된 RFC 2076 \[38\]의 값입니다.

```text
   Examples:
```

제목: 토네이도가 우리 쪽으로 다가오고 있습니다!

- 우선순위: 긴급상황

```text
   or

      Subject: Weekend plans
      Priority: non-urgent
```

---
## **20.27 Proxy-Authenticate**

Proxy-Authenticate 헤더 필드 값에는 인증 문제가 포함되어 있습니다.

이 헤더 필드의 사용은 \[H14.33\]에 정의되어 있습니다. 사용법에 대한 자세한 내용은 섹션 22.3을 참조하세요.

```text
   Example:

      Proxy-Authenticate: Digest realm="atlanta.com",
       domain="sip:ss1.carrier.com", qop="auth",
       nonce="f84f1cec41e6cbe5aea9c8e88d359",
       opaque="", stale=FALSE, algorithm=MD5
```

---
## **20.28 Proxy-Authorization**

Proxy-Authorization 헤더 필드를 사용하면 클라이언트는 인증이 필요한 프록시에 대해 자신\(또는 해당 사용자\)을 식별할 수 있습니다. Proxy-Authorization 필드 값은 요청되는 리소스의 프록시 및/또는 영역에 대한 사용자 에이전트의 인증 정보를 포함하는 자격 증명으로 구성됩니다.

이 헤더 필드의 사용법에 대한 정의는 섹션 22.3을 참조하세요.

Authorization과 함께 이 헤더 필드는 여러 헤더 필드 이름에 대한 일반 규칙을 위반합니다. 쉼표로 구분된 목록은 아니지만 이 헤더 필드 이름은 여러 번 나타날 수 있으며 섹션 7.3.1에 설명된 일반적인 규칙을 사용하여 단일 헤더 라인으로 결합해서는 안 됩니다.\(MUST NOT\)

```text
   Example:

   Proxy-Authorization: Digest username="Alice", realm="atlanta.com",
      nonce="c60f3082ee1212b402a21831ae",
      response="245f23415f11432b3434341c022"
```

---
## **20.29 Proxy-Require**

Proxy-Require 헤더 필드는 프록시에서 지원해야 하는 프록시 관련 기능을 나타내는 데 사용됩니다. 이 메시지의 메커니즘과 사용 예에 ​​대한 자세한 내용은 섹션 20.32를 참조하세요.

```text
   Example:

      Proxy-Require: foo
```

---
## **20.30 Record-Route**

Record-Route 헤더 필드는 대화 상자의 향후 요청이 프록시를 통해 라우팅되도록 요청의 프록시에 의해 삽입됩니다.

Route 헤더 필드와 함께 사용하는 예는 섹션 16.12.1에 설명되어 있습니다.

```text
   Example:

      Record-Route: <sip:server10.biloxi.com;lr>,
                    <sip:bigbox3.site3.atlanta.com;lr>
```

---
## **20.31 Reply-To**

Reply-To 헤더 필드에는 From 헤더 필드와 다를 수 있는 논리적 반환 URI가 포함되어 있습니다. 예를 들어, URI는 부재중 전화나 설정되지 않은 세션을 반환하는 데 사용될 수 있습니다. 사용자가 익명을 유지하려는 경우 헤더 필드를 요청에서 생략하거나 개인 정보를 공개하지 않는 방식으로 채워야 합니다.\(MAY, SHOULD\)

"display-name"이 비어 있더라도 "addr-spec"에 쉼표, 물음표 또는 세미콜론이 포함되어 있으면 "name-addr" 형식을 사용해야 합니다. 구문 문제는 섹션 7.3.1에서 논의됩니다.\(MUST\)

```text
   Example:

      Reply-To: Bob <sip:bob@biloxi.com>
```

---
## **20.32 Require**

Require 헤더 필드는 UAC가 요청을 처리하기 위해 UAS가 지원할 것으로 예상하는 옵션에 대해 UAS에 알리는 데 사용됩니다. 선택적 헤더 필드이기는 하지만 Require가 존재하는 경우 무시해서는 안 됩니다.\(MUST NOT\)

Require 헤더 필드에는 섹션 19.2에 설명된 옵션 태그 목록이 포함되어 있습니다. 각 옵션 태그는 요청을 처리하기 위해 반드시 이해해야 하는 SIP 확장을 정의합니다. 종종 이는 특정 확장 헤더 필드 세트를 이해해야 함을 나타내는 데 사용됩니다. 이 사양을 준수하는 UAC는 표준 트랙 RFC에 해당하는 옵션 태그만 포함해야 합니다.\(MUST, MUST\)

```text
   Example:

      Require: 100rel
```

---
## **20.33 Retry-After**

Retry-After 헤더 필드는 500\(서버 내부 오류\) 또는 503\(서비스를 사용할 수 없음\) 응답과 함께 사용하여 요청 클라이언트가 서비스를 사용할 수 없는 기간을 나타내고 404\(찾을 수 없음\), 413\( 요청 엔터티가 너무 큼\), 480\(일시적으로 사용할 수 없음\), 486\(여기서는 통화 중\), 600\(통화 중\) 또는 603

\(거절\) 응답은 수신자가 언제 다시 전화를 받을 수 있을 것으로 예상하는지 나타냅니다. 이 필드의 값은 응답 시간 이후의 양의 정수\(십진수\)입니다.

선택적 설명을 사용하여 콜백 시간에 대한 추가 정보를 나타낼 수 있습니다. 선택적 "기간" 매개변수는 초기 사용 가능 시간부터 착신자에게 연락 가능한 시간을 나타냅니다. 기간 매개변수가 제공되지 않으면 서비스를 무기한으로 사용할 수 있는 것으로 간주됩니다.

```text
   Examples:

      Retry-After: 18000;duration=3600
      Retry-After: 120 (I'm in a meeting)
```

---
## **20.34 Route**

Route 헤더 필드는 나열된 프록시 세트를 통해 요청에 대한 라우팅을 강제하는 데 사용됩니다. Route 헤더 필드의 사용 예는 섹션 16.12.1에 있습니다.

```text
   Example:

      Route: <sip:bigbox3.site3.atlanta.com;lr>,
             <sip:server10.biloxi.com;lr>
```

---
## **20.35 Server**

서버 헤더 필드에는 UAS가 요청을 처리하는 데 사용하는 소프트웨어에 대한 정보가 포함되어 있습니다.

서버의 특정 소프트웨어 버전을 공개하면 보안 허점이 있는 것으로 알려진 소프트웨어에 대한 공격에 서버가 더욱 취약해질 수 있습니다. 구현자는 서버 헤더 필드를 구성 가능한 옵션으로 만들어야 합니다.\(SHOULD\)

```text
   Example:

      Server: HomeServer v2
```

---
## **20.36 Subject**

제목 헤더 필드는 요약을 제공하거나 통화의 성격을 나타내므로 세션 설명을 구문 분석하지 않고도 통화 필터링이 가능합니다. 세션 설명은 초대와 동일한 제목 표시를 사용할 필요가 없습니다.

제목 헤더 필드의 압축 형식은 s입니다.

```text
   Example:

      Subject: Need more boxes
      s: Tech Support
```

---
## **20.37 Supported**

지원되는 헤더 필드는 UAC 또는 UAS에서 지원하는 모든 확장을 열거합니다.

Supported 헤더 필드에는 UAC 또는 UAS가 이해하는 섹션 19.2에 설명된 옵션 태그 목록이 포함되어 있습니다. 이 사양을 준수하는 UA는 표준 트랙 RFC에 해당하는 옵션 태그만 포함해야 합니다. 비어 있으면 확장이 지원되지 않는다는 의미입니다.\(MUST\)

지원되는 헤더 필드의 압축 형식은 k입니다.

```text
   Example:

      Supported: 100rel
```

---
## **20.38 Timestamp**

Timestamp 헤더 필드는 UAC가 UAS에 요청을 보낸 시기를 설명합니다.

헤더 필드가 포함된 요청에 대한 응답을 생성하는 방법에 대한 자세한 내용은 섹션 8.2.6을 참조하세요. 여기에 정의된 헤더 사용에 대한 규범적인 동작은 없지만 확장 프로그램이나 SIP 애플리케이션이 RTT 추정치를 얻을 수 있도록 허용합니다.

```text
   Example:

      Timestamp: 54
```

---
## **20.39 To**

To 헤더 필드는 요청의 논리적 수신자를 지정합니다.

선택적 "display-name"은 인간 사용자 인터페이스에 의해 렌더링됩니다. "태그" 매개변수는 대화 식별을 위한 일반적인 메커니즘 역할을 합니다.

"tag" 매개변수에 대한 자세한 내용은 섹션 19.3을 참조하세요.

To 헤더 필드의 동등성을 비교하는 것은 From 헤더 필드를 비교하는 것과 동일합니다. 표시 이름, URI 및 URI 매개변수, 헤더 필드 매개변수를 구문 분석하는 규칙은 섹션 20.10을 참조하세요.

To 헤더 필드의 압축 형식은 t입니다.

다음은 유효한 To 헤더 필드의 예입니다.

- 받는 사람: 교환원 <sip:operator@cs.columbia.edu\>;tag=287447 t: sip:+12125551212@server.phone2net.com

---
## **20.40 Unsupported**

지원되지 않는 헤더 필드에는 UAS에서 지원하지 않는 기능이 나열됩니다. 동기 부여는 섹션 20.32를 참조하세요.

```text
   Example:

      Unsupported: foo
```

---
## **20.41 User-Agent**

User-Agent 헤더 필드에는 요청을 시작한 UAC에 대한 정보가 포함되어 있습니다. 이 헤더 필드의 의미는 \[H14.43\]에 정의되어 있습니다.

사용자 에이전트의 특정 소프트웨어 버전을 공개하면 사용자 에이전트가 보안 허점이 있는 것으로 알려진 소프트웨어에 대한 공격에 더욱 취약해질 수 있습니다. 구현자는 User-Agent 헤더 필드를 구성 가능한 옵션으로 만들어야 합니다.\(SHOULD\)

```text
   Example:

      User-Agent: Softphone Beta1.5
```

---
## **20.42 Via**

Via 헤더 필드는 요청이 지금까지 선택한 경로를 나타내며 응답 라우팅에서 따라야 하는 경로를 나타냅니다. Via 헤더 필드 값의 분기 ID 매개변수는 트랜잭션 식별자 역할을 하며 프록시에서 루프를 감지하는 데 사용됩니다.

Via 헤더 필드 값에는 메시지를 보내는 데 사용되는 전송 프로토콜, 클라이언트의 호스트 이름 또는 네트워크 주소, 응답을 수신하려는 포트 번호가 포함됩니다. Via 헤더 필드 값에는 "maddr", "ttl", "received" 및 "branch"와 같은 매개변수가 포함될 수도 있습니다. 해당 매개변수의 의미와 용도는 설명됩니다.

다른 섹션에서. 이 사양을 준수하는 구현의 경우 분기 매개변수의 값은 섹션 8.1.1.7에서 설명한 대로 매직 쿠키 "z9hG4bK"로 시작해야 합니다.\(MUST\)

여기에 정의된 전송 프로토콜은 "UDP", "TCP", "TLS" 및 "SCTP"입니다. "TLS"는 TCP를 통한 TLS를 의미합니다. 요청이 SIPS URI로 전송되면 프로토콜은 여전히 ​​"SIP"를 나타내고 전송 프로토콜은 TLS입니다.

```text
Via: SIP/2.0/UDP erlang.bell-telephone.com:5060;branch=z9hG4bK87asdks7
Via: SIP/2.0/UDP 192.0.2.1:5060 ;received=192.0.2.207
     ;branch=z9hG4bK77asjd
```

Via 헤더 필드의 압축 형식은 v입니다.

이 예에서 메시지는 두 개의 주소\(192.0.2.1 및 192.0.2.207\)가 있는 멀티홈 호스트에서 시작되었습니다. 발신자는 어떤 네트워크 인터페이스가 사용될지 잘못 추측했습니다. Erlang.bell-phone.com은 불일치를 발견하고 패킷이 실제로 나온 주소를 포함하는 이전 홉의 Via 헤더 필드 값에 매개변수를 추가했습니다.

SIP URI 구문을 따르기 위해 호스트 또는 네트워크 주소와 포트 번호가 필요하지 않습니다. 특히 다음과 같이 ":" 또는 "/" 양쪽에 LWS가 허용됩니다.

```text
      Via: SIP / 2.0 / UDP first.example.com: 4000;ttl=16
        ;maddr=224.2.0.1 ;branch=z9hG4bKa7c6a8dlze.1
```

이 사양에서는 모든 요청에 ​​분기 매개변수가 있어야 한다고 규정하지만 헤더 필드의 BNF는 선택사항임을 나타냅니다. 이를 통해 분기 매개변수를 삽입할 필요가 없었던 RFC 2543 요소와의 상호 운용이 가능해졌습니다.

sent-protocol과 sent-by 필드가 동일하고 둘 다 동일한 매개변수 세트를 가지며 모든 매개변수의 값이 동일한 경우 두 Via 헤더 필드는 동일합니다.

---
## **20.43 Warning**

경고 헤더 필드는 응답 상태에 대한 추가 정보를 전달하는 데 사용됩니다. 경고 헤더 필드 값은 응답과 함께 전송되며 3자리 경고 코드, 호스트 이름 및 경고 텍스트를 포함합니다.

"경고 텍스트"는 응답을 받는 인간 사용자가 가장 쉽게 이해할 수 있는 자연어로 작성되어야 합니다. 이 결정은 사용자의 위치, 요청의 Accept-Language 필드 또는

응답의 Content-Language 필드입니다. 기본 언어는 i-default\[21\]입니다.

현재 정의된 "경고 코드"는 영어로 된 권장 경고 텍스트 및 해당 의미에 대한 설명과 함께 아래에 나열되어 있습니다. 이러한 경고는 세션 설명으로 인해 발생한 오류를 설명합니다. "3"으로 시작하는 경고 코드의 첫 번째 숫자는 SIP 관련 경고를 나타냅니다. 경고 300부터 329까지는 세션 설명에서 키워드에 문제가 있음을 나타내기 위해 예약되어 있고, 330부터 339까지는 세션 설명에서 요청한 기본 네트워크 서비스와 관련된 경고이고, 370부터 379까지는 세션 설명에서 요청한 정량적 QoS 매개변수와 관련된 경고이고, 390은 399부터 399까지는 위 범주 중 하나에 속하지 않는 기타 경고입니다.

- 300 호환되지 않는 네트워크 프로토콜: 세션 설명에 포함된 하나 이상의 네트워크 프로토콜을 사용할 수 없습니다.

- 301 호환되지 않는 네트워크 주소 형식: 세션 설명에 포함된 하나 이상의 네트워크 주소 형식을 사용할 수 없습니다.

- 302 호환되지 않는 전송 프로토콜: 세션 설명에 설명된 하나 이상의 전송 프로토콜을 사용할 수 없습니다.

303 호환되지 않는 대역폭 단위: 하나 이상의 대역폭

- 세션 설명에 포함된 측정 단위를 이해하지 못했습니다.

- 304 미디어 유형을 사용할 수 없음: 세션 설명에 포함된 하나 이상의 미디어 유형을 사용할 수 없습니다.

- 305 호환되지 않는 미디어 형식: 세션 설명에 포함된 하나 이상의 미디어 형식을 사용할 수 없습니다.

- 306 속성이 이해되지 않음: 세션 설명의 미디어 속성 중 하나 이상이 지원되지 않습니다.

- 307 세션 설명 매개변수가 이해되지 않음: 위에 나열된 매개변수 이외의 매개변수를 이해하지 못했습니다.

- 330 멀티캐스트를 사용할 수 없음: 사용자가 위치한 사이트가 멀티캐스트를 지원하지 않습니다.

- 331 유니캐스트를 사용할 수 없음: 사용자가 위치한 사이트는 유니캐스트 통신을 지원하지 않습니다\(보통 방화벽이 있기 때문에\).

- 370 대역폭 부족: 세션 설명에 지정되거나 미디어에서 정의된 대역폭이 사용 가능한 것으로 알려진 대역폭을 초과합니다.

- 399 기타 경고: 경고 텍스트에는 인간 사용자에게 표시되거나 기록될 임의의 정보가 포함될 수 있습니다. 이 경고를 받은 시스템은 자동화된 조치를 취해서는 안 됩니다.\(MUST NOT\)

- 1xx 및 2xx는 HTTP/1.1에서 사용되었습니다.

추가 "경고 코드"는 섹션 27.2에 정의된 대로 IANA를 통해 정의할 수 있습니다.

```text
   Examples:

      Warning: 307 isi.edu "Session parameter 'foo' not understood"
      Warning: 301 isi.edu "Incompatible network address type 'E.164'"
```

---
## **20.44 WWW-Authenticate**

WWW-Authenticate 헤더 필드 값에는 인증 문제가 포함되어 있습니다. 사용법에 대한 자세한 내용은 섹션 22.2를 참조하세요.

```text
   Example:

      WWW-Authenticate: Digest realm="atlanta.com",
        domain="sip:boxesbybob.com", qop="auth",
        nonce="f84f1cec41e6cbe5aea9c8e88d359",
        opaque="", stale=FALSE, algorithm=MD5
```

---
# **21 Response Codes**

응답 코드는 HTTP/1.1 응답 코드와 일치하고 확장됩니다. 모든 HTTP/1.1 응답 코드가 적절한 것은 아니며 여기에는 적절한 코드만 제공됩니다. 다른 HTTP/1.1 응답 코드는 사용하면 안 됩니다. 또한 SIP는 새로운 클래스인 6xx를 정의합니다.\(SHOULD NOT\)

---
## **21.1 Provisional 1xx**

정보 응답이라고도 알려진 임시 응답은 연결된 서버가 추가 작업을 수행 중이지만 아직 최종 응답이 없음을 나타냅니다. 서버는 최종 응답을 얻는 데 200ms 이상이 걸릴 것으로 예상되는 경우 1xx 응답을 보냅니다. 1xx 응답은 안정적으로 전송되지 않습니다. 클라이언트가 ACK를 보내도록 하지 않습니다. 임시\(1xx\) 응답에는 세션 설명을 포함한 메시지 본문이 포함될 수 있습니다.\(MAY\)

---
### **21.1.1 100 Trying**

이 응답은 다음 홉 서버가 요청을 수신했으며 이 호출을 대신하여 지정되지 않은 일부 작업이 수행되고 있음을 나타냅니다\(예: 데이터베이스를 참조하는 중\). 다른 모든 임시 응답과 마찬가지로 이 응답은 UAC에 의한 INVITE 재전송을 중지합니다. 100\(시도 중\) 응답은 상태 저장 프록시에 의해 업스트림으로 전달되지 않는다는 점에서 다른 임시 응답과 다릅니다.

---
### **21.1.2 180 Ringing**

INVITE를 수신한 UA가 사용자에게 경고를 시도하고 있습니다. 이 응답은 로컬 링백을 시작하는 데 사용될 수 있습니다.\(MAY\)

---
### **21.1.3 181 Call Is Being Forwarded**

서버는 이 상태 코드를 사용하여 통화가 다른 대상 집합으로 전달되고 있음을 나타낼 수 있습니다.\(MAY\)

---
### **21.1.4 182 Queued**

수신자를 일시적으로 사용할 수 없지만 서버가 통화를 거부하지 않고 대기열에 넣기로 결정했습니다. 호출 수신자가 사용 가능해지면 적절한 최종 상태 응답을 반환합니다. 이유 문구는 통화 상태에 대한 추가 세부정보를 제공할 수 있습니다\(예: "5개의 통화가 대기 중입니다. 예상 대기 시간은 15분입니다"\). 서버는 대기 중인 통화 상태에 대해 호출자에게 업데이트하기 위해 여러 개의 182\(대기 중\) 응답을 발행할 수 있습니다.\(MAY, MAY\)

---
### **21.1.5 183 Session Progress**

183\(세션 진행률\) 응답은 달리 분류되지 않은 통화 진행률에 대한 정보를 전달하는 데 사용됩니다. Reason-Phrase, 헤더 필드 또는 메시지 본문을 사용하여 통화 진행에 대한 자세한 내용을 전달할 수 있습니다.\(MAY\)

---
## **21.2 Successful 2xx**

요청이 성공했습니다.

---
### **21.2.1 200 OK**

요청이 성공했습니다. 응답과 함께 반환되는 정보는 요청에 사용된 방법에 따라 다릅니다.

---
## **21.3 Redirection 3xx**

3xx 응답은 사용자의 새 위치 또는 통화를 만족시킬 수 있는 대체 서비스에 대한 정보를 제공합니다.

---
### **21.3.1 300 Multiple Choices**

요청의 주소는 각각 고유한 특정 위치를 가진 여러 선택 사항으로 해석되며 사용자\(또는 UA\)는 선호하는 통신 끝점을 선택하고 요청을 해당 위치로 리디렉션할 수 있습니다.

응답에는 Accept 요청 헤더 필드에서 허용하는 경우 사용자 또는 UA가 가장 적절한 것을 선택할 수 있는 리소스 특성 및 위치 목록이 포함된 메시지 본문이 포함될 수 있습니다. 그러나 이 메시지 본문에 대해 정의된 MIME 유형이 없습니다.\(MAY\)

선택 사항은 연락처 필드로도 나열되어야 합니다\(섹션 20.10\). HTTP와 달리 SIP 응답에는 여러 연락처 필드 또는 연락처 필드의 주소 목록이 포함될 수 있습니다. UA는 자동 리디렉션을 위해 연락처 헤더 필드 값을 사용하거나 사용자에게 선택 사항을 확인하도록 요청할 수 있습니다. 그러나 본 사양에서는 이러한 자동 선택에 대한 어떠한 기준도 정의하지 않습니다.\(SHOULD, MAY, MAY\)

- 이 상태 응답은 수신자가 여러 다른 위치에 도달할 수 있고 서버가 요청을 프록시할 수 없거나 프록시하지 않기를 원하는 경우에 적합합니다.

---
### **21.3.2 301 Moved Permanently**

사용자는 요청-URI의 주소에서 더 이상 찾을 수 없으며 요청 클라이언트는 연락처 헤더 필드\(섹션 20.10\)에 제공된 새 주소에서 다시 시도해야 합니다. 요청자는 모든 로컬 디렉터리, 주소록, 사용자 위치 캐시를 이 새로운 값으로 업데이트하고 향후 요청을 나열된 주소로 리디렉션해야 합니다.\(SHOULD, SHOULD\)

---
### **21.3.3 302 Moved Temporarily**

요청 클라이언트는 연락처 헤더 필드\(섹션 20.10\)에 의해 제공된 새 주소에서 요청을 재시도해야 합니다. 새 요청의 Request-URI는 응답의 Contact 헤더 필드 값을 사용합니다.\(SHOULD\)

연락처 URI의 유효 기간은 Expires\(섹션 20.19\) 헤더 필드 또는 연락처 헤더 필드의 만료 매개변수를 통해 표시될 수 있습니다. 프록시와 UA 모두 만료 시간 동안 이 URI를 캐시할 수 있습니다. 명시적인 만료 시간이 없는 경우 주소는 반복에 대해 한 번만 유효하며 향후 트랜잭션을 위해 캐시되어서는 안 됩니다.\(MAY, MUST NOT\)

연락처 헤더 필드에서 캐시된 URI가 실패하면 리디렉션된 요청의 Request-URI가 한 번 다시 시도될 수 있습니다.\(MAY\)

- 임시 URI가 만료 시간보다 빨리 만료되어 새로운 임시 URI가 사용 가능할 수 있습니다.

---
### **21.3.4 305 Use Proxy**

요청된 리소스는 연락처 필드에 제공된 프록시를 통해 액세스되어야 합니다. 연락처 필드는 프록시의 URI를 제공합니다. 수신자는 프록시를 통해 이 단일 요청을 반복해야 합니다. 305\(프록시 사용\) 응답은 UAS에 의해서만 생성되어야 합니다.\(MUST, MUST\)

---
### **21.3.5 380 Alternative Service**

통화가 실패했지만 대체 서비스는 가능합니다.

대체 서비스는 응답의 메시지 본문에 설명되어 있습니다. 이러한 본문의 형식은 여기에 정의되어 있지 않으며 향후 표준화의 대상이 될 수 있습니다.

---
## **21.4 Request Failure 4xx**

4xx 응답은 특정 서버의 확실한 실패 응답입니다. 클라이언트는 수정\(예: 적절한 인증 추가\) 없이 동일한 요청을 재시도해서는 안 됩니다. 그러나 다른 서버에 대한 동일한 요청이 성공할 수도 있습니다.\(SHOULD NOT\)

---
### **21.4.1 400 Bad Request**

잘못된 구문으로 인해 요청을 이해할 수 없습니다. Reason-Phrase는 "Missing Call-ID 헤더 필드"와 같이 구문 문제를 더 자세히 식별해야 합니다.\(SHOULD\)

---
### **21.4.2 401 Unauthorized**

요청에는 사용자 인증이 필요합니다. 이 응답은 UAS 및 등록 기관에서 발행되는 반면 407\(프록시 인증 필요\)은 프록시 서버에서 사용됩니다.

---
### **21.4.3 402 Payment Required**

향후 사용을 위해 예약되었습니다.

---
### **21.4.4 403 Forbidden**

서버가 요청을 이해했지만 이행을 거부하고 있습니다. 승인은 도움이 되지 않으며 요청을 반복해서는 안 됩니다.\(SHOULD NOT\)

---
### **21.4.5 404 Not Found**

서버에는 요청-URI에 지정된 도메인에 사용자가 존재하지 않는다는 최종 정보가 있습니다. 요청-URI의 도메인이 요청 수신자가 처리한 도메인과 일치하지 않는 경우에도 이 상태가 반환됩니다.

---
### **21.4.6 405 Method Not Allowed**

요청 라인에 지정된 방법은 이해되지만 요청-URI에 의해 식별된 주소에는 허용되지 않습니다.

응답에는 표시된 주소에 대한 유효한 방법 목록이 포함된 Allow 헤더 필드가 포함되어야 합니다.\(MUST\)

---
### **21.4.7 406 Not Acceptable**

요청에 의해 식별된 리소스는 요청에 전송된 Accept 헤더 필드에 따라 허용되지 않는 콘텐츠 특성을 가진 응답 엔터티만 생성할 수 있습니다.

---
### **21.4.8 407 Proxy Authentication Required**

이 코드는 401\(인증되지 않음\)과 유사하지만 클라이언트가 먼저 프록시를 통해 자신을 인증해야 함을 나타냅니다. SIP 액세스 인증은 섹션 26 및 22.3에 설명되어 있습니다.\(MUST\)

이 상태 코드는 수신자가 아닌 통신 채널\(예: 전화 게이트웨이\)에 액세스하려면 인증이 필요한 애플리케이션에 사용할 수 있습니다.

---
### **21.4.9 408 Request Timeout**

서버는 적절한 시간 내에 응답을 생성할 수 없습니다. 예를 들어 사용자의 위치를 ​​제 시간에 확인할 수 없는 경우입니다. 클라이언트는 나중에 수정 없이 요청을 반복할 수 있습니다.\(MAY\)

---
### **21.4.10 410 Gone**

요청한 리소스는 더 이상 서버에서 사용할 수 없으며 전달 주소도 알려져 있지 않습니다. 이 상태는 영구적인 것으로 간주될 것으로 예상됩니다. 서버가 조건이 영구적인지 여부를 알 수 없거나 결정할 수 있는 기능이 없는 경우 상태 코드 404\(찾을 수 없음\)를 대신 사용해야 합니다.\(SHOULD\)

---
### **21.4.11 413 Request Entity Too Large**

요청 엔터티 본문이 서버가 처리할 의사가 있거나 처리할 수 있는 것보다 크기 때문에 서버가 요청 처리를 거부하고 있습니다. 서버는 클라이언트가 요청을 계속하는 것을 방지하기 위해 연결을 닫을 수 있습니다.\(MAY\)

조건이 일시적인 경우 서버는 그것이 일시적임을 나타내고 클라이언트가 몇 시간 후에 다시 시도할 수 있는지를 나타내기 위해 Retry-After 헤더 필드를 포함해야 합니다.\(SHOULD\)

---
### **21.4.12 414 Request-URI Too Long**

요청-URI가 서버가 해석할 수 있는 것보다 길기 때문에 서버가 요청 서비스를 거부하고 있습니다.

---
### **21.4.13 415 Unsupported Media Type**

요청의 메시지 본문이 요청된 메서드에 대해 서버에서 지원하지 않는 형식이기 때문에 서버가 요청 서비스를 거부하고 있습니다. 서버는 콘텐츠의 특정 문제에 따라 Accept, Accept-Encoding 또는 Accept-Language 헤더 필드를 사용하여 허용 가능한 형식 목록을 반환해야 합니다. 이 응답의 UAC 처리는 섹션 8.1.3.5에 설명되어 있습니다.\(MUST\)

---
### **21.4.14 416 Unsupported URI Scheme**

Request-URI의 URI 체계를 서버가 알 수 없기 때문에 서버가 요청을 처리할 수 없습니다. 이 응답의 클라이언트 처리는 섹션 8.1.3.5에 설명되어 있습니다.

---
### **21.4.15 420 Bad Extension**

서버가 Proxy-Require\(섹션 20.29\) 또는 Require\(섹션 20.32\) 헤더 필드에 지정된 프로토콜 확장을 이해하지 못했습니다. 서버는 응답의 지원되지 않는 헤더 필드에 지원되지 않는 확장 목록을 포함해야 합니다. 이 응답의 UAC 처리는 섹션 8.1.3.5에 설명되어 있습니다.\(MUST\)

---
### **21.4.16 421 Extension Required**

UAS는 요청을 처리하기 위해 특정 확장이 필요하지만 이 확장은 요청의 지원되는 헤더 필드에 나열되지 않습니다. 이 상태 코드가 포함된 응답에는 필수 확장을 나열하는 Require 헤더 필드가 포함되어야 합니다.\(MUST\)

UAS는 실제로 클라이언트에게 유용한 서비스를 제공할 수 없는 경우가 아니면 이 응답을 사용해서는 안 됩니다. 대신, 원하는 확장이 지원 헤더 필드에 나열되지 않은 경우 서버는 기본 SIP 기능과 클라이언트가 지원하는 모든 확장을 사용하여 요청을 처리해야 합니다.\(SHOULD NOT, SHOULD\)

---
### **21.4.17 423 Interval Too Brief**

요청에 의해 새로 고쳐진 리소스의 만료 시간이 너무 짧기 때문에 서버가 요청을 거부하고 있습니다. 이 응답은 등록자가 연락처 헤더 필드 만료 시간이 너무 짧은 등록을 거부하는 데 사용될 수 있습니다. 이 응답 및 관련 Min-Expires 헤더 필드의 사용은 섹션 10.2.8, 10.3 및 20.23에 설명되어 있습니다.

---
### **21.4.18 480 Temporarily Unavailable**

수신자의 최종 시스템에 성공적으로 연결되었지만 수신자를 현재 사용할 수 없습니다\(예: 로그인하지 않았거나 로그인했지만 수신자와 통신할 수 없는 상태이거나 "방해 금지" 기능을 활성화했습니다\). 응답은 Retry-After 헤더 필드에서 호출하기에 더 좋은 시간을 나타낼 수 있습니다. 사용자는 다른 곳에서도 사용할 수 있습니다\(이 서버에 알려지지 않음\). 이유 문구는 수신자를 사용할 수 없는 이유에 대한 보다 정확한 원인을 나타내야 합니다. 이 값은 UA에 의해 설정 가능해야 합니다\(SHOULD\). 상태 486\(Busy Here\)은 통화 실패의 특정 이유를 보다 정확하게 표시하는 데 사용될 수 있습니다.\(MAY, SHOULD, SHOULD, MAY\)

이 상태는 요청-URI로 식별된 사용자를 인식하지만 현재 해당 사용자에 대한 유효한 전달 위치가 없는 리디렉션 또는 프록시 서버에 의해 반환됩니다.

---
### **21.4.19 481 Call/Transaction Does Not Exist**

이 상태는 UAS가 기존 대화 또는 트랜잭션과 일치하지 않는 요청을 수신했음을 나타냅니다.

---
### **21.4.20 482 Loop Detected**

서버가 루프를 감지했습니다\(16.3절 항목 4\).

---
### **21.4.21 483 Too Many Hops**

서버는 값이 0인 Max-Forwards\(섹션 20.22\) 헤더 필드가 포함된 요청을 받았습니다.

---
### **21.4.22 484 Address Incomplete**

서버가 불완전한 Request-URI가 포함된 요청을 받았습니다. 이유 문구에 추가 정보를 제공해야 합니다.\(SHOULD\)

- 이 상태 코드는 중복 다이얼링을 허용합니다. 중복 다이얼링을 사용하면 클라이언트는 다이얼링 문자열의 길이를 알 수 없습니다. 더 이상 484\(주소 불완전\) 상태 응답을 수신하지 않을 때까지 사용자에게 더 많은 입력을 요청하는 길이가 늘어나는 문자열을 보냅니다.

---
### **21.4.23 485 Ambiguous**

요청-URI가 모호했습니다. 응답에는 연락처 헤더 필드에 가능한 명확한 주소 목록이 포함될 수 있습니다. 대안을 공개하는 것은 사용자나 조직의 개인정보를 침해할 수 있습니다. 상태 404\(찾을 수 없음\)로 응답하거나 모호한 요청-URI에 대해 가능한 선택 목록을 억제하도록 서버를 구성하는 것이 가능해야 합니다\(MUST\).\(MAY, MUST\)

Request-URI sip:lee@example.com을 사용한 요청에 대한 응답 예:

```text
      SIP/2.0 485 Ambiguous
      Contact: Carol Lee <sip:carol.lee@example.com>
      Contact: Ping Lee <sip:p.lee@example.com>
      Contact: Lee M. Foote <sips:lee.foote@example.com>
```

- 일부 이메일 및 음성 메일 시스템은 이 기능을 제공합니다. 의미가 다르기 때문에 3xx와 별도의 상태 코드가 사용됩니다. 300의 경우 제공된 선택 사항에 의해 동일한 사람이나 서비스에 도달한다고 가정합니다. 3xx 응답에는 자동 선택 또는 순차 검색이 적합하지만 485\(모호함\) 응답에는 사용자 개입이 필요합니다.

---
### **21.4.24 486 Busy Here**

수신자의 최종 시스템에 성공적으로 연결되었지만 현재 수신자는 이 최종 시스템에서 추가 통화를 받을 의향이 없거나 수신할 수 없습니다. 응답은 Retry-After 헤더 필드에서 호출하기에 더 좋은 시간을 나타낼 수 있습니다. 사용자도 사용할 수 있습니다\(MAY\)

음성 메일 서비스 등을 통해 다른 곳에서. 클라이언트가 다른 최종 시스템이 이 호출을 수락할 수 없다는 것을 알고 있는 경우 상태 600\(Busy Everywhere\)을 사용해야 합니다.\(SHOULD\)

---
### **21.4.25 487 Request Terminated**

요청이 BYE 또는 CANCEL 요청으로 종료되었습니다. CANCEL 요청 자체에 대해서는 이 응답이 반환되지 않습니다.

---
### **21.4.26 488 Not Acceptable Here**

응답은 606\(허용되지 않음\)과 동일한 의미를 갖지만 요청-URI에 의해 지정된 특정 리소스에만 적용되며 요청은 다른 곳에서 성공할 수 있습니다.

미디어 기능에 대한 설명이 포함된 메시지 본문이 응답에 존재할 수 있습니다. 이는 INVITE\(또는 존재하지 않는 경우 애플리케이션/sdp\)의 Accept 헤더 필드에 따라 형식이 지정되며 200\(OK\)의 메시지 본문과 동일합니다. OPTIONS 요청에 대한 응답입니다.\(MAY\)

---
### **21.4.27 491 Request Pending**

동일한 대화 상자 내에 보류 중인 요청이 있는 UAS가 요청을 받았습니다. 섹션 14.2에서는 이러한 "눈부심" 상황을 해결하는 방법을 설명합니다.

---
### **21.4.28 493 Undecipherable**

수신자가 적절한 암호 해독 키를 소유하지 않거나 제공하지 않는 암호화된 MIME 본문이 포함된 UAS가 요청을 받았습니다. 이 응답에는 이 UA로 전송된 MIME 본문을 암호화하는 데 사용해야 하는 적절한 공개 키가 포함된 단일 본문이 있을 수 있습니다. 이 응답 코드의 자세한 사용법은 23.2절에서 확인할 수 있습니다.\(MAY\)

---
## **21.5 Server Failure 5xx**

5xx 응답은 서버 자체에 오류가 발생한 경우 제공되는 실패 응답입니다.

---
### **21.5.1 500 Server Internal Error**

서버에서 요청을 이행하지 못하게 하는 예상치 못한 상황이 발생했습니다. 클라이언트는 특정 오류 조건을 표시하고 몇 초 후에 요청을 다시 시도할 수 있습니다.\(MAY\)

조건이 일시적인 경우 서버는 클라이언트가 Retry-After 헤더 필드를 사용하여 요청을 재시도할 수 있는 시기를 나타낼 수 있습니다.\(MAY\)

---
### **21.5.2 501 Not Implemented**

서버가 요청을 이행하는 데 필요한 기능을 지원하지 않습니다. 이는 UAS가 요청 방법을 인식하지 못하고 어떤 사용자에게도 이를 지원할 수 없는 경우 적절한 응답입니다. \(프록시는 방법에 관계없이 모든 요청을 전달합니다.\)

서버가 요청 방법을 인식하지만 해당 방법이 허용되거나 지원되지 않으면 405\(Method Not Allowed\)가 전송됩니다.

---
### **21.5.3 502 Bad Gateway**

서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 이행하려고 시도하는 동안 액세스한 다운스트림 서버로부터 잘못된 응답을 받았습니다.

---
### **21.5.4 503 Service Unavailable**

일시적인 과부하 또는 서버 점검으로 인해 서버가 일시적으로 요청을 처리할 수 없습니다. 서버는 클라이언트가 Retry-After 헤더 필드에서 요청을 재시도해야 하는 시기를 나타낼 수 있습니다. Retry-After가 제공되지 않으면 클라이언트는 500\(서버 내부 오류\) 응답을 받은 것처럼 행동해야 합니다.\(MAY, MUST\)

503\(서비스를 사용할 수 없음\)을 수신한 클라이언트\(프록시 또는 UAC\)는 요청을 대체 서버로 전달하려고 시도해야 합니다. Retry-After 헤더 필드\(있는 경우\)에 지정된 기간 동안 해당 서버에 다른 요청을 전달해서는 안 됩니다.\(SHOULD, SHOULD NOT\)

서버는 503\(서비스를 사용할 수 없음\)으로 응답하는 대신 연결을 거부하거나 요청을 삭제할 수 있습니다.\(MAY\)

---
### **21.5.5 504 Server Time-out**

서버가 요청 처리를 시도하는 동안 액세스한 외부 서버로부터 적시에 응답을 받지 못했습니다. 업스트림 서버에서 Expires 헤더 필드에 지정된 기간 내에 응답이 없는 경우 408\(Request Timeout\)을 대신 사용해야 합니다.

---
### **21.5.6 505 Version Not Supported**

서버가 요청에 사용된 SIP 프로토콜 버전을 지원하지 않거나 지원을 거부합니다. 서버는 이 오류 메시지 외에는 클라이언트와 동일한 주요 버전을 사용하여 요청을 완료할 수 없거나 완료할 의사가 없음을 나타냅니다.

---
### **21.5.7 513 Message Too Large**

메시지 길이가 용량을 초과했기 때문에 서버가 요청을 처리할 수 없습니다.

---
## **21.6 Global Failures 6xx**

6xx 응답은 서버가 Request-URI에 표시된 특정 인스턴스뿐만 아니라 특정 사용자에 대한 최종 정보를 가지고 있음을 나타냅니다.

---
### **21.6.1 600 Busy Everywhere**

수신자의 최종 시스템에 성공적으로 연결되었지만 수신자가 통화 중이어서 지금은 전화를 받고 싶지 않습니다. 응답은 Retry-After 헤더 필드에서 호출하기에 더 좋은 시간을 나타낼 수 있습니다. 수신자가 통화 거부 이유를 공개하고 싶지 않은 경우 수신자는 대신 상태 코드 603\(거절\)을 사용합니다. 이 상태 응답은 다른 끝점\(예: 음성 메일 시스템\)이 요청에 응답하지 않는다는 것을 클라이언트가 알고 있는 경우에만 반환됩니다. 그렇지 않으면 486\(Busy Here\)이 반환되어야 합니다.\(MAY\)

---
### **21.6.2 603 Decline**

수신자의 컴퓨터에 성공적으로 연결되었지만 사용자가 명시적으로 참여를 원하지 않거나 참여할 수 없습니다. 응답은 Retry-After 헤더 필드에서 호출하기에 더 좋은 시간을 나타낼 수 있습니다. 이 상태 응답은 다른 엔드포인트가 요청에 응답하지 않는다는 것을 클라이언트가 알고 있는 경우에만 반환됩니다.\(MAY\)

---
### **21.6.3 604 Does Not Exist Anywhere**

서버에는 Request-URI에 표시된 사용자가 어디에도 존재하지 않는다는 신뢰할 수 있는 정보가 있습니다.

---
### **21.6.4 606 Not Acceptable**

사용자 에이전트에 성공적으로 연결되었지만 요청한 미디어, 대역폭 또는 주소 지정 스타일과 같은 세션 설명의 일부 측면이 허용되지 않습니다.

606\(허용되지 않음\) 응답은 사용자가 통신을 원하지만 설명된 세션을 적절하게 지원할 수 없음을 의미합니다. 606\(허용되지 않음\) 응답은 설명된 세션을 지원할 수 없는 이유를 설명하는 경고 헤더 필드에 이유 목록을 포함할 수 있습니다. 경고 이유 코드는 섹션 20.43에 나열되어 있습니다.\(MAY\)

미디어 기능에 대한 설명이 포함된 메시지 본문이 응답에 존재할 수 있습니다. 이는 INVITE\(또는 존재하지 않는 경우 애플리케이션/sdp\)의 Accept 헤더 필드에 따라 형식이 지정되며 200\(OK\)의 메시지 본문과 동일합니다. OPTIONS 요청에 대한 응답입니다.\(MAY\)

협상이 자주 필요하지 않기를 바라며, 기존 회의에 새로운 사용자를 초대하는 경우 협상이 불가능할 수도 있습니다. 606\(허용되지 않음\) 응답에 대한 조치를 취할지 여부를 결정하는 것은 초대 개시자에게 달려 있습니다.

이 상태 응답은 다른 엔드포인트가 요청에 응답하지 않는다는 것을 클라이언트가 알고 있는 경우에만 반환됩니다.

---
# **22 Usage of HTTP Authentication**

SIP는 HTTP 인증을 기반으로 하는 인증을 위한 상태 비저장, 챌린지 기반 메커니즘을 제공합니다. 프록시 서버 또는 UA가 요청을 수신할 때마다\(섹션 22.1에 제공된 예외 제외\) 요청 개시자에게 해당 신원을 보장하도록 요구할 수 있습니다. 발신자가 식별되면 요청 수신자는 이 사용자가 문제의 요청을 할 권한이 있는지 여부를 확인해야 합니다. 이 문서에서는 인증 시스템을 권장하거나 논의하지 않습니다.\(MAY, SHOULD\)

이 섹션에 설명된 "다이제스트" 인증 메커니즘은 메시지 무결성이나 기밀성 없이 메시지 인증 및 재생 보호만 제공합니다. 적극적인 공격자가 SIP 요청 및 응답을 수정하는 것을 방지하려면 다이제스트에서 제공하는 것 이상의 보호 조치를 취해야 합니다.

보안이 취약하기 때문에 "기본" 인증 사용은 더 이상 사용되지 않습니다. 서버는 "기본" 권한 부여 체계를 사용하여 자격 증명을 수락해서는 안 되며, 서버도 "기본"에 도전해서는 안 됩니다. 이는 RFC 2543의 변경 사항입니다.\(MUST NOT\)

---
## **22.1 Framework**

```text
   The framework for SIP authentication closely parallels that of HTTP
   (RFC 2617 [17]).  In particular, the BNF for auth-scheme, auth-param,
   challenge, realm, realm-value, and credentials is identical (although
   the usage of "Basic" as a scheme is not permitted).  In SIP, a UAS
   uses the 401 (Unauthorized) response to challenge the identity of a
   UAC.  Additionally, registrars and redirect servers MAY make use of
   401 (Unauthorized) responses for authentication, but proxies MUST
   NOT, and instead MAY use the 407 (Proxy Authentication Required)
```

응답. 다양한 메시지에 Proxy-Authenticate, Proxy-Authorization, WWW-Authenticate 및 Authorization을 포함하기 위한 요구 사항은 RFC 2617 \[17\]에 설명된 것과 동일합니다.

SIP에는 표준 루트 URL 개념이 없으므로 SIP에서는 보호 공간 개념이 다르게 해석됩니다. 영역 문자열만으로 보호 도메인을 정의합니다. 이는 요청-URI와 영역이 함께 보호 도메인을 정의하는 RFC 2543의 변경 사항입니다.

- 보호 도메인에 대한 이전 정의는 UAC가 보낸 Request-URI와 도전 서버가 받은 Request-URI가 다를 수 있고 실제로 Request-URI의 최종 형식을 알 수 없기 때문에 약간의 혼란을 야기했습니다. UAC. 또한 이전 정의는 요청-URI에 SIP URI가 있는지 여부에 따라 달라지며 대체 URI 체계\(예: 전화 URL\)를 배제하는 것처럼 보였습니다.

수신된 요청을 인증할 사용자 에이전트 또는 프록시 서버의 운영자는 서버에 대한 영역 문자열 생성에 대한 다음 지침을 준수해야 합니다.\(MUST\)

- o 영역 문자열은 전역적으로 고유해야 합니다. RFC 2617 \[17\] 섹션 3.2.1의 권장 사항에 따라 영역 문자열에 호스트 이름이나 도메인 이름을 포함하는 것이 좋습니다.\(MUST, SHOULD\)

- o 영역 문자열은 사용자에게 렌더링될 수 있고 사람이 읽을 수 있는 식별자를 제공해야 합니다.\(SHOULD\)

예를 들어:

```text
      INVITE sip:bob@biloxi.com SIP/2.0
      Authorization: Digest realm="biloxi.com", <...>
```

일반적으로 SIP 인증은 특정 영역, 즉 보호 도메인에 대해 의미가 있습니다. 따라서 다이제스트 인증의 경우 각 보호 도메인에는 고유한 사용자 이름 및 비밀번호 세트가 있습니다. 서버가 특정 요청에 대한 인증을 요구하지 않는 경우 비밀번호가 없는 기본 사용자 이름\(비밀번호 ""\)인 "anonymous"를 수락할 수 있습니다. 마찬가지로 PSTN 게이트웨이와 같이 많은 사용자를 대표하는 UAC는 해당 영역에 대해 특정 사용자의 계정이 아닌 자체 장치별 사용자 이름과 비밀번호를 가질 수 있습니다.\(MAY, MAY\)

서버는 대부분의 SIP 요청을 합법적으로 요청할 수 있지만 이 문서에서는 인증을 위해 특별한 처리가 필요한 두 가지 요청\(ACK 및 CANCEL\)이 정의되어 있습니다.

Nonce를 계산하는 데 사용되는 값\(예: 다이제스트\)을 전달하기 위해 응답을 사용하는 인증 체계에서는 ACK를 포함하여 응답을 받지 않는 요청에 대해 몇 가지 문제가 발생합니다. 이러한 이유로 서버에서 수락한 INVITE의 모든 자격 증명은 ACK에 대해 해당 서버에서 수락해야 합니다. ACK 메시지를 생성하는 UAC는 ACK가 해당하는 INVITE에 나타나는 Authorization 및 Proxy-Authorization 헤더 필드 값을 모두 복제합니다. 서버는 ACK에 도전하려고 시도해서는 안 됩니다.\(MUST, MUST NOT\)

CANCEL 메소드가 응답\(2xx\)을 받더라도 서버는 CANCEL 요청을 다시 제출할 수 없으므로 CANCEL 요청을 시도해서는 안 됩니다. 일반적으로 CANCEL 요청은 취소되는 요청을 보낸 동일한 홉에서 오는 경우 서버에서 수락해야 합니다\(섹션 26.2.1에 설명된 대로 일종의 전송 또는 네트워크 계층 보안 연결이 있는 경우\).\(MUST NOT, SHOULD\)

UAC가 챌린지를 수신하면 UAC 장치가 아직 알지 못하는 경우 챌린지의 "realm" 매개변수\(WWW-Authenticate 헤더 필드 또는 Proxy-Authenticate 헤더 필드에 표시됨\)의 내용을 사용자에게 렌더링해야 합니다. 해당 영역에 대한 자격 증명입니다. 해당 영역에 대한 자격 증명으로 UA를 사전 구성하는 서비스 공급자는 사용자가 사전 구성된 장치에서 질문을 받을 때 이 영역에 대한 자신의 자격 증명을 제시할 기회가 없다는 점을 알아야 합니다.\(SHOULD\)

마지막으로, UAC가 적절한 영역과 연결된 자격 증명을 찾을 수 있더라도 이러한 자격 증명이 더 이상 유효하지 않거나 문제의 서버가 어떤 이유로든\(특히 "익명"인 경우\) 이러한 자격 증명을 수락하지 않을 가능성이 존재합니다. 비밀번호가 제출되지 않았습니다\). 이 경우 서버는 챌린지를 반복하거나 403 Forbidden으로 응답할 수 있습니다. UAC는 방금 거부된 자격 증명으로 요청을 다시 시도해서는 안 됩니다\(단, nonce가 오래된 경우 요청을 다시 시도할 수 있음\).\(MUST NOT\)

---
## **22.2 User-to-User Authentication**

UAS가 UAC로부터 요청을 받으면 UAS는 요청이 처리되기 전에 발신자를 인증할 수 있습니다. 요청에 자격 증명\(Authorization 헤더 필드\)이 제공되지 않은 경우 UAS는 401\(Unauthorized\) 상태 코드와 함께 요청을 거부하여 보낸 사람에게 자격 증명을 제공하도록 요청할 수 있습니다.\(MAY\)

WWW-인증 응답 헤더 필드는 401\(인증되지 않음\) 응답 메시지에 포함되어야 합니다. 필드 값은 영역에 적용 가능한 인증 체계 및 매개 변수를 나타내는 하나 이상의 챌린지로 구성됩니다.\(MUST\)

401 챌린지의 WWW-Authenticate 헤더 필드의 예는 다음과 같습니다.

```text
      WWW-Authenticate: Digest
              realm="biloxi.com",
              qop="auth,auth-int",
              nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
              opaque="5ccc069c403ebaf9f0171e9517f40e41"
```

원본 UAC가 401\(인증되지 않음\)을 수신하면 가능하다면 적절한 자격 증명을 사용하여 요청을 다시 시작해야 합니다. UAC는 계속 진행하기 전에 원래 사용자의 입력을 요구할 수 있습니다. 인증 자격 증명이 제공되면\(사용자가 직접 또는 내부 키링에서 검색\), UA는 To 헤더 필드 및 "영역"의 지정된 값에 대한 자격 증명을 캐시하고 다음 번에 이 값을 재사용하려고 시도해야 합니다. 해당 목적지에 대한 요청입니다. UA는 원하는 방식으로 자격 증명을 캐시할 수 있습니다.\(SHOULD, SHOULD, MAY\)

영역에 대한 자격 증명을 찾을 수 없는 경우 UAC는 사용자 이름 "anonymous"와 비밀번호 없이\(비밀번호 ""\) 요청을 재시도할 수 있습니다.\(MAY\)

자격 증명을 찾으면 UAS 또는 등록 기관을 통해 자신을 인증하려는 UA는 일반적으로 401\(무단\) 응답을 받은 후 반드시 그런 것은 아니지만 요청에 Authorization 헤더 필드를 포함시켜 인증할 수 있습니다. Authorization 필드 값은 요청 중인 리소스 영역에 대한 UA의 인증 정보와 인증 및 재생 보호 지원에 필요한 매개변수가 포함된 자격 증명으로 구성됩니다.\(MAY\)

Authorization 헤더 필드의 예는 다음과 같습니다.

```text
      Authorization: Digest username="bob",
              realm="biloxi.com",
              nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
              uri="sip:bob@biloxi.com",
              qop=auth,
              nc=00000001,
              cnonce="0a4f113b",
              response="6629fae49393a05397450978507c4ef1",
              opaque="5ccc069c403ebaf9f0171e9517f40e41"
```

UAC가 401\(승인되지 않음\) 또는 407\(프록시 인증 필요\) 응답을 수신한 후 해당 자격 증명과 함께 요청을 다시 제출할 때 업데이트된 요청을 보낼 때 일반적으로 하는 것처럼 CSeq 헤더 필드 값을 증가시켜야 합니다.\(MUST\)

---
## **22.3 Proxy-to-User Authentication**

마찬가지로 UAC가 프록시 서버에 요청을 보낼 때 프록시 서버는 요청이 처리되기 전에 발신자를 인증할 수 있습니다. 요청에 자격 증명\(Proxy-Authorization 헤더 필드\)이 제공되지 않은 경우 프록시는 407\(프록시 인증 필요\) 상태 코드로 요청을 거부하여 보낸 사람에게 자격 증명을 제공하도록 요구할 수 있습니다. 프록시는 요청된 리소스에 대한 프록시에 적용 가능한 Proxy-Authenticate 헤더 필드 값으로 407\(프록시 인증 필요\) 메시지를 채워야 합니다.\(MAY, MUST\)

\[17\]에 설명된 프록시 인증 및 프록시 인증 병렬 사용에는 한 가지 차이점이 있습니다. 프록시는 Proxy-Authorization 헤더 필드에 값을 추가해서는 안 됩니다. 모든 407\(프록시 인증 필요\) 응답은 다른 응답에 대한 절차에 따라 UAC를 향해 업스트림으로 전달되어야 합니다. 인증을 요청한 프록시 영역에 대한 자격 증명이 포함된 Proxy-Authorization 헤더 필드 값을 추가하는 것은 UAC의 책임입니다.\(MUST NOT, MUST\)

- 프록시가 Proxy-Authorization 헤더 필드 값을 추가하여 요청을 다시 제출하는 경우 새 요청에서 CSeq를 증가시켜야 합니다. 그러나 이렇게 하면 원래 요청을 제출한 UAC가 CSeq 값이 다르기 때문에 UAS의 응답을 삭제하게 됩니다.

원본 UAC가 407\(프록시 인증 필요\)을 수신하면 가능하다면 적절한 자격 증명을 사용하여 요청을 다시 시작해야 합니다. 401에 응답하기 위해 위에 제공된 "영역" 매개변수 표시에 대해 동일한 절차를 따라야 합니다.\(SHOULD\)

영역에 대한 자격 증명을 찾을 수 없는 경우 UAC는 사용자 이름 "anonymous"와 비밀번호 없이\(비밀번호 ""\) 요청을 재시도할 수 있습니다.\(MAY\)

UAC는 또한 다시 시작된 요청에 사용된 자격 증명을 캐시해야 합니다.\(SHOULD\)

프록시 자격 증명 캐싱에는 다음 규칙을 권장합니다.\(SHOULD\)

UA가 특정 Call-ID가 있는 요청에 대한 401/407 응답에서 Proxy-Authenticate 헤더 필드 값을 수신하는 경우 동일한 Call-ID를 포함하는 모든 후속 요청에 해당 영역에 대한 자격 증명을 통합해야 합니다. 이러한 자격 증명은 대화 상자 전체에 걸쳐 캐시되어서는 안 됩니다. 그러나 UA가 로컬 아웃바운드 프록시 영역으로 구성된 경우\(존재하는 경우\) UA는 캐시할 수 있습니다.\(MUST NOT\)

대화 상자 전체에서 해당 영역에 대한 자격 증명입니다. 이는 대화 상자의 향후 요청에 경로 헤더 경로를 따라 프록시에 필요하지 않은 자격 증명이 포함될 수 있음을 의미합니다.

프록시 서버에 자신을 인증하려는 모든 UA는 일반적으로 407\(프록시 인증 필요\) 응답을 받은 후 요청에 Proxy-Authorization 헤더 필드 값을 포함하여 인증할 수 있습니다. Proxy-Authorization 요청 헤더 필드를 사용하면 클라이언트는 인증이 필요한 프록시에 대해 자신\(또는 해당 사용자\)을 식별할 수 있습니다. Proxy-Authorization 헤더 필드 값은 요청 중인 리소스의 프록시 및/또는 영역에 대한 UA의 인증 정보를 포함하는 자격 증명으로 구성됩니다.\(MAY\)

Proxy-Authorization 헤더 필드 값은 해당 영역이 "realm" 매개변수에서 식별되는 프록시에만 적용됩니다\(이 프록시는 이전에 Proxy-Authenticate 필드를 사용하여 인증을 요구했을 수 있습니다\). 여러 프록시가 체인에서 사용되는 경우 Proxy-Authorization 헤더 필드 값은 해당 값에 지정된 "영역" 매개변수와 영역이 일치하지 않는 프록시에서 사용되어서는 안 됩니다.\(MUST NOT\)

영역을 지원하지 않는 인증 체계가 Proxy-Authorization 헤더 필드에 사용되는 경우 프록시 서버는 모든 Proxy-Authorization 헤더 필드 값을 구문 분석하여 그 중 하나가 프록시 서버가 유효하다고 간주하는 값을 가지고 있는지 확인해야 합니다. 신임장. 이는 대규모 네트워크에서 잠재적으로 시간이 많이 소요되기 때문에 프록시 서버는 Proxy-Authorization 헤더 필드에서 영역을 지원하는 인증 체계를 사용해야 합니다.\(MUST, SHOULD\)

요청이 분기되면\(섹션 16.7에 설명된 대로\) 다양한 프록시 서버 및/또는 UA가 UAC에 도전할 수 있습니다. 이 경우 분기 프록시 서버는 이러한 문제를 단일 응답으로 집계하는 역할을 합니다. 분기된 요청에 대한 응답으로 수신된 각 WWW 인증 및 프록시 인증 값은 분기 프록시가 UA로 전송하는 단일 응답에 배치되어야 합니다. 이러한 헤더 필드 값의 순서는 중요하지 않습니다.\(MUST\)

- 프록시 서버가 요청에 대한 응답으로 챌린지를 발행하면 UAC가 유효한 자격 증명으로 요청을 다시 시도할 때까지 요청을 프록시하지 않습니다. 분기 프록시는 인증이 필요한 여러 프록시 서버에 동시에 요청을 전달할 수 있으며, 각 프록시 서버는 원래 UAC가 해당 영역에서 인증될 때까지 요청을 전달하지 않습니다. UAC가 다음에 대한 자격 증명을 제공하지 않는 경우

- 각 챌린지에서 챌린지를 발행한 프록시 서버는 대상 사용자가 있을 수 있는 UA에 요청을 전달하지 않으므로 분기의 장점이 대부분 손실됩니다.

여러 질문이 포함된 401\(인증되지 않음\) 또는 407\(프록시 인증 필요\)에 대한 응답으로 요청을 다시 제출할 때 UAC는 각 WWW-인증 값에 대한 Authorization 값과 각 Proxy-Authenticate 값에 대한 Proxy-Authorization 값을 포함할 수 있습니다. UAC가 자격 증명을 제공하려고 합니다. 위에서 언급한 것처럼 요청의 여러 자격 증명은 "realm" 매개변수로 구별되어야 합니다.\(MAY, SHOULD\)

동일한 영역과 관련된 여러 질문이 동일한 401\(권한 없음\) 또는 407\(프록시 인증 필요\)에 나타날 수 있습니다. 예를 들어, 공통 영역을 사용하는 동일한 관리 도메인 내의 여러 프록시가 분기 요청에 의해 도달할 때 이런 일이 발생할 수 있습니다. 따라서 요청을 재시도할 때 UAC는 동일한 "영역" 매개변수 값을 사용하여 Authorization 또는 Proxy-Authorization 헤더 필드에 여러 자격 증명을 제공할 수 있습니다. 동일한 영역에 대해 동일한 자격 증명을 사용해야 합니다.\(MAY, SHOULD\)

---
## **22.4 The Digest Authentication Scheme**

이 섹션에서는 HTTP Digest 인증 체계를 SIP에 적용하는 데 필요한 수정 사항과 설명을 설명합니다. SIP 체계 사용법은 HTTP \[17\]와 거의 완전히 동일합니다.

RFC 2543은 RFC 2069 \[39\]에 정의된 HTTP 다이제스트를 기반으로 하기 때문에 RFC 2617을 지원하는 SIP 서버는 RFC 2069와 역호환성을 보장해야 합니다. 이 역호환성을 위한 절차는 RFC 2617에 지정되어 있습니다. 기본 인증을 수락하거나 요청해서는 안 됩니다.\(MUST, MUST NOT\)

다이제스트 인증 규칙은 \[17\]에 정의된 규칙을 따르며 "HTTP/1.1"은 "SIP/2.0"으로 대체되며 다음 차이점도 있습니다.

- 1. 챌린지에 포함된 URI에는 다음과 같은 BNF가 있습니다.

```text
          URI  =  SIP-URI / SIPS-URI
```

- 2. RFC 2617의 BNF에는 HTTP Digest에 대한 Authorization 헤더 필드의 'uri' 매개변수에 오류가 있습니다.

- 인증은 따옴표로 묶지 않습니다. \(RFC 2617의 섹션 3.5에 있는 예는 정확합니다.\) SIP의 경우 'uri'는 따옴표로 묶어야 합니다.\(MUST\)

- 3. 다이제스트-우리-값의 BNF는 다음과 같습니다.

```text
          digest-uri-value  =  Request-URI ; as defined in Section 25
```

- 4. Etag를 기반으로 nonce를 선택하는 예제 절차는 SIP에서 작동하지 않습니다.

- 5. 캐시 동작에 관한 RFC 2617 \[17\]의 내용은 SIP에는 적용되지 않습니다.

- 6. RFC 2617 \[17\]에서는 서버가 요청 라인의 URI와 Authorization 헤더 필드에 포함된 URI가 동일한 리소스를 가리키는지 확인하도록 요구합니다. SIP 컨텍스트에서 이러한 두 URI는 일부 프록시에서의 전달로 인해 서로 다른 사용자를 참조할 수 있습니다. 따라서 SIP에서 서버는 Authorization 헤더 필드 값의 Request-URI가 서버가 전달 또는 직접 요청을 수락하려는 사용자에 해당하는지 확인할 수 있지만 두 필드가 그렇지 않은 경우 반드시 실패는 아닙니다. 동등한.\(MAY\)

- 7. 다이제스트 인증 방식에서 메시지 무결성 보증을 위한 A2 값 계산을 명확히 하기 위해 구현자는 엔터티 본문이 비어 있을 때\(즉, SIP 메시지에 본문이 없을 때\) 엔터티 본문의 해시를 가정해야 합니다. 엔터티-본문은 빈 문자열의 MD5 해시로 확인됩니다. 또는:

```text
             H(entity-body) = MD5("") =
          "d41d8cd98f00b204e9800998ecf8427e"
```

- 8. RFC 2617에서는 qop 지시문이 전송되지 않은 경우 승인\(및 확장 프록시 인증\) 헤더 필드에 connonce 값을 전송해서는 안 된다고 명시합니다. 따라서 connonce\("MD5-Sess" 포함\)에 종속된 모든 알고리즘에서는 qop 지시문을 보내야 합니다. RFC 2069와의 하위 호환성을 위해 RFC 2617에서는 "qop" 매개변수 사용이 선택 사항입니다. RFC 2543은 RFC 2069를 기반으로 했기 때문에 불행하게도 "qop" 매개변수는 클라이언트와 서버가 수신할 수 있도록 선택 사항으로 남아 있어야 합니다. 그러나 서버는 항상 WWW-Authenticate 및 Proxy-Authenticate 헤더 필드 값에 "qop" 매개변수를 보내야 합니다. 클라이언트가 챌린지 헤더 필드에서 "qop" 매개변수를 수신하는 경우 결과 인증 헤더 필드에서 "qop" 매개변수를 전송해야 합니다.\(MUST NOT, MUST, MUST\)

RFC 2543은 인증 정보 헤더 필드의 사용을 허용하지 않았습니다\(RFC 2069를 효과적으로 사용함\). 그러나 이제 이 헤더 필드는 본문에 대한 무결성 검사를 제공하고 상호 인증을 제공하므로 사용을 허용합니다. RFC 2617 \[17\]은 요청의 qop 속성을 사용하여 이전 버전과의 호환성을 위한 메커니즘을 정의합니다. 이러한 메커니즘은 클라이언트가 RFC 2069에 지정되지 않은 RFC 2617의 새로운 메커니즘을 지원하는지 확인하기 위해 서버에서 사용해야 합니다.\(MUST\)

---
# **23 S/MIME**

SIP 메시지는 MIME 본문을 전달하며 MIME 표준에는 무결성과 기밀성을 모두 보장하기 위해 MIME 콘텐츠를 보호하는 메커니즘이 포함되어 있습니다\('multipart/signed' 및 'application/pkcs7-mime' MIME 유형 포함, RFC 1847 \[22\], RFC 2630 \[ 참조\). 23\] 및 RFC 2633 \[24\]\). 그러나 구현자는 SIP 메시지\(특히 SDP\)의 본문을 보거나 수정하는 데 의존하는 네트워크 중개자\(일반적인 프록시 서버 아님\)가 드물며 보안 MIME으로 인해 이러한 종류의 중개자가 작동하지 않을 수 있다는 점에 유의해야 합니다.

- 이는 특히 특정 유형의 방화벽에 적용됩니다.

- RFC 2543에 설명된 SIP 메시지의 헤더 필드와 본문을 암호화하기 위한 PGP 메커니즘은 더 이상 사용되지 않습니다.

---
## **23.1 S/MIME Certificates**

S/MIME 목적으로 최종 사용자를 식별하는 데 사용되는 인증서는 한 가지 중요한 측면에서 서버에서 사용되는 인증서와 다릅니다. 즉, 소유자의 신원이 특정 호스트 이름에 해당한다고 주장하기보다는 이러한 인증서는 소유자가 최종 사용자 주소로 식별됩니다. 이 주소는 SIP 또는 SIPS URI\(즉, "bob@biloxi.com" 형식의 이메일 주소\)의 "userinfo" "@" 및 "domainname" 부분의 연결로 구성되며, 가장 일반적으로 다음과 같습니다. 사용자의 기록 주소.

이러한 인증서는 SIP 메시지 본문을 서명하거나 암호화하는 데 사용되는 키와도 연결됩니다. 본문은 보낸 사람\(적절하게 메시지에 공개 키를 포함할 수 있음\)의 개인 키로 서명되지만 본문은 의도된 수신자의 공개 키로 암호화됩니다. 분명히 메시지 본문을 암호화하려면 보낸 사람이 받는 사람의 공개 키를 미리 알고 있어야 합니다. 공개 키는 가상 키링의 UA 내에 저장될 수 있습니다.

S/MIME을 지원하는 각 사용자 에이전트에는 최종 사용자 인증서를 위한 키링이 반드시 포함되어야 합니다. 이 키링은 기록 주소와 해당 인증서 간에 매핑되어야 합니다. 시간이 지남에 따라 사용자는 동일한 레코드 주소로 신호의 원래 URI\(From 헤더 필드\)를 채울 때 동일한 인증서를 사용해야 합니다.\(MUST, SHOULD\)

최종 사용자 인증서의 존재에 따른 모든 메커니즘은 오늘날 최종 사용자 애플리케이션에 인증서를 제공하는 통합 기관이 사실상 없다는 점에서 심각하게 제한됩니다. 그러나 사용자는 알려진 공용 인증 기관으로부터 인증서를 취득해야 합니다. 대안으로 사용자는 자체 서명된 인증서를 생성할 수 있습니다. 자체 서명된 인증서의 의미는 섹션 26.4.2에서 자세히 살펴봅니다. 구현에서는 모든 SIP 엔터티 간에 이전 신뢰 관계가 존재하는 배포에서 사전 구성된 인증서를 사용할 수도 있습니다.\(SHOULD, MAY\)

최종 사용자 인증서를 획득하는 문제 외에도 최종 사용자 인증서를 배포하는 잘 알려진 중앙 집중식 디렉터리는 거의 없습니다. 그러나 인증서 보유자는 적절한 공개 디렉터리에 인증서를 게시해야 합니다. 마찬가지로 UAC는 SIP 요청의 대상 URI에 해당하는 공개 디렉터리에서 발견된 인증서를 가져오기\(수동 또는 자동\)하기 위한 메커니즘을 지원해야 합니다.\(SHOULD, SHOULD\)

---
## **23.2 S/MIME Key Exchange**

SIP 자체는 다음과 같은 방식으로 공개 키를 배포하는 수단으로 사용될 수도 있습니다.

CMS SignedData 메시지가 SIP용 S/MIME에서 사용될 때마다 서명을 확인하는 데 필요한 공개 키가 포함된 인증서를 포함해야 합니다.\(MUST\)

UAC가 대화를 시작하는 S/MIME 본문이 포함된 요청을 보내거나 대화 컨텍스트 외부에서 INVITE가 아닌 요청을 보내는 경우 UAC는 본문을 S/MIME 'multipart/signed' CMS SignedData 본문으로 구성해야 합니다. . 원하는 CMS 서비스가 EnvelopedData이고 대상 사용자의 공개 키가 알려진 경우 UAC는 SignedData 메시지 내에 캡슐화된 EnvelopedData 메시지를 보내야 합니다.\(SHOULD, SHOULD\)

UAS가 인증서가 포함된 S/MIME CMS 본문이 포함된 요청을 받으면 UAS는 먼저 인증 기관에 사용 가능한 루트 인증서를 사용하여 인증서의 유효성을 검사해야 합니다. UAS는 또한 인증서의 제목\(S/MIME의 경우 SubjectAltName에 적절한 ID가 포함됨\)을 결정하고 이 값을 From 헤더 필드와 비교해야 합니다.\(SHOULD, SHOULD\)

요청의. 인증서가 자체 서명되었거나 알려진 기관에 의해 서명되지 않았기 때문에 인증서를 확인할 수 없는 경우 또는 인증서가 확인 가능하지만 해당 제목이 요청의 From 헤더 필드와 일치하지 않는 경우 UAS는 사용자에게 상태를 알려야 합니다. 인증서\(인증서의 주체, 서명자 및 키 지문 정보 포함\)를 확인하고 계속하기 전에 명시적인 허가를 요청하세요. 인증서가 성공적으로 확인되었고 인증서 제목이 SIP 요청의 From 헤더 필드에 해당하거나 사용자가\(알림 후\) 인증서 사용을 명시적으로 승인한 경우 UAS는 이 인증서를 로컬 키 링에 추가해야 합니다. 인증서 보유자의 기록 주소로 색인이 생성됩니다.\(MUST, SHOULD\)

UAS가 대화 상자의 첫 번째 요청에 응답하는 S/MIME 본문이 포함된 응답을 보내거나 대화 상자 컨텍스트 외부의 비INVITE 요청에 대한 응답을 보낼 때 UAS는 본문을 S/MIME '다중 부분으로 구성해야 합니다. /signed' CMS SignedData 본문입니다. 원하는 CMS 서비스가 EnvelopedData인 경우 UAS는 SignedData 메시지 내에 캡슐화된 EnvelopedData 메시지를 보내야 합니다.\(SHOULD, SHOULD\)

UAC가 인증서가 포함된 S/MIME CMS 본문이 포함된 응답을 수신하면 UAC는 먼저 가능한 경우 적절한 루트 인증서를 사용하여 인증서의 유효성을 검사해야 합니다. UAC는 또한 인증서의 제목을 결정하고 이 값을 응답의 To 필드와 비교해야 합니다. 두 가지가 매우 다를 수 있지만 이것이 반드시 보안 위반을 나타내는 것은 아닙니다. 자체 서명되었거나 알려진 기관이 서명하지 않아 인증서를 확인할 수 없는 경우 UAC는 사용자에게 인증서 상태\(인증서 주체, 서명자 및 키 지문 정보 포함\)를 알려야 합니다. 계속하기 전에 명시적인 허가를 요청하세요. 인증서가 성공적으로 확인되었고 인증서 제목이 응답의 To 헤더 필드에 해당하거나 사용자가 \(알림 후\) 명시적으로 인증서 사용을 승인한 경우 UAC는 이 인증서를 로컬 키링에 추가해야 합니다. 인증서 보유자의 기록 주소로 색인이 생성됩니다. UAC가 이전 트랜잭션에서 UAS에 자체 인증서를 전송하지 않은 경우 다음 요청 또는 응답에 대해 CMS SignedData 본문을 사용해야 합니다.\(SHOULD, SHOULD, MUST, SHOULD, SHOULD\)

나중에 UA가 키링의 값에 해당하는 From 헤더 필드가 포함된 요청이나 응답을 수신하면 UA는 이러한 메시지에 제공된 인증서를 키링의 기존 인증서와 비교해야 합니다. 불일치가 있는 경우 UA는 사용자에게 인증서 변경 사항을 알리고\(가능한 한 잠재적인 보안 위반임을 나타내는 용어로\) 계속 진행하기 전에 사용자의 허가를 받아야 합니다.\(SHOULD, MUST\)

신호를 처리합니다. 사용자가 이 인증서를 승인하는 경우 이 레코드 주소에 대한 이전 값과 함께 키링에 추가되어야 합니다.\(SHOULD\)

그러나 이 키 교환 메커니즘은 자체 서명된 인증서나 모호한 기관에서 서명한 인증서를 사용할 때 키의 안전한 교환을 보장하지 않는다는 점에 유의하세요. 이는 잘 알려진 공격에 취약합니다. 그러나 저자의 의견에 따르면 이것이 제공하는 보안은 없는 것보다 낫다고 합니다. 이는 실제로 널리 사용되는 SSH 애플리케이션과 유사합니다. 이러한 제한 사항은 섹션 26.4.2에서 더 자세히 설명됩니다.

UA가 수신자가 알 수 없는 공개 키로 암호화된 S/MIME 본문을 수신하는 경우 493\(해독할 수 없음\) 응답으로 요청을 거부해야 합니다. 이 응답은 'certs-only' "smime-type" 매개변수가 있는 MIME 본문 내 응답자에 대한 유효한 인증서\(가능한 경우 거부된 요청의 To 헤더 필드에 제공된 레코드 주소에 해당\)를 포함해야 합니다.\(MUST, SHOULD\)

인증서 없이 전송된 493\(해독 불가능\)은 응답자가 S/MIME 암호화된 메시지를 사용할 수 없거나 사용할 수 없음을 나타냅니다. 하지만 S/MIME 서명은 계속 지원할 수 있습니다.

선택사항이 아닌\("필수"의 Content-Disposition 헤더 "처리" 매개변수 사용\) S/MIME 본문이 포함된 요청을 수신하는 사용자 에이전트는 MIME 유형이 다음과 같은 경우 415 지원되지 않는 미디어 유형 응답으로 요청을 거부해야 합니다. 이해되지 않습니다. S/MIME이 전송될 때 이러한 응답을 수신하는 사용자 에이전트는 원격 장치가 S/MIME을 지원하지 않는다는 것을 사용자에게 알려야 하며, 적절한 경우 이후에 S/MIME 없이 요청을 다시 보낼 수 있습니다. 그러나 이 415 응답은 다운그레이드 공격을 구성할 수 있습니다.\(MUST, SHOULD\)

사용자 에이전트가 요청에 S/MIME 본문을 보냈지만 보안되지 않은 MIME 본문이 포함된 응답을 받은 경우 UAC는 사용자에게 세션을 보호할 수 없음을 알려야 합니다. 그러나 S/MIME을 지원하는 사용자 에이전트가 보안되지 않은 본문이 포함된 요청을 받으면 보안된 본문으로 응답해서는 안 됩니다. 그러나 발신자로부터 S/MIME을 기대하는 경우\(예를 들어 발신자의 From 헤더 필드 값이 일치하기 때문에\) 키체인의 ID에 연결\) UAS는 사용자에게 세션을 보호할 수 없음을 알려야 합니다.\(SHOULD, SHOULD NOT\)

비정상적인 인증서 관리 이벤트가 발생할 때 사용자에게 알리기 위한 이전 문자 호출에서 발생하는 여러 가지 조건입니다. 사용자는 이러한 상황에서 무엇을 해야 하는지 질문할 수도 있습니다. 무엇보다도 인증서에 예기치 않은 변경이 있거나 보안이 예상되는 데 보안이 부재하는 경우가 있습니다.

경고를 유발하지만 반드시 공격이 진행 중임을 나타내는 것은 아닙니다. 사용자는 연결 시도를 중단하거나 수신한 연결 요청을 거부할 수 있습니다. 전화 용어로 말하면 전화를 끊고 다시 전화할 수 있습니다. 사용자는 상대방에게 연락하여 키가 합법적으로 변경되었는지 확인할 수 있는 대체 수단을 찾고 싶어할 수 있습니다. 예를 들어 개인 키의 비밀이 손상되었다고 의심되는 경우 사용자는 인증서를 변경해야 하는 경우가 있습니다. 개인 키가 더 이상 개인 키가 아닌 경우 사용자는 합법적으로 새 키를 생성하고 이전 키를 보유한 모든 사용자와 신뢰를 다시 설정해야 합니다.

마지막으로, 대화 중에 UA가 대화 중에 이전에 교환된 인증서와 일치하지 않는 CMS SignedData 메시지의 인증서를 수신하는 경우, UA는 사용자에게 변경 사항을 알려야 합니다. 잠재적인 보안 침해.\(MUST\)

---
## **23.3 Securing MIME bodies**

SIP에 관심이 있는 보안 MIME 본문에는 두 가지 유형이 있습니다. 이러한 본문의 사용은 몇 가지 변형을 제외하고 S/MIME 사양\[24\]을 따라야 합니다.

o "multipart/signed"는 CMS가 분리된 경우에만 사용해야 합니다.

- 서명.\(MUST\)

- 이를 통해 S/MIME을 준수하지 않는 수신자와 이전 버전과의 호환성을 허용합니다.

```text
      o  S/MIME bodies SHOULD have a Content-Disposition header field,
         and the value of the "handling" parameter SHOULD be "required."
```

- o UAC가 요청을 보내려는 레코드 주소와 연결된 키 링에 인증서가 없으면 암호화된 "application/pkcs7-mime" MIME 메시지를 보낼 수 없습니다. UAC는 원격 측의 인증서를 요청하기 위해 CMS 분리 서명이 있는 OPTIONS 메시지와 같은 초기 요청을 보낼 수 있습니다\(서명은 섹션 23.4에 설명된 유형의 "메시지/sip" 본문 위에 있어야 합니다\).\(SHOULD\)

- S/MIME에 대한 향후 표준화 작업에서는 비인증서 기반 키를 정의할 수 있습니다.

```text
      o  Senders of S/MIME bodies SHOULD use the "SMIMECapabilities"
         (see Section 2.5.2 of [24]) attribute to express their
         capabilities and preferences for further communications.  Note
         especially that senders MAY use the "preferSignedData"
```

수신자가 CMS로 응답하도록 장려하는 기능

- SignedData 메시지\(예: 위에서 설명한 대로 OPTIONS 요청을 보내는 경우\)

- o S/MIME 구현은 최소한 디지털 서명 알고리즘으로 SHA1을 지원하고 암호화 알고리즘으로 3DES를 지원해야 합니다. 다른 모든 서명 및 암호화 알고리즘이 지원될 수 있습니다. 구현에서는 "SMIMECapability" 특성을 사용하여 이러한 알고리즘에 대한 지원을 협상할 수 있습니다.\(MUST, MAY\)

- o SIP 메시지의 각 S/MIME 본문은 하나의 인증서로만 서명되어야 합니다. UA가 여러 서명이 포함된 메시지를 수신하는 경우 가장 바깥쪽 서명은 이 본문에 대한 단일 인증서로 처리되어야 합니다. 병렬 서명은 사용하면 안 됩니다.\(SHOULD, SHOULD NOT\)

- 다음은 SIP 메시지 내 암호화된 S/MIME SDP 본문의 예입니다.

```text
        INVITE sip:bob@biloxi.com SIP/2.0
        Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
        To: Bob <sip:bob@biloxi.com>
        From: Alice <sip:alice@atlanta.com>;tag=1928301774
        Call-ID: a84b4c76e66710
        CSeq: 314159 INVITE
        Max-Forwards: 70
        Contact: <sip:alice@pc33.atlanta.com>
        Content-Type: application/pkcs7-mime; smime-type=enveloped-data;
             name=smime.p7m
        Content-Disposition: attachment; filename=smime.p7m
           handling=required

      *******************************************************
      * Content-Type: application/sdp                       *
      *                                                     *
      * v=0                                                 *
      * o=alice 53655765 2353687637 IN IP4 pc33.atlanta.com *
      * s=-                                                 *
      * t=0 0                                               *
      * c=IN IP4 pc33.atlanta.com                           *
      * m=audio 3456 RTP/AVP 0 1 3 99                       *
      * a=rtpmap:0 PCMU/8000                                *
      *******************************************************
```

---
## **23.4 SIP Header Privacy and Integrity using S/MIME: Tunneling SIP**

SIP 헤더 필드에 대한 어느 정도의 종단 간 인증, 무결성 또는 기밀성을 제공하는 수단으로 S/MIME은 "message/sip" 유형의 MIME 본문 내에 전체 SIP 메시지를 캡슐화한 다음 이러한 본문에 MIME 보안을 적용할 수 있습니다. 일반적인 SIP 본문과 동일한 방식입니다. 이러한 캡슐화된 SIP 요청 및 응답은 별도의 대화 상자나 트랜잭션을 구성하지 않으며 무결성을 확인하거나 추가 정보를 제공하는 데 사용되는 "외부" 메시지의 복사본입니다.

UAS가 터널링된 "메시지/sip" S/MIME 본문이 포함된 요청을 수신하는 경우 동일한 smime 유형의 응답에 터널링된 "메시지/sip" 본문을 포함해야 합니다.\(SHOULD\)

SDP와 같은 전통적인 MIME 본문은 S/MIME 보안의 이점을 누릴 수 있도록 "내부" 메시지에 첨부되어야 합니다. 보안되지 않은 MIME 유형도 요청에서 전송해야 하는 경우 "메시지/sip" 본문은 MIME "다중 부분/혼합" 본문의 일부로 전송될 수 있습니다.\(SHOULD\)

---
### **23.4.1 Integrity and Confidentiality Properties of SIP Headers**

S/MIME 무결성 또는 기밀성 메커니즘을 사용하는 경우 "내부" 메시지의 값과 "외부" 메시지의 값 사이에 불일치가 있을 수 있습니다. 이 문서에 설명된 모든 헤더 필드에 대한 이러한 차이점을 처리하는 규칙은 이 섹션에 나와 있습니다.

느슨한 타임스탬프를 위해 "message/sip"을 터널링하는 모든 SIP 메시지는 "내부" 및 "외부" 헤더 모두에 날짜 헤더를 포함해야 합니다.\(SHOULD\)

---
#### **23.4.1.1 Integrity**

무결성 검사가 수행될 때마다 헤더 필드의 무결성은 20에 설명된 대로 SIP의 비교 규칙을 사용하여 서명된 본문의 헤더 필드 값을 "외부" 메시지의 헤더 필드 값과 일치시켜 결정해야 합니다.

프록시 서버에 의해 합법적으로 수정될 수 있는 헤더 필드는 Request-URI, Via, Record-Route, Route, Max-Forwards 및 Proxy-Authorization입니다. 이러한 헤더 필드가 종단 간 손상되지 않은 경우 구현에서는 이를 보안 위반으로 간주해서는 안 됩니다. 이 문서에 정의된 다른 헤더 필드를 변경하면 무결성 위반이 됩니다. 사용자에게 불일치 사실을 알려야 합니다.\(SHOULD NOT, MUST\)

---
#### **23.4.1.2 Confidentiality**

메시지가 암호화되면 "외부" 메시지에는 없는 헤더 필드가 암호화된 본문에 포함될 수 있습니다.

일부 헤더 필드는 요청 및 응답의 필수 헤더 필드이므로 항상 일반 텍스트 버전을 가져야 합니다. 여기에는 다음이 포함됩니다.

받는 사람, 보낸 사람, 통화 ID, CSeq, 연락처. Call-ID, CSeq 또는 연락처에 대한 암호화된 대안을 제공하는 것은 아마도 유용하지 않지만 "외부" To 또는 From의 정보에 대한 대안을 제공하는 것은 허용됩니다. 암호화된 본문의 값은 트랜잭션이나 대화를 식별하는 목적으로 사용되지 않으며 단지 정보 제공용일 뿐입니다. 암호화된 본문의 From 헤더 필드가 "외부" 메시지의 값과 다른 경우 암호화된 본문 내의 값은 사용자에게 표시되어야 하지만 향후 메시지의 "외부" 헤더 필드에는 사용되어서는 안 됩니다.\(MUST NOT\)

기본적으로 사용자 에이전트는 제목, 응답 대상, 조직, 수락, 수락 인코딩, 수락 언어, 경고 정보, 오류 정보, 인증을 포함하여 엔드투엔드 의미 체계를 갖는 헤더 필드를 암호화하려고 합니다. -정보, 만료, 응답 시, 필요, 지원됨, 지원되지 않음, 재시도 후, 사용자 에이전트, 서버 및 경고. 암호화된 본문에 이러한 헤더 필드가 있는 경우 헤더 필드 값을 사용자에게 표시하거나 UA에서 내부 상태를 설정하는 것과 관계없이 "외부" 헤더 필드 대신 사용해야 합니다. 그러나 향후 메시지의 "외부" 헤더에는 사용하면 안 됩니다.\(SHOULD NOT\)

Date 헤더 필드가 있는 경우 "내부" 및 "외부" 헤더에서 항상 동일해야 합니다.\(MUST\)

MIME 본문은 "내부" 메시지에 첨부되므로 구현에서는 일반적으로 MIME-Version, Content-Type, Content-Length, Content-Language, Content-Encoding 및 Content-Disposition을 포함한 MIME 관련 헤더 필드를 암호화합니다. "외부" 메시지에는 S/MIME 본문에 대한 적절한 MIME 헤더 필드가 있습니다. 이러한 헤더 필드\(및 앞에 붙는 모든 MIME 본문\)는 SIP 메시지에서 수신된 일반 MIME 헤더 필드 및 본문으로 처리되어야 합니다.

Min-Expires, Timestamp, Authorization, Priority 및 WWW-Authenticate와 같은 헤더 필드를 암호화하는 것은 특히 유용하지 않습니다. 이 범주에는 프록시 서버에서 변경할 수 있는 헤더 필드도 포함됩니다\(이전 섹션에서 설명\). UA는 '내부' 메시지에 이를 포함해서는 안 됩니다.\(SHOULD\)

"외부" 메시지에 포함됩니다. 암호화된 본문에서 이러한 헤더 필드를 수신하는 UA는 암호화된 값을 무시해야 합니다\(SHOULD\).\(SHOULD\)

SIP 확장은 추가 헤더 필드를 정의할 수 있습니다. 이러한 확장의 작성자는 해당 헤더 필드의 무결성 및 기밀성 속성을 설명해야 합니다. SIP UA가 무결성 위반이 있는 알 수 없는 헤더 필드를 발견하면 헤더 필드를 무시해야 합니다.\(MUST\)

---
### **23.4.2 Tunneling Integrity and Authentication**

보낸 사람이 보호하려는 헤더 필드가 CMS 분리 서명으로 서명된 "메시지/sip" MIME 본문에 복제된 경우 S/MIME 본문 내에서 SIP 메시지를 터널링하면 SIP 헤더 필드에 무결성을 제공할 수 있습니다.

"메시지/sip" 본문에 최소한 기본 대화 식별자\(To, From, Call-ID, CSeq\)가 포함되어 있는 경우 서명된 MIME 본문은 제한된 인증을 제공할 수 있습니다. 최소한 본문에 서명하는 데 사용된 인증서가 수신자에게 알려지지 않았고 확인할 수 없는 경우 서명을 사용하여 대화를 시작한 동일한 인증서 보유자가 대화의 이후 요청을 전송했는지 확인할 수 있습니다. 서명된 MIME 본문의 수신자가 인증서를 신뢰하려는 더 강력한 인센티브를 갖고 있는 경우\(인증서를 검증할 수 있었거나 신뢰할 수 있는 저장소에서 인증서를 획득했거나 자주 사용함\) 서명은 다음과 같은 더 강력한 주장으로 간주될 수 있습니다. 인증서 주체의 신원.

전체 헤더 필드의 추가 또는 뺄셈에 대한 혼동 가능성을 없애기 위해 발신자는 서명된 본문 내 요청의 모든 헤더 필드를 복제해야 합니다. 무결성 보호가 필요한 모든 메시지 본문은 "내부" 메시지에 첨부되어야 합니다.\(SHOULD, MUST\)

서명된 본문이 있는 메시지에 날짜 헤더가 있는 경우 수신자는 헤더 필드 값을 자체 내부 시계와 비교해야 합니다\(해당되는 경우\). 상당한 시간 불일치가 감지되면\(약 1시간 이상\) 사용자 에이전트는 사용자에게 예외 사항을 경고하고 잠재적인 보안 위반임을 알려야 합니다.\(SHOULD, SHOULD\)

메시지의 무결성 위반이 수신자에 의해 감지되면 해당 메시지가 요청인 경우 403\(금지됨\) 응답으로 거부되거나 기존 대화가 종료될 수 있습니다. UA는 사용자에게 이러한 상황을 알리고 진행 방법에 대한 명시적인 지침을 요청해야 합니다.\(MAY, SHOULD\)

다음은 터널링된 "메시지/sip" 본문 사용의 예입니다.

```text
      INVITE sip:bob@biloxi.com SIP/2.0
      Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
      To: Bob <sip:bob@biloxi.com>
      From: Alice <sip:alice@atlanta.com>;tag=1928301774
      Call-ID: a84b4c76e66710
      CSeq: 314159 INVITE
      Max-Forwards: 70
      Date: Thu, 21 Feb 2002 13:02:03 GMT
      Contact: <sip:alice@pc33.atlanta.com>
      Content-Type: multipart/signed;
        protocol="application/pkcs7-signature";
        micalg=sha1; boundary=boundary42
      Content-Length: 568

      --boundary42
      Content-Type: message/sip

      INVITE sip:bob@biloxi.com SIP/2.0
      Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
      To: Bob <bob@biloxi.com>
      From: Alice <alice@atlanta.com>;tag=1928301774
      Call-ID: a84b4c76e66710
      CSeq: 314159 INVITE
      Max-Forwards: 70
      Date: Thu, 21 Feb 2002 13:02:03 GMT
      Contact: <sip:alice@pc33.atlanta.com>
      Content-Type: application/sdp
      Content-Length: 147
```

v=0

- o=UserA 2890844526 2890844526 IN IP4 here.com s=세션 SDP c=IN IP4 pc33.atlanta.com t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000

```text
      --boundary42
      Content-Type: application/pkcs7-signature; name=smime.p7s
      Content-Transfer-Encoding: base64
      Content-Disposition: attachment; filename=smime.p7s;
         handling=required

      ghyHhHUujhJhjH77n8HHGTrfvbnj756tbB9HG4VQpfyF467GhIGfHfYT6
      4VQpfyF467GhIGfHfYT6jH77n8HHGghyHhHUujhJh756tbB9HGTrfvbnj
      n8HHGTrfvhJhjH776tbB9HG4VQbnj7567GhIGfHfYT6ghyHhHUujpfyF4
      7GhIGfHfYT64VQbnj756

      --boundary42-
```

---
### **23.4.3 Tunneling Encryption**

CMS EnvelopedData 메시지 S/MIME 본문 내에서 "메시지/sip" MIME 본문을 암호화하기 위해 이 메커니즘을 사용하는 것이 바람직할 수도 있지만 실제로는 대부분의 헤더 필드가 네트워크에 어느 정도 사용됩니다. S/MIME을 사용한 암호화의 일반적인 용도는 메시지 헤더가 아닌 SDP와 같은 메시지 본문을 보호하는 것입니다. 제목 또는 조직과 같은 일부 정보 헤더 필드는 종단 간 보안을 보장할 수 있습니다. 향후 SIP 애플리케이션에서 정의되는 헤더에도 난독화가 필요할 수 있습니다.

헤더 필드 암호화의 또 다른 가능한 적용은 선택적 익명성입니다. 개인 정보가 포함되지 않은 From 헤더 필드를 사용하여 요청을 구성할 수 있습니다\(예: sip:anonymous@anonymizer.invalid\). 그러나 발신자의 실제 레코드 주소를 포함하는 두 번째 From 헤더 필드는 대화의 끝점에만 표시되는 "메시지/sip" MIME 본문 내에서 암호화될 수 있습니다.

- 익명성을 위해 이 메커니즘을 사용하는 경우 메시지 수신자는 발신자와 연결된 적절한 S/MIME 키를 검색하기 위해 인증서 키체인에 대한 인덱스로 더 이상 From 헤더 필드를 사용할 수 없습니다. 메시지를 먼저 해독해야 하며 "내부" From 헤더 필드를 인덱스로 사용해야 합니다.\(MUST\)

종단간 무결성을 제공하려면 암호화된 "메시지/sip" MIME 본문에 발신자가 서명해야 합니다. 이렇게 하면 "application/pkcs7-mime" 유형의 암호화된 본문과 서명을 포함하는 "다중 부분/서명된" MIME 본문이 생성됩니다.\(SHOULD\)

다음 예에서는 암호화되고 서명된 메시지에서 별표\("\*"\)로 표시된 텍스트 상자가 암호화됩니다.

```text
        INVITE sip:bob@biloxi.com SIP/2.0
        Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
        To: Bob <sip:bob@biloxi.com>
        From: Anonymous <sip:anonymous@atlanta.com>;tag=1928301774
        Call-ID: a84b4c76e66710
        CSeq: 314159 INVITE
        Max-Forwards: 70
        Date: Thu, 21 Feb 2002 13:02:03 GMT
        Contact: <sip:pc33.atlanta.com>
        Content-Type: multipart/signed;
          protocol="application/pkcs7-signature";
          micalg=sha1; boundary=boundary42
        Content-Length: 568

        --boundary42
        Content-Type: application/pkcs7-mime; smime-type=enveloped-data;
             name=smime.p7m
        Content-Transfer-Encoding: base64
        Content-Disposition: attachment; filename=smime.p7m
           handling=required
        Content-Length: 231

      ***********************************************************
      * Content-Type: message/sip                               *
      *                                                         *
      * INVITE sip:bob@biloxi.com SIP/2.0                       *
      * Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 *
      * To: Bob <bob@biloxi.com>                                *
      * From: Alice <alice@atlanta.com>;tag=1928301774          *
      * Call-ID: a84b4c76e66710                                 *
      * CSeq: 314159 INVITE                                     *
      * Max-Forwards: 70                                        *
      * Date: Thu, 21 Feb 2002 13:02:03 GMT                     *
      * Contact: <sip:alice@pc33.atlanta.com>                   *
      *                                                         *
      * Content-Type: application/sdp                           *
      *                                                         *
      * v=0                                                     *
      * o=alice 53655765 2353687637 IN IP4 pc33.atlanta.com     *
      * s=Session SDP                                           *
      * t=0 0                                                   *
      * c=IN IP4 pc33.atlanta.com                               *
      * m=audio 3456 RTP/AVP 0 1 3 99                           *
      * a=rtpmap:0 PCMU/8000                                    *
      ***********************************************************

        --boundary42
        Content-Type: application/pkcs7-signature; name=smime.p7s
        Content-Transfer-Encoding: base64
        Content-Disposition: attachment; filename=smime.p7s;
           handling=required

        ghyHhHUujhJhjH77n8HHGTrfvbnj756tbB9HG4VQpfyF467GhIGfHfYT6
        4VQpfyF467GhIGfHfYT6jH77n8HHGghyHhHUujhJh756tbB9HGTrfvbnj
        n8HHGTrfvhJhjH776tbB9HG4VQbnj7567GhIGfHfYT6ghyHhHUujpfyF4
        7GhIGfHfYT64VQbnj756

        --boundary42-
```

---
# **24 Examples**

다음 예에서는 간결성을 위해 메시지 본문과 해당 Content-Length 및 Content-Type 헤더 필드를 생략하는 경우가 많습니다.

---
## **24.1 Registration**

Bob은 시작 시 등록합니다. 메시지 흐름은 그림 9에 나와 있습니다. 일반적으로 등록에 필요한 인증은 단순화를 위해 표시되지 않습니다.

```text
                  biloxi.com         Bob's
                   registrar       softphone
                      |                |
                      |   REGISTER F1  |
                      |<---------------|
                      |    200 OK F2   |
                      |--------------->|

                  Figure 9: SIP Registration Example

   F1 REGISTER Bob -> Registrar

       REGISTER sip:registrar.biloxi.com SIP/2.0
       Via: SIP/2.0/UDP bobspc.biloxi.com:5060;branch=z9hG4bKnashds7
       Max-Forwards: 70
       To: Bob <sip:bob@biloxi.com>
       From: Bob <sip:bob@biloxi.com>;tag=456248
       Call-ID: 843817637684230@998sdasdh09
       CSeq: 1826 REGISTER
       Contact: <sip:bob@192.0.2.4>
       Expires: 7200
       Content-Length: 0
```

등록은 2시간 후에 만료됩니다. 등록자는 200 OK로 응답합니다.

```text
   F2 200 OK Registrar -> Bob

        SIP/2.0 200 OK
        Via: SIP/2.0/UDP bobspc.biloxi.com:5060;branch=z9hG4bKnashds7
         ;received=192.0.2.4
        To: Bob <sip:bob@biloxi.com>;tag=2493k59kd
        From: Bob <sip:bob@biloxi.com>;tag=456248
        Call-ID: 843817637684230@998sdasdh09
        CSeq: 1826 REGISTER
        Contact: <sip:bob@192.0.2.4>
        Expires: 7200
        Content-Length: 0
```

---
## **24.2 Session Setup**

이 예에는 섹션 4의 세션 설정 예에 대한 전체 세부 정보가 포함되어 있습니다. 메시지 흐름은 그림 1에 나와 있습니다. 이러한 흐름은 최소 필수 헤더 필드 집합을 보여줍니다. 일반적으로 Allow 및 Supported와 같은 일부 다른 헤더 필드가 존재합니다. .

---
# **F1 INVITE Alice -> atlanta.com proxy**

```text
INVITE sip:bob@biloxi.com SIP/2.0
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
Max-Forwards: 70
To: Bob <sip:bob@biloxi.com>
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 314159 INVITE
Contact: <sip:alice@pc33.atlanta.com>
Content-Type: application/sdp
Content-Length: 142

(Alice's SDP not shown)
```

---
# **F2 100 Trying atlanta.com proxy -> Alice**

```text
SIP/2.0 100 Trying
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@biloxi.com>
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 314159 INVITE
Content-Length: 0
```

---
# **F3 INVITE atlanta.com proxy -> biloxi.com proxy**

```text
INVITE sip:bob@biloxi.com SIP/2.0
Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Max-Forwards: 69
To: Bob <sip:bob@biloxi.com>
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 314159 INVITE
Contact: <sip:alice@pc33.atlanta.com>
Content-Type: application/sdp
Content-Length: 142

(Alice's SDP not shown)
```

---
# **F4 100 Trying biloxi.com proxy -> atlanta.com proxy**

```text
SIP/2.0 100 Trying
Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1
 ;received=192.0.2.2
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@biloxi.com>
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 314159 INVITE
Content-Length: 0
```

---
# **F5 INVITE biloxi.com proxy -> Bob**

```text
INVITE sip:bob@192.0.2.4 SIP/2.0
Via: SIP/2.0/UDP server10.biloxi.com;branch=z9hG4bK4b43c2ff8.1
Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1
 ;received=192.0.2.2
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
Max-Forwards: 68
To: Bob <sip:bob@biloxi.com>
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 314159 INVITE
Contact: <sip:alice@pc33.atlanta.com>
Content-Type: application/sdp
Content-Length: 142

(Alice's SDP not shown)
```

---
# **F6 180 Ringing Bob -> biloxi.com proxy**

```text
SIP/2.0 180 Ringing
Via: SIP/2.0/UDP server10.biloxi.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1
 ;received=192.0.2.2
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@biloxi.com>;tag=a6c85cf
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
Contact: <sip:bob@192.0.2.4>
CSeq: 314159 INVITE
Content-Length: 0
```

---
# **F7 180 Ringing biloxi.com proxy -> atlanta.com proxy**

```text
SIP/2.0 180 Ringing
Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1
 ;received=192.0.2.2
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@biloxi.com>;tag=a6c85cf
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
Contact: <sip:bob@192.0.2.4>
CSeq: 314159 INVITE
Content-Length: 0
```

---
# **F8 180 Ringing atlanta.com proxy -> Alice**

```text
SIP/2.0 180 Ringing
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@biloxi.com>;tag=a6c85cf
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
Contact: <sip:bob@192.0.2.4>
CSeq: 314159 INVITE
Content-Length: 0
```

---
# **F9 200 OK Bob -> biloxi.com proxy**

```text
SIP/2.0 200 OK
Via: SIP/2.0/UDP server10.biloxi.com;branch=z9hG4bK4b43c2ff8.1
 ;received=192.0.2.3
Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1
 ;received=192.0.2.2
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@biloxi.com>;tag=a6c85cf
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 314159 INVITE
Contact: <sip:bob@192.0.2.4>
Content-Type: application/sdp
Content-Length: 131

(Bob's SDP not shown)
```

---
# **F10 200 OK biloxi.com proxy -> atlanta.com proxy**

```text
SIP/2.0 200 OK
Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1
 ;received=192.0.2.2
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@biloxi.com>;tag=a6c85cf
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 314159 INVITE
Contact: <sip:bob@192.0.2.4>
Content-Type: application/sdp
Content-Length: 131

(Bob's SDP not shown)
```

---
# **F11 200 OK atlanta.com proxy -> Alice**

```text
SIP/2.0 200 OK
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8
 ;received=192.0.2.1
To: Bob <sip:bob@biloxi.com>;tag=a6c85cf
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 314159 INVITE
Contact: <sip:bob@192.0.2.4>
Content-Type: application/sdp
Content-Length: 131

(Bob's SDP not shown)
```

---
# **F12 ACK Alice -> Bob**

```text
ACK sip:bob@192.0.2.4 SIP/2.0
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds9
Max-Forwards: 70
To: Bob <sip:bob@biloxi.com>;tag=a6c85cf
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 314159 ACK
Content-Length: 0
```

이제 Alice와 Bob 사이의 미디어 세션이 설정되었습니다.

밥이 먼저 전화를 끊는다. Bob의 SIP 전화는 자체 CSeq 번호 지정 공간을 유지하며 이 예에서는 231로 시작합니다. Bob이 요청을 하기 때문에 To 및 From URI와 태그가 교체되었습니다.

---
# **F13 BYE Bob -> Alice**

```text
BYE sip:alice@pc33.atlanta.com SIP/2.0
Via: SIP/2.0/UDP 192.0.2.4;branch=z9hG4bKnashds10
Max-Forwards: 70
From: Bob <sip:bob@biloxi.com>;tag=a6c85cf
To: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 231 BYE
Content-Length: 0
```

---
# **F14 200 OK Alice -> Bob**

```text
SIP/2.0 200 OK
Via: SIP/2.0/UDP 192.0.2.4;branch=z9hG4bKnashds10
From: Bob <sip:bob@biloxi.com>;tag=a6c85cf
To: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710
CSeq: 231 BYE
Content-Length: 0
```

SIP 통화 흐름 문서\[40\]에는 SIP 메시지의 추가 예가 포함되어 있습니다.

---
# **25  Augmented BNF for the SIP Protocol**

이 문서에 명시된 모든 메커니즘은 RFC 2234 \[10\]에 정의된 산문과 확장된 BNF\(Backus-Naur Form\)에 설명되어 있습니다. RFC 2234의 섹션 6.1은 이 사양에서 사용되는 핵심 규칙 집합을 정의하며 여기서는 반복하지 않습니다. 구현자는 이 사양을 이해하기 위해 RFC 2234의 표기법과 내용을 잘 알고 있어야 합니다. SP, LWS, HTAB, CRLF, DIGIT, ALPHA 등과 같은 특정 기본 규칙은 대문자로 표시됩니다. 규칙 이름의 사용을 명확하게 하기 위해 정의 내에서 꺾쇠 괄호가 사용됩니다.

대괄호 사용은 구문상 중복됩니다. 특정 매개변수를 선택적으로 사용할 수 있다는 의미적 힌트로 사용됩니다.

---
## **25.1 Basic Rules**

다음 규칙은 기본 구문 분석 구성을 설명하기 위해 이 사양 전체에서 사용됩니다. US-ASCII 코드 문자 집합은 ANSI X3.4-1986에 의해 정의됩니다.

```text
      alphanum  =  ALPHA / DIGIT
```

여러 규칙은 RFC 2396 \[5\]에서 통합되었지만 RFC 2234 \[10\]을 준수하도록 업데이트되었습니다. 여기에는 다음이 포함됩니다.

```text
      reserved    =  ";" / "/" / "?" / ":" / "@" / "&" / "=" / "+"
                     / "$" / ","
      unreserved  =  alphanum / mark
      mark        =  "-" / "_" / "." / "!" / "~" / "*" / "'"
                     / "(" / ")"
      escaped     =  "%" HEXDIG HEXDIG
```

연속 줄이 공백이나 가로 탭으로 시작하는 경우 SIP 헤더 필드 값을 여러 줄로 접을 수 있습니다. 접기를 포함한 모든 선형 공백은 SP와 동일한 의미를 갖습니다. 수신자는 필드 값을 해석하거나 메시지를 다운스트림으로 전달하기 전에 모든 선형 공백을 단일 SP로 바꿀 수 있습니다. 이는 RFC 2616 \[8\]에 설명된 대로 HTTP/1.1과 정확히 동일하게 작동하기 위한 것입니다. SWS 구성은 선형 공백이 선택 사항일 때, 일반적으로 토큰과 구분 기호 사이에 사용됩니다.\(MAY\)

```text
      LWS  =  [*WSP CRLF] 1*WSP ; linear whitespace
      SWS  =  [LWS] ; sep whitespace
```

헤더 이름을 나머지 값과 분리하기 위해 콜론을 사용합니다. 콜론은 위의 규칙에 따라 앞에 공백을 허용하지만 줄바꿈은 허용하지 않고 뒤에 공백\(줄바꿈 포함\)을 허용합니다. HCOLON은 이 구성을 정의합니다.

```text
      HCOLON  =  *( SP / HTAB ) ":" SWS
```

TEXT-UTF8 규칙은 메시지 구문 분석기에 의해 해석되지 않는 설명 필드 내용 및 값에만 사용됩니다. \*TEXT-UTF8의 단어에는 UTF-8 문자 집합\(RFC 2279 \[7\]\)의 문자가 포함되어 있습니다. TEXT-UTF8-TRIM 규칙은 인용 문자열이 아닌 설명 필드 내용에 사용됩니다. 여기서 선행 및 후행 LWS는 의미가 없습니다. 이러한 점에서 SIP는 ISO 8859-1 문자 집합을 사용하는 HTTP와 다릅니다.

```text
      TEXT-UTF8-TRIM  =  1*TEXT-UTF8char *(*LWS TEXT-UTF8char)
      TEXT-UTF8char   =  %x21-7E / UTF8-NONASCII
      UTF8-NONASCII   =  %xC0-DF 1UTF8-CONT
                      /  %xE0-EF 2UTF8-CONT
                      /  %xF0-F7 3UTF8-CONT
                      /  %xF8-Fb 4UTF8-CONT
                      /  %xFC-FD 5UTF8-CONT
      UTF8-CONT       =  %x80-BF
```

CRLF는 TEXT-UTF8-TRIM 정의에서 헤더 필드 연속의 일부로만 허용됩니다. TEXT-UTF8-TRIM 값을 해석하기 전에 접이식 LWS가 단일 SP로 대체될 것으로 예상됩니다.

16진수 문자는 여러 프로토콜 요소에 사용됩니다. 일부 요소\(인증\)는 16진수 알파를 소문자로 강제합니다.

```text
      LHEX  =  DIGIT / %x61-66 ;lowercase a-f
```

많은 SIP 헤더 필드 값은 LWS 또는 특수 문자로 구분된 단어로 구성됩니다. 별도로 명시하지 않는 한 토큰은 대소문자를 구분하지 않습니다. 이러한 특수 문자는 매개변수 값 내에서 사용되도록 따옴표로 묶은 문자열에 있어야 합니다. Call-ID에서는 대부분의 구분 기호를 사용할 수 있도록 구조라는 단어가 사용됩니다.\(MUST\)

```text
      token       =  1*(alphanum / "-" / "." / "!" / "%" / "*"
                     / "_" / "+" / "`" / "'" / "~" )
      separators  =  "(" / ")" / "<" / ">" / "@" /
                     "," / ";" / ":" / "\" / DQUOTE /
                     "/" / "[" / "]" / "?" / "=" /
                     "{" / "}" / SP / HTAB
      word        =  1*(alphanum / "-" / "." / "!" / "%" / "*" /
                     "_" / "+" / "`" / "'" / "~" /
                     "(" / ")" / "<" / ">" /
                     ":" / "\" / DQUOTE /
                     "/" / "[" / "]" / "?" /
                     "{" / "}" )
```

토큰을 사용하거나 요소 사이에 구분 기호를 사용하는 경우 다음 문자 앞이나 뒤에 공백이 허용되는 경우가 많습니다.

```text
      STAR    =  SWS "*" SWS ; asterisk
      SLASH   =  SWS "/" SWS ; slash
      EQUAL   =  SWS "=" SWS ; equal
      LPAREN  =  SWS "(" SWS ; left parenthesis
      RPAREN  =  SWS ")" SWS ; right parenthesis
      RAQUOT  =  ">" SWS ; right angle quote
      LAQUOT  =  SWS "<"; left angle quote
      COMMA   =  SWS "," SWS ; comma
      SEMI    =  SWS ";" SWS ; semicolon
      COLON   =  SWS ":" SWS ; colon
      LDQUOT  =  SWS DQUOTE; open double quotation mark
      RDQUOT  =  DQUOTE SWS ; close double quotation mark
```

설명 텍스트를 괄호로 묶어 일부 SIP 헤더 필드에 설명을 포함할 수 있습니다. 설명은 필드 값 정의의 일부로 "설명"을 포함하는 필드에서만 허용됩니다. 다른 모든 필드에서는 괄호가 필드 값의 일부로 간주됩니다.

```text
      comment  =  LPAREN *(ctext / quoted-pair / comment) RPAREN
      ctext    =  %x21-27 / %x2A-5B / %x5D-7E / UTF8-NONASCII
                  / LWS
```

ctext에는 왼쪽 및 오른쪽 괄호와 백슬래시를 제외한 모든 문자가 포함됩니다. 텍스트 문자열이 큰따옴표를 사용하여 인용된 경우 단일 단어로 구문 분석됩니다. 인용된 문자열에서는 인용 부호\("\)와 백슬래시\(\)를 이스케이프해야 합니다.

```text
      quoted-string  =  SWS DQUOTE *(qdtext / quoted-pair ) DQUOTE
      qdtext         =  LWS / %x21 / %x23-5B / %x5D-7E
                        / UTF8-NONASCII
```

백슬래시 문자\("\"\)는 인용 문자열 및 주석 구성 내에서만 단일 문자 인용 메커니즘으로 사용될 수 있습니다. HTTP/1.1과 달리 CR 및 LF 문자는 줄 접기 및 헤더 분리와의 충돌을 피하기 위해 이 메커니즘으로 이스케이프될 수 없습니다.\(MAY\)

```text
quoted-pair  =  "\" (%x00-09 / %x0B-0C
                / %x0E-7F)

SIP-URI          =  "sip:" [ userinfo ] hostport
                    uri-parameters [ headers ]
SIPS-URI         =  "sips:" [ userinfo ] hostport
                    uri-parameters [ headers ]
userinfo         =  ( user / telephone-subscriber ) [ ":" password ] "@"
user             =  1*( unreserved / escaped / user-unreserved )
user-unreserved  =  "&" / "=" / "+" / "$" / "," / ";" / "?" / "/"
password         =  *( unreserved / escaped /
                    "&" / "=" / "+" / "$" / "," )
hostport         =  host [ ":" port ]
host             =  hostname / IPv4address / IPv6reference
hostname         =  *( domainlabel "." ) toplabel [ "." ]
domainlabel      =  alphanum
                    / alphanum *( alphanum / "-" ) alphanum
toplabel         =  ALPHA / ALPHA *( alphanum / "-" ) alphanum

IPv4address    =  1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
IPv6reference  =  "[" IPv6address "]"
IPv6address    =  hexpart [ ":" IPv4address ]
hexpart        =  hexseq / hexseq "::" [ hexseq ] / "::" [ hexseq ]
hexseq         =  hex4 *( ":" hex4)
hex4           =  1*4HEXDIG
port           =  1*DIGIT
```

전화 가입자에 대한 BNF는 RFC 2806 \[9\]에서 찾을 수 있습니다. 그러나 SIP URI의 사용자 부분에서 허용되지 않는 문자는 이스케이프되어야 합니다.\(MUST\)

```text
uri-parameters    =  *( ";" uri-parameter)
uri-parameter     =  transport-param / user-param / method-param
                     / ttl-param / maddr-param / lr-param / other-param
transport-param   =  "transport="
                     ( "udp" / "tcp" / "sctp" / "tls"
                     / other-transport)
other-transport   =  token
user-param        =  "user=" ( "phone" / "ip" / other-user)
other-user        =  token
method-param      =  "method=" Method
ttl-param         =  "ttl=" ttl
maddr-param       =  "maddr=" host
lr-param          =  "lr"
other-param       =  pname [ "=" pvalue ]
pname             =  1*paramchar
pvalue            =  1*paramchar
paramchar         =  param-unreserved / unreserved / escaped
param-unreserved  =  "[" / "]" / "/" / ":" / "&" / "+" / "$"

headers         =  "?" header *( "&" header )
header          =  hname "=" hvalue
hname           =  1*( hnv-unreserved / unreserved / escaped )
hvalue          =  *( hnv-unreserved / unreserved / escaped )
hnv-unreserved  =  "[" / "]" / "/" / "?" / ":" / "+" / "$"

SIP-message    =  Request / Response
Request        =  Request-Line
                  *( message-header )
                  CRLF
                  [ message-body ]
Request-Line   =  Method SP Request-URI SP SIP-Version CRLF
Request-URI    =  SIP-URI / SIPS-URI / absoluteURI
absoluteURI    =  scheme ":" ( hier-part / opaque-part )
hier-part      =  ( net-path / abs-path ) [ "?" query ]
net-path       =  "//" authority [ abs-path ]
abs-path       =  "/" path-segments

opaque-part    =  uric-no-slash *uric
uric           =  reserved / unreserved / escaped
uric-no-slash  =  unreserved / escaped / ";" / "?" / ":" / "@"
                  / "&" / "=" / "+" / "$" / ","
path-segments  =  segment *( "/" segment )
segment        =  *pchar *( ";" param )
param          =  *pchar
pchar          =  unreserved / escaped /
                  ":" / "@" / "&" / "=" / "+" / "$" / ","
scheme         =  ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
authority      =  srvr / reg-name
srvr           =  [ [ userinfo "@" ] hostport ]
reg-name       =  1*( unreserved / escaped / "$" / ","
                  / ";" / ":" / "@" / "&" / "=" / "+" )
query          =  *uric
SIP-Version    =  "SIP" "/" 1*DIGIT "." 1*DIGIT
```

message-header = \(수락 / Accept-Encoding / Accept-Language / Alert-Info / Allow / Authentication-Info / Authorization / Call-ID / Call-Info / Contact / Content-Disposition / Content-Encoding / Content-Language / Content -길이 / 콘텐츠 유형 / CSeq / 날짜 / 오류 정보 / 만료 / 보낸 사람 / 응답 수신 / 최대 전달 / MIME 버전 / 최소 만료 / 조직 / 우선 순위 / 프록시 인증 / 프록시 인증 / 프록시 -요구/기록-라우트/회신

/  필요하다

- / 재시도 후 / 경로 / 서버 / 제목 / 지원됨 / 타임스탬프 / 받는 사람 / 지원되지 않음 / 사용자 에이전트 / 경유 / 경고 / WWW-인증 / 확장 헤더\) CRLF

```text
INVITEm           =  %x49.4E.56.49.54.45 ; INVITE in caps
ACKm              =  %x41.43.4B ; ACK in caps
OPTIONSm          =  %x4F.50.54.49.4F.4E.53 ; OPTIONS in caps
BYEm              =  %x42.59.45 ; BYE in caps
CANCELm           =  %x43.41.4E.43.45.4C ; CANCEL in caps
REGISTERm         =  %x52.45.47.49.53.54.45.52 ; REGISTER in caps
Method            =  INVITEm / ACKm / OPTIONSm / BYEm
                     / CANCELm / REGISTERm
                     / extension-method
extension-method  =  token
Response          =  Status-Line
                     *( message-header )
                     CRLF
                     [ message-body ]

Status-Line     =  SIP-Version SP Status-Code SP Reason-Phrase CRLF
Status-Code     =  Informational
               /   Redirection
               /   Success
               /   Client-Error
               /   Server-Error
               /   Global-Failure
               /   extension-code
extension-code  =  3DIGIT
Reason-Phrase   =  *(reserved / unreserved / escaped
                   / UTF8-NONASCII / UTF8-CONT / SP / HTAB)
```

정보 = "100" ; 시도 중 / "180" ; 벨소리 / "181" ; 통화가 착신전환 중입니다 / "182" ; 대기 중 / "183" ; 세션 진행

---
# **Success  =  "200"  ;  OK**

```text
Redirection  =  "300"  ;  Multiple Choices
            /   "301"  ;  Moved Permanently
            /   "302"  ;  Moved Temporarily
            /   "305"  ;  Use Proxy
            /   "380"  ;  Alternative Service

Client-Error  =  "400"  ;  Bad Request
             /   "401"  ;  Unauthorized
             /   "402"  ;  Payment Required
             /   "403"  ;  Forbidden
             /   "404"  ;  Not Found
             /   "405"  ;  Method Not Allowed
             /   "406"  ;  Not Acceptable
             /   "407"  ;  Proxy Authentication Required
             /   "408"  ;  Request Timeout
             /   "410"  ;  Gone
             /   "413"  ;  Request Entity Too Large
             /   "414"  ;  Request-URI Too Large
             /   "415"  ;  Unsupported Media Type
             /   "416"  ;  Unsupported URI Scheme
             /   "420"  ;  Bad Extension
             /   "421"  ;  Extension Required
             /   "423"  ;  Interval Too Brief
             /   "480"  ;  Temporarily not available
             /   "481"  ;  Call Leg/Transaction Does Not Exist
             /   "482"  ;  Loop Detected
             /   "483"  ;  Too Many Hops
             /   "484"  ;  Address Incomplete
             /   "485"  ;  Ambiguous
             /   "486"  ;  Busy Here
             /   "487"  ;  Request Terminated
             /   "488"  ;  Not Acceptable Here
             /   "491"  ;  Request Pending
             /   "493"  ;  Undecipherable

Server-Error  =  "500"  ;  Internal Server Error
             /   "501"  ;  Not Implemented
             /   "502"  ;  Bad Gateway
             /   "503"  ;  Service Unavailable
             /   "504"  ;  Server Time-out
             /   "505"  ;  SIP Version not supported
             /   "513"  ;  Message Too Large

Global-Failure  =  "600"  ;  Busy Everywhere
               /   "603"  ;  Decline
               /   "604"  ;  Does not exist anywhere
               /   "606"  ;  Not Acceptable

Accept         =  "Accept" HCOLON
                   [ accept-range *(COMMA accept-range) ]
accept-range   =  media-range *(SEMI accept-param)
media-range    =  ( "*/*"
                  / ( m-type SLASH "*" )
                  / ( m-type SLASH m-subtype )
                  ) *( SEMI m-parameter )
accept-param   =  ("q" EQUAL qvalue) / generic-param
qvalue         =  ( "0" [ "." 0*3DIGIT ] )
                  / ( "1" [ "." 0*3("0") ] )
generic-param  =  token [ EQUAL gen-value ]
gen-value      =  token / host / quoted-string

Accept-Encoding  =  "Accept-Encoding" HCOLON
                     [ encoding *(COMMA encoding) ]
encoding         =  codings *(SEMI accept-param)
codings          =  content-coding / "*"
content-coding   =  token

Accept-Language  =  "Accept-Language" HCOLON
                     [ language *(COMMA language) ]
language         =  language-range *(SEMI accept-param)
language-range   =  ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) / "*" )

Alert-Info   =  "Alert-Info" HCOLON alert-param *(COMMA alert-param)
alert-param  =  LAQUOT absoluteURI RAQUOT *( SEMI generic-param )
```

---
# **Allow  =  "Allow" HCOLON [Method *(COMMA Method)]**

```text
Authorization     =  "Authorization" HCOLON credentials
credentials       =  ("Digest" LWS digest-response)
                     / other-response
digest-response   =  dig-resp *(COMMA dig-resp)
dig-resp          =  username / realm / nonce / digest-uri
                      / dresponse / algorithm / cnonce
                      / opaque / message-qop
                      / nonce-count / auth-param
username          =  "username" EQUAL username-value
username-value    =  quoted-string
digest-uri        =  "uri" EQUAL LDQUOT digest-uri-value RDQUOT
digest-uri-value  =  rquest-uri ; Equal to request-uri as specified
                     by HTTP/1.1
message-qop       =  "qop" EQUAL qop-value

cnonce            =  "cnonce" EQUAL cnonce-value
cnonce-value      =  nonce-value
nonce-count       =  "nc" EQUAL nc-value
nc-value          =  8LHEX
dresponse         =  "response" EQUAL request-digest
request-digest    =  LDQUOT 32LHEX RDQUOT
auth-param        =  auth-param-name EQUAL
                     ( token / quoted-string )
auth-param-name   =  token
other-response    =  auth-scheme LWS auth-param
                     *(COMMA auth-param)
auth-scheme       =  token

Authentication-Info  =  "Authentication-Info" HCOLON ainfo
                        *(COMMA ainfo)
ainfo                =  nextnonce / message-qop
                         / response-auth / cnonce
                         / nonce-count
nextnonce            =  "nextnonce" EQUAL nonce-value
response-auth        =  "rspauth" EQUAL response-digest
response-digest      =  LDQUOT *LHEX RDQUOT

Call-ID  =  ( "Call-ID" / "i" ) HCOLON callid
callid   =  word [ "@" word ]

Call-Info   =  "Call-Info" HCOLON info *(COMMA info)
info        =  LAQUOT absoluteURI RAQUOT *( SEMI info-param)
info-param  =  ( "purpose" EQUAL ( "icon" / "info"
               / "card" / token ) ) / generic-param

Contact        =  ("Contact" / "m" ) HCOLON
                  ( STAR / (contact-param *(COMMA contact-param)))
contact-param  =  (name-addr / addr-spec) *(SEMI contact-params)
name-addr      =  [ display-name ] LAQUOT addr-spec RAQUOT
addr-spec      =  SIP-URI / SIPS-URI / absoluteURI
display-name   =  *(token LWS)/ quoted-string

contact-params     =  c-p-q / c-p-expires
                      / contact-extension
c-p-q              =  "q" EQUAL qvalue
c-p-expires        =  "expires" EQUAL delta-seconds
contact-extension  =  generic-param
delta-seconds      =  1*DIGIT

Content-Disposition   =  "Content-Disposition" HCOLON
                         disp-type *( SEMI disp-param )
disp-type             =  "render" / "session" / "icon" / "alert"
                         / disp-extension-token

disp-param            =  handling-param / generic-param
handling-param        =  "handling" EQUAL
                         ( "optional" / "required"
                         / other-handling )
other-handling        =  token
disp-extension-token  =  token

Content-Encoding  =  ( "Content-Encoding" / "e" ) HCOLON
                     content-coding *(COMMA content-coding)

Content-Language  =  "Content-Language" HCOLON
                     language-tag *(COMMA language-tag)
language-tag      =  primary-tag *( "-" subtag )
primary-tag       =  1*8ALPHA
subtag            =  1*8ALPHA

Content-Length  =  ( "Content-Length" / "l" ) HCOLON 1*DIGIT
Content-Type     =  ( "Content-Type" / "c" ) HCOLON media-type
media-type       =  m-type SLASH m-subtype *(SEMI m-parameter)
m-type           =  discrete-type / composite-type
discrete-type    =  "text" / "image" / "audio" / "video"
                    / "application" / extension-token
composite-type   =  "message" / "multipart" / extension-token
extension-token  =  ietf-token / x-token
ietf-token       =  token
x-token          =  "x-" token
m-subtype        =  extension-token / iana-token
iana-token       =  token
m-parameter      =  m-attribute EQUAL m-value
m-attribute      =  token
m-value          =  token / quoted-string
```

---
# **CSeq  =  "CSeq" HCOLON 1*DIGIT LWS Method**

```text
Date          =  "Date" HCOLON SIP-date
SIP-date      =  rfc1123-date
rfc1123-date  =  wkday "," SP date1 SP time SP "GMT"
date1         =  2DIGIT SP month SP 4DIGIT
                 ; day month year (e.g., 02 Jun 1982)
time          =  2DIGIT ":" 2DIGIT ":" 2DIGIT
                 ; 00:00:00 - 23:59:59
wkday         =  "Mon" / "Tue" / "Wed"
                 / "Thu" / "Fri" / "Sat" / "Sun"
month         =  "Jan" / "Feb" / "Mar" / "Apr"
                 / "May" / "Jun" / "Jul" / "Aug"
                 / "Sep" / "Oct" / "Nov" / "Dec"
```

---
# **Error-Info  =  "Error-Info" HCOLON error-uri *(COMMA error-uri)**
---
# **error-uri   =  LAQUOT absoluteURI RAQUOT *( SEMI generic-param )**

```text
Expires     =  "Expires" HCOLON delta-seconds
From        =  ( "From" / "f" ) HCOLON from-spec
from-spec   =  ( name-addr / addr-spec )
               *( SEMI from-param )
from-param  =  tag-param / generic-param
tag-param   =  "tag" EQUAL token
```

---
# **In-Reply-To  =  "In-Reply-To" HCOLON callid *(COMMA callid)**
---
# **Max-Forwards  =  "Max-Forwards" HCOLON 1*DIGIT**
---
# **MIME-Version  =  "MIME-Version" HCOLON 1*DIGIT "." 1*DIGIT**
---
# **Min-Expires  =  "Min-Expires" HCOLON delta-seconds**
---
# **Organization  =  "Organization" HCOLON [TEXT-UTF8-TRIM]**

```text
Priority        =  "Priority" HCOLON priority-value
priority-value  =  "emergency" / "urgent" / "normal"
                   / "non-urgent" / other-priority
other-priority  =  token

Proxy-Authenticate  =  "Proxy-Authenticate" HCOLON challenge
challenge           =  ("Digest" LWS digest-cln *(COMMA digest-cln))
                       / other-challenge
other-challenge     =  auth-scheme LWS auth-param
                       *(COMMA auth-param)
digest-cln          =  realm / domain / nonce
                        / opaque / stale / algorithm
                        / qop-options / auth-param
realm               =  "realm" EQUAL realm-value
realm-value         =  quoted-string
domain              =  "domain" EQUAL LDQUOT URI
                       *( 1*SP URI ) RDQUOT
URI                 =  absoluteURI / abs-path
nonce               =  "nonce" EQUAL nonce-value
nonce-value         =  quoted-string
opaque              =  "opaque" EQUAL quoted-string
stale               =  "stale" EQUAL ( "true" / "false" )
algorithm           =  "algorithm" EQUAL ( "MD5" / "MD5-sess"
                       / token )
qop-options         =  "qop" EQUAL LDQUOT qop-value
                       *("," qop-value) RDQUOT
qop-value           =  "auth" / "auth-int" / token
```

---
# **Proxy-Authorization  =  "Proxy-Authorization" HCOLON credentials**

```text
Proxy-Require  =  "Proxy-Require" HCOLON option-tag
                  *(COMMA option-tag)
option-tag     =  token

Record-Route  =  "Record-Route" HCOLON rec-route *(COMMA rec-route)
rec-route     =  name-addr *( SEMI rr-param )
rr-param      =  generic-param

Reply-To      =  "Reply-To" HCOLON rplyto-spec
rplyto-spec   =  ( name-addr / addr-spec )
                 *( SEMI rplyto-param )
rplyto-param  =  generic-param
Require       =  "Require" HCOLON option-tag *(COMMA option-tag)

Retry-After  =  "Retry-After" HCOLON delta-seconds
                [ comment ] *( SEMI retry-param )

retry-param  =  ("duration" EQUAL delta-seconds)
                / generic-param

Route        =  "Route" HCOLON route-param *(COMMA route-param)
route-param  =  name-addr *( SEMI rr-param )

Server           =  "Server" HCOLON server-val *(LWS server-val)
server-val       =  product / comment
product          =  token [SLASH product-version]
product-version  =  token
```

---
# **Subject  =  ( "Subject" / "s" ) HCOLON [TEXT-UTF8-TRIM]**

```text
Supported  =  ( "Supported" / "k" ) HCOLON
              [option-tag *(COMMA option-tag)]

Timestamp  =  "Timestamp" HCOLON 1*(DIGIT)
               [ "." *(DIGIT) ] [ LWS delay ]
delay      =  *(DIGIT) [ "." *(DIGIT) ]

To        =  ( "To" / "t" ) HCOLON ( name-addr
             / addr-spec ) *( SEMI to-param )
to-param  =  tag-param / generic-param

Unsupported  =  "Unsupported" HCOLON option-tag *(COMMA option-tag)
User-Agent  =  "User-Agent" HCOLON server-val *(LWS server-val)

Via               =  ( "Via" / "v" ) HCOLON via-parm *(COMMA via-parm)
via-parm          =  sent-protocol LWS sent-by *( SEMI via-params )
via-params        =  via-ttl / via-maddr
                     / via-received / via-branch
                     / via-extension
via-ttl           =  "ttl" EQUAL ttl
via-maddr         =  "maddr" EQUAL host
via-received      =  "received" EQUAL (IPv4address / IPv6address)
via-branch        =  "branch" EQUAL token
via-extension     =  generic-param
sent-protocol     =  protocol-name SLASH protocol-version
                     SLASH transport
protocol-name     =  "SIP" / token
protocol-version  =  token
transport         =  "UDP" / "TCP" / "TLS" / "SCTP"
                     / other-transport
sent-by           =  host [ COLON port ]
ttl               =  1*3DIGIT ; 0 to 255

Warning        =  "Warning" HCOLON warning-value *(COMMA warning-value)
warning-value  =  warn-code SP warn-agent SP warn-text
warn-code      =  3DIGIT
warn-agent     =  hostport / pseudonym
                  ;  the name or pseudonym of the server adding
                  ;  the Warning header, for use in debugging
warn-text      =  quoted-string
pseudonym      =  token
```

---
# **WWW-Authenticate  =  "WWW-Authenticate" HCOLON challenge**

```text
extension-header  =  header-name HCOLON header-value
header-name       =  token
header-value      =  *(TEXT-UTF8char / UTF8-CONT / LWS)
message-body  =  *OCTET
```

26 보안 고려 사항: 위협 모델 및 보안 사용 권장 사항

SIP는 보안을 유지하기 쉬운 프로토콜이 아닙니다. 중개자의 사용, 다면적인 신뢰 관계, 전혀 신뢰하지 않는 요소 간의 예상되는 사용 및 사용자 간 작업은 보안을 결코 사소한 것이 아닙니다. 현재 광범위한 조정 없이 다양한 환경과 용도에 배포할 수 있는 보안 솔루션이 필요합니다. 이러한 다양한 요구 사항을 충족하려면 SIP의 다양한 측면과 용도에 적용할 수 있는 몇 가지 고유한 메커니즘이 필요합니다.

SIP 신호 자체의 보안은 RTP와 같은 SIP와 함께 사용되는 프로토콜의 보안이나 SIP가 수행할 수 있는 특정 기관의 보안 영향과 관련이 없습니다\(MIME 보안이 SIP 보안에 중요한 역할을 하지만\). 세션과 연결된 모든 미디어는 연결된 SIP 신호와 관계없이 종단 간 암호화될 수 있습니다. 미디어 암호화는 이 문서의 범위를 벗어납니다.

다음 고려 사항에서는 먼저 SIP의 보안 요구 사항을 광범위하게 식별하는 일련의 고전적인 위협 모델을 조사합니다. 그런 다음 이러한 위협을 해결하는 데 필요한 보안 서비스 집합을 자세히 설명한 다음 이러한 서비스를 제공하는 데 사용할 수 있는 여러 보안 메커니즘에 대해 설명합니다. 다음으로, SIP 보안을 향상시키기 위해 이러한 보안 메커니즘을 사용할 수 있는 예시적인 배포와 함께 SIP 구현자를 위한 요구 사항이 열거됩니다. 개인 정보 보호에 대한 일부 참고 사항이 이 섹션을 마무리합니다.

---
## **26.1 Attacks and Threat Models**

이 섹션에서는 대부분의 SIP 배포에 공통적으로 나타나는 몇 가지 위협에 대해 자세히 설명합니다. 이러한 위협은 SIP에 필요한 각 보안 서비스를 설명하기 위해 특별히 선택되었습니다.

다음 예는 결코 SIP에 대한 완전한 위협 목록을 제공하지 않습니다. 오히려 이는 전체 위협 범주를 잠재적으로 예방할 수 있는 특정 보안 서비스의 필요성을 보여주는 "전통적인" 위협입니다.

이러한 공격은 공격자가 잠재적으로 네트워크의 모든 패킷을 읽을 수 있는 환경을 가정합니다. 즉, SIP가 공용 인터넷에서 자주 사용될 것으로 예상됩니다. 네트워크의 공격자는 패킷을 수정할 수 있습니다\(아마도 일부 손상된 중개자에서\). 공격자는 서비스를 도용하거나 통신을 도청하거나 세션을 방해할 수 있습니다.

---
### **26.1.1 Registration Hijacking**

SIP 등록 메커니즘을 사용하면 사용자 에이전트는 사용자\(기록 주소로 지정됨\)가 위치한 장치로서 등록 기관에 자신을 식별할 수 있습니다. 등록자는 REGISTER 메시지의 From 헤더 필드에 주장된 ID를 평가하여 이 요청이 To 헤더 필드의 레코드 주소와 연관된 연락처 주소를 수정할 수 있는지 여부를 결정합니다. 이 두 필드는 동일한 경우가 많지만 제3자가 사용자를 대신하여 연락처를 등록할 수 있는 유효한 배포가 많이 있습니다.

그러나 SIP 요청의 From 헤더 필드는 UA 소유자가 임의로 수정할 수 있으며 이로 인해 악의적인 등록이 발생할 수 있습니다. 예를 들어, 기록 주소와 관련된 연락처를 변경할 권한이 있는 당사자를 성공적으로 가장한 공격자는 URI에 대한 모든 기존 연락처의 등록을 취소한 다음 자신의 장치를 적절한 연락처 주소로 등록하여 모든 요청을 지시할 수 있습니다. 영향을 받은 사용자를 공격자의 장치로 보냅니다.

이 위협은 요청 작성자의 암호화 보증 부재에 의존하는 위협 계열에 속합니다. 중요한 서비스\(예: SIP 요청을 기존 전화 통화와 연동하는 게이트웨이\)를 나타내는 SIP UAS는 수신하는 요청을 인증하여 리소스에 대한 액세스를 제어할 수 있습니다. SIP 전화와 같은 최종 사용자 UA도 요청을 보낸 사람의 신원을 확인하는 데 관심이 있습니다.

이 위협은 SIP 엔터티가 요청 발신자를 인증할 수 있도록 하는 보안 서비스의 필요성을 보여줍니다.

---
### **26.1.2 Impersonating a Server**

요청이 전달되는 도메인은 일반적으로 Request-URI에 지정됩니다. UA는 일반적으로 요청을 전달하기 위해 이 도메인의 서버에 직접 접속합니다. 그러나 공격자가 원격 서버를 가장할 수 있고 UA의 요청이 다른 당사자에 의해 가로채질 가능성은 항상 존재합니다.

예를 들어, 한 도메인인 Chicago.com의 리디렉션 서버가 다른 도메인인 biloxi.com의 리디렉션 서버를 가장하는 경우를 생각해 보세요. 사용자 에이전트가 biloxi.com에 요청을 보내지만 Chicago.com의 리디렉션 서버는 biloxi.com의 응답에 적합한 SIP 헤더 필드가 있는 위조된 응답으로 응답합니다. 리디렉션 응답의 위조된 연락처 주소는 원래 UA를 부적절하거나 안전하지 않은 리소스로 연결하거나 단순히 biloxi.com에 대한 요청이 성공하지 못하게 할 수 있습니다.

이 위협군은 광범위한 구성원을 보유하고 있으며 그 중 다수는 매우 중요합니다. 등록 하이재킹 위협과 반대로, biloxi.com으로 전송된 등록이 Chicago.com에 의해 차단되고, 차단된 등록에 대해 위조된 301\(영구적으로 이동됨\) 응답으로 응답하는 경우를 생각해 보십시오. 이 응답은 biloxi.com에서 나온 것처럼 보이지만 Chicago.com을 적절한 등록 기관으로 지정합니다. 원래 UA의 모든 향후 REGISTER 요청은 Chicago.com으로 이동됩니다.

이 위협을 예방하려면 UA가 요청을 보내는 서버를 인증할 수 있는 수단이 필요합니다.

---
### **26.1.3 Tampering with Message Bodies**

물론 SIP UA는 신뢰할 수 있는 프록시 서버를 통해 요청을 라우팅합니다. 신뢰가 어떻게 설정되었는지에 관계없이\(프록시 인증은 이 섹션의 다른 부분에서 논의됨\) UA는 요청을 라우팅하기 위해 프록시 서버를 신뢰하지만 해당 요청에 포함된 본문을 검사하거나 수정할 수는 없습니다.

미디어 세션에 대한 세션 암호화 키를 전달하기 위해 SIP 메시지 본문을 사용하는 UA를 생각해 보세요. 신호를 적절하게 전달하기 위해 연결 중인 도메인의 프록시 서버를 신뢰하지만 해당 도메인의 관리자가 후속 미디어 세션의 암호를 해독하는 것을 원하지 않을 수도 있습니다. 더 나쁜 것은 프록시 서버가 적극적으로 악의적인 경우 중간자 역할을 하거나 원래 UA에서 요청한 보안 특성을 변경하여 세션 키를 수정할 수 있다는 것입니다.

이러한 위협 계열은 세션 키뿐만 아니라 SIP에서 종단 간 전달되는 가장 상상할 수 있는 형태의 콘텐츠에도 적용됩니다. 여기에는 사용자에게 렌더링되어야 하는 MIME 본문, SDP 또는 캡슐화된 전화 통신 신호 등이 포함될 수 있습니다. 예를 들어, 공격자는 후속 음성 통신을 도청하기 위해 RTP 미디어 스트림을 도청 장치로 지정하기 위해 SDP 본문을 수정하려고 시도할 수 있습니다.

또한 SIP의 일부 헤더 필드\(예: Subject\)는 엔드투엔드로 의미가 있습니다. UA는 이러한 헤더 필드와 본문을 보호할 수 있습니다. 예를 들어 악의적인 중개자가 제목 헤더 필드를 변경하면 중요한 요청이 스팸으로 표시될 수 있습니다. 그러나 요청이 라우팅될 때 많은 헤더 필드가 프록시 서버에 의해 합법적으로 검사되거나 변경되므로 모든 헤더 필드가 엔드 투 엔드로 보호되어야 하는 것은 아닙니다.

이러한 이유로 UA는 SIP 메시지 본문과 일부 제한된 경우 헤더 필드를 종단 간으로 보호하려고 할 수 있습니다. 신체에 필요한 보안 서비스에는 기밀성, 무결성, 인증이 포함됩니다. 이러한 종단 간 서비스는 프록시 서버와 같은 중개자와의 상호 작용을 보호하는 데 사용되는 수단과 독립적이어야 합니다.

---
### **26.1.4 Tearing Down Sessions**

초기 메시징을 통해 대화가 설정되면 대화 및/또는 세션의 상태를 수정하는 후속 요청이 전송될 수 있습니다. 세션의 주체가 그러한 요청이 공격자에 의해 위조되지 않았음을 확신할 수 있는 것이 중요합니다.

제3자 공격자가 세션의 매개변수\(To 태그, From 태그 등\)를 학습하기 위해 두 당사자가 공유하는 대화 상자에서 일부 초기 메시지를 캡처한 다음 BYE 요청을 세션에 삽입하는 경우를 생각해 보세요. . 공격자는 요청이 두 참가자 중 한 사람에게서 온 것처럼 보이도록 위조할 수 있습니다. 대상이 BYE를 수신하면 세션이 조기에 종료됩니다.

유사한 세션 중간 위협에는 세션을 변경하는 위조된 re-INVITE 전송이 포함됩니다\(세션 보안을 감소시키거나 도청 공격의 ​​일부로 미디어 스트림을 리디렉션하기 위해\).

이 위협에 대한 가장 효과적인 대응 방법은 BYE 보낸 사람을 인증하는 것입니다. 이 경우 수신자는 BYE가 해당 대화가 설정된 동일한 당사자로부터 왔다는 것만 알면 됩니다\(발신자의 절대적인 신원을 확인하는 것과는 대조적\). 또한 기밀성으로 인해 공격자가 세션의 매개변수를 알 수 없는 경우 BYE를 위조하는 것은 불가능합니다. 그러나 일부 중개자\(예: 프록시 서버\)는 세션이 설정될 때 해당 매개변수를 검사해야 합니다.

---
### **26.1.5 Denial of Service and Amplification**

서비스 거부 공격은 일반적으로 해당 인터페이스에 과도한 양의 네트워크 트래픽을 전달하여 특정 네트워크 요소를 사용할 수 없게 만드는 데 중점을 둡니다. 분산 서비스 거부 공격을 사용하면 한 명의 네트워크 사용자가 여러 네트워크 호스트에서 대상 호스트에 대량의 네트워크 트래픽이 넘치도록 할 수 있습니다.

많은 아키텍처에서 SIP 프록시 서버는 전 세계 IP 엔드포인트의 요청을 수락하기 위해 공용 인터넷에 접속합니다. SIP는 SIP 시스템의 구현자와 운영자가 인식하고 해결해야 하는 분산 서비스 거부 공격에 대한 여러 가지 잠재적인 기회를 생성합니다.

공격자는 위조된 소스 IP 주소와 대상 호스트를 요청 발신자로 식별하는 해당 Via 헤더 필드가 포함된 가짜 요청을 생성한 다음 이 요청을 다수의 SIP 네트워크 요소에 보내 불운한 SIP UA 또는 프록시를 사용할 수 있습니다. 대상을 겨냥한 서비스 거부 트래픽을 생성합니다.

마찬가지로, 공격자는 대상 호스트를 식별하는 요청에서 위조된 경로 헤더 필드 값을 사용한 다음 해당 메시지를 대상으로 전송되는 메시지를 증폭시키는 분기 프록시에 보낼 수 있습니다.

Record-Route는 요청에 의해 시작된 SIP 대화가 역방향으로 시작되는 수많은 트랜잭션으로 이어질 것이라고 공격자가 확신하는 경우 비슷한 효과로 사용될 수 있습니다.

REGISTER 요청이 등록기관에 의해 적절하게 인증 및 승인되지 않으면 다양한 서비스 거부 공격이 발생합니다. 공격자는 관리 도메인에서 일부 또는 모든 사용자의 등록을 취소하여 해당 사용자가 새 세션에 초대되지 못하게 할 수 있습니다. 또한 공격자는 서비스 거부 공격에서 등록자 및 관련 프록시 서버를 증폭기로 사용하기 위해 특정 레코드 주소에 대해 동일한 호스트를 지정하는 다수의 연락처를 등록할 수 있습니다. 또한 공격자는 엄청난 수의 바인딩을 등록하여 등록자의 사용 가능한 메모리와 디스크 리소스를 고갈시키려고 시도할 수도 있습니다.

SIP 요청을 전송하기 위해 멀티캐스트를 사용하면 서비스 거부 공격 가능성이 크게 높아질 수 있습니다.

이러한 문제는 서비스 거부 위험을 최소화하는 아키텍처를 정의해야 하는 일반적인 필요성과 이러한 종류의 공격에 대한 보안 메커니즘 권장 사항에 유의해야 할 필요성을 보여줍니다.

---
## **26.2 Security Mechanisms**

위에서 설명한 위협으로부터 SIP 프로토콜에 필요한 기본 보안 서비스는 메시징의 기밀성과 무결성 유지, 재생 공격 또는 메시지 스푸핑 방지, 세션 참가자의 인증 및 개인 정보 보호 제공, 서비스 거부 공격. SIP 메시지 내의 본문에는 기밀성, 무결성 및 인증에 대한 보안 서비스가 별도로 필요합니다.

SIP에 특정한 새로운 보안 메커니즘을 정의하는 대신 SIP는 가능한 경우 HTTP 및 SMTP 공간에서 파생된 기존 보안 모델을 재사용합니다.

메시지의 전체 암호화는 신호의 기밀성을 유지하는 최선의 방법을 제공합니다. 또한 메시지가 악의적인 중개자에 의해 수정되지 않도록 보장할 수도 있습니다. 그러나 SIP 요청이 올바르게 라우팅되도록 하려면 요청-URI, 경로 및 경유와 같은 메시지 필드가 대부분의 네트워크 아키텍처에서 프록시에 표시되어야 하기 때문에 SIP 요청 및 응답은 전체적으로 종단 간 순진하게 암호화될 수 없습니다. SIP가 작동하려면 프록시 서버가 메시지의 일부 기능\(예: Via 헤더 필드 값 추가 등\)을 수정해야 합니다. 따라서 프록시 서버는 SIP UA에 의해 어느 정도 신뢰되어야 합니다. 이를 위해 SIP에 대한 하위 계층 보안 메커니즘이 권장됩니다.

전체 SIP 요청 또는 응답을 홉별로 암호화하여 엔드포인트가 요청을 보내는 프록시 서버의 신원을 확인할 수 있도록 합니다.

또한 SIP 엔터티는 안전한 방식으로 서로를 식별해야 합니다. SIP 엔드포인트가 사용자의 ID를 피어 UA 또는 프록시 서버에 어설션할 때 해당 ID는 어떤 방식으로든 검증 가능해야 합니다. 이 요구 사항을 해결하기 위해 SIP에는 암호화 인증 메커니즘이 제공됩니다.

SIP 메시지 본문에 대한 독립적인 보안 메커니즘은 엔드투엔드 상호 인증의 대체 수단을 제공할 뿐만 아니라 사용자 에이전트가 중개자를 신뢰해야 하는 정도에 대한 제한을 제공합니다.

---
### **26.2.1 Transport and Network Layer Security**

전송 또는 네트워크 계층 보안은 신호 트래픽을 암호화하여 메시지 기밀성과 무결성을 보장합니다.

종종 인증서는 하위 계층 보안 설정에 사용되며 이러한 인증서는 많은 아키텍처에서 인증 수단을 제공하는 데 사용될 수도 있습니다.

전송 및 네트워크 계층에서 보안을 제공하기 위한 두 가지 인기 있는 대안은 각각 TLS\[25\]와 IPSec\[26\]입니다.

IPSec는 기존 IP\(인터넷 프로토콜\)의 보안 대체품으로 집합적으로 사용할 수 있는 네트워크 계층 프로토콜 도구 세트입니다. IPSec는 호스트 또는 관리 도메인 집합이 서로 기존 신뢰 관계를 갖고 있는 아키텍처에서 가장 일반적으로 사용됩니다. IPSec는 일반적으로 호스트의 운영 체제 수준에서 구현되거나 특정 인터페이스\(VPN 아키텍처에서와 같이\)로부터 수신하는 모든 트래픽에 대한 기밀성과 무결성을 제공하는 보안 게이트웨이에서 구현됩니다. IPSec는 홉별\(hop-by-hop\) 기반으로도 사용할 수 있습니다.

많은 아키텍처에서 IPSec은 SIP 애플리케이션과의 통합을 요구하지 않습니다. IPSec는 아마도 SIP 호스트에 직접 보안을 추가하는 것이 어려운 배포에 가장 적합할 것입니다. 첫 번째 홉 프록시 서버와 사전 공유 키잉 관계가 있는 UA도 IPSec를 사용하기에 좋은 후보입니다. SIP용 IPSec 배포에는 SIP 보안에 필요한 프로토콜 도구를 설명하는 IPSec 프로필이 필요합니다. 이 문서에는 그러한 프로필이 제공되지 않습니다.

TLS는 연결 지향 프로토콜\(이 문서에서는 TCP\)을 통해 전송 계층 보안을 제공합니다. "tls"\(TCP를 통한 TLS를 나타냄\)는 Via 헤더 필드 값 또는 SIP-URI 내에서 원하는 전송 프로토콜로 지정할 수 있습니다. TLS는 기존 신뢰 연결이 없는 호스트 간에 홉별 보안이 필요한 아키텍처에 가장 적합합니다. 예를 들어, Alice는 인증서 교환 후 Bob이 신뢰하는 Bob의 로컬 프록시 서버를 신뢰하기로 결정한 로컬 프록시 서버를 신뢰하므로 Bob과 Alice는 안전하게 통신할 수 있습니다.

TLS는 SIP 애플리케이션과 긴밀하게 결합되어야 합니다. 전송 메커니즘은 SIP에서 홉별로 지정되므로 TLS를 통해 프록시 서버에 요청을 보내는 UA는 TLS가 엔드 투 엔드로 사용될 것이라는 보장이 없습니다.

TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA 암호화 모음\[6\]은 TLS가 SIP 애플리케이션에서 사용될 때 구현자가 최소한 지원해야 합니다. 이전 버전과의 호환성을 위해 프록시 서버, 리디렉션 서버 및 등록 기관은 TLS\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA를 지원해야 합니다. 구현자는 다른 암호 모음도 지원할 수 있습니다.\(MUST, SHOULD, MAY\)

---
### **26.2.2 SIPS URI Scheme**

SIPS URI 체계는 SIP URI 구문\(19에 설명됨\)을 준수하지만 체계 문자열은 "sip"이 아닌 "sips"입니다. 그러나 SIPS의 의미는 SIP URI와 매우 다릅니다. SIPS를 사용하면 리소스에 안전하게 도달해야 함을 지정할 수 있습니다.

SIPS URI는 특정 사용자에 대한 레코드 주소로 사용될 수 있습니다. 즉, 사용자가 정식으로 알려진 URI\(명함, 요청의 From 헤더 필드, REGISTER 요청의 To 헤더 필드\)로 사용될 수 있습니다. \). 요청의 요청-URI로 사용되는 경우 SIPS 체계는 요청이 요청-URI의 도메인 부분을 담당하는 SIP 엔터티에 도달할 때까지 요청이 전달되는 각 홉이 TLS로 보호되어야 함을 나타냅니다. 문제의 도메인에 도달하면 로컬 보안 및 라우팅 정책에 따라 처리되며 UAS에 대한 마지막 홉에 TLS를 사용할 가능성이 높습니다. 요청 발신자가 SIPS URI를 대상의 레코드 주소로 사용하는 경우와 같이 사용하는 경우 SIPS는 대상 도메인에 대한 전체 요청 경로가 매우 안전하게 보호되도록 지시합니다.

SIPS 체계는 레코드 주소, 연락처 주소\(REGISTER 방법의 내용을 포함한 연락처 헤더의 내용\)를 포함하여 요청-URI 외에도 현재 SIP에서 SIP URI가 사용되는 다양한 방법에 적용 가능합니다. \) 및 경로 헤더. 각 인스턴스에서 SIPS URI 체계는 이러한 기존 필드를 허용합니다.

보안 리소스를 지정합니다. 이러한 컨텍스트에서 SIPS URI가 역참조되는 방식에는 \[4\]에 자세히 설명된 고유한 보안 속성이 있습니다.

특히 SIPS를 사용하려면 암호화 제품군 TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA를 사용해야 하므로 상호 TLS 인증을 사용해야 합니다. 인증 프로세스에서 수신된 인증서는 클라이언트가 보유한 루트 인증서로 유효성을 검사해야 합니다. 인증서 유효성 검사에 실패하면 요청이 실패해야 합니다.\(SHOULD, SHOULD\)

- SIPS URI 체계에서 전송은 TLS와 독립적이므로 "sips:alice@atlanta.com;transport=tcp" 및 "sips:alice@atlanta.com;transport=sctp"는 모두 유효합니다\(단, UDP는 SIPS에 대한 유효한 전송이 아닙니다. 결과적으로 "transport=tls" 사용은 요청의 단일 홉에만 국한되었기 때문에 더 이상 사용되지 않습니다. 이는 RFC 2543 이후 변경된 사항입니다.

SIPS URI를 기록 주소로 배포하는 사용자는 안전하지 않은 전송을 통한 요청을 거부하는 장치를 작동하도록 선택할 수 있습니다.

---
### **26.2.3 HTTP Authentication**

SIP는 401 및 407 응답 코드와 챌린지 및 자격 증명을 전달하기 위한 헤더 필드를 사용하는 HTTP 인증을 기반으로 하는 챌린지 기능을 제공합니다. 큰 수정 없이 SIP에서 HTTP 다이제스트 인증 체계를 재사용하면 재생 보호 및 단방향 인증이 가능합니다.

SIP에서 다이제스트 인증의 사용법은 섹션 22에 자세히 설명되어 있습니다.

---
### **26.2.4 S/MIME**

위에서 논의한 바와 같이, 기밀 유지를 위해 전체 SIP 메시지를 종단 간 암호화하는 것은 적절하지 않습니다. 왜냐하면 네트워크 중개자\(예: 프록시 서버\)가 메시지를 올바르게 라우팅하기 위해 특정 헤더 필드를 확인해야 하고 이러한 중개자가 대상에서 제외되는 경우이기 때문입니다. 보안 연결이 이루어지지 않으면 SIP 메시지는 기본적으로 라우팅이 불가능해집니다.

그러나 S/MIME을 사용하면 SIP UA가 SIP 내의 MIME 본문을 암호화하여 메시지 헤더에 영향을 주지 않고 이러한 본문을 엔드 투 엔드로 보호할 수 있습니다. S/MIME은 메시지 본문에 대한 엔드투엔드 기밀성과 무결성은 물론 상호 인증도 제공할 수 있습니다. S/MIME을 사용하여 SIP 메시지 터널링을 통해 SIP 헤더 필드에 대한 무결성 및 기밀성을 제공할 수도 있습니다.

SIP에서 S/MIME의 사용법은 섹션 23에 자세히 설명되어 있습니다.

---
## **26.3 Implementing Security Mechanisms**
---
### **26.3.1 Requirements for Implementers of SIP**

프록시 서버, 리디렉션 서버 및 등록 기관은 TLS를 구현해야 하며 상호 인증과 단방향 인증을 모두 지원해야 합니다\(MUST\). UA가 TLS를 시작할 수 있도록 강력히 권장합니다. UA는 TLS 서버 역할도 할 수 있습니다. 프록시 서버, 리디렉션 서버 및 등록자는 주체가 정식 호스트 이름과 일치하는 사이트 인증서를 보유해야 합니다. UA는 TLS와의 상호 인증을 위해 자체 인증서를 가질 수 있지만 이 문서에는 해당 사용에 대한 조항이 명시되어 있지 않습니다. TLS를 지원하는 모든 SIP 요소에는 TLS 협상 중에 수신된 인증서를 검증하기 위한 메커니즘이 있어야 합니다. 이는 인증 기관\(웹 브라우저용 루트 인증서를 발행하는 것과 유사한 사이트 인증서의 잘 알려진 배포자가 바람직함\)에서 발행한 하나 이상의 루트 인증서를 소유하는 것을 수반합니다.\(MUST, SHOULD, SHOULD, MAY, MUST\)

TLS를 지원하는 모든 SIP 요소는 SIPS URI 체계도 지원해야 합니다.\(MUST\)

프록시 서버, 리디렉션 서버, 등록자 및 UA도 IPSec 또는 기타 하위 계층 보안 프로토콜을 구현할 수 있습니다.\(MAY\)

UA가 프록시 서버, 리디렉션 서버 또는 등록 기관에 접속을 시도할 때 UAC는 SIP 메시지를 보낼 TLS 연결을 시작해야 합니다. 일부 아키텍처에서는 UAS가 TLS 연결을 통해서도 요청을 받을 수 있습니다.\(SHOULD, MAY\)

프록시 서버, 리디렉션 서버, 등록자 및 UA는 22에서 요구되는 모든 측면을 포함하는 다이제스트 인증을 구현해야 합니다. 프록시 서버, 리디렉션 서버 및 등록자는 최소한 하나의 다이제스트 영역과 하나 이상의 "영역" 문자열로 구성되어야 합니다. 특정 서버에서 지원하는 이름은 서버의 호스트 이름 또는 도메인 이름과 일치해야 합니다.\(MUST, SHOULD\)

UA는 섹션 23에 설명된 대로 MIME 본문의 서명 및 암호화와 S/MIME을 통한 자격 증명 전송을 지원할 수 있습니다. UA가 TLS 또는 IPSec에 대한 인증서의 유효성을 검사하기 위해 인증 기관의 루트 인증서를 하나 이상 보유하는 경우 다음과 같아야 합니다. 적절하게 S/MIME 인증서를 확인하기 위해 이를 재사용할 수 있습니다. UA는 S/MIME 인증서 검증을 위해 특별히 루트 인증서를 보유할 수 있습니다.\(MAY, SHOULD, MAY\)

- S/MIME 구현이 나타나고 문제 공간이 더 잘 이해됨에 따라 향후 보안 확장이 S/MIME과 관련된 규범적 강도를 업그레이드할 수 있을 것으로 예상됩니다.

---
### **26.3.2 Security Solutions**

이러한 보안 메커니즘의 작동은 기존 웹 및 이메일 보안 모델을 어느 정도 따를 수 있습니다. 높은 수준에서 UA는 다이제스트 사용자 이름과 비밀번호를 사용하여 서버\(프록시 서버, 리디렉션 서버 및 등록자\)에 자신을 인증합니다. 서버는 TLS에서 제공하는 사이트 인증서를 사용하여 한 홉 떨어진 UA에 인증하거나 한 홉 떨어진 다른 서버에\(또는 그 반대\) 자신을 인증합니다.

P2P 수준에서 UA는 일반적으로 서로를 인증하기 위해 네트워크를 신뢰합니다. 그러나 네트워크가 그렇지 않거나 네트워크 자체를 신뢰할 수 없는 경우 S/MIME을 사용하여 직접 인증을 제공할 수도 있습니다.

다음은 섹션 26.1에 설명된 종류의 위협을 방지하기 위해 다양한 UA 및 서버에서 이러한 보안 메커니즘을 사용하는 예시입니다. 구현자와 네트워크 관리자는 이 섹션의 나머지 부분에 제공된 규범적 지침을 따를 수 있지만 이는 예시 구현으로만 제공됩니다.\(MAY\)

---
#### **26.3.2.1 Registration**

UA가 온라인 상태가 되어 로컬 관리 도메인에 등록할 때 등록자와 TLS 연결을 설정해야 합니다\(섹션 10에서는 UA가 등록자에 도달하는 방법을 설명합니다\). 등록 기관은 UA에 인증서를 제공해야 하며, 인증서로 식별된 사이트는 UA가 등록하려는 도메인과 일치해야 합니다. 예를 들어, UA가 기록 주소 'alice@atlanta.com'을 등록하려는 경우 사이트 인증서는 atlanta.com 도메인 내의 호스트\(예: sip.atlanta.com\)를 식별해야 합니다. TLS 인증서 메시지를 수신하면 UA는 인증서를 확인하고 인증서로 식별된 사이트를 검사해야 합니다. 인증서가 유효하지 않거나 취소되거나 적절한 당사자를 식별하지 못하는 경우 UA는 REGISTER 메시지를 전송해서는 안 되며 그렇지 않으면 등록을 진행해야 합니다.\(SHOULD, MUST, SHOULD, MUST NOT\)

- 등록기관이 유효한 인증서를 제공한 경우 UA는 등록기관이 UA를 리디렉션하거나 비밀번호를 도용하거나 유사한 공격을 시도할 수 있는 공격자가 아니라는 것을 알고 있습니다.

그런 다음 UA는 등록자로부터 받은 사이트 인증서에 해당하는 Request-URI로 주소가 지정되어야 하는 REGISTER 요청을 생성합니다. UA가 기존 TLS 연결을 통해 REGISTER 요청을 보낼 때 등록자는 401\(프록시 인증 필요\) 응답으로 요청에 도전해야 합니다. 응답의 Proxy-Authenticate 헤더 필드 내의 "realm" 매개변수는 사이트 인증서에서 이전에 제공한 도메인과 일치해야 합니다. UAC가 챌린지를 수신하면 사용자에게 자격 증명을 묻는 메시지를 표시하거나 챌린지의 "realm" 매개 변수에 해당하는 키링에서 적절한 자격 증명을 가져와야 합니다. 이 자격 증명의 사용자 이름은 REGISTER 요청의 To 헤더 필드에 있는 URI의 "userinfo" 부분과 일치해야 합니다. Digest 자격 증명이 적절한 Proxy-Authorization 헤더 필드에 삽입되면 REGISTER를 등록 기관에 다시 제출해야 합니다.\(SHOULD, SHOULD, SHOULD, SHOULD, SHOULD\)

- 등록자는 사용자 에이전트가 자신을 인증하도록 요구하므로 공격자가 사용자의 레코드 주소에 대한 REGISTER 요청을 위조하는 것은 어렵습니다. 또한 REGISTER는 기밀 TLS 연결을 통해 전송되므로 공격자는 가능한 재생 공격에 대한 자격 증명을 기록하기 위해 REGISTER를 가로챌 수 없습니다.

등록자가 등록을 승인하면 등록자가 이 관리 도메인의 사용자를 위해 요청을 보내는 프록시 서버 역할도 하는 경우 UA는 이 TLS 연결을 열어 두어야 합니다. 기존 TLS 연결은 방금 등록이 완료된 UA에 들어오는 요청을 전달하는 데 재사용됩니다.\(SHOULD\)

- UA가 이미 TLS 연결 반대편의 서버를 인증했기 때문에 이 연결을 통해 들어오는 모든 요청은 프록시 서버를 통과한 것으로 알려져 있습니다. 공격자는 해당 프록시 서버를 통해 전송된 것처럼 보이는 스푸핑된 요청을 생성할 수 없습니다. .

---
#### **26.3.2.2 Interdomain Requests**

이제 Alice의 UA가 "bob@biloxi.com"이라는 원격 관리 도메인의 사용자와 세션을 시작하려고 한다고 가정해 보겠습니다. 또한 로컬 관리 도메인\(atlanta.com\)에는 로컬 아웃바운드 프록시가 있다고 하겠습니다.

관리 도메인에 대한 인바운드 요청을 처리하는 프록시 서버는 로컬 아웃바운드 프록시 역할도 할 수 있습니다. 단순화를 위해 atlanta.com의 경우라고 가정하겠습니다\(그렇지 않으면 사용자 에이전트가 이 시점에서 별도의 서버에 대한 새 TLS 연결을 시작합니다\). 클라이언트가 등록을 완료했다고 가정\(MAY\)

이전 섹션에서 설명한 프로세스에서는 다른 사용자에게 INVITE 요청을 보낼 때 로컬 프록시 서버에 대한 TLS 연결을 재사용해야 합니다. UA는 사용자에게 불필요하게 메시지를 표시하는 것을 피하기 위해 INVITE에서 캐시된 자격 증명을 재사용해야 합니다.\(SHOULD, SHOULD\)

로컬 아웃바운드 프록시 서버가 INVITE에서 UA가 제공한 자격 증명의 유효성을 검사한 경우 Request-URI를 검사하여 메시지 라우팅 방법을 결정해야 합니다\(\[4\] 참조\). 요청-URI의 "domainname" 부분이 biloxi.com이 아닌 로컬 도메인\(atlanta.com\)에 해당하는 경우 프록시 서버는 요청된 사용자에게 가장 적합한 방법을 결정하기 위해 위치 서비스를 참조했을 것입니다.\(SHOULD\)

"alice@atlanta.com"이 연락을 시도했다면,

- "alex@atlanta.com", 로컬 프록시는 Alex가 등록할 때 등록 대행자와 설정한 TLS 연결에 대한 요청을 프록시 처리했을 것입니다. Alex는 인증된 채널을 통해 이 요청을 수신하므로 Alice의 요청이 로컬 관리 도메인의 프록시 서버에 의해 승인되었음을 확신할 수 있습니다.

그러나 이 경우 Request-URI는 원격 도메인을 지정합니다. 따라서 atlanta.com의 로컬 아웃바운드 프록시 서버는 biloxi.com의 원격 프록시 서버와 TLS 연결을 설정해야 합니다. 이 TLS 연결의 참가자는 모두 사이트 인증서를 소유한 서버이므로 상호 TLS 인증이 발생해야 합니다. 연결의 각 측은 상대방의 인증서를 확인하고 검사해야 하며, SIP 메시지의 헤더 필드와 비교하기 위해 인증서에 나타나는 도메인 이름을 기록해야 합니다. 예를 들어 atlanta.com 프록시 서버는 이 단계에서 원격 측에서 받은 인증서가 biloxi.com 도메인과 일치하는지 확인해야 합니다. 일단 그렇게 하고 TLS 협상이 완료되어 두 프록시 사이에 보안 채널이 생성되면 atlanta.com 프록시는 INVITE 요청을 biloxi.com으로 전달할 수 있습니다.\(SHOULD, SHOULD, SHOULD, SHOULD\)

biloxi.com의 프록시 서버는 atlanta.com의 프록시 서버 인증서를 차례로 검사하고 INVITE 요청의 From 헤더 필드에 있는 "domainname" 부분과 인증서가 주장하는 도메인을 비교해야 합니다. 빌록시 프록시는 프록시된 관리 도메인과 일치하지 않는 요청을 거부하도록 요구하는 엄격한 보안 정책을 가질 수 있습니다.\(SHOULD, MAY\)

- 이러한 보안 정책은 스팸을 생성하는 데 자주 악용되는 SMTP '오픈 릴레이'에 해당하는 SIP를 방지하기 위해 제정될 수 있습니다.

그러나 이 정책은 요청이 자신에게 할당된 도메인에서 왔다는 것만 보장합니다. 이는 biloxi.com이 atlanta.com이 Alice를 인증한 방법을 확인하는 것을 허용하지 않습니다. biloxi.com이 atlanta.com의 인증 정책을 알 수 있는 다른 방법이 있는 경우에만 Alice가 자신의 신원을 어떻게 증명했는지 확인할 수 있습니다. 그런 다음 biloxi.com은 관리상 알려지지 않은 도메인에서 오는 요청이 biloxi.com과 공통 인증 정책을 공유하는 것을 금지하는 더욱 엄격한 정책을 도입할 수 있습니다.

INVITE가 biloxi 프록시에 의해 승인되면 프록시 서버는 이 요청의 대상 사용자\(이 경우 "bob@biloxi.com"\)와 연결된 기존 TLS 채널\(있는 경우\)을 식별해야 합니다. INVITE는 이 채널을 통해 Bob에게 프록시 처리되어야 합니다. 이전에 biloxi 프록시로 인증된 TLS 연결을 통해 요청이 수신되었으므로 Bob은 From 헤더 필드가 변조되지 않았으며 atlanta.com이 Alice의 유효성을 검사했음을 알고 있지만 Alice의 신원을 신뢰할지 여부는 반드시 그런 것은 아닙니다.\(SHOULD\)

요청을 전달하기 전에 두 프록시 서버 모두 요청에 Record-Route 헤더 필드를 추가하여 이 대화 상자의 모든 향후 요청이 프록시 서버를 통과하도록 해야 합니다. 따라서 프록시 서버는 이 대화의 수명 동안 보안 서비스를 계속 제공할 수 있습니다. 프록시 서버가 Record-Route에 자신을 추가하지 않으면 향후 메시지는 보안 서비스 없이 Alice와 Bob 사이에서 직접 종단 간 전달됩니다\(두 당사자가 S와 같은 일부 독립적인 종단 간 보안에 동의하지 않는 한\). /몸짓 광대극\). 이러한 점에서 SIP 사다리꼴 모델은 사이트 프록시 간의 합의 규칙이 Alice와 Bob 사이에 합리적으로 안전한 채널을 제공할 수 있는 멋진 구조를 제공할 수 있습니다.\(SHOULD\)

- 예를 들어 이 아키텍처를 노리는 공격자는 BYE 요청을 위조하여 Bob과 Alice 사이의 신호 스트림에 삽입할 수 없습니다. 공격자는 세션의 매개변수를 확인할 방법이 없고 무결성 메커니즘이 전이적으로 작동하기 때문입니다. Alice와 Bob 사이의 트래픽을 보호합니다.

---
#### **26.3.2.3 Peer-to-Peer Requests**

또는 로컬 아웃바운드 프록시가 없는 "carol@chicago.com" ID를 주장하는 UA를 고려해 보세요. Carol이 "bob@biloxi.com"으로 INVITE를 보내려고 할 때, 그녀의 UA는 biloxi 프록시와의 TLS 연결을 직접 시작해야 합니다\(주어진 Request-URI에 도달하는 최선의 방법을 결정하기 위해 \[4\]에 설명된 메커니즘을 사용함\). . 그녀의 UA가 biloxi 프록시로부터 인증서를 수신하면 TLS 연결을 통해 INVITE를 전달하기 전에 정상적으로 확인되어야 합니다. 하지만 Carol은 증명할 수단이 없습니다.\(SHOULD, SHOULD\)

그녀의 신원은 빌록시 프록시에 있지만 INVITE의 "메시지/sip" 본문에 CMS 분리 서명이 있습니다. 이 경우 Carol은 biloxi.com과 공식적으로 연관되어 있지 않기 때문에 biloxi.com 영역에 자격 증명을 보유할 가능성은 거의 없습니다. 또한 biloxi 프록시는 From 헤더 필드의 "domainname" 부분에 biloxi.com이 없는 요청에 도전하지 못하도록 하는 엄격한 정책을 가질 수도 있습니다. 이러한 사용자는 인증되지 않은 사용자로 처리됩니다.\(MAY\)

biloxi 프록시에는 인증되지 않은 모든 요청이 'bob@biloxi.com'에 등록된 적절한 연락처 주소, 즉 <sip:bob@192.0.2.4\>로 리디렉션되어야 한다는 Bob에 대한 정책이 있습니다. Carol은 빌록시 프록시와 설정한 TLS 연결을 통해 리디렉션 응답을 수신하므로 연락처 주소의 정확성을 신뢰합니다.

그런 다음 Carol은 지정된 주소로 TCP 연결을 설정하고 수신된 연락처 주소가 포함된 Request-URI와 함께 새로운 INVITE를 보내야 합니다\(요청이 준비되면 본문의 서명을 다시 계산함\). Bob은 안전하지 않은 인터페이스에서 이 INVITE를 받지만 그의 UA는 요청의 From 헤더 필드를 검사하고 인식한 후 로컬로 캐시된 인증서를 INVITE 본문의 서명에 표시된 인증서와 일치시킵니다. 그는 유사한 방식으로 응답하여 Carol에게 자신을 인증하고 보안 대화가 시작됩니다.\(SHOULD\)

- 때때로 관리 도메인의 방화벽이나 NAT로 인해 UA에 대한 직접 TCP 연결 설정이 불가능할 수 있습니다. 이러한 경우 프록시 서버는 로컬 정책에 따라 신뢰에 영향을 주지 않는 방식\(예: 기존 TLS 연결을 포기하고 일반 텍스트 TCP를 통해 요청을 전달\)으로 요청을 UA에 전달할 수도 있습니다.

---
#### **26.3.2.4 DoS Protection**

이러한 보안 솔루션을 사용하는 아키텍처에 대한 서비스 거부 공격 위험을 최소화하려면 구현자는 다음 지침에 유의해야 합니다.

SIP 프록시 서버가 작동하는 호스트가 공용 인터넷에서 라우팅 가능한 경우 방어적인 운영 정책\(소스 라우팅 트래픽 차단, 바람직하게는 핑 트래픽 필터링\)을 사용하여 관리 도메인에 배포해야 합니다. TLS와 IPSec 모두 보안 터널과 소켓을 집계하기 위해 보안 연결에 참여하는 관리 도메인의 가장자리에 있는 배스천 호스트를 사용할 수도 있습니다. 또한 이러한 요새 호스트는 서비스 거부 공격을 정면으로 받아 관리 도메인 내의 SIP 호스트가 불필요한 메시징으로 방해받지 않도록 할 수 있습니다.\(SHOULD\)

어떤 보안 솔루션을 배포하더라도 프록시 서버로 전달되는 메시지의 홍수로 인해 프록시 서버 리소스가 잠기고 원하는 트래픽이 대상에 도달하지 못할 수 있습니다. 프록시 서버에서 SIP 트랜잭션을 처리하는 것과 관련된 계산 비용이 있으며, 해당 비용은 상태 비저장 프록시 서버보다 상태 저장 프록시 서버의 경우 더 큽니다. 따라서 상태 저장 프록시는 상태 비저장 프록시 서버보다 플러딩에 더 취약합니다.

UA 및 프록시 서버는 단일 401\(무단\) 또는 407\(프록시 인증 필요\)만으로 의심스러운 요청에 도전해야 하며, 일반적인 응답 재전송 알고리즘을 포기하고 인증되지 않은 요청에 대해 상태 비저장 상태로 작동해야 합니다.\(SHOULD\)

- 401\(권한 없음\) 또는 407\(프록시 인증 필요\) 상태 응답을 재전송하면 공격자가 위조된 헤더 필드 값\(예: Via\)을 사용하여 트래픽을 제3자에게 전달하는 문제가 증폭됩니다.

요약하면 TLS와 같은 메커니즘을 통한 프록시 서버의 상호 인증은 악의적인 중개자가 서비스를 거부할 수 있는 위조된 요청이나 응답을 도입할 가능성을 크게 줄입니다. 이에 따라 공격자가 무고한 SIP 노드를 증폭 에이전트로 만드는 것이 더 어려워집니다.

---
## **26.4 Limitations**

이러한 보안 메커니즘을 신중하게 적용하면 많은 위협을 막을 수 있지만 구현자와 네트워크 운영자가 이해해야 하는 메커니즘의 범위에는 제한이 있습니다.

---
### **26.4.1 HTTP Digest**

SIP에서 HTTP 다이제스트를 사용할 때의 주요 제한 사항 중 하나는 다이제스트의 무결성 메커니즘이 SIP에 대해 잘 작동하지 않는다는 것입니다. 특히 요청-URI 및 메시지 방법에 대한 보호를 제공하지만 UA가 보안을 가장 원하는 헤더 필드에 대해서는 보호하지 않습니다.

RFC 2617에 설명된 기존 재생 보호 메커니즘에도 SIP에 대한 몇 가지 제한 사항이 있습니다. 예를 들어 next-nonce 메커니즘은 파이프라인 요청을 지원하지 않습니다. 재생 보호를 위해 nonce-count 메커니즘을 사용해야 합니다.

HTTP Digest의 또 다른 제한 사항은 영역 범위입니다. 다이제스트는 사용자가 서비스와 같이 기존 연결이 있는 리소스에 대해 자신을 인증하려고 할 때 유용합니다.

사용자가 고객인 공급자\(이는 매우 일반적인 시나리오이므로 Digest는 매우 유용한 기능을 제공합니다\). 대조적으로 TLS의 범위는 도메인 간 또는 다중 영역입니다. 인증서는 종종 전역적으로 검증 가능하므로 UA는 기존 연결 없이 서버를 인증할 수 있습니다.

---
### **26.4.2 S/MIME**

S/MIME 메커니즘의 가장 큰 눈에 띄는 결함은 최종 사용자를 위한 일반적인 공개 키 인프라가 부족하다는 것입니다. 자체 서명된 인증서\(또는 대화 참가자 중 한 명이 확인할 수 없는 인증서\)를 사용하는 경우 섹션 23.2에 설명된 SIP 기반 키 교환 메커니즘은 메시지 가로채기\(man-in-the-middle\) 공격에 취약합니다. 공격자는 잠재적으로 S/MIME 본문을 검사하고 수정할 수 있습니다. 공격자는 대화 상자에서 두 당사자 간의 첫 번째 키 교환을 가로채고, 요청 및 응답에서 기존 CMS 분리 서명을 제거하고, 공격자가 제공한 인증서가 포함된 다른 CMS 분리 서명을 삽입해야 합니다\(그러나 이는 올바른 기록 주소에 대한 인증서여야 함\). 각 당사자는 실제로는 공격자의 공개 키를 각자 갖고 있지만 서로 키를 교환했다고 생각합니다.

공격자는 두 당사자 간의 첫 번째 키 교환에서만 이 취약점을 활용할 수 있다는 점에 유의하는 것이 중요합니다. 이후에는 키 변경이 UA에 눈에 띌 것입니다. 공격자가 시간이 지남에 따라\(잠재적으로 며칠, 몇 주 또는 몇 년이 지날 때\) 두 당사자 간의 모든 향후 대화 경로에 머무르는 것도 어려울 것입니다.

SSH는 첫 번째 키 교환에서 동일한 중간자 공격에 취약합니다. 그러나 SSH가 완벽하지는 않지만 연결 보안을 향상시킨다는 사실은 널리 알려져 있습니다. 키 지문을 사용하면 SSH와 마찬가지로 SIP에도 어느 정도 도움이 될 수 있습니다. 예를 들어 두 당사자가 SIP를 사용하여 음성 통신 세션을 설정하는 경우 각 당사자는 상대방으로부터 받은 키의 지문을 판독하여 원본과 비교할 수 있습니다. 중간자가 신호를 보내는 것보다 참가자의 목소리를 모방하는 것이 확실히 더 어려울 것입니다\(Clipper 칩 기반 보안 전화에서 사용되는 방식\).

S/MIME 메커니즘을 사용하면 UA가 키링에 대상 레코드 주소에 대한 인증서를 보유하고 있는 경우 프리앰블 없이 암호화된 요청을 보낼 수 있습니다. 그러나 레코드 주소에 등록된 특정 장치는 해당 장치의 현재 사용자가 이전에 사용한 인증서를 보유하지 않으므로 인증서를 처리하지 못할 수도 있습니다.

요청이 제대로 암호화되어 피할 수 있는 오류 신호가 발생할 수 있습니다. 특히 암호화된 요청이 포크될 때 이런 일이 발생할 가능성이 높습니다.

S/MIME과 연결된 키는 장치\(UA\)보다는 특정 사용자\(레코드 주소\)와 연결될 때 가장 유용합니다. 사용자가 장치 간에 이동할 때 UA 간에 개인 키를 안전하게 전송하는 것이 어려울 수 있습니다. 장치에서 이러한 키를 획득하는 방법은 이 문서의 범위를 벗어납니다.

S/MIME 메커니즘의 또 다른 일반적인 어려움은 특히 섹션 23.4에 설명된 SIP 터널링 메커니즘을 사용할 때 매우 큰 메시지가 발생할 수 있다는 것입니다. 이러한 이유로 S/MIME 터널링을 사용할 때는 TCP를 전송 프로토콜로 사용하는 것이 좋습니다.\(SHOULD\)

---
### **26.4.3 TLS**

TLS에 대해 가장 일반적으로 제기되는 우려는 TLS가 UDP를 통해 실행될 수 없다는 것입니다. TLS에는 연결 지향 기본 전송 프로토콜이 필요하며, 이 문서에서는 TCP를 의미합니다.

또한 로컬 아웃바운드 프록시 서버 및/또는 등록 기관이 수많은 UA와 동시에 여러 개의 장기 TLS 연결을 유지하는 것이 어려울 수 있습니다. 이로 인해 특히 집약적인 암호화 제품군의 경우 몇 가지 유효한 확장성 문제가 발생합니다. 특히 UA가 연결 설정을 단독으로 담당하는 경우 수명이 긴 TLS 연결의 중복성을 유지하는 것도 번거로울 수 있습니다.

TLS는 SIP 엔터티가 인접한 서버만 인증하도록 허용합니다. TLS는 엄격한 홉별 보안을 제공합니다. TLS나 이 문서에 지정된 다른 메커니즘은 클라이언트가 직접 TCP 연결을 형성할 수 없는 프록시 서버를 인증하는 것을 허용하지 않습니다.

---
### **26.4.4 SIPS URIs**

실제로 요청 경로의 모든 세그먼트에서 TLS를 사용하려면 TLS를 통해 종료 UAS에 연결할 수 있어야 합니다\(SIPS URI를 연락처 주소로 등록\). 이것이 SIPS의 기본 용도입니다. 그러나 많은 유효한 아키텍처는 TLS를 사용하여 요청 경로의 일부를 보호하지만 예를 들어 UAS에 대한 최종 홉에는 다른 메커니즘을 사용합니다. 따라서 SIPS는 TLS 사용이 실제로 종단 간임을 보장할 수 없습니다. 많은 UA가 들어오는 TLS 연결을 허용하지 않기 때문에 TLS를 지원하는 UA라도 UAS로서 TLS를 통해 요청을 수신하려면 위의 TLS 제한 섹션에 설명된 대로 지속적인 TLS 연결을 유지해야 할 수 있습니다.

SIPS 요청-URI에 대한 SIPS 바인딩을 제공하는 데 위치 서비스가 필요하지 않습니다. 위치 서비스는 일반적으로 사용자 등록\(섹션 10.2.1에 설명된 대로\)으로 채워지지만 다양한 다른 프로토콜과 인터페이스가 AOR에 대한 연락처 주소를 제공할 수 있으며 이러한 도구는 SIPS URI를 SIP URI에 적절하게 매핑할 수 있습니다. 바인딩을 쿼리하면 위치 서비스는 SIPS 요청-URI가 포함된 요청을 받았는지 여부에 관계없이 연락처 주소를 반환합니다. 리디렉션 서버가 위치 서비스에 액세스하는 경우 연락처 주소의 적합성을 결정하는 것은 리디렉션의 연락처 헤더 필드를 처리하는 엔터티에 달려 있습니다.

대상 도메인까지의 모든 요청 세그먼트에 TLS가 사용되도록 보장하는 것은 다소 복잡합니다. 비준수 또는 손상된 방식으로 암호화 인증된 프록시 서버가 SIPS와 관련된 전달 규칙\(및 섹션 16.6의 일반 전달 규칙\)을 무시하도록 선택할 수 있습니다. 예를 들어, 이러한 악의적인 중개자는 보안을 다운그레이드하기 위해 SIPS URI의 요청 대상을 SIP URI로 변경할 수 있습니다.

또는 중개자가 SIP에서 SIPS URI로 요청의 대상을 합법적으로 변경할 수 있습니다. 따라서 요청-URI가 SIPS URI 체계를 사용하는 요청의 수신자는 요청-URI만으로는 전체 요청 경로\(클라이언트부터\)에 SIPS가 사용되었다고 가정할 수 없습니다.

이러한 문제를 해결하기 위해 요청 URI에 SIP 또는 SIPS URI가 포함된 요청의 수신자는 To 헤더 필드 값을 검사하여 SIPS URI가 포함되어 있는지 확인하는 것이 좋습니다. 이 URI는 동일한 체계를 가지지만 To 헤더 필드의 URI와 동일하지 않습니다. 클라이언트는 요청의 Request-URI 및 To 헤더 필드를 다르게 채우도록 선택할 수 있지만 SIPS를 사용할 때 이러한 불일치는 보안 위반 가능성으로 해석될 수 있으며 결과적으로 수신자가 요청을 거부할 수 있습니다. 수신자는 로컬 관리 도메인에 도달할 때까지 전체 요청 경로에 TLS가 사용되었는지 여부를 다시 확인하기 위해 Via 헤더 체인을 검사할 수도 있습니다. S/MIME은 원래 UAC에서 To 헤더 필드의 원래 형식이 종단 간 전달되도록 보장하는 데 사용될 수도 있습니다.\(SHOULD, MAY\)

UAS가 Request-URI의 체계가 전송 중에 부적절하게 수정되었다고 믿을 만한 이유가 있는 경우 UA는 사용자에게 잠재적인 보안 위반을 알려야 합니다.\(SHOULD\)

다운그레이드 공격을 방지하기 위한 추가 조치로 SIPS 요청만 수락하는 엔터티는 안전하지 않은 포트에서의 연결도 거부할 수 있습니다.\(MAY\)

최종 사용자는 의심할 여지 없이 SIPS와 SIP URI의 차이를 식별할 것이며 자극에 반응하여 수동으로 편집할 수도 있습니다. 이는 보안에 도움이 될 수도 있고 저하될 수도 있습니다. 예를 들어 공격자가 프록시 서버에 대한 모든 SIPS 레코드를 효과적으로 제거하는 가짜 레코드 세트를 삽입하여 DNS 캐시를 손상시킨 경우 이 프록시 서버를 통과하는 모든 SIPS 요청이 실패할 수 있습니다. 그러나 사용자가 SIPS AOR에 대한 반복 호출이 실패하는 것을 확인하면 일부 장치에서 구성표를 SIPS에서 SIP로 수동으로 변환하고 다시 시도할 수 있습니다. 물론 이에 대한 몇 가지 보호 장치가 있지만\(대상 UA가 실제로 편집증적인 경우 SIPS가 아닌 모든 요청을 거부할 수 있음\) 이는 주목할 만한 제한 사항입니다. 긍정적인 측면에서는 사용자가 SIP URI만 표시되는 경우에도 'SIPS'가 유효할 것이라고 생각할 수도 있습니다.

---
## **26.5 Privacy**

SIP 메시지에는 발신자에 대한 중요한 정보\(말해야 하는 내용뿐만 아니라 누구와 통신하는지, 언제, 얼마나 오랫동안 통신하는지, 세션에 참여하는 장소\)에 대한 민감한 정보가 포함되는 경우가 많습니다. 많은 애플리케이션과 해당 사용자는 이러한 종류의 개인 정보를 알 필요가 없는 당사자에게 숨겨야 한다고 요구합니다.

개인 정보가 공개될 수 있는 덜 직접적인 방법도 있다는 점에 유의하세요. 사용자나 서비스가 개인의 이름과 조직 소속\(대부분의 기록 주소를 설명함\)으로 추측할 수 있는 주소로 연결하기로 선택한 경우, 목록에 없는 "전화번호"를 보유하여 개인정보를 보호하는 전통적인 방법이 손상됩니다. 사용자 위치 서비스는 발신자에게 특정 소재를 공개함으로써 세션 초대 수신자의 개인정보를 침해할 수 있습니다. 결과적으로 구현은 사용자별로 특정 클래스의 발신자에게 제공되는 위치 및 가용성 정보의 종류를 제한할 수 있어야 합니다. 이는 진행 중인 SIP 작업에서 추가로 연구될 것으로 예상되는 전체 문제 유형입니다.\(SHOULD\)

어떤 경우에는 사용자가 신원을 전달하는 헤더 필드에 개인 정보를 숨기고 싶어할 수도 있습니다. 이는 요청 발신자를 나타내는 From 및 관련 헤더뿐만 아니라 To에도 적용될 수 있습니다. 최종 목적지에 단축 다이얼링 별명 또는 대상 그룹에 대한 확장되지 않은 식별자를 전달하는 것은 적절하지 않을 수 있습니다. 둘 중 하나는 요청이 라우팅될 때 Request-URI에서 제거되지만 To에서는 변경되지 않습니다.

두 항목이 처음에 동일한 경우 헤더 필드입니다. 따라서 개인 정보 보호를 위해 Request-URI와 다른 To 헤더 필드를 생성하는 것이 바람직할 수 있습니다.\(MAY\)

---
# **27 IANA Considerations**

SIP 애플리케이션에 사용되는 모든 메서드 이름, 헤더 필드 이름, 상태 코드 및 옵션 태그는 RFC의 IANA 고려 사항 섹션에 있는 지침을 통해 IANA에 등록됩니다.

사양은 IANA에게 http://www.iana.org/locationments/sip-parameters 아래에 옵션 태그, 경고 코드\(경고 코드\), 메서드 및 응답 코드 등 4개의 새로운 하위 레지스트리를 생성하도록 지시합니다. 이미 존재하는 헤더 필드의 레지스트리입니다.

---
## **27.1 Option Tags**

이 사양은 http://www.iana.org/designments/sip-parameters 아래에 Option Tags 하위 레지스트리를 설정합니다.

옵션 태그는 확장에 대한 SIP 호환성 메커니즘을 지원하기 위해 Require, Supported, Proxy-Require 및 Unsupported와 같은 헤더 필드에 사용됩니다\(섹션 19.2\). 옵션 태그 자체는 특정 SIP 옵션\(즉, 확장 프로그램\)과 연결된 문자열입니다. SIP 끝점에 대한 옵션을 식별합니다.

옵션 태그는 표준 추적 RFC에 게시될 때 IANA에 의해 등록됩니다. RFC의 IANA 고려 사항 섹션에는 출판물의 RFC 번호와 함께 IANA 레지스트리에 나타나는 다음 정보가 포함되어야 합니다.

- o 옵션 태그의 이름입니다. 이름의 길이는 제한되지 않지만 20자를 초과할 수 없습니다. 이름은 영숫자\(섹션 25\) 문자로만 구성되어야 합니다.\(SHOULD, MUST\)

- o 확장을 설명하는 설명 텍스트입니다.

---
## **27.2 Warn-Codes**

이 사양은 http://www.iana.org/locationments/sip-parameters 아래에 Warn-codes 하위 레지스트리를 설정하고 섹션 20.43에 나열된 경고 코드로 채우기를 시작합니다. 추가 경고 코드는 RFC 간행물에 의해 등록됩니다.

경고 코드 표에 대한 설명 텍스트는 다음과 같습니다.

경고 코드는 트랜잭션 실패가 SDP\(Session Description Protocol\)\(RFC 2327 \[1\]\) 문제로 인해 발생한 경우 SIP 응답 메시지의 상태 코드에 대한 추가 정보를 제공합니다.

"경고 코드"는 세 자리 숫자로 구성됩니다. 첫 번째 숫자 "3"은 SIP 관련 경고를 나타냅니다. 향후 사양에서 3xx 이외의 경고 코드 사용을 설명할 때까지 3xx 경고 코드만 등록할 수 있습니다.

경고 300부터 329까지는 세션 설명에서 키워드에 문제가 있음을 나타내기 위해 예약되어 있고, 330부터 339까지는 세션 설명에서 요청한 기본 네트워크 서비스와 관련된 경고이고, 370부터 379까지는 세션 설명에서 요청한 정량적 QoS 매개변수와 관련된 경고이고, 390은 399부터 399까지는 위 범주 중 하나에 속하지 않는 기타 경고입니다.

---
## **27.3 Header Field Names**

이로 인해 http://www.iana.org/locationments/sip-parameters 아래의 헤더 하위 레지스트리에 대한 IANA 지침이 더 이상 사용되지 않습니다.

새 헤더 필드 이름을 등록하려면 RFC 발행물에 다음 정보를 제공해야 합니다.

```text
      o  The RFC number in which the header is registered;

      o  the name of the header field being registered;

      o  a compact form version for that header field, if one is
         defined;
```

일반적이고 널리 사용되는 일부 헤더 필드에는 한 글자로 된 압축 형식이 할당될 수 있습니다\(섹션 7.3.3\). 압축 양식은 SIP 작업 그룹 검토 후 RFC 게시 후에만 할당할 수 있습니다.\(MAY\)

---
## **27.4 Method and Response Codes**

이 사양은 http://www.iana.org/locationments/sip-parameters 아래에 방법 및 응답 코드 하위 레지스트리를 설정하고 다음과 같이 채우기를 시작합니다. 초기 방법 테이블은 다음과 같습니다.

```text
         INVITE                   [RFC3261]
         ACK                      [RFC3261]
         BYE                      [RFC3261]
         CANCEL                   [RFC3261]
         REGISTER                 [RFC3261]
         OPTIONS                  [RFC3261]
         INFO                     [RFC2976]
```

응답 코드 테이블은 처음에 섹션 21의 정보, 성공, 리디렉션, 클라이언트 오류, 서버 오류 및 전역 오류로 표시된 부분으로 채워집니다. 테이블의 형식은 다음과 같습니다.

```text
      Type (e.g., Informational)
            Number    Default Reason Phrase         [RFC3261]
```

새 응답 코드나 메서드를 등록하려면 RFC 간행물에 다음 정보를 제공해야 합니다.

```text
      o  The RFC number in which the method or response code is
         registered;

      o  the number of the response code or name of the method being
         registered;

      o  the default reason phrase for that response code, if
         applicable;
```

---
## **27.5 The "message/sip" MIME type.**

이 문서는 주로 종단 간 보안 목적으로 SIP 메시지가 SIP 내의 본문으로 터널링될 수 있도록 "message/sip" MIME 미디어 유형을 등록합니다. 이 미디어 유형은 다음 정보로 정의됩니다.

```text
      Media type name: message
      Media subtype name: sip
      Required parameters: none
```

선택적 매개변수: 버전

- 버전: 포함된 메시지의 SIP 버전 번호\(예: "2.0"\)입니다. 존재하지 않는 경우 버전은 기본적으로 "2.0"으로 설정됩니다. 인코딩 체계: SIP 메시지는 선택적으로 바이너리 MIME 데이터 개체가 뒤따르는 8비트 헤더로 구성됩니다. 따라서 SIP 메시지는 바이너리로 처리되어야 합니다. 일반적인 상황에서 SIP 메시지는 바이너리 지원 전송을 통해 전송되므로 특별한 인코딩이 필요하지 않습니다.

보안 고려 사항: 아래 참조

- S/MIME과 함께 보안 메커니즘으로 사용되는 동기와 예는 23.4에 나와 있습니다.

---
## **27.6 New Content-Disposition Parameter Registrations**

이 문서는 또한 네 가지 새로운 Content-Disposition 헤더 "disposition-types"\(경고, 아이콘, 세션 및 렌더링\)을 등록합니다. 작성자는 이러한 값을 콘텐츠 처리에 대한 IANA 레지스트리에 기록하도록 요청합니다.

동기와 예를 포함하여 이러한 "처분 유형"에 대한 설명은 섹션 20.11에 나와 있습니다.

IANA 레지스트리에 적합한 간단한 설명은 다음과 같습니다.

```text
      alert     the body is a custom ring tone to alert the user
      icon      the body is displayed as an icon to the user
      render    the body should be displayed to the user
      session   the body describes a communications session, for
                example, as RFC 2327 SDP body
```

---
# **28 Changes From RFC 2543**

이 RFC는 RFC 2543을 개정합니다. 대부분 RFC 2543과 역호환됩니다. 여기에 설명된 변경 사항은 RFC 2543에서 발견된 많은 오류를 수정하고 RFC 2543에 자세히 설명되지 않은 시나리오에 대한 정보를 제공합니다. 여기서 프로토콜은 보다 깔끔하게 계층화된 모델로 제시되었습니다.

우리는 상호 운용성 또는 경우에 따라 올바른 작동에 영향을 미치는 RFC 2543의 실질적인 변경인 기능적 동작과 RFC 2543과 다르지만 상호 운용성 문제의 잠재적 원인이 아닌 기능적 동작으로 차이점을 구분합니다. 여기에 문서화되지 않은 수많은 설명도 있었습니다.

---
## **28.1 Major Functional Changes**

o UAC가 통화에 응답하기 전에 통화를 종료하려는 경우 CANCEL을 보냅니다. 원래 INVITE가 여전히 2xx를 반환하면 UAC는 BYE를 보냅니다. BYE는 기존 호출 구간\(이제 이 RFC에서는 대화라고 함\)에서만 보낼 수 있지만 RFC 2543에서는 언제든지 보낼 수 있습니다.

o SIP BNF는 RFC 2234를 준수하도록 변환되었습니다.

o SIP URL BNF가 더욱 일반화되어 사용자 부분에 더 많은 문자 집합을 허용합니다. 또한 비교 규칙은 기본적으로 대소문자를 구분하지 않도록 단순화되었으며 매개변수가 있는 경우 비교를 자세히 처리하는 방법이 설명되었습니다. 가장 중요한 변화는 기본값이 있는 매개변수가 있는 URI가 해당 매개변수가 없는 URI와 일치하지 않는다는 것입니다.

o Via 숨기기를 제거했습니다. 난독화 프로세스를 수행하기 위해 다음 홉에 의존했기 때문에 심각한 신뢰 문제가 있었습니다. 대신 Via 숨기기는 상태 저장 프록시에서 로컬 구현 선택으로 수행될 수 있으므로 더 이상 문서화되지 않습니다.

o RFC 2543에서는 CANCEL 및 INVITE 트랜잭션이 혼합되었습니다. 그들은 지금 분리되었습니다. 사용자가 INVITE를 보낸 다음 CANCEL을 보내면 INVITE 트랜잭션은 여전히 ​​정상적으로 종료됩니다. UAS는 487 응답으로 원래 INVITE 요청에 응답해야 합니다.

o 마찬가지로 CANCEL 및 BYE 트랜잭션이 혼합되었습니다. RFC 2543에서는 BYE가 수신될 때 UAS가 INVITE에 대한 응답을 보내지 않도록 허용했습니다. 여기서는 허용되지 않습니다. 원래 INVITE에는 응답이 필요합니다.

o RFC 2543에서 UA는 UDP만 지원해야 했습니다. 이 RFC에서 UA는 UDP와 TCP를 모두 지원해야 합니다.

o RFC 2543에서 포크 프록시는 여러 문제가 발생할 경우 다운스트림 요소에서 하나의 문제만 전달했습니다. 이 RFC에서 프록시는 모든 문제를 수집하여 전달된 응답에 배치해야 합니다.

o 다이제스트 자격 증명에서는 URI를 인용해야 합니다. 이는 둘 다 일관성이 없는 RFC 2617 및 RFC 2069에서 명확하지 않습니다.

o SDP 처리는 별도의 사양으로 분할되었으며\[13\] SIP를 통해 효과적으로 터널링되는 공식적인 제안/응답 교환 프로세스로 더욱 완벽하게 지정되었습니다. 기본 SIP 구현을 위해 INVITE/200 또는 200/ACK에서 SDP가 허용됩니다. RFC 2543에서는 단일 트랜잭션의 INVITE, 200 및 ACK에서 이를 사용할 수 있는 기능을 암시했지만 이는 잘 지정되지 않았습니다. 확장에서는 더 복잡한 SDP 사용이 허용됩니다.

o URI 및 Via 헤더 필드에 IPv6에 대한 전체 지원이 추가되었습니다. Via에서 IPv6을 지원하려면 헤더 필드 매개변수에서 대괄호와 콜론 문자를 허용해야 합니다. 이전에는 이러한 문자가 허용되지 않았습니다. 이론적으로 이는 이전 구현에서 상호 운용성 문제를 일으킬 수 있습니다. 그러나 우리는 대부분의 구현이 이러한 매개변수에 비제어 ASCII 문자를 허용한다는 것을 관찰했습니다.

o DNS SRV 절차는 이제 별도의 사양에 문서화되어 있습니다\[4\]. 이 절차에서는 SRV 및 NAPTR 리소스 레코드를 모두 사용하며 RFC 2543에 설명된 대로 더 이상 SRV 레코드 전체의 데이터를 결합하지 않습니다.

o 루프 감지는 선택 사항이 되었으며 Max-Forwards의 필수 사용으로 대체되었습니다. RFC 2543의 루프 감지 절차에는 그렇지 않은 경우에도 "나선형"을 오류 조건으로 보고하는 심각한 버그가 있었습니다. 선택적 루프 감지 절차는 여기에서 더 완전하고 정확하게 지정됩니다.

o 이제 태그 사용은 대화 상자 식별의 기본 구성 요소이므로 필수입니다\(RFC 2543에서는 선택 사항임\).

o 클라이언트가 서버에 지원되는 확장을 표시할 수 있도록 지원 헤더 필드를 추가했습니다. 이를 통해 해당 확장을 응답에 적용하고 응답에 Require를 사용하여 사용법을 표시할 수 있습니다.

o 여러 헤더 필드에 대한 확장 매개변수가 BNF에서 누락되어 추가되었습니다.

o 경로 및 기록 경로 건설 처리가 매우

- RFC 2543에 과소 지정되어 있으며 올바른 접근 방식도 아닙니다. 이 사양에서는 상당히 재작업되었으며\(그리고 훨씬 더 단순해졌습니다\), 이것이 아마도 가장 큰 변화일 것입니다. 초기 요청에 Record-Route 외부에서 어떤 방식으로 얻은 Route 헤더 필드 값 세트가 있는 "사전 로드된 경로"를 사용하지 않는 배포에는 이전 버전과의 호환성이 계속 제공됩니다. 이러한 상황에서는 새 메커니즘이 상호 운용되지 않습니다.

o RFC 2543에서는 메시지의 줄이 CR, LF 또는 CRLF로 끝날 수 있습니다. 이 사양에서는 CRLF만 허용합니다.

o CANCEL 및 ACK의 경로 사용은 RFC 2543에 잘 정의되어 있지 않습니다. 이제 잘 지정되었습니다. 요청에 경로 헤더 필드가 있는 경우 요청에 대한 2xx가 아닌 응답에 대한 CANCEL 또는 ACK는 동일한 경로 헤더 필드 값을 전달해야 합니다. 2xx 응답에 대한 ACK는 2xx 응답의 Record-Route에서 학습된 경로 값을 사용합니다.

o RFC 2543은 단일 UDP 패킷에서 여러 요청을 허용했습니다. 이 사용법은 제거되었습니다.

o Expires 헤더 필드 및 매개변수에서 절대 시간 사용이 제거되었습니다. 이는 시간이 동기화되지 않은 요소에서 상호 운용성 문제를 일으키는데, 이는 흔히 발생하는 일입니다. 대신 상대 시간이 사용됩니다.

o Via 헤더 필드 값의 분기 매개변수는 이제

- 모든 요소를 ​​사용하려면 필수입니다. 이제 고유한 거래 식별자 역할을 합니다. 이렇게 하면 RFC 2543의 복잡하고 버그가 많은 트랜잭션 식별 규칙을 피할 수 있습니다. 이전 홉이 매개변수를 전역적으로 고유하게 만들었는지 확인하기 위해 매개변수 값에 매직 쿠키가 사용되며, 매개변수가 없으면 이전 규칙으로 비교가 대체됩니다. . 따라서 상호 운용성이 보장됩니다.

o RFC 2543에서는 TCP 연결 종료가 취소와 동일해졌습니다. 이는 프록시 간의 TCP 연결에 대해 구현하는 것이 거의 불가능했으며 잘못되었습니다. 이는 제거되어 TCP 연결 상태와 SIP 처리 간에 결합이 없습니다.

o RFC 2543은 UA가 새로운 서비스를 시작할 수 있는지 여부에 대해 언급하지 않았습니다.

- 다른 피어가 진행 중인 동안 피어와의 트랜잭션. 이제 여기에 지정되었습니다. INVITE 이외의 요청에는 허용되며 INVITE에는 허용되지 않습니다.

o PGP가 제거되었습니다. 충분히 지정되지 않았으며 더 완전한 PGP MIME과 호환되지 않습니다. S/MIME으로 대체되었습니다.

o 엔드투엔드 TLS를 위한 "sips" URI 체계가 추가되었습니다. 이 체계는 이전 버전인 RFC 2543과 호환되지 않습니다. 요청-URI의 SIPS URI 체계로 요청을 수신하는 기존 요소는 요청을 거부할 가능성이 높습니다. 이것은 실제로 기능입니다. 이는 모든 경로 홉이 보호될 수 있는 경우에만 SIPS URI에 대한 호출이 전달되도록 보장합니다.

o 추가 보안 기능이 TLS에 추가되었으며 이는 훨씬 더 크고 완전한 보안 고려 사항 섹션에 설명되어 있습니다.

o RFC 2543에서는 임시 응답을 101에서 199 업스트림으로 전달하는 데 프록시가 필요하지 않았습니다. 이는 MUST로 변경되었습니다. 많은 후속 기능이 101에서 199까지의 모든 임시 응답 전달에 의존하기 때문에 이는 중요합니다.\(MUST\)

o RFC 2543의 503 응답 코드에 대해서는 알려진 바가 거의 없습니다. 이후 이 코드는 프록시의 오류 또는 과부하 조건을 나타내는 데 실질적으로 사용되는 것으로 나타났습니다. 이를 위해서는 다소 특별한 처리가 필요합니다. 특히 503을 수신하면 DNS SRV 조회 결과의 다음 요소에 연결하려는 시도가 트리거되어야 합니다. 또한 503 응답은 특정 조건에서만 프록시에 의해 업스트림으로 전달됩니다.

o RFC 2543은 서버의 UA 인증 메커니즘을 정의했지만 충분히 지정하지 않았습니다. 그것은 제거되었습니다. 대신 RFC 2617의 상호 인증 절차가 허용됩니다.

o UA는 초기 INVITE에 대한 ACK를 수신할 때까지 통화에 대한 BYE를 보낼 수 없습니다. 이는 RFC 2543에서 허용되었지만 잠재적인 경쟁 조건이 발생할 수 있습니다.

o UA 또는 프록시는 요청에 대한 임시 응답을 받을 때까지 거래에 대한 CANCEL을 보낼 수 없습니다. 이는 RFC 2543에서 허용되었지만 잠재적인 경쟁 조건이 발생할 수 있습니다.

o 등록의 작업 매개변수는 더 이상 사용되지 않습니다. 유용한 서비스를 제공하기에는 부족했고, 프록시에서 애플리케이션 처리를 적용할 때 충돌이 발생했습니다.

o RFC 2543에는 멀티캐스트에 대한 특별한 경우가 많이 있었습니다. 예를 들어 특정 응답이 억제되고 타이머가 조정되는 등의 작업이 있었습니다. 이제 멀티캐스트는 더욱 제한된 역할을 수행하며 프로토콜 작동은 유니캐스트와 달리 멀티캐스트 사용에 영향을 받지 않습니다. 그 결과로 인한 제한 사항이 문서화되어 있습니다.

o 기본 인증이 완전히 제거되어 사용이 금지되었습니다.

o 프록시는 더 이상 6xx를 수신하자마자 즉시 전달하지 않습니다. 대신 보류 중인 분기를 즉시 취소합니다. 이렇게 하면 UAC가 6xx에 이어 2xx를 받게 되는 잠재적인 경쟁 조건을 방지할 수 있습니다. 이 경쟁 조건을 제외한 모든 경우에 결과는 동일합니다. 즉, 6xx가 업스트림으로 전달됩니다.

o RFC 2543은 요청 병합 문제를 다루지 않았습니다. 이는 요청이 프록시에서 분기되고 나중에 요소에서 다시 조인될 때 발생합니다. 병합 처리는 UA에서만 이루어지며 첫 번째 요청을 제외한 모든 요청을 거부하는 절차가 정의되어 있습니다.

---
## **28.2 Minor Functional Changes**

o 사용자에게 선택적 콘텐츠 표시를 위한 Alert-Info, Error-Info 및 Call-Info 헤더 필드를 추가했습니다.

o Content-Language, Content-Disposition 및 MIME-Version 헤더 필드를 추가했습니다.

o 양 당사자가 동시에 서로에게 re-INVITE를 보내는 경우를 처리하기 위해 "눈부심 처리" 메커니즘을 추가했습니다. 새로운 491\(요청 보류 중\) 오류 코드를 사용합니다.

o 나중에 부재중 전화 또는 메시지 반환을 지원하기 위해 In-Reply-To 및 Reply-To 헤더 필드를 추가했습니다.

o 유효한 SIP 전송으로 TLS 및 SCTP를 추가했습니다.

o 통화 중 언제든지 오류를 처리하기 위한 다양한 메커니즘이 설명되어 있습니다. 이제는 일반적으로 통합되었습니다. 종료하려면 BYE가 전송됩니다.

o RFC 2543에서는 TCP를 통한 INVITE 응답의 재전송을 의무화했지만 실제로는 2xx에만 필요하다고 언급했습니다. 이는 프로토콜 계층화가 부족하여 발생한 결과였습니다. 여기에 정의된 보다 일관된 트랜잭션 레이어를 사용하면 더 이상 필요하지 않습니다. INVITE에 대한 2xx 응답만 TCP를 통해 재전송됩니다.

o 클라이언트 및 서버 트랜잭션 시스템은 이제 재전송 횟수가 아닌 시간 초과를 기준으로 구동됩니다. 이를 통해 TCP 및 UDP에 대해 상태 머신을 적절하게 지정할 수 있습니다.

o 날짜 헤더 필드는 사용자 에이전트에서 날짜 자동 구성을 위한 간단한 수단을 제공하기 위해 REGISTER 응답에 사용됩니다.

o 등록기관이 기간이 너무 짧은 등록을 거부할 수 있도록 허용했습니다. 이를 위해 423 응답 코드와 최소 만료 시간을 정의했습니다.

---
# **29 Normative References**

\[1\] Handley, M. 및 V. Jacobson, "SDP: 세션 설명

- 프로토콜", RFC 2327, 1998년 4월.

\[2\] Bradner, S., "요구 사항 수준을 나타 내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

```text
   [3]  Resnick, P., "Internet Message Format", RFC 2822, April 2001.
```

\[4\] Rosenberg, J. 및 H. Schulzrinne, "SIP: SIP 서버 찾기", RFC 3263, 2002년 6월.

\[5\] Berners-Lee, T., Fielding, R. 및 L. Masinter, "URI\(Uniform Resource Identifier\): 일반 구문", RFC 2396, 1998년 8월.

\[6\] Chown, P., "TLS\(전송 계층 보안\)를 위한 AES\(고급 암호화 표준\) 암호 제품군", RFC 3268, 2002년 6월.

\[7\] Yergeau, F., "UTF-8, ISO 10646의 변환 형식", RFC 2279, 1998년 1월.

\[8\] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, "하이퍼텍스트 전송 프로토콜 - HTTP/1.1", RFC 2616, 1999년 6월.

\[9\] Vaha-Sipila, A., "전화 통화용 URL", RFC 2806, 2000년 4월.

\[10\] Crocker, D. 및 P. Overell, "구문을 위한 증강된 BNF

- 사양: ABNF", RFC 2234, 1997년 11월.

\[11\] Freed, F. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 2부: 미디어 유형", RFC 2046, 1996년 11월.

\[12\] Eastlake, D., Crocker, S. 및 J. Schiller, "무작위성"

- 보안에 대한 권장 사항", RFC 1750, 1994년 12월.

\[13\] Rosenberg, J. 및 H. Schulzrinne, "SDP를 사용한 제안/응답 모델", RFC 3264, 2002년 6월.

```text
   [14] Postel, J., "User Datagram Protocol", STD 6, RFC 768, August
        1980.

   [15] Postel, J., "DoD Standard Transmission Control Protocol", RFC
        761, January 1980.
```

\[16\] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L. 및 V. Paxson, "스트림 제어 전송 프로토콜", RFC 2960, 2000년 10월.

\[17\] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A. 및 L. Stewart, "HTTP 인증: 기본 및 다이제스트 액세스 인증", RFC 2617, 1999년 6월.

\[18\] Troost, R., Dorner, S. 및 K. Moore, "인터넷 메시지에서 프레젠테이션 정보 전달: 콘텐츠 처리 헤더 필드", RFC 2183, 1997년 8월.

\[19\] Zimmerer, E., Peterson, J., Vemuri, A., Ong, L., Audet, F., Watson, M. 및 M. Zonoun, "ISUP 및 QSIG 개체에 대한 MIME 미디어 유형", RFC 3204 , 2001년 12월.

\[20\] Braden, R., "인터넷 호스트 요구 사항 - 응용 프로그램 및 지원", STD 3, RFC 1123, 1989년 10월.

\[21\] Alvestrand, H., "문자 집합 및 언어에 대한 IETF 정책", BCP 18, RFC 2277, 1998년 1월.

\[22\] Galvin, J., Murphy, S., Crocker, S. 및 N. Freed, "MIME용 보안 멀티파트: 멀티파트/서명 및 멀티파트/암호화", RFC 1847, 1995년 10월.

```text
   [23] Housley, R., "Cryptographic Message Syntax", RFC 2630, June
        1999.

   [24] Ramsdell B., "S/MIME Version 3 Message Specification", RFC 2633,
        June 1999.
```

\[25\] Dierks, T. 및 C. Allen, "TLS 프로토콜 버전 1.0", RFC 2246, 1999년 1월.

\[26\] Kent, S. 및 R. Atkinson, "인터넷 프로토콜을 위한 보안 아키텍처", RFC 2401, 1998년 11월.

---
# **30 Informative References**

\[27\] R. Pandya, "신흥 모바일 및 개인 통신 시스템", IEEE Communications Magazine, Vol. 33, 44\~52페이지, 1995년 6월.

\[28\] Schulzrinne, H., Casner, S., Frederick, R. 및 V. Jacobson, "RTP: 실시간 애플리케이션을 위한 전송 프로토콜", RFC 1889, 1996년 1월.

\[29\] Schulzrinne, H., Rao, R. 및 R. Lanphier, "실시간 스트리밍 프로토콜\(RTSP\)", RFC 2326, 1998년 4월.

\[30\] Cuervo, F., Greene, N., Rayhan, A., Huitema, C., Rosen, B. 및 J. Segers, "Megaco 프로토콜 버전 1.0", RFC 3015, 2000년 11월.

\[31\] Handley, M., Schulzrinne, H., Schooler, E. 및 J. Rosenberg, "SIP: 세션 시작 프로토콜", RFC 2543, 1999년 3월.

\[32\] Hoffman, P., Masinter, L. 및 J. Zawinski, "mailto URL 체계", RFC 2368, 1998년 7월.

\[33\] E. M. Schooler, "멀티캐스트 사용자 디렉토리 서비스

- 동기식 랑데부," 석사 논문 CS-TR-96-18, 캘리포니아 공과대학 컴퓨터 과학부, 캘리포니아주 패서디나, 1996년 8월.

```text
   [34] Donovan, S., "The SIP INFO Method", RFC 2976, October 2000.

   [35] Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321, April
        1992.
```

\[36\] Dawson, F. 및 T. Howes, "vCard MIME 디렉터리 프로필", RFC 2426, 1998년 9월.

```text
   [37] Good, G., "The LDAP Data Interchange Format (LDIF) - Technical
        Specification", RFC 2849, June 2000.

   [38] Palme, J., "Common Internet Message Headers",  RFC 2076,
        February 1997.
```

\[39\] 프랭크스, J., 할람-베이커, P., 호스테틀러, J., 리치, P.,

- Luotonen, A., Sink, E. 및 L. Stewart, "HTTP 확장: 다이제스트 액세스 인증", RFC 2069, 1997년 1월.

\[40\] Johnston, A., Donovan, S., Sparks, R., Cunningham, C., Willis, D., Rosenberg, J., Summers, K. 및 H. Schulzrinne, "SIP 통화 흐름 예", 작업 진행 중.

\[41\] E. M. Schooler, "사례 연구: 패킷 교환 원격 회의 시스템의 멀티미디어 회의 제어", Journal of Internetworking: Research and Experience, Vol. 4, pp. 99-120, 1993년 6월. ISI 재인쇄 시리즈 ISI/RS-93-359.

\[42\] H. Schulzrinne, "인터넷의 멀티미디어 서비스를 위한 개인 이동성", 대화형 분산 멀티미디어 시스템 및 서비스\(IDMS\)에 관한 유럽 워크숍, \(독일 베를린\), 1996년 3월.

```text
   [43] Floyd, S., "Congestion Control Principles", RFC 2914, September
        2000.
```

---
# **A Table of Timer Values**

표 4는 이 사양에서 사용되는 다양한 타이머의 의미와 기본값을 요약합니다.

```text
Timer    Value            Section               Meaning
----------------------------------------------------------------------
T1       500ms default    Section 17.1.1.1     RTT Estimate
T2       4s               Section 17.1.2.2     The maximum retransmit
                                               interval for non-INVITE
                                               requests and INVITE
                                               responses
T4       5s               Section 17.1.2.2     Maximum duration a
                                               message will
                                               remain in the network
Timer A  initially T1     Section 17.1.1.2     INVITE request retransmit
                                               interval, for UDP only
Timer B  64*T1            Section 17.1.1.2     INVITE transaction
                                               timeout timer
Timer C  > 3min           Section 16.6         proxy INVITE transaction
                           bullet 11            timeout
Timer D  > 32s for UDP    Section 17.1.1.2     Wait time for response
         0s for TCP/SCTP                       retransmits
Timer E  initially T1     Section 17.1.2.2     non-INVITE request
                                               retransmit interval,
                                               UDP only
Timer F  64*T1            Section 17.1.2.2     non-INVITE transaction
                                               timeout timer
Timer G  initially T1     Section 17.2.1       INVITE response
                                               retransmit interval
Timer H  64*T1            Section 17.2.1       Wait time for
                                               ACK receipt
Timer I  T4 for UDP       Section 17.2.1       Wait time for
         0s for TCP/SCTP                       ACK retransmits
Timer J  64*T1 for UDP    Section 17.2.2       Wait time for
         0s for TCP/SCTP                       non-INVITE request
                                               retransmits
Timer K  T4 for UDP       Section 17.1.2.2     Wait time for
         0s for TCP/SCTP                       response retransmits

                   Table 4: Summary of timers
```

---
# **Acknowledgments**

IETF MMUSIC 및 SIP WG 회원들의 의견과 제안에 감사드립니다. Ofir Arkin, Brian Bidulock, Jim Buller, Neil Deason, Dave Devanathan, Keith Drage, Bill Fenner, Cedric Fluckiger, Yaron Goland, John Hearty, Bernie Hoeneisen, Jo Hornsby, Phil Hoffer, Christian Huitema, Hisham Khartabil, Jean Jervis, Gadi Karmi, Peter Kjellerstedt, Anders Kristensen, Jonathan Lennox, Gethin Liddell, Allison Mankin, William Marshall, Rohan Mahy, Keith Moore, Vern Paxson, Bob Penfield, Moshe J. Sambol, Chip Sharp, Igor Slepchin, Eric Tremblay, 그리고 릭 워크맨.

Brian Rosen은 컴파일된 BNF를 제공했습니다.

Jean Mahoney는 기술적인 글쓰기 지원을 제공했습니다.

이 작업은 특히 \[41,42\]를 기반으로 합니다.

---
# **Authors' Addresses**

저자 주소는 RFC 2543의 편집자, 작성자, 원저자를 알파벳순으로 나열합니다. 나열된 모든 저자는 이 문서에 적극적으로 많은 양의 텍스트를 제공했습니다.

```text
   Jonathan Rosenberg
   dynamicsoft
   72 Eagle Rock Ave
   East Hanover, NJ 07936
   USA

   EMail:  jdrosen@dynamicsoft.com
```

Henning Schulzrinne 컴퓨터 과학과 Columbia University 1214 Amsterdam Avenue New York, NY 10027 USA

```text
   EMail:  schulzrinne@cs.columbia.edu

   Gonzalo Camarillo
   Ericsson
   Advanced Signalling Research Lab.
   FIN-02420 Jorvas
   Finland

   EMail:  Gonzalo.Camarillo@ericsson.com

   Alan Johnston
   WorldCom
   100 South 4th Street
   St. Louis, MO 63102
   USA

   EMail:  alan.johnston@wcom.com

   Jon Peterson
   NeuStar, Inc
   1800 Sutter Street, Suite 570
   Concord, CA 94520
   USA

   EMail:  jon.peterson@neustar.com

   Robert Sparks
   dynamicsoft, Inc.
   5100 Tennyson Parkway
   Suite 1200
   Plano, Texas 75024
   USA

   EMail:  rsparks@dynamicsoft.com

   Mark Handley
   International Computer Science Institute
   1947 Center St, Suite 600
   Berkeley, CA 94704
   USA

   EMail:  mjh@icir.org

   Eve Schooler
   AT&T Labs-Research
   75 Willow Road
   Menlo Park, CA 94025
   USA

   EMail: schooler@research.att.com
```

---
# **Full Copyright Statement**

저작권\(C\)인터넷학회\(2002\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에서 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
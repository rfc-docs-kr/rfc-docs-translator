

```text
Network Working Group                                          D. Cooper
Request for Comments: 5280                                          NIST
Obsoletes: 3280, 4325, 4630                                 S. Santesson
Category: Standards Track                                      Microsoft
                                                              S. Farrell
                                                  Trinity College Dublin
                                                               S. Boeyen
                                                                 Entrust
                                                              R. Housley
                                                          Vigil Security
                                                                 W. Polk
                                                                    NIST
                                                                May 2008

         Internet X.509 Public Key Infrastructure Certificate
             and Certificate Revocation List (CRL) Profile
```

---
# **Status of This Memo**

본 문서는 인터넷 커뮤니티를 위한 인터넷 표준 트랙 프로토콜을 명시하고 개선을 위한 논의와 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "인터넷 공식 프로토콜 표준"\(STD 1\) 최신판을 참조하세요. 이 메모의 배포는 무제한입니다.

---
# **Abstract**

이 메모는 인터넷에서 사용하기 위한 X.509 v3 인증서 및 X.509 v2 인증서 해지 목록\(CRL\)을 프로파일링합니다. 이 접근 방식과 모델에 대한 개요가 소개로 제공됩니다. X.509 v3 인증서 형식은 인터넷 이름 형식의 형식 및 의미에 관한 추가 정보와 함께 자세히 설명되어 있습니다. 표준 인증서 확장이 설명되고 두 개의 인터넷 관련 확장이 정의됩니다. 필수 인증서 확장 세트가 지정됩니다. X.509 v2 CRL 형식은 표준 및 인터넷 관련 확장과 함께 자세히 설명되어 있습니다. X.509 인증 경로 유효성 검사를 위한 알고리즘이 설명됩니다. ASN.1 모듈과 예제는 부록에 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................4
   2. Requirements and Assumptions ....................................6
      2.1. Communication and Topology .................................7
      2.2. Acceptability Criteria .....................................7
      2.3. User Expectations ..........................................7
      2.4. Administrator Expectations .................................8
   3. Overview of Approach ............................................8
      3.1. X.509 Version 3 Certificate ................................9
      3.2. Certification Paths and Trust .............................10
      3.3. Revocation ................................................13
      3.4. Operational Protocols .....................................14
      3.5. Management Protocols ......................................14
   4. Certificate and Certificate Extensions Profile .................16
      4.1. Basic Certificate Fields ..................................16
           4.1.1. Certificate Fields .................................17
                  4.1.1.1. tbsCertificate ............................18
                  4.1.1.2. signatureAlgorithm ........................18
                  4.1.1.3. signatureValue ............................18
           4.1.2. TBSCertificate .....................................18
                  4.1.2.1. Version ...................................19
                  4.1.2.2. Serial Number .............................19
                  4.1.2.3. Signature .................................19
                  4.1.2.4. Issuer ....................................20
                  4.1.2.5. Validity ..................................22
                           4.1.2.5.1. UTCTime ........................23
                           4.1.2.5.2. GeneralizedTime ................23
                  4.1.2.6. Subject ...................................23
                  4.1.2.7. Subject Public Key Info ...................25
                  4.1.2.8. Unique Identifiers ........................25
                  4.1.2.9. Extensions ................................26
      4.2. Certificate Extensions ....................................26
           4.2.1. Standard Extensions ................................27
                  4.2.1.1. Authority Key Identifier ..................27
                  4.2.1.2. Subject Key Identifier ....................28
                  4.2.1.3. Key Usage .................................29
                  4.2.1.4. Certificate Policies ......................32
                  4.2.1.5. Policy Mappings ...........................35
                  4.2.1.6. Subject Alternative Name ..................35
                  4.2.1.7. Issuer Alternative Name ...................38
                  4.2.1.8. Subject Directory Attributes ..............39
                  4.2.1.9. Basic Constraints .........................39
                  4.2.1.10. Name Constraints .........................40
                  4.2.1.11. Policy Constraints .......................43
                  4.2.1.12. Extended Key Usage .......................44
                  4.2.1.13. CRL Distribution Points ..................45
                  4.2.1.14. Inhibit anyPolicy ........................48
                  4.2.1.15. Freshest CRL (a.k.a. Delta CRL
                            Distribution Point) ......................48
           4.2.2. Private Internet Extensions ........................49
                  4.2.2.1. Authority Information Access ..............49
                  4.2.2.2. Subject Information Access ................51
   5. CRL and CRL Extensions Profile .................................54
      5.1. CRL Fields ................................................55
           5.1.1. CertificateList Fields .............................56
                  5.1.1.1. tbsCertList ...............................56
                  5.1.1.2. signatureAlgorithm ........................57
                  5.1.1.3. signatureValue ............................57
           5.1.2. Certificate List "To Be Signed" ....................58
                  5.1.2.1. Version ...................................58
                  5.1.2.2. Signature .................................58
                  5.1.2.3. Issuer Name ...............................58
                  5.1.2.4. This Update ...............................58
                  5.1.2.5. Next Update ...............................59
                  5.1.2.6. Revoked Certificates ......................59
                  5.1.2.7. Extensions ................................60
      5.2. CRL Extensions ............................................60
           5.2.1. Authority Key Identifier ...........................60
           5.2.2. Issuer Alternative Name ............................60
           5.2.3. CRL Number .........................................61
           5.2.4. Delta CRL Indicator ................................62
           5.2.5. Issuing Distribution Point .........................65
           5.2.6. Freshest CRL (a.k.a. Delta CRL Distribution
                  Point) .............................................67
           5.2.7. Authority Information Access .......................67
      5.3. CRL Entry Extensions ......................................69
           5.3.1. Reason Code ........................................69
           5.3.2. Invalidity Date ....................................70
           5.3.3. Certificate Issuer .................................70
   6. Certification Path Validation ..................................71
      6.1. Basic Path Validation .....................................72
           6.1.1. Inputs .............................................75
           6.1.2. Initialization .....................................77
           6.1.3. Basic Certificate Processing .......................80
           6.1.4. Preparation for Certificate i+1 ....................84
           6.1.5. Wrap-Up Procedure ..................................87
           6.1.6. Outputs ............................................89
      6.2. Using the Path Validation Algorithm .......................89
      6.3. CRL Validation ............................................90
           6.3.1. Revocation Inputs ..................................91
           6.3.2. Initialization and Revocation State Variables ......91
           6.3.3. CRL Processing .....................................92
   7. Processing Rules for Internationalized Names ...................95
      7.1. Internationalized Names in Distinguished Names ............96
      7.2. Internationalized Domain Names in GeneralName .............97
      7.3. Internationalized Domain Names in Distinguished Names .....98
      7.4. Internationalized Resource Identifiers ....................98
      7.5. Internationalized Electronic Mail Addresses ..............100
   8. Security Considerations .......................................100
   9. IANA Considerations ...........................................105
   10. Acknowledgments ..............................................105
   11. References ...................................................105
      11.1. Normative References ....................................105
      11.2. Informative References ..................................107
   Appendix A.  Pseudo-ASN.1 Structures and OIDs ....................110
      A.1. Explicitly Tagged Module, 1988 Syntax ....................110
      A.2. Implicitly Tagged Module, 1988 Syntax ....................125
   Appendix B. ASN.1 Notes ..........................................133
   Appendix C. Examples .............................................136
      C.1. RSA Self-Signed Certificate ..............................137
      C.2. End Entity Certificate Using RSA .........................140
      C.3. End Entity Certificate Using DSA .........................143
      C.4. Certificate Revocation List ..............................147
```

---
## **1.  Introduction**

이 사양은 인터넷용 X.509 공개 키 인프라\(PKI\) 표준 제품군의 일부입니다.

이 사양은 인터넷 PKI에 대한 인증서 및 인증서 해지 목록\(CRL\)의 형식과 의미를 프로파일링합니다. 인터넷 환경에서 인증경로를 처리하는 절차를 설명한다. 마지막으로 정의되거나 참조된 모든 데이터 구조에 대한 ASN.1 모듈이 부록에 제공됩니다.

섹션 2에서는 인터넷 PKI 요구 사항과 이 문서의 범위에 영향을 미치는 가정에 대해 설명합니다. 섹션 3에서는 아키텍처 모델을 제시하고 이전 IETF 및 ISO/IEC/ITU-T 표준과의 관계를 설명합니다. 특히, 이 문서와 IETF PEM 사양 및 ISO/IEC/ITU-T X.509 문서와의 관계가 설명됩니다.

섹션 4에서는 X.509 버전 3 인증서를 프로파일링하고, 섹션 5에서는 X.509 버전 2 CRL을 프로파일링합니다. 프로필에는 인터넷 PKI에 유용할 수 있는 ISO/IEC/ITU-T 및 ANSI 확장의 식별이 포함됩니다. 프로필은 최신 ISO/IEC/ITU-T 표준에 사용되는 1997 ASN.1 구문이 아닌 1988 ASN.1\(Abstract Syntax Notation One\)으로 표시됩니다.

섹션 6에는 인증 경로 검증 절차가 포함되어 있습니다. 이러한 절차는 ISO/IEC/ITU-T 정의를 기반으로 합니다. 구현은 동일한 결과를 도출해야 하지만 지정된 절차를 사용할 필요는 없습니다.

공개 키 자료 및 디지털 서명의 식별 및 인코딩 절차는 \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에 정의되어 있습니다. 이 사양의 구현에는 특정 암호화 알고리즘을 사용할 필요가 없습니다. 그러나 \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에 식별된 알고리즘을 사용하는 구현은 해당 사양에 설명된 대로 공개 키 자료 및 디지털 서명을 식별하고 인코딩해야 합니다.

마지막으로 구현자를 돕기 위해 세 가지 부록이 제공됩니다. 부록 A에는 이 사양 내에서 정의되거나 참조된 모든 ASN.1 구조가 포함되어 있습니다. 위와 같이 자료는 1988 ASN.1에 제시되어 있습니다. 부록 B에는 이 사양 내에서 사용되는 ASN.1 표기법의 덜 친숙한 기능에 대한 참고 사항이 포함되어 있습니다. 부록 C에는 적합한 인증서와 적합한 CRL의 예가 포함되어 있습니다.

이 사양은 \[RFC3280\]을 더 이상 사용하지 않습니다. RFC 3280과의 차이점은 아래에 요약되어 있습니다.

- \* 국제화된 이름에 대한 향상된 지원은 국제화된 도메인 이름, 국제화된 자원 식별자\(IRI\) 및 고유 이름을 인코딩하고 비교하는 규칙과 함께 섹션 7에 지정되어 있습니다. 이러한 규칙은 \[RFC3490\], \[RFC3987\] 및 \[RFC4518\]을 포함하여 현재 RFC에 설정된 비교 규칙과 일치합니다.

- \* 섹션 4.1.2.4 및 4.1.2.6은 \[RFC4630\]에 지정된 레거시 텍스트 인코딩 체계를 계속 사용하기 위한 조건을 통합합니다. 설정된 PKI에서 사용 중인 경우 UTF8String으로 전환하면 이름 연결 오류 또는 이름 제약 조건의 잘못된 처리로 인해 서비스 거부가 발생할 수 있습니다.

- \* privateKeyUsagePeriod 인증서 확장을 지정했지만 더 이상 사용되지 않는 RFC 3280의 섹션 4.2.1.4가 제거되었습니다. 이 ISO 표준 확장의 사용은 더 이상 사용되지 않거나 인터넷 PKI에서의 사용이 권장되지 않습니다.

- \* 섹션 4.2.1.5에서는 정책 매핑 확장을 중요로 표시할 것을 권장합니다. RFC 3280에서는 정책 매핑 확장을 중요하지 않음으로 표시하도록 요구했습니다.

- \* 섹션 4.2.1.11에서는 정책 제약 확장을 중요로 표시하도록 요구합니다. RFC 3280에서는 정책 제약 조건 확장이 중요 또는 중요하지 않음으로 표시되도록 허용했습니다.

- \* \[RFC4325\]에 지정된 AIA\(Authority Information Access\) CRL 확장이 섹션 5.2.7에 추가되었습니다.

- \* 섹션 5.2 및 5.3에서는 각각 인식할 수 없는 CRL 확장 및 CRL 항목 확장을 처리하기 위한 규칙을 명확히 합니다.

- \* HoldInstructionCode CRL 항목 확장을 지정하는 RFC 3280의 섹션 5.3.2가 제거되었습니다.

- \* 섹션 6에 지정된 경로 유효성 검사 알고리즘은 더 이상 인증서 체인에서 인증서 정책 확장의 중요도를 추적하지 않습니다. RFC 3280에서는 이 정보가 신뢰 당사자에게 반환되었습니다.

- \* 보안 고려 사항 섹션에서는 CRL 배포 지점, 기관 정보 액세스 또는 주체 정보 액세스 확장에서 https 또는 유사한 체계를 사용하여 발생하는 순환 종속성의 위험을 다룹니다.

- \* 보안 고려 사항 섹션에서는 이름 모호성과 관련된 위험을 다룹니다.

- \* 보안 고려 사항 섹션에서는 CA 작업의 변경 사항을 알리는 절차에 대해 RFC 4210을 참조합니다.

부록 A의 ASN.1 모듈은 PKCS #9 \[RFC2985\]에 맞추기 위해 ub-emailaddress-length가 128에서 255로 변경된 점을 제외하고 RFC 3280에서 변경되지 않았습니다.

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.

---
## **2.  Requirements and Assumptions**

이 사양의 목표는 X.509 기술을 사용하려는 커뮤니티를 위해 인터넷 애플리케이션 내에서 X.509 인증서의 사용을 용이하게 하는 프로필을 개발하는 것입니다. 이러한 응용 프로그램에는 WWW, 전자 메일, 사용자 인증 및 IPsec이 포함될 수 있습니다. X.509 인증서 사용에 대한 몇 가지 장애물을 완화하기 위해 이 문서에서는 인증서 관리 시스템 개발, 응용 도구 개발 및 정책에 따라 결정되는 상호 운용성을 촉진하는 프로필을 정의합니다.

일부 커뮤니티에서는 추가 인증, 보증 또는 운영 요구 사항이 있는 특수 응용 프로그램 도메인 또는 환경의 요구 사항을 충족하기 위해 이 프로필을 보완하거나 대체해야 합니다. 그러나 기본 애플리케이션의 경우 자주 사용되는 속성의 공통 표현은 다음과 같이 정의됩니다.

애플리케이션 개발자는 특정 인증서 발급자나 CRL\(인증서 해지 목록\)에 관계없이 필요한 정보를 얻을 수 있습니다.

인증서 사용자는 특정 인증서의 공개 키와 관련된 인증 또는 부인 방지 서비스에 의존하기 전에 인증 기관\(CA\)에서 생성한 인증서 정책을 검토해야 합니다. 이를 위해 이 표준은 법적 구속력이 있는 규칙이나 의무를 규정하지 않습니다.

속성 인증서와 같은 추가 인증 및 속성 관리 도구가 등장함에 따라 인증서에 포함되는 인증된 속성을 제한하는 것이 적절할 수 있습니다. 이러한 다른 관리 도구는 인증된 많은 속성을 전달하는 보다 적절한 방법을 제공할 수 있습니다.

---
### **2.1.  Communication and Topology**

인증서 사용자는 통신 토폴로지, 특히 보안 전자 메일 사용자와 관련하여 광범위한 환경에서 작업합니다. 이 프로필은 고대역폭, 실시간 IP 연결 또는 높은 연결 가용성이 없는 사용자를 지원합니다. 또한 프로필은 방화벽이나 기타 필터링된 통신의 존재를 허용합니다.

이 프로필은 X.500 디렉토리 시스템\[X.500\] 또는 LDAP\(Lightweight Directory Access Protocol\) 디렉토리 시스템\[RFC4510\]의 배포를 가정하지 않습니다. 프로필은 X.500 디렉터리 또는 LDAP 디렉터리의 사용을 금지하지 않습니다. 그러나 인증서 및 CRL\(인증서 해지 목록\)을 배포하는 모든 방법을 사용할 수 있습니다.

---
### **2.2.  Acceptability Criteria**

인터넷 공개 키 인프라\(PKI\)의 목표는 결정적이고 자동화된 식별, 인증, 액세스 제어 및 권한 부여 기능에 대한 요구 사항을 충족하는 것입니다. 이러한 서비스에 대한 지원은 인증서에 포함된 속성뿐만 아니라 정책 데이터 및 인증 경로 제약 조건과 같은 인증서의 보조 제어 정보를 결정합니다.

---
### **2.3.  User Expectations**

인터넷 PKI 사용자는 클라이언트 소프트웨어를 사용하는 사람과 프로세스이며 인증서에 명명된 주체입니다. 이러한 용도에는 전자 메일의 리더 및 작성자, WWW 브라우저용 클라이언트, WWW 서버 및 라우터 내 IPsec용 키 관리자가 포함됩니다. 이 프로필은 이러한 사용자가 사용하는 플랫폼의 한계를 인식합니다.

사용자 자신의 정교함과 세심함의 한계를 사용합니다. 이는 최소한의 사용자 구성 책임\(예: 신뢰할 수 있는 CA 키, 규칙\), 인증서 내의 명시적인 플랫폼 사용 제약, 많은 악의적인 작업으로부터 사용자를 보호하는 인증 경로 제약, 유효성 검사 기능을 현명하게 자동화하는 애플리케이션에서 나타납니다.

---
### **2.4.  Administrator Expectations**

사용자 기대와 마찬가지로 인터넷 PKI 프로필은 일반적으로 CA를 운영하는 개인을 지원하도록 구성되었습니다. 관리자에게 무한한 선택권을 제공하면 CA 관리자의 미묘한 실수로 인해 광범위한 손상이 발생할 가능성이 높아집니다. 또한 무제한적인 선택은 CA에서 생성한 인증서를 처리하고 유효성을 검사하는 소프트웨어를 크게 복잡하게 만듭니다.

---
## **3.  Overview of Approach**

다음은 X.509\(PKIX\) 사양을 사용하는 공개 키 인프라에서 가정하는 아키텍처 모델의 단순화된 보기입니다.

이 모델의 구성 요소는 다음과 같습니다.

```text
   end entity: user of PKI certificates and/or end user system that is
               the subject of a certificate;

   CA:         certification authority;

   RA:         registration authority, i.e., an optional system to which
               a CA delegates certain management functions;
```

CRL 발급자: CRL을 생성하고 서명하는 시스템입니다. 그리고

```text
   repository: a system or collection of distributed systems that stores
               certificates and CRLs and serves as a means of
               distributing these certificates and CRLs to end entities.
```

CA는 자신이 발급한 인증서의 해지 상태를 표시할 책임이 있습니다. 해지 상태 정보는 OCSP\(온라인 인증서 상태 프로토콜\) \[RFC2560\], CRL\(인증서 해지 목록\) 또는 기타 메커니즘을 사용하여 제공될 수 있습니다. 일반적으로 해지 상태 정보가 CRL을 사용하여 제공되는 경우 CA도 CRL 발급자입니다. 그러나 CA는 CRL 발급 책임을 다른 엔터티에 위임할 수 있습니다.

AA\(속성 기관\)는 CRL 발행자에게 CRL 게시를 위임하도록 선택할 수도 있습니다.

```text
   +---+
   | C |                       +------------+
   | e | <-------------------->| End entity |
   | r |       Operational     +------------+
   | t |       transactions          ^
   | i |      and management         |  Management
   | f |       transactions          |  transactions        PKI
   | i |                             |                     users
   | c |                             v
   | a | =======================  +--+------------+  ==============
   | t |                          ^               ^
   | e |                          |               |         PKI
   |   |                          v               |      management
   | & |                       +------+           |       entities
   |   | <---------------------|  RA  |<----+     |
   | C |  Publish certificate  +------+     |     |
   | R |                                    |     |
   | L |                                    |     |
   |   |                                    v     v
   | R |                                +------------+
   | e | <------------------------------|     CA     |
   | p |   Publish certificate          +------------+
   | o |   Publish CRL                     ^      ^
   | s |                                   |      |  Management
   | i |                +------------+     |      |  transactions
   | t | <--------------| CRL Issuer |<----+      |
   | o |   Publish CRL  +------------+            v
   | r |                                      +------+
   | y |                                      |  CA  |
   +---+                                      +------+

                      Figure 1. PKI Entities
```

---
### **3.1.  X.509 Version 3 Certificate**

공개 키 사용자는 암호화 또는 디지털 서명 메커니즘을 사용할 올바른 원격 주체\(사람 또는 시스템\)가 관련 개인 키를 소유하고 있다는 확신이 필요합니다. 이러한 신뢰는 공개 키 값을 주체에 바인딩하는 데이터 구조인 공개 키 인증서를 사용하여 얻습니다. 바인딩은 신뢰할 수 있는 CA가 각 인증서에 디지털 서명을 함으로써 확인됩니다. CA는 기술적 수단\(즉, 도전-응답 프로토콜을 통한 소유 증명\), 개인 키 제시 또는 주체의 주장을 바탕으로 이 주장을 기반으로 할 수 있습니다. 인증서에는 제한된 유효 수명이 있으며 이는 서명된 내용에 표시되어 있습니다. 인증서를 사용하는 클라이언트는 인증서의 서명과 적시성을 독립적으로 확인할 수 있으므로 인증서를 다음을 통해 배포할 수 있습니다.

신뢰할 수 없는 통신 및 서버 시스템이며 인증서 사용 시스템의 보안되지 않은 저장소에 캐시될 수 있습니다.

ITU-T X.509\(이전 CCITT X.509\) 또는 X.500 디렉토리 권장 사항의 일부로 1988년에 처음 게시된 ISO/IEC 9594-8은 표준 인증서 형식\[X.509\]을 정의합니다. 1988 표준의 인증서 형식을 버전 1\(v1\) 형식이라고 합니다. 1993년 X.500이 개정되었을 때 두 개의 필드가 더 추가되어 버전 2\(v2\) 형식이 되었습니다.

1993년에 게시된 PEM\(Internet Privacy Enhanced Mail\) RFC에는 X.509 v1 인증서\[RFC1422\]를 기반으로 하는 공개 키 인프라에 대한 사양이 포함되어 있습니다. RFC 1422를 배포하려고 시도하면서 얻은 경험을 통해 v1 및 v2 인증서 형식이 여러 측면에서 부족하다는 것이 분명해졌습니다. 가장 중요한 것은 PEM 설계 및 구현 경험이 필요하다고 입증한 정보를 전달하기 위해 더 많은 필드가 필요했다는 것입니다. 이러한 새로운 요구 사항에 대응하여 ISO/IEC, ITU-T 및 ANSI X9는 X.509 버전 3\(v3\) 인증서 형식을 개발했습니다. v3 형식은 추가 확장 필드에 대한 규정을 추가하여 v2 형식을 확장합니다. 특정 확장 필드 유형은 표준에 지정되거나 조직이나 커뮤니티에서 정의 및 등록될 수 있습니다. 1996년 6월 기본 v3 형식의 표준화가 완료되었다\[X.509\].

ISO/IEC, ITU-T 및 ANSI X9도 v3 확장 필드 \[X.509\]\[X9.55\]에서 사용하기 위한 표준 확장을 개발했습니다. 이러한 확장은 추가 주체 식별 정보, 주요 속성 정보, 정책 정보 및 인증 경로 제약 조건과 같은 데이터를 전달할 수 있습니다.

그러나 ISO/IEC, ITU-T 및 ANSI X9 표준 확장은 적용 범위가 매우 넓습니다. 인터넷 사용을 위한 X.509 v3 시스템의 상호 운용 가능한 구현을 개발하려면 인터넷에 맞게 조정된 X.509 v3 확장 사용을 위한 프로필을 지정해야 합니다. 이 문서의 목표 중 하나는 인터넷 WWW, 전자 메일 및 IPsec 응용 프로그램에 대한 프로필을 지정하는 것입니다. 추가 요구 사항이 있는 환경에서는 이 프로필을 기반으로 구축하거나 대체할 수 있습니다.

---
### **3.2.  Certification Paths and Trust**

공개 키에 대한 지식이 필요한 보안 서비스 사용자는 일반적으로 필요한 공개 키가 포함된 인증서를 획득하고 유효성을 검사해야 합니다. 공개 키 사용자가 인증서에 서명한 CA 공개 키의 보증된 사본, CA 이름 및 관련 정보\(예: 유효 기간 또는 이름 제약 조건\)를 아직 보유하지 않은 경우 추가 인증서가 필요할 수 있습니다. 해당 공개 키를 얻으세요. 일반적으로 여러 인증서의 체인

하나의 CA가 서명한 공개 키 소유자\(최종 엔터티\)의 인증서와 다른 CA가 서명한 0개 이상의 추가 CA 인증서로 구성됩니다. 공개 키 사용자는 제한된 수의 보장된 CA 공개 키로만 초기화되므로 인증 경로라고 하는 이러한 체인이 필요합니다.

공개 키 사용자가 인증 경로를 찾을 수 있도록 CA를 구성하는 방법에는 여러 가지가 있습니다. PEM의 경우 RFC 1422는 CA의 엄격한 계층 구조를 정의했습니다. PEM 인증 기관에는 세 가지 유형이 있습니다.

```text
      (a)  Internet Policy Registration Authority (IPRA):  This
           authority, operated under the auspices of the Internet
           Society, acts as the root of the PEM certification hierarchy
           at level 1.  It issues certificates only for the next level
           of authorities, PCAs.  All certification paths start with the
           IPRA.

      (b)  Policy Certification Authorities (PCAs):  PCAs are at level 2
           of the hierarchy, each PCA being certified by the IPRA.  A
           PCA shall establish and publish a statement of its policy
           with respect to certifying users or subordinate certification
           authorities.  Distinct PCAs aim to satisfy different user
           needs.  For example, one PCA (an organizational PCA) might
           support the general electronic mail needs of commercial
           organizations, and another PCA (a high-assurance PCA) might
           have a more stringent policy designed for satisfying legally
           binding digital signature requirements.

      (c)  Certification Authorities (CAs):  CAs are at level 3 of the
           hierarchy and can also be at lower levels.  Those at level 3
           are certified by PCAs.  CAs represent, for example,
           particular organizations, particular organizational units
           (e.g., departments, groups, sections), or particular
           geographical areas.
```

또한 RFC 1422에는 이름 종속 규칙이 있는데, 이는 CA가 이름이 CA 자체 이름에 종속된\(X.500 명명 트리에서\) 엔터티에 대해서만 인증서를 발급할 수 있도록 요구합니다. PEM 인증 경로와 연관된 신뢰는 PCA 이름으로 암시됩니다. 이름 종속 규칙은 PCA 아래의 CA가 인증할 수 있는 하위 엔터티 집합에 대해 합리적으로 제한되도록 보장합니다\(예: 조직의 CA는 해당 조직의 이름 트리에 있는 엔터티만 인증할 수 있음\). 인증서 사용자 시스템은 이름 종속 규칙이 준수되었는지 기계적으로 확인할 수 있습니다.

RFC 1422는 X.509 v1 인증서 형식을 사용합니다. X.509 v1의 제한 사항으로 인해 정책 정보를 명확하게 연결하거나 인증서의 유용성을 제한하기 위해 몇 가지 구조적 제한 사항을 적용해야 했습니다. 이러한 제한 사항에는 다음이 포함됩니다.

```text
      (a)  a pure top-down hierarchy, with all certification paths
           starting from IPRA;

      (b)  a naming subordination rule restricting the names of a CA's
           subjects; and

      (c)  use of the PCA concept, which requires knowledge of
           individual PCAs to be built into certificate chain
           verification logic.  Knowledge of individual PCAs was
           required to determine if a chain could be accepted.
```

X.509 v3을 사용하면 사용되는 CA 구조를 제한할 필요 없이 RFC 1422에서 다루는 대부분의 요구 사항을 인증서 확장을 사용하여 해결할 수 있습니다. 특히, 인증서 정책과 관련된 인증서 확장은 PCA의 필요성을 제거하고 제약 확장은 이름 종속 규칙의 필요성을 제거합니다. 결과적으로 이 문서는 다음을 포함하여 보다 유연한 아키텍처를 지원합니다.

```text
      (a)  Certification paths start with a public key of a CA in a
           user's own domain, or with the public key of the top of a
           hierarchy.  Starting with the public key of a CA in a user's
           own domain has certain advantages.  In some environments, the
           local domain is the most trusted.

      (b)  Name constraints may be imposed through explicit inclusion of
           a name constraints extension in a certificate, but are not
           required.

      (c)  Policy extensions and policy mappings replace the PCA
           concept, which permits a greater degree of automation.  The
           application can determine if the certification path is
           acceptable based on the contents of the certificates instead
           of a priori knowledge of PCAs.  This permits automation of
           certification path processing.
```

X.509 v3에는 또한 인증서의 주체를 CA 또는 최종 엔터티로 식별하는 확장 기능이 포함되어 있어 PEM에서 요구되는 대역 외 정보에 대한 의존도가 줄어듭니다.

이 사양에는 CA 인증서와 최종 엔터티 인증서라는 두 가지 인증서 클래스가 포함됩니다. CA 인증서는 교차 인증서, 자체 발급 인증서의 세 가지 클래스로 더 나눌 수 있습니다.

인증서 및 자체 서명된 인증서. 교차 인증서는 발급자와 주체가 서로 다른 CA 인증서입니다. 교차 인증서는 두 CA 간의 신뢰 관계를 설명합니다. 자체 발급 인증서는 발급자와 주체가 동일한 CA 인증서입니다. 정책이나 운영의 변경 사항을 지원하기 위해 자체 발급 인증서가 생성됩니다. 자체 서명 인증서는 인증서에 바인딩된 공개 키를 통해 디지털 서명을 확인할 수 있는 자체 발급 인증서입니다. 자체 서명된 인증서는 인증 경로를 시작하는 데 사용할 공개 키를 전달하는 데 사용됩니다. 최종 엔터티 인증서는 인증서 발급 권한이 없는 주체에게 발급됩니다.

---
### **3.3.  Revocation**

인증서가 발급되면 전체 유효 기간 동안 사용되는 것으로 예상됩니다. 그러나 다양한 상황에 따라 유효기간이 만료되기 전에 인증서가 무효화될 수 있습니다. 이러한 상황에는 이름 변경, 주체와 CA 간의 연결 변경\(예: 직원이 조직에서 고용을 종료하는 경우\), 해당 개인 키의 손상 또는 손상이 의심되는 경우가 포함됩니다. 이러한 상황에서는 CA가 인증서를 취소해야 합니다.

X.509는 인증서 해지의 한 가지 방법을 정의합니다. 이 방법에는 각 CA가 CRL\(인증서 해지 목록\)이라는 서명된 데이터 구조를 주기적으로 발행하는 방식이 포함됩니다. CRL은 CA 또는 CRL 발급자가 서명하고 공용 저장소에서 무료로 사용할 수 있는 해지된 인증서를 식별하는 타임 스탬프 목록입니다. 해지된 각 인증서는 인증서 일련 번호로 CRL에서 식별됩니다. 인증서 사용 시스템이 인증서를 사용하는 경우\(예: 원격 사용자의 디지털 서명 확인\) 해당 시스템은 인증서 서명 및 유효성을 확인할 뿐만 아니라 적절한 최신 CRL을 획득하고 인증서 일련 번호가 해당 CRL에 없는지 확인합니다. . "적절하게 최근"의 의미는 지역 정책에 따라 다를 수 있지만 일반적으로 가장 최근에 발행된 CRL을 의미합니다. 새로운 CRL은 정기적으로\(예: 매시간, 매일 또는 매주\) 발행됩니다. 해지 알림 후 다음 업데이트의 일부로 항목이 CRL에 추가됩니다. 해지된 인증서의 유효 기간 이후에 발행된 정기적으로 예약된 하나의 CRL에 해당 항목이 나타날 때까지 CRL에서 항목을 제거해서는 안 됩니다.

이 해지 방법의 장점은 CRL이 인증서 자체와 정확히 동일한 수단, 즉 신뢰할 수 없는 서버 및 신뢰할 수 없는 통신을 통해 배포될 수 있다는 것입니다.

신뢰할 수 없는 통신 및 서버를 사용하는 CRL 해지 방법의 한 가지 제한 사항은 해지 시간 단위가 CRL 발급 기간으로 제한된다는 것입니다. 예를 들어,

이제 해지가 보고되고 현재 발행된 모든 CRL이 업데이트되도록 예약될 때까지 인증서 사용 시스템에 해지가 안정적으로 통보되지 않습니다. 이는 CRL이 업데이트되는 빈도에 따라 최대 1시간, 1일 또는 1주일이 될 수 있습니다. 발행 된.

X.509 v3 인증서 형식과 마찬가지로 여러 공급업체의 상호 운용 가능한 구현을 용이하게 하려면 인터넷 사용을 위해 X.509 v2 CRL 형식을 프로파일링해야 합니다. 해당 프로필을 지정하는 것이 이 문서의 목표 중 하나입니다. 그러나 이 프로필에는 CRL 발급이 필요하지 않습니다. 온라인 폐기 알림을 지원하는 메시지 형식과 프로토콜은 다른 PKIX 사양에 정의되어 있습니다. 일부 환경에서는 X.509 CRL 대신 온라인 취소 알림 방법을 적용할 수 있습니다. 온라인 해지 확인은 해지 보고서와 신뢰 당사자에게 정보 배포 사이의 대기 시간을 크게 줄일 수 있습니다. CA가 해지 보고서를 신뢰할 수 있고 유효한 것으로 수락하면 온라인 서비스에 대한 모든 쿼리는 해지의 인증서 유효성 검사 영향을 올바르게 반영합니다. 그러나 이러한 방법은 새로운 보안 요구 사항을 부과합니다. 즉, 인증서 유효성 검사기는 온라인 유효성 검사 서비스를 신뢰해야 하지만 저장소는 신뢰할 필요가 없습니다.

---
### **3.4.  Operational Protocols**

인증서를 사용하는 클라이언트 시스템에 인증서와 CRL\(또는 상태 정보\)을 전달하려면 운영 프로토콜이 필요합니다. LDAP, HTTP, FTP 및 X.500을 기반으로 한 배포 절차를 포함하여 다양한 인증서 및 CRL 전달 수단을 위한 규정이 필요합니다. 이러한 기능을 지원하는 작동 프로토콜은 다른 PKIX 사양에 정의되어 있습니다. 이러한 사양에는 적절한 MIME 콘텐츠 유형에 대한 정의 또는 참조를 포함하여 위의 모든 운영 환경을 지원하기 위한 메시지 형식 및 절차에 대한 정의가 포함될 수 있습니다.

---
### **3.5.  Management Protocols**

PKI 사용자와 관리 엔터티 간의 온라인 상호 작용을 지원하려면 관리 프로토콜이 필요합니다. 예를 들어, 관리 프로토콜은 CA와 키 쌍이 연결된 클라이언트 시스템 간에 또는 서로 교차 인증하는 두 CA 간에 사용될 수 있습니다. 관리 프로토콜이 잠재적으로 지원해야 하는 기능 세트는 다음과 같습니다.

```text
      (a)  registration:  This is the process whereby a user first makes
           itself known to a CA (directly, or through an RA), prior to
           that CA issuing a certificate or certificates for that user.

      (b)  initialization:  Before a client system can operate securely,
           it is necessary to install key materials that have the
           appropriate relationship with keys stored elsewhere in the
           infrastructure.  For example, the client needs to be securely
           initialized with the public key and other assured information
           of the trusted CA(s), to be used in validating certificate
           paths.

           Furthermore, a client typically needs to be initialized with
           its own key pair(s).

      (c)  certification:  This is the process in which a CA issues a
           certificate for a user's public key, and returns that
           certificate to the user's client system and/or posts that
           certificate in a repository.

      (d)  key pair recovery:  As an option, user client key materials
           (e.g., a user's private key used for encryption purposes) may
           be backed up by a CA or a key backup system.  If a user needs
           to recover these backed-up key materials (e.g., as a result
           of a forgotten password or a lost key chain file), an on-line
           protocol exchange may be needed to support such recovery.

      (e)  key pair update:  All key pairs need to be updated regularly,
           i.e., replaced with a new key pair, and new certificates
           issued.

      (f)  revocation request:  An authorized person advises a CA of an
           abnormal situation requiring certificate revocation.

      (g)  cross-certification:  Two CAs exchange information used in
           establishing a cross-certificate.  A cross-certificate is a
           certificate issued by one CA to another CA that contains a CA
           signature key used for issuing certificates.
```

온라인 프로토콜이 위 기능을 구현하는 유일한 방법은 아닙니다. 모든 기능에 대해 동일한 결과를 달성하는 오프라인 방법이 있으며 이 사양은 온라인 프로토콜의 사용을 요구하지 않습니다. 예를 들어, 하드웨어 토큰을 사용하는 경우 많은 기능이 물리적 토큰 전달의 일부로 달성될 수 있습니다. 또한 위 기능 중 일부는 하나의 프로토콜 교환으로 결합될 수 있습니다. 특히 등록, 초기화, 인증 기능 중 둘 이상이 하나의 프로토콜 교환으로 결합될 수 있습니다.

PKIX 시리즈 사양은 위 기능을 지원하는 표준 메시지 형식 세트를 정의합니다. 다양한 환경\(예: 이메일, 파일 전송 및 WWW\)에서 이러한 메시지를 전달하기 위한 프로토콜은 해당 사양에 설명되어 있습니다.

---
## **4.  Certificate and Certificate Extensions Profile**

이 섹션에서는 상호 운용성과 재사용 가능한 PKI를 촉진하는 공개 키 인증서에 대한 프로필을 제공합니다. 이 섹션은 X.509 v3 인증서 형식과 \[X.509\]에 정의된 표준 인증서 확장을 기반으로 합니다. ISO/IEC 및 ITU-T 문서는 ASN.1의 1997 버전을 사용합니다. 이 문서에서는 1988 ASN.1 구문을 사용하지만 인코딩된 인증서와 표준 확장은 동일합니다. 이 섹션에서는 인터넷 커뮤니티에 대한 PKI를 지원하는 데 필요한 개인 확장도 정의합니다.

인증서는 광범위한 상호 운용성 목표와 운영 및 보증 요구 사항을 포괄하는 광범위한 응용 프로그램 및 환경에서 사용될 수 있습니다. 이 문서의 목표는 광범위한 상호 운용성과 제한된 특수 목적 요구 사항이 필요한 일반 응용 프로그램에 대한 공통 기준을 설정하는 것입니다. 특히, 비공식 인터넷 전자 메일, IPsec 및 WWW 애플리케이션에 대한 X.509 v3 인증서 사용 지원에 중점을 둘 것입니다.

---
### **4.1.  Basic Certificate Fields**

X.509 v3 인증서 기본 구문은 다음과 같습니다. 서명 계산을 위해 서명될 데이터는 ASN.1 DER\(고유 인코딩 규칙\) \[X.690\]을 사용하여 인코딩됩니다. ASN.1 DER 인코딩은 각 요소에 대한 태그, 길이, 값 인코딩 시스템입니다.

```text
   Certificate  ::=  SEQUENCE  {
        tbsCertificate       TBSCertificate,
        signatureAlgorithm   AlgorithmIdentifier,
        signatureValue       BIT STRING  }

   TBSCertificate  ::=  SEQUENCE  {
        version         [0]  EXPLICIT Version DEFAULT v1,
        serialNumber         CertificateSerialNumber,
        signature            AlgorithmIdentifier,
        issuer               Name,
        validity             Validity,
        subject              Name,
        subjectPublicKeyInfo SubjectPublicKeyInfo,
        issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
                             -- If present, version MUST be v2 or v3

        subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
                             -- If present, version MUST be v2 or v3
        extensions      [3]  EXPLICIT Extensions OPTIONAL
                             -- If present, version MUST be v3
        }

   Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }

   CertificateSerialNumber  ::=  INTEGER

   Validity ::= SEQUENCE {
        notBefore      Time,
        notAfter       Time }

   Time ::= CHOICE {
        utcTime        UTCTime,
        generalTime    GeneralizedTime }

   UniqueIdentifier  ::=  BIT STRING

   SubjectPublicKeyInfo  ::=  SEQUENCE  {
        algorithm            AlgorithmIdentifier,
        subjectPublicKey     BIT STRING  }
```

확장 ::= 확장의 시퀀스 크기\(1..MAX\)

```text
   Extension  ::=  SEQUENCE  {
        extnID      OBJECT IDENTIFIER,
        critical    BOOLEAN DEFAULT FALSE,
        extnValue   OCTET STRING
                    -- contains the DER encoding of an ASN.1 value
                    -- corresponding to the extension type identified
                    -- by extnID
        }
```

다음 항목은 인터넷에서 사용하기 위한 X.509 v3 인증서에 대해 설명합니다.

---
#### **4.1.1.  Certificate Fields**

인증서는 세 가지 필수 필드로 구성된 시퀀스입니다. 해당 필드는 다음 하위 섹션에 자세히 설명되어 있습니다.

---
##### **4.1.1.1.  tbsCertificate**

필드에는 주체 및 발급자의 이름, 주체와 연결된 공개 키, 유효 기간 및 기타 관련 정보가 포함됩니다. 해당 필드는 섹션 4.1.2에 자세히 설명되어 있습니다. tbsCertificate에는 일반적으로 섹션 4.2에 설명된 확장이 포함됩니다.

---
##### **4.1.1.2.  signatureAlgorithm**

SignatureAlgorithm 필드에는 CA가 이 인증서에 서명하는 데 사용하는 암호화 알고리즘에 대한 식별자가 포함되어 있습니다. \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에는 지원되는 서명 알고리즘이 나열되어 있지만 다른 서명 알고리즘도 지원될 수 있습니다.

알고리즘 식별자는 다음 ASN.1 구조로 정의됩니다.

```text
   AlgorithmIdentifier  ::=  SEQUENCE  {
        algorithm               OBJECT IDENTIFIER,
        parameters              ANY DEFINED BY algorithm OPTIONAL  }
```

알고리즘 식별자는 암호화 알고리즘을 식별하는 데 사용됩니다. OBJECT IDENTIFIER 구성 요소는 알고리즘\(예: SHA-1을 사용하는 DSA\)을 식별합니다. 선택적 매개변수 필드의 내용은 식별된 알고리즘에 따라 달라집니다.

이 필드는 tbsCertificate 시퀀스\(섹션 4.1.2.3\)의 서명 필드와 동일한 알고리즘 식별자를 포함해야 합니다.

---
##### **4.1.1.3.  signatureValue**

SignatureValue 필드에는 ASN.1 DER로 인코딩된 tbsCertificate에 대해 계산된 디지털 서명이 포함되어 있습니다. ASN.1 DER로 인코딩된 tbsCertificate는 서명 기능에 대한 입력으로 사용됩니다. 이 서명 값은 BIT STRING으로 인코딩되어 서명 필드에 포함됩니다. 이 프로세스의 세부 사항은 \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에 나열된 각 알고리즘에 대해 지정됩니다.

CA는 이 서명을 생성하여 tbsCertificate 필드에 있는 정보의 유효성을 인증합니다. 특히 CA는 공개 키 자료와 인증서 주체 간의 바인딩을 인증합니다.

---
#### **4.1.2.  TBSCertificate**

TBSCertificate 시퀀스에는 인증서 주체 및 인증서를 발급한 CA와 관련된 정보가 포함되어 있습니다. 모든 TBSCertificate에는 주체 및 발급자의 이름, 공개 인증서가 포함되어 있습니다.

주제와 관련된 키, 유효 기간, 버전 번호 및 일련 번호; 일부는 선택적 고유 식별자 필드를 포함할 수 있습니다. 이 섹션의 나머지 부분에서는 이러한 필드의 구문과 의미를 설명합니다. TBSCertificate에는 일반적으로 확장이 포함됩니다. 인터넷 PKI의 확장은 섹션 4.2에 설명되어 있습니다.

---
##### **4.1.2.1.  Version**

이 필드는 인코딩된 인증서의 버전을 설명합니다. 확장이 사용되는 경우 이 프로필에서 예상한 대로 버전은 3\(값은 2\)이어야 합니다. 확장은 없지만 UniqueIdentifier가 있는 경우 버전은 2\(값은 1\)여야 합니다. 그러나 버전은 3일 수 있습니다. 기본 필드만 있는 경우 버전은 1이어야 합니다\(값은 기본값으로 인증서에서 생략됩니다\). 그러나 버전은 2 또는 3일 수 있습니다.

구현은 모든 버전 인증서를 수락할 준비를 해야 합니다. 최소한 준수 구현은 버전 3 인증서를 인식해야 합니다.

이 프로필을 기반으로 한 구현에서는 버전 2 인증서 생성이 예상되지 않습니다.

---
##### **4.1.2.2.  Serial Number**

일련 번호는 CA가 각 인증서에 할당한 양의 정수여야 합니다. 이는 특정 CA에서 발급한 각 인증서에 대해 고유해야 합니다. 즉, 발급자 이름과 일련 번호는 고유한 인증서를 식별합니다. CA는 serialNumber가 음수가 아닌 정수가 되도록 강제해야 합니다.

위의 고유성 요구 사항을 고려하면 일련 번호에는 긴 정수가 포함될 것으로 예상됩니다. 인증서 사용자는 최대 20옥텟의 serialNumber 값을 처리할 수 있어야 합니다. 준수 CA는 20옥텟보다 긴 serialNumber 값을 사용해서는 안 됩니다.

참고: 비준수 CA는 음수 또는 0인 일련 번호로 인증서를 발급할 수 있습니다. 인증서 사용자는 그러한 인증서를 적절하게 처리할 준비가 되어 있어야 합니다.

---
##### **4.1.2.3.  Signature**

이 필드에는 CA가 인증서에 서명하는 데 사용하는 알고리즘에 대한 알고리즘 식별자가 포함되어 있습니다.

이 필드는 시퀀스 인증서\(섹션\)의 서명 알고리즘 필드와 동일한 알고리즘 식별자를 포함해야 합니다.

4.1.1.2\). 선택적 매개변수 필드의 내용은 식별된 알고리즘에 따라 달라집니다. \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에는 지원되는 서명 알고리즘이 나열되어 있지만 다른 서명 알고리즘도 지원될 수 있습니다.

---
##### **4.1.2.4.  Issuer**

발급자 필드는 인증서에 서명하고 발급한 엔터티를 식별합니다. 발급자 필드에는 비어 있지 않은 고유 이름\(DN\)이 포함되어야 합니다. 발행자 필드는 X.501 유형 이름 \[X.501\]로 정의됩니다. 이름은 다음 ASN.1 구조로 정의됩니다.

이름 ::= CHOICE { -- 지금은 단 하나의 가능성만 -- rdnSequence RDNSequence }

RDNSequence ::= RelativeDistinguishedName의 시퀀스

RelativeDistinguishedName ::= AttributeTypeAndValue의 크기 설정\(1..MAX\)

```text
   AttributeTypeAndValue ::= SEQUENCE {
     type     AttributeType,
     value    AttributeValue }

   AttributeType ::= OBJECT IDENTIFIER
```

AttributeValue ::= ANY -- AttributeType에 의해 정의됨

```text
   DirectoryString ::= CHOICE {
         teletexString           TeletexString (SIZE (1..MAX)),
         printableString         PrintableString (SIZE (1..MAX)),
         universalString         UniversalString (SIZE (1..MAX)),
         utf8String              UTF8String (SIZE (1..MAX)),
         bmpString               BMPString (SIZE (1..MAX)) }
```

이름은 국가 이름과 같은 속성과 US와 같은 해당 값으로 구성된 계층적 이름을 설명합니다. AttributeValue 구성요소의 유형은 AttributeType에 의해 결정됩니다. 일반적으로 이는 DirectoryString이 됩니다.

DirectoryString 유형은 PrintableString, TeletexString, BMPString, UTF8String 및 UniversalString을 선택하여 정의됩니다. 이 프로필을 준수하는 CA는 두 가지 예외를 제외하고 DirectoryString의 PrintableString 또는 UTF8String 인코딩을 사용해야 합니다. CA가 이전에 TeletexString, BMPString 또는 UniversalString을 사용하여 인코딩된 특성이 있는 발급자 필드가 있는 인증서를 발급한 경우 CA는 이전 버전과의 호환성을 유지하기 위해 DirectoryString의 이러한 인코딩을 계속 사용할 수 있습니다. 또한 새로운

기존 CA가 TeletexString, BMPString 또는 UniversalString을 사용하여 인코딩된 속성이 있는 발급자 필드가 있는 인증서를 발급하는 도메인에 추가된 CA는 기존 CA가 사용하는 것과 동일한 인코딩을 사용하여 기존 CA와 공유하는 속성을 인코딩할 수 있습니다.

위에서 언급한 것처럼 고유 이름은 속성으로 구성됩니다. 이 사양은 이름에 나타날 수 있는 속성 유형 집합을 제한하지 않습니다. 그러나 준수 구현은 아래에 정의된 속성 유형 집합을 포함하는 발급자 이름이 있는 인증서를 수신하도록 준비해야 합니다\(MUST\). 이 사양은 추가 속성 유형에 대한 지원을 권장합니다.

표준 속성 세트는 X.500 사양 시리즈 \[X.520\]에 정의되어 있습니다. 이 사양의 구현은 발행자 및 주체\(섹션 4.1.2.6\) 이름에서 다음 표준 속성 유형을 수신하도록 준비되어야 합니다.

- \* 국가, \* 조직, \* 조직 단위, \* 고유 이름 한정자, \* 주 또는 지방 이름, \* 일반 이름\(예: "Susan Housley"\) 및 \* 일련 번호.

또한, 이 사양의 구현은 발급자 및 주체 이름에 다음과 같은 표준 속성 유형을 수신하도록 준비해야 합니다\(SHOULD\).

- \* 지역, \* 직함, \* 성, \* 이름, \* 이니셜, \* 가명 및 \* 세대 한정어\(예: "Jr.", "3rd" 또는 "IV"\).

이러한 속성 유형에 대한 구문 및 관련 개체 식별자\(OID\)는 부록 A의 ASN.1 모듈에 제공됩니다.

또한, 이 사양의 구현은 \[RFC4519\]에 정의된 대로 domainComponent 속성을 수신하도록 준비되어야 합니다. DNS\(Domain Name System\)는 계층적 리소스 레이블 지정 시스템을 제공합니다. 이 속성은 DNS 이름과 유사한 DN을 사용하려는 조직에 편리한 메커니즘을 제공합니다. 이는 대체 이름 확장명의 dNSName 구성 요소를 대체하지 않습니다. 구현에는 다음이 필요하지 않습니다.

해당 이름을 DNS 이름으로 변환합니다. 이 속성 유형에 대한 구문 및 관련 OID는 부록 A의 ASN.1 모듈에 제공됩니다. domainComponent 속성 유형과 함께 사용하기 위해 국제화된 도메인 이름을 인코딩하는 규칙은 섹션 7.3에 지정되어 있습니다.

인증서 사용자는 인증 경로 유효성 검사\(섹션 6\)를 위한 이름 체인을 수행하기 위해 발급자 고유 이름 및 주체 고유 이름\(섹션 4.1.2.6\) 필드를 처리할 준비를 해야 합니다. 이름 체인화는 한 인증서의 발급자 고유 이름을 CA 인증서의 주체 이름과 일치시켜 수행됩니다. 고유 이름 비교 규칙은 섹션 7.1에 지정되어 있습니다. 인증서의 발급자 및 제목 필드에 있는 이름이 섹션 7.1에 지정된 규칙에 따라 일치하면 인증서가 자체 발급됩니다.

---
##### **4.1.2.5.  Validity**

인증서 유효 기간은 CA가 인증서 상태에 대한 정보를 유지함을 보증하는 기간입니다. 필드는 인증서 유효 기간이 시작되는 날짜\(notBefore\)와 인증서 유효 기간이 끝나는 날짜\(notAfter\)라는 두 날짜의 SEQUENCE로 표시됩니다. notBefore와 notAfter는 모두 UTCTime 또는 GeneralizedTime으로 인코딩될 수 있습니다.

이 프로필을 준수하는 CA는 항상 2049년까지 인증서 유효 날짜를 UTCTime으로 인코딩해야 합니다. 2050년 이후의 인증서 유효 날짜는 GeneralizedTime으로 인코딩되어야 합니다. 준수 애플리케이션은 UTCTime 또는 GeneralizedTime으로 인코딩된 유효 날짜를 처리할 수 있어야 합니다\(MUST\).

인증서의 유효 기간은 notBefore부터 notAfter까지의 기간입니다.

어떤 상황에서는 적절한 만료 날짜를 할당할 수 없는 인증서가 장치에 제공됩니다. 예를 들어, 모델과 일련 번호를 공개 키에 바인딩하는 인증서가 장치에 발급될 수 있습니다. 이러한 인증서는 장치의 전체 수명 동안 사용되도록 고안되었습니다.

인증서에 잘 정의된 만료 날짜가 없음을 나타내려면 notAfter에 GeneralizedTime 값 99991231235959Z를 할당해야 합니다.

발급자가 notAfter 날짜\(notAfter 날짜가 99991231235959Z인 경우 포함\)까지 상태 정보를 유지할 수 없는 경우, 발급자는 상태 유지 후 인증서에 대한 유효한 인증 경로가 존재하지 않는지 확인해야 합니다.

정보가 종료되었습니다. 이는 인증서의 서명을 확인하는 데 사용되는 공개 키를 포함하는 모든 CA 인증서를 만료하거나 취소하고 인증서의 서명을 트러스트 앵커로 확인하는 데 사용되는 공개 키의 사용을 중단함으로써 달성될 수 있습니다.

---
###### **4.1.2.5.1.  UTCTime**

표준시 유형인 UTCTime은 날짜 및 시간 표시를 위한 표준 ASN.1 유형입니다. UTCTime은 두 개의 하위 숫자를 통해 연도를 지정하고 시간은 1분 또는 1초의 정밀도로 지정됩니다. UTCTime에는 Z\(Zulu 또는 그리니치 표준시\) 또는 시차가 포함됩니다.

이 프로필의 목적을 위해 UTCTime 값은 그리니치 표준시\(Zulu\)로 표현되어야 하며 초 수가 0인 경우에도 초를 포함해야 합니다\(즉, 시간은 YYMMDDHHMMSSZ임\). 준수 시스템은 연도 필드\(YY\)를 다음과 같이 해석해야 합니다.

- YY가 50보다 크거나 같은 경우 연도는 19YY로 해석됩니다. 그리고

- YY가 50보다 작은 경우 연도는 20YY로 해석됩니다.

---
###### **4.1.2.5.2.  GeneralizedTime**

일반화된 시간 유형인 GeneralizedTime은 시간의 가변 정밀도 표현을 위한 표준 ASN.1 유형입니다. 선택적으로 GeneralizedTime 필드에는 현지 표준시와 그리니치 표준시 간의 시간 차이 표현이 포함될 수 있습니다.

이 프로필의 목적을 위해 GeneralizedTime 값은 그리니치 표준시\(Zulu\)로 표현되어야 하며 초 수가 0인 경우에도 초를 포함해야 합니다\(즉, 시간은 YYYYMMDDHHMMSSZ임\). GeneralizedTime 값은 소수 초를 포함해서는 안 됩니다.

---
##### **4.1.2.6.  Subject**

제목 필드는 제목 공개 키 필드에 저장된 공개 키와 연관된 엔터티를 식별합니다. 제목 이름은 제목 필드 및/또는 subjectAltName 확장에 포함될 수 있습니다. 주체가 CA인 경우\(예: 섹션 4.2.1.9에서 논의된 기본 제약 확장이 존재하고 cA 값이 TRUE인 경우\), 주체 필드는 내용과 일치하는 비어 있지 않은 고유 이름으로 채워져야 합니다. 주체 CA가 발급한 모든 인증서의 발급자 필드\(섹션 4.1.2.4\). 주체가 CRL 발급자인 경우\(예: 섹션 4.2.1.3에 설명된 키 사용 확장이 존재하고 cRLSign 값이 TRUE인 경우\)

그러면 주제 필드는 주제 CRL 발급자가 발급한 모든 CRL의 발급자 필드\(섹션 5.1.2.3\) 내용과 일치하는 비어 있지 않은 고유 이름으로 채워져야 합니다. 주체 이름 지정 정보가 subjectAltName 확장\(예: 이메일 주소 또는 URI에만 바인딩된 키\)에만 있는 경우 주체 이름은 빈 시퀀스여야 하며 subjectAltName 확장은 중요해야 합니다\(MUST\).

비어 있지 않은 경우 제목 필드에는 X.500 고유 이름\(DN\)이 포함되어야 합니다. DN은 발급자 필드에 정의된 대로 하나의 CA에서 인증한 각 주체 엔터티에 대해 고유해야 합니다. CA는 동일한 주체 엔터티에 대해 동일한 DN을 가진 두 개 이상의 인증서를 발급할 수 있습니다.

제목 필드는 X.501 유형 이름으로 정의됩니다. 이 필드에 대한 구현 요구 사항은 발급자 필드\(섹션 4.1.2.4\)에 대해 정의된 요구 사항입니다. 이 사양의 구현은 발급자 필드에 필요한 속성 유형이 포함된 주체 이름을 수신하도록 준비되어야 합니다\(MUST\). 이 사양의 구현은 발급자 필드에 권장되는 속성 유형이 포함된 주체 이름을 수신할 준비를 해야 합니다. 이러한 속성 유형에 대한 구문 및 관련 개체 식별자\(OID\)는 부록 A의 ASN.1 모듈에 제공됩니다. 이 사양의 구현은 섹션 7.1의 비교 규칙을 사용하여 익숙하지 않은 속성 유형\(예: 이름 연결\)을 처리할 수 있습니다. 속성 값은 DirectoryString의 인코딩 옵션 중 하나를 사용합니다. 익숙하지 않은 속성 유형에 DirectoryString에 있는 인코딩 옵션 이외의 인코딩 옵션이 있는 속성 값이 포함된 경우 이진 비교를 사용해야 합니다. 이를 통해 구현에서는 주체 이름에 익숙하지 않은 속성이 있는 인증서를 처리할 수 있습니다.

DirectoryString 유형의 속성 값을 인코딩할 때, 준수 CA는 다음 예외를 제외하고 PrintableString 또는 UTF8String 인코딩을 사용해야 합니다.

```text
      (a)  When the subject of the certificate is a CA, the subject
           field MUST be encoded in the same way as it is encoded in the
           issuer field (Section 4.1.2.4) in all certificates issued by
           the subject CA.  Thus, if the subject CA encodes attributes
           in the issuer fields of certificates that it issues using the
           TeletexString, BMPString, or UniversalString encodings, then
           the subject field of certificates issued to that CA MUST use
           the same encoding.

      (b)  When the subject of the certificate is a CRL issuer, the
           subject field MUST be encoded in the same way as it is
           encoded in the issuer field (Section 5.1.2.3) in all CRLs
           issued by the subject CRL issuer.

      (c)  TeletexString, BMPString, and UniversalString are included
           for backward compatibility, and SHOULD NOT be used for
           certificates for new subjects.  However, these types MAY be
           used in certificates where the name was previously
           established, including cases in which a new certificate is
           being issued to an existing subject or a certificate is being
           issued to a new subject where the attributes being encoded
           have been previously established in certificates issued to
           other subjects.  Certificate users SHOULD be prepared to
           receive certificates with these types.
```

전자 메일 주소가 emailAddress 속성\[RFC2985\]으로 제목 고유 이름에 포함된 레거시 구현이 존재합니다. emailAddress의 속성 값은 PrintableString 문자 세트의 일부가 아닌 문자 '@'의 포함을 허용하는 IA5String 유형입니다. emailAddress 속성 값은 대소문자를 구분하지 않습니다\(예: "subscriber@example.com"은 "SUBSCRIBER@EXAMPLE.COM"과 동일함\).

전자 메일 주소로 새 인증서를 생성하는 구현을 준수하는 경우 이러한 ID를 설명하기 위해 주체 대체 이름 확장\(섹션 4.2.1.6\)에서 rfc822Name을 사용해야 합니다. 레거시 구현을 지원하기 위해 주체 고유 이름에 emailAddress 속성을 동시에 포함하는 것은 더 이상 사용되지 않지만 허용됩니다.

---
##### **4.1.2.7.  Subject Public Key Info**

이 필드는 공개 키를 전달하고 키가 사용되는 알고리즘\(예: RSA, DSA 또는 Diffie-Hellman\)을 식별하는 데 사용됩니다. 알고리즘은 섹션 4.1.1.2에 지정된 AlgorithmIdentifier 구조를 사용하여 식별됩니다. 지원되는 알고리즘에 대한 객체 식별자와 공개 키 자료\(공개 키 및 매개변수\)를 인코딩하는 방법은 \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에 지정되어 있습니다.

---
##### **4.1.2.8.  Unique Identifiers**

이러한 필드는 버전이 2 또는 3인 경우에만 나타나야 합니다\(섹션 4.1.2.1\). 버전이 1인 경우 이러한 필드는 표시되어서는 안 됩니다. 주체 및 발급자 고유 식별자는 시간이 지남에 따라 주체 및/또는 발급자 이름의 재사용 가능성을 처리하기 위해 인증서에 존재합니다. 이 프로필은 이름이 다른 엔터티에 재사용되지 않고 인터넷 인증서가 고유 식별자를 사용하지 않을 것을 권장합니다. 이 프로필을 준수하는 CA는 고유 식별자가 있는 인증서를 생성해서는 안 됩니다. 다음을 준수하는 애플리케이션

이 프로필은 고유 식별자를 포함하는 인증서를 구문 분석할 수 있어야 하지만 고유 식별자와 관련된 처리 요구 사항은 없습니다.

---
##### **4.1.2.9.  Extensions**

이 필드는 버전이 3\(섹션 4.1.2.1\)인 경우에만 나타나야 합니다. 있는 경우 이 필드는 하나 이상의 인증서 확장의 SEQUENCE입니다. 인터넷 PKI의 인증서 확장 형식과 내용은 섹션 4.2에 정의되어 있습니다.

---
### **4.2.  Certificate Extensions**

X.509 v3 인증서에 대해 정의된 확장은 추가 특성을 사용자 또는 공개 키와 연결하고 CA 간의 관계를 관리하는 방법을 제공합니다. X.509 v3 인증서 형식을 사용하면 커뮤니티에서 해당 커뮤니티에 고유한 정보를 전달하는 개인 확장 기능을 정의할 수도 있습니다. 인증서의 각 확장은 중요 또는 중요하지 않음으로 지정됩니다. 인증서 사용 시스템은 인식할 수 없는 중요한 확장이나 처리할 수 없는 정보가 포함된 중요한 확장을 발견하면 인증서를 거부해야 합니다. 중요하지 않은 확장은 인식되지 않으면 무시될 수 있지만 인식되면 처리되어야 합니다. 다음 섹션에서는 인터넷 인증서 내에서 사용되는 권장 확장명과 정보의 표준 위치를 제시합니다. 커뮤니티는 추가 확장 기능을 사용하도록 선택할 수 있습니다. 그러나 일반적인 상황에서 사용을 방해할 수 있는 인증서의 중요한 확장을 채택할 때는 주의를 기울여야 합니다.

각 확장에는 OID와 ASN.1 구조가 포함됩니다. 확장이 인증서에 나타나면 OID는 extnID 필드로 나타나고 해당 ASN.1 DER 인코딩 구조는 옥텟 문자열 extnValue의 값입니다. 인증서에는 특정 확장의 인스턴스가 두 개 이상 포함되어서는 안 됩니다. 예를 들어 인증서에는 기관 키 식별자 확장이 하나만 포함될 수 있습니다\(4.2.1.1항\). 확장에는 기본값이 FALSE인 부울 임계값이 포함됩니다. 각 확장에 대한 텍스트는 이 프로필을 준수하는 CA의 중요 필드에 허용되는 값을 지정합니다.

준수 CA는 키 식별자\(섹션 4.2.1.1 및 4.2.1.2\), 기본 제약 조건\(섹션 4.2.1.9\), 키 사용\(섹션 4.2.1.3\) 및 인증서 정책\(섹션 4.2.1.4\) 확장을 지원해야 합니다. CA가 주체 필드에 대해 빈 시퀀스로 인증서를 발급하는 경우 CA는 주체 대체 이름 확장\(섹션 4.2.1.6\)을 지원해야 합니다. 나머지 확장에 대한 지원은 선택 사항입니다. 준수 CA는 내부에서 식별되지 않은 확장을 지원할 수 있습니다\(MAY\).

이 사양; 인증서 발급자는 이러한 확장을 중요로 표시하면 상호 운용성이 저하될 수 있다는 점에 주의해야 합니다.

최소한 이 프로필을 준수하는 애플리케이션은 키 사용\(섹션 4.2.1.3\), 인증서 정책\(섹션 4.2.1.4\), 주체 대체 이름\(섹션 4.2.1.6\), 기본 제약 조건\(섹션 4.2.1.9\)과 같은 확장을 인식해야 합니다. \), 이름 제약 조건\(섹션 4.2.1.10\), 정책 제약 조건\(섹션 4.2.1.11\), 확장 키 사용\(섹션 4.2.1.12\) 및 anyPolicy 금지\(섹션 4.2.1.14\).

또한 이 프로필을 준수하는 애플리케이션은 권한 및 주체 키 식별자\(섹션 4.2.1.1 및 4.2.1.2\)와 정책 매핑\(섹션 4.2.1.5\) 확장을 인식해야 합니다.

---
#### **4.2.1.  Standard Extensions**

이 섹션에서는 인터넷 PKI에서 사용하기 위해 \[X.509\]에 정의된 표준 인증서 확장을 식별합니다. 각 확장은 \[X.509\]에 정의된 OID와 연관됩니다. 이러한 OID는 다음과 같이 정의되는 id-ce 아크의 구성원입니다.

```text
   id-ce   OBJECT IDENTIFIER ::=  { joint-iso-ccitt(2) ds(5) 29 }
```

---
##### **4.2.1.1.  Authority Key Identifier**

기관 키 식별자 확장은 인증서 서명에 사용되는 개인 키에 해당하는 공개 키를 식별하는 수단을 제공합니다. 이 확장은 발급자가 여러 개의 서명 키를 가지고 있는 경우\(여러 개의 동시 키 쌍 또는 전환으로 인해\) 사용됩니다. 식별은 키 식별자\(발급자 인증서의 주체 키 식별자\) 또는 발급자 이름 및 일련 번호를 기반으로 할 수 있습니다.

AuthorityKeyIdentifier 확장의 keyIdentifier 필드는 인증 경로 구성을 용이하게 하기 위해 CA를 준수하여 생성된 모든 인증서에 포함되어야 합니다. 한 가지 예외가 있습니다. CA가 "자체 서명" 인증서 형식으로 공개 키를 배포하는 경우 기관 키 식별자는 생략될 수 있습니다. 자체 서명된 인증서의 서명은 인증서의 주체 공개 키와 연결된 개인 키를 사용하여 생성됩니다. \(이는 발급자가 공개키와 개인키를 모두 보유하고 있음을 증명합니다.\) 이 경우 주체키 식별자와 권한키 식별자는 동일하지만, 인증 경로 구축에는 주체키 식별자만 필요합니다.

keyIdentifier 필드의 값은 인증서의 서명이나 방법을 확인하는 데 사용되는 공개 키에서 파생되어야 합니다.

독특한 가치를 만들어내는 곳입니다. 공개 키에서 키 식별자를 생성하는 두 가지 일반적인 방법은 섹션 4.2.1.2에 설명되어 있습니다. 키 식별자가 이전에 설정되지 않은 경우 이 사양에서는 keyIdentifier를 생성하기 위해 이러한 방법 중 하나를 사용하거나 다른 해시 알고리즘을 사용하는 유사한 방법을 사용할 것을 권장합니다. 키 식별자가 이전에 설정된 경우 CA는 이전에 설정된 식별자를 사용해야 합니다.

이 프로필은 모든 인증서 사용자가 키 식별자 방법을 지원할 것을 권장합니다.

준수 CA는 이 확장을 중요하지 않은 것으로 표시해야 합니다.

```text
   id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 }

   AuthorityKeyIdentifier ::= SEQUENCE {
      keyIdentifier             [0] KeyIdentifier           OPTIONAL,
      authorityCertIssuer       [1] GeneralNames            OPTIONAL,
      authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }

   KeyIdentifier ::= OCTET STRING
```

---
##### **4.2.1.2.  Subject Key Identifier**

주체 키 식별자 확장은 특정 공개 키가 포함된 인증서를 식별하는 수단을 제공합니다.

인증 경로 구성을 용이하게 하기 위해 이 확장은 모든 준수 CA 인증서, 즉 cA 값이 TRUE인 기본 제약 확장\(섹션 4.2.1.9\)을 포함하는 모든 인증서에 나타나야 합니다. CA 인증서를 준수하는 경우 주체 키 식별자의 값은 이 인증서의 주체가 발급한 인증서의 기관 키 식별자 확장\(섹션 4.2.1.1\)의 키 식별자 필드에 있는 값이어야 합니다. 애플리케이션은 인증 경로 유효성 검사를 수행할 때 키 식별자가 일치하는지 확인할 필요가 없습니다.

CA 인증서의 경우 주체 키 식별자는 공개 키 또는 고유한 값을 생성하는 방법에서 파생되어야 합니다. 공개 키에서 키 식별자를 생성하는 두 가지 일반적인 방법은 다음과 같습니다.

```text
      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
           value of the BIT STRING subjectPublicKey (excluding the tag,
           length, and number of unused bits).

      (2) The keyIdentifier is composed of a four-bit type field with
           the value 0100 followed by the least significant 60 bits of
           the SHA-1 hash of the value of the BIT STRING
           subjectPublicKey (excluding the tag, length, and number of
           unused bits).
```

고유 번호를 생성하는 다른 방법도 허용됩니다.

최종 엔터티 인증서의 경우 주체 키 식별자 확장은 애플리케이션에 사용되는 특정 공개 키가 포함된 인증서를 식별하는 수단을 제공합니다. 최종 엔터티가 특히 여러 CA로부터 여러 인증서를 얻은 경우 주체 키 식별자는 특정 공개 키가 포함된 인증서 집합을 신속하게 식별하는 수단을 제공합니다. 적절한 최종 엔터티 인증서를 식별하는 데 애플리케이션을 지원하려면 이 확장이 모든 최종 엔터티 인증서에 포함되어야 합니다.

최종 엔터티 인증서의 경우 주체 키 식별자는 공개 키에서 파생되어야 합니다. 공개 키에서 키 식별자를 생성하는 두 가지 일반적인 방법은 위에서 식별되었습니다.

키 식별자가 이전에 설정되지 않은 경우 이 사양에서는 keyIdentifier를 생성하기 위해 이러한 방법 중 하나를 사용하거나 다른 해시 알고리즘을 사용하는 유사한 방법을 사용할 것을 권장합니다. 키 식별자가 이전에 설정된 경우 CA는 이전에 설정된 식별자를 사용해야 합니다.

준수 CA는 이 확장을 중요하지 않은 것으로 표시해야 합니다.

```text
   id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 14 }

   SubjectKeyIdentifier ::= KeyIdentifier
```

---
##### **4.2.1.3.  Key Usage**

키 사용 확장은 인증서에 포함된 키의 목적\(예: 암호화, 서명, 인증서 서명\)을 정의합니다. 둘 이상의 작업에 사용할 수 있는 키를 제한하려는 경우 사용 제한을 사용할 수 있습니다. 예를 들어 RSA 키를 공개 키 인증서 및 CRL이 아닌 개체의 서명을 확인하는 데에만 사용해야 하는 경우 digitalSignature 및/또는 nonRepudiation 비트가 어설션됩니다. 마찬가지로 RSA 키를 키 관리에만 사용해야 하는 경우 keyEncipherment 비트가 어설션됩니다.

준수 CA는 다른 공개 키 인증서 또는 CRL의 디지털 서명을 검증하는 데 사용되는 공개 키가 포함된 인증서에 이 확장을 포함해야 합니다. 존재하는 경우, 이를 준수하는 CA는 이 확장을 중요로 표시해야 합니다.

```text
      id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }

      KeyUsage ::= BIT STRING {
           digitalSignature        (0),
           nonRepudiation          (1), -- recent editions of X.509 have
                                -- renamed this bit to contentCommitment
           keyEncipherment         (2),
           dataEncipherment        (3),
           keyAgreement            (4),
           keyCertSign             (5),
           cRLSign                 (6),
           encipherOnly            (7),
           decipherOnly            (8) }
```

KeyUsage 유형의 비트는 다음과 같이 사용됩니다.

- digitalSignature 비트는 개체 인증 서비스, 데이터 원본 인증 서비스에서 사용되는 인증서\(비트 5\) 및 CRL\(비트 6\)의 서명 이외의 디지털 서명을 확인하는 데 주체 공개 키가 사용될 때 주장됩니다. 및/또는 무결성 서비스.

- 서명 엔터티의 거짓 거부를 방지하는 부인 방지 서비스를 제공하는 데 사용되는 인증서\(비트 5\) 및 CRL\(비트 6\)의 서명 이외의 디지털 서명을 확인하는 데 주체 공개 키가 사용될 때 부인 방지 비트가 주장됩니다. 어떤 행동. 나중에 충돌이 발생하는 경우 신뢰할 수 있는 제3자가 서명된 데이터의 진위 여부를 확인할 수 있습니다. \(최근 X.509 버전에서는 nonRepudiation 비트의 이름이 contentCommitment로 변경되었습니다.\)

- keyEncipherment 비트는 주체 공개 키가 개인 키 또는 비밀 키를 암호화하는 데, 즉 키 전송에 사용될 때 주장됩니다. 예를 들어 RSA 공개 키가 대칭 콘텐츠 암호 해독 키 또는 비대칭 개인 키를 암호화하는 데 사용될 때 이 비트가 설정되어야 합니다.

- 중간 대칭 암호를 사용하지 않고 원시 사용자 데이터를 직접 암호화하기 위해 주체 공개 키가 사용될 때 dataEncipherment 비트가 어설션됩니다. 이 비트의 사용은 극히 드물다는 점에 유의하십시오. 거의 모든 애플리케이션은 키 전송 또는 키 계약을 사용하여 대칭 키를 설정합니다.

- keyAgreement 비트는 주체 공개키가 키 합의에 사용될 때 주장됩니다. 예를 들어 Diffie-Hellman 키를 키 관리에 사용하는 경우 이 비트가 설정됩니다.

- 주체 공개 키가 공개 키 인증서의 서명을 확인하는 데 사용될 때 keyCertSign 비트가 어설션됩니다. keyCertSign 비트가 주장되면 기본 제약 확장\(섹션 4.2.1.9\)의 cA 비트도 주장되어야 합니다.

- 인증서 해지 목록\(예: CRL, 델타 CRL 또는 ARL\)의 서명을 확인하기 위해 주체 공개 키가 사용될 때 cRLSign 비트가 어설션됩니다.

- keyAgreement 비트가 없으면 encipherOnly 비트의 의미가 정의되지 않습니다. encipherOnly 비트가 어설션되고 keyAgreement 비트도 설정된 경우 대상 공개키는 키 합의를 수행하는 동안 데이터 암호화에만 사용될 수 있습니다.

- keyAgreement 비트가 없으면 decipherOnly 비트의 의미가 정의되지 않습니다. decipherOnly 비트가 어설션되고 keyAgreement 비트도 설정된 경우 대상 공개 키는 키 합의를 수행하는 동안 데이터를 해독하는 데에만 사용될 수 있습니다.

keyUsage 확장이 존재하는 경우 해당 keyCertSign 또는 cRLSign 비트가 설정되지 않은 한 주체 공개 키를 인증서 또는 CRL의 서명을 확인하는 데 사용하면 안 됩니다. 주체 공개 키가 인증서 및/또는 CRL의 서명을 확인하는 데에만 사용되는 경우 digitalSignature 및 nonRepudiation 비트를 설정하면 안 됩니다. 그러나 주체 공개 키가 인증서 및/또는 CRL 및 기타 개체의 서명을 확인하는 데 사용되는 경우 keyCertSign 및/또는 cRLSign 비트에 추가로 digitalSignature 및/또는 nonRepudiation 비트를 설정할 수도 있습니다.

keyUsage 인증서 확장의 nonRepudiation 비트를 다른 keyUsage 비트와 결합하면 인증서가 사용되는 컨텍스트에 따라 보안에 영향을 미칠 수 있습니다. digitalSignature와 nonRepudiation 비트 간의 추가 구분은 특정 인증서 정책에서 제공될 수 있습니다.

이 프로필은 keyUsage 확장의 인스턴스화에 설정될 수 있는 비트 조합을 제한하지 않습니다. 그러나 특정 알고리즘에 대한 keyUsage 확장의 적절한 값은 \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에 지정됩니다. keyUsage 확장이 인증서에 나타나면 비트 중 하나 이상이 1로 설정되어야 합니다.

---
##### **4.2.1.4.  Certificate Policies**

인증서 정책 확장에는 하나 이상의 정책 정보 용어 시퀀스가 ​​포함되어 있으며, 각 정책 정보 용어는 OID\(객체 식별자\)와 선택적 한정자로 구성됩니다. 존재할 수 있는 선택적 한정자는 정책 정의를 변경하지 않을 것으로 예상됩니다. 인증서 정책 OID는 인증서 정책 확장에 두 번 이상 나타나서는 안 됩니다.

최종 엔터티 인증서에서 이러한 정책 정보 용어는 인증서가 발급된 정책과 인증서가 사용될 수 있는 목적을 나타냅니다. CA 인증서에서 이러한 정책 정보 용어는 이 인증서를 포함하는 인증 경로에 대한 정책 집합을 제한합니다. CA가 이 인증서를 포함하는 인증 경로에 대한 정책 집합을 제한하지 않으려면 {2 5 29 32 0 } 값을 사용하여 특수 정책 anyPolicy를 주장할 수 있습니다.

특정 정책 요구 사항이 있는 응용 프로그램에는 수락할 정책 목록이 있고 인증서의 정책 OID를 해당 목록과 비교할 것으로 예상됩니다. 이 확장이 중요한 경우 경로 유효성 검사 소프트웨어는 이 확장\(선택적 한정자 포함\)을 해석할 수 있거나 인증서를 거부해야 합니다\(MUST\).

상호 운용성을 높이기 위해 이 프로필에서는 정책 정보 용어가 OID로만 구성되도록 권장합니다. OID만으로는 불충분한 경우 이 프로필에서는 한정자의 사용을 이 섹션에서 식별된 한정자로 제한할 것을 강력히 권장합니다. 한정자가 특별 정책 anyPolicy와 함께 사용되는 경우 이 섹션에서 식별된 한정자로 제한되어야 합니다. 경로 유효성 검사의 결과로 반환된 한정자만 고려됩니다.

이 사양은 인증서 정책 작성자와 인증서 발급자가 사용할 두 가지 정책 한정자 유형을 정의합니다. 한정자 유형은 CPS 포인터 및 사용자 알림 한정자입니다.

CPS 포인터 한정자에는 CA가 게시한 CPS\(인증 업무 기술서\)에 대한 포인터가 포함되어 있습니다. 포인터는 URI 형식입니다. 이 한정자에 대한 처리 요구 사항은 지역적 문제입니다. 확장에 대해 주장된 중요도 값에 관계없이 이 사양에서는 어떤 조치도 요구하지 않습니다.

사용자 알림은 인증서를 사용할 때 신뢰 당사자에게 표시하기 위한 것입니다. 경로 유효성 검사의 결과로 반환된 사용자 알림만 사용자에게 표시됩니다. 공지사항인 경우

복제된 경우에는 복사본 하나만 표시하면 됩니다. 이러한 중복을 방지하려면 이 한정자는 최종 엔터티 인증서와 다른 조직에 발급된 CA 인증서에만 있어야 합니다.

사용자 알림에는 2개의 선택 필드\(noticeRef 필드와explicitText 필드\)가 있습니다. 준수 CA는 통지Ref 옵션을 사용해서는 안 됩니다.

- 통지Ref 필드가 사용되는 경우 조직의 이름을 지정하고 해당 조직에서 준비한 특정 텍스트 설명을 번호로 식별합니다. 예를 들어 조직 "CertsRUs"와 공지 번호 1을 식별할 수 있습니다. 일반적인 구현에서 응용 프로그램 소프트웨어에는 CertsRU에 대한 현재 공지 세트가 포함된 공지 파일이 있습니다. 애플리케이션은 파일에서 알림 텍스트를 추출하여 표시합니다. 메시지는 다국어일 수 있으며, 이를 통해 소프트웨어는 자체 환경에 맞는 특정 언어 메시지를 선택할 수 있습니다.

-explicitText 필드에는 인증서에 직접 텍스트 설명이 포함됩니다. explicitText 필드는 최대 크기가 200자인 문자열입니다. 준수 CA는explicitText에 대해 UTF8String 인코딩을 사용해야 하지만 IA5String을 사용할 수도 있습니다. CA를 준수하는 경우 명시적 텍스트를 VisibleString 또는 BMPString으로 인코딩하면 안 됩니다. licitText 문자열에는 제어 문자\(예: U+0000\~U+001F 및 U+007F\~U+009F\)가 포함되어서는 안 됩니다. UTF8String 인코딩이 사용되는 경우 모든 문자 시퀀스는 유니코드 정규화 형식 C\(NFC\)\[NFC\]에 따라 정규화되어야 합니다.

통지Ref 및explicitText 옵션이 모두 하나의 한정자에 포함되어 있고 응용 프로그램 소프트웨어가 통지Ref 옵션에 의해 표시된 통지 텍스트를 찾을 수 있는 경우 해당 텍스트가 표시되어야 합니다. 그렇지 않으면,explicitText 문자열이 표시되어야 합니다.

참고:explicitText의 최대 크기는 200자이지만 일부 비준수 CA는 이 제한을 초과합니다. 따라서 인증서 사용자는 200자가 넘는 명시적 텍스트를 적절하게 처리해야 합니다.

```text
   id-ce-certificatePolicies OBJECT IDENTIFIER ::=  { id-ce 32 }

   anyPolicy OBJECT IDENTIFIER ::= { id-ce-certificatePolicies 0 }
```

CertificatePolicies ::= 정책 정보의 시퀀스 크기\(1..MAX\)

```text
   PolicyInformation ::= SEQUENCE {
        policyIdentifier   CertPolicyId,
        policyQualifiers   SEQUENCE SIZE (1..MAX) OF
                                PolicyQualifierInfo OPTIONAL }

   CertPolicyId ::= OBJECT IDENTIFIER

   PolicyQualifierInfo ::= SEQUENCE {
        policyQualifierId  PolicyQualifierId,
        qualifier          ANY DEFINED BY policyQualifierId }
```

-- 인터넷 정책 한정자를 위한policyQualifierIds

```text
   id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
   id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
   id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }

   PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )

   Qualifier ::= CHOICE {
        cPSuri           CPSuri,
        userNotice       UserNotice }

   CPSuri ::= IA5String

   UserNotice ::= SEQUENCE {
        noticeRef        NoticeReference OPTIONAL,
        explicitText     DisplayText OPTIONAL }

   NoticeReference ::= SEQUENCE {
        organization     DisplayText,
        noticeNumbers    SEQUENCE OF INTEGER }

   DisplayText ::= CHOICE {
        ia5String        IA5String      (SIZE (1..200)),
        visibleString    VisibleString  (SIZE (1..200)),
        bmpString        BMPString      (SIZE (1..200)),
        utf8String       UTF8String     (SIZE (1..200)) }
```

---
##### **4.2.1.5.  Policy Mappings**

이 확장은 CA 인증서에 사용됩니다. 하나 이상의 OID 쌍을 나열합니다. 각 쌍에는 issuerDomainPolicy와 subjectDomainPolicy가 포함되어 있습니다. 페어링은 발급 CA가 IssuerDomainPolicy를 주체 CA의 subjectDomainPolicy와 동일하다고 간주함을 나타냅니다.

발급 CA의 사용자는 특정 애플리케이션에 대해 issuerDomainPolicy를 수락할 수 있습니다. 정책 매핑은 issuerDomainPolicy와 비교할 수 있는 것으로 허용될 수 있는 주체 CA와 관련된 정책 목록을 정의합니다.

정책 매핑 확장에 명명된 각 issuerDomainPolicy는 동일한 인증서의 인증서 정책 확장에서도 주장되어야 합니다. 정책은 특수 값 anyPolicy\(섹션 4.2.1.4\)로 매핑되어서는 안 됩니다.

일반적으로 정책 매핑 확장의 issuerDomainPolicy 필드에 나타나는 인증서 정책은 인증 경로의 후속 인증서에 포함할 수 있는 정책으로 간주되지 않습니다. 어떤 상황에서는 CA가 한 정책\(p1\)에서 다른 정책\(p2\)으로 매핑하기를 원하지만 여전히 issuerDomainPolicy\(p1\)가 후속 인증서에 포함되도록 허용되기를 원할 수 있습니다. 예를 들어 CA가 정책 p1 사용에서 정책 p2 사용으로 전환하는 중이고 각 정책에 따라 발급된 유효한 인증서가 있는 경우 이런 일이 발생할 수 있습니다. CA는 발급하는 CA 인증서에 두 가지 정책 매핑을 포함하여 이를 나타낼 수 있습니다. 각 정책 매핑에는 p1의 issuerDomainPolicy가 있습니다. 한 정책 매핑에는 p1의 subjectDomainPolicy가 있고 다른 정책 매핑에는 p2의 subjectDomainPolicy가 있습니다.

이 확장은 CA 및/또는 애플리케이션에서 지원될 수 있습니다. CA를 준수하는 경우에는 이 확장을 중요로 표시해야 합니다.

```text
   id-ce-policyMappings OBJECT IDENTIFIER ::=  { id-ce 33 }

   PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {
        issuerDomainPolicy      CertPolicyId,
        subjectDomainPolicy     CertPolicyId }
```

---
##### **4.2.1.6.  Subject Alternative Name**

주체 대체 이름 확장을 사용하면 ID를 인증서 주체에 바인딩할 수 있습니다. 이러한 ID는 인증서의 제목 필드에 있는 ID에 추가로 또는 대신 포함될 수 있습니다. 정의된 옵션에는 인터넷 전자 메일이 포함됩니다.

주소, DNS 이름, IP 주소 및 URI\(Uniform Resource Identifier\)입니다. 완전히 로컬 정의를 포함하여 다른 옵션도 존재합니다. 여러 이름 형식과 각 이름 형식의 여러 인스턴스가 포함될 수 있습니다. 이러한 ID를 인증서에 바인딩할 때마다 주체 대체 이름\(또는 발급자 대체 이름\) 확장을 사용해야 합니다. 그러나 DNS 이름은 섹션 4.1.2.4에 설명된 대로 domainComponent 속성을 사용하여 제목 필드에 표시될 수도 있습니다. 이러한 이름이 제목 필드 구현에 표시되는 경우 해당 이름을 DNS 이름으로 변환할 필요가 없습니다.

주체 대체 이름은 공개 키에 확실히 바인딩된 것으로 간주되므로 주체 대체 이름의 모든 부분은 CA에서 확인되어야 합니다.

또한 인증서에 포함된 유일한 주체 신원이 대체 이름 형식\(예: 전자 메일 주소\)인 경우 주체 고유 이름은 비어 있어야 하며\(빈 시퀀스\) subjectAltName 확장이 있어야 합니다. 제목 필드에 빈 시퀀스가 ​​포함된 경우 발급 CA는 중요로 표시된 subjectAltName 확장을 포함해야 합니다. 비어 있지 않은 주체 고유 이름이 있는 인증서에 subjectAltName 확장을 포함할 때, 준수 CA는 subjectAltName 확장을 중요하지 않은 것으로 표시해야 합니다.

subjectAltName 확장에 인터넷 메일 주소가 포함된 경우 주소는 rfc822Name에 저장되어야 합니다. rfc822Name의 형식은 \[RFC2821\]의 섹션 4.1.2에 정의된 "Mailbox"입니다. 사서함의 형식은 "Local-part@Domain"입니다. 메일함 앞에는 문구\(예: 일반 이름\)가 없고, 뒤에는 설명\(괄호 안의 텍스트\)이 없으며, "<" 및 "\>"로 둘러싸여 있지 않습니다. 국제화된 도메인 이름을 포함하는 인터넷 메일 주소 인코딩 규칙은 섹션 7.5에 지정되어 있습니다.

subjectAltName 확장에 iPAddress가 포함된 경우 주소는 \[RFC791\]에 지정된 대로 "네트워크 바이트 순서"로 옥텟 문자열에 저장되어야 합니다. 각 옥텟의 최하위 비트\(LSB\)는 네트워크 주소에서 해당 바이트의 LSB입니다. \[RFC791\]에 지정된 대로 IP 버전 4의 경우 옥텟 문자열은 정확히 4개의 옥텟을 포함해야 합니다. \[RFC2460\]에 지정된 대로 IP 버전 6의 경우 옥텟 문자열은 정확히 16개의 옥텟을 포함해야 합니다.

subjectAltName 확장에 도메인 이름 시스템 레이블이 포함된 경우 도메인 이름은 dNSName\(IA5String\)에 저장되어야 합니다. 이름은 \[RFC1034\]의 섹션 3.5에 지정되고 \[RFC1123\]의 섹션 2.1에 의해 수정된 대로 "선호 이름 구문"에 있어야 합니다. 도메인 이름에는 대문자와 소문자는 허용되지만 대소문자는 의미가 없습니다. \~ 안에

또한 " " 문자열은 합법적인 도메인 이름이지만 dNSName이 " "인 subjectAltName 확장자는 사용하면 안 됩니다. 마지막으로, 인터넷 메일 주소\(subscriber@example.com 대신 subscriber.example.com\)에 대한 DNS 표현을 사용해서는 안 됩니다. 이러한 ID는 rfc822Name으로 인코딩됩니다. 국제화된 도메인 이름 인코딩 규칙은 섹션 7.2에 명시되어 있습니다.

subjectAltName 확장에 URI가 포함되어 있는 경우 이름은uniformResourceIdentifier\(IA5String\)에 저장되어야 합니다. 이름은 상대 URI가 아니어야 하며 \[RFC3986\]에 지정된 URI 구문 및 인코딩 규칙을 따라야 합니다. 이름에는 구성표\(예: "http" 또는 "ftp"\)와 구성표별 부분이 모두 포함되어야 합니다. 기관\(\[RFC3986\], 섹션 3.2\)을 포함하는 URI는 호스트로서 정규화된 도메인 이름 또는 IP 주소를 포함해야 합니다. IRI\(Internationalized Resource Identifier\) ​​인코딩 규칙은 섹션 7.4에 지정되어 있습니다.

\[RFC3986\]에 지정된 대로 체계 이름은 대소문자를 구분하지 않습니다\(예: "http"는 "HTTP"와 동일함\). 호스트 부분\(있는 경우\)도 대소문자를 구분하지 않지만 구성표별 부분의 다른 구성 요소는 대소문자를 구분할 수 있습니다. URI 비교 규칙은 섹션 7.4에 지정되어 있습니다.

subjectAltName 확장이 디렉토리 이름에 DN을 포함하는 경우 인코딩 규칙은 섹션 4.1.2.4의 발급자 필드에 대해 지정된 규칙과 동일합니다. DN은 발급자 필드에 정의된 대로 하나의 CA에서 인증한 각 주체 엔터티에 대해 고유해야 합니다. CA는 동일한 주체 엔터티에 대해 동일한 DN을 가진 두 개 이상의 인증서를 발급할 수 있습니다.

subjectAltName은 otherName 필드를 사용하여 추가 이름 유형을 전달할 수 있습니다. 이름의 형식과 의미는 type-id 필드의 OBJECT IDENTIFIER를 통해 표시됩니다. 이름 자체는 otherName의 값 필드로 전달됩니다. 예를 들어, Kerberos \[RFC4120\] 형식 이름은 Kerberos 5 주체 이름 OID와 Realm 및 PrincipalName의 SEQUENCE를 사용하여 otherName으로 인코딩될 수 있습니다.

주체 대체 이름은 섹션 4.2.1.10에 설명된 이름 제약 확장을 사용하여 주체 고유 이름과 동일한 방식으로 제한될 수 있습니다.

subjectAltName 확장이 있는 경우 시퀀스에는 최소한 하나의 항목이 포함되어야 합니다. 제목 필드와 달리, 준수 CA는 빈 GeneralName 필드가 포함된 subjectAltNames가 있는 인증서를 발급해서는 안 됩니다. 예를 들어 rfc822Name은 IA5String으로 표시됩니다. 빈 문자열은 유효한 IA5String이지만 이러한 rfc822Name은 이 프로필에서 허용되지 않습니다. 클라이언트의 행동

인증 경로를 처리할 때 이러한 인증서를 발견하는 것은 이 프로필에 의해 정의되지 않습니다.

마지막으로, 와일드카드 문자\(예: 이름 집합에 대한 자리 표시자\)를 포함하는 주체 대체 이름의 의미는 이 사양에서 다루지 않습니다. 특정 요구 사항이 있는 애플리케이션은 이러한 이름을 사용할 수 있지만 의미를 정의해야 합니다.

```text
   id-ce-subjectAltName OBJECT IDENTIFIER ::=  { id-ce 17 }

   SubjectAltName ::= GeneralNames
```

GeneralNames ::= GeneralName의 시퀀스 크기\(1..MAX\)

```text
   GeneralName ::= CHOICE {
        otherName                       [0]     OtherName,
        rfc822Name                      [1]     IA5String,
        dNSName                         [2]     IA5String,
        x400Address                     [3]     ORAddress,
        directoryName                   [4]     Name,
        ediPartyName                    [5]     EDIPartyName,
        uniformResourceIdentifier       [6]     IA5String,
        iPAddress                       [7]     OCTET STRING,
        registeredID                    [8]     OBJECT IDENTIFIER }

   OtherName ::= SEQUENCE {
        type-id    OBJECT IDENTIFIER,
        value      [0] EXPLICIT ANY DEFINED BY type-id }

   EDIPartyName ::= SEQUENCE {
        nameAssigner            [0]     DirectoryString OPTIONAL,
        partyName               [1]     DirectoryString }
```

---
##### **4.2.1.7.  Issuer Alternative Name**

섹션 4.2.1.6과 마찬가지로 이 확장은 인터넷 스타일 ID를 인증서 발급자와 연결하는 데 사용됩니다. 발급자 대체 이름은 4.2.1.6과 같이 인코딩되어야 합니다. 발급자 대체 이름은 섹션 6의 인증 경로 유효성 검사 알고리즘의 일부로 처리되지 않습니다. \(즉, 발급자 대체 이름은 이름 체인에 사용되지 않으며 이름 제약 조건이 적용되지 않습니다.\)

존재하는 경우, 준수 CA는 이 확장을 중요하지 않은 것으로 표시해야 합니다.

```text
   id-ce-issuerAltName OBJECT IDENTIFIER ::=  { id-ce 18 }

   IssuerAltName ::= GeneralNames
```

---
##### **4.2.1.8.  Subject Directory Attributes**

주체 디렉토리 속성 확장은 주체의 식별 속성\(예: 국적\)을 전달하는 데 사용됩니다. 확장은 하나 이상의 속성의 시퀀스로 정의됩니다. 준수 CA는 이 확장을 중요하지 않은 것으로 표시해야 합니다.

```text
   id-ce-subjectDirectoryAttributes OBJECT IDENTIFIER ::=  { id-ce 9 }
```

SubjectDirectoryAttributes ::= SEQUENCE SIZE \(1..MAX\) OF 속성

---
##### **4.2.1.9.  Basic Constraints**

기본 제약 조건 확장은 인증서의 주체가 CA인지 여부와 이 인증서를 포함하는 유효한 인증 경로의 최대 깊이를 식별합니다.

CA 부울은 인증된 공개 키가 인증서 서명을 확인하는 데 사용될 수 있는지 여부를 나타냅니다. CA 부울이 주장되지 않으면 키 사용 확장의 keyCertSign 비트가 주장되어서는 안 됩니다. 기본 제약 확장이 버전 3 인증서에 없거나 확장이 있지만 CA 부울이 주장되지 않은 경우 인증된 공개 키를 인증서 서명을 확인하는 데 사용해서는 안 됩니다.

pathLenConstraint 필드는 cA 부울이 주장되고 키 사용 확장\(있는 경우\)이 keyCertSign 비트\(섹션 4.2.1.3\)를 주장하는 경우에만 의미가 있습니다. 이 경우 유효한 인증 경로에서 이 인증서를 따를 수 있는 자체 발급되지 않은 중간 인증서의 최대 수를 제공합니다. \(참고: 인증 경로의 마지막 인증서는 중간 인증서가 아니며 이 제한에 포함되지 않습니다. 일반적으로 마지막 인증서는 최종 엔터티 인증서이지만 CA 인증서일 수도 있습니다.\) pathLenConstraint가 0이면 다음을 나타냅니다. 자체 발급되지 않은 중간 CA 인증서는 유효한 인증 경로를 따를 수 없습니다. 나타나는 경우 pathLenConstraint 필드는 0보다 크거나 같아야 합니다. pathLenConstraint가 나타나지 않는 경우에는 제한이 적용되지 않습니다.

준수 CA는 인증서의 디지털 서명을 검증하는 데 사용되는 공개 키를 포함하는 모든 CA 인증서에 이 확장을 포함해야 하며 해당 인증서에서 확장을 중요로 표시해야 합니다. 이 확장은 인증서의 디지털 서명 유효성 검사 이외의 목적으로만 사용되는 공개 키를 포함하는 CA 인증서에서 중요하거나 중요하지 않은 확장으로 나타날 수 있습니다. 이러한 CA 인증서에는 CRL의 디지털 서명 검증에만 사용되는 공개 키가 포함된 인증서와 인증서와 함께 사용되는 키 관리 공개 키가 포함된 인증서가 포함됩니다.

등록 프로토콜. 이 확장은 최종 엔터티 인증서에서 중요하거나 중요하지 않은 확장으로 나타날 수 있습니다.

CA는 CA 부울이 주장되고 키 사용 확장이 keyCertSign 비트를 주장하지 않는 한 pathLenConstraint 필드를 포함해서는 안 됩니다.

```text
   id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }

   BasicConstraints ::= SEQUENCE {
        cA                      BOOLEAN DEFAULT FALSE,
        pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
```

---
##### **4.2.1.10.  Name Constraints**

CA 인증서에서만 사용해야 하는 이름 제약 확장은 인증 경로에 있는 후속 인증서의 모든 주체 이름이 위치해야 하는 네임스페이스를 나타냅니다. 제한 사항은 주체 고유 이름에 적용되고 주체 대체 이름에도 적용됩니다. 제한 사항은 지정된 이름 형식이 있는 경우에만 적용됩니다. 인증서에 해당 유형의 이름이 없으면 인증서가 허용됩니다.

자체 발급된 인증서에는 이름 제약 조건이 적용되지 않습니다\(인증서가 경로의 최종 인증서가 아닌 경우\). \(이렇게 하면 이름 제약 조건을 사용하는 CA가 자체 발급 인증서를 사용하여 키 롤오버를 구현하는 것을 방지할 수 있습니다.\)

제한사항은 허용되거나 제외된 이름 하위 트리 측면에서 정의됩니다. ExceptSubtrees 필드의 제한 사항과 일치하는 모든 이름은 allowedSubtrees에 나타나는 정보에 관계없이 유효하지 않습니다. 준수 CA는 이 확장자를 중요로 표시해야 하며 x400Address, ediPartyName 또는 등록된 ID 이름 형식에 이름 제약 조건을 적용해서는 안 됩니다. 준수 CA는 이름 제약 조건이 빈 시퀀스인 인증서를 발행해서는 안 됩니다. 즉, allowedSubtrees 필드나 제외된Subtrees가 반드시 있어야 합니다.

이 프로필을 준수하는 애플리케이션은 DirectoryName 이름 형식에 적용되는 이름 제약 조건을 처리할 수 있어야 하며\(MUST\) rfc822Name,uniformResourceIdentifier, dNSName 및 iPAddress 이름 형식에 적용되는 이름 제약 조건을 처리할 수 있어야 합니다. 중요로 표시된 이름 제약 확장이 특정 이름 형식에 제약을 부과하고 해당 이름 형식의 인스턴스가 후속 인증서의 제목 필드 또는 subjectAltName 확장에 나타나는 경우 애플리케이션은 제약 조건을 처리하거나 인증서를 거부해야 합니다. .

이 프로필 내에서 최소 및 최대 필드는 이름 형식과 함께 사용되지 않으므로 최소값은 0이어야 하고 최대값은 없어야 합니다\(MUST\). 그러나 애플리케이션이 후속 인증서에 나타나는 이름 형식의 최소값 또는 최대값에 대한 다른 값을 지정하는 중요한 이름 제약 조건 확장을 발견하는 경우 애플리케이션은 이러한 필드를 처리하거나 인증서를 거부해야 합니다.

URI의 경우 제약조건은 이름의 호스트 부분에 적용됩니다. 제약조건은 정규화된 도메인 이름으로 지정되어야 하며 호스트 또는 도메인을 지정할 수 있습니다. 예를 들면 "host.example.com" 및 ".example.com"입니다. 제약 조건이 마침표로 시작되면 하나 이상의 레이블로 확장될 수 있습니다. 즉, 제약 조건 ".example.com"은 host.example.com과 my.host.example.com 모두에서 충족됩니다. 그러나 ".example.com" 제약조건은 "example.com"에 의해 충족되지 않습니다. 제약 조건이 마침표로 시작하지 않으면 호스트를 지정합니다. 제약 조건이 균일한 리소스 식별자\(uniformResourceIdentifier\) ​​이름 형식에 적용되고 후속 인증서에 정규화된 도메인 이름으로 지정된 호스트 이름이 있는 권한 구성 요소를 포함하지 않는 균일한 리소스 식별자\(uniformResourceIdentifier\)가 있는 subjectAltName 확장이 포함된 경우\(예: URI에 기관 구성 요소 또는 호스트 이름이 IP 주소로 지정된 기관 구성 요소를 포함하는 경우\) 애플리케이션은 인증서를 거부해야 합니다.

인터넷 메일 주소에 대한 이름 제약은 특정 메일함, 특정 호스트의 모든 주소 또는 도메인의 모든 메일함을 지정할 수 있습니다. 특정 사서함을 나타내기 위한 제약 조건은 전체 메일 주소입니다. 예를 들어 "root@example.com"은 "example.com" 호스트의 루트 사서함을 나타냅니다. 특정 호스트의 모든 인터넷 메일 주소를 나타내기 위해 제약 조건은 호스트 이름으로 지정됩니다. 예를 들어, "example.com" 제약 조건은 "example.com" 호스트의 모든 메일 주소에 의해 충족됩니다. 도메인 내의 주소를 지정하려면 URI와 마찬가지로 선행 마침표를 사용하여 제약 조건을 지정합니다. 예를 들어, ".example.com"은 "example.com" 도메인의 모든 인터넷 메일 주소를 나타내지만 호스트 "example.com"의 인터넷 메일 주소는 아닙니다.

DNS 이름 제한은 host.example.com으로 표현됩니다. 이름 왼쪽에 0개 이상의 레이블을 추가하여 구성할 수 있는 모든 DNS 이름은 이름 제약 조건을 충족합니다. 예를 들어, www.host.example.com은 제약 조건을 충족하지만 host1.example.com은 충족하지 않습니다.

emailAddress 유형 속성의 제목 고유 이름에 전자 메일 주소가 포함된 레거시 구현이 존재합니다\(섹션 4.1.2.6\). 에 제약이 가해질 때

rfc822Name 이름 형식이지만 인증서에 주체 대체 이름이 포함되어 있지 않으면 rfc822Name 제약 조건이 주체 고유 이름의 emailAddress 유형 속성에 적용되어야 합니다. emailAddress에 대한 ASN.1 구문과 해당 OID는 부록 A에 제공됩니다.

DirectoryName 형식의 제한 사항은 인증서의 제목 필드\(인증서에 비어 있지 않은 제목 필드가 포함된 경우\)와 subjectAltName 확장에 있는 DirectoryName 유형의 모든 이름에 적용되어야 합니다. x400Address 형식의 제한 사항은 subjectAltName 확장의 x400Address 유형 이름에 적용되어야 합니다.

DirectoryName 형식의 제한 사항을 적용할 때 구현에서는 DN 속성을 비교해야 합니다. 최소한 구현은 섹션 7.1에 지정된 DN 비교 규칙을 수행해야 합니다. DirectoryName 형식의 제한이 있는 인증서를 발급하는 CA는 전체 ISO DN 이름 비교 알고리즘의 구현에 의존해서는 안 됩니다. 이는 이름 제한이 제목 필드 또는 subjectAltName 확장에 사용된 인코딩과 동일하게 명시되어야 함을 의미합니다.

iPAddress의 구문은 특히 이름 제약 조건에 대해 다음 추가 사항을 포함하여 섹션 4.2.1.6에 설명된 것과 같아야 합니다. IPv4 주소의 경우 GeneralName의 iPAddress 필드에는 주소 범위\[RFC4632\]를 나타내기 위해 RFC 4632\(CIDR\) 스타일로 인코딩된 8옥텟이 포함되어야 합니다. IPv6 주소의 경우 iPAddress 필드는 유사하게 인코딩된 32옥텟을 포함해야 합니다. 예를 들어 "클래스 C" 서브넷 192.0.2.0에 대한 이름 제약 조건은 CIDR 표기법 192.0.2.0/24\(마스크 255.255.255.0\)를 나타내는 옥텟 C0 00 02 00 FF FF FF 00으로 표시됩니다.

이름 제약 조건 인코딩 및 처리에 대한 추가 규칙은 섹션 7에 지정되어 있습니다.

otherName, ediPartyName 및 RegisteredID에 대한 이름 제약 조건의 구문 및 의미는 이 사양에 의해 정의되지 않습니다. 그러나 다른 이름 형식에 대한 이름 제약 조건의 구문 및 의미는 다른 문서에서 지정될 수 있습니다.

```text
      id-ce-nameConstraints OBJECT IDENTIFIER ::=  { id-ce 30 }

      NameConstraints ::= SEQUENCE {
           permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
           excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
```

- GeneralSubtrees ::= GeneralSubtree의 시퀀스 크기\(1..MAX\)

```text
      GeneralSubtree ::= SEQUENCE {
           base                    GeneralName,
           minimum         [0]     BaseDistance DEFAULT 0,
           maximum         [1]     BaseDistance OPTIONAL }

      BaseDistance ::= INTEGER (0..MAX)
```

---
##### **4.2.1.11.  Policy Constraints**

정책 제약 확장은 CA에 발급된 인증서에 사용될 수 있습니다. 정책 제약 확장은 두 가지 방법으로 경로 유효성 검사를 제한합니다. 정책 매핑을 금지하거나 경로의 각 인증서에 허용 가능한 정책 식별자가 포함되도록 요구하는 데 사용할 수 있습니다.

InhibitPolicyMapping 필드가 있는 경우 값은 정책 매핑이 더 이상 허용되지 않기 전에 경로에 나타날 수 있는 추가 인증서 수를 나타냅니다. 예를 들어, 값 1은 정책 매핑이 이 인증서의 주체가 발급한 인증서에서 처리될 수 있지만 경로의 추가 인증서에서는 처리될 수 없음을 나타냅니다.

requireExplicitPolicy 필드가 있는 경우 requireExplicitPolicy 값은 전체 경로에 대해 명시적 정책이 필요하기 전에 경로에 나타날 수 있는 추가 인증서 수를 나타냅니다. 명시적인 정책이 필요한 경우 경로의 모든 인증서는 인증서 정책 확장에 허용되는 정책 식별자를 포함해야 합니다. 허용 가능한 정책 식별자는 인증 경로의 사용자가 요구하는 정책 식별자 또는 정책 매핑을 통해 동등하다고 선언된 정책 식별자입니다.

준수 애플리케이션은 requireExplicitPolicy 필드를 처리할 수 있어야 하며\(MUST\) InhibitPolicyMapping 필드를 처리할 수 있어야 합니다\(SHOULD\). InhibitPolicyMapping 필드를 지원하는 애플리케이션은 PolicyMappings 확장에 대한 지원도 구현해야 합니다. PolicyConstraints 확장이 중요로 표시되고 InhibitPolicyMapping 필드가 존재하는 경우, InhibitPolicyMapping 필드에 대한 지원을 구현하지 않는 애플리케이션은 인증서를 거부해야 합니다.

준수 CA는 정책 제약 조건이 빈 시퀀스인 인증서를 발행해서는 안 됩니다. 즉,hibitPolicyMapping 필드나 requireExplicitPolicy 필드가 반드시 존재해야 합니다. 빈 정책 제약 조건 필드가 나타나는 클라이언트의 동작은 이 프로필에서 다루어지지 않습니다.

준수 CA는 이 확장을 중요로 표시해야 합니다.

```text
   id-ce-policyConstraints OBJECT IDENTIFIER ::=  { id-ce 36 }

   PolicyConstraints ::= SEQUENCE {
        requireExplicitPolicy           [0] SkipCerts OPTIONAL,
        inhibitPolicyMapping            [1] SkipCerts OPTIONAL }

   SkipCerts ::= INTEGER (0..MAX)
```

---
##### **4.2.1.12.  Extended Key Usage**

이 확장은 키 사용 확장에 표시된 기본 목적에 추가로 또는 대신하여 인증된 공개 키를 사용할 수 있는 하나 이상의 목적을 나타냅니다. 일반적으로 이 확장은 최종 엔터티 인증서에만 나타납니다. 이 확장은 다음과 같이 정의됩니다.

```text
   id-ce-extKeyUsage OBJECT IDENTIFIER ::= { id-ce 37 }
```

ExtKeyUsageSyntax ::= KeyPurposeId의 시퀀스 크기\(1..MAX\)

```text
   KeyPurposeId ::= OBJECT IDENTIFIER
```

주요 목적은 필요한 모든 조직에서 정의할 수 있습니다. 키 목적을 식별하는 데 사용되는 객체 식별자는 IANA 또는 ITU-T 권고 X.660 \[X.660\]에 따라 할당되어야 합니다.

이 확장은 인증서 발급자의 선택에 따라 중요하거나 중요하지 않을 수 있습니다.

확장이 있는 경우 인증서는 표시된 목적 중 하나로만 사용해야 합니다. 여러 목적이 표시된 경우 의도된 목적이 존재하는 한 애플리케이션은 표시된 모든 목적을 인식할 필요가 없습니다. 애플리케이션을 사용하는 인증서는 확장된 키 사용 확장이 존재하고 인증서가 해당 애플리케이션에 허용되도록 특정 목적이 표시되도록 요구할 수 있습니다.

CA가 이러한 애플리케이션을 충족하기 위해 확장된 키 사용을 포함하지만 키 사용을 제한하지 않으려는 경우 CA는 애플리케이션에 필요한 특정 키 목적 외에도 특수 KeyPurposeId anyExtendedKeyUsage를 포함할 수 있습니다. 준수 CA는 anyExtendedKeyUsage KeyPurposeId가 존재하는 경우 이 확장을 중요로 표시해서는 안 됩니다. 특정 목적의 존재를 요구하는 애플리케이션은 anyExtendedKeyUsage OID를 포함하지만 애플리케이션에 예상되는 특정 OID는 포함하지 않는 인증서를 거부할 수 있습니다.

인증서에 키 사용 확장과 확장된 키 사용 확장이 모두 포함되어 있는 경우 두 확장은 모두 독립적으로 처리되어야 하며 인증서는 두 확장과 일치하는 목적으로만 사용해야 합니다. 두 확장 모두와 일치하는 목적이 없으면 인증서를 어떤 목적으로도 사용해서는 안 됩니다.

다음과 같은 주요 사용 목적이 정의됩니다.

```text
   anyExtendedKeyUsage OBJECT IDENTIFIER ::= { id-ce-extKeyUsage 0 }

   id-kp OBJECT IDENTIFIER ::= { id-pkix 3 }

   id-kp-serverAuth             OBJECT IDENTIFIER ::= { id-kp 1 }
   -- TLS WWW server authentication
   -- Key usage bits that may be consistent: digitalSignature,
   -- keyEncipherment or keyAgreement

   id-kp-clientAuth             OBJECT IDENTIFIER ::= { id-kp 2 }
   -- TLS WWW client authentication
   -- Key usage bits that may be consistent: digitalSignature
   -- and/or keyAgreement

   id-kp-codeSigning             OBJECT IDENTIFIER ::= { id-kp 3 }
   -- Signing of downloadable executable code
   -- Key usage bits that may be consistent: digitalSignature

   id-kp-emailProtection         OBJECT IDENTIFIER ::= { id-kp 4 }
   -- Email protection
   -- Key usage bits that may be consistent: digitalSignature,
   -- nonRepudiation, and/or (keyEncipherment or keyAgreement)

   id-kp-timeStamping            OBJECT IDENTIFIER ::= { id-kp 8 }
   -- Binding the hash of an object to a time
   -- Key usage bits that may be consistent: digitalSignature
   -- and/or nonRepudiation

   id-kp-OCSPSigning            OBJECT IDENTIFIER ::= { id-kp 9 }
   -- Signing OCSP responses
   -- Key usage bits that may be consistent: digitalSignature
   -- and/or nonRepudiation
```

---
##### **4.2.1.13.  CRL Distribution Points**

CRL 배포 지점 확장은 CRL 정보를 얻는 방법을 식별합니다. 확장은 중요하지 않아야 하지만 이 프로필은 CA 및 애플리케이션에서 이 확장을 지원할 것을 권장합니다. CRL 관리에 대한 추가 논의는 섹션 5에 포함되어 있습니다.

cRLDistributionPoints 확장은 DistributionPoint의 SEQUENCE입니다. DistributionPoint는 distributionPoint, 이유 및 cRLIssuer의 세 가지 필드로 구성되며 각 필드는 선택 사항입니다. 이러한 각 필드는 선택 사항이지만 DistributionPoint는 이유 필드로만 구성되어서는 안 됩니다. distributionPoint 또는 cRLIssuer가 있어야 합니다. 인증서 발급자가 CRL 발급자가 아닌 경우 cRLIssuer 필드가 있어야 하며 CRL 발급자의 이름을 포함해야 합니다. 인증서 발급자가 CRL 발급자이기도 한 경우, 준수 CA는 반드시 cRLIssuer 필드를 생략하고 distributionPoint 필드를 포함해야 합니다.

distributionPoint 필드가 있는 경우 일반 이름의 SEQUENCE 또는 단일 값 nameRelativeToCRLIssuer가 포함됩니다. DistributionPointName에 여러 값이 포함된 경우 각 이름은 동일한 CRL을 얻기 위한 서로 다른 메커니즘을 설명합니다. 예를 들어, LDAP와 HTTP를 통해 동일한 CRL을 검색하는 데 사용할 수 있습니다.

distributionPoint 필드에 디렉토리 이름이 포함된 경우 해당 디렉토리 이름에 대한 항목에는 연관된 이유에 대한 현재 CRL이 포함되며 CRL은 연관된 cRLIssuer에 의해 발급됩니다. CRL은 CertificateRevocationList 또는 AuthorityRevocationList 속성에 저장될 수 있습니다. CRL은 로컬로 구성된 디렉터리 서버에서 응용 프로그램에 의해 얻어집니다. 애플리케이션이 디렉토리에 액세스하기 위해 사용하는 프로토콜\(예: DAP 또는 LDAP\)은 로컬 문제입니다.

DistributionPointName에 URI 유형의 일반 이름이 포함되어 있는 경우 다음 의미 체계를 가정해야 합니다. URI는 관련 이유로 인해 현재 CRL에 대한 포인터이며 관련 cRLIssuer에 의해 발급됩니다. HTTP 또는 FTP URI 체계가 사용되는 경우 URI는 \[RFC2585\]에 지정된 대로 단일 DER 인코딩 CRL을 가리켜야 합니다. URI를 통해 액세스되는 HTTP 서버 구현은 응답의 콘텐츠 유형 헤더 필드에 미디어 유형 application/pkix-crl을 지정해야 합니다. LDAP URI 체계 \[RFC4516\]가 사용되는 경우 URI는 CRL을 보유하는 항목의 고유 이름을 포함하는 <dn\> 필드를 포함해야 하며, 해당 속성에 대한 적절한 속성 설명을 포함하는 단일 <attrdesc\>를 포함해야 합니다. CRL \[RFC4523\] 및 <host\>를 포함해야 합니다\(예: <ldap://ldap.example.com/cn=example%20CA,dc=example,dc=com?certificateRevocationList;binary\>\). <host\>\(예: <ldap:///cn=CA,dc=example,dc=com?authorityRevocationList;binary\>\)를 생략하면 클라이언트가 적절한 서버에 연결해야 할 수 있는 사전 지식에 의존하는 효과가 있습니다. . DistributionPointName이 있는 경우 최소한 하나의 LDAP 또는 HTTP URI를 포함해야 합니다.

DistributionPointName에 단일 값 nameRelativeToCRLIssuer가 포함되어 있는 경우 해당 값은 고유 이름을 제공합니다.

파편. 배포 지점 이름을 얻기 위해 CRL 발급자의 X.500 고유 이름에 조각이 추가됩니다. DistributionPoint에 cRLIssuer 필드가 있으면 이름 조각이 포함된 고유 이름에 추가됩니다. 그렇지 않으면 이름 조각이 인증서 발급자 고유 이름에 추가됩니다. 준수 CA는 배포 지점 이름을 지정하기 위해 nameRelativeToCRLIssuer를 사용해서는 안 됩니다. cRLIssuer에 둘 이상의 고유 이름이 포함된 경우 DistributionPointName은 nameRelativeToCRLIssuer 대안을 사용해서는 안 됩니다.

DistributionPoint가 이유 필드를 생략하는 경우 CRL은 모든 이유에 대한 해지 정보를 포함해야 합니다. 이 프로필은 이유 코드별로 CRL을 분할하는 것을 권장하지 않습니다. 준수 CA가 인증서에 cRLDistributionPoints 확장을 포함하는 경우 모든 이유로 인증서를 포함하는 CRL을 가리키는 배포 지점을 하나 이상 포함해야 합니다.

cRLIssuer는 CRL에 서명하고 발급하는 엔터티를 식별합니다. 존재하는 경우 cRLIssuer는 DistributionPoint가 가리키는 CRL의 발급자 필드에 있는 고유 이름\(DN\)만 포함해야 합니다. cRLIssuer 필드의 이름 인코딩은 CRL 발행자 필드의 인코딩과 정확히 동일해야 합니다. cRLIssuer 필드가 포함되어 있고 해당 필드의 DN이 CRL이 있는 X.500 또는 LDAP 디렉터리 항목과 일치하지 않는 경우 준수 CA는 distributionPoint 필드를 포함해야 합니다.

```text
   id-ce-cRLDistributionPoints OBJECT IDENTIFIER ::=  { id-ce 31 }
```

CRLDistributionPoints ::= DistributionPoint의 시퀀스 크기\(1..MAX\)

```text
   DistributionPoint ::= SEQUENCE {
        distributionPoint       [0]     DistributionPointName OPTIONAL,
        reasons                 [1]     ReasonFlags OPTIONAL,
        cRLIssuer               [2]     GeneralNames OPTIONAL }

   DistributionPointName ::= CHOICE {
        fullName                [0]     GeneralNames,
        nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }

   ReasonFlags ::= BIT STRING {
        unused                  (0),
        keyCompromise           (1),
        cACompromise            (2),
        affiliationChanged      (3),
        superseded              (4),
        cessationOfOperation    (5),
        certificateHold         (6),
        privilegeWithdrawn      (7),
        aACompromise            (8) }
```

---
##### **4.2.1.14.  Inhibit anyPolicy**

Inhibit anyPolicy 확장은 CA에 발급된 인증서에 사용될 수 있습니다. 금지 anyPolicy 확장은 값이 { 2 5 29 32 0 }인 특수 anyPolicy OID가 중간 자체 발급 CA 인증서에 나타나는 경우를 제외하고 다른 인증서 정책과 명시적으로 일치하는 것으로 간주되지 않음을 나타냅니다. 값은 anyPolicy가 더 이상 허용되지 않기 전에 경로에 나타날 수 있는 자체 발급되지 않은 추가 인증서 수를 나타냅니다. 예를 들어 값 1은 anyPolicy가 이 인증서의 주체가 발급한 인증서에서 처리될 수 있지만 경로의 추가 인증서에서는 처리될 수 없음을 나타냅니다.

준수 CA는 이 확장을 중요로 표시해야 합니다.

```text
   id-ce-inhibitAnyPolicy OBJECT IDENTIFIER ::=  { id-ce 54 }

   InhibitAnyPolicy ::= SkipCerts

   SkipCerts ::= INTEGER (0..MAX)
```

---
##### **4.2.1.15.  Freshest CRL (a.k.a. Delta CRL Distribution Point)**

최신 CRL 확장은 델타 CRL 정보를 얻는 방법을 식별합니다. 확장은 CA를 준수하여 중요하지 않은 것으로 표시되어야 합니다. CRL 관리에 대한 추가 논의는 섹션 5에 포함되어 있습니다.

이 확장과 cRLDistributionPoints 확장에 동일한 구문이 사용되며 섹션 4.2.1.13에 설명되어 있습니다. 두 확장 모두에 동일한 규칙이 적용됩니다.

```text
   id-ce-freshestCRL OBJECT IDENTIFIER ::=  { id-ce 46 }

   FreshestCRL ::= CRLDistributionPoints
```

---
#### **4.2.2.  Private Internet Extensions**

이 섹션에서는 인터넷 공개 키 인프라에서 사용할 두 가지 확장을 정의합니다. 이러한 확장은 발행자 또는 주제에 관한 온라인 정보로 애플리케이션을 안내하는 데 사용될 수 있습니다. 각 확장에는 일련의 액세스 방법과 액세스 위치가 포함되어 있습니다. 액세스 방법은 사용 가능한 정보 유형을 나타내는 개체 식별자입니다. 액세스 위치는 정보의 위치와 형식, 정보를 얻는 방법을 암시적으로 지정하는 GeneralName입니다.

개인 확장에 대해 개체 식별자가 정의됩니다. 개인 확장과 연관된 객체 식별자는 arc id-pkix 내의 arc id-pe 아래에 정의됩니다. 인터넷 PKI에 대해 정의된 향후 확장도 arc id-pe 아래에 정의될 것으로 예상됩니다.

```text
      id-pkix  OBJECT IDENTIFIER  ::=
               { iso(1) identified-organization(3) dod(6) internet(1)
                       security(5) mechanisms(5) pkix(7) }

      id-pe  OBJECT IDENTIFIER  ::=  { id-pkix 1 }
```

---
##### **4.2.2.1.  Authority Information Access**

기관정보 접근 확장은 해당 확장이 나타나는 인증서 발급자의 정보 및 서비스에 접근하는 방법을 나타낸다. 정보 및 서비스에는 온라인 검증 서비스 및 CA 정책 데이터가 포함될 수 있습니다. \(CRL의 위치는 이 확장에 지정되지 않습니다. 해당 정보는 cRLDistributionPoints 확장에 의해 제공됩니다.\) 이 확장은 최종 엔터티 또는 CA 인증서에 포함될 수 있습니다. 준수 CA는 이 확장을 중요하지 않은 것으로 표시해야 합니다.

```text
   id-pe-authorityInfoAccess OBJECT IDENTIFIER ::= { id-pe 1 }

   AuthorityInfoAccessSyntax  ::=
           SEQUENCE SIZE (1..MAX) OF AccessDescription

   AccessDescription  ::=  SEQUENCE {
           accessMethod          OBJECT IDENTIFIER,
           accessLocation        GeneralName  }

   id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }

   id-ad-caIssuers OBJECT IDENTIFIER ::= { id-ad 2 }

   id-ad-ocsp OBJECT IDENTIFIER ::= { id-ad 1 }
```

AuthorityInfoAccessSyntax 시퀀스의 각 항목은 이 확장이 나타나는 인증서 발급자가 제공하는 추가 정보의 형식과 위치를 설명합니다. 정보의 유형과 형식은 accessMethod 필드에 의해 지정됩니다. accessLocation 필드는 정보의 위치를 ​​지정합니다. 검색 메커니즘은 accessMethod에 의해 암시되거나 accessLocation에 의해 지정될 수 있습니다.

이 프로필은 id-ad-caIssuers 및 id-ad-ocsp라는 두 가지 accessMethod OID를 정의합니다.

공개 키 인증서에서 id-ad-caIssuers OID는 이 확장이 포함된 인증서를 발급한 CA에 발급된 인증서를 추가 정보에 나열할 때 사용됩니다. 참조된 CA 발급자 설명은 인증서 사용자가 인증서 사용자가 신뢰하는 지점에서 종료되는 인증 경로를 선택하는 데 도움을 주기 위한 것입니다.

id-ad-caIssuers가 accessMethod로 나타나면 accessLocation 필드는 참조된 설명 서버와 참조된 설명을 얻기 위한 액세스 프로토콜을 설명합니다. accessLocation 필드는 여러 형식을 취할 수 있는 GeneralName으로 정의됩니다.

accessLocation이 디렉토리 이름인 경우 애플리케이션은 로컬로 구성된 디렉토리 서버에서 정보를 가져옵니다. DirectoryName에 대한 항목에는 \[RFC4523\]에 지정된 대로 crossCertificatePair 및/또는 cACertificate 속성의 CA 인증서가 포함되어 있습니다. 애플리케이션이 디렉토리에 액세스하기 위해 사용하는 프로토콜\(예: DAP 또는 LDAP\)은 로컬 문제입니다.

LDAP를 통해 정보를 사용할 수 있는 경우 accessLocation은uniformResourceIdentifier여야 합니다. LDAP URI \[RFC4516\]에는 인증서를 보유하는 항목의 고유 이름을 포함하는 <dn\> 필드가 포함되어야 하며, DER로 인코딩된 인증서 또는 교차 인증서 쌍을 보유하는 속성에 대한 적절한 속성 설명을 나열하는 <attributes\> 필드가 포함되어야 합니다. \[RFC4523\], <host\>\(예: <ldap://ldap.example.com/cn=CA, dc=example,dc=com?cACertificate;binary,crossCertificatePair;binary\>\)를 포함해야 합니다. <host\>\(예: <ldap:///cn=exampleCA,dc=example,dc=com? cACertificate;binary\>\)를 생략하면 클라이언트가 적절한 서버에 연결해야 할 수 있는 사전 지식에 의존하는 효과가 있습니다. .

HTTP 또는 FTP를 통해 정보를 사용할 수 있는 경우 accessLocation은uniformResourceIdentifier여야 하며 URI는 \[RFC2585\]에 지정된 단일 DER 인코딩 인증서 또는 BER 또는 DER 인코딩된 "인증서 전용" CMS의 인증서 모음을 가리켜야 합니다. \[RFC2797\]에 지정된 메시지입니다.

인증서 액세스를 위해 HTTP 또는 FTP를 지원하는 애플리케이션을 준수하는 것은 개별 DER로 인코딩된 인증서를 수락할 수 있어야 하며 "인증서 전용" CMS 메시지를 수락할 수 있어야 합니다.

URI를 통해 액세스되는 HTTP 서버 구현은 단일 DER 인코딩 인증서에 대한 응답의 콘텐츠 유형 헤더 필드에 미디어 유형 application/pkix-cert \[RFC2585\]를 지정해야 하며 미디어 유형 application/pkcs7-mime \[RFC2797\]을 지정해야 합니다. "인증서 전용" CMS 메시지에 대한 응답의 콘텐츠 유형 헤더 필드에 있습니다. FTP의 경우 단일 DER 인코딩 인증서를 포함하는 파일 이름에는 ".cer" \[RFC2585\] 접미사가 있어야 하고 "인증서 전용" CMS 메시지를 포함하는 파일 이름에는 ".cer" 접미사가 있어야 합니다. p7c" \[RFC2797\]. 소비자 클라이언트는 미디어 유형이나 파일 확장자를 콘텐츠에 대한 힌트로 사용할 수 있지만 서버 응답에 올바른 미디어 유형이나 파일 확장자가 있는지에만 의존해서는 안 됩니다.

다른 id-ad-caIssuers accessLocation 이름 형식의 의미는 정의되지 않습니다.

AuthorityInfoAccess 확장에는 id-ad-caIssuers accessMethod의 여러 인스턴스가 포함될 수 있습니다. 서로 다른 인스턴스는 동일한 정보에 액세스하기 위한 서로 다른 방법을 지정하거나 서로 다른 정보를 가리킬 수 있습니다. id-ad-caIssuers accessMethod가 사용되는 경우 적어도 하나의 인스턴스는 HTTP \[RFC2616\] 또는 LDAP \[RFC4516\] URI인 accessLocation을 지정해야 합니다.

id-ad-ocsp OID는 이 확장이 포함된 인증서에 대한 해지 정보가 온라인 인증서 상태 프로토콜\(OCSP\) \[RFC2560\]을 사용하여 제공될 때 사용됩니다.

id-ad-ocsp가 accessMethod로 나타나는 경우 accessLocation 필드는 \[RFC2560\]에 정의된 규칙을 사용하는 OCSP 응답자의 위치입니다.

추가 액세스 설명자는 다른 PKIX 사양에서 정의될 수 있습니다.

---
##### **4.2.2.2.  Subject Information Access**

주체정보 접근 확장자는 확장자가 나타나는 인증서의 주체에 대한 정보 및 서비스에 접근하는 방법을 나타낸다. 주체가 CA인 경우 정보 및 서비스에는 인증서 유효성 검사 서비스 및 CA 정책 데이터가 포함될 수 있습니다. 주체가 최종 엔터티인 경우 정보는 제공되는 서비스 유형과 해당 서비스에 액세스하는 방법을 설명합니다. 이 경우 이 확장의 내용은 프로토콜에 정의됩니다.

지원되는 서비스 사양입니다. 이 확장은 최종 엔터티 또는 CA 인증서에 포함될 수 있습니다. 준수 CA는 이 확장을 중요하지 않은 것으로 표시해야 합니다.

```text
   id-pe-subjectInfoAccess OBJECT IDENTIFIER ::= { id-pe 11 }

   SubjectInfoAccessSyntax  ::=
           SEQUENCE SIZE (1..MAX) OF AccessDescription

   AccessDescription  ::=  SEQUENCE {
           accessMethod          OBJECT IDENTIFIER,
           accessLocation        GeneralName  }
```

SubjectInfoAccessSyntax 시퀀스의 각 항목은 이 확장이 나타나는 인증서의 제목이 제공하는 추가 정보의 형식과 위치를 설명합니다. 정보의 유형과 형식은 accessMethod 필드에 의해 지정됩니다. accessLocation 필드는 정보의 위치를 ​​지정합니다. 검색 메커니즘은 accessMethod에 의해 암시되거나 accessLocation에 의해 지정될 수 있습니다.

이 프로파일은 주체가 CA일 때 사용할 액세스 방법과 주체가 최종 엔터티일 때 사용할 액세스 방법을 정의합니다. 향후 다른 서비스의 프로토콜 사양에서 추가적인 액세스 방법이 정의될 수 있습니다.

id-ad-caRepository OID는 주체가 저장소에서 발급한 인증서를 게시하는 CA인 경우에 사용됩니다. accessLocation 필드는 여러 형식을 취할 수 있는 GeneralName으로 정의됩니다.

accessLocation이 디렉토리 이름인 경우 애플리케이션은 로컬로 구성된 디렉토리 서버에서 정보를 가져옵니다. CA 인증서를 가리키는 데 확장이 사용되는 경우, 디렉토리 이름 항목에는 \[RFC4523\]에 지정된 대로 crossCertificatePair 및/또는 cACertificate 속성에 CA 인증서가 포함됩니다. 애플리케이션이 디렉토리에 액세스하기 위해 사용하는 프로토콜\(예: DAP 또는 LDAP\)은 로컬 문제입니다.

LDAP를 통해 정보를 사용할 수 있는 경우 accessLocation은uniformResourceIdentifier여야 합니다. LDAP URI \[RFC4516\]에는 인증서를 보유하는 항목의 고유 이름을 포함하는 <dn\> 필드가 포함되어야 하며, DER로 인코딩된 인증서 또는 교차 인증서 쌍을 보유하는 속성에 대한 적절한 속성 설명을 나열하는 <attributes\> 필드가 포함되어야 합니다. \[RFC4523\], <host\>\(예: <ldap://ldap.example.com/cn=CA, dc=example,dc=com?cACertificate;binary,crossCertificatePair;binary\>\)를 포함해야 합니다.

<host\>\(예: <ldap:///cn=exampleCA,dc=example,dc=com? cACertificate;binary\>\)를 생략하면 클라이언트가 적절한 서버에 연결해야 할 수 있는 사전 지식에 의존하는 효과가 있습니다. .

HTTP 또는 FTP를 통해 정보를 사용할 수 있는 경우 accessLocation은uniformResourceIdentifier여야 하며 URI는 \[RFC2585\]에 지정된 단일 DER 인코딩 인증서 또는 BER 또는 DER 인코딩된 "인증서 전용" CMS의 인증서 모음을 가리켜야 합니다. \[RFC2797\]에 지정된 메시지입니다.

인증서 액세스를 위해 HTTP 또는 FTP를 지원하는 애플리케이션을 준수하는 것은 개별 DER로 인코딩된 인증서를 수락할 수 있어야 하며 "인증서 전용" CMS 메시지를 수락할 수 있어야 합니다.

URI를 통해 액세스되는 HTTP 서버 구현은 단일 DER 인코딩 인증서에 대한 응답의 콘텐츠 유형 헤더 필드에 미디어 유형 application/pkix-cert \[RFC2585\]를 지정해야 하며 미디어 유형 application/pkcs7-mime \[RFC2797\]을 지정해야 합니다. "인증서 전용" CMS 메시지에 대한 응답의 콘텐츠 유형 헤더 필드에 있습니다. FTP의 경우 단일 DER 인코딩 인증서를 포함하는 파일 이름에는 ".cer" \[RFC2585\] 접미사가 있어야 하고 "인증서 전용" CMS 메시지를 포함하는 파일 이름에는 ".cer" 접미사가 있어야 합니다. p7c" \[RFC2797\]. 소비자 클라이언트는 미디어 유형이나 파일 확장자를 콘텐츠에 대한 힌트로 사용할 수 있지만 서버 응답에 올바른 미디어 유형이나 파일 확장자가 있는지에만 의존해서는 안 됩니다.

다른 id-ad-caRepository accessLocation 이름 형식의 의미는 정의되지 않습니다.

subjectInfoAccess 확장에는 id-ad-caRepository accessMethod의 여러 인스턴스가 포함될 수 있습니다. 서로 다른 인스턴스는 동일한 정보에 액세스하기 위한 서로 다른 방법을 지정하거나 서로 다른 정보를 가리킬 수 있습니다. id-ad-caRepository accessMethod가 사용되는 경우 적어도 하나의 인스턴스는 HTTP \[RFC2616\] 또는 LDAP \[RFC4516\] URI인 accessLocation을 지정해야 합니다.

id-ad-timeStamping OID는 주체가 \[RFC3161\]에 정의된 타임스탬프 프로토콜을 사용하여 타임스탬프 서비스를 제공할 때 사용됩니다. HTTP 또는 FTP를 통해 타임스탬프 서비스를 사용할 수 있는 경우 accessLocation은uniformResourceIdentifier여야 합니다. 전자 메일을 통해 타임스탬프 서비스를 사용할 수 있는 경우 accessLocation은 rfc822Name이어야 합니다. TCP/IP를 사용하여 타임스탬프 서비스를 사용할 수 있는 경우 dNSName 또는 iPAddress 이름 형식을 사용할 수 있습니다. accessLocation의 다른 이름 형식\(accessMethod가 id-ad-timeStamping인 경우\)의 의미는 이 사양에서 정의되지 않습니다.

추가 액세스 설명자는 다른 PKIX 사양에서 정의될 수 있습니다.

```text
   id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }

   id-ad-caRepository OBJECT IDENTIFIER ::= { id-ad 5 }

   id-ad-timeStamping OBJECT IDENTIFIER ::= { id-ad 3 }
```

---
## **5.  CRL and CRL Extensions Profile**

위에서 설명한 대로 이 X.509 v2 CRL 프로필의 목표 중 하나는 상호 운용 가능하고 재사용 가능한 인터넷 PKI 생성을 촉진하는 것입니다. 이 목표를 달성하기 위해 확장 사용에 대한 지침이 지정되고 CRL에 포함된 정보의 특성에 대한 몇 가지 가정이 이루어집니다.

CRL은 광범위한 상호 운용성 목표와 훨씬 더 광범위한 운영 및 보증 요구 사항을 포괄하는 광범위한 응용 프로그램 및 환경에서 사용될 수 있습니다. 이 프로필은 광범위한 상호 운용성을 요구하는 일반 애플리케이션에 대한 공통 기준을 설정합니다. 프로필은 모든 CRL에서 예상할 수 있는 정보 집합을 정의합니다. 또한 프로필은 자주 사용되는 속성에 대한 CRL 내의 공통 위치와 이러한 속성에 대한 공통 표현을 정의합니다.

CRL 발급자는 CRL을 발급합니다. CRL 발급자는 CA이거나 CA가 CRL을 발급하도록 승인한 엔터티입니다. CA는 자신이 발급한 인증서에 대한 상태 정보를 제공하기 위해 CRL을 게시합니다. 그러나 CA는 이 책임을 다른 신뢰할 수 있는 기관에 위임할 수 있습니다.

각 CRL에는 특정 범위가 있습니다. CRL 범위는 지정된 CRL에 나타날 수 있는 인증서 집합입니다. 예를 들어 범위는 "CA X에서 발급한 모든 인증서", "CA X에서 발급한 모든 CA 인증서", "키 손상 및 CA 손상으로 인해 취소된 CA X에서 발급한 모든 인증서" 또는 집합일 수 있습니다. "Boulder에 위치한 NIST 직원에게 발급된 모든 인증서"와 같은 임의의 지역 정보를 기반으로 한 인증서입니다.

완전한 CRL은 해당 범위 내에서 CRL 범위에 포함된 해지 이유 중 하나로 인해 해지된 만료되지 않은 모든 인증서를 나열합니다. 전체 CRL에는 어떤 이유로든 해지되었지만 CA에서 발급한 만료되지 않은 모든 인증서가 나열됩니다. \(CA와 CRL 발급자는 이름으로 식별되므로 CRL의 범위는 CRL 서명에 사용된 키나 인증서 서명에 사용된 키의 영향을 받지 않습니다.\)

CRL 범위에 CRL 발급자가 아닌 엔터티가 발급한 하나 이상의 인증서가 포함되어 있는 경우 이는 간접 CRL입니다. 간접 CRL의 범위는 단일 CA에서 발급한 인증서로 제한되거나 여러 CA에서 발급한 인증서를 포함할 수 있습니다. 간접 CRL의 발급자가 CA인 경우 간접 CRL의 범위에는 CRL 발급자가 발급한 인증서도 포함될 수 있습니다.

CRL 발급자는 델타 CRL을 생성할 수도 있습니다. 델타 CRL은 해당 범위 내에서 참조된 전체 CRL 발행 이후 해지 상태가 변경된 인증서만 나열합니다. 참조된 전체 CRL을 기본 CRL이라고 합니다. 델타 CRL의 범위는 참조하는 기본 CRL과 동일해야 합니다.

이 프로필은 하나의 개인 인터넷 CRL 확장을 정의하지만 개인 CRL 항목 확장은 정의하지 않습니다.

추가 또는 특수 목적 요구 사항이 있는 환경에서는 이 프로필을 기반으로 구축하거나 대체할 수 있습니다.

다른 해지 또는 인증서 상태 메커니즘이 제공되는 경우 준수 CA는 CRL을 발급할 필요가 없습니다. CRL이 발행되면 CRL은 버전 2 CRL이어야 하며 nextUpdate 필드\(섹션 5.1.2.5\)에 다음 CRL이 발행될 날짜를 포함하고 CRL 번호 확장\(섹션 5.2.3\)을 포함하며 다음을 포함해야 합니다. 기관 키 식별자 확장\(섹션 5.2.1\). CRL을 지원하는 애플리케이션을 준수하려면 하나의 CA에서 발급한 모든 인증서에 대한 해지 정보를 제공하는 버전 1 및 버전 2 전체 CRL을 모두 처리해야 합니다. 델타 CRL, 간접 CRL 또는 하나의 CA에서 발급한 모든 인증서 이외의 범위를 가진 CRL의 처리를 지원하기 위해 적합한 응용 프로그램이 필요하지 않습니다.

---
### **5.1.  CRL Fields**

X.509 v2 CRL 구문은 다음과 같습니다. 서명 계산을 위해 서명할 데이터는 ASN.1 DER로 인코딩됩니다. ASN.1 DER 인코딩은 각 요소에 대한 태그, 길이, 값 인코딩 시스템입니다.

```text
   CertificateList  ::=  SEQUENCE  {
        tbsCertList          TBSCertList,
        signatureAlgorithm   AlgorithmIdentifier,
        signatureValue       BIT STRING  }

   TBSCertList  ::=  SEQUENCE  {
        version                 Version OPTIONAL,
                                     -- if present, MUST be v2
        signature               AlgorithmIdentifier,
        issuer                  Name,
        thisUpdate              Time,
        nextUpdate              Time OPTIONAL,
        revokedCertificates     SEQUENCE OF SEQUENCE  {
             userCertificate         CertificateSerialNumber,
             revocationDate          Time,
             crlEntryExtensions      Extensions OPTIONAL
                                      -- if present, version MUST be v2
                                  }  OPTIONAL,
        crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                      -- if present, version MUST be v2
                                  }
```

-- 버전, 시간, 인증서 일련 번호 및 확장자 -- 모두 섹션 4.1의 ASN.1에 정의되어 있습니다.

-- AlgorithmIdentifier는 섹션 4.1.1.2에 정의되어 있습니다.

다음 항목에서는 인터넷 PKI에서 X.509 v2 CRL을 사용하는 방법을 설명합니다.

---
#### **5.1.1.  CertificateList Fields**

CertificateList는 세 개의 필수 필드로 구성된 시퀀스입니다. 해당 필드는 다음 하위 섹션에 자세히 설명되어 있습니다.

---
##### **5.1.1.1.  tbsCertList**

시퀀스의 첫 번째 필드는 tbsCertList입니다. 이 필드 자체는 발급자 이름, 발급 날짜, 다음 목록의 발급 날짜, 해지된 인증서의 선택적 목록 및 선택적 CRL 확장을 포함하는 시퀀스입니다. 해지된 인증서가 없으면 해지된 인증서 목록이 없습니다. 하나 이상의 인증서가 해지되면 해지된 인증서 목록의 각 항목은 사용자 인증서 일련 번호, 해지 날짜 및 선택적 CRL 항목 확장의 순서로 정의됩니다.

---
##### **5.1.1.2.  signatureAlgorithm**

SignatureAlgorithm 필드에는 CRL 발급자가 CertificateList에 서명하는 데 사용하는 알고리즘에 대한 알고리즘 식별자가 포함되어 있습니다. 필드는 섹션 4.1.1.2에 정의된 AlgorithmIdentifier 유형입니다. \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에는 이 사양에 대해 지원되는 알고리즘이 나열되어 있지만 다른 서명 알고리즘도 지원될 수 있습니다.

이 필드는 tbsCertList 시퀀스\(섹션 5.1.2.2\)의 서명 필드와 동일한 알고리즘 식별자를 포함해야 합니다.

---
##### **5.1.1.3.  signatureValue**

SignatureValue 필드에는 ASN.1 DER로 인코딩된 tbsCertList에 따라 계산된 디지털 서명이 포함되어 있습니다. ASN.1 DER로 인코딩된 tbsCertList는 서명 기능에 대한 입력으로 사용됩니다. 이 서명 값은 BIT STRING으로 인코딩되며 CRL SignatureValue 필드에 포함됩니다. 이 프로세스의 세부 사항은 \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에서 지원되는 각 알고리즘에 대해 지정됩니다.

CRL 발급자이기도 한 CA는 하나의 개인 키를 사용하여 인증서 및 CRL에 디지털 서명하거나 별도의 개인 키를 사용하여 인증서 및 CRL에 디지털 서명할 수 있습니다. 별도의 개인 키가 사용되는 경우 이러한 개인 키와 연결된 각 공개 키는 별도의 인증서에 배치됩니다. 하나는 키 사용 확장에 keyCertSign 비트가 설정되어 있고 다른 하나는 키 사용 확장에 cRLSign 비트가 설정되어 있습니다\(섹션 4.2.1.3\). 별도의 개인 키가 사용되는 경우 CA에서 발급한 인증서에는 하나의 기관 키 식별자가 포함되고 해당 CRL에는 다른 기관 키 식별자가 포함됩니다. 인증서 서명 및 CRL 서명의 유효성 검사를 위해 별도의 CA 인증서를 사용하면 향상된 보안 특성을 제공할 수 있습니다. 그러나 이는 애플리케이션에 부담을 주고 상호 운용성을 제한할 수 있습니다. 많은 애플리케이션이 인증 경로를 구성한 다음 인증 경로의 유효성을 검사합니다\(섹션 6\). CRL 검사를 위해서는 CA의 CRL 서명 확인 인증서에 대해 별도의 인증 경로를 구성하고 확인해야 합니다. CRL 확인을 수행하는 애플리케이션은 인증서와 CRL이 동일한 CA 개인 키로 디지털 서명된 경우 인증 경로 유효성 검사를 지원해야 합니다. 이러한 애플리케이션은 인증서와 CRL이 다른 CA 개인 키를 사용하여 디지털 서명된 경우 인증 경로 유효성 검사를 지원해야 합니다.

---
#### **5.1.2.  Certificate List "To Be Signed"**

서명할 인증서 목록 또는 TBSCertList는 필수 및 선택 필드의 시퀀스입니다. 필수 필드는 CRL 발급자, CRL 서명에 사용된 알고리즘, CRL이 발급된 날짜 및 시간을 식별합니다.

선택 필드에는 CRL 발급자가 다음 CRL을 발급할 날짜 및 시간, 해지된 인증서 목록 및 CRL 확장이 포함됩니다. 해지된 인증서 목록은 CA가 발급한 만료되지 않은 인증서를 해지하지 않은 경우를 지원하기 위한 선택 사항입니다. 이 프로필에서는 발급된 모든 CRL에 nextUpdate 필드와 CRL 번호 및 인증 키 식별자 CRL 확장을 포함하도록 CRL 발급자를 준수해야 합니다.

---
##### **5.1.2.1.  Version**

이 선택적 필드는 인코딩된 CRL의 버전을 설명합니다. 이 프로필에서 요구하는 대로 확장이 사용되는 경우 이 필드가 있어야 하며 버전 2\(정수 값은 1\)를 지정해야 합니다.

---
##### **5.1.2.2.  Signature**

이 필드에는 CRL 서명에 사용된 알고리즘에 대한 알고리즘 식별자가 포함되어 있습니다. \[RFC3279\], \[RFC4055\] 및 \[RFC4491\]에는 인터넷 PKI에서 사용되는 가장 널리 사용되는 서명 알고리즘에 대한 OID가 나열되어 있습니다.

이 필드는 시퀀스 CertificateList\(섹션 5.1.1.2\)의 SignatureAlgorithm 필드와 동일한 알고리즘 식별자를 포함해야 합니다.

---
##### **5.1.2.3.  Issuer Name**

발급자 이름은 CRL에 서명하고 발급한 엔터티를 식별합니다. 발급자 ID는 발급자 필드에 전달됩니다. 대체 이름 형식은 issuerAltName 확장\(섹션 5.2.2\)에도 나타날 수 있습니다. 발급자 필드에는 비어 있지 않은 X.500 고유 이름\(DN\)이 포함되어야 합니다. 발급자 필드는 X.501 유형 이름으로 정의되며 인증서의 발급자 이름 필드에 대한 인코딩 규칙을 따라야 합니다\(섹션 4.1.2.4\).

---
##### **5.1.2.4.  This Update**

이 필드는 이 CRL의 발행 날짜를 나타냅니다. thisUpdate는 UTCTime 또는 GeneralizedTime으로 인코딩될 수 있습니다.

이 프로필을 준수하는 CRL 발급자는 2049년까지 날짜에 대해 thisUpdate를 UTCTime으로 인코딩해야 합니다.

이 프로필은 2050년 이후 날짜에 대해 thisUpdate를 GeneralizedTime으로 인코딩해야 합니다. 준수 애플리케이션은 UTCTime 또는 GeneralizedTime으로 인코딩된 날짜를 처리할 수 있어야 합니다\(MUST\).

UTCTime으로 인코딩된 경우 thisUpdate는 섹션 4.1.2.5.1에 ​​정의된 대로 지정되고 해석되어야 합니다. GeneralizedTime으로 인코딩된 경우 thisUpdate는 섹션 4.1.2.5.2에 정의된 대로 지정되고 해석되어야 합니다.

---
##### **5.1.2.5.  Next Update**

이 필드는 다음 CRL이 발행되는 날짜를 나타냅니다. 다음 CRL은 지정된 날짜 이전에 발행될 수 있지만 지정된 날짜 이후에는 발행되지 않습니다. CRL 발급자는 모든 이전 CRL과 같거나 이후의 nextUpdate 시간으로 CRL을 발급해야 합니다. nextUpdate는 UTCTime 또는 GeneralizedTime으로 인코딩될 수 있습니다.

준수하는 CRL 발급자는 모든 CRL에 nextUpdate 필드를 포함해야 합니다. TBSCertList의 ASN.1 구문은 이 필드를 \[X.509\]에 정의된 ASN.1 구조와 일치하는 OPTIONAL로 설명합니다. nextUpdate를 생략한 CRL을 처리하는 클라이언트의 동작은 이 프로필에 의해 지정되지 않습니다.

이 프로필을 준수하는 CRL 발급자는 2049년까지 날짜에 대해 nextUpdate를 UTCTime으로 인코딩해야 합니다. 이 프로필을 준수하는 CRL 발급자는 2050년 이후 날짜에 대해 nextUpdate를 GeneralizedTime으로 인코딩해야 합니다. 준수 애플리케이션은 UTCTime 또는 GeneralizedTime으로 인코딩된 날짜를 처리할 수 있어야 합니다\(MUST\).

UTCTime으로 인코딩된 경우 nextUpdate는 섹션 4.1.2.5.1에 ​​정의된 대로 지정되고 해석되어야 합니다. GeneralizedTime으로 인코딩된 경우 nextUpdate는 섹션 4.1.2.5.2에 정의된 대로 지정되고 해석되어야 합니다.

---
##### **5.1.2.6.  Revoked Certificates**

폐기된 인증서가 없으면 폐기된 인증서 목록이 없어야 합니다. 그렇지 않으면 해지된 인증서가 일련 번호별로 나열됩니다. CA가 해지한 인증서는 인증서 일련번호로 고유하게 식별됩니다. 철회가 발생한 날짜가 지정됩니다. revocationDate 시간은 섹션 5.1.2.4에 설명된 대로 표현되어야 합니다. 추가 정보는 CRL 항목 확장에 제공될 수 있습니다. CRL 항목 확장은 섹션 5.3에서 논의됩니다.

---
##### **5.1.2.7.  Extensions**

이 필드는 버전이 2\(섹션 5.1.2.1\)인 경우에만 나타날 수 있습니다. 존재하는 경우 이 필드는 하나 이상의 CRL 확장의 시퀀스입니다. CRL 확장은 섹션 5.2에서 논의됩니다.

---
### **5.2.  CRL Extensions**

X.509 v2 CRL \[X.509\] \[X9.55\]에 대해 ANSI X9, ISO/IEC 및 ITU-T에서 정의한 확장은 추가 속성을 CRL과 연결하는 방법을 제공합니다. 또한 X.509 v2 CRL 형식을 사용하면 커뮤니티에서 해당 커뮤니티에 고유한 정보를 전달하는 개인 확장을 정의할 수 있습니다. CRL의 각 확장은 중요 또는 중요하지 않음으로 지정될 수 있습니다. CRL에 애플리케이션이 처리할 수 없는 중요한 확장이 포함된 경우 애플리케이션은 해당 CRL을 사용하여 인증서 상태를 결정해서는 안 됩니다. 그러나 응용 프로그램은 인식되지 않고 중요하지 않은 확장을 무시할 수 있습니다. 다음 하위 섹션에서는 인터넷 CRL 내에서 사용되는 확장을 제시합니다. 커뮤니티는 이 사양에 정의되지 않은 CRL에 확장을 포함하도록 선택할 수 있습니다. 그러나 일반적인 상황에서 사용될 수 있는 CRL의 중요한 확장을 채택할 때는 주의가 필요합니다.

준수하는 CRL 발급자는 발행된 모든 CRL에 기관 키 식별자\(섹션 5.2.1\) 및 CRL 번호\(섹션 5.2.3\) 확장을 포함해야 합니다.

---
#### **5.2.1.  Authority Key Identifier**

기관 키 식별자 확장은 CRL 서명에 사용된 개인 키에 해당하는 공개 키를 식별하는 수단을 제공합니다. 식별은 키 식별자\(CRL 서명자 인증서의 주체 키 식별자\) 또는 발급자 이름 및 일련 번호를 기반으로 할 수 있습니다. 이 확장은 여러 개의 동시 키 쌍이나 전환으로 인해 발급자가 둘 이상의 서명 키를 갖고 있는 경우에 특히 유용합니다.

준수하는 CRL 발급자는 반드시 키 식별자 방법을 사용해야 하며, 발급된 모든 CRL에 이 확장을 포함해야 합니다.

이 CRL 확장의 구문은 섹션 4.2.1.1에 정의되어 있습니다.

---
#### **5.2.2.  Issuer Alternative Name**

발급자 대체 이름 확장을 사용하면 추가 ID를 CRL 발급자와 연결할 수 있습니다. 정의된 옵션에는 전자 메일 주소\(rfc822Name\), DNS 이름, IP 주소 및 URI가 포함됩니다. 이름 형식과 여러 이름 형식의 여러 인스턴스는 다음과 같습니다.

포함됩니다. 이러한 ID를 사용할 때마다 발급자 대체 이름 확장을 사용해야 합니다. 그러나 DNS 이름은 섹션 4.1.2.4에 설명된 대로 domainComponent 속성을 사용하여 발급자 필드에 표시될 수 있습니다.

준수하는 CRL 발급자는 issuerAltName 확장을 중요하지 않은 것으로 표시해야 합니다.

이 CRL 확장의 OID와 구문은 섹션 4.2.1.7에 정의되어 있습니다.

---
#### **5.2.3.  CRL Number**

CRL 번호는 지정된 CRL 범위 및 CRL 발급자에 대해 단조롭게 증가하는 시퀀스 번호를 전달하는 중요하지 않은 CRL 확장입니다. 이 확장을 통해 사용자는 특정 CRL이 다른 CRL을 대체하는 시기를 쉽게 결정할 수 있습니다. CRL 번호는 보완적인 전체 CRL 및 델타 CRL의 식별도 지원합니다. 이 프로필을 준수하는 CRL 발급자는 모든 CRL에 이 확장을 포함해야 하며 이 확장을 중요하지 않은 것으로 표시해야 합니다.

CRL 발급자가 특정 범위에 대한 전체 CRL 외에 델타 CRL을 생성하는 경우 전체 CRL과 델타 CRL은 하나의 번호 지정 순서를 공유해야 합니다. 동일한 범위를 포괄하는 델타 CRL과 전체 CRL이 동시에 발급되는 경우 동일한 CRL 번호를 갖고 동일한 취소 정보를 제공해야 합니다. 즉, 델타 CRL과 허용 가능한 완전한 CRL의 조합은 동시에 발행된 완전한 CRL과 동일한 폐기 정보를 제공해야 합니다.

CRL 발급자가 서로 다른 시간에 동일한 범위에 대해 두 개의 CRL\(두 개의 완전한 CRL, 두 개의 델타 CRL 또는 완전한 CRL과 델타 CRL\)을 생성하는 경우 두 CRL은 동일한 CRL 번호를 가져서는 안 됩니다. 즉, 두 CRL의 이 업데이트 필드\(섹션 5.1.2.4\)가 동일하지 않은 경우 CRL 번호는 달라야 합니다.

위의 요구 사항을 고려하면 CRL 번호에는 긴 정수가 포함될 것으로 예상할 수 있습니다. CRL 검증자는 최대 20옥텟의 CRLNumber 값을 처리할 수 있어야 합니다. CRL 발급자를 준수하는 경우에는 20옥텟보다 긴 CRLNumber 값을 사용하면 안 됩니다.

```text
   id-ce-cRLNumber OBJECT IDENTIFIER ::= { id-ce 20 }

   CRLNumber ::= INTEGER (0..MAX)
```

---
#### **5.2.4.  Delta CRL Indicator**

델타 CRL 표시기는 CRL을 델타 CRL로 식별하는 중요한 CRL 확장입니다. 델타 CRL에는 전체 CRL에 표시되는 모든 정보가 아닌 이전에 배포된 해지 정보에 대한 업데이트가 포함되어 있습니다. 델타 CRL을 사용하면 일부 환경에서 네트워크 로드 및 처리 시간을 크게 줄일 수 있습니다. 델타 CRL은 일반적으로 업데이트하는 CRL보다 작으므로 델타 CRL을 얻는 응용 프로그램은 해당하는 전체 CRL을 얻는 응용 프로그램보다 네트워크 대역폭을 덜 소비합니다. CRL 구조가 아닌 형식으로 해지 정보를 저장하는 애플리케이션은 정보를 다시 처리하지 않고도 로컬 데이터베이스에 새 해지 정보를 추가할 수 있습니다.

델타 CRL 표시기 확장에는 BaseCRLNumber 유형의 단일 값이 포함되어 있습니다. CRL 번호는 해당 범위에 대해 완전한 CRL을 식별하며 이 델타 CRL 생성의 시작점으로 사용되었습니다. 적합한 CRL 발급자는 참조된 기본 CRL을 완전한 CRL로 게시해야 합니다. 델타 CRL에는 동일한 범위에 대한 해지 상태에 대한 모든 업데이트가 포함됩니다. 델타 CRL과 참조된 기본 CRL의 조합은 델타 CRL 게시 당시 해당 범위에 대한 완전한 CRL과 동일합니다.

적합한 CRL 발급자가 델타 CRL을 생성할 때 델타 CRL은 중요한 델타 CRL 표시기 확장을 포함해야 합니다.

델타 CRL이 발급되면 참조하는 기본 CRL에서 다루는 것과 동일한 이유 집합과 동일한 인증서 집합을 다루어야 합니다. 즉, 델타 CRL의 범위는 기본으로 참조되는 전체 CRL의 범위와 동일해야 합니다. 참조된 기본 CRL과 델타 CRL은 발급 배포 지점 확장을 생략하거나 동일한 발급 배포 지점 확장을 포함해야 합니다. 또한 CRL 발급자는 동일한 개인 키를 사용하여 업데이트하는 데 사용할 수 있는 델타 CRL 및 전체 CRL에 서명해야 합니다.

델타 CRL을 지원하는 응용 프로그램은 해당 범위에 대한 델타 CRL을 해당 범위에 대해 완전한 발급된 CRL 또는 해당 범위에 대해 완전한 로컬로 생성된 CRL과 결합하여 지정된 범위에 대해 완전한 CRL을 생성할 수 있습니다.

델타 CRL이 전체 CRL 또는 로컬로 구성된 CRL과 결합되면 결과적으로 로컬로 구성된 CRL은 구성에 사용된 델타 CRL에 있는 CRL 번호 확장에 지정된 CRL 번호를 갖습니다. 또한 로컬에서 생성된 결과 CRL에는 thisUpdate 및 nextUpdate 시간이 지정되어 있습니다.

구성에 사용된 델타 CRL의 해당 필드. 또한 로컬로 생성된 CRL은 델타 CRL에서 발급 배포 지점을 상속합니다.

다음 네 가지 조건이 충족되면 완전한 CRL과 델타 CRL을 결합할 수 있습니다.

- \(a\) 전체 CRL과 델타 CRL의 발급자는 동일합니다.

```text
      (b)  The complete CRL and delta CRL have the same scope.  The two
           CRLs have the same scope if either of the following
           conditions are met:

         (1)  The issuingDistributionPoint extension is omitted from
              both the complete CRL and the delta CRL.

         (2)  The issuingDistributionPoint extension is present in both
              the complete CRL and the delta CRL, and the values for
              each of the fields in the extensions are the same in both
              CRLs.

      (c)  The CRL number of the complete CRL is equal to or greater
           than the BaseCRLNumber specified in the delta CRL.  That is,
           the complete CRL contains (at a minimum) all the revocation
           information held by the referenced base CRL.

      (d)  The CRL number of the complete CRL is less than the CRL
           number of the delta CRL.  That is, the delta CRL follows the
           complete CRL in the numbering sequence.
```

CRL 발급자는 델타 CRL과 적절한 전체 CRL의 조합이 현재 해지 상태를 정확하게 반영하는지 확인해야 합니다. CRL 발급자는 참조된 기본 CRL 생성 이후 상태가 변경된 델타 CRL 범위 내의 각 인증서에 대해 델타 CRL에 항목을 포함해야 합니다.

```text
      (a)  If the certificate is revoked for a reason included in the
           scope of the CRL, list the certificate as revoked.

      (b)  If the certificate is valid and was listed on the referenced
           base CRL or any subsequent CRL with reason code
           certificateHold, and the reason code certificateHold is
           included in the scope of the CRL, list the certificate with
           the reason code removeFromCRL.

      (c)  If the certificate is revoked for a reason outside the scope
           of the CRL, but the certificate was listed on the referenced
           base CRL or any subsequent CRL with a reason code included in
           the scope of this CRL, list the certificate as revoked but
           omit the reason code.

      (d)  If the certificate is revoked for a reason outside the scope
           of the CRL and the certificate was neither listed on the
           referenced base CRL nor any subsequent CRL with a reason code
           included in the scope of this CRL, do not list the
           certificate on this CRL.
```

인증서가 해지되거나\(certificateHold를 포함한 해지 사유로 인해\) 보류 상태가 해제되거나 해지 사유가 변경되면 인증서 상태가 변경된 것으로 간주됩니다.

참조된 기본 CRL에 인증서가 보류되지 않은 경우에도 델타 CRL에 이유 코드 제거FromCRL이 포함된 인증서를 나열하는 것이 적절합니다. 인증서가 기본 이후, 그러나 이 델타 CRL 이전에 발급된 CRL에 보류 상태로 배치되었다가 보류 상태에서 해제된 경우, 취소 이유가 제거된 CRL과 함께 델타 CRL에 나열되어야 합니다.

인증서에 지정된 notAfter 시간이 델타 CRL에 지정된 thisUpdate 시간보다 이전이고 인증서가 참조된 기본 CRL 또는 이후에 발행된 CRL에 나열된 경우 CRL 발급자는 선택적으로 이유 코드 제거FromCRL과 함께 델타 CRL에 인증서를 나열할 수 있습니다. 기본이지만 이 델타 CRL 이전입니다.

인증서 해지 알림이 델타 CRL에 처음 나타나는 경우 동일한 범위에 대한 다음 완전한 CRL이 발급되기 전에 인증서 유효 기간이 만료될 수 있습니다. 이 경우, 취소 알림은 이 범위에 대해 명시적으로 발행된 하나 이상의 완전한 CRL에 취소 알림이 포함될 때까지 모든 후속 델타 CRL에 포함되어야 합니다.

델타 CRL을 지원하는 애플리케이션은 이전에 발행된 전체 CRL과 최신 델타 CRL을 결합하여 현재 전체 CRL을 구성할 수 있어야 합니다. 델타 CRL을 지원하는 애플리케이션은 이전에 로컬로 생성된 완전한 CRL과 현재 델타 CRL을 결합하여 현재의 완전한 CRL을 생성할 수도 있습니다. 현재 시간이 thisUpdate 및 nextUpdate 필드에 포함된 시간 사이에 있는 경우 델타 CRL은 현재 CRL로 간주됩니다. 일부 상황에서는 CRL 발급자가 nextUpdate 필드에 표시된 시간 이전에 하나 이상의 델타 CRL을 게시할 수 있습니다. 주어진 범위에 대해 둘 이상의 현재 델타 CRL이 발견되면 애플리케이션은 thisUpdate에서 최신 값을 가진 항목을 최신 항목으로 간주해야 합니다.

```text
   id-ce-deltaCRLIndicator OBJECT IDENTIFIER ::= { id-ce 27 }

   BaseCRLNumber ::= CRLNumber
```

---
#### **5.2.5.  Issuing Distribution Point**

발급 배포 지점은 특정 CRL에 대한 CRL 배포 지점과 범위를 식별하는 중요한 CRL 확장이며 CRL이 최종 엔터티 인증서만, CA 인증서만, 속성 인증서만 또는 제한된 이유 집합에 대한 해지를 포함하는지 여부를 나타냅니다. 코드. 확장이 중요하기는 하지만 이 확장을 지원하기 위해 구현을 준수할 필요는 없습니다. 그러나 이 확장을 지원하지 않는 구현은 이 CRL에 나열되지 않은 인증서의 상태를 알 수 없음으로 처리하거나 인식할 수 없는 중요한 확장을 포함하지 않는 다른 CRL을 찾아야 합니다.

CRL은 CRL 발급자의 개인 키를 사용하여 서명됩니다. CRL 배포 지점에는 자체 키 쌍이 없습니다. CRL이 X.500 디렉터리에 저장되어 있는 경우 CRL 배포 지점에 해당하는 디렉터리 항목에 저장되며 이는 CRL 발급자의 디렉터리 항목과 다를 수 있습니다.

배포 지점과 관련된 이유 코드는 onlySomeReasons에 지정되어야 합니다. onlySomeReasons가 표시되지 않으면 배포 지점에 모든 이유 코드에 대한 취소가 포함되어야 합니다. CA는 CRL 배포 지점을 사용하여 손상 및 일상적인 해지를 기준으로 CRL을 분할할 수 있습니다. 이 경우 이유 코드 keyCompromise \(1\), cACompromise \(2\) 및 aACompromise \(8\)가 있는 취소는 하나의 배포 지점에 나타나고 다른 이유 코드가 있는 취소는 다른 배포 지점에 나타납니다.

CRL에 onlySomeReasons가 있는 issuingDistributionPoint 확장이 포함된 경우 취소된 CRL 범위의 모든 인증서에는 지정되지 않은 취소 이유가 할당되어야 합니다. 할당된 폐기 이유는 폐기된 인증서를 나열할 CRL을 결정하는 데 사용됩니다. 그러나 해당 CRL 항목에 ReasonCode CRL 항목 확장을 포함할 필요는 없습니다.

distributionPoint 필드의 구문과 의미는 cRLDistributionPoints 확장\(섹션 4.2.1.13\)의 distributionPoint 필드와 동일합니다. distributionPoint 필드가 있는 경우 cRLDistributionPoints의 해당 distributionPoint 필드에 있는 이름 중 하나 이상을 포함해야 합니다.

이 CRL 범위 내에 있는 모든 인증서의 확장입니다. 인증서와 CRL의 distributionPoint 필드에는 동일한 인코딩을 사용해야 합니다.

distributionPoint 필드가 없는 경우 CRL에는 CRL 범위 내에서 CRL 발급자가 발급한 모든 취소되고 만료되지 않은 인증서에 대한 항목이 포함되어야 합니다\(있는 경우\).

CRL 범위에 CRL 발급자가 발급한 인증서만 포함되는 경우 indirectCRL 부울을 FALSE로 설정해야 합니다. 그렇지 않고 CRL 범위에 CRL 발급자 이외의 하나 이상의 기관에서 발급한 인증서가 포함되어 있는 경우 indirectCRL 부울을 TRUE로 설정해야 합니다. 각 항목을 담당하는 기관은 인증서 발급자 CRL 항목 확장\(섹션 5.3.3\)으로 표시됩니다.

CRL 범위에 최종 엔터티 공개 키 인증서만 포함된 경우 onlyContainsUserCerts를 TRUE로 설정해야 합니다. CRL 범위에 CA 인증서만 포함된 경우 onlyContainsCACerts를 TRUE로 설정해야 합니다. onlyContainsUserCerts 또는 onlyContainsCACerts가 TRUE로 설정된 경우 CRL의 범위에는 버전 1 또는 버전 2 인증서가 포함되어서는 안 됩니다. CRL을 준수하는 발급자는 onlyContainsAttributeCerts 부울을 FALSE로 설정해야 합니다.

CRL 준수 발행자는 발행 배포 지점 확장의 DER 인코딩이 빈 시퀀스인 CRL을 발행해서는 안 됩니다. 즉, onlyContainsUserCerts, onlyContainsCACerts, indirectCRL 및 onlyContainsAttributeCerts가 모두 FALSE인 경우 distributionPoint 필드 또는 onlySomeReasons 필드가 있어야 합니다.

```text
   id-ce-issuingDistributionPoint OBJECT IDENTIFIER ::= { id-ce 28 }

   IssuingDistributionPoint ::= SEQUENCE {
        distributionPoint          [0] DistributionPointName OPTIONAL,
        onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE,
        onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE,
        onlySomeReasons            [3] ReasonFlags OPTIONAL,
        indirectCRL                [4] BOOLEAN DEFAULT FALSE,
        onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
```

- -- onlyContainsUserCerts, onlyContainsCACerts, -- 및 onlyContainsAttributeCerts 중 최대 하나가 TRUE로 설정될 수 있습니다.

---
#### **5.2.6.  Freshest CRL (a.k.a. Delta CRL Distribution Point)**

최신 CRL 확장은 이 전체 CRL에 대한 델타 CRL 정보를 얻는 방법을 식별합니다. 준수하는 CRL 발급자는 이 확장을 중요하지 않은 것으로 표시해야 합니다. 이 확장은 델타 CRL에 표시되어서는 안 됩니다.

이 확장에는 cRLDistributionPoints 인증서 확장과 동일한 구문이 사용되며 섹션 4.2.1.13에 설명되어 있습니다. 그러나 이 컨텍스트에서는 배포 지점 필드만 의미가 있습니다. 이유 및 cRLIssuer 필드는 이 CRL 확장에서 생략되어야 합니다.

각 배포 지점 이름은 이 전체 CRL에 대한 델타 CRL을 찾을 수 있는 위치를 제공합니다. 이러한 델타 CRL의 범위는 이 전체 CRL의 범위와 동일해야 합니다. 이 CRL 확장의 내용은 델타 CRL을 찾는 데에만 사용됩니다. 내용은 CRL 또는 참조된 델타 CRL의 유효성을 검사하는 데 사용되지 않습니다. 섹션 4.2.1.13의 배포 지점에 대해 정의된 인코딩 규칙이 이 확장에 적용됩니다.

```text
   id-ce-freshestCRL OBJECT IDENTIFIER ::=  { id-ce 46 }

   FreshestCRL ::= CRLDistributionPoints
```

---
#### **5.2.7.  Authority Information Access**

이 섹션에서는 CRL에서 기관 정보 액세스 확장의 사용을 정의합니다. 인증서 확장에 대해 섹션 4.2.2.1에 정의된 구문 및 의미는 CRL 확장에도 사용됩니다.

이 CRL 확장은 중요하지 않은 것으로 표시되어야 합니다.

CRL에 있는 경우 이 확장은 id-ad-caIssuers를 accessMethod로 지정하는 최소한 하나의 AccessDescription을 포함해야 합니다. id-ad-caIssuers OID는 사용 가능한 정보에 CRL의 서명을 확인하는 데 사용할 수 있는 인증서\(예: CRL의 발급자 이름과 일치하는 주체 이름이 있고 주체 공개 키가 있는 인증서\)가 나열되어 있을 때 사용됩니다. 이는 CRL 서명에 사용된 개인 키에 해당합니다\). id-ad-caIssuers 이외의 액세스 방법 유형은 포함되어서는 안 됩니다. 적어도 하나의 AccessDescription 인스턴스는 HTTP \[RFC2616\] 또는 LDAP \[RFC4516\] URI인 accessLocation을 지정해야 합니다.

HTTP 또는 FTP를 통해 정보를 사용할 수 있는 경우 accessLocation은uniformResourceIdentifier여야 하며 URI는 \[RFC2585\]에 지정된 단일 DER 인코딩 인증서 또는 BER 또는 DER 인코딩된 "인증서 전용" CMS의 인증서 모음을 가리켜야 합니다. \[RFC2797\]에 지정된 메시지입니다.

인증서 액세스를 위해 HTTP 또는 FTP를 지원하는 애플리케이션을 준수하는 것은 개별 DER로 인코딩된 인증서를 수락할 수 있어야 하며 "인증서 전용" CMS 메시지를 수락할 수 있어야 합니다.

URI를 통해 액세스되는 HTTP 서버 구현은 단일 DER 인코딩 인증서에 대한 응답의 콘텐츠 유형 헤더 필드에 미디어 유형 application/pkix-cert \[RFC2585\]를 지정해야 하며 미디어 유형 application/pkcs7-mime \[RFC2797\]을 지정해야 합니다. "인증서 전용" CMS 메시지에 대한 응답의 콘텐츠 유형 헤더 필드에 있습니다. FTP의 경우 단일 DER 인코딩 인증서를 포함하는 파일 이름에는 ".cer" \[RFC2585\] 접미사가 있어야 하고 "인증서 전용" CMS 메시지를 포함하는 파일 이름에는 ".cer" 접미사가 있어야 합니다. p7c" \[RFC2797\]. 소비자 클라이언트는 미디어 유형이나 파일 확장자를 콘텐츠에 대한 힌트로 사용할 수 있지만 서버 응답에 올바른 미디어 유형이나 파일 확장자가 있는지에만 의존해서는 안 됩니다.

accessLocation이 디렉토리 이름인 경우 애플리케이션은 로컬로 구성된 디렉토리 서버에서 정보를 가져옵니다. 하나의 CA 공개 키를 사용하여 인증서 및 CRL의 서명을 검증하는 경우 원하는 CA 인증서는 \[RFC4523\]에 지정된 대로 crossCertificatePair 및/또는 cACertificate 속성에 저장됩니다. 인증서 및 CRL의 서명을 검증하기 위해 서로 다른 공개 키가 사용되는 경우 원하는 인증서는 \[RFC4523\]에 지정된 대로 userCertificate 속성에 저장됩니다. 따라서 accessLocation의 DirectoryName 형식을 지원하는 구현은 이러한 세 가지 속성 중 하나에서 필요한 인증서를 찾을 수 있도록 준비되어야 합니다. 애플리케이션이 디렉토리에 액세스하기 위해 사용하는 프로토콜\(예: DAP 또는 LDAP\)은 로컬 문제입니다.

LDAP를 통해 정보를 사용할 수 있는 경우 accessLocation은uniformResourceIdentifier여야 합니다. LDAP URI \[RFC4516\]에는 인증서를 보유하는 항목의 고유 이름을 포함하는 <dn\> 필드가 포함되어야 하며, DER로 인코딩된 인증서 또는 교차 인증서 쌍을 보유하는 속성에 대한 적절한 속성 설명을 나열하는 <attributes\> 필드가 포함되어야 합니다. \[RFC4523\], <host\>\(예: <ldap://ldap.example.com/cn=CA, dc=example,dc=com?cACertificate;binary,crossCertificatePair;binary\>\)를 포함해야 합니다. <host\>\(예: <ldap:///cn=exampleCA,dc=example,dc=com? cACertificate;binary\>\)를 생략하면 클라이언트가 적절한 서버에 연결해야 할 수 있는 사전 지식에 의존하는 효과가 있습니다. .

---
### **5.3.  CRL Entry Extensions**

X.509 v2 CRL에 대해 ISO/IEC, ITU-T 및 ANSI X9에서 정의한 CRL 항목 확장은 추가 속성을 CRL 항목 \[X.509\] \[X9.55\]과 연결하는 방법을 제공합니다. 또한 X.509 v2 CRL 형식을 사용하면 커뮤니티에서 해당 커뮤니티에 고유한 정보를 전달하는 개인 CRL 항목 확장을 정의할 수 있습니다. CRL 항목의 각 확장은 중요 또는 중요하지 않음으로 지정될 수 있습니다. CRL에 애플리케이션이 처리할 수 없는 중요한 CRL 항목 확장이 포함되어 있는 경우 애플리케이션은 해당 CRL을 사용하여 인증서의 상태를 결정해서는 안 됩니다. 그러나 응용 프로그램은 인식되지 않은 중요하지 않은 CRL 항목 확장을 무시할 수 있습니다.

다음 하위 섹션에서는 인터넷 CRL 항목과 정보의 표준 위치에 사용되는 권장 확장을 제시합니다. 커뮤니티는 추가 CRL 항목 확장을 사용하도록 선택할 수 있습니다. 그러나 일반적인 상황에서 사용될 수 있는 CRL에 중요한 CRL 항목 확장을 채택할 때는 주의해야 합니다.

이 사양에 정의된 CRL 항목 확장에 대한 지원은 CRL 발급자와 응용 프로그램을 준수하기 위한 선택 사항입니다. 그러나 CRL 발급자는 이 정보가 가능할 때마다 이유 코드\(섹션 5.3.1\) 및 무효 날짜\(섹션 5.3.2\)를 포함해야 합니다.

---
#### **5.3.1.  Reason Code**

ReasonCode는 인증서 해지 이유를 식별하는 중요하지 않은 CRL 항목 확장입니다. CRL 발급자는 CRL 항목에 의미 있는 이유 코드를 포함하는 것이 좋습니다. 그러나 지정되지 않은\(0\) ReasonCode 값을 사용하는 대신 이유 코드 CRL 항목 확장이 없어야 합니다.

RemoveFromCRL\(8\) ReasonCode 값은 델타 CRL에만 나타날 수 있으며 인증서가 만료되었거나 보류 상태에서 제거되었기 때문에 인증서가 CRL에서 제거되어야 함을 나타냅니다. 다른 모든 이유 코드는 CRL에 나타날 수 있으며 지정된 인증서가 해지된 것으로 간주되어야 함을 나타냅니다.

```text
   id-ce-cRLReasons OBJECT IDENTIFIER ::= { id-ce 21 }

   -- reasonCode ::= { CRLReason }

   CRLReason ::= ENUMERATED {
        unspecified             (0),
        keyCompromise           (1),
        cACompromise            (2),
        affiliationChanged      (3),
        superseded              (4),
        cessationOfOperation    (5),
        certificateHold         (6),
             -- value 7 is not used
        removeFromCRL           (8),
        privilegeWithdrawn      (9),
        aACompromise           (10) }
```

---
#### **5.3.2.  Invalidity Date**

무효 날짜는 개인 키가 손상되었거나 인증서가 무효화되었다는 사실이 알려지거나 의심되는 날짜를 제공하는 중요하지 않은 CRL 항목 확장입니다. 이 날짜는 CA가 해지를 처리한 날짜인 CRL 항목의 해지 날짜보다 이전일 수 있습니다. CRL 발급자가 CRL에 철회를 처음 게시하는 경우 무효 날짜는 이전 CRL의 발급 날짜보다 앞설 수 있지만, 철회 날짜는 이전 CRL의 발급 날짜보다 앞서서는 안 됩니다. 이 정보를 사용할 수 있을 때마다 CRL 발급자는 이를 CRL 사용자와 공유할 것을 적극 권장합니다.

이 필드에 포함된 GeneralizedTime 값은 그리니치 표준시\(Zulu\)로 표현되어야 하며 섹션 4.1.2.5.2에 정의된 대로 지정 및 해석되어야 합니다.

```text
   id-ce-invalidityDate OBJECT IDENTIFIER ::= { id-ce 24 }

   InvalidityDate ::=  GeneralizedTime
```

---
#### **5.3.3.  Certificate Issuer**

이 CRL 항목 확장은 간접 CRL, 즉 발급 배포 지점 확장에 indirectCRL 표시기가 설정된 CRL의 항목과 연결된 인증서 발급자를 식별합니다. 존재하는 경우 인증서 발급자 CRL 항목 확장에는 발급자 필드 및/또는 CRL 항목에 해당하는 인증서의 발급자 대체 이름 확장에 있는 하나 이상의 이름이 포함됩니다. 이 확장자가 간접 CRL의 첫 번째 항목에 없으면 인증서 발급자는 기본적으로 CRL 발급자를 사용합니다. \~에

간접 CRL의 후속 항목에서 이 확장이 없으면 해당 항목의 인증서 발급자는 이전 항목의 인증서 발급자와 동일합니다. 이 필드는 다음과 같이 정의됩니다.

```text
   id-ce-certificateIssuer   OBJECT IDENTIFIER ::= { id-ce 29 }

   CertificateIssuer ::=     GeneralNames
```

준수하는 CRL 발급자는 이 CRL 항목에 해당하는 인증서 발급자 필드의 고유 이름\(DN\)을 이 확장에 포함해야 합니다. DN의 인코딩은 인증서에 사용된 인코딩과 동일해야 합니다.

CRL 발급자는 이 확장을 무시한 구현이 CRL 항목을 인증서에 올바르게 지정할 수 없으므로 이 확장을 중요로 표시해야 합니다. 이 사양에서는 구현 시 이 확장을 인식할 것을 권장합니다.

---
## **6.  Certification Path Validation**

인터넷 PKI에 대한 인증 경로 유효성 검사 절차는 \[X.509\]에 제공된 알고리즘을 기반으로 합니다. 인증 경로 처리는 주체 고유 이름 및/또는 주체 대체 이름과 주체 공개 키 간의 바인딩을 확인합니다. 바인딩은 신뢰 당사자가 지정한 경로와 입력을 구성하는 인증서에 지정된 제약 조건에 의해 제한됩니다. 기본 제약 조건 및 정책 제약 조건 확장을 통해 인증 경로 처리 논리를 통해 의사 결정 프로세스를 자동화할 수 있습니다.

이 섹션에서는 인증 경로의 유효성을 검사하는 알고리즘을 설명합니다. 이 사양을 준수하는 구현은 이 알고리즘을 구현하는 데 필요하지 않지만 이 절차의 결과로 발생하는 외부 동작과 동일한 기능을 제공해야 합니다\(MUST\). 올바른 결과를 도출하는 한 특정 구현에서는 모든 알고리즘을 사용할 수 있습니다.

섹션 6.1의 텍스트에서는 기본 경로 유효성 검사에 대해 설명합니다. 유효한 경로는 트러스트 앵커에서 발급한 인증서로 시작됩니다. 알고리즘에는 CA의 공개 키, CA 이름 및 이 키를 사용하여 유효성을 검사할 수 있는 경로 집합에 대한 제약 조건이 필요합니다.

트러스트 앵커의 선택은 정책의 문제입니다. 이는 계층적 PKI의 최상위 CA, 검증자의 자체 인증서를 발급한 CA 또는 네트워크 PKI의 다른 CA일 수 있습니다. 경로

검증 절차는 트러스트 앵커 선택에 관계없이 동일합니다. 또한, 다양한 애플리케이션은 다양한 트러스트 앵커에 의존하거나 트러스트 앵커 세트로 시작하는 경로를 허용할 수 있습니다.

섹션 6.2에서는 특정 구현에서 경로 유효성 검사 알고리즘을 사용하는 방법을 설명합니다.

섹션 6.3에서는 CRL이 인증서 발급자가 사용하는 해지 메커니즘인 경우 인증서가 해지되는지 확인하는 데 필요한 단계를 설명합니다.

---
### **6.1.  Basic Path Validation**

이 텍스트는 X.509 경로 처리를 위한 알고리즘을 설명합니다. 적합한 구현에는 이 알고리즘의 외부 동작과 기능적으로 동일한 X.509 경로 처리 절차가 포함되어야 합니다. 그러나 이 알고리즘에서 처리되는 일부 인증서 확장에 대한 지원은 호환 구현을 위한 선택 사항입니다. 이러한 확장을 지원하지 않는 클라이언트는 경로 유효성 검사 알고리즘에서 해당 단계를 생략할 수 있습니다.

예를 들어 클라이언트는 정책 매핑 확장을 지원할 필요가 없습니다. 이 확장을 지원하지 않는 클라이언트는 정책 매핑이 처리되는 경로 유효성 검사 단계를 생략할 수 있습니다. 지원되지 않는 중요한 확장이 포함된 경우 클라이언트는 인증서를 거부해야 합니다.

이 문서의 섹션 4와 5에 지정된 인증서 및 CRL 프로필은 인터넷 PKI에 적합하다고 간주되는 인증서 및 CRL 필드와 확장에 대한 값을 지정하지만, 이 섹션에 제시된 알고리즘은 다음과 같은 인증서 및 CRL을 수락하는 것으로 제한되지 않습니다. 이 프로필을 준수하세요. 따라서 알고리즘에는 인증 경로가 X.509에 따라 유효한지 확인하는 검사만 포함되며 인증서와 CRL이 이 프로필을 준수하는지 확인하는 검사는 포함되지 않습니다. 섹션 4와 5의 프로필에 대한 적합성 검사를 포함하도록 알고리즘을 확장할 수 있지만, 이 프로필에서는 그러한 검사를 포함하지 않을 것을 권장합니다.

이 섹션에 제시된 알고리즘은 현재 날짜 및 시간을 기준으로 인증서의 유효성을 검사합니다. 적합한 구현은 과거의 특정 시점에 대한 유효성 검사도 지원할 수 있습니다. 인증서 유효 기간을 벗어난 시간에 대해서는 인증서를 검증하는 메커니즘을 사용할 수 없습니다.

트러스트 앵커는 알고리즘에 대한 입력입니다. 모든 인증 경로를 검증하는 데 동일한 트러스트 앵커를 사용해야 한다는 요구 사항은 없습니다. 섹션 6.2에서 자세히 설명하는 것처럼 다양한 경로를 검증하기 위해 다양한 신뢰 앵커를 사용할 수 있습니다.

경로 유효성 검사의 기본 목표는 트러스트 앵커의 공개 키를 기반으로 대상 인증서에 표시된 주체 고유 이름 또는 주체 대체 이름과 주체 공개 키 간의 바인딩을 확인하는 것입니다. 대부분의 경우 대상 인증서는 최종 엔터티 인증서가 되지만 대상 공개 키가 공개 키 인증서의 서명을 확인하는 것 이외의 목적으로 사용되는 한 대상 인증서는 CA 인증서일 수 있습니다. 이름과 주체 공개 키 간의 바인딩을 확인하려면 해당 바인딩을 지원하는 일련의 인증서를 얻어야 합니다. 이 인증서 시퀀스를 얻기 위해 수행되는 절차는 이 사양의 범위를 벗어납니다.

이 목표를 달성하기 위해 경로 유효성 검사 프로세스는 무엇보다도 예상 인증 경로\(n개의 인증서 시퀀스\)가 다음 조건을 충족하는지 확인합니다.

```text
      (a)  for all x in {1, ..., n-1}, the subject of certificate x is
           the issuer of certificate x+1;
```

- \(b\) 인증서 1은 트러스트 앵커에 의해 발행됩니다.

```text
      (c)  certificate n is the certificate to be validated (i.e., the
           target certificate); and

      (d)  for all x in {1, ..., n}, the certificate was valid at the
           time in question.
```

인증서는 장래 인증 경로에 두 번 이상 나타나서는 안 됩니다.

트러스트 앵커가 자체 서명된 인증서 형식으로 제공되는 경우 이 자체 서명된 인증서는 예상 인증 경로의 일부로 포함되지 않습니다. 트러스트 앵커에 대한 정보는 인증 경로 검증 알고리즘\(섹션 6.1.1\)에 대한 입력으로 제공됩니다.

그러나 특정 인증 경로가 모든 응용 프로그램에 적합하지 않을 수도 있습니다. 따라서 애플리케이션은 이 알고리즘을 확장하여 유효한 경로 집합을 추가로 제한할 수 있습니다. 또한 경로 유효성 검사 프로세스에서는 인증서 정책 확장, 정책 매핑 확장, 정책 제약 조건 확장 및 anyPolicy 확장 금지를 기반으로 이 경로에 유효한 인증서 정책 집합을 결정합니다. 이를 달성하기 위한 경로는

검증 알고리즘은 유효한 정책 트리를 구성합니다. 이 경로에 유효한 인증서 정책 집합이 비어 있지 않으면 결과는 깊이 n의 유효한 정책 트리가 되고, 그렇지 않으면 결과는 null 유효한 정책 트리가 됩니다.

주체 및 발급자 필드에 동일한 DN이 나타나면 인증서가 자체 발급됩니다\(섹션 7.1에 지정된 규칙에 따라 일치하면 두 DN이 동일함\). 일반적으로 경로를 구성하는 인증서의 발급자와 주체는 인증서마다 다릅니다. 그러나 CA는 키 롤오버 또는 인증서 정책 변경을 지원하기 위해 자체적으로 인증서를 발급할 수 있습니다. 이러한 자체 발급 인증서는 경로 길이 또는 이름 제약 조건을 평가할 때 계산되지 않습니다.

이 섹션에서는 \(1\) 초기화, \(2\) 기본 인증서 처리, \(3\) 다음 인증서 준비, \(4\) 마무리의 네 가지 기본 단계로 알고리즘을 제시합니다. \(1\)과 \(4\)단계는 정확히 한 번만 수행됩니다. \(2\) 단계는 경로의 모든 인증서에 대해 수행됩니다. \(3\) 단계는 최종 인증서를 제외한 경로의 모든 인증서에 대해 수행됩니다. 그림 2는 이 알고리즘의 상위 수준 흐름도를 제공합니다.

```text
                           +-------+
                           | START |
                           +-------+
                               |
                               V
                       +----------------+
                       | Initialization |
                       +----------------+
                               |
                               +<--------------------+
                               |                     |
                               V                     |
                       +----------------+            |
                       |  Process Cert  |            |
                       +----------------+            |
                               |                     |
                               V                     |
                       +================+            |
                       |  IF Last Cert  |            |
                       |    in Path     |            |
                       +================+            |
                         |            |              |
                    THEN |            | ELSE         |
                         V            V              |
              +----------------+ +----------------+  |
              |    Wrap up     | |  Prepare for   |  |
              +----------------+ |   Next Cert    |  |
                      |          +----------------+  |
                      V               |              |
                  +-------+           +--------------+
                  | STOP  |
                  +-------+

         Figure 2.  Certification Path Processing Flowchart
```

---
#### **6.1.1.  Inputs**

이 알고리즘은 경로 처리 로직에 다음 9개의 입력이 제공된다고 가정합니다.

- \(a\) 길이 n의 장래 인증 경로.

- \(b\) 현재 날짜/시간.

```text
      (c)  user-initial-policy-set:  A set of certificate policy
           identifiers naming the policies that are acceptable to the
           certificate user.  The user-initial-policy-set contains the
           special value any-policy if the user is not concerned about
           certificate policy.

      (d)  trust anchor information, describing a CA that serves as a
           trust anchor for the certification path.  The trust anchor
           information includes:
```

- \(1\) 신뢰할 수 있는 발급자 이름,

- \(2\) 신뢰할 수 있는 공개 키 알고리즘,

- \(3\) 신뢰할 수 있는 공개 키, 그리고

```text
         (4)  optionally, the trusted public key parameters associated
              with the public key.
```

- 트러스트 앵커 정보는 자체 서명된 인증서 형태로 경로 처리 절차에 제공될 수 있습니다. 트러스트 앵커 정보가 인증서 형태로 제공되는 경우 제목 필드의 이름은 신뢰할 수 있는 발급자 이름으로 사용되며 subjectPublicKeyInfo 필드의 내용은 신뢰할 수 있는 공개키 알고리즘 및 신뢰할 수 있는 공개키의 소스로 사용됩니다. . 트러스트 앵커 정보는 신뢰할 수 있는 대역 외 절차에 의해 경로 처리 절차에 전달되었기 때문에 신뢰할 수 있습니다. 신뢰할 수 있는 공개 키 알고리즘에 매개변수가 필요한 경우 매개변수는 신뢰할 수 있는 공개 키와 함께 제공됩니다.

```text
      (e)  initial-policy-mapping-inhibit, which indicates if policy
           mapping is allowed in the certification path.

      (f)  initial-explicit-policy, which indicates if the path must be
           valid for at least one of the certificate policies in the
           user-initial-policy-set.

      (g)  initial-any-policy-inhibit, which indicates whether the
           anyPolicy OID should be processed if it is included in a
           certificate.

      (h)  initial-permitted-subtrees, which indicates for each name
           type (e.g., X.500 distinguished names, email addresses, or IP
           addresses) a set of subtrees within which all subject names
           in every certificate in the certification path MUST fall.
           The initial-permitted-subtrees input includes a set for each
           name type.  For each name type, the set may consist of a

           single subtree that includes all names of that name type or
           one or more subtrees that each specifies a subset of the
           names of that name type, or the set may be empty.  If the set
           for a name type is empty, then the certification path will be
           considered invalid if any certificate in the certification
           path includes a name of that name type.

      (i)  initial-excluded-subtrees, which indicates for each name type
           (e.g., X.500 distinguished names, email addresses, or IP
           addresses) a set of subtrees within which no subject name in
           any certificate in the certification path may fall.  The
           initial-excluded-subtrees input includes a set for each name
           type.  For each name type, the set may be empty or may
           consist of one or more subtrees that each specifies a subset
           of the names of that name type.  If the set for a name type
           is empty, then no names of that name type are excluded.
```

이러한 모든 입력의 설정을 지원하기 위해 구현을 준수할 필요는 없습니다. 예를 들어, 초기 정책 금지에 대해 FALSE 값을 사용하여 모든 인증 경로를 검증하도록 적합한 구현을 설계할 수 있습니다.

---
#### **6.1.2.  Initialization**

이 초기화 단계에서는 9개의 입력을 기반으로 11개의 상태 변수를 설정합니다.

```text
      (a)  valid_policy_tree:  A tree of certificate policies with their
           optional qualifiers; each of the leaves of the tree
           represents a valid policy at this stage in the certification
           path validation.  If valid policies exist at this stage in
           the certification path validation, the depth of the tree is
           equal to the number of certificates in the chain that have
           been processed.  If valid policies do not exist at this stage
           in the certification path validation, the tree is set to
           NULL.  Once the tree is set to NULL, policy processing
           ceases.

           Each node in the valid_policy_tree includes three data
           objects: the valid policy, a set of associated policy
           qualifiers, and a set of one or more expected policy values.
           If the node is at depth x, the components of the node have
           the following semantics:

         (1)  The valid_policy is a single policy OID representing a
              valid policy for the path of length x.

         (2)  The qualifier_set is a set of policy qualifiers associated
              with the valid policy in certificate x.

         (3)  The expected_policy_set contains one or more policy OIDs
              that would satisfy this policy in the certificate x+1.
```

- valid\_policy\_tree의 초기 값은 valid\_policy anyPolicy가 포함된 단일 노드, 빈 qualifier\_set 및 단일 값 anyPolicy가 포함된 Expect\_policy\_set입니다. 이 노드는 깊이 0에 있는 것으로 간주됩니다.

- 그림 3은 valid\_policy\_tree의 초기 상태를 그래픽으로 표현한 것입니다. 추가 그림에서는 이 형식을 사용하여 경로 처리 중 valid\_policy\_tree의 변경 사항을 설명합니다.

```text
              +----------------+
              |   anyPolicy    |   <---- valid_policy
              +----------------+
              |       {}       |   <---- qualifier_set
              +----------------+
              |  {anyPolicy}   |   <---- expected_policy_set
              +----------------+
```

- 그림 3. valid\_policy\_tree 상태 변수의 초기 값

```text
      (b)  permitted_subtrees:  a set of root names for each name type
           (e.g., X.500 distinguished names, email addresses, or IP
           addresses) defining a set of subtrees within which all
           subject names in subsequent certificates in the certification
           path MUST fall.  This variable includes a set for each name
           type, and the initial value is initial-permitted-subtrees.

      (c)  excluded_subtrees:  a set of root names for each name type
           (e.g., X.500 distinguished names, email addresses, or IP
           addresses) defining a set of subtrees within which no subject
           name in subsequent certificates in the certification path may
           fall.  This variable includes a set for each name type, and
           the initial value is initial-excluded-subtrees.

      (d)  explicit_policy:  an integer that indicates if a non-NULL
           valid_policy_tree is required.  The integer indicates the
           number of non-self-issued certificates to be processed before
           this requirement is imposed.  Once set, this variable may be
           decreased, but may not be increased.  That is, if a
           certificate in the path requires a non-NULL
           valid_policy_tree, a later certificate cannot remove this
           requirement.  If initial-explicit-policy is set, then the
           initial value is 0, otherwise the initial value is n+1.

      (e)  inhibit_anyPolicy:  an integer that indicates whether the
           anyPolicy policy identifier is considered a match.  The
           integer indicates the number of non-self-issued certificates
           to be processed before the anyPolicy OID, if asserted in a
           certificate other than an intermediate self-issued
           certificate, is ignored.  Once set, this variable may be
           decreased, but may not be increased.  That is, if a
           certificate in the path inhibits processing of anyPolicy, a
           later certificate cannot permit it.  If initial-any-policy-
           inhibit is set, then the initial value is 0, otherwise the
           initial value is n+1.

      (f)  policy_mapping:  an integer that indicates if policy mapping
           is permitted.  The integer indicates the number of non-self-
           issued certificates to be processed before policy mapping is
           inhibited.  Once set, this variable may be decreased, but may
           not be increased.  That is, if a certificate in the path
           specifies that policy mapping is not permitted, it cannot be
           overridden by a later certificate.  If initial-policy-
           mapping-inhibit is set, then the initial value is 0,
           otherwise the initial value is n+1.

      (g)  working_public_key_algorithm:  the digital signature
           algorithm used to verify the signature of a certificate.  The
           working_public_key_algorithm is initialized from the trusted
           public key algorithm provided in the trust anchor
           information.

      (h)  working_public_key:  the public key used to verify the
           signature of a certificate.  The working_public_key is
           initialized from the trusted public key provided in the trust
           anchor information.

      (i)  working_public_key_parameters:  parameters associated with
           the current public key that may be required to verify a
           signature (depending upon the algorithm).  The
           working_public_key_parameters variable is initialized from
           the trusted public key parameters provided in the trust
           anchor information.

      (j)  working_issuer_name:  the issuer distinguished name expected
           in the next certificate in the chain.  The
           working_issuer_name is initialized to the trusted issuer name
           provided in the trust anchor information.

      (k)  max_path_length:  this integer is initialized to n, is
           decremented for each non-self-issued certificate in the path,
           and may be reduced to the value in the path length constraint
           field within the basic constraints extension of a CA
           certificate.
```

초기화 단계가 완료되면 6.1.3에 지정된 기본 인증서 처리 단계를 수행합니다.

---
#### **6.1.3.  Basic Certificate Processing**

인증서 i\(\[1..n\]의 모든 i에 대해\)에 대해 수행되는 기본 경로 처리 작업은 다음과 같습니다.

```text
      (a)  Verify the basic certificate information.  The certificate
           MUST satisfy each of the following:

         (1)  The signature on the certificate can be verified using
              working_public_key_algorithm, the working_public_key, and
              the working_public_key_parameters.
```

- \(2\) 인증서 유효기간에는 현재 시간이 포함됩니다.

```text
         (3)  At the current time, the certificate is not revoked.  This
              may be determined by obtaining the appropriate CRL
              (Section 6.3), by status information, or by out-of-band
              mechanisms.
```

- \(4\) 인증서 발급자 이름은 Working\_issuer\_name 입니다.

```text
      (b)  If certificate i is self-issued and it is not the final
           certificate in the path, skip this step for certificate i.
           Otherwise, verify that the subject name is within one of the
           permitted_subtrees for X.500 distinguished names, and verify
           that each of the alternative names in the subjectAltName
           extension (critical or non-critical) is within one of the
           permitted_subtrees for that name type.

      (c)  If certificate i is self-issued and it is not the final
           certificate in the path, skip this step for certificate i.
           Otherwise, verify that the subject name is not within any of
           the excluded_subtrees for X.500 distinguished names, and
           verify that each of the alternative names in the
           subjectAltName extension (critical or non-critical) is not
           within any of the excluded_subtrees for that name type.

      (d)  If the certificate policies extension is present in the
           certificate and the valid_policy_tree is not NULL, process
           the policy information by performing the following steps in
           order:

         (1)  For each policy P not equal to anyPolicy in the
              certificate policies extension, let P-OID denote the OID
              for policy P and P-Q denote the qualifier set for policy
              P.  Perform the following steps in order:

            (i)   For each node of depth i-1 in the valid_policy_tree
                  where P-OID is in the expected_policy_set, create a
                  child node as follows: set the valid_policy to P-OID,
                  set the qualifier_set to P-Q, and set the
                  expected_policy_set to
                  {P-OID}.

                  For example, consider a valid_policy_tree with a node
                  of depth i-1 where the expected_policy_set is {Gold,
                  White}.  Assume the certificate policies Gold and
                  Silver appear in the certificate policies extension of
                  certificate i.  The Gold policy is matched, but the
                  Silver policy is not.  This rule will generate a child
                  node of depth i for the Gold policy.  The result is
                  shown as Figure 4.

                             +-----------------+
                             |       Red       |
                             +-----------------+
                             |       {}        |
                             +-----------------+   node of depth i-1
                             |  {Gold, White}  |
                             +-----------------+
                                      |
                                      |
                                      |
                                      V
                             +-----------------+
                             |      Gold       |
                             +-----------------+
                             |       {}        |
                             +-----------------+   node of depth i
                             |     {Gold}      |
                             +-----------------+

                    Figure 4.  Processing an Exact Match

            (ii)  If there was no match in step (i) and the
                  valid_policy_tree includes a node of depth i-1 with
                  the valid_policy anyPolicy, generate a child node with
                  the following values: set the valid_policy to P-OID,
                  set the qualifier_set to P-Q, and set the
                  expected_policy_set to  {P-OID}.

                  For example, consider a valid_policy_tree with a node
                  of depth i-1 where the valid_policy is anyPolicy.
                  Assume the certificate policies Gold and Silver appear
                  in the certificate policies extension of certificate
                  i.  The Gold policy does not have a qualifier, but the
                  Silver policy has the qualifier Q-Silver.  If Gold and
                  Silver were not matched in (i) above, this rule will
                  generate two child nodes of depth i, one for each
                  policy.  The result is shown as Figure 5.

                                   +-----------------+
                                   |    anyPolicy    |
                                   +-----------------+
                                   |       {}        |
                                   +-----------------+ node of depth i-1
                                   |   {anyPolicy}   |
                                   +-----------------+
                                      /           \
                                     /             \
                                    /               \
                                   /                 \
                     +-----------------+          +-----------------+
                     |      Gold       |          |     Silver      |
                     +-----------------+          +-----------------+
                     |       {}        |          |   {Q-Silver}    |
                     +-----------------+ nodes of +-----------------+
                     |     {Gold}      | depth i  |    {Silver}     |
                     +-----------------+          +-----------------+

                  Figure 5.  Processing Unmatched Policies when a
                  Leaf Node Specifies anyPolicy

         (2)  If the certificate policies extension includes the policy
              anyPolicy with the qualifier set AP-Q and either (a)
              inhibit_anyPolicy is greater than 0 or (b) i<n and the
              certificate is self-issued, then:

              For each node in the valid_policy_tree of depth i-1, for
              each value in the expected_policy_set (including
              anyPolicy) that does not appear in a child node, create a
              child node with the following values: set the valid_policy

              to the value from the expected_policy_set in the parent
              node, set the qualifier_set to AP-Q, and set the
              expected_policy_set to the value in the valid_policy from
              this node.

              For example, consider a valid_policy_tree with a node of
              depth i-1 where the expected_policy_set is {Gold, Silver}.
              Assume anyPolicy appears in the certificate policies
              extension of certificate i with no policy qualifiers, but
              Gold and Silver do not appear.  This rule will generate
              two child nodes of depth i, one for each policy.  The
              result is shown below as Figure 6.

                               +-----------------+
                               |      Red        |
                               +-----------------+
                               |       {}        |
                               +-----------------+ node of depth i-1
                               |  {Gold, Silver} |
                               +-----------------+
                                  /           \
                                 /             \
                                /               \
                               /                 \
                 +-----------------+          +-----------------+
                 |      Gold       |          |     Silver      |
                 +-----------------+          +-----------------+
                 |       {}        |          |       {}        |
                 +-----------------+ nodes of +-----------------+
                 |     {Gold}      | depth i  |    {Silver}     |
                 +-----------------+          +-----------------+

              Figure 6.  Processing Unmatched Policies When the
              Certificate Policies Extension Specifies anyPolicy

         (3)  If there is a node in the valid_policy_tree of depth i-1
              or less without any child nodes, delete that node.  Repeat
              this step until there are no nodes of depth i-1 or less
              without children.

              For example, consider the valid_policy_tree shown in
              Figure 7 below.  The two nodes at depth i-1 that are
              marked with an 'X' have no children, and they are deleted.
              Applying this rule to the resulting tree will cause the
              node at depth i-2 that is marked with a 'Y' to be deleted.
              In the resulting tree, there are no nodes of depth i-1 or
              less without children, and this step is complete.

      (e)  If the certificate policies extension is not present, set the
           valid_policy_tree to NULL.

      (f)  Verify that either explicit_policy is greater than 0 or the
           valid_policy_tree is not equal to NULL;
```

\(a\), \(b\), \(c\) 또는 \(f\) 단계 중 하나라도 실패하면 절차가 종료되고 실패 표시와 적절한 이유가 반환됩니다.

i가 n과 같지 않으면 섹션 6.1.4에 나열된 준비 단계를 계속 수행합니다. i가 n과 같으면 섹션 6.1.5에 나열된 마무리 단계를 수행합니다.

```text
                                 +-----------+
                                 |           | node of depth i-3
                                 +-----------+
                                 /     |     \
                                /      |      \
                               /       |       \
                   +-----------+ +-----------+ +-----------+
                   |           | |           | |     Y     | nodes of
                   +-----------+ +-----------+ +-----------+ depth i-2
                   /   \               |             |
                  /     \              |             |
                 /       \             |             |
      +-----------+ +-----------+ +-----------+ +-----------+ nodes of
      |           | |     X     | |           | |    X      |  depth
      +-----------+ +-----------+ +-----------+ +-----------+   i-1
            |                      /    |    \
            |                     /     |     \
            |                    /      |      \
      +-----------+ +-----------+ +-----------+ +-----------+ nodes of
      |           | |           | |           | |           |  depth
      +-----------+ +-----------+ +-----------+ +-----------+   i

             Figure 7.  Pruning the valid_policy_tree
```

---
#### **6.1.4.  Preparation for Certificate i+1**

- 인증서 i+1 처리를 준비하려면 인증서 i에 대해 다음 단계를 수행합니다.

```text
      (a)  If a policy mappings extension is present, verify that the
           special value anyPolicy does not appear as an
           issuerDomainPolicy or a subjectDomainPolicy.

      (b)  If a policy mappings extension is present, then for each
           issuerDomainPolicy ID-P in the policy mappings extension:

         (1)  If the policy_mapping variable is greater than 0, for each
              node in the valid_policy_tree of depth i where ID-P is the
              valid_policy, set expected_policy_set to the set of
              subjectDomainPolicy values that are specified as
              equivalent to ID-P by the policy mappings extension.

              If no node of depth i in the valid_policy_tree has a
              valid_policy of ID-P but there is a node of depth i with a
              valid_policy of anyPolicy, then generate a child node of
              the node of depth i-1 that has a valid_policy of anyPolicy
              as follows:
```

- \(i\) valid\_policy를 ID-P로 설정합니다.

```text
            (ii)   set the qualifier_set to the qualifier set of the
                   policy anyPolicy in the certificate policies
                   extension of certificate i; and

            (iii)  set the expected_policy_set to the set of
                   subjectDomainPolicy values that are specified as
                   equivalent to ID-P by the policy mappings extension.
```

- \(2\)policy\_mapping 변수가 0인 경우:

```text
            (i)    delete each node of depth i in the valid_policy_tree
                   where ID-P is the valid_policy.

            (ii)   If there is a node in the valid_policy_tree of depth
                   i-1 or less without any child nodes, delete that
                   node.  Repeat this step until there are no nodes of
                   depth i-1 or less without children.
```

- \(c\) Working\_issuer\_name에 인증서 주체 이름을 할당합니다.

```text
      (d)  Assign the certificate subjectPublicKey to
           working_public_key.

      (e)  If the subjectPublicKeyInfo field of the certificate contains
           an algorithm field with non-null parameters, assign the
           parameters to the working_public_key_parameters variable.

           If the subjectPublicKeyInfo field of the certificate contains
           an algorithm field with null parameters or parameters are
           omitted, compare the certificate subjectPublicKey algorithm
           to the working_public_key_algorithm.  If the certificate
           subjectPublicKey algorithm and the
           working_public_key_algorithm are different, set the
           working_public_key_parameters to null.

      (f)  Assign the certificate subjectPublicKey algorithm to the
           working_public_key_algorithm variable.

      (g)  If a name constraints extension is included in the
           certificate, modify the permitted_subtrees and
           excluded_subtrees state variables as follows:

         (1)  If permittedSubtrees is present in the certificate, set
              the permitted_subtrees state variable to the intersection
              of its previous value and the value indicated in the
              extension field.  If permittedSubtrees does not include a
              particular name type, the permitted_subtrees state
              variable is unchanged for that name type.  For example,
              the intersection of example.com and foo.example.com is
              foo.example.com.  And the intersection of example.com and
              example.net is the empty set.

         (2)  If excludedSubtrees is present in the certificate, set the
              excluded_subtrees state variable to the union of its
              previous value and the value indicated in the extension
              field.  If excludedSubtrees does not include a particular
              name type, the excluded_subtrees state variable is
              unchanged for that name type.  For example, the union of
              the name spaces example.com and foo.example.com is
              example.com.  And the union of example.com and example.net
              is both name spaces.
```

- \(h\) 인증서 i가 자체 발급되지 않은 경우:

```text
         (1)  If explicit_policy is not 0, decrement explicit_policy by
              1.
```

- \(2\)policy\_mapping이 0이 아닌 경우,policy\_mapping을 1씩 감소시킵니다.

```text
         (3)  If inhibit_anyPolicy is not 0, decrement inhibit_anyPolicy
              by 1.

      (i)  If a policy constraints extension is included in the
           certificate, modify the explicit_policy and policy_mapping
           state variables as follows:

         (1)  If requireExplicitPolicy is present and is less than
              explicit_policy, set explicit_policy to the value of
              requireExplicitPolicy.

         (2)  If inhibitPolicyMapping is present and is less than
              policy_mapping, set policy_mapping to the value of
              inhibitPolicyMapping.

      (j)  If the inhibitAnyPolicy extension is included in the
           certificate and is less than inhibit_anyPolicy, set
           inhibit_anyPolicy to the value of inhibitAnyPolicy.

      (k)  If certificate i is a version 3 certificate, verify that the
           basicConstraints extension is present and that cA is set to
           TRUE.  (If certificate i is a version 1 or version 2
           certificate, then the application MUST either verify that
           certificate i is a CA certificate through out-of-band means
           or reject the certificate.  Conforming implementations may
           choose to reject all version 1 and version 2 intermediate
           certificates.)

      (l)  If the certificate was not self-issued, verify that
           max_path_length is greater than zero and decrement
           max_path_length by 1.

      (m)  If pathLenConstraint is present in the certificate and is
           less than max_path_length, set max_path_length to the value
           of pathLenConstraint.

      (n)  If a key usage extension is present, verify that the
           keyCertSign bit is set.

      (o)  Recognize and process any other critical extension present in
           the certificate.  Process any other recognized non-critical
           extension present in the certificate that is relevant to path
           processing.
```

검사 \(a\), \(k\), \(l\), \(n\) 또는 \(o\)가 실패하면 절차가 종료되고 실패 표시와 적절한 이유가 반환됩니다.

\(a\), \(k\), \(l\), \(n\) 및 \(o\)가 성공적으로 완료되면 i를 증가시키고 섹션 6.1.3에 지정된 기본 인증서 처리를 수행합니다.

---
#### **6.1.5.  Wrap-Up Procedure**

대상 인증서 처리를 완료하려면 인증서 n에 대해 다음 단계를 수행하십시오.

- \(a\)explicit\_policy가 0이 아닌 경우,explicit\_policy를 1씩 감소시킵니다.

```text
      (b)  If a policy constraints extension is included in the
           certificate and requireExplicitPolicy is present and has a
           value of 0, set the explicit_policy state variable to 0.

      (c)  Assign the certificate subjectPublicKey to
           working_public_key.

      (d)  If the subjectPublicKeyInfo field of the certificate contains
           an algorithm field with non-null parameters, assign the
           parameters to the working_public_key_parameters variable.

           If the subjectPublicKeyInfo field of the certificate contains
           an algorithm field with null parameters or parameters are
           omitted, compare the certificate subjectPublicKey algorithm
           to the working_public_key_algorithm.  If the certificate
           subjectPublicKey algorithm and the
           working_public_key_algorithm are different, set the
           working_public_key_parameters to null.

      (e)  Assign the certificate subjectPublicKey algorithm to the
           working_public_key_algorithm variable.

      (f)  Recognize and process any other critical extension present in
           the certificate n.  Process any other recognized non-critical
           extension present in certificate n that is relevant to path
           processing.

      (g)  Calculate the intersection of the valid_policy_tree and the
           user-initial-policy-set, as follows:

         (i)    If the valid_policy_tree is NULL, the intersection is
                NULL.

         (ii)   If the valid_policy_tree is not NULL and the user-
                initial-policy-set is any-policy, the intersection is
                the entire valid_policy_tree.

         (iii)  If the valid_policy_tree is not NULL and the user-
                initial-policy-set is not any-policy, calculate the
                intersection of the valid_policy_tree and the user-
                initial-policy-set as follows:

             1.  Determine the set of policy nodes whose parent nodes
                 have a valid_policy of anyPolicy.  This is the
                 valid_policy_node_set.

             2.  If the valid_policy of any node in the
                 valid_policy_node_set is not in the user-initial-
                 policy-set and is not anyPolicy, delete this node and
                 all its children.

             3.  If the valid_policy_tree includes a node of depth n
                 with the valid_policy anyPolicy and the user-initial-
                 policy-set is not any-policy, perform the following
                 steps:

               a.  Set P-Q to the qualifier_set in the node of depth n
                   with valid_policy anyPolicy.

               b.  For each P-OID in the user-initial-policy-set that is
                   not the valid_policy of a node in the
                   valid_policy_node_set, create a child node whose
                   parent is the node of depth n-1 with the valid_policy
                   anyPolicy.  Set the values in the child node as
                   follows: set the valid_policy to P-OID, set the
                   qualifier_set to P-Q, and set the expected_policy_set
                   to {P-OID}.

               c.  Delete the node of depth n with the valid_policy
                   anyPolicy.

             4.  If there is a node in the valid_policy_tree of depth
                 n-1 or less without any child nodes, delete that node.
                 Repeat this step until there are no nodes of depth n-1
                 or less without children.
```

\(1\)explicit\_policy 변수의 값이 0보다 크거나 \(2\)valid\_policy\_tree가 NULL이 아닌 경우 경로 처리가 성공한 것입니다.

---
#### **6.1.6.  Outputs**

경로 처리가 성공하면 프로시저가 종료되고 valid\_policy\_tree,working\_public\_key,working\_public\_key\_algorithm 및 Working\_public\_key\_parameters의 최종 값과 함께 성공 표시가 반환됩니다.

---
### **6.2.  Using the Path Validation Algorithm**

경로 유효성 검사 알고리즘은 단일 인증 경로의 유효성을 검사하는 프로세스를 설명합니다. 각 인증 경로는 특정 트러스트 앵커로 시작되지만 특정 시스템에서 검증된 모든 인증 경로가 단일 트러스트 앵커를 공유해야 한다는 요구 사항은 없습니다. 하나 이상의 신뢰할 수 있는 CA 선택은 지역적으로 결정됩니다. 시스템은 신뢰할 수 있는 CA 중 하나를 특정 경로에 대한 신뢰 앵커로 제공할 수 있습니다. 경로 유효성 검사 알고리즘에 대한 입력은 경로마다 다를 수 있습니다. 경로를 처리하는 데 사용되는 입력은 특정 트러스트 앵커에 부여된 신뢰의 애플리케이션별 요구 사항이나 제한 사항을 반영할 수 있습니다. 을 위한

예를 들어 신뢰할 수 있는 CA는 특정 인증서 정책에 대해서만 신뢰할 수 있습니다. 이 제한은 경로 유효성 검사 절차에 대한 입력을 통해 표현될 수 있습니다.

구현은 특정 트러스트 앵커로 시작하는 유효한 인증 경로 집합을 추가로 제한하기 위해 섹션 6.1에 제시된 알고리즘을 강화할 수 있습니다. 예를 들어, 구현은 초기화 단계에서 특정 트러스트 앵커에 경로 길이 제약 조건을 적용하기 위해 알고리즘을 수정할 수도 있고, 애플리케이션이 대상 인증서에 특정 대체 이름 형식의 존재를 요구할 수도 있고, 애플리케이션이 다음에 대한 요구 사항을 부과할 수도 있습니다. 애플리케이션별 확장. 따라서 섹션 6.1에 제시된 경로 유효성 검사 알고리즘은 경로가 유효한 것으로 간주되는 최소 조건을 정의합니다.

CA가 트러스트 앵커 정보를 지정하기 위해 자체 서명된 인증서를 배포하는 경우 인증서 확장을 사용하여 경로 유효성 검사에 권장되는 입력을 지정할 수 있습니다. 예를 들어, 정책 제약 확장은 자체 서명된 인증서에 포함되어 이 트러스트 앵커로 시작하는 경로가 지정된 정책에 대해서만 신뢰되어야 함을 나타낼 수 있습니다. 마찬가지로, 이 트러스트 앵커로 시작하는 경로는 지정된 네임스페이스에 대해서만 신뢰되어야 함을 나타내기 위해 이름 제약 확장이 포함될 수 있습니다. 섹션 6.1에 제시된 경로 유효성 검사 알고리즘은 트러스트 앵커 정보가 자체 서명된 인증서에 제공된다고 가정하지 않으며 해당 인증서에 포함된 추가 정보에 대한 처리 규칙을 지정하지 않습니다. 트러스트 앵커 정보를 지정하기 위해 자체 서명된 인증서를 사용하는 구현에서는 그러한 정보를 자유롭게 처리하거나 무시할 수 있습니다.

---
### **6.3.  CRL Validation**

이 섹션에서는 CRL이 인증서 발급자가 사용하는 해지 메커니즘인 경우 인증서가 해지되는지 확인하는 데 필요한 단계를 설명합니다. CRL을 지원하는 구현을 준수하는 것은 이 알고리즘을 구현하는 데 필요하지 않지만, 이 프로필에 따라 발행된 CRL을 처리할 때 이 절차에서 발생하는 외부 동작과 기능적으로 동일해야 합니다. 올바른 결과를 도출하는 한 특정 구현에서는 모든 알고리즘을 사용할 수 있습니다.

이 알고리즘은 필요한 모든 CRL을 로컬 캐시에서 사용할 수 있다고 가정합니다. 또한 CRL의 다음 업데이트 시간이 지나면 알고리즘은 현재 CRL을 가져와 로컬 CRL 캐시에 저장하는 메커니즘을 가정합니다.

이 알고리즘은 경로의 각 인증서에 대해 수행되는 입력 집합, 상태 변수 집합 및 처리 단계를 정의합니다. 알고리즘 출력은 인증서의 해지 상태입니다.

---
#### **6.3.1.  Revocation Inputs**

해지 처리를 지원하려면 알고리즘에 다음 두 가지 입력이 필요합니다.

```text
      (a)  certificate:  The algorithm requires the certificate serial
           number and issuer name to determine whether a certificate is
           on a particular CRL.  The basicConstraints extension is used
           to determine whether the supplied certificate is associated
           with a CA or an end entity.  If present, the algorithm uses
           the cRLDistributionPoints and freshestCRL extensions to
           determine revocation status.

      (b)  use-deltas:  This boolean input determines whether delta CRLs
           are applied to CRLs.
```

---
#### **6.3.2.  Initialization and Revocation State Variables**

CRL 처리를 지원하려면 알고리즘에 다음 상태 변수가 필요합니다.

```text
      (a)  reasons_mask:  This variable contains the set of revocation
           reasons supported by the CRLs and delta CRLs processed so
           far.  The legal members of the set are the possible
           revocation reason values minus unspecified: keyCompromise,
           cACompromise, affiliationChanged, superseded,
           cessationOfOperation, certificateHold, privilegeWithdrawn,
           and aACompromise.  The special value all-reasons is used to
           denote the set of all legal members.  This variable is
           initialized to the empty set.

      (b)  cert_status:  This variable contains the status of the
           certificate.  This variable may be assigned one of the
           following values: unspecified, keyCompromise, cACompromise,
           affiliationChanged, superseded, cessationOfOperation,
           certificateHold, removeFromCRL, privilegeWithdrawn,
           aACompromise, the special value UNREVOKED, or the special
           value UNDETERMINED.  This variable is initialized to the
           special value UNREVOKED.

      (c)  interim_reasons_mask:  This contains the set of revocation
           reasons supported by the CRL or delta CRL currently being
           processed.
```

참고: 일부 환경에서는 모든 이유 코드를 확인할 필요가 없습니다. 예를 들어 일부 환경은 CA 인증서에 대한 cACompromise 및 keyCompromise에만 관련됩니다. 이 알고리즘은 모든 이유 코드를 확인합니다. 검사를 이유 코드의 하위 집합으로 제한하려면 추가 처리 및 상태 변수가 필요할 수 있습니다.

---
#### **6.3.3.  CRL Processing**

이 알고리즘은 인증서가 해지되지 않았다는 가정으로 시작됩니다. 알고리즘은 인증서 상태가 해지된 것으로 확인되거나 모든 이유 코드를 포괄하기에 충분한 CRL이 확인될 때까지 하나 이상의 CRL을 확인합니다.

인증서의 CRL 배포 지점 확장에 있는 각 배포 지점\(DP\)에 대해, 로컬 CRL 캐시에 있는 각 해당 CRL에 대해 \(\(reasons\_mask는 모든 이유가 아님\) 및 \(cert\_status는 UNREVOKED입니다\)\) 다음을 수행합니다.

```text
      (a)  Update the local CRL cache by obtaining a complete CRL, a
           delta CRL, or both, as required:

         (1)  If the current time is after the value of the CRL next
              update field, then do one of the following:

            (i)   If use-deltas is set and either the certificate or the
                  CRL contains the freshest CRL extension, obtain a
                  delta CRL with a next update value that is after the
                  current time and can be used to update the locally
                  cached CRL as specified in Section 5.2.4.

            (ii)  Update the local CRL cache with a current complete
                  CRL, verify that the current time is before the next
                  update value in the new CRL, and continue processing
                  with the new CRL.  If use-deltas is set and either the
                  certificate or the CRL contains the freshest CRL
                  extension, then obtain the current delta CRL that can
                  be used to update the new locally cached complete CRL
                  as specified in Section 5.2.4.

         (2)  If the current time is before the value of the next update
              field, use-deltas is set, and either the certificate or
              the CRL contains the freshest CRL extension, then obtain
              the current delta CRL that can be used to update the
              locally cached complete CRL as specified in Section 5.2.4.
```

- \(b\) 다음과 같이 전체 CRL의 발행자와 범위를 확인합니다.

```text
         (1)  If the DP includes cRLIssuer, then verify that the issuer
              field in the complete CRL matches cRLIssuer in the DP and
              that the complete CRL contains an issuing distribution
              point extension with the indirectCRL boolean asserted.
              Otherwise, verify that the CRL issuer matches the
              certificate issuer.

         (2)  If the complete CRL includes an issuing distribution point
              (IDP) CRL extension, check the following:

            (i)   If the distribution point name is present in the IDP
                  CRL extension and the distribution field is present in
                  the DP, then verify that one of the names in the IDP
                  matches one of the names in the DP.  If the
                  distribution point name is present in the IDP CRL
                  extension and the distribution field is omitted from
                  the DP, then verify that one of the names in the IDP
                  matches one of the names in the cRLIssuer field of the
                  DP.

            (ii)  If the onlyContainsUserCerts boolean is asserted in
                  the IDP CRL extension, verify that the certificate
                  does not include the basic constraints extension with
                  the cA boolean asserted.

            (iii) If the onlyContainsCACerts boolean is asserted in the
                  IDP CRL extension, verify that the certificate
                  includes the basic constraints extension with the cA
                  boolean asserted.

            (iv)  Verify that the onlyContainsAttributeCerts boolean is
                  not asserted.

      (c)  If use-deltas is set, verify the issuer and scope of the
           delta CRL as follows:

         (1)  Verify that the delta CRL issuer matches the complete CRL
              issuer.

         (2)  If the complete CRL includes an issuing distribution point
              (IDP) CRL extension, verify that the delta CRL contains a
              matching IDP CRL extension.  If the complete CRL omits an
              IDP CRL extension, verify that the delta CRL also omits an
              IDP CRL extension.

         (3)  Verify that the delta CRL authority key identifier
              extension matches the complete CRL authority key
              identifier extension.
```

- \(d\) 이 CRL에 대한 interim\_reasons\_mask를 다음과 같이 계산합니다.

```text
         (1)  If the issuing distribution point (IDP) CRL extension is
              present and includes onlySomeReasons and the DP includes
              reasons, then set interim_reasons_mask to the intersection
              of reasons in the DP and onlySomeReasons in the IDP CRL
              extension.

         (2)  If the IDP CRL extension includes onlySomeReasons but the
              DP omits reasons, then set interim_reasons_mask to the
              value of onlySomeReasons in the IDP CRL extension.

         (3)  If the IDP CRL extension is not present or omits
              onlySomeReasons but the DP includes reasons, then set
              interim_reasons_mask to the value of DP reasons.

         (4)  If the IDP CRL extension is not present or omits
              onlySomeReasons and the DP omits reasons, then set
              interim_reasons_mask to the special value all-reasons.

      (e)  Verify that interim_reasons_mask includes one or more reasons
           that are not included in the reasons_mask.

      (f)  Obtain and validate the certification path for the issuer of
           the complete CRL.  The trust anchor for the certification
           path MUST be the same as the trust anchor used to validate
           the target certificate.  If a key usage extension is present
           in the CRL issuer's certificate, verify that the cRLSign bit
           is set.

      (g)  Validate the signature on the complete CRL using the public
           key validated in step (f).

      (h)  If use-deltas is set, then validate the signature on the
           delta CRL using the public key validated in step (f).

      (i)  If use-deltas is set, then search for the certificate on the
           delta CRL.  If an entry is found that matches the certificate
           issuer and serial number as described in Section 5.3.3, then
           set the cert_status variable to the indicated reason as
           follows:

         (1)  If the reason code CRL entry extension is present, set the
              cert_status variable to the value of the reason code CRL
              entry extension.

         (2)  If the reason code CRL entry extension is not present, set
              the cert_status variable to the value unspecified.

      (j)  If (cert_status is UNREVOKED), then search for the
           certificate on the complete CRL.  If an entry is found that
           matches the certificate issuer and serial number as described
           in Section 5.3.3, then set the cert_status variable to the
           indicated reason as described in step (i).

      (k)  If (cert_status is removeFromCRL), then set cert_status to
           UNREVOKED.

      (l)  Set the reasons_mask state variable to the union of its
           previous value and the value of the interim_reasons_mask
           state variable.
```

\(\(reasons\_mask가 모든 이유임\) OR \(cert\_status가 UNREVOKED가 아님\)\)인 경우 해지 상태가 결정되었으므로 cert\_status를 반환합니다.

해지 상태가 확인되지 않은 경우 배포 지점에 지정되지 않았지만 인증서 발급자가 발급한 사용 가능한 CRL을 사용하여 위 프로세스를 반복합니다. 이러한 CRL을 처리하려면 이유와 cRLIssuer 필드가 모두 생략된 DP와 인증서 발급자의 배포 지점 이름을 가정합니다. 즉, fullName의 이름 시퀀스는 인증서 발급자 필드와 인증서 발급자AltName 확장에서 생성됩니다. 이러한 CRL을 처리한 후에도 해지 상태가 아직 결정되지 않은 경우 cert\_status UNDETERMINED를 반환합니다.

---
## **7.  Processing Rules for Internationalized Names**

국제화된 이름은 고유 이름, 국제화된 도메인 이름, 전자 메일 주소 및 국제화된 자원 식별자\(IRI\)를 포함하여 수많은 인증서와 CRL 필드 및 확장명에서 나타날 수 있습니다. 이러한 이름의 저장, 비교 및 ​​표시에는 특별한 주의가 필요합니다. 일부 문자는 여러 가지 방법으로 인코딩될 수 있습니다. 동일한 이름이 여러 인코딩\(예: ASCII 또는 UTF8\)으로 표시될 수 있습니다. 이 섹션에서는 이러한 각 이름 형식의 저장 또는 비교에 대한 적합성 요구 사항을 설정합니다. 이러한 이름 형식 중 일부에 대한 표시에 대한 유익한 지침이 제공됩니다.

---
### **7.1.  Internationalized Names in Distinguished Names**

고유 이름으로 국제화된 이름을 표현하는 방법은 섹션 4.1.2.4, 발행자 이름 및 4.1.2.6, 주체 이름에서 다룹니다. 일반 이름과 같은 표준 명명 속성은 다양한 언어 인코딩을 통해 국제화된 이름을 지원하는 DirectoryString 유형을 사용합니다. 준수 구현은 UTF8String 및 PrintableString을 지원해야 합니다. RFC 3280에서는 UTF8String으로 인코딩된 속성 값의 이진 비교만 요구했지만 이 사양에서는 보다 포괄적인 비교 처리가 필요합니다. 구현 시 TeletexString, BMPString 또는 UniversalString을 사용하여 이름이 인코딩된 인증서 및 CRL이 나타날 수 있지만 이에 대한 지원은 선택 사항입니다.

준수 구현은 PrintableString 또는 UTF8String으로 인코딩된 고유 이름 속성 비교의 기초로 \[RFC4518\]에 지정된 대로 LDAP StringPrep 프로필\(미미한 공간 처리 포함\)을 사용해야 합니다. 준수 구현은 caseIgnoreMatch를 사용하여 이름 비교를 지원해야 합니다\(MUST\). 다른 동등 일치 규칙을 사용하는 속성 유형에 대한 지원은 선택 사항입니다.

CaseIgnoreMatch 일치 규칙을 사용하여 이름을 비교하기 전에, 준수 구현은 다음 설명과 함께 DirectoryString 유형의 각 속성에 대해 \[RFC4518\]에 설명된 6단계 문자열 준비 알고리즘을 수행해야 합니다.

- \* 2단계 Map에서는 \[RFC3454\]의 부록 B.2에 명시된 대로 매핑에 사례 접기가 포함되어야 합니다.

- \* 6단계, 중요하지 않은 문자 제거에서는 \[RFC4518\]의 섹션 2.6.1, 중요하지 않은 공간 처리에 지정된 대로 공백 압축을 수행합니다.

문자열 준비 알고리즘을 수행할 때 속성은 저장된 값으로 처리되어야 합니다.

domainComponent 속성의 비교는 섹션 7.3에 명시된 대로 수행되어야 합니다.

문자열 준비 알고리즘으로 처리한 후 속성 유형이 동일하고 속성 값이 정확히 일치하는 경우 두 개의 이름 지정 속성이 일치합니다. 두 개의 상대 고유 이름 RDN1 및 RDN2는 동일한 수의 명명 속성이 있고 RDN1의 각 명명 속성에 대해 RDN2에 일치하는 명명 속성이 있는 경우 일치합니다. 두 개의 고유 이름 DN1과 DN2는 RDN 수가 동일한 경우 일치합니다. DN1의 각 RDN에 대해 DN2에 일치하는 RDN이 있고 일치하는 RDN은 두 DN에서 동일한 순서로 나타납니다. 고유 이름 DN1은 다음에 의해 정의된 하위 트리 내에 있습니다.

DN1에 최소한 DN2만큼의 RDN이 포함되어 있고 DN1의 후행 RDN이 무시될 때 DN1과 DN2가 일치하는 경우 고유 이름 DN2입니다.

---
### **7.2.  Internationalized Domain Names in GeneralName**

IDN\(국제 도메인 이름\)은 subjectAltName 및 issuerAltName 확장, 이름 제약 조건 확장, 기관 정보 액세스 확장, 주체 정보 액세스 확장, CRL 배포 지점 확장 및 발급 배포 지점 확장의 인증서 및 CRL에 포함될 수 있습니다. 이러한 각 확장은 GeneralName 유형을 사용합니다. GeneralName에서 선택할 수 있는 항목 중 하나는 IA5String 유형으로 정의된 dNSName 필드입니다.

IA5String은 ASCII 문자 집합으로 제한됩니다. 현재 구조에서 국제화된 도메인 이름을 수용하기 위해 구현을 준수하려면 dNSName 필드에 저장하기 전에 RFC 3490의 섹션 4에 지정된 대로 국제화된 도메인 이름을 ACE\(ASCII Compatible Encoding\) 형식으로 변환해야 합니다. 특히, 준수 구현은 다음 설명과 함께 RFC 3490의 섹션 4에 지정된 변환 작업을 수행해야 합니다.

- \* 1단계에서 도메인 이름은 "저장된 문자열"로 간주됩니다. 즉, AllowUnsigned 플래그는 설정되어서는 안 됩니다.

- \* 3단계에서 "UseSTD3ASCIIRules"라는 플래그를 설정합니다.

- \* 4단계에서는 "ToASCII" 작업으로 각 라벨을 처리합니다. 그리고

- \* 5단계에서 모든 라벨 구분 기호를 U+002E\(마침표\)로 변경합니다.

DNS 이름이 동일한지 비교할 때 준수 구현은 전체 DNS 이름에 대해 대소문자를 구분하지 않는 정확한 일치를 수행해야 합니다\(MUST\). 이름 제약 조건을 평가할 때 준수 구현은 레이블별로 대소문자를 구분하지 않는 정확한 일치를 수행해야 합니다\(MUST\). 섹션 4.2.1.10에 명시된 대로 제약 조건으로 제공된 도메인 이름의 왼쪽에 레이블을 추가하여 구성할 수 있는 모든 DNS 이름은 표시된 하위 트리에 속하는 것으로 간주됩니다.

구현에서는 표시하기 전에 IDN을 유니코드로 변환해야 합니다. 특히, 준수 구현은 다음 설명과 함께 RFC 3490의 섹션 4에 지정된 변환 작업을 수행해야 합니다.

- \* 1단계에서 도메인 이름은 "저장된 문자열"로 간주됩니다. 즉, AllowUnsigned 플래그는 설정되어서는 안 됩니다.

- \* 3단계에서 "UseSTD3ASCIIRules"라는 플래그를 설정합니다.

- \* 4단계에서는 "ToUnicode" 작업으로 각 라벨을 처리합니다. 그리고

```text
      *  skip step 5.
```

참고: 구현 시 IDN에 대한 증가된 공간 요구 사항을 허용해야 합니다. IDN ACE 라벨은 4개의 추가 문자 "xn--"로 시작하며 단일 국제 문자를 지정하려면 최대 5개의 ASCII 문자가 필요할 수 있습니다.

---
### **7.3.  Internationalized Domain Names in Distinguished Names**

도메인 이름은 제목 필드, 발급자 필드, subjectAltName 확장 또는 issuerAltName 확장의 도메인 구성 요소를 사용하여 고유 이름으로 표시될 수도 있습니다. GeneralName 유형의 dNSName과 마찬가지로 이 속성의 값은 IA5String으로 정의됩니다. 각 domainComponent 속성은 단일 레이블을 나타냅니다. 고유 이름으로 IDN의 레이블을 나타내려면 구현 시 RFC 3490의 섹션 4.1에 지정된 "ToASCII" 레이블 변환을 수행해야 합니다. 레이블은 "저장된 문자열"로 간주됩니다. 즉, AllowUnsigned 플래그는 설정되어서는 안 됩니다.

준수 구현은 섹션 7.2에 설명된 대로 고유 이름의 domainComponent 속성을 비교할 때 대소문자를 구분하지 않는 정확한 일치를 수행해야 합니다.

구현에서는 표시하기 전에 ACE 레이블을 유니코드로 변환해야 합니다. 특히, 준수 구현은 이름을 표시하기 전에 각 ACE 레이블에 대해 섹션 7.2에 설명된 대로 지정된 "ToUnicode" 변환 작업을 수행해야 합니다.

---
### **7.4.  Internationalized Resource Identifiers**

IRI\(국제화된 리소스 식별자\)는 URI\(Uniform Resource Identifier\)를 국제적으로 보완한 것입니다. IRI는 유니코드의 문자 시퀀스이고, URI는 ASCII 문자 세트의 문자 시퀀스입니다. \[RFC3987\]은 IRI에서 URI로의 매핑을 정의합니다. IRI는 인증서 필드나 확장에서 직접 인코딩되지 않지만 매핑된 URI는 인증서와 CRL에 포함될 수 있습니다. URI는 subjectAltName 및 issuerAltName 확장, 이름 제약 조건 확장, 권한 정보 액세스 확장, 주체 정보 액세스 확장, 발급 배포 지점 확장 및 CRL 배포 지점 확장에 나타날 수 있습니다. 이러한 각 확장은 GeneralName 유형을 사용합니다. URI는 IA5String 유형으로 정의되는 GeneralName의uniformResourceIdentifier 필드에 인코딩됩니다.

현재 구조에서 IRI를 수용하려면 준수 구현은 다음 설명과 함께 \[RFC3987\]의 섹션 3.1에 지정된 대로 IRI를 URI에 매핑해야 합니다.

- \* 1단계에서는 변형 b에 지정된 NFC에 따라 정규화\(NFC에 따른 정규화\)된 원본 IRI 형식에서 UCS 문자 시퀀스를 생성합니다.

- \* 1단계의 출력을 사용하여 2단계를 수행합니다.

구현은 2단계를 수행하기 전에 ireg-name 구성 요소를 변환해서는 안 됩니다.

URI를 비교하기 전에, 준수 구현은 \[RFC3987\]에 설명된 구문 기반 및 체계 기반 정규화 기술의 조합을 수행해야 합니다. 특히, 준수 구현은 다음과 같이 비교를 위해 URI를 준비해야 합니다.

- \* 1단계: IRI가 IDN 사용을 허용하는 경우 해당 이름은 위의 섹션 7.2에 지정된 대로 ASCII 호환 인코딩으로 변환되어야 합니다.

- \* 2단계: \[RFC3987\]의 섹션 5.3.2.1에 설명된 대로 체계와 호스트를 소문자로 정규화합니다.

- \* 3단계: \[RFC3987\]의 섹션 5.3.2.3에 지정된 대로 백분율 인코딩 정규화를 수행합니다.

- \* 4단계: \[RFC3987\]의 섹션 5.3.2.4에 지정된 대로 경로 세그먼트 정규화를 수행합니다.

- \* 5단계: 인식된 경우 구현은 \[RFC3987\]의 섹션 5.3.3에 지정된 대로 체계 기반 정규화를 수행해야 합니다.

준수 구현은 ldap, http, https 및 ftp 체계에 대한 체계 기반 정규화를 인식하고 수행해야 합니다\(MUST\). 구성표가 인식되지 않으면 5단계가 생략됩니다.

URI가 동일한지 비교할 때 구현을 준수하면 대소문자를 구분하여 정확한 일치를 수행해야 합니다.

구현에서는 표시하기 전에 URI를 유니코드로 변환해야 합니다. 특히, 준수 구현은 \[RFC3987\]의 섹션 3.2에 지정된 변환 작업을 수행해야 합니다.

---
### **7.5.  Internationalized Electronic Mail Addresses**

전자 메일 주소는 subjectAltName 및 issuerAltName 확장, 이름 제약 확장, 기관 정보 액세스 확장, 주체 정보 액세스 확장, 발급 배포 지점 확장 또는 CRL 배포 지점 확장의 인증서 및 CRL에 포함될 수 있습니다. 이러한 각 확장은 GeneralName 구성을 사용합니다. GeneralName에는 IA5String 유형으로 정의된 rfc822Name 선택 사항이 포함됩니다. 현재 구조를 사용하여 국제화된 도메인 이름이 있는 이메일 주소를 수용하려면 구현을 준수하여 주소를 ASCII 표현으로 변환해야 합니다.

호스트 부분\(사서함의 도메인\)에 국제화된 이름이 포함된 경우 도메인 이름은 섹션 7.2에 지정된 대로 IDN에서 ACE\(ASCII Compatible Encoding\) 형식으로 변환되어야 합니다.

다음과 같은 경우 두 개의 이메일 주소가 일치하는 것으로 간주됩니다.

- 1\) 각 이름의 로컬 부분이 정확히 일치하고, 그리고

```text
      2)  the host-part of each name matches using a case-insensitive
          ASCII comparison.
```

구현에서는 이러한 확장명에 지정된 국제화된 이메일 주소의 호스트 부분을 표시하기 전에 유니코드로 변환해야 합니다. 특히, 구현을 준수하면 섹션 7.2에 설명된 대로 메일박스의 호스트 부분 변환을 수행해야 합니다.

---
## **8.  Security Considerations**

이 사양의 대부분은 인증서 및 CRL의 형식과 내용에 전념합니다. 인증서와 CRL은 디지털 서명되므로 추가 무결성 서비스가 필요하지 않습니다. 인증서나 CRL은 모두 비밀로 유지될 필요가 없으며 인증서와 CRL에 대한 무제한 및 익명 액세스는 보안에 영향을 미치지 않습니다.

그러나 이 사양의 범위를 벗어나는 보안 요소는 인증서 사용자에게 제공되는 보증에 영향을 미칩니다. 이 섹션에서는 구현자, 관리자 및 사용자가 고려해야 할 중요한 문제를 강조합니다.

주체의 신원과 공개 키의 바인딩을 검증하기 위해 CA 및 RA가 수행하는 절차는 인증서에 포함되어야 하는 보증에 큰 영향을 미칩니다. 의지

당사자들은 CA의 인증 실무 선언문을 검토하기를 원할 수 있습니다. 이는 다른 CA에 인증서를 발급할 때 특히 중요합니다.

서명 및 기타 목적으로 단일 키 쌍을 사용하는 것은 강력히 권장되지 않습니다. 서명 및 키 관리를 위해 별도의 키 쌍을 사용하면 사용자에게 여러 가지 이점이 제공됩니다. 서명 키의 분실 또는 공개와 관련된 결과는 키 관리 키의 분실 또는 공개와 다릅니다. 별도의 키 쌍을 사용하면 균형 있고 유연한 응답이 가능합니다. 마찬가지로, 일부 애플리케이션 환경에서는 각 키 쌍에 대해 서로 다른 유효 기간이나 키 길이가 적절할 수 있습니다. 불행하게도 일부 레거시 애플리케이션\(예: SSL\(Secure Sockets Layer\)\)은 서명 및 키 관리를 위해 단일 키 쌍을 사용합니다.

개인 키를 보호하는 것은 중요한 보안 요소입니다. 소규모에서는 사용자가 개인 키를 보호하지 못하면 공격자가 개인 키를 가장하거나 개인 정보를 해독할 수 있습니다. 더 큰 규모로 CA의 개인 서명 키가 손상되면 치명적인 영향을 미칠 수 있습니다. 공격자가 몰래 개인 키를 획득하면 공격자는 가짜 인증서와 CRL을 발급할 수 있습니다. 가짜 인증서와 CRL이 존재하면 시스템에 대한 신뢰가 약화됩니다. 이러한 손상이 감지되면 손상된 CA에 발급된 모든 인증서를 취소해야 하며, 이를 통해 CA 사용자와 다른 CA 사용자 간의 서비스가 차단됩니다. 이러한 손상 후 재구축하는 것은 문제가 될 수 있으므로 CA는 이러한 사고를 방지하기 위해 강력한 기술적 조치\(예: 변조 방지 암호화 모듈\)와 적절한 관리 절차\(예: 직무 분리\)를 조합하여 구현하는 것이 좋습니다.

CA의 개인 서명 키가 손실되는 경우에도 문제가 발생할 수 있습니다. CA는 CRL을 생성하거나 일반적인 키 롤오버를 수행할 수 없습니다. CA는 서명 키에 대한 보안 백업을 유지해야 합니다. 키 백업 절차의 보안은 키 손상을 방지하는 데 중요한 요소입니다.

해지 정보의 가용성과 최신성은 인증서에 포함되어야 하는 보증 수준에 영향을 미칩니다. 인증서는 자연적으로 만료되지만, 자연 수명 동안 주체와 공개 키 간의 바인딩을 무효화하는 이벤트가 발생할 수 있습니다. 철회 정보가 시의적절하지 않거나 이용할 수 없는 경우 바인딩과 관련된 보증은 명백히 감소됩니다. 신뢰 당사자는 CRL에 나타날 수 있는 모든 중요한 확장을 처리하지 못할 수도 있습니다. CA는 중요한 확장이 포함된 CRL을 통해서만 해지 정보를 제공할 때 특히 주의해야 합니다. 특히 해당 확장에 대한 지원이 이 프로필에서 요구되지 않는 경우 더욱 그렇습니다. 예를 들어, 델타 CRL과 전체 CRL의 조합을 사용하여 해지 정보가 제공되고

델타 CRL은 전체 CRL보다 더 자주 발행되며, 델타 CRL 처리와 관련된 중요한 확장을 처리할 수 없는 신뢰 당사자는 최신 해지 정보를 얻을 수 없습니다. 또는 델타 CRL이 발급될 때마다 전체 CRL이 발급되면 모든 신뢰 당사자가 적시에 해지 정보를 사용할 수 있습니다. 마찬가지로, 해지 확인을 생략하는 섹션 6에 설명된 인증 경로 유효성 검사 메커니즘의 구현은 이를 지원하는 것보다 낮은 보증을 제공합니다.

인증 경로 유효성 검사 알고리즘은 하나 이상의 신뢰할 수 있는 CA에 대한 공개 키\(및 기타 정보\)에 대한 특정 지식에 따라 달라집니다. CA를 신뢰하기로 한 결정은 궁극적으로 인증서에 부여되는 신뢰를 결정하므로 중요한 결정입니다. 신뢰할 수 있는 CA 공개 키\(일반적으로 "자체 서명" 인증서 형식\)의 인증된 배포는 이 사양의 범위를 벗어나는 보안에 중요한 대역 외 프로세스입니다.

또한 신뢰할 수 있는 CA에 대해 키 손상이나 CA 오류가 발생하는 경우 사용자는 경로 유효성 검사 루틴에 제공된 정보를 수정해야 합니다. 신뢰할 수 있는 CA를 너무 많이 선택하면 신뢰할 수 있는 CA 정보를 유지 관리하기가 어려워집니다. 반면에 신뢰할 수 있는 CA를 하나만 선택하면 사용자가 폐쇄된 사용자 커뮤니티로 제한될 수 있습니다.

인증서를 처리하는 구현의 품질도 제공되는 보증 수준에 영향을 미칩니다. 섹션 6에 설명된 경로 유효성 검사 알고리즘은 신뢰할 수 있는 CA 정보의 무결성, 특히 신뢰할 수 있는 CA와 관련된 공개 키의 무결성에 의존합니다. 공격자는 개인 키를 가지고 있는 것을 공개 키로 대체함으로써 사용자가 거짓 인증서를 수락하도록 속일 수 있습니다.

키와 인증서 주체 간의 바인딩은 서명을 생성하는 데 사용되는 암호화 모듈 구현 및 알고리즘보다 강력할 수 없습니다. 키 길이가 짧거나 해시 알고리즘이 약하면 인증서의 유용성이 제한됩니다. CA는 강력한 암호화 기술을 사용할 수 있도록 암호화의 발전에 주목하는 것이 좋습니다. 또한 CA는 약한 서명을 생성하는 CA 또는 최종 엔터티에 대한 인증서 발급을 거부해야 합니다.

이름 비교 규칙을 일관되지 않게 적용하면 유효하지 않은 X.509 인증 경로가 승인되거나 유효한 경로가 거부될 수 있습니다. X.500 사양 시리즈는 문자열 비교가 필요한 고유 이름 비교 규칙을 정의합니다.

대/소문자, 문자 집합, 다중 문자 공백 하위 문자열 또는 선행 및 후행 공백으로 변환됩니다. 이 사양은 이러한 요구 사항을 완화하여 최소한 이진 비교에 대한 지원을 요구합니다.

CA는 CA 인증서의 제목 필드에 있는 고유 이름을 해당 CA가 발급한 인증서의 발급자 필드에 있는 고유 이름과 동일하게 인코딩해야 합니다. CA가 다른 인코딩을 사용하는 경우 구현 시 이 인증서가 포함된 경로의 이름 체인을 인식하지 못할 수 있습니다. 결과적으로 유효한 경로가 거부될 수 있습니다.

또한 고유 이름에 대한 이름 제약 조건은 제목 필드 또는 subjectAltName 확장에 사용된 인코딩과 동일하게 명시되어야 합니다. 그렇지 않은 경우 ExcludedSubtrees로 명시된 이름 제약 조건은 일치하지 않고 잘못된 경로는 허용되며 allowedSubtrees로 표현된 이름 제약 조건은 일치하지 않으며 유효한 경로는 거부됩니다. 유효하지 않은 경로의 승인을 피하기 위해 CA는 가능한 경우 고유 이름에 대한 이름 제약 조건을 allowedSubtree로 명시해야 합니다.

일반적으로 nameConstraints 확장을 사용하여 하나의 이름 형식\(예: DNS 이름\)을 제한하면 다른 이름 형식\(예: 전자 메일 주소\) 사용에 대한 보호가 제공되지 않습니다.

X.509에서는 이름이 명확해야 한다고 규정하고 있지만 관련되지 않은 두 기관이 동일한 발급자 이름으로 인증서 및/또는 CRL을 발급할 위험이 있습니다. 발급자 이름 충돌과 관련된 문제 및 보안 문제를 줄이기 위한 수단으로 CA 및 CRL 발급자 이름은 이름 충돌 가능성을 줄이는 방식으로 구성되어야 합니다. 구현자는 동일한 이름을 가진 관련되지 않은 여러 CA 및 CRL 발급자가 존재할 수 있다는 점을 고려해야 합니다. 최소한 CRL을 검증하는 구현에서는 인증서의 인증 경로와 인증서를 검증하는 데 사용되는 CRL 발급자 인증 경로가 동일한 트러스트 앵커에서 종료되도록 해야 합니다.

전자 메일 주소의 로컬 부분은 대소문자를 구분하지만\[RFC2821\], emailAddress 속성 값은 대소문자를 구분하지 않습니다\[RFC2985\]. 결과적으로 이메일 서버가 사서함 로컬 부분의 대소문자 구분을 활용하는 경우 emailAddress 속성에 대한 일치 규칙이 사용될 때 두 개의 서로 다른 이메일 주소가 동일한 주소로 처리될 위험이 있습니다. 이메일 주소를 호스팅하는 이메일 서버가 이메일 주소의 로컬 부분을 대소문자를 구분하여 처리하는 경우 구현자는 emailAddress 속성에 이메일 주소를 포함해서는 안 됩니다.

구현자는 CRL 배포 지점이나 권한 정보 액세스 확장이 관련된 위험을 인식해야 합니다.

손상된 인증서 또는 CRL에는 악성 코드에 대한 링크가 포함되어 있습니다. 구현자는 항상 검색된 데이터의 유효성을 검사하는 단계를 수행하여 데이터가 올바르게 구성되었는지 확인해야 합니다.

인증서에 https URI 또는 ​​유사한 체계를 사용하는 cRLDistributionPoints 확장이 포함되어 있으면 순환 종속성이 도입될 수 있습니다. 신뢰 당사자는 초기 경로 유효성 검사를 완료하는 데 필요한 CRL을 얻기 위해 추가 경로 유효성 검사를 수행해야 합니다. AuthorityInfoAccess 또는 subjectInfoAccess 확장에서 https URI\(또는 유사한 체계\)를 사용하여 순환 조건을 생성할 수도 있습니다. 최악의 경우 이러한 상황은 해결 불가능한 종속성을 생성할 수 있습니다.

CA는 확장에 https, ldaps 또는 유사한 체계를 지정하는 URI를 포함해서는 안 됩니다. 이러한 확장 중 하나에 https URI를 포함하는 CA는 URI가 가리키는 정보를 사용하지 않고도 서버 인증서의 유효성을 검사할 수 있는지 확인해야 합니다. cRLDistributionPoints, AuthorityInfoAccess 또는 subjectInfoAccess 확장의 https URI가 가리키는 정보를 얻을 때 서버 인증서의 유효성을 검사하기로 선택한 신뢰 당사자는 이로 인해 무제한 재귀가 발생할 가능성에 대비해야 합니다.

자체 발급 인증서는 CA 운영의 변경 사항을 표시하는 하나의 자동화된 메커니즘을 CA에 제공합니다. 특히, 자체 발급 인증서는 손상되지 않은 CA 키 쌍에서 다음 CA 키 쌍으로의 원활한 전환을 구현하는 데 사용될 수 있습니다. "CA 키 업데이트"에 대한 자세한 절차는 \[RFC4210\]에 명시되어 있습니다. 여기서 CA는 이전 개인 키를 사용하여 새 공개 키를 보호하고 그 반대로 자체 발급된 두 개의 인증서를 사용하여 보호합니다. 클라이언트 구현을 준수하면 자체 발급된 인증서를 처리하고 새 키로 발급된 인증서를 신뢰할 수 있는지 여부를 결정합니다. 자체 발급 인증서는 유사한 절차를 사용하여 CA 정책 세트에 추가하는 등 CA 작업의 다른 변경 사항을 지원하는 데 사용될 수 있습니다.

일부 레거시 구현은 ISO 8859-1 문자 집합\(Latin1String\)\[ISO8859\]으로 인코딩된 이름을 지원하지만 TeletexString으로 태그를 지정합니다. TeletexString은 ISO 8859-1보다 더 큰 문자 세트를 인코딩하지만 일부 문자를 다르게 인코딩합니다. 섹션 7.1에 지정된 이름 비교 규칙은 TeletexString이 ASN.1 표준에 설명된 대로 인코딩된다고 가정합니다. Latin1String 문자 세트를 사용하여 인코딩된 이름을 비교할 때 거짓 긍정과 부정이 가능합니다.

문자열이 내부 표현에서 시각적 표현으로 매핑되면 때로는 서로 다른 두 문자열이 동일하거나 유사한 시각적 표현을 갖게 됩니다. 이는 유사한 글리프 사용 및

합성 문자\(예: U+00E9와 동일한 e + ', 한국어 합성 문자 및 특정 언어의 자음 묶음 위의 모음\). 이러한 상황의 결과로, 서로 다른 두 이름을 시각적으로 비교하는 사람들은 실제로는 동일하지 않지만 동일하다고 생각할 수 있습니다. 또한 사람들은 한 문자열을 다른 문자열로 착각할 수도 있습니다. 인증서 발급자와 신뢰 당사자 모두 이 상황을 알고 있어야 합니다.

---
## **9.  IANA Considerations**

인증서 및 CRL의 확장은 개체 식별자를 사용하여 식별됩니다. 객체는 IANA가 PKIX 작업 그룹에 위임한 아크로 정의됩니다. 이 문서나 예상 업데이트에 대해 IANA의 추가 조치는 필요하지 않습니다.

---
## **10.  Acknowledgments**

Warwick Ford는 이 문서의 개발을 지시하는 일부 디자인 팀 회의에 저자들과 함께 참여했습니다. 디자인 팀의 노력은 Matt Crawford, Tom Gindin, Steve Hanna, Stephen Henson, Paul Hoffman, Takashi Ito, Denis Pinkas 및 Wen-Cheng Wang의 기여에 힘입어 이루어졌습니다.

---
## **11.  References**
---
### **11.1.  Normative References**

```text
   [RFC791]   Postel, J., "Internet Protocol", STD 5, RFC 791, September
              1981.

   [RFC1034]  Mockapetris, P., "Domain Names - Concepts and Facilities",
              STD 13, RFC 1034, November 1987.

   [RFC1123]  Braden, R., Ed., "Requirements for Internet Hosts --
              Application and Support", STD 3, RFC 1123, October 1989.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, December 1998.

   [RFC2585]  Housley, R. and P. Hoffman, "Internet X.509 Public Key
              Infrastructure: Operational Protocols: FTP and HTTP", RFC
              2585, May 1999.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

   [RFC2797]  Myers, M., Liu, X., Schaad, J., and J. Weinstein,
              "Certificate Management Messages over CMS", RFC 2797,
              April 2000.

   [RFC2821]  Klensin, J., Ed., "Simple Mail Transfer Protocol", RFC
              2821, April 2001.

   [RFC3454]  Hoffman, P. and M. Blanchet, "Preparation of
              Internationalized Strings ("stringprep")", RFC 3454,
              December 2002.

   [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,
              "Internationalizing Domain Names in Applications (IDNA)",
              RFC 3490, March 2003.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, November 2003.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, RFC
              3986, January 2005.

   [RFC3987]  Duerst, M. and M. Suignard, "Internationalized Resource
              Identifiers (IRIs)", RFC 3987, January 2005.

   [RFC4516]  Smith, M., Ed., and T. Howes, "Lightweight Directory
              Access Protocol (LDAP): Uniform Resource Locator", RFC
              4516, June 2006.

   [RFC4518]  Zeilenga, K., "Lightweight Directory Access Protocol
              (LDAP): Internationalized String Preparation", RFC 4518,
              June 2006.

   [RFC4523]  Zeilenga, K., "Lightweight Directory Access Protocol
              (LDAP) Schema Definitions for X.509 Certificates", RFC
              4523, June 2006.

   [RFC4632]  Fuller, V. and T. Li, "Classless Inter-domain Routing
              (CIDR): The Internet Address Assignment and Aggregation
              Plan", BCP 122, RFC 4632, August 2006.

   [X.680]    ITU-T Recommendation X.680 (2002) | ISO/IEC 8824-1:2002,
              Information technology - Abstract Syntax Notation One
              (ASN.1):  Specification of basic notation.

   [X.690]    ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002,
              Information technology - ASN.1 encoding rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER).
```

---
### **11.2.  Informative References**

```text
   [ISO8859]  ISO/IEC 8859-1:1998.  Information technology -- 8-bit
              single-byte coded graphic character sets -- Part 1: Latin
              alphabet No. 1.

   [ISO10646] ISO/IEC 10646:2003.  Information technology -- Universal
              Multiple-Octet Coded Character Set (UCS).

   [NFC]      Davis, M. and M. Duerst, "Unicode Standard Annex #15:
              Unicode Normalization Forms", October 2006,
              <http://www.unicode.org/reports/tr15/>.

   [RFC1422]  Kent, S., "Privacy Enhancement for Internet Electronic
              Mail: Part II: Certificate-Based Key Management", RFC
              1422, February 1993.

   [RFC2277]  Alvestrand, H., "IETF Policy on Character Sets and
              Languages", BCP 18, RFC 2277, January 1998.

   [RFC2459]  Housley, R., Ford, W., Polk, W., and D. Solo, "Internet
              X.509 Public Key Infrastructure Certificate and CRL
              Profile", RFC 2459, January 1999.

   [RFC2560]  Myers, M., Ankney, R., Malpani, A., Galperin, S., and C.
              Adams, "X.509 Internet Public Key Infrastructure Online
              Certificate Status Protocol - OCSP", RFC 2560, June 1999.

   [RFC2985]  Nystrom, M. and B. Kaliski, "PKCS #9: Selected Object
              Classes and Attribute Types Version 2.0", RFC 2985,
              November 2000.

   [RFC3161]  Adams, C., Cain, P., Pinkas, D., and R. Zuccherato,
              "Internet X.509 Public Key Infrastructure Time-Stamp
              Protocol (TSP)", RFC 3161, August 2001.

   [RFC3279]  Bassham, L., Polk, W., and R. Housley, "Algorithms and
              Identifiers for the Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 3279, April 2002.

   [RFC3280]  Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
              X.509 Public Key Infrastructure Certificate and
              Certificate Revocation List (CRL) Profile", RFC 3280,
              April 2002.

   [RFC4055]  Schaad, J., Kaliski, B., and R. Housley, "Additional
              Algorithms and Identifiers for RSA Cryptography for use in
              the Internet X.509 Public Key Infrastructure Certificate
              and Certificate Revocation List (CRL) Profile", RFC 4055,
              June 2005.

   [RFC4120]  Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
              Kerberos Network Authentication Service (V5)", RFC 4120,
              July 2005.

   [RFC4210]  Adams, C., Farrell, S., Kause, T., and T. Mononen,
              "Internet X.509 Public Key Infrastructure Certificate
              Management Protocol (CMP)", RFC 4210, September 2005.

   [RFC4325]  Santesson, S. and R. Housley, "Internet X.509 Public Key
              Infrastructure Authority Information Access Certificate
              Revocation List (CRL) Extension", RFC 4325, December 2005.

   [RFC4491]  Leontiev, S., Ed., and D. Shefanovski, Ed., "Using the
              GOST R 34.10-94, GOST R 34.10-2001, and GOST R 34.11-94
              Algorithms with the Internet X.509 Public Key
              Infrastructure Certificate and CRL Profile", RFC 4491, May
              2006.

   [RFC4510]  Zeilenga, K., Ed., "Lightweight Directory Access Protocol
              (LDAP): Technical Specification Road Map", RFC 4510, June
              2006.

   [RFC4512]  Zeilenga, K., Ed., "Lightweight Directory Access Protocol
              (LDAP): Directory Information Models", RFC 4512, June
              2006.

   [RFC4514]  Zeilenga, K., Ed., "Lightweight Directory Access Protocol
              (LDAP): String Representation of Distinguished Names", RFC
              4514, June 2006.

   [RFC4519]  Sciberras, A., Ed., "Lightweight Directory Access Protocol
              (LDAP): Schema for User Applications", RFC 4519, June
              2006.

   [RFC4630]  Housley, R. and S. Santesson, "Update to DirectoryString
              Processing in the Internet X.509 Public Key Infrastructure
              Certificate and Certificate Revocation List (CRL)
              Profile", RFC 4630, August 2006.

   [X.500]    ITU-T Recommendation X.500 (2005) | ISO/IEC 9594-1:2005,
              Information technology - Open Systems Interconnection -
              The Directory: Overview of concepts, models and services.

   [X.501]    ITU-T Recommendation X.501 (2005) | ISO/IEC 9594-2:2005,
              Information technology - Open Systems Interconnection -
              The Directory: Models.

   [X.509]    ITU-T Recommendation X.509 (2005) | ISO/IEC 9594-8:2005,
              Information technology - Open Systems Interconnection -
              The Directory: Public-key and attribute certificate
              frameworks.

   [X.520]    ITU-T Recommendation X.520 (2005) | ISO/IEC 9594-6:2005,
              Information technology - Open Systems Interconnection -
              The Directory: Selected attribute types.

   [X.660]    ITU-T Recommendation X.660 (2004) | ISO/IEC 9834-1:2005,
              Information technology - Open Systems Interconnection -
              Procedures for the operation of OSI Registration
              Authorities: General procedures, and top arcs of the ASN.1
              Object Identifier tree.

   [X.683]    ITU-T Recommendation X.683 (2002) | ISO/IEC 8824-4:2002,
              Information technology - Abstract Syntax Notation One
              (ASN.1): Parameterization of ASN.1 specifications.

   [X9.55]    ANSI X9.55-1997, Public Key Cryptography for the Financial
              Services Industry: Extensions to Public Key Certificates
              and Certificate Revocation Lists, January 1997.
```

---
# **Appendix A.  Pseudo-ASN.1 Structures and OIDs**

이 부록에서는 "ASN.1과 유사한" 구문으로 PKI 구성 요소를 준수하는 데 사용되는 데이터 개체에 대해 설명합니다. 이 구문은 1988 및 1993 ASN.1 구문을 혼합한 것입니다. 1988 ASN.1 구문은 1993 UNIVERSAL 유형 UniversalString, BMPString 및 UTF8String으로 확장되었습니다.

ASN.1 구문은 ASN.1 모듈에 유형 문을 포함하는 것을 허용하지 않으며 1993 ASN.1 표준은 1988 구문을 사용하는 모듈에서 새로운 UNIVERSAL 유형의 사용을 허용하지 않습니다. 결과적으로 이 모듈은 ASN.1 표준의 두 버전 모두를 준수하지 않습니다.

이 부록은 UNIVERSAL 유형에 대한 정의를 1988 포괄적인 "ANY"로 대체하여 1988 ASN.1로 변환될 수 있습니다.

---
### **A.1.  Explicitly Tagged Module, 1988 Syntax**

```text
PKIX1Explicit88 { iso(1) identified-organization(3) dod(6) internet(1)
  security(5) mechanisms(5) pkix(7) id-mod(0) id-pkix1-explicit(18) }
```

---
# **DEFINITIONS EXPLICIT TAGS ::=**
---
# **BEGIN**

```text
-- EXPORTS ALL --

-- IMPORTS NONE --
```

-- 1993년과 1998년 ASN.1에 정의된 UNIVERSAL 유형 -- 이 사양에서 요구되는 유형

UniversalString ::= \[UNIVERSAL 28\] IMPLICIT OCTET STRING -- UniversalString은 ASN.1:1993에 정의되어 있습니다.

BMPString ::= \[UNIVERSAL 30\] IMPLICIT OCTET STRING -- BMPString은 UniversalString 및 모델의 하위 유형입니다 -- ISO/IEC 10646의 기본 다국어 평면

UTF8String ::= \[UNIVERSAL 12\] IMPLICIT OCTET STRING -- 이 유형의 콘텐츠는 RFC 3629를 준수합니다.

```text
-- PKIX specific OIDs

id-pkix  OBJECT IDENTIFIER  ::=
         { iso(1) identified-organization(3) dod(6) internet(1)
                    security(5) mechanisms(5) pkix(7) }

-- PKIX arcs
```

id-pe OBJECT IDENTIFIER ::= { id-pkix 1 } -- 개인 인증서 확장에 대한 호 id-qt OBJECT IDENTIFIER ::= { id-pkix 2 } -- 정책 한정자 유형에 대한 호 id-kp OBJECT IDENTIFIER ::= { id-pkix 3 } -- 확장 키 목적을 위한 호 OIDS id-ad OBJECT IDENTIFIER ::= { id-pkix 48 } -- 액세스 설명자를 위한 호

-- 인터넷 정책 한정자를 위한policyQualifierIds

```text
id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
      -- OID for CPS qualifier
id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
      -- OID for user notice qualifier

-- access descriptor definitions

id-ad-ocsp         OBJECT IDENTIFIER ::= { id-ad 1 }
id-ad-caIssuers    OBJECT IDENTIFIER ::= { id-ad 2 }
id-ad-timeStamping OBJECT IDENTIFIER ::= { id-ad 3 }
id-ad-caRepository OBJECT IDENTIFIER ::= { id-ad 5 }

-- attribute data types

Attribute               ::= SEQUENCE {
      type             AttributeType,
      values    SET OF AttributeValue }
            -- at least one value is required
```

---
# **AttributeType           ::= OBJECT IDENTIFIER**
---
# **AttributeValue          ::= ANY -- DEFINED BY AttributeType**

```text
AttributeTypeAndValue   ::= SEQUENCE {
        type    AttributeType,
        value   AttributeValue }
```

-- 제안된 명명 속성: 다음 정의 - 정보 개체 집합은 지역 요구 사항을 충족하기 위해 -- 확장될 수 있습니다. 세트의 멤버를 삭제하면 해당 구현과의 상호 운용성이 저하될 수 있습니다. -- 쌍으로 표시: AttributeType 다음에 해당 AttributeValue에 대한 유형 정의가 옵니다.

-- 표준 명명 속성에 대한 Arc

---
# **id-at OBJECT IDENTIFIER ::= { joint-iso-ccitt(2) ds(5) 4 }**

-- X520name 유형의 이름 지정 속성

```text
id-at-name                AttributeType ::= { id-at 41 }
id-at-surname             AttributeType ::= { id-at  4 }
id-at-givenName           AttributeType ::= { id-at 42 }
id-at-initials            AttributeType ::= { id-at 43 }
id-at-generationQualifier AttributeType ::= { id-at 44 }

-- Naming attributes of type X520Name:
--   X520name ::= DirectoryString (SIZE (1..ub-name))
--
-- Expanded to avoid parameterized type:
X520name ::= CHOICE {
      teletexString     TeletexString   (SIZE (1..ub-name)),
      printableString   PrintableString (SIZE (1..ub-name)),
      universalString   UniversalString (SIZE (1..ub-name)),
      utf8String        UTF8String      (SIZE (1..ub-name)),
      bmpString         BMPString       (SIZE (1..ub-name)) }
```

-- X520CommonName 유형의 이름 지정 속성

---
# **id-at-commonName        AttributeType ::= { id-at 3 }**

```text
-- Naming attributes of type X520CommonName:
--   X520CommonName ::= DirectoryName (SIZE (1..ub-common-name))
--
-- Expanded to avoid parameterized type:
X520CommonName ::= CHOICE {
      teletexString     TeletexString   (SIZE (1..ub-common-name)),
      printableString   PrintableString (SIZE (1..ub-common-name)),
      universalString   UniversalString (SIZE (1..ub-common-name)),
      utf8String        UTF8String      (SIZE (1..ub-common-name)),
      bmpString         BMPString       (SIZE (1..ub-common-name)) }
```

-- X520LocalityName 유형의 이름 지정 속성

---
# **id-at-localityName      AttributeType ::= { id-at 7 }**

```text
-- Naming attributes of type X520LocalityName:
--   X520LocalityName ::= DirectoryName (SIZE (1..ub-locality-name))
--
-- Expanded to avoid parameterized type:
X520LocalityName ::= CHOICE {
      teletexString     TeletexString   (SIZE (1..ub-locality-name)),
      printableString   PrintableString (SIZE (1..ub-locality-name)),
      universalString   UniversalString (SIZE (1..ub-locality-name)),
      utf8String        UTF8String      (SIZE (1..ub-locality-name)),
      bmpString         BMPString       (SIZE (1..ub-locality-name)) }
```

-- X520StateOrProvinceName 유형의 이름 지정 속성

---
# **id-at-stateOrProvinceName AttributeType ::= { id-at 8 }**

```text
-- Naming attributes of type X520StateOrProvinceName:
--   X520StateOrProvinceName ::= DirectoryName (SIZE (1..ub-state-name))
--
-- Expanded to avoid parameterized type:
X520StateOrProvinceName ::= CHOICE {
      teletexString     TeletexString   (SIZE (1..ub-state-name)),
      printableString   PrintableString (SIZE (1..ub-state-name)),
      universalString   UniversalString (SIZE (1..ub-state-name)),
      utf8String        UTF8String      (SIZE (1..ub-state-name)),
      bmpString         BMPString       (SIZE (1..ub-state-name)) }
```

-- X520OrganizationName 유형의 이름 지정 속성

---
# **id-at-organizationName  AttributeType ::= { id-at 10 }**

```text
-- Naming attributes of type X520OrganizationName:
--   X520OrganizationName ::=
--          DirectoryName (SIZE (1..ub-organization-name))
--
-- Expanded to avoid parameterized type:
X520OrganizationName ::= CHOICE {
      teletexString     TeletexString
                          (SIZE (1..ub-organization-name)),
      printableString   PrintableString
                          (SIZE (1..ub-organization-name)),
      universalString   UniversalString
                          (SIZE (1..ub-organization-name)),
      utf8String        UTF8String
                          (SIZE (1..ub-organization-name)),
      bmpString         BMPString
                          (SIZE (1..ub-organization-name))  }
```

-- X520OrganizationalUnitName 유형의 이름 지정 속성

---
# **id-at-organizationalUnitName AttributeType ::= { id-at 11 }**

```text
-- Naming attributes of type X520OrganizationalUnitName:
--   X520OrganizationalUnitName ::=
--          DirectoryName (SIZE (1..ub-organizational-unit-name))
--
-- Expanded to avoid parameterized type:
X520OrganizationalUnitName ::= CHOICE {
      teletexString     TeletexString
                          (SIZE (1..ub-organizational-unit-name)),
      printableString   PrintableString
                          (SIZE (1..ub-organizational-unit-name)),
      universalString   UniversalString
                          (SIZE (1..ub-organizational-unit-name)),
      utf8String        UTF8String
                          (SIZE (1..ub-organizational-unit-name)),
      bmpString         BMPString
                          (SIZE (1..ub-organizational-unit-name)) }
```

-- X520Title 유형의 이름 지정 속성

---
# **id-at-title             AttributeType ::= { id-at 12 }**

```text
-- Naming attributes of type X520Title:
--   X520Title ::= DirectoryName (SIZE (1..ub-title))
--
-- Expanded to avoid parameterized type:
X520Title ::= CHOICE {
      teletexString     TeletexString   (SIZE (1..ub-title)),
      printableString   PrintableString (SIZE (1..ub-title)),
      universalString   UniversalString (SIZE (1..ub-title)),
      utf8String        UTF8String      (SIZE (1..ub-title)),
      bmpString         BMPString       (SIZE (1..ub-title)) }
```

-- X520dnQualifier 유형의 이름 지정 속성

---
# **id-at-dnQualifier       AttributeType ::= { id-at 46 }**
---
# **X520dnQualifier ::=     PrintableString**

-- X520countryName 유형의 이름 지정 속성\(IS 3166의 digraph\)

---
# **id-at-countryName       AttributeType ::= { id-at 6 }**
---
# **X520countryName ::=     PrintableString (SIZE (2))**

-- X520SerialNumber 유형의 이름 지정 속성

---
# **id-at-serialNumber      AttributeType ::= { id-at 5 }**
---
# **X520SerialNumber ::=    PrintableString (SIZE (1..ub-serial-number))**

-- X520Pseudonym 유형의 이름 지정 속성

---
# **id-at-pseudonym         AttributeType ::= { id-at 65 }**

```text
-- Naming attributes of type X520Pseudonym:
--   X520Pseudonym ::= DirectoryName (SIZE (1..ub-pseudonym))
--
-- Expanded to avoid parameterized type:
X520Pseudonym ::= CHOICE {
   teletexString     TeletexString   (SIZE (1..ub-pseudonym)),
   printableString   PrintableString (SIZE (1..ub-pseudonym)),
   universalString   UniversalString (SIZE (1..ub-pseudonym)),
   utf8String        UTF8String      (SIZE (1..ub-pseudonym)),
   bmpString         BMPString       (SIZE (1..ub-pseudonym)) }
```

-- DomainComponent 유형의 이름 지정 속성\(RFC 4519에서\)

---
# **id-domainComponent   AttributeType ::= { 0 9 2342 19200300 100 1 25 }**
---
# **DomainComponent ::=  IA5String**

```text
-- Legacy attributes

pkcs-9 OBJECT IDENTIFIER ::=
       { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 9 }
```

---
# **id-emailAddress      AttributeType ::= { pkcs-9 1 }**
---
# **EmailAddress ::=     IA5String (SIZE (1..ub-emailaddress-length))**

```text
-- naming data types --
```

이름 ::= CHOICE { -- 지금은 단 하나의 가능성만 -- rdnSequence RDNSequence }

---
# **RDNSequence ::= SEQUENCE OF RelativeDistinguishedName**
---
# **DistinguishedName ::=   RDNSequence**
---
# **RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue**

```text
-- Directory string type --

DirectoryString ::= CHOICE {
      teletexString       TeletexString   (SIZE (1..MAX)),
      printableString     PrintableString (SIZE (1..MAX)),
      universalString     UniversalString (SIZE (1..MAX)),
      utf8String          UTF8String      (SIZE (1..MAX)),
      bmpString           BMPString       (SIZE (1..MAX)) }
```

-- 인증서 및 CRL 특정 구조가 여기에서 시작됩니다.

```text
Certificate  ::=  SEQUENCE  {
     tbsCertificate       TBSCertificate,
     signatureAlgorithm   AlgorithmIdentifier,
     signature            BIT STRING  }

TBSCertificate  ::=  SEQUENCE  {
     version         [0]  Version DEFAULT v1,
     serialNumber         CertificateSerialNumber,
     signature            AlgorithmIdentifier,
     issuer               Name,
     validity             Validity,
     subject              Name,
     subjectPublicKeyInfo SubjectPublicKeyInfo,
     issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
                          -- If present, version MUST be v2 or v3
     subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
                          -- If present, version MUST be v2 or v3
     extensions      [3]  Extensions OPTIONAL
                          -- If present, version MUST be v3 --  }
```

---
# **Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }**
---
# **CertificateSerialNumber  ::=  INTEGER**

```text
Validity ::= SEQUENCE {
     notBefore      Time,
     notAfter       Time  }

Time ::= CHOICE {
     utcTime        UTCTime,
     generalTime    GeneralizedTime }
```

---
# **UniqueIdentifier  ::=  BIT STRING**

```text
SubjectPublicKeyInfo  ::=  SEQUENCE  {
     algorithm            AlgorithmIdentifier,
     subjectPublicKey     BIT STRING  }
```

---
# **Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension**

```text
Extension  ::=  SEQUENCE  {
     extnID      OBJECT IDENTIFIER,
     critical    BOOLEAN DEFAULT FALSE,
     extnValue   OCTET STRING
                 -- contains the DER encoding of an ASN.1 value
                 -- corresponding to the extension type identified
                 -- by extnID
     }

-- CRL structures

CertificateList  ::=  SEQUENCE  {
     tbsCertList          TBSCertList,
     signatureAlgorithm   AlgorithmIdentifier,
     signature            BIT STRING  }

TBSCertList  ::=  SEQUENCE  {
     version                 Version OPTIONAL,
                                   -- if present, MUST be v2
     signature               AlgorithmIdentifier,
     issuer                  Name,
     thisUpdate              Time,
     nextUpdate              Time OPTIONAL,
     revokedCertificates     SEQUENCE OF SEQUENCE  {
          userCertificate         CertificateSerialNumber,
          revocationDate          Time,
          crlEntryExtensions      Extensions OPTIONAL
                                   -- if present, version MUST be v2
                               }  OPTIONAL,
     crlExtensions           [0] Extensions OPTIONAL }
                                   -- if present, version MUST be v2
```

-- 버전, 시간, CertificateSerialNumber 및 확장자는 -- 인증서 구조에서 사용하기 위해 이전에 정의되었습니다.

```text
AlgorithmIdentifier  ::=  SEQUENCE  {
     algorithm               OBJECT IDENTIFIER,
     parameters              ANY DEFINED BY algorithm OPTIONAL  }
                                -- contains a value of the type
                                -- registered for use with the
                                -- algorithm object identifier value

-- X.400 address syntax starts here

ORAddress ::= SEQUENCE {
   built-in-standard-attributes BuiltInStandardAttributes,
   built-in-domain-defined-attributes
                   BuiltInDomainDefinedAttributes OPTIONAL,
   -- see also teletex-domain-defined-attributes
   extension-attributes ExtensionAttributes OPTIONAL }

-- Built-in Standard Attributes

BuiltInStandardAttributes ::= SEQUENCE {
   country-name                  CountryName OPTIONAL,
   administration-domain-name    AdministrationDomainName OPTIONAL,
   network-address           [0] IMPLICIT NetworkAddress OPTIONAL,
     -- see also extended-network-address
   terminal-identifier       [1] IMPLICIT TerminalIdentifier OPTIONAL,
   private-domain-name       [2] PrivateDomainName OPTIONAL,
   organization-name         [3] IMPLICIT OrganizationName OPTIONAL,
     -- see also teletex-organization-name
   numeric-user-identifier   [4] IMPLICIT NumericUserIdentifier
                                 OPTIONAL,
   personal-name             [5] IMPLICIT PersonalName OPTIONAL,
     -- see also teletex-personal-name
   organizational-unit-names [6] IMPLICIT OrganizationalUnitNames
                                 OPTIONAL }
     -- see also teletex-organizational-unit-names

CountryName ::= [APPLICATION 1] CHOICE {
   x121-dcc-code         NumericString
                           (SIZE (ub-country-name-numeric-length)),
   iso-3166-alpha2-code  PrintableString
                           (SIZE (ub-country-name-alpha-length)) }

AdministrationDomainName ::= [APPLICATION 2] CHOICE {
   numeric   NumericString   (SIZE (0..ub-domain-name-length)),
   printable PrintableString (SIZE (0..ub-domain-name-length)) }
```

---
# **NetworkAddress ::= X121Address  -- see also extended-network-address**
---
# **X121Address ::= NumericString (SIZE (1..ub-x121-address-length))**
---
# **TerminalIdentifier ::= PrintableString (SIZE (1..ub-terminal-id-length))**

```text
PrivateDomainName ::= CHOICE {
   numeric   NumericString   (SIZE (1..ub-domain-name-length)),
   printable PrintableString (SIZE (1..ub-domain-name-length)) }

OrganizationName ::= PrintableString
                            (SIZE (1..ub-organization-name-length))
  -- see also teletex-organization-name

NumericUserIdentifier ::= NumericString
                            (SIZE (1..ub-numeric-user-id-length))

PersonalName ::= SET {
   surname     [0] IMPLICIT PrintableString
                    (SIZE (1..ub-surname-length)),
   given-name  [1] IMPLICIT PrintableString
                    (SIZE (1..ub-given-name-length)) OPTIONAL,
   initials    [2] IMPLICIT PrintableString
                    (SIZE (1..ub-initials-length)) OPTIONAL,
   generation-qualifier [3] IMPLICIT PrintableString
                    (SIZE (1..ub-generation-qualifier-length))
                    OPTIONAL }
  -- see also teletex-personal-name

OrganizationalUnitNames ::= SEQUENCE SIZE (1..ub-organizational-units)
                             OF OrganizationalUnitName
  -- see also teletex-organizational-unit-names

OrganizationalUnitName ::= PrintableString (SIZE
                    (1..ub-organizational-unit-name-length))

-- Built-in Domain-defined Attributes

BuiltInDomainDefinedAttributes ::= SEQUENCE SIZE
                    (1..ub-domain-defined-attributes) OF
                    BuiltInDomainDefinedAttribute

BuiltInDomainDefinedAttribute ::= SEQUENCE {
   type PrintableString (SIZE
                   (1..ub-domain-defined-attribute-type-length)),
   value PrintableString (SIZE
                   (1..ub-domain-defined-attribute-value-length)) }

-- Extension Attributes

ExtensionAttributes ::= SET SIZE (1..ub-extension-attributes) OF
               ExtensionAttribute

ExtensionAttribute ::=  SEQUENCE {
   extension-attribute-type [0] IMPLICIT INTEGER
                   (0..ub-extension-attributes),
   extension-attribute-value [1]
                   ANY DEFINED BY extension-attribute-type }
```

-- 확장 유형 및 속성 값

---
# **common-name INTEGER ::= 1**
---
# **CommonName ::= PrintableString (SIZE (1..ub-common-name-length))**
---
# **teletex-common-name INTEGER ::= 2**
---
# **TeletexCommonName ::= TeletexString (SIZE (1..ub-common-name-length))**
---
# **teletex-organization-name INTEGER ::= 3**

```text
TeletexOrganizationName ::=
                TeletexString (SIZE (1..ub-organization-name-length))
```

---
# **teletex-personal-name INTEGER ::= 4**

```text
TeletexPersonalName ::= SET {
   surname     [0] IMPLICIT TeletexString
                    (SIZE (1..ub-surname-length)),
   given-name  [1] IMPLICIT TeletexString
                    (SIZE (1..ub-given-name-length)) OPTIONAL,
   initials    [2] IMPLICIT TeletexString
                    (SIZE (1..ub-initials-length)) OPTIONAL,
   generation-qualifier [3] IMPLICIT TeletexString
                    (SIZE (1..ub-generation-qualifier-length))
                    OPTIONAL }
```

---
# **teletex-organizational-unit-names INTEGER ::= 5**

TeletexOrganizationalUnitNames ::= TeletexOrganizationalUnitName의 시퀀스 크기\(1..ub-organizational-units\)

```text
TeletexOrganizationalUnitName ::= TeletexString
                  (SIZE (1..ub-organizational-unit-name-length))
```

---
# **pds-name INTEGER ::= 7**
---
# **PDSName ::= PrintableString (SIZE (1..ub-pds-name-length))**
---
# **physical-delivery-country-name INTEGER ::= 8**

```text
PhysicalDeliveryCountryName ::= CHOICE {
   x121-dcc-code NumericString (SIZE (ub-country-name-numeric-length)),
   iso-3166-alpha2-code PrintableString
                               (SIZE (ub-country-name-alpha-length)) }
```

---
# **postal-code INTEGER ::= 9**

```text
PostalCode ::= CHOICE {
   numeric-code   NumericString (SIZE (1..ub-postal-code-length)),
   printable-code PrintableString (SIZE (1..ub-postal-code-length)) }
```

---
# **physical-delivery-office-name INTEGER ::= 10**
---
# **PhysicalDeliveryOfficeName ::= PDSParameter**
---
# **physical-delivery-office-number INTEGER ::= 11**
---
# **PhysicalDeliveryOfficeNumber ::= PDSParameter**
---
# **extension-OR-address-components INTEGER ::= 12**
---
# **ExtensionORAddressComponents ::= PDSParameter**
---
# **physical-delivery-personal-name INTEGER ::= 13**
---
# **PhysicalDeliveryPersonalName ::= PDSParameter**
---
# **physical-delivery-organization-name INTEGER ::= 14**
---
# **PhysicalDeliveryOrganizationName ::= PDSParameter**
---
# **extension-physical-delivery-address-components INTEGER ::= 15**
---
# **ExtensionPhysicalDeliveryAddressComponents ::= PDSParameter**
---
# **unformatted-postal-address INTEGER ::= 16**

UnformattedPostalAddress ::= SET { 인쇄 가능 주소 SEQUENCE SIZE \(1..ub-pds-physical-address-lines\) OF PrintableString \(SIZE \(1..ub-pds-parameter-length\)\) 선택 사항, teletex-string TeletexString \(SIZE \(1..ub-형식화되지 않은 주소-길이\)\) 선택 사항 }

---
# **street-address INTEGER ::= 17**
---
# **StreetAddress ::= PDSParameter**
---
# **post-office-box-address INTEGER ::= 18**
---
# **PostOfficeBoxAddress ::= PDSParameter**
---
# **poste-restante-address INTEGER ::= 19**
---
# **PosteRestanteAddress ::= PDSParameter**
---
# **unique-postal-name INTEGER ::= 20**
---
# **UniquePostalName ::= PDSParameter**
---
# **local-postal-attributes INTEGER ::= 21**
---
# **LocalPostalAttributes ::= PDSParameter**

```text
PDSParameter ::= SET {
   printable-string PrintableString
                (SIZE(1..ub-pds-parameter-length)) OPTIONAL,
   teletex-string TeletexString
                (SIZE(1..ub-pds-parameter-length)) OPTIONAL }
```

---
# **extended-network-address INTEGER ::= 22**

```text
ExtendedNetworkAddress ::= CHOICE {
   e163-4-address SEQUENCE {
      number      [0] IMPLICIT NumericString
                       (SIZE (1..ub-e163-4-number-length)),
      sub-address [1] IMPLICIT NumericString
                       (SIZE (1..ub-e163-4-sub-address-length))
                       OPTIONAL },
   psap-address   [0] IMPLICIT PresentationAddress }

PresentationAddress ::= SEQUENCE {
    pSelector     [0] EXPLICIT OCTET STRING OPTIONAL,
    sSelector     [1] EXPLICIT OCTET STRING OPTIONAL,
    tSelector     [2] EXPLICIT OCTET STRING OPTIONAL,
    nAddresses    [3] EXPLICIT SET SIZE (1..MAX) OF OCTET STRING }
```

---
# **terminal-type  INTEGER ::= 23**

```text
TerminalType ::= INTEGER {
   telex        (3),
   teletex      (4),
   g3-facsimile (5),
   g4-facsimile (6),
   ia5-terminal (7),
   videotex     (8) } (0..ub-integer-options)

-- Extension Domain-defined Attributes
```

---
# **teletex-domain-defined-attributes INTEGER ::= 6**

TeletexDomainDefinedAttributes ::= TeletexDomainDefinedAttribute의 SEQUENCE SIZE \(1..ub-domain-defined-attributes\)

```text
TeletexDomainDefinedAttribute ::= SEQUENCE {
        type TeletexString
               (SIZE (1..ub-domain-defined-attribute-type-length)),
        value TeletexString
               (SIZE (1..ub-domain-defined-attribute-value-length)) }
```

-- 상한의 사양은 필수로 간주되어야 합니다. -- ITU-T X.411의 부록 B에서 MTS 매개변수의 참조 정의 -- 상한

```text
-- Upper Bounds
ub-name INTEGER ::= 32768
ub-common-name INTEGER ::= 64
ub-locality-name INTEGER ::= 128
ub-state-name INTEGER ::= 128
ub-organization-name INTEGER ::= 64
ub-organizational-unit-name INTEGER ::= 64
ub-title INTEGER ::= 64
ub-serial-number INTEGER ::= 64
ub-match INTEGER ::= 128
ub-emailaddress-length INTEGER ::= 255
ub-common-name-length INTEGER ::= 64
ub-country-name-alpha-length INTEGER ::= 2
ub-country-name-numeric-length INTEGER ::= 3
ub-domain-defined-attributes INTEGER ::= 4
ub-domain-defined-attribute-type-length INTEGER ::= 8
ub-domain-defined-attribute-value-length INTEGER ::= 128
ub-domain-name-length INTEGER ::= 16
ub-extension-attributes INTEGER ::= 256
ub-e163-4-number-length INTEGER ::= 15
ub-e163-4-sub-address-length INTEGER ::= 40
ub-generation-qualifier-length INTEGER ::= 3
ub-given-name-length INTEGER ::= 16
ub-initials-length INTEGER ::= 5
ub-integer-options INTEGER ::= 256
ub-numeric-user-id-length INTEGER ::= 32
ub-organization-name-length INTEGER ::= 64
ub-organizational-unit-name-length INTEGER ::= 32
ub-organizational-units INTEGER ::= 4
ub-pds-name-length INTEGER ::= 16
ub-pds-parameter-length INTEGER ::= 30
ub-pds-physical-address-lines INTEGER ::= 6
ub-postal-code-length INTEGER ::= 16
ub-pseudonym INTEGER ::= 128
ub-surname-length INTEGER ::= 40
ub-terminal-id-length INTEGER ::= 24
ub-unformatted-address-length INTEGER ::= 180
ub-x121-address-length INTEGER ::= 16
```

-- 참고 - TeletexString과 같은 문자열 유형의 상한은 문자로 측정됩니다. PrintableString 또는 IA5String을 제외하고 이러한 값을 유지하려면 훨씬 더 많은 수의 옥텟이 필요합니다. 최소 16옥텟 또는 지정된 것의 두 배 - 상한 중 더 큰 값이 허용되어야 합니다.

-- 텔레텍스스트링. UTF8String 또는 UniversalString의 경우 최소 4배의 상한이 허용되어야 합니다.

---
# **END**
---
### **A.2.  Implicitly Tagged Module, 1988 Syntax**

```text
PKIX1Implicit88 { iso(1) identified-organization(3) dod(6) internet(1)
  security(5) mechanisms(5) pkix(7) id-mod(0) id-pkix1-implicit(19) }
```

---
# **DEFINITIONS IMPLICIT TAGS ::=**
---
# **BEGIN**

```text
-- EXPORTS ALL --

IMPORTS
      id-pe, id-kp, id-qt-unotice, id-qt-cps,
      -- delete following line if "new" types are supported --
      BMPString, UTF8String,  -- end "new" types --
      ORAddress, Name, RelativeDistinguishedName,
      CertificateSerialNumber, Attribute, DirectoryString
      FROM PKIX1Explicit88 { iso(1) identified-organization(3)
            dod(6) internet(1) security(5) mechanisms(5) pkix(7)
            id-mod(0) id-pkix1-explicit(18) };
```

-- 표준 인증서 및 CRL 확장을 위한 ISO 아크

---
# **id-ce OBJECT IDENTIFIER  ::=  {joint-iso-ccitt(2) ds(5) 29}**

-- 권한 키 식별자 OID 및 구문

---
# **id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 }**

```text
AuthorityKeyIdentifier ::= SEQUENCE {
    keyIdentifier             [0] KeyIdentifier            OPTIONAL,
    authorityCertIssuer       [1] GeneralNames             OPTIONAL,
    authorityCertSerialNumber [2] CertificateSerialNumber  OPTIONAL }
    -- authorityCertIssuer and authorityCertSerialNumber MUST both
    -- be present or both be absent
```

---
# **KeyIdentifier ::= OCTET STRING**

-- 주체 키 식별자 OID 및 구문

---
# **id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 14 }**
---
# **SubjectKeyIdentifier ::= KeyIdentifier**

-- 키 사용 확장 OID 및 구문

---
# **id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }**

```text
KeyUsage ::= BIT STRING {
     digitalSignature        (0),
     nonRepudiation          (1),  -- recent editions of X.509 have
                                -- renamed this bit to contentCommitment
     keyEncipherment         (2),
     dataEncipherment        (3),
     keyAgreement            (4),
     keyCertSign             (5),
     cRLSign                 (6),
     encipherOnly            (7),
     decipherOnly            (8) }
```

-- 개인키 사용기간 연장 OID 및 구문

---
# **id-ce-privateKeyUsagePeriod OBJECT IDENTIFIER ::=  { id-ce 16 }**

```text
PrivateKeyUsagePeriod ::= SEQUENCE {
     notBefore       [0]     GeneralizedTime OPTIONAL,
     notAfter        [1]     GeneralizedTime OPTIONAL }
     -- either notBefore or notAfter MUST be present
```

-- 인증서 정책 확장 OID 및 구문

---
# **id-ce-certificatePolicies OBJECT IDENTIFIER ::=  { id-ce 32 }**
---
# **anyPolicy OBJECT IDENTIFIER ::= { id-ce-certificatePolicies 0 }**
---
# **CertificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation**

```text
PolicyInformation ::= SEQUENCE {
     policyIdentifier   CertPolicyId,
     policyQualifiers   SEQUENCE SIZE (1..MAX) OF
             PolicyQualifierInfo OPTIONAL }
```

---
# **CertPolicyId ::= OBJECT IDENTIFIER**

```text
PolicyQualifierInfo ::= SEQUENCE {
     policyQualifierId  PolicyQualifierId,
     qualifier          ANY DEFINED BY policyQualifierId }
```

-- 추가 정책 한정자를 인식하는 구현은 반드시 -- PolicyQualifierId에 대한 다음 정의를 보강해야 합니다.

---
# **PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )**

```text
-- CPS pointer qualifier
```

---
# **CPSuri ::= IA5String**

```text
-- user notice qualifier

UserNotice ::= SEQUENCE {
     noticeRef        NoticeReference OPTIONAL,
     explicitText     DisplayText OPTIONAL }

NoticeReference ::= SEQUENCE {
     organization     DisplayText,
     noticeNumbers    SEQUENCE OF INTEGER }

DisplayText ::= CHOICE {
     ia5String        IA5String      (SIZE (1..200)),
     visibleString    VisibleString  (SIZE (1..200)),
     bmpString        BMPString      (SIZE (1..200)),
     utf8String       UTF8String     (SIZE (1..200)) }
```

-- 정책 매핑 확장 OID 및 구문

---
# **id-ce-policyMappings OBJECT IDENTIFIER ::=  { id-ce 33 }**

```text
PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {
     issuerDomainPolicy      CertPolicyId,
     subjectDomainPolicy     CertPolicyId }
```

-- 주체 대체 이름 확장자 OID 및 구문

---
# **id-ce-subjectAltName OBJECT IDENTIFIER ::=  { id-ce 17 }**
---
# **SubjectAltName ::= GeneralNames**
---
# **GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName**

```text
GeneralName ::= CHOICE {
     otherName                 [0]  AnotherName,
     rfc822Name                [1]  IA5String,
     dNSName                   [2]  IA5String,
     x400Address               [3]  ORAddress,
     directoryName             [4]  Name,
     ediPartyName              [5]  EDIPartyName,
     uniformResourceIdentifier [6]  IA5String,
     iPAddress                 [7]  OCTET STRING,
     registeredID              [8]  OBJECT IDENTIFIER }
```

-- AnotherName은 OTHER-NAME ::= TYPE-IDENTIFIER를 대체합니다. -- TYPE-IDENTIFIER는 '88 ASN.1 구문에서 지원되지 않습니다.

```text
AnotherName ::= SEQUENCE {
     type-id    OBJECT IDENTIFIER,
     value      [0] EXPLICIT ANY DEFINED BY type-id }

EDIPartyName ::= SEQUENCE {
     nameAssigner              [0]  DirectoryString OPTIONAL,
     partyName                 [1]  DirectoryString }
```

-- 발급자 대체 이름 확장자 OID 및 구문

---
# **id-ce-issuerAltName OBJECT IDENTIFIER ::=  { id-ce 18 }**
---
# **IssuerAltName ::= GeneralNames**
---
# **id-ce-subjectDirectoryAttributes OBJECT IDENTIFIER ::=  { id-ce 9 }**
---
# **SubjectDirectoryAttributes ::= SEQUENCE SIZE (1..MAX) OF Attribute**

-- 기본 제약 확장 OID 및 구문

---
# **id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }**

```text
BasicConstraints ::= SEQUENCE {
     cA                      BOOLEAN DEFAULT FALSE,
     pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
```

-- 이름 제약 확장 OID 및 구문

---
# **id-ce-nameConstraints OBJECT IDENTIFIER ::=  { id-ce 30 }**

```text
NameConstraints ::= SEQUENCE {
     permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
     excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
```

---
# **GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree**

```text
GeneralSubtree ::= SEQUENCE {
     base                    GeneralName,
     minimum         [0]     BaseDistance DEFAULT 0,
     maximum         [1]     BaseDistance OPTIONAL }
```

---
# **BaseDistance ::= INTEGER (0..MAX)**

-- 정책 제약 확장 OID 및 구문

---
# **id-ce-policyConstraints OBJECT IDENTIFIER ::=  { id-ce 36 }**

```text
PolicyConstraints ::= SEQUENCE {
     requireExplicitPolicy   [0]     SkipCerts OPTIONAL,
     inhibitPolicyMapping    [1]     SkipCerts OPTIONAL }
```

---
# **SkipCerts ::= INTEGER (0..MAX)**

-- CRL 배포 지점 확장 OID 및 구문

---
# **id-ce-cRLDistributionPoints     OBJECT IDENTIFIER  ::=  {id-ce 31}**
---
# **CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint**

```text
DistributionPoint ::= SEQUENCE {
     distributionPoint       [0]     DistributionPointName OPTIONAL,
     reasons                 [1]     ReasonFlags OPTIONAL,
     cRLIssuer               [2]     GeneralNames OPTIONAL }

DistributionPointName ::= CHOICE {
     fullName                [0]     GeneralNames,
     nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }

ReasonFlags ::= BIT STRING {
     unused                  (0),
     keyCompromise           (1),
     cACompromise            (2),
     affiliationChanged      (3),
     superseded              (4),
     cessationOfOperation    (5),
     certificateHold         (6),
     privilegeWithdrawn      (7),
     aACompromise            (8) }
```

-- 확장된 키 사용 확장 OID 및 구문

---
# **id-ce-extKeyUsage OBJECT IDENTIFIER ::= {id-ce 37}**
---
# **ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId**
---
# **KeyPurposeId ::= OBJECT IDENTIFIER**

```text
-- permit unspecified key uses
```

---
# **anyExtendedKeyUsage OBJECT IDENTIFIER ::= { id-ce-extKeyUsage 0 }**

```text
-- extended key purpose OIDs

id-kp-serverAuth             OBJECT IDENTIFIER ::= { id-kp 1 }
id-kp-clientAuth             OBJECT IDENTIFIER ::= { id-kp 2 }
id-kp-codeSigning            OBJECT IDENTIFIER ::= { id-kp 3 }
id-kp-emailProtection        OBJECT IDENTIFIER ::= { id-kp 4 }
id-kp-timeStamping           OBJECT IDENTIFIER ::= { id-kp 8 }
id-kp-OCSPSigning            OBJECT IDENTIFIER ::= { id-kp 9 }
```

-- 모든 정책 OID 및 구문을 금지합니다.

---
# **id-ce-inhibitAnyPolicy OBJECT IDENTIFIER ::=  { id-ce 54 }**
---
# **InhibitAnyPolicy ::= SkipCerts**

-- 최신 \(델타\)CRL 확장 OID 및 구문

---
# **id-ce-freshestCRL OBJECT IDENTIFIER ::=  { id-ce 46 }**
---
# **FreshestCRL ::= CRLDistributionPoints**

```text
-- authority info access
```

---
# **id-pe-authorityInfoAccess OBJECT IDENTIFIER ::= { id-pe 1 }**

AuthorityInfoAccessSyntax ::= AccessDescription의 시퀀스 크기\(1..MAX\)

```text
AccessDescription  ::=  SEQUENCE {
        accessMethod          OBJECT IDENTIFIER,
        accessLocation        GeneralName  }

-- subject info access
```

---
# **id-pe-subjectInfoAccess OBJECT IDENTIFIER ::= { id-pe 11 }**

SubjectInfoAccessSyntax ::= 액세스 설명의 시퀀스 크기\(1..MAX\)

-- CRL 번호 확장 OID 및 구문

---
# **id-ce-cRLNumber OBJECT IDENTIFIER ::= { id-ce 20 }**
---
# **CRLNumber ::= INTEGER (0..MAX)**

-- 배포 지점 확장 OID 및 구문 발급

---
# **id-ce-issuingDistributionPoint OBJECT IDENTIFIER ::= { id-ce 28 }**

IssuingDistributionPoint ::= SEQUENCE { distributionPoint \[0\] DistributionPointName OPTIONAL, onlyContainsUserCerts \[1\] BOOLEAN DEFAULT FALSE, onlyContainsCACerts \[2\] BOOLEAN DEFAULT FALSE, onlySomeReasons \[3\] ReasonFlags OPTIONAL, indirectCRL \[4\] BOOLEAN DEFAULT FALSE, onlyContainsAttributeCerts \[5\] BOOLEAN DEFAULT FALSE } -- onlyContainsUserCerts, onlyContainsCACerts, -- 및 onlyContainsAttributeCerts 중 최대 하나가 TRUE로 설정될 수 있습니다.

---
# **id-ce-deltaCRLIndicator OBJECT IDENTIFIER ::= { id-ce 27 }**
---
# **BaseCRLNumber ::= CRLNumber**

-- 이유 코드 확장 OID 및 구문

---
# **id-ce-cRLReasons OBJECT IDENTIFIER ::= { id-ce 21 }**

```text
CRLReason ::= ENUMERATED {
     unspecified             (0),
     keyCompromise           (1),
     cACompromise            (2),
     affiliationChanged      (3),
     superseded              (4),
     cessationOfOperation    (5),
     certificateHold         (6),
     removeFromCRL           (8),
     privilegeWithdrawn      (9),
     aACompromise           (10) }
```

-- 인증서 발급자 CRL 항목 확장 OID 및 구문

---
# **id-ce-certificateIssuer OBJECT IDENTIFIER ::= { id-ce 29 }**
---
# **CertificateIssuer ::= GeneralNames**

-- 명령어 확장 OID 및 구문 보유

---
# **id-ce-holdInstructionCode OBJECT IDENTIFIER ::= { id-ce 23 }**
---
# **HoldInstructionCode ::= OBJECT IDENTIFIER**

```text
-- ANSI x9 arc holdinstruction arc

holdInstruction OBJECT IDENTIFIER ::=
          {joint-iso-itu-t(2) member-body(2) us(840) x9cm(10040) 2}

-- ANSI X9 holdinstructions

id-holdinstruction-none OBJECT IDENTIFIER  ::=
                                      {holdInstruction 1} -- deprecated
```

---
# **id-holdinstruction-callissuer OBJECT IDENTIFIER ::= {holdInstruction 2}**
---
# **id-holdinstruction-reject OBJECT IDENTIFIER ::= {holdInstruction 3}**

-- 무효 날짜 CRL 항목 확장 OID 및 구문

---
# **id-ce-invalidityDate OBJECT IDENTIFIER ::= { id-ce 24 }**
---
# **InvalidityDate ::=  GeneralizedTime**
---
# **END**
---
# **Appendix B.  ASN.1 Notes**

CA는 serialNumber가 음이 아닌 정수가 되도록 강제해야 합니다. 즉, INTEGER 값의 DER 인코딩에 있는 부호 비트가 0이어야 합니다. 필요한 경우 선행\(가장 왼쪽\) \`00'H 옥텟을 추가하여 이를 수행할 수 있습니다. 이는 옥텟 문자열과 정수 값 사이의 매핑에서 잠재적인 모호성을 제거합니다.

섹션 4.1.2.2에 명시된 대로 일련번호에는 긴 정수가 포함될 것으로 예상됩니다. 인증서 사용자는 최대 20옥텟 길이의 serialNumber 값을 처리할 수 있어야 합니다. 준수 CA는 20옥텟보다 긴 serialNumber 값을 사용해서는 안 됩니다.

섹션 5.2.3에서 설명한 대로 CRL 번호에는 긴 정수가 포함될 것으로 예상할 수 있습니다. CRL 유효성 검사기는 길이가 최대 20옥텟인 cRLNumber 값을 처리할 수 있어야 합니다. CRL 발급자를 준수하는 경우 20옥텟보다 긴 cRLNumber 값을 사용하면 안 됩니다.

"SEQUENCE SIZE \(1..MAX\) OF" 구조는 여러 ASN.1 구조에 나타납니다. 유효한 ASN.1 시퀀스에는 0개 이상의 항목이 있습니다. SIZE \(1..MAX\) 구성은 시퀀스에 항목이 하나 이상 있도록 제한합니다. MAX는 상한이 지정되지 않았음을 나타냅니다. 구현에서는 해당 환경에 적합한 상한을 자유롭게 선택할 수 있습니다.

문자열 유형 PrintableString은 매우 기본적인 라틴 문자 세트를 지원합니다: 소문자 'a' \~ 'z', 대문자 'A' \~ 'Z', 숫자 '0' \~ '9', 11개의 특수 문자 ' = \( \) + , - . / : ? 그리고 공간.

구현자는 at 기호\('@'\) 및 밑줄\('\_'\) 문자가 ASN.1 유형 PrintableString에서 지원되지 않는다는 점에 유의해야 합니다. 이러한 문자는 인터넷 주소에 자주 나타납니다. 이러한 주소는 이를 지원하는 ASN.1 유형을 사용하여 인코딩되어야 합니다. 일반적으로 고유 이름 내의 emailAddress 속성 또는 GeneralName의 rfc822Name 필드에 IA5String으로 인코딩됩니다. 준수 구현은 at 기호 또는 밑줄 문자를 포함하는 문자열을 PrintableString으로 인코딩해서는 안 됩니다.

문자열 유형 TeletexString은 PrintableString의 상위 집합입니다. TeletexString은 상당히 표준적인\(ASCII와 유사한\) 라틴 문자 세트\(공백 없는 악센트가 있는 라틴 문자 및 일본어 문자\)를 지원합니다.

명명된 비트 목록은 값에 이름이 할당된 BIT STRING입니다. 이 사양에서는 키 사용, CRL 배포 지점, 최신 CRL 인증서 확장, 최신 CRL 및 발급 배포 지점 CRL 확장에 대한 정의에서 명명된 비트 목록을 사용합니다. 명명된 비트 목록을 DER 인코딩할 때 후행 0은 생략되어야 합니다. 즉, 인코딩된 값은 1로 설정된 마지막 명명된 비트로 끝납니다.

문자열 유형 UniversalString은 \[ISO10646\]에서 허용하는 모든 문자를 지원합니다. ISO 10646은 범용 다중 옥텟 코드 문자 집합\(UCS\)입니다.

문자열 유형 UTF8String은 ASN.1의 1997 버전에서 도입되었으며 UTF8String은 \[X.520\]의 2001 버전에서 DirectoryString에 대한 선택 목록에 추가되었습니다. UTF8String은 범용 유형이며 태그 번호 12가 할당되었습니다. UTF8String의 내용은 RFC 2044에 의해 정의되었으며 \[RFC3629\]에서 업데이트된 RFC 2279에서 업데이트되었습니다.

이러한 변경을 예상하고 \[RFC2277\], 문자 집합 및 언어에 대한 IETF 정책에 성문화된 IETF 모범 사례에 따라 이 문서에는 DirectoryString 및 userNotice 인증서 정책 한정자의 선택 항목으로 UTF8String이 포함되어 있습니다.

\[X.520\]에 정의된 많은 속성 유형의 경우 AttributeValue는 DirectoryString 유형을 사용합니다. 부록 A에 지정된 속성 중 name, surname, GiveName,initials, GenerationQualifier, commonName, localityName, stateOrProvinceName, organizationName, organizationUnitName, title 및 pseudonym 속성은 모두 DirectoryString 유형을 사용합니다. X.520은 DirectoryString의 매개변수화된 유형 정의 \[X.683\]를 사용하여 이러한 각 속성에 대한 구문을 지정합니다. 매개변수는 속성에 허용되는 최대 문자열 길이를 나타내는 데 사용됩니다. 부록 A에서는 매개변수화된 유형 정의의 사용을 피하기 위해 DirectoryString 유형이 이러한 각 속성 유형의 정의에 대해 확장된 형식으로 작성되었습니다. 따라서 부록 A의 ASN.1은 이러한 각 속성에 대한 구문을 CHOICE의 각 유형에 적용되는 문자열 길이에 대한 적절한 제약 조건과 함께 TeletexString, PrintableString, UniversalString, UTF8String 및 BMPString의 CHOICE로 설명합니다. , 구문을 설명하기 위해 ASN.1 유형 DirectoryString을 사용하는 대신.

구현자는 SET OF 값의 DER 인코딩에는 값 인코딩의 순서가 필요하다는 점에 유의해야 합니다. 특히 이 문제는 고유 이름과 관련하여 발생합니다.

구현자는 값이 DEFAULT인 SET 또는 SEQUENCE 구성 요소의 DER 인코딩이 인코딩된 인증서 또는 CRL에서 구성 요소를 생략한다는 점에 유의해야 합니다. 예를 들어, cA 값이 FALSE인 BasicConstraints 확장은 인코딩된 인증서에서 cA 부울을 생략합니다.

개체 식별자\(OID\)는 인증서 정책, 공개 키 및 서명 알고리즘, 인증서 확장 등을 식별하기 위해 이 사양 전반에 걸쳐 사용됩니다. OID의 최대 크기는 없습니다. 이 사양에서는 값이 2^28보다 작은 arc 요소가 있는 OID에 대한 지원을 요구합니다. 즉, 값은 0에서 268,435,455 사이여야 합니다. 이를 통해 각 호 요소를 단일 32비트 워드 내에서 표현할 수 있습니다. 구현은 또한 점으로 구분된 십진수\(\[RFC4512\]의 섹션 1.4 참조\) 문자열 표현의 길이가 최대 100바이트\(포함\)일 수 있는 OID를 지원해야 합니다. 구현은 최대 20개 요소\(포함\)가 포함된 OID를 처리할 수 있어야 합니다\(MUST\). CA는 이러한 요구 사항을 초과하는 OID가 포함된 인증서를 발급해서는 안 됩니다. 마찬가지로 CRL 발급자는 이러한 요구 사항을 초과하는 OID가 포함된 CRL을 발급해서는 안 됩니다.

nameConstraints 확장의 GeneralName 필드 값을 인코딩하기 위한 콘텐츠별 규칙은 다른 확장에 적용되는 규칙과 다릅니다. 이 문서에 지정된 다른 모든 인증서, CRL 및 CRL 항목 확장에서 인코딩 규칙은 기본 유형에 대한 규칙을 따릅니다. 예를 들어,uniformResourceIdentifier 필드의 값은 \[RFC3986\]에 지정된 대로 유효한 URI를 포함해야 합니다. nameConstraints 확장의 값 인코딩에 대한 콘텐츠별 규칙은 섹션 4.2.1.10에 지정되어 있으며 이러한 규칙은 기본 유형에 대한 규칙을 따르지 않을 수 있습니다. 예를 들어,uniformResourceIdentifier 필드가 nameConstraints 확장에 나타나면 URI가 아닌 DNS 이름\(예: "host.example.com" 또는 ".example.com"\)을 보유해야 합니다.

구현자는 X.500 표준 커뮤니티가 일련의 확장성 규칙을 개발했다는 ​​경고를 받습니다. 이러한 규칙은 새 OID\(객체 식별자\)를 할당하지 않고 ASN.1 정의를 변경할 수 있는 시기를 결정합니다. 예를 들어, 이 프로파일 문서의 전신인 \[RFC2459\]에 포함된 적어도 두 개의 확장 정의는 본 사양에서는 서로 다른 ASN.1 정의를 가지지만 동일한 OID가 사용됩니다. 알 수 없는 요소가 확장 내에 나타나고 확장이 중요로 표시되지 않은 경우 다음과 같이 알 수 없는 요소를 무시해야 합니다.

- \(a\) 비트 문자열 내에서 알려지지 않은 모든 비트 이름 할당을 무시합니다.

```text
      (b)  ignore all unknown named numbers in an ENUMERATED type or
           INTEGER type that is being used in the enumerated style,
           provided the number occurs as an optional element of a SET or
           SEQUENCE; and

      (c)  ignore all unknown elements in SETs, at the end of SEQUENCEs,
           or in CHOICEs where the CHOICE is itself an optional element
           of a SET or SEQUENCE.
```

예상치 못한 값을 포함하는 확장이 중요로 표시되는 경우 구현에서는 인식할 수 없는 확장이 포함된 인증서나 CRL을 거부해야 합니다.

---
# **Appendix C.  Examples**

이 부록에는 세 개의 인증서와 하나의 CRL이라는 네 가지 예가 포함되어 있습니다. 처음 두 개의 인증서와 CRL은 최소 인증 경로를 구성합니다.

부록 C.1에는 고유 이름이 cn=Example CA,dc=example,dc=com인 CA에서 발급한 "자체 서명" 인증서의 주석이 달린 16진수 덤프가 포함되어 있습니다. 인증서에는 RSA 공개 키가 포함되어 있으며 해당 RSA 개인 키로 서명됩니다.

부록 C.2에는 최종 엔터티 인증서의 주석이 달린 16진수 덤프가 포함되어 있습니다. 최종 엔터티 인증서에는 RSA 공개 키가 포함되어 있으며 부록 C.1의 "자체 서명" 인증서에 해당하는 개인 키로 서명됩니다.

부록 C.3에는 매개변수와 함께 DSA 공개 키를 포함하고 DSA 및 SHA-1로 서명된 최종 엔터티 인증서의 주석이 달린 16진수 덤프가 포함되어 있습니다. 이 인증서는 최소 인증 경로의 일부가 아닙니다.

부록 C.4에는 주석이 달린 CRL의 16진수 덤프가 포함되어 있습니다. CRL은 고유 이름이 cn=Example CA,dc=example,dc=com인 CA에서 발급되며 해지된 인증서 목록에는 부록 C.2에 제시된 최종 엔터티 인증서가 포함됩니다.

인증서는 출력을 생성하기 위해 Peter Gutmann의 dumpasn1 유틸리티를 사용하여 처리되었습니다. dumpasn1 유틸리티의 소스는 <http://www.cs.auckland.ac.nz/\~pgut001/dumpasn1.c\>에서 구할 수 있습니다. 인증서 및 CRL의 바이너리는 http://csrc.nist.gov/groups/ST/crypto\_apps\_infra/documents/pkixtools에서 사용할 수 있습니다.

이 부록에서 문자열 표현을 사용하여 고유 이름이 지정된 위치에서는 \[RFC4514\]에 지정된 규칙을 사용하여 문자열 형식이 지정됩니다.

---
### **C.1.  RSA Self-Signed Certificate**

이 부록에는 578바이트 버전 3 인증서의 주석이 달린 16진수 덤프가 포함되어 있습니다. 인증서에는 다음 정보가 포함되어 있습니다.

\(a\) 일련번호는 17이다. \(b\) 인증서는 RSA 및 SHA-1 해시 알고리즘으로 서명됩니다. \(c\) 발급자의 고유 이름은 cn=Example CA,dc=example,dc=com입니다. \(d\) 주체의 고유 이름은 cn=Example CA,dc=example,dc=com입니다. \(e\) 인증서는 2004년 4월 30일에 발행되었으며 2005년 4월 30일에 만료되었습니다. \(f\) 인증서에는 1024비트 RSA 공개 키가 포함되어 있습니다. \(g\) 인증서에는 섹션 4.2.1.2의 방법 \(1\)을 사용하여 생성된 주체 키 식별자 확장이 포함되어 있습니다. \(h\) 인증서는 CA 인증서입니다\(기본 제약 확장을 통해 표시됨\).

```text
   0  574: SEQUENCE {
   4  423:   SEQUENCE {
   8    3:     [0] {
  10    1:       INTEGER 2
         :       }
  13    1:     INTEGER 17
  16   13:     SEQUENCE {
  18    9:       OBJECT IDENTIFIER
         :         sha1withRSAEncryption (1 2 840 113549 1 1 5)
  29    0:       NULL
         :       }
  31   67:     SEQUENCE {
  33   19:       SET {
  35   17:         SEQUENCE {
  37   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
  49    3:           IA5String 'com'
         :           }
         :         }
  54   23:       SET {
  56   21:         SEQUENCE {
  58   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
  70    7:           IA5String 'example'
         :           }

         :         }
  79   19:       SET {
  81   17:         SEQUENCE {
  83    3:           OBJECT IDENTIFIER commonName (2 5 4 3)
  88   10:           PrintableString 'Example CA'
         :           }
         :         }
         :       }
 100   30:     SEQUENCE {
 102   13:       UTCTime 30/04/2004 14:25:34 GMT
 117   13:       UTCTime 30/04/2005 14:25:34 GMT
         :       }
 132   67:     SEQUENCE {
 134   19:       SET {
 136   17:         SEQUENCE {
 138   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
 150    3:           IA5String 'com'
         :           }
         :         }
 155   23:       SET {
 157   21:         SEQUENCE {
 159   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
 171    7:           IA5String 'example'
         :           }
         :         }
 180   19:       SET {
 182   17:         SEQUENCE {
 184    3:           OBJECT IDENTIFIER commonName (2 5 4 3)
 189   10:           PrintableString 'Example CA'
         :           }
         :         }
         :       }
 201  159:     SEQUENCE {
 204   13:       SEQUENCE {
 206    9:         OBJECT IDENTIFIER
         :           rsaEncryption (1 2 840 113549 1 1 1)
 217    0:         NULL
         :         }
 219  141:       BIT STRING, encapsulates {
 223  137:         SEQUENCE {
 226  129:           INTEGER
         :             00 C2 D7 97 6D 28 70 AA 5B CF 23 2E 80 70 39 EE
         :             DB 6F D5 2D D5 6A 4F 7A 34 2D F9 22 72 47 70 1D
         :             EF 80 E9 CA 30 8C 00 C4 9A 6E 5B 45 B4 6E A5 E6
         :             6C 94 0D FA 91 E9 40 FC 25 9D C7 B7 68 19 56 8F
         :             11 70 6A D7 F1 C9 11 4F 3A 7E 3F 99 8D 6E 76 A5

         :             74 5F 5E A4 55 53 E5 C7 68 36 53 C7 1D 3B 12 A6
         :             85 FE BD 6E A1 CA DF 35 50 AC 08 D7 B9 B4 7E 5C
         :             FE E2 A3 2C D1 23 84 AA 98 C0 9B 66 18 9A 68 47
         :             E9
 358    3:           INTEGER 65537
         :           }
         :         }
         :       }
 363   66:     [3] {
 365   64:       SEQUENCE {
 367   29:         SEQUENCE {
 369    3:           OBJECT IDENTIFIER subjectKeyIdentifier (2 5 29 14)
 374   22:           OCTET STRING, encapsulates {
 376   20:             OCTET STRING
         :               08 68 AF 85 33 C8 39 4A 7A F8 82 93 8E 70 6A 4A
         :               20 84 2C 32
         :             }
         :           }
 398   14:         SEQUENCE {
 400    3:           OBJECT IDENTIFIER keyUsage (2 5 29 15)
 405    1:           BOOLEAN TRUE
 408    4:           OCTET STRING, encapsulates {
 410    2:             BIT STRING 1 unused bits
         :               '0000011'B
         :             }
         :           }
 414   15:         SEQUENCE {
 416    3:           OBJECT IDENTIFIER basicConstraints (2 5 29 19)
 421    1:           BOOLEAN TRUE
 424    5:           OCTET STRING, encapsulates {
 426    3:             SEQUENCE {
 428    1:               BOOLEAN TRUE
         :               }
         :             }
         :           }
         :         }
         :       }
         :     }
 431   13:   SEQUENCE {
 433    9:     OBJECT IDENTIFIER
         :         sha1withRSAEncryption (1 2 840 113549 1 1 5)
 444    0:     NULL
         :     }
 446  129:   BIT STRING
         :     6C F8 02 74 A6 61 E2 64 04 A6 54 0C 6C 72 13 AD
         :     3C 47 FB F6 65 13 A9 85 90 33 EA 76 A3 26 D9 FC
         :     D1 0E 15 5F 28 B7 EF 93 BF 3C F3 E2 3E 7C B9 52
         :     FC 16 6E 29 AA E1 F4 7A 6F D5 7F EF B3 95 CA F3
```

- : 66 88 83 4E A1 35 45 84 CB BC 9B B8 C8 AD C5 5E : 46 D9 0B 0E 8D 80 E1 33 2B DC BE 2B 92 7E 4A 43 : A9 6A EF 8A 63 61 B3 6E 47 38 BE E8 0D A3 67 5D : F3 FA 91 81 3C 92 BB C5 5F 25 25 EB 7C E7 D8 A1 : }

---
### **C.2.  End Entity Certificate Using RSA**

이 부록에는 629바이트 버전 3 인증서의 주석이 달린 16진수 덤프가 포함되어 있습니다. 인증서에는 다음 정보가 포함되어 있습니다.

\(a\) 일련번호는 18이다. \(b\) 인증서는 RSA 및 SHA-1 해시 알고리즘으로 서명됩니다. \(c\) 발급자의 고유 이름은 cn=Example CA,dc=example,dc=com입니다. \(d\) 주체의 고유 이름은 cn=End Entity,dc=example,dc=com입니다. \(e\) 인증서는 2004년 9월 15일부터 2005년 3월 15일까지 유효했습니다. \(f\) 인증서에는 1024비트 RSA 공개 키가 포함되어 있습니다. \(g\) 기본 제약 확장이 존재하지 않기 때문에 인증서는 최종 엔터티 인증서입니다. \(h\) 인증서에는 부록 C.1에 있는 인증서의 주체 키 식별자와 일치하는 기관 키 식별자 확장이 포함되어 있습니다. \(i\) 인증서에는 하나의 대체 이름, 즉 "end.entity@example.com"의 전자 메일 주소\(rfc822Name\)가 포함되어 있습니다.

```text
   0  625: SEQUENCE {
   4  474:   SEQUENCE {
   8    3:     [0] {
  10    1:       INTEGER 2
         :       }
  13    1:     INTEGER 18
  16   13:     SEQUENCE {
  18    9:       OBJECT IDENTIFIER
         :         sha1withRSAEncryption (1 2 840 113549 1 1 5)
  29    0:       NULL
         :       }
  31   67:     SEQUENCE {
  33   19:       SET {
  35   17:         SEQUENCE {
  37   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
  49    3:           IA5String 'com'
         :           }
         :         }
  54   23:       SET {

  56   21:         SEQUENCE {
  58   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
  70    7:           IA5String 'example'
         :           }
         :         }
  79   19:       SET {
  81   17:         SEQUENCE {
  83    3:           OBJECT IDENTIFIER commonName (2 5 4 3)
  88   10:           PrintableString 'Example CA'
         :           }
         :         }
         :       }
 100   30:     SEQUENCE {
 102   13:       UTCTime 15/09/2004 11:48:21 GMT
 117   13:       UTCTime 15/03/2005 11:48:21 GMT
         :       }
 132   67:     SEQUENCE {
 134   19:       SET {
 136   17:         SEQUENCE {
 138   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
 150    3:           IA5String 'com'
         :           }
         :         }
 155   23:       SET {
 157   21:         SEQUENCE {
 159   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
 171    7:           IA5String 'example'
         :           }
         :         }
 180   19:       SET {
 182   17:         SEQUENCE {
 184    3:           OBJECT IDENTIFIER commonName (2 5 4 3)
 189   10:           PrintableString 'End Entity'
         :           }
         :         }
         :       }
 201  159:     SEQUENCE {
 204   13:       SEQUENCE {
 206    9:         OBJECT IDENTIFIER
         :           rsaEncryption (1 2 840 113549 1 1 1)
 217    0:         NULL
         :         }
 219  141:       BIT STRING, encapsulates {
 223  137:         SEQUENCE {
 226  129:           INTEGER

         :             00 E1 6A E4 03 30 97 02 3C F4 10 F3 B5 1E 4D 7F
         :             14 7B F6 F5 D0 78 E9 A4 8A F0 A3 75 EC ED B6 56
         :             96 7F 88 99 85 9A F2 3E 68 77 87 EB 9E D1 9F C0
         :             B4 17 DC AB 89 23 A4 1D 7E 16 23 4C 4F A8 4D F5
         :             31 B8 7C AA E3 1A 49 09 F4 4B 26 DB 27 67 30 82
         :             12 01 4A E9 1A B6 C1 0C 53 8B 6C FC 2F 7A 43 EC
         :             33 36 7E 32 B2 7B D5 AA CF 01 14 C6 12 EC 13 F2
         :             2D 14 7A 8B 21 58 14 13 4C 46 A3 9A F2 16 95 FF
         :             23
 358    3:           INTEGER 65537
         :           }
         :         }
         :       }
 363  117:     [3] {
 365  115:       SEQUENCE {
 367   33:         SEQUENCE {
 369    3:           OBJECT IDENTIFIER subjectAltName (2 5 29 17)
 374   26:           OCTET STRING, encapsulates {
 376   24:             SEQUENCE {
 378   22:               [1] 'end.entity@example.com'
         :               }
         :             }
         :           }
 402   29:         SEQUENCE {
 404    3:           OBJECT IDENTIFIER subjectKeyIdentifier (2 5 29 14)
 409   22:           OCTET STRING, encapsulates {
 411   20:             OCTET STRING
         :               17 7B 92 30 FF 44 D6 66 E1 90 10 22 6C 16 4F C0
         :               8E 41 DD 6D
         :             }
         :           }
 433   31:         SEQUENCE {
 435    3:           OBJECT IDENTIFIER
         :             authorityKeyIdentifier (2 5 29 35)
 440   24:           OCTET STRING, encapsulates {
 442   22:             SEQUENCE {
 444   20:               [0]
         :                 08 68 AF 85 33 C8 39 4A 7A F8 82 93 8E 70 6A
         :                 4A 20 84 2C 32
         :               }
         :             }
         :           }
 466   14:         SEQUENCE {
 468    3:           OBJECT IDENTIFIER keyUsage (2 5 29 15)
 473    1:           BOOLEAN TRUE
 476    4:           OCTET STRING, encapsulates {
 478    2:             BIT STRING 6 unused bits
         :               '11'B

         :             }
         :           }
         :         }
         :       }
         :     }
 482   13:   SEQUENCE {
 484    9:     OBJECT IDENTIFIER
         :         sha1withRSAEncryption (1 2 840 113549 1 1 5)
 495    0:     NULL
         :     }
 497  129:   BIT STRING
         :     00 20 28 34 5B 68 32 01 BB 0A 36 0E AD 71 C5 95
         :     1A E1 04 CF AE AD C7 62 14 A4 1B 36 31 C0 E2 0C
         :     3D D9 1E C0 00 DC 10 A0 BA 85 6F 41 CB 62 7A B7
         :     4C 63 81 26 5E D2 80 45 5E 33 E7 70 45 3B 39 3B
         :     26 4A 9C 3B F2 26 36 69 08 79 BB FB 96 43 77 4B
         :     61 8B A1 AB 91 64 E0 F3 37 61 3C 1A A3 A4 C9 8A
         :     B2 BF 73 D4 4D E4 58 E4 62 EA BC 20 74 92 86 0E
         :     CE 84 60 76 E9 73 BB C7 85 D3 91 45 EA 62 5D CD
         :   }
```

---
### **C.3.  End Entity Certificate Using DSA**

이 부록에는 914바이트 버전 3 인증서의 주석이 달린 16진수 덤프가 포함되어 있습니다. 인증서에는 다음 정보가 포함되어 있습니다.

\(a\) 일련번호는 256이다.

\(b\) 인증서는 DSA 및 SHA-1 해시 알고리즘으로 서명됩니다.

\(c\) 발급자의 고유 이름은 cn=Example DSA CA,dc=example,dc=com입니다.

\(d\) 주체의 고유 이름은 cn=DSA End Entity,dc=example,dc=com입니다.

\(e\) 인증서는 2004년 5월 2일에 발행되었으며 2005년 5월 2일에 만료되었습니다.

\(f\) 인증서에는 매개변수가 포함된 1024비트 DSA 공개 키가 포함되어 있습니다.

\(g\) 인증서가 최종 엔터티 인증서\(CA 인증서가 아님\)입니다.

\(h\) 인증서에는 "<http://www.example.com/users/DSAendentity.html\>"이라는 주체 대체 이름과 "<http://www.example.com\>"이라는 발급자 대체 이름이 포함되어 있습니다. - 둘 다 URL입니다.

\(i\) 인증서에는 기관 키 식별자 확장과 정책 OID 2.16.840.1.101.3.2.1.48.9를 지정하는 인증서 정책 확장이 포함됩니다. 그리고

\(j\) 인증서에는 공개 키가 디지털 서명 확인용임을 지정하는 중요한 키 사용 확장이 포함되어 있습니다.

```text
   0  910: SEQUENCE {
   4  846:   SEQUENCE {
   8    3:     [0] {
  10    1:       INTEGER 2
         :       }
  13    2:     INTEGER 256
  17    9:     SEQUENCE {
  19    7:       OBJECT IDENTIFIER dsaWithSha1 (1 2 840 10040 4 3)
         :       }
  28   71:     SEQUENCE {
  30   19:       SET {
  32   17:         SEQUENCE {
  34   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
  46    3:           IA5String 'com'
         :           }
         :         }
  51   23:       SET {
  53   21:         SEQUENCE {
  55   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
  67    7:           IA5String 'example'
         :           }
         :         }
  76   23:       SET {
  78   21:         SEQUENCE {
  80    3:           OBJECT IDENTIFIER commonName (2 5 4 3)
  85   14:           PrintableString 'Example DSA CA'
         :           }
         :         }
         :       }
 101   30:     SEQUENCE {
 103   13:       UTCTime 02/05/2004 16:47:38 GMT
 118   13:       UTCTime 02/05/2005 16:47:38 GMT
         :       }
 133   71:     SEQUENCE {
 135   19:       SET {
 137   17:         SEQUENCE {
 139   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)

 151    3:           IA5String 'com'
         :           }
         :         }
 156   23:       SET {
 158   21:         SEQUENCE {
 160   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
 172    7:           IA5String 'example'
         :           }
         :         }
 181   23:       SET {
 183   21:         SEQUENCE {
 185    3:           OBJECT IDENTIFIER commonName (2 5 4 3)
 190   14:           PrintableString 'DSA End Entity'
         :           }
         :         }
         :       }
 206  439:     SEQUENCE {
 210  300:       SEQUENCE {
 214    7:         OBJECT IDENTIFIER dsa (1 2 840 10040 4 1)
 223  287:         SEQUENCE {
 227  129:           INTEGER
         :             00 B6 8B 0F 94 2B 9A CE A5 25 C6 F2 ED FC FB 95
         :             32 AC 01 12 33 B9 E0 1C AD 90 9B BC 48 54 9E F3
         :             94 77 3C 2C 71 35 55 E6 FE 4F 22 CB D5 D8 3E 89
         :             93 33 4D FC BD 4F 41 64 3E A2 98 70 EC 31 B4 50
         :             DE EB F1 98 28 0A C9 3E 44 B3 FD 22 97 96 83 D0
         :             18 A3 E3 BD 35 5B FF EE A3 21 72 6A 7B 96 DA B9
         :             3F 1E 5A 90 AF 24 D6 20 F0 0D 21 A7 D4 02 B9 1A
         :             FC AC 21 FB 9E 94 9E 4B 42 45 9E 6A B2 48 63 FE
         :             43
 359   21:           INTEGER
         :             00 B2 0D B0 B1 01 DF 0C 66 24 FC 13 92 BA 55 F7
         :             7D 57 74 81 E5
 382  129:           INTEGER
         :             00 9A BF 46 B1 F5 3F 44 3D C9 A5 65 FB 91 C0 8E
         :             47 F1 0A C3 01 47 C2 44 42 36 A9 92 81 DE 57 C5
         :             E0 68 86 58 00 7B 1F F9 9B 77 A1 C5 10 A5 80 91
         :             78 51 51 3C F6 FC FC CC 46 C6 81 78 92 84 3D F4
         :             93 3D 0C 38 7E 1A 5B 99 4E AB 14 64 F6 0C 21 22
         :             4E 28 08 9C 92 B9 66 9F 40 E8 95 F6 D5 31 2A EF
         :             39 A2 62 C7 B2 6D 9E 58 C4 3A A8 11 81 84 6D AF
         :             F8 B4 19 B4 C2 11 AE D0 22 3B AA 20 7F EE 1E 57
         :             18
         :           }
         :         }
 514  132:       BIT STRING, encapsulates {
 518  128:         INTEGER

         :           30 B6 75 F7 7C 20 31 AE 38 BB 7E 0D 2B AB A0 9C
         :           4B DF 20 D5 24 13 3C CD 98 E5 5F 6C B7 C1 BA 4A
         :           BA A9 95 80 53 F0 0D 72 DC 33 37 F4 01 0B F5 04
         :           1F 9D 2E 1F 62 D8 84 3A 9B 25 09 5A 2D C8 46 8E
         :           2B D4 F5 0D 3B C7 2D C6 6C B9 98 C1 25 3A 44 4E
         :           8E CA 95 61 35 7C CE 15 31 5C 23 13 1E A2 05 D1
         :           7A 24 1C CB D3 72 09 90 FF 9B 9D 28 C0 A1 0A EC
         :           46 9F 0D B8 D0 DC D0 18 A6 2B 5E F9 8F B5 95 BE
         :         }
         :       }
 649  202:     [3] {
 652  199:       SEQUENCE {
 655   57:         SEQUENCE {
 657    3:           OBJECT IDENTIFIER subjectAltName (2 5 29 17)
 662   50:           OCTET STRING, encapsulates {
 664   48:             SEQUENCE {
 666   46:               [6]
         :                 'http://www.example.com/users/DSAendentity.'
         :                 'html'
         :               }
         :             }
         :           }
 714   33:         SEQUENCE {
 716    3:           OBJECT IDENTIFIER issuerAltName (2 5 29 18)
 721   26:           OCTET STRING, encapsulates {
 723   24:             SEQUENCE {
 725   22:               [6] 'http://www.example.com'
         :               }
         :             }
         :           }
 749   29:         SEQUENCE {
 751    3:           OBJECT IDENTIFIER subjectKeyIdentifier (2 5 29 14)
 756   22:           OCTET STRING, encapsulates {
 758   20:             OCTET STRING
         :               DD 25 66 96 43 AB 78 11 43 44 FE 95 16 F9 D9 B6
         :               B7 02 66 8D
         :             }
         :           }
 780   31:         SEQUENCE {
 782    3:           OBJECT IDENTIFIER
         :             authorityKeyIdentifier (2 5 29 35)
 787   24:           OCTET STRING, encapsulates {
 789   22:             SEQUENCE {
 791   20:               [0]
         :                 86 CA A5 22 81 62 EF AD 0A 89 BC AD 72 41 2C
         :                 29 49 F4 86 56
         :               }
         :             }

         :           }
 813   23:         SEQUENCE {
 815    3:           OBJECT IDENTIFIER certificatePolicies (2 5 29 32)
 820   16:           OCTET STRING, encapsulates {
 822   14:             SEQUENCE {
 824   12:               SEQUENCE {
 826   10:                 OBJECT IDENTIFIER '2 16 840 1 101 3 2 1 48 9'
         :                 }
         :               }
         :             }
         :           }
 838   14:         SEQUENCE {
 840    3:           OBJECT IDENTIFIER keyUsage (2 5 29 15)
 845    1:           BOOLEAN TRUE
 848    4:           OCTET STRING, encapsulates {
 850    2:             BIT STRING 7 unused bits
         :               '1'B (bit 0)
         :             }
         :           }
         :         }
         :       }
         :     }
 854    9:   SEQUENCE {
 856    7:     OBJECT IDENTIFIER dsaWithSha1 (1 2 840 10040 4 3)
         :     }
 865   47:   BIT STRING, encapsulates {
 868   44:     SEQUENCE {
 870   20:       INTEGER
         :         65 57 07 34 DD DC CA CC 5E F4 02 F4 56 42 2C 5E
         :         E1 B3 3B 80
 892   20:       INTEGER
         :         60 F4 31 17 CA F4 CF FF EE F4 08 A7 D9 B2 61 BE
         :         B1 C3 DA BF
         :       }
         :     }
         :   }
```

---
### **C.4.  Certificate Revocation List**

이 부록에는 두 개의 확장자\(cRLNumber 및 AuthorityKeyIdentifier\)가 있는 버전 2 CRL의 주석이 달린 16진수 덤프가 포함되어 있습니다. CRL은 2005년 2월 5일에 cn=Example CA,dc=example,dc=com에 의해 발행되었습니다. 다음으로 예정된 발행일은 2005년 2월 6일이었습니다. CRL에는 해지된 인증서 하나가 포함되어 있습니다. 일련 번호 18은 keyCompromise로 인해 2004년 11월 19일에 해지되었습니다. CRL 자체는 12번이며 RSA 및 SHA-1로 서명되었습니다.

```text
   0  352: SEQUENCE {
   4  202:   SEQUENCE {
   7    1:     INTEGER 1
  10   13:     SEQUENCE {
  12    9:       OBJECT IDENTIFIER
         :         sha1withRSAEncryption (1 2 840 113549 1 1 5)
  23    0:       NULL
         :       }
  25   67:     SEQUENCE {
  27   19:       SET {
  29   17:         SEQUENCE {
  31   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
  43    3:           IA5String 'com'
         :           }
         :         }
  48   23:       SET {
  50   21:         SEQUENCE {
  52   10:           OBJECT IDENTIFIER
         :             domainComponent (0 9 2342 19200300 100 1 25)
  64    7:           IA5String 'example'
         :           }
         :         }
  73   19:       SET {
  75   17:         SEQUENCE {
  77    3:           OBJECT IDENTIFIER commonName (2 5 4 3)
  82   10:           PrintableString 'Example CA'
         :           }
         :         }
         :       }
  94   13:     UTCTime 05/02/2005 12:00:00 GMT
 109   13:     UTCTime 06/02/2005 12:00:00 GMT
 124   34:     SEQUENCE {
 126   32:       SEQUENCE {
 128    1:         INTEGER 18
 131   13:         UTCTime 19/11/2004 15:57:03 GMT
 146   12:         SEQUENCE {
 148   10:           SEQUENCE {
 150    3:             OBJECT IDENTIFIER cRLReason (2 5 29 21)
 155    3:             OCTET STRING, encapsulates {
 157    1:               ENUMERATED 1
         :               }
         :             }
         :           }
         :         }
         :       }
 160   47:     [0] {
 162   45:       SEQUENCE {

 164   31:         SEQUENCE {
 166    3:           OBJECT IDENTIFIER
         :             authorityKeyIdentifier (2 5 29 35)
 171   24:           OCTET STRING, encapsulates {
 173   22:             SEQUENCE {
 175   20:               [0]
         :                 08 68 AF 85 33 C8 39 4A 7A F8 82 93 8E 70 6A
         :                 4A 20 84 2C 32
         :               }
         :             }
         :           }
 197   10:         SEQUENCE {
 199    3:           OBJECT IDENTIFIER cRLNumber (2 5 29 20)
 204    3:           OCTET STRING, encapsulates {
 206    1:             INTEGER 12
         :             }
         :           }
         :         }
         :       }
         :     }
 209   13:   SEQUENCE {
 211    9:     OBJECT IDENTIFIER
         :         sha1withRSAEncryption (1 2 840 113549 1 1 5)
 222    0:     NULL
         :     }
 224  129:   BIT STRING
         :     22 DC 18 7D F7 08 CE CC 75 D0 D0 6A 9B AD 10 F4
         :     76 23 B4 81 6E B5 6D BE 0E FB 15 14 6C C8 17 6D
         :     1F EE 90 17 A2 6F 60 E4 BD AA 8C 55 DE 8E 84 6F
         :     92 F8 9F 10 12 27 AF 4A D4 2F 85 E2 36 44 7D AA
         :     A3 4C 25 38 15 FF 00 FD 3E 7E EE 3D 26 12 EB D8
         :     E7 2B 62 E2 2B C3 46 80 EF 78 82 D1 15 C6 D0 9C
         :     72 6A CB CE 7A ED 67 99 8B 6E 70 81 7D 43 42 74
         :     C1 A6 AF C1 55 17 A2 33 4C D6 06 98 2B A4 FC 2E
         :   }
```

---
# **Authors' Addresses**

David Cooper National Institute of Standards and Technology 100 Bureau Drive, Mail Stop 8930 Gaithersburg, MD 20899-8930 USA 이메일: david.cooper@nist.gov

```text
   Stefan Santesson
   Microsoft
   One Microsoft Way
   Redmond, WA 98052
   USA
   EMail: stefans@microsoft.com

   Stephen Farrell
   Distributed Systems Group
   Computer Science Department
   Trinity College Dublin
   Ireland
   EMail: stephen.farrell@cs.tcd.ie

   Sharon Boeyen
   Entrust
   1000 Innovation Drive
   Ottawa, Ontario
   Canada K2K 3E7
   EMail: sharon.boeyen@entrust.com

   Russell Housley
   Vigil Security, LLC
   918 Spring Knoll Drive
   Herndon, VA 20170
   USA
   EMail: housley@vigilsec.com
```

Tim Polk National Institute of Standards and Technology 100 Bureau Drive, Mail Stop 8930 Gaithersburg, MD 20899-8930 USA 이메일: wpolk@nist.gov

---
# **Full Copyright Statement**

저작권\(C\) IETF 트러스트\(2008\).

이 문서에는 BCP 78에 포함된 권리, 라이선스 및 제한 사항이 적용되며, 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 그가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회, IETF 트러스트 및 인터넷 엔지니어링 태스크 포스는 모든 것을 부인합니다. 여기에 있는 정보의 사용이 상품성이나 특정 목적에의 적합성에 대한 묵시적인 보증이나 권리를 침해하지 않는다는 보증을 포함하되 이에 국한되지 않는 명시적 또는 묵시적 보증.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현이나 사용과 관련이 있다고 주장될 수 있는 지적 재산권 또는 기타 권리의 유효성이나 범위, 그러한 권리에 따른 라이선스가 적용되거나 적용되지 않을 수 있는 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 확인하기 위해 독립적인 노력을 했다는 것을 나타내지도 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 확인할 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이센스에 대한 보증, 또는 이 사양의 구현자 또는 사용자가 해당 독점적 권리 사용에 대한 일반 라이센스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. IETF 온라인 IPR 저장소\(http://www.ietf.org/ipr\)에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술에 적용될 수 있는 모든 저작권, 특허, 특허 출원 또는 기타 독점권에 관심을 갖도록 관심 있는 당사자를 초대합니다. IETF\(ietf-ipr@ietf.org\)에 해당 정보를 보내주십시오.


```text
Internet Engineering Task Force (IETF)                          M. Jones
Request for Comments: 7515                                     Microsoft
Category: Standards Track                                     J. Bradley
ISSN: 2070-1721                                            Ping Identity
                                                             N. Sakimura
                                                                     NRI
                                                                May 2015

                        JSON Web Signature (JWS)
```

---
# **Abstract**

JSON 웹 서명\(JWS\)은 JSON 기반 데이터 구조를 사용하여 디지털 서명 또는 MAC\(Message Authentication Codes\)으로 보안된 콘텐츠를 나타냅니다. 이 사양과 함께 사용할 암호화 알고리즘 및 식별자는 별도의 JSON 웹 알고리즘\(JWA\) 사양과 해당 사양에서 정의한 IANA 레지스트리에 설명되어 있습니다. 관련 암호화 기능은 별도의 JSON 웹 암호화\(JWE\) 사양에 설명되어 있습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 사항, 이 문서에 대한 피드백을 제공하는 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7515에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2015 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................4
      1.1. Notational Conventions .....................................4
   2. Terminology .....................................................5
   3. JSON Web Signature (JWS) Overview ...............................7
      3.1. JWS Compact Serialization Overview .........................7
      3.2. JWS JSON Serialization Overview ............................8
      3.3. Example JWS ................................................8
   4. JOSE Header .....................................................9
      4.1. Registered Header Parameter Names .........................10
           4.1.1. "alg" (Algorithm) Header Parameter .................10
           4.1.2. "jku" (JWK Set URL) Header Parameter ...............10
           4.1.3. "jwk" (JSON Web Key) Header Parameter ..............11
           4.1.4. "kid" (Key ID) Header Parameter ....................11
           4.1.5. "x5u" (X.509 URL) Header Parameter .................11
           4.1.6. "x5c" (X.509 Certificate Chain) Header Parameter ...11
           4.1.7. "x5t" (X.509 Certificate SHA-1 Thumbprint)
                  Header Parameter ...................................12
           4.1.8. "x5t#S256" (X.509 Certificate SHA-256
                  Thumbprint) Header Parameter .......................12
           4.1.9. "typ" (Type) Header Parameter ......................12
           4.1.10. "cty" (Content Type) Header Parameter .............13
           4.1.11. "crit" (Critical) Header Parameter ................14
      4.2. Public Header Parameter Names .............................14
      4.3. Private Header Parameter Names ............................14
   5. Producing and Consuming JWSs ...................................15
      5.1. Message Signature or MAC Computation ......................15
      5.2. Message Signature or MAC Validation .......................16
      5.3. String Comparison Rules ...................................17
   6. Key Identification .............................................18
   7. Serializations .................................................19
      7.1. JWS Compact Serialization .................................19
      7.2. JWS JSON Serialization ....................................19
           7.2.1. General JWS JSON Serialization Syntax ..............20
           7.2.2. Flattened JWS JSON Serialization Syntax ............21
   8. TLS Requirements ...............................................22
   9. IANA Considerations ............................................22
      9.1. JSON Web Signature and Encryption Header
           Parameters Registry .......................................23
           9.1.1. Registration Template ..............................23
           9.1.2. Initial Registry Contents ..........................24
      9.2. Media Type Registration ...................................26
           9.2.1. Registry Contents ..................................26
   10. Security Considerations .......................................27
      10.1. Key Entropy and Random Values ............................27
      10.2. Key Protection ...........................................28
      10.3. Key Origin Authentication ................................28
      10.4. Cryptographic Agility ....................................28
      10.5. Differences between Digital Signatures and MACs ..........28
      10.6. Algorithm Validation .....................................29
      10.7. Algorithm Protection .....................................29
      10.8. Chosen Plaintext Attacks .................................30
      10.9. Timing Attacks ...........................................30
      10.10. Replay Protection .......................................30
      10.11. SHA-1 Certificate Thumbprints ...........................30
      10.12. JSON Security Considerations ............................31
      10.13. Unicode Comparison Security Considerations ..............31
   11. References ....................................................32
      11.1. Normative References .....................................32
      11.2. Informative References ...................................34
   Appendix A.  JWS Examples .........................................36
     A.1.  Example JWS Using HMAC SHA-256 ............................36
       A.1.1.  Encoding ..............................................36
       A.1.2.  Validating ............................................38
     A.2.  Example JWS Using RSASSA-PKCS1-v1_5 SHA-256 ...............38
       A.2.1.  Encoding ..............................................38
       A.2.2.  Validating ............................................42
     A.3.  Example JWS Using ECDSA P-256 SHA-256 .....................42
       A.3.1.  Encoding ..............................................42
       A.3.2.  Validating ............................................44
     A.4.  Example JWS Using ECDSA P-521 SHA-512 .....................45
       A.4.1.  Encoding ..............................................45
       A.4.2.  Validating ............................................47
     A.5.  Example Unsecured JWS .....................................47
     A.6.  Example JWS Using General JWS JSON Serialization ..........48
       A.6.1.  JWS Per-Signature Protected Headers ...................48
       A.6.2.  JWS Per-Signature Unprotected Headers .................49
       A.6.3.  Complete JOSE Header Values ...........................49
       A.6.4.  Complete JWS JSON Serialization Representation ........50
     A.7.  Example JWS Using Flattened JWS JSON Serialization ........51
   Appendix B.  "x5c" (X.509 Certificate Chain) Example ..............52
   Appendix C.  Notes on Implementing base64url Encoding without
                Padding ..............................................54
   Appendix D.  Notes on Key Selection ...............................55
   Appendix E.  Negative Test Case for "crit" Header Parameter .......57
   Appendix F.  Detached Content .....................................57
   Acknowledgements ..................................................58
   Authors' Addresses ................................................58
```

---
## **1.  Introduction**

JSON 웹 서명\(JWS\)은 JSON 기반 \[RFC7159\] 데이터 구조를 사용하여 디지털 서명 또는 MAC\(메시지 인증 코드\)으로 보안된 콘텐츠를 나타냅니다. JWS 암호화 메커니즘은 임의의 옥텟 시퀀스에 대한 무결성 보호를 제공합니다. 디지털 서명과 MAC의 차이점에 대한 논의는 섹션 10.5를 참조하십시오.

JWS에 대한 두 가지 밀접하게 관련된 직렬화가 정의됩니다. JWS Compact Serialization은 HTTP Authorization 헤더 및 URI 쿼리 매개변수와 같은 공간 제약이 있는 환경을 위한 컴팩트하고 URL이 안전한 표현입니다. JWS JSON Serialization은 JWS를 JSON 객체로 표현하고 여러 서명 및/또는 MAC을 동일한 콘텐츠에 적용할 수 있도록 합니다. 둘 다 동일한 암호화 기반을 공유합니다.

이 사양과 함께 사용할 암호화 알고리즘 및 식별자는 별도의 JSON 웹 알고리즘\(JWA\) \[JWA\] 사양 및 해당 사양에서 정의한 IANA 레지스트리에 설명되어 있습니다. 관련 암호화 기능은 별도의 JSON 웹 암호화\(JWE\) \[JWE\] 사양에 설명되어 있습니다.

이 사양에 정의된 이름은 결과 표현을 간결하게 하는 것이 핵심 목표이기 때문에 짧습니다.

---
### **1.1.  Notational Conventions**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", "OPTIONAL"은 "RFC에서 요구 사항 수준을 나타내는 데 사용되는 핵심 단어"\[RFC2119\]에 설명된 대로 해석해야 합니다. 이 해석은 용어가 모두 대문자로 나타나는 경우에만 적용해야 합니다.

BASE64URL\(OCTETS\)는 섹션 2에 따른 OCTETS의 base64url 인코딩을 나타냅니다.

UTF8\(STRING\)은 STRING의 UTF-8 \[RFC3629\] 표현의 옥텟을 나타냅니다. 여기서 STRING은 0개 이상의 유니코드 \[UNICODE\] 문자 시퀀스입니다.

ASCII\(STRING\)은 STRING의 ASCII \[RFC20\] 표현의 옥텟을 나타냅니다. 여기서 STRING은 0개 이상의 ASCII 문자 시퀀스입니다.

두 값 A와 B의 연결은 A || B로 표시합니다.

---
## **2.  Terminology**

이러한 용어는 이 사양에 의해 정의됩니다.

JSON 웹 서명\(JWS\) - 디지털 서명 또는 MAC 처리된 메시지를 나타내는 데이터 구조입니다.

JOSE 헤더 - 암호화 작업과 사용된 매개변수를 설명하는 매개변수를 포함하는 JSON 객체. JOSE\(JSON 객체 서명 및 암호화\) 헤더는 헤더 매개변수 세트로 구성됩니다.

JWS 페이로드 - 보안할 옥텟 시퀀스 -- 일명 메시지. 페이로드는 임의의 옥텟 시퀀스를 포함할 수 있습니다.

JWS 서명 - JWS 보호 헤더와 JWS 페이로드에 대한 디지털 서명 또는 MAC입니다.

헤더 매개변수 - JOSE 헤더의 구성원인 이름/값 쌍입니다.

JWS 보호 헤더 - JWS 서명 디지털 서명 또는 MAC 작업으로 무결성이 보호되는 헤더 매개변수를 포함하는 JSON 객체입니다. JWS Compact Serialization의 경우 전체 JOSE 헤더를 포함합니다. JWS JSON Serialization의 경우 JOSE 헤더의 한 구성 요소입니다.

JWS 보호되지 않은 헤더 - 무결성 보호되지 않은 헤더 매개변수를 포함하는 JSON 객체입니다. 이는 JWS JSON 직렬화를 사용할 때만 존재할 수 있습니다.

Base64url 인코딩 - RFC 4648 \[RFC4648\]의 섹션 5에 정의된 URL 및 파일 이름 안전 문자 집합을 사용하는 Base64 인코딩으로, 모든 후행 '=' 문자는 생략\(섹션 3.2에서 허용\)하고 줄 바꿈, 공백 또는 기타 추가 문자는 포함하지 않습니다. 빈 옥텟 시퀀스의 base64url 인코딩은 빈 문자열입니다. \(패딩 없이 base64url 인코딩을 구현하는 방법에 대한 참고 사항은 부록 C를 참조하세요.\)

JWS 서명 입력 - 디지털 서명 또는 MAC 계산에 대한 입력. 값은 ASCII\(BASE64URL\(UTF8\(JWS 보호 헤더\)\) || '.' || BASE64URL\(JWS 페이로드\)\)입니다.

JWS 컴팩트 직렬화 - JWS를 컴팩트하고 URL에 안전한 문자열로 표현한 것입니다.

JWS JSON 직렬화 - JSON 객체로서의 JWS 표현. JWS Compact Serialization과 달리 JWS JSON 직렬화는 여러 디지털 서명 및/또는 MAC을 동일한 콘텐츠에 적용할 수 있도록 합니다. 이 표현은 컴팩트함이나 URL 안전에 최적화되지 않았습니다.

보안되지 않은 JWS - 무결성 보호를 제공하지 않는 JWS. 보안되지 않은 JWS는 "alg" 값 "none"을 사용합니다.

충돌 방지 이름 - 다른 이름과 충돌할 가능성이 매우 낮은 방식으로 이름을 할당할 수 있는 네임스페이스의 이름입니다. 충돌 방지 네임스페이스의 예로는 도메인 이름, ITU-T X.660 및 X.670 권장 사항 시리즈에 정의된 개체 식별자\(OID\), Universally Unique IDentifiers\(UUID\)\[RFC4122\]가 있습니다. 관리적으로 위임된 네임스페이스를 사용할 때 이름 정의자는 이름을 정의하는 데 사용하는 네임스페이스 부분을 제어할 수 있도록 합리적인 예방 조치를 취해야 합니다.

StringOrURI - JSON 문자열 값, 임의의 문자열 값을 사용할 수 있지만 ":" 문자가 포함된 값은 URI여야 한다는 추가 요구 사항이 있습니다 \[RFC3986\]. StringOrURI 값은 변환이나 정규화가 적용되지 않은 대소문자 구분 문자열로 비교됩니다.

"JSON 웹 암호화\(JWE\)", "JWE 컴팩트 직렬화" 및 "JWE JSON 직렬화"라는 용어는 JWE 사양\[JWE\]에 의해 정의됩니다.

"디지털 서명" 및 "메시지 인증 코드\(MAC\)"라는 용어는 "인터넷 보안 용어집, 버전 2"\[RFC4949\]에 정의되어 있습니다.

---
## **3.  JSON Web Signature (JWS) Overview**

JWS는 JSON 데이터 구조와 base64url 인코딩을 사용하여 디지털 서명 또는 MAC 처리된 콘텐츠를 나타냅니다. 이러한 JSON 데이터 구조는 RFC 7159 \[RFC7159\]의 섹션 2에 따라 JSON 값이나 구조적 문자 앞이나 뒤에 공백 및/또는 줄 바꿈을 포함할 수 있습니다. JWS는 다음과 같은 논리 값을 나타냅니다\(각각은 섹션 2에서 정의됨\):

```text
   o  JOSE Header
   o  JWS Payload
   o  JWS Signature
```

JWS의 경우 JOSE 헤더 멤버는 다음 값의 멤버의 합집합입니다\(각각은 섹션 2에서 정의됨\).

```text
   o  JWS Protected Header
   o  JWS Unprotected Header
```

이 문서는 JWS에 대한 두 가지 직렬화를 정의합니다. JWS Compact Serialization이라는 컴팩트하고 URL에 안전한 직렬화와 JWS JSON Serialization이라는 JSON 직렬화입니다. 두 직렬화 모두에서 JWS Protected Header, JWS Payload 및 JWS Signature는 base64url로 인코딩됩니다. JSON은 임의의 옥텟 시퀀스를 직접 표현할 방법이 없기 때문입니다.

---
### **3.1.  JWS Compact Serialization Overview**

JWS Compact Serialization에서는 JWS Unprotected Header가 사용되지 않습니다. 이 경우 JOSE Header와 JWS Protected Header는 동일합니다.

JWS Compact Serialization에서 JWS는 다음과 같은 연결로 표현됩니다.

```text
      BASE64URL(UTF8(JWS Protected Header)) || '.' ||
      BASE64URL(JWS Payload) || '.' ||
      BASE64URL(JWS Signature)
```

JWS Compact Serialization에 대한 자세한 내용은 섹션 7.1을 참조하세요.

---
### **3.2.  JWS JSON Serialization Overview**

JWS JSON 직렬화에서 JWS 보호 헤더와 JWS 보호되지 않은 헤더 중 하나 또는 둘 다 반드시 존재해야 합니다. 이 경우 JOSE 헤더의 멤버는 존재하는 JWS 보호 헤더와 JWS 보호되지 않은 헤더 값의 멤버의 합집합입니다.

JWS JSON 직렬화에서 JWS는 다음 네 가지 멤버 중 일부 또는 전부를 포함하는 JSON 객체로 표현됩니다.

- "protected", BASE64URL\(UTF8\(JWS Protected Header\)\) 값
- "header", JWS Unprotected Header 값
- "payload", BASE64URL\(JWS Payload\) 값
- "signature", BASE64URL\(JWS Signature\) 값

세 개의 base64url 인코딩된 결과 문자열과 JWS Unprotected Header 값은 JSON 객체 내의 멤버로 표현됩니다. 이러한 값 중 일부를 포함하는 것은 선택 사항입니다. JWS JSON 직렬화는 하나가 아닌 여러 개의 서명 및/또는 MAC 값을 표현할 수도 있습니다. JWS JSON 직렬화에 대한 자세한 내용은 섹션 7.2를 참조하십시오.

---
### **3.3.  Example JWS**

이 섹션에서는 JWS의 예를 제공합니다. 해당 계산은 부록 A.1에 더 자세히 설명되어 있으며, 여기에는 사용된 JSON 값을 나타내는 정확한 옥텟 시퀀스와 사용된 키 값을 지정하는 것도 포함됩니다.

다음 예제 JWS 보호 헤더는 인코딩된 객체가 JSON 웹 토큰\[JWT\]이고 JWS 보호 헤더와 JWS 페이로드가 HMAC SHA-256\[RFC2104\] \[SHS\] 알고리즘을 사용하여 보안된다고 선언합니다.

```text
     {"typ":"JWT",
      "alg":"HS256"}
```

이 JWS 보호 헤더를 BASE64URL\(UTF8\(JWS 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
```

다음 JSON 객체의 UTF-8 표현은 JWS 페이로드로 사용됩니다. \(페이로드는 어떤 콘텐츠일 수 있으며 JSON 객체의 표현일 필요는 없습니다.\)

```text
     {"iss":"joe",
      "exp":1300819380,
      "http://example.com/is_root":true}
```

이 JWS 페이로드를 BASE64URL\(JWS 페이로드\)로 인코딩하면 다음 값이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
```

부록 A.1에 지정된 키와 base64url 인코딩 결과를 사용하여 HMAC SHA-256 알고리즘을 사용하여 JWS 서명 입력 ASCII\(BASE64URL\(UTF8\(JWS Protected Header\)\) || '.' || BASE64URL\(JWS Payload\)\)의 HMAC을 계산하면 이 BASE64URL\(JWS Signature\) 값이 생성됩니다.

```text
     dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
```

Header.Payload.Signature 순서로 이러한 값을 연결하고 각 부분 사이에 마침표\(.\)를 사용하면 JWS Compact Serialization을 사용하여 다음과 같은 완전한 JWS 표현이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
     .
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
     .
     dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
```

추가 예제는 부록 A를 참조하세요. 여기에는 섹션 A.6 및 A.7에서 JWS JSON 직렬화를 사용한 예제가 포함됩니다.

---
## **4.  JOSE Header**

JWS의 경우 JOSE 헤더를 나타내는 JSON 객체의 멤버는 JWS 보호 헤더와 JWS 페이로드에 적용된 디지털 서명 또는 MAC과 선택적으로 JWS의 추가 속성을 설명합니다. JOSE 헤더 내의 헤더 매개변수 이름은 고유해야 합니다. JWS 파서는 중복된 헤더 매개변수 이름이 있는 JWS를 거부하거나 ECMAScript 5.1 \[ECMAScript\]의 섹션 15.12\("JSON 객체"\)에 지정된 대로 어휘적으로 마지막 중복된 멤버 이름만 반환하는 JSON 파서를 사용해야 합니다.

구현은 이 사양에서 정의한 특정 헤더 매개변수를 이해해야 하며, "반드시 이해해야 함"으로 지정되어 있으며 이 사양에서 정의한 방식으로 처리해야 합니다. 이 사양에서 정의한 다른 모든 헤더 매개변수

이렇게 지정되지 않은 사양은 이해되지 않을 경우 무시해야 합니다. 섹션 4.1.11에 따라 중요한 헤더 매개변수로 나열되지 않는 한, 이 사양에서 정의되지 않은 모든 헤더 매개변수는 이해되지 않을 경우 무시해야 합니다.

헤더 매개변수 이름에는 등록된 헤더 매개변수 이름, 공개 헤더 매개변수 이름, 개인 헤더 매개변수 이름의 세 가지 클래스가 있습니다.

---
### **4.1.  Registered Header Parameter Names**

JWS에서 사용되는 다음 헤더 매개변수 이름은 섹션 9.1에 의해 설정된 IANA "JSON 웹 서명 및 암호화 헤더 매개변수" 레지스트리에 등록되어 있으며, 의미는 아래 하위 섹션에 정의된 대로입니다.

공통 레지스트리에서 알 수 있듯이 JWS와 JWE는 공통 헤더 매개변수 공간을 공유합니다. 매개변수가 두 사양에서 모두 사용되는 경우 해당 사양 간에 사용이 호환되어야 합니다.

---
#### **4.1.1.  "alg" (Algorithm) Header Parameter**

"alg"\(알고리즘\) 헤더 매개변수는 JWS를 보호하는 데 사용된 암호화 알고리즘을 식별합니다. "alg" 값이 지원되는 알고리즘을 나타내지 않거나 콘텐츠에 디지털 서명하거나 MAC한 당사자와 관련된 해당 알고리즘에 사용할 키가 없는 경우 JWS 서명 값은 유효하지 않습니다. "alg" 값은 \[JWA\]에서 설정한 IANA "JSON 웹 서명 및 암호화 알고리즘" 레지스트리에 등록되거나 충돌 방지 이름이 포함된 값이어야 합니다. "alg" 값은 StringOrURI 값이 포함된 대소문자 구분 ASCII 문자열입니다. 이 헤더 매개변수는 반드시 존재해야 하며 구현에서 이해하고 처리해야 합니다.

이 용도에 대해 정의된 "alg" 값 목록은 \[JWA\]가 설정한 IANA "JSON 웹 서명 및 암호화 알고리즘" 레지스트리에서 찾을 수 있습니다. 이 레지스트리의 초기 내용은 \[JWA\]의 섹션 3.1에 정의된 값입니다.

---
#### **4.1.2.  "jku" (JWK Set URL) Header Parameter**

"jku"\(JWK Set URL\) 헤더 매개변수는 JSON으로 인코딩된 공개 키 세트에 대한 리소스를 참조하는 URI\[RFC3986\]이며, 그 중 하나는 JWS에 디지털 서명하는 데 사용된 키에 해당합니다. 키는 JWK Set\[JWK\]으로 인코딩되어야 합니다. 리소스를 획득하는 데 사용된 프로토콜은 무결성 보호를 제공해야 합니다. JWK Set을 검색하기 위한 HTTP GET 요청은 전송 계층 보안을 사용해야 합니다.

\(TLS\) \[RFC2818\] \[RFC5246\]; 그리고 서버의 ID는 RFC 6125 \[RFC6125\]의 섹션 6에 따라 검증되어야 합니다. 또한 TLS 요구 사항에 대한 섹션 8을 참조하세요. 이 헤더 매개변수의 사용은 선택 사항입니다.

---
#### **4.1.3.  "jwk" (JSON Web Key) Header Parameter**

"jwk"\(JSON 웹 키\) 헤더 매개변수는 JWS에 디지털 서명하는 데 사용되는 키에 해당하는 공개 키입니다. 이 키는 JSON 웹 키\[JWK\]로 표현됩니다. 이 헤더 매개변수의 사용은 선택 사항입니다.

---
#### **4.1.4.  "kid" (Key ID) Header Parameter**

"kid"\(키 ID\) 헤더 매개변수는 JWS를 보호하는 데 사용된 키를 나타내는 힌트입니다. 이 매개변수를 사용하면 발신자가 수신자에게 키 변경을 명시적으로 알릴 수 있습니다. "kid" 값의 구조는 지정되지 않습니다. 값은 대소문자를 구분하는 문자열이어야 합니다. 이 헤더 매개변수를 사용하는 것은 선택 사항입니다.

JWK와 함께 사용할 경우 "kid" 값은 JWK "kid" 매개변수 값과 일치하도록 사용됩니다.

---
#### **4.1.5.  "x5u" (X.509 URL) Header Parameter**

"x5u"\(X.509 URL\) 헤더 매개변수는 JWS에 디지털 서명하는 데 사용된 키에 해당하는 X.509 공개 키 인증서 또는 인증서 체인\[RFC5280\]에 대한 리소스를 참조하는 URI\[RFC3986\]입니다. 식별된 리소스는 RFC 5280\[RFC5280\]을 준수하는 인증서 또는 인증서 체인의 표현을 PEM 인코딩된 형태로 제공해야 하며, 각 인증서는 RFC 4945\[RFC4945\]의 섹션 6.1에 지정된 대로 구분되어야 합니다. JWS에 디지털 서명하는 데 사용된 키에 해당하는 공개 키가 포함된 인증서는 첫 번째 인증서여야 합니다. 그 뒤에 추가 인증서가 올 수 있으며, 이후의 각 인증서는 이전 인증서를 인증하는 데 사용됩니다. 리소스를 획득하는 데 사용된 프로토콜은 무결성 보호를 제공해야 합니다. 인증서를 검색하기 위한 HTTP GET 요청은 TLS\[RFC2818\] \[RFC5246\]를 사용해야 합니다. 그리고 서버의 ID는 RFC 6125 \[RFC6125\]의 섹션 6에 따라 검증되어야 합니다. 또한 TLS 요구 사항에 대한 섹션 8을 참조하세요. 이 헤더 매개변수의 사용은 선택 사항입니다.

---
#### **4.1.6.  "x5c" (X.509 Certificate Chain) Header Parameter**

"x5c"\(X.509 인증서 체인\) 헤더 매개변수에는 JWS에 디지털 서명하는 데 사용된 키에 해당하는 X.509 공개 키 인증서 또는 인증서 체인\[RFC5280\]이 포함되어 있습니다. 인증서 또는 인증서 체인은 JSON 배열로 표현됩니다.

인증서 값 문자열. 배열의 각 문자열은 base64로 인코딩된\(\[RFC4648\]의 섹션 4 -- base64url로 인코딩되지 않음\) DER \[ITU.X690.2008\] PKIX 인증서 값입니다. JWS에 디지털 서명하는 데 사용된 키에 해당하는 공개 키가 포함된 인증서는 첫 번째 인증서여야 합니다. 이후의 인증서는 이전 인증서를 인증하는 데 사용된 인증서가 될 수 있는 추가 인증서가 뒤따를 수 있습니다. 수신자는 RFC 5280 \[RFC5280\]에 따라 인증서 체인을 검증해야 하며 검증 실패가 발생하면 인증서 또는 인증서 체인을 무효로 간주해야 합니다. 이 헤더 매개변수를 사용하는 것은 선택 사항입니다.

"x5c" 값의 예는 부록 B를 참조하세요.

---
#### **4.1.7.  "x5t" (X.509 Certificate SHA-1 Thumbprint) Header Parameter**

"x5t"\(X.509 인증서 SHA-1 지문\) 헤더 매개변수는 JWS에 디지털 서명하는 데 사용된 키에 해당하는 X.509 인증서 \[RFC5280\]의 DER 인코딩의 base64url 인코딩된 SHA-1 지문\(일명 다이제스트\)입니다. 인증서 지문은 때때로 인증서 지문이라고도 합니다. 이 헤더 매개변수의 사용은 선택 사항입니다.

```text
4.1.8.  "x5t#S256" (X.509 Certificate SHA-256 Thumbprint) Header
        Parameter
```

"x5t#S256"\(X.509 인증서 SHA-256 지문\) 헤더 매개변수는 JWS에 디지털 서명하는 데 사용된 키에 해당하는 X.509 인증서 \[RFC5280\]의 DER 인코딩의 base64url 인코딩된 SHA-256 지문\(일명 다이제스트\)입니다. 인증서 지문은 때때로 인증서 지문이라고도 합니다. 이 헤더 매개변수의 사용은 선택 사항입니다.

---
#### **4.1.9.  "typ" (Type) Header Parameter**

"typ"\(유형\) 헤더 매개변수는 JWS 애플리케이션에서 이 완전한 JWS의 미디어 유형\[IANA.MediaTypes\]을 선언하는 데 사용됩니다. 이는 애플리케이션 데이터 구조에 JWS를 포함할 수 있는 여러 종류의 객체가 존재할 수 있는 경우 애플리케이션에서 사용하도록 의도된 것입니다. 애플리케이션은 이 값을 사용하여 존재할 수 있는 다양한 종류의 객체를 구별할 수 있습니다. 일반적으로 객체 종류가 이미 알려져 있는 경우 애플리케이션에서 사용되지 않습니다. 이 매개변수는 JWS 구현에서 무시됩니다. 이 매개변수의 모든 처리가 JWS 애플리케이션에서 수행됩니다. 이 헤더 매개변수의 사용은 선택 사항입니다.

RFC 2045 \[RFC2045\]에 따르면 모든 미디어 유형 값, 하위 유형 값 및 매개변수 이름은 대소문자를 구분하지 않습니다. 그러나 매개변수 값은 특정 매개변수에 대해 달리 지정되지 않는 한 대소문자를 구분합니다.

일반적인 상황에서 메시지를 간결하게 유지하기 위해, 미디어 유형 값에 다른 '/'가 나타나지 않을 경우, 제작자가 "typ" 헤더 매개변수에서 미디어 유형 값의 "application/" 접두사를 생략하는 것이 좋습니다. 미디어 유형 값을 사용하는 수신자는 "application/"이 '/'를 포함하지 않는 모든 "typ" 값에 접두사로 붙은 것처럼 처리해야 합니다. 예를 들어, "type" 값 "example"은 "application/example" 미디어 유형을 나타내는 데 사용해야 하지만, 미디어 유형 "application/example;part="1/2""는 "example;part="1/2""로 줄일 수 없습니다.

"typ" 값 "JOSE"는 애플리케이션에서 JWS Compact Serialization 또는 JWE Compact Serialization을 사용하여 이 객체가 JWS 또는 JWE임을 나타내는 데 사용할 수 있습니다. "typ" 값 "JOSE+JSON"은 애플리케이션에서 JWS JSON Serialization 또는 JWE JSON Serialization을 사용하여 이 객체가 JWS 또는 JWE임을 나타내는 데 사용할 수 있습니다. 다른 유형 값도 애플리케이션에서 사용할 수 있습니다.

---
#### **4.1.10.  "cty" (Content Type) Header Parameter**

"cty"\(콘텐츠 유형\) 헤더 매개변수는 JWS 애플리케이션에서 보안 콘텐츠\(페이로드\)의 미디어 유형\[IANA.MediaTypes\]을 선언하는 데 사용됩니다. 이는 JWS 페이로드에 두 가지 이상의 개체가 존재할 수 있는 경우 애플리케이션에서 사용하도록 의도된 것입니다. 애플리케이션은 이 값을 사용하여 존재할 수 있는 다양한 종류의 개체를 구별할 수 있습니다. 개체 종류가 이미 알려져 있는 경우 애플리케이션에서 일반적으로 사용되지 않습니다. 이 매개변수는 JWS 구현에서 무시됩니다. 이 매개변수의 모든 처리가 JWS 애플리케이션에서 수행됩니다. 이 헤더 매개변수의 사용은 선택 사항입니다.

RFC 2045 \[RFC2045\]에 따르면 모든 미디어 유형 값, 하위 유형 값 및 매개변수 이름은 대소문자를 구분하지 않습니다. 그러나 매개변수 값은 특정 매개변수에 대해 달리 지정되지 않는 한 대소문자를 구분합니다.

일반적인 상황에서 메시지를 간결하게 유지하기 위해, 미디어 유형 값에 다른 '/'가 나타나지 않을 경우, 제작자가 "cty" 헤더 매개변수에서 미디어 유형 값의 "application/" 접두사를 생략하는 것이 좋습니다. 미디어 유형 값을 사용하는 수신자는 "application/"이 '/'를 포함하지 않는 모든 "cty" 값에 접두사로 붙은 것처럼 처리해야 합니다. 예를 들어, "application/example" 미디어 유형을 나타내기 위해 "cty" 값인 "example"을 사용해야 하지만, 미디어 유형 "application/example;part="1/2""는 "example;part="1/2""로 줄일 수 없습니다.

---
#### **4.1.11.  "crit" (Critical) Header Parameter**

"crit"\(중요\) 헤더 매개변수는 이 사양 및/또는 \[JWA\]에 대한 확장이 사용되고 있으며 반드시 이해하고 처리해야 함을 나타냅니다. 값은 해당 확장을 사용하는 JOSE 헤더에 있는 헤더 매개변수 이름을 나열하는 배열입니다. 나열된 확장 헤더 매개변수 중 수신자가 이해하지 못하고 지원하지 않는 것이 있으면 JWS가 유효하지 않습니다. 제작자는 "crit" 목록에 JWS와 함께 사용하기 위해 이 사양 또는 \[JWA\]에서 정의한 헤더 매개변수 이름, 중복 이름 또는 JOSE 헤더 내에서 헤더 매개변수 이름으로 나타나지 않는 이름을 포함해서는 안 됩니다. 제작자는 "crit" 값으로 빈 목록 "\[\]"를 사용해서는 안 됩니다. 수신자는 중요 목록에 JWS와 함께 사용하기 위해 이 사양 또는 \[JWA\]에서 정의한 헤더 매개변수 이름이 포함되어 있거나 사용에 대한 다른 제약 조건이 위반되는 경우 JWS를 유효하지 않은 것으로 간주할 수 있습니다. 이 헤더 매개변수를 사용할 경우 무결성 보호를 받아야 합니다. 따라서 JWS 보호 헤더 내에서만 발생해야 합니다. 이 헤더 매개변수의 사용은 선택 사항입니다. 이 헤더 매개변수는 구현에서 이해하고 처리해야 합니다.

가상의 "exp"\(만료 시간\) 필드와 함께 사용되는 예는 다음과 같습니다.

```text
     {"alg":"ES256",
      "crit":["exp"],
      "exp":1363284000
     }
```

---
### **4.2.  Public Header Parameter Names**

추가 헤더 매개변수 이름은 JWS를 사용하는 사람이 정의할 수 있습니다. 그러나 충돌을 방지하기 위해 모든 새 헤더 매개변수 이름은 섹션 9.1에 의해 설정된 IANA "JSON 웹 서명 및 암호화 헤더 매개변수" 레지스트리에 등록되거나 공개 이름\(충돌 방지 이름이 포함된 값\)이어야 합니다. 각 경우 이름 또는 값의 정의자는 헤더 매개변수 이름을 정의하는 데 사용하는 네임스페이스 부분을 제어하고 있는지 확인하기 위해 합리적인 예방 조치를 취해야 합니다.

새로운 헤더 매개변수는 상호 운용 가능한 JWS가 발생할 수 있으므로 아껴서 도입해야 합니다.

---
### **4.3.  Private Header Parameter Names**

JWS의 생산자와 소비자는 비공개 이름\(등록된 헤더 매개변수 이름\(섹션 4.1\)이 아닌 이름\) 또는 공개 헤더 매개변수 이름을 사용하는 데 동의할 수 있습니다.

\(4.2절\). Public Header Parameter 이름과 달리 Private Header Parameter 이름은 충돌의 위험이 있으므로 주의해서 사용해야 합니다.

---
## **5.  Producing and Consuming JWSs**
---
### **5.1.  Message Signature or MAC Computation**

JWS를 만들려면 다음 단계를 수행합니다. 단계의 입력과 출력 사이에 종속성이 없는 경우 단계의 순서는 중요하지 않습니다.

1. JWS 페이로드로 사용할 콘텐츠를 생성합니다.

1. 인코딩된 페이로드 값 BASE64URL\(JWS 페이로드\)을 계산합니다.

1. JOSE 헤더\(JWS 보호 헤더 및/또는 JWS 보호되지 않은 헤더\)를 구성하는 원하는 헤더 매개변수 세트를 포함하는 JSON 객체를 만듭니다.

1. 인코딩된 헤더 값 BASE64URL\(UTF8\(JWS 보호 헤더\)\)을 계산합니다. JWS 보호 헤더가 없는 경우\(JWS JSON 직렬화를 사용하고 "보호된" 멤버가 없는 경우에만 발생할 수 있음\) 이 값을 빈 문자열로 둡니다.

1. JWS 서명 입력 ASCII\(BASE64URL\(UTF8\(JWS 보호 헤더\)\) || '.' || BASE64URL\(JWS 페이로드\)\)에 사용되는 특정 알고리즘에 대해 정의된 방식으로 JWS 서명을 계산합니다. "alg"\(알고리즘\) 헤더 매개변수는 JOSE 헤더에 있어야 하며, 알고리즘 값은 JWS 서명을 구성하는 데 사용된 알고리즘을 정확하게 나타냅니다.

1. 인코딩된 서명 값 BASE64URL\(JWS Signature\)을 계산합니다.

1. JWS JSON 직렬화를 사용하는 경우 수행되는 각 디지털 서명 또는 MAC 작업에 대해 이 프로세스\(3\~6단계\)를 반복합니다.

1. 원하는 직렬화된 출력을 만듭니다. 이 결과의 JWS Compact Serialization은 BASE64URL\(UTF8\(JWS Protected Header\)\) || '.' || BASE64URL\(JWS Payload\) || '.' || BASE64URL\(JWS Signature\)입니다. JWS JSON Serialization은 섹션 7.2에 설명되어 있습니다.

---
### **5.2.  Message Signature or MAC Validation**

JWS를 검증할 때 다음 단계가 수행됩니다. 단계의 입력과 출력 사이에 종속성이 없는 경우 단계의 순서는 중요하지 않습니다. 나열된 단계 중 하나라도 실패하면 서명 또는 MAC을 검증할 수 없습니다.

여러 JWS 서명 값이 있는 경우 JWS가 수락되기 위해 어떤 JWS 서명 값이 성공적으로 검증되어야 하는지는 애플리케이션에서 결정합니다. 어떤 경우에는 모든 값이 성공적으로 검증되어야 하며, 그렇지 않으면 JWS가 무효한 것으로 간주됩니다. 다른 경우에는 특정 JWS 서명 값만 성공적으로 검증되면 됩니다. 그러나 모든 경우에 적어도 하나의 JWS 서명 값이 성공적으로 검증되어야 하며, 그렇지 않으면 JWS가 무효한 것으로 간주되어야 합니다.

1. JWS 표현을 구문 분석하여 JWS 구성 요소에 대한 직렬화된 값을 추출합니다. JWS Compact Serialization을 사용할 때 이러한 구성 요소는 JWS 보호 헤더, JWS 페이로드 및 JWS 서명의 base64url 인코딩 표현이며, JWS JSON Serialization을 사용할 때 이러한 구성 요소에는 인코딩되지 않은 JWS 보호되지 않은 헤더 값도 포함됩니다. JWS Compact Serialization을 사용할 때 JWS 보호 헤더, JWS 페이로드 및 JWS 서명은 해당 순서로 base64url 인코딩된 값으로 표현되며 각 값은 단일 마침표\('.'\) 문자로 다음 값과 구분되어 정확히 두 개의 구분 마침표 문자가 사용됩니다. JWS JSON Serialization은 섹션 7.2에서 설명합니다.

1. 줄 바꿈, 공백 또는 기타 추가 문자가 사용되지 않았다는 제한 사항에 따라 JWS 보호 헤더의 인코딩된 표현을 Base64url로 디코딩합니다.

1. 결과 옥텟 시퀀스가 RFC 7159 \[RFC7159\]에 따른 완전히 유효한 JSON 개체의 UTF-8 인코딩 표현인지 확인합니다. JWS 보호 헤더가 이 JSON 개체가 되도록 합니다.

1. JWS Compact Serialization을 사용하는 경우 JOSE 헤더를 JWS 보호 헤더로 설정합니다. 그렇지 않은 경우 JWS JSON Serialization을 사용하는 경우 JOSE 헤더를 해당 JWS 보호 헤더와 JWS 보호되지 않은 헤더의 멤버의 합집합으로 설정합니다. 이 모든 멤버는 완전히 유효한 JSON 객체여야 합니다. 이 단계에서 결과 JOSE 헤더에 중복된 헤더 매개변수 이름이 포함되지 않았는지 확인합니다. JWS를 사용하는 경우

- JSON 직렬화, 이 제한에는 동일한 헤더 매개변수 이름이 JOSE 헤더를 구성하는 고유한 JSON 개체 값에도 나타나서는 안 된다는 것이 포함됩니다.

1. 구현이 이 사양, 사용 중인 알고리즘 또는 "crit" 헤더 매개변수 값에 의해 요구되는 모든 필드를 이해하고 처리할 수 있는지 확인하고, 해당 매개변수의 값도 이해되고 지원되는지 확인합니다.

1. 줄 바꿈, 공백 또는 기타 추가 문자가 사용되지 않았다는 제한 사항에 따라 JWS 페이로드의 인코딩된 표현을 Base64url로 디코딩합니다.

1. 줄 바꿈, 공백 또는 기타 추가 문자가 사용되지 않았다는 제한 사항에 따라 JWS 서명의 인코딩된 표현을 Base64url로 디코딩합니다.

1. JWS 서명을 JWS 서명 입력 ASCII\(BASE64URL\(UTF8\(JWS 보호 헤더\)\) || '.' || BASE64URL\(JWS 페이로드\)\)에 대해 알고리즘에 정의된 방식으로 검증합니다. 이는 반드시 존재해야 하는 "alg"\(알고리즘\) 헤더 매개변수의 값으로 정확하게 표현되어야 합니다. 알고리즘 검증에 대한 보안 고려 사항은 섹션 10.6을 참조하세요. 검증이 성공했는지 여부를 기록합니다.

1. JWS JSON 직렬화를 사용하는 경우 표현에 포함된 각 디지털 서명 또는 MAC 값에 대해 이 프로세스\(4\~8단계\)를 반복합니다.

1. 9단계의 검증 중 어느 것도 성공하지 못하면 JWS는 무효로 간주되어야 합니다. 그렇지 않으면 JWS JSON 직렬화의 경우 어떤 검증이 성공했고 실패했는지를 나타내는 결과를 애플리케이션에 반환합니다. JWS Compact 직렬화의 경우 결과는 JWS가 성공적으로 검증되었는지 여부를 나타낼 수 있습니다.

마지막으로, 주어진 컨텍스트에서 어떤 알고리즘을 사용할 수 있는지는 애플리케이션의 결정이라는 점에 유의하십시오. JWS가 성공적으로 검증될 수 있더라도 JWS에서 사용된 알고리즘이 애플리케이션에 수용 가능하지 않으면 JWS를 무효로 간주해야 합니다.

---
### **5.3.  String Comparison Rules**

JWS를 처리하려면 필연적으로 알려진 문자열을 JSON 객체의 멤버 및 값과 비교해야 합니다. 예를 들어, 알고리즘이 무엇인지 확인할 때 유니코드 문자열 "alg"를 JOSE 헤더의 멤버 이름과 비교하여 일치하는 것이 있는지 확인합니다.

헤더 매개변수 이름. 그런 다음 동일한 프로세스를 사용하여 "alg" 헤더 매개변수의 값이 지원되는 알고리즘을 나타내는지 확인합니다.

멤버 이름 비교를 위한 JSON 규칙은 RFC 7159 \[RFC7159\]의 섹션 8.3에 설명되어 있습니다. 수행되는 유일한 문자열 비교 연산은 동등성과 부등성이므로 동일한 규칙을 사용하여 알려진 문자열에 대해 멤버 이름과 멤버 값을 모두 비교할 수 있습니다.

이러한 비교 규칙은 멤버 정의에서 해당 멤버 값에 대해 다른 비교 규칙을 사용해야 한다고 명시적으로 명시한 경우를 제외하고 모든 JSON 문자열 비교에 사용해야 합니다. 이 사양에 정의된 "typ" 및 "cty" 멤버 값만 이러한 비교 규칙을 사용하지 않습니다.

일부 애플리케이션은 대소문자를 구분하지 않는 정보를 대소문자 구분 값에 포함할 수 있습니다\(예: "kid"\(키 ID\) 값의 일부로 DNS 이름을 포함하는 경우\). 이러한 경우 애플리케이션은 대소문자를 구분하지 않는 부분을 나타내는 데 사용할 표준 케이스에 대한 규칙을 정의해야 할 수 있습니다\(예: 소문자로 표시\). 둘 이상의 당사자가 동일한 값을 생성하여 비교할 수 있도록 해야 할 수 있습니다. \(그러나 다른 모든 당사자가 독립적으로 생성된 값과 비교하려고 하지 않고 생성 당사자가 그대로 내보낸 값을 소비하는 경우 생성자가 사용한 케이스는 중요하지 않습니다.\)

또한, 섹션 10.12의 JSON 보안 고려 사항과 섹션 10.13의 유니코드 보안 고려 사항을 참조하세요.

---
## **6.  Key Identification**

JWS 수신자는 디지털 서명 또는 MAC 작업에 사용된 키를 확인할 수 있어야 합니다. 사용된 키는 섹션 4.1에 설명된 헤더 매개변수 방법을 사용하여 식별하거나 이 사양의 범위를 벗어나는 방법을 사용하여 식별할 수 있습니다. 구체적으로 헤더 매개변수 "jku", "jwk", "kid", "x5u", "x5c", "x5t" 및 "x5t#S256"을 사용하여 사용된 키를 식별할 수 있습니다. 이러한 헤더 매개변수는 전달하는 정보가 신뢰 결정에 활용되는 경우 무결성 보호를 받아야 합니다. 그러나 신뢰 결정에 사용된 유일한 정보가 키인 경우 이러한 매개변수는 무결성 보호를 받을 필요가 없습니다. 다른 키가 사용되도록 매개변수를 변경하면 유효성 검사가 실패하기 때문입니다.

제작자는 애플리케이션이 사용된 키를 확인하기 위해 다른 수단이나 규칙을 사용하지 않는 한 헤더 매개변수에 사용된 키를 식별할 수 있는 충분한 정보를 포함해야 합니다. 검증

알고리즘에 키가 필요하고\(모든 알고리즘에 해당, '없음' 제외\) 사용된 키를 확인할 수 없는 경우 서명 또는 MAC이 실패합니다.

공유 대칭 키를 교환하는 방법은 이 사양의 범위를 벗어납니다.

또한, 가능한 키 선택 알고리즘에 대한 참고 사항은 부록 D를 참조하세요.

---
## **7.  Serializations**

JWS는 JWS Compact Serialization 또는 JWS JSON Serialization의 두 가지 직렬화 중 하나를 사용합니다. 이 사양을 사용하는 애플리케이션은 해당 애플리케이션에 사용되는 직렬화 및 직렬화 기능을 지정해야 합니다. 예를 들어, 애플리케이션은 JWS JSON Serialization만 사용하거나, 단일 서명 또는 MAC 값에 대한 JWS JSON Serialization 지원만 사용하거나, 여러 서명 및/또는 MAC 값에 대한 지원을 사용하도록 지정할 수 있습니다. JWS 구현은 지원하도록 설계된 애플리케이션에 필요한 기능만 구현하면 됩니다.

---
### **7.1.  JWS Compact Serialization**

JWS Compact Serialization은 디지털 서명 또는 MAC된 콘텐츠를 압축된 URL 안전 문자열로 나타냅니다. 이 문자열은 다음과 같습니다.

```text
      BASE64URL(UTF8(JWS Protected Header)) || '.' ||
      BASE64URL(JWS Payload) || '.' ||
      BASE64URL(JWS Signature)
```

JWS Compact Serialization은 하나의 서명/MAC만 지원하며 JWS Unprotected Header 값을 나타내는 구문을 제공하지 않습니다.

---
### **7.2.  JWS JSON Serialization**

JWS JSON 직렬화는 디지털 서명 또는 MAC된 콘텐츠를 JSON 객체로 표현합니다. 이 표현은 압축성이나 URL 안전성에 최적화되지 않았습니다.

JWS JSON 직렬화에 대해 두 가지 밀접하게 관련된 구문이 정의되어 있습니다. 하나는 완전히 일반적인 구문으로, 콘텐츠를 두 개 이상의 디지털 서명 및/또는 MAC 작업으로 보호할 수 있고, 다른 하나는 단일 디지털 서명 또는 MAC 사례에 최적화된 일반화된 구문입니다.

---
#### **7.2.1.  General JWS JSON Serialization Syntax**

다음 멤버는 완전히 일반적인 JWS JSON 직렬화 구문에 사용되는 최상위 JSON 객체에서 사용하도록 정의됩니다.

payload - "payload" 멤버는 반드시 존재해야 하며 BASE64URL\(JWS Payload\) 값을 포함해야 합니다.

signatures - "signatures" 멤버 값은 JSON 객체의 배열이어야 합니다. 각 객체는 JWS Payload와 JWS Protected Header에 대한 서명 또는 MAC을 나타냅니다.

다음 멤버는 "signatures" 배열의 요소인 JSON 객체에서 사용하도록 정의됩니다.

protected - "protected" 멤버는 반드시 존재해야 하며 JWS Protected Header 값이 비어 있지 않으면 BASE64URL\(UTF8\(JWS Protected Header\)\) 값을 포함해야 합니다. 그렇지 않으면 반드시 없어야 합니다. 이러한 헤더 매개변수 값은 무결성 보호됩니다.

헤더 - "헤더" 멤버는 반드시 존재해야 하며 JWS 보호되지 않은 헤더 값이 비어 있지 않으면 JWS 보호되지 않은 헤더 값을 포함해야 합니다. 그렇지 않으면 반드시 없어야 합니다. 이 값은 문자열이 아니라 인코딩되지 않은 JSON 객체로 표현됩니다. 이러한 헤더 매개변수 값은 무결성 보호되지 않습니다.

signature - "signature" 멤버는 반드시 존재해야 하며 BASE64URL\(JWS Signature\) 값을 포함해야 합니다.

각 서명/MAC 계산에는 반드시 "protected" 및 "header" 멤버 중 하나 이상이 있어야 "alg" 헤더 매개변수 값이 전달됩니다.

위에 정의된 JSON 객체 둘 다에 추가 멤버가 있을 수 있으며, 이를 발견한 구현에서 이를 이해하지 못하는 경우 반드시 무시해야 합니다.

개별 서명 또는 MAC 값을 생성하거나 검증할 때 사용되는 헤더 매개변수 값은 존재할 수 있는 두 개의 헤더 매개변수 값 집합의 합집합입니다. \(1\) 서명/MAC 배열 요소의 "보호된" 멤버에 표현된 JWS 보호된 헤더, \(2\) "헤더"에 있는 JWS 보호되지 않은 헤더

signature/MAC 배열 요소의 멤버입니다. 이러한 헤더 매개변수 세트의 합집합은 JOSE 헤더를 구성합니다. 두 위치의 헤더 매개변수 이름은 분리되어야 합니다.

각 JWS 서명 값은 JWS Compact Serialization과 동일한 방식으로 해당 JOSE 헤더 값의 매개변수를 사용하여 계산됩니다. 이는 "signatures" 배열에 표현된 각 JWS 서명 값이 JWS Compact Serialization에서 동일한 매개변수에 대해 계산된 값과 동일하다는 바람직한 속성을 가지고 있습니다. 단, 해당 서명/MAC 계산에 대한 JWS 보호 헤더 값\(무결성 보호 헤더 매개변수 값을 나타냄\)이 JWS Compact Serialization에서 사용된 값과 일치해야 합니다.

요약하자면, 일반적인 JWS JSON 직렬화를 사용하는 JWS의 구문은 다음과 같습니다.

```text
     {
      "payload":"<payload contents>",
      "signatures":[
       {"protected":"<integrity-protected header 1 contents>",
        "header":<non-integrity-protected header 1 contents>,
        "signature":"<signature 1 contents>"},
       ...
       {"protected":"<integrity-protected header N contents>",
        "header":<non-integrity-protected header N contents>,
        "signature":"<signature N contents>"}]
     }
```

일반적인 JWS JSON 직렬화 구문을 사용하는 JWS의 예는 부록 A.6을 참조하세요.

---
#### **7.2.2.  Flattened JWS JSON Serialization Syntax**

평면화된 JWS JSON 직렬화 구문은 일반 구문을 기반으로 하지만, 단일 디지털 서명/MAC 케이스에 최적화하여 평면화합니다. "signatures" 멤버를 제거하고 대신 "signatures" 배열에서 사용하도록 정의된 멤버\("protected", "header" 및 "signature" 멤버\)를 최상위 JSON 객체\("payload" 멤버와 동일한 수준\)에 배치하여 평면화합니다.

이 구문을 사용할 때는 "signatures" 멤버가 없어야 합니다. 이 구문 차이 외에, flattened 구문을 사용하는 JWS JSON Serialization 객체는 일반 구문을 사용하는 객체와 동일하게 처리됩니다.

요약하자면, 평면화된 JWS JSON 직렬화를 사용하는 JWS의 구문은 다음과 같습니다.

```text
     {
      "payload":"<payload contents>",
      "protected":"<integrity-protected header contents>",
      "header":<non-integrity-protected header contents>,
      "signature":"<signature contents>"
     }
```

평면화된 JWS JSON 직렬화 구문을 사용하는 JWS의 예는 부록 A.7을 참조하세요.

---
## **8.  TLS Requirements**

"jku" 및/또는 "x5u" 헤더 매개변수를 지원하는 구현은 TLS를 지원해야 합니다. 구현해야 할 TLS 버전은 시간이 지남에 따라 달라지며 구현 당시의 광범위한 배포 및 알려진 보안 취약성에 따라 달라집니다. 이 글을 쓰는 시점에서 TLS 버전 1.2\[RFC5246\]가 최신 버전입니다.

정보 공개 및 변조로부터 보호하려면 기밀성 보호는 기밀성 및 무결성 보호를 제공하는 암호 그룹이 있는 TLS를 사용하여 적용해야 합니다. 현재 사용에 적합하다고 간주되는 암호 그룹에 대한 지침은 RFC 6176 \[RFC6176\]을 포함하여 IETF TLS 작업 그룹의 최신 간행물을 참조하십시오. 또한 TLS를 사용하여 소프트웨어 및 서비스의 보안을 개선하기 위한 권장 사항은 "전송 계층 보안\(TLS\) 및 데이터그램 전송 계층 보안\(DTLS\)의 안전한 사용을 위한 권장 사항"\[RFC7525\]을 참조하십시오.

TLS를 사용할 때마다 TLS 서버 인증서에 인코딩된 서비스 공급자의 신원은 RFC 6125 \[RFC6125\]의 섹션 6에 설명된 절차를 사용하여 검증되어야 합니다.

---
## **9.  IANA Considerations**

다음 등록 절차는 본 명세서에 의해 설정된 모든 레지스트리에 사용됩니다.

값은 jose-reg-review@ietf.org 메일링 목록에서 3주간의 검토 기간 후 사양 요구 사항 \[RFC5226\] 기준으로 등록되며, 한 명 이상의 지정 전문가의 조언에 따라 등록됩니다. 그러나 발행 전에 값을 할당할 수 있도록 지정 전문가는 해당 사양이 발행될 것이라고 만족하면 등록을 승인할 수 있습니다.

검토를 위해 메일링 목록에 보낸 등록 요청은 적절한 제목을 사용해야 합니다\(예: "헤더 매개변수 등록 요청: 예"\).

검토 기간 내에 지정된 전문가는 등록 요청을 승인하거나 거부하고 이 결정을 검토 목록과 IANA에 전달합니다. 거부에는 설명과 해당되는 경우 요청을 성공적으로 만드는 방법에 대한 제안이 포함되어야 합니다. 21일 이상 결정되지 않은 등록 요청은 IESG에 보고하여 해결할 수 있습니다\(iesg@ietf.org 메일링 목록 사용\).

지정된 전문가가 적용해야 하는 기준에는 제안된 등록이 기존 기능을 중복하는지 여부, 일반적으로 적용될 가능성이 있는지 또는 단일 애플리케이션에만 유용한지 여부, 등록 설명이 명확한지 여부가 포함됩니다.

IANA는 지정된 전문가로부터 레지스트리 업데이트만 수락해야 하며, 모든 등록 요청은 검토 메일링 목록으로 전달해야 합니다.

이 사양을 사용하여 다양한 애플리케이션의 관점을 대표할 수 있는 여러 지정 전문가를 임명하여 등록 결정에 대한 광범위한 정보 검토를 가능하게 하는 것이 좋습니다. 등록 결정이 특정 전문가에게 이해 상충을 일으키는 것으로 인식될 수 있는 경우 해당 전문가는 다른 전문가의 판단을 따라야 합니다.

---
### **9.1.  JSON Web Signature and Encryption Header Parameters Registry**

이 사양은 헤더 매개변수 이름에 대한 IANA "JSON 웹 서명 및 암호화 헤더 매개변수" 레지스트리를 설정합니다. 레지스트리는 헤더 매개변수 이름과 이를 정의하는 사양에 대한 참조를 기록합니다. 매개변수 사용이 사양 간에 호환되는 경우 동일한 헤더 매개변수 이름을 여러 번 등록할 수 있습니다. 동일한 헤더 매개변수 이름의 다른 등록은 일반적으로 다른 헤더 매개변수 사용 위치 값을 사용합니다.

---
#### **9.1.1.  Registration Template**

헤더 매개변수 이름: - 요청된 이름\(예: "kid"\). 이 사양의 핵심 목표는 결과 표현이 간결해지는 것이므로 이름은 짧아야 합니다. 즉, 그렇게 할 만한 강력한 이유가 없이는 8자를 넘지 않아야 합니다. 이 이름은

- 대소문자 구분. 지정된 전문가가 예외를 허용할 만한 강력한 이유가 있다고 명시하지 않는 한, 이름은 대소문자 구분 없이 다른 등록된 이름과 일치할 수 없습니다.

헤더 매개변수 설명: - 헤더 매개변수에 대한 간략한 설명\(예: "키 ID"\).

헤더 매개변수 사용 위치: - 헤더 매개변수 사용 위치는 "JWS" 또는 "JWE" 값 중 하나 이상이어야 합니다.

변경 컨트롤러: - 표준 추적 RFC의 경우 "IESG"를 나열합니다. 다른 경우 책임 당사자의 이름을 제공합니다. 기타 세부 정보\(예: 우편 주소, 이메일 주소, 홈페이지 URI\)도 포함될 수 있습니다.

사양 문서: - 매개변수를 지정하는 문서 또는 문서에 대한 참조, 문서 사본을 검색하는 데 사용할 수 있는 URI를 포함하는 것이 좋습니다. 관련 섹션에 대한 표시도 포함될 수 있지만 필수는 아닙니다.

---
#### **9.1.2.  Initial Registry Contents**

이 섹션에서는 섹션 4.1에 정의된 헤더 매개변수 이름을 이 레지스트리에 등록합니다.

- 헤더 매개변수 이름: "alg"
- 헤더 매개변수 설명: 알고리즘
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.1

- 헤더 매개변수 이름: "jku"
- 헤더 매개변수 설명: JWK Set URL
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.2

- 헤더 매개변수 이름: "jwk"
- 헤더 매개변수 설명: JSON 웹 키
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.3

- 헤더 매개변수 이름: "kid"
- 헤더 매개변수 설명: 키 ID
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.4

- 헤더 매개변수 이름: "x5u"
- 헤더 매개변수 설명: X.509 URL
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.5

- 헤더 매개변수 이름: "x5c"
- 헤더 매개변수 설명: X.509 인증서 체인
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.6

- 헤더 매개변수 이름: "x5t"
- 헤더 매개변수 설명: X.509 인증서 SHA-1 지문
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.7

- 헤더 매개변수 이름: "x5t#S256"
- 헤더 매개변수 설명: X.509 인증서 SHA-256 지문
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.8

- 헤더 매개변수 이름: "typ"
- 헤더 매개변수 설명: 유형
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.9

- 헤더 매개변수 이름: "cty"
- 헤더 매개변수 설명: 콘텐츠 유형
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.10

- 헤더 매개변수 이름: "crit"
- 헤더 매개변수 설명: 중요
- 헤더 매개변수 사용 위치: JWS
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7515의 섹션 4.1.11

---
### **9.2.  Media Type Registration**
---
#### **9.2.1.  Registry Contents**

이 섹션에서는 RFC 6838 \[RFC6838\]에 설명된 방식으로 "Media Types" 레지스트리 \[IANA.MediaTypes\]에 "application/jose" 미디어 유형 \[RFC2046\]을 등록합니다. 이는 JWS Compact Serialization 또는 JWE Compact Serialization을 사용하여 콘텐츠가 JWS 또는 JWE임을 나타내는 데 사용할 수 있습니다. 이 섹션에서는 또한 "Media Types" 레지스트리에 "application/jose+json" 미디어 유형을 등록합니다. 이는 JWS JSON Serialization 또는 JWE JSON Serialization을 사용하여 콘텐츠가 JWS 또는 JWE임을 나타내는 데 사용할 수 있습니다.

- 유형 이름: application
- 하위 유형 이름: jose
- 필수 매개변수: 없음
- 선택 매개변수: 없음
- 인코딩 고려 사항: 8비트; application/jose 값은 일련의 base64url 인코딩된 값\(일부는 빈 문자열일 수 있음\)으로 인코딩되며, 각각은 단일 마침표\('.'\) 문자로 구분됩니다.
- 보안 고려 사항: RFC 7515의 보안 고려 사항 섹션을 참조하세요.
- 상호 운용성 고려 사항: 없음
- 게시된 사양: RFC 7515
- 이 미디어 유형을 사용하는 애플리케이션: OpenID Connect, Mozilla Persona, Salesforce, Google, Android, Windows Azure, Xbox One, Amazon Web Services 및 JWT를 사용하는 기타 여러 애플리케이션
- 조각 식별자 고려 사항: 없음
- 추가 정보:

```text
         Magic number(s): n/a
         File extension(s): n/a
         Macintosh file type code(s): n/a
```

- 추가 정보를 문의할 사람 및 이메일 주소: Michael B. Jones, mbj@microsoft.com
- 의도된 사용: COMMON
- 사용 제한: 없음
- 작성자: Michael B. Jones, mbj@microsoft.com
- 변경 관리자: IESG
- 임시 등록? 아니요

- 유형 이름: application
- 하위 유형 이름: jose+json
- 필수 매개변수: 없음
- 선택 매개변수: 없음
- 인코딩 고려 사항: 8비트; application/jose+json 값은 JSON 객체로 표현됨; JSON 객체에 UTF-8 인코딩을 사용해야 함.
- 보안 고려 사항: RFC 7515의 보안 고려 사항 섹션 참조
- 상호 운용성 고려 사항: 없음
- 게시된 사양: RFC 7515
- 이 미디어 유형을 사용하는 애플리케이션: Nimbus JOSE + JWT 라이브러리
- 조각 식별자 고려 사항: 없음
- 추가 정보:

```text
         Magic number(s): n/a
         File extension(s): n/a
         Macintosh file type code(s): n/a
```

- 추가 정보를 문의할 사람 및 이메일 주소: Michael B. Jones, mbj@microsoft.com
- 의도된 사용: COMMON
- 사용 제한: 없음
- 작성자: Michael B. Jones, mbj@microsoft.com
- 변경 관리자: IESG
- 임시 등록? 아니요

---
## **10.  Security Considerations**

모든 암호화 애플리케이션과 관련된 모든 보안 문제는 JWS/JWE/JWK 에이전트가 해결해야 합니다. 이러한 문제 중에는 사용자의 비대칭 개인 키와 대칭 비밀 키를 보호하고 다양한 공격에 대한 대책을 채택하는 것이 있습니다.

"XML 서명 구문 및 처리 버전 2.0"\[W3C.NOTE-xmldsig-core2-20130411\]의 모든 보안 고려 사항은 XML에 국한되지 않는 한 이 사양에도 적용됩니다. 마찬가지로 "XML 서명 모범 사례"\[W3C.NOTE-xmldsig-bestpractices-20130411\]에 문서화된 모범 사례 중 다수도 XML에 국한되지 않는 한 이 사양에도 적용됩니다.

---
### **10.1.  Key Entropy and Random Values**

키는 키 생성에 사용된 엔트로피 양만큼만 강력합니다. 모든 키에 최소 128비트의 엔트로피를 사용해야 하며, 애플리케이션 컨텍스트에 따라 더 많이 필요할 수 있습니다.

구현은 공개/개인 키 쌍, MAC 키 및 패딩 값을 무작위로 생성해야 합니다. 암호화 키를 생성하는 데 부적절한 의사 난수 생성기\(PRNG\)를 사용하면 보안이 거의 또는 전혀 보장되지 않을 수 있습니다. 공격자는 키를 생성한 PRNG 환경을 재생성하여 전체 키 공간을 무차별 대입하여 검색하는 것보다 결과적으로 발생하는 작은 가능성 집합을 검색하는 것이 훨씬 더 쉽다고 생각할 수 있습니다. 양질의 난수를 생성하는 것은 어렵습니다. RFC 4086\[RFC4086\]은 이 분야에서 중요한 지침을 제공합니다.

---
### **10.2.  Key Protection**

구현은 서명자의 개인 키를 보호해야 합니다. 서명자의 개인 키가 손상되면 공격자가 서명자로 위장할 수 있습니다.

구현은 MAC 키를 보호해야 합니다. MAC 키가 손상되면 인증된 콘텐츠가 감지할 수 없게 수정될 수 있습니다.

---
### **10.3.  Key Origin Authentication**

공개 키를 얻기 위해 사용되는 키 관리 기술은 키의 출처를 인증해야 합니다. 그렇지 않으면 메시지에 서명한 당사자가 누구인지 알 수 없습니다.

마찬가지로, MAC 키를 배포하는 데 사용되는 키 관리 기술은 데이터 출처 인증을 제공해야 합니다. 그렇지 않으면 내용이 알 수 없는 출처에서 무결성 있게 전달됩니다.

---
### **10.4.  Cryptographic Agility**

암호화 민첩성에 대한 보안 고려 사항은 \[JWA\]의 섹션 8.1을 참조하십시오.

---
### **10.5.  Differences between Digital Signatures and MACs**

MAC과 디지털 서명은 모두 무결성 검사에 사용될 수 있지만, 각각이 제공하는 보안 속성 간에는 몇 가지 중요한 차이점이 있습니다. 프로토콜을 설계하고 프로토콜에 사용할 알고리즘을 선택할 때 이러한 차이점을 고려해야 합니다.

서명과 MAC은 모두 무결성 검사를 제공합니다. 즉, 무결성 값이 계산된 이후로 메시지가 수정되지 않았는지 확인합니다. 그러나 MAC은 특정 상황에서만 출처 식별을 제공합니다. 일반적으로 서명에 사용된 개인 키는 단일 엔터티\(분산 엔터티의 경우\)의 손에만 있다고 가정할 수 있습니다.

복제된 서버\); 그러나 MAC 키는 무결성 계산 및 확인에 사용하는 모든 엔터티의 손에 있어야 합니다. MAC의 검증은 대칭 MAC 키를 아는 당사자 중 한 명이 메시지를 생성했다는 것을 뒷받침할 뿐입니다. 즉, MAC 키가 두 엔터티에게만 알려져 있고 수신자가 메시지를 생성하지 않았다는 것을 알고 있는 경우에만 발신지를 확인할 수 있습니다. MAC 검증은 제3자에게 발신지를 증명하는 데 사용할 수 없습니다.

---
### **10.6.  Algorithm Validation**

일부 알고리즘의 디지털 서명 표현에는 서명 값 내부에 사용된 알고리즘에 대한 정보가 포함됩니다. 예를 들어, RSASSA-PKCS1-v1\_5 \[RFC3447\]로 생성된 서명은 사용된 해시 함수를 인코딩하고, 많은 라이브러리는 실제로 서명을 검증할 때 서명 내부에 지정된 해시 알고리즘을 사용합니다. 이러한 라이브러리를 사용할 때 알고리즘 검증의 일부로 구현은 서명에 인코딩된 알고리즘 정보가 "alg" 헤더 매개변수로 지정된 정보와 일치하는지 확인해야 합니다. 이렇게 하지 않으면 공격자는 실제로 서명 값에 표현된 약한 알고리즘을 사용하면서 강력한 해시 알고리즘을 사용했다고 주장할 수 있습니다.

---
### **10.7.  Algorithm Protection**

JWS의 일부 사용에서 알고리즘 대체 공격의 위험이 있는데, 공격자가 다른 서명 알고리즘을 사용하여 서명자가 서명하지 않은 것을 서명한 것처럼 보이게 할 수 있습니다. 이러한 공격은 Cryptographic Message Syntax\(CMS\) \[RFC6211\]의 맥락에서 자세히 논의되었습니다. 이 위험은 다음 모든 것이 참일 때 발생합니다.

- 서명 검증자는 여러 알고리즘을 지원합니다.

- 기존 서명이 주어졌을 때 공격자는 다른 알고리즘을 사용하여 동일한 서명 값을 생성하는 또 다른 페이로드를 찾을 수 있습니다.

- 공격자가 만든 페이로드는 애플리케이션 컨텍스트에서 유효합니다.

애플리케이션이 알고리즘 대체 공격을 완화하는 데에는 여러 가지 방법이 있습니다.

- 대체 공격에 취약하지 않은 디지털 서명 알고리즘만 사용하십시오. 대체 공격은 공격자가 해시 함수에 대한 사전 이미지를 계산할 수 있는 경우에만 가능합니다.

- 수신자. 모든 JWA 정의 서명 알고리즘은 SHA-2 해시를 사용하는데, 이 글을 쓰는 시점까지 알려진 사전 이미지 공격은 없습니다.

- "alg" 헤더 매개변수가 JWS 보호 헤더에 포함되어야 합니다. \(이것은 JWS Compact Serialization을 사용할 때 항상 해당되며 CMS에서 취하는 접근 방식입니다 \[RFC6211\].\)

- 애플리케이션 페이로드에 알고리즘을 포함하는 필드를 포함하고 검증 중에 "alg" 헤더 매개변수와 일치하도록 요구합니다. \(이것은 PKIX \[RFC5280\]에서 취한 접근 방식입니다.\)

---
### **10.8.  Chosen Plaintext Attacks**

JWS 작성자는 제3자가 제어할 수 없는 엔트로피를 추가하지 않고 임의의 내용을 메시지에 삽입하는 것을 허용해서는 안 됩니다.

---
### **10.9.  Timing Attacks**

암호화 알고리즘이 성공적인 작업이 실패한 작업과 다른 시간이 걸리는 방식으로 구현되면 공격자는 시간 차이를 사용하여 사용된 키에 대한 정보를 얻을 수 있습니다. 따라서 이러한 시간 차이는 피해야 합니다.

---
### **10.10.  Replay Protection**

이 사양의 범위에 직접적으로 포함되지는 않지만 JWS\(또는 JWE\) 객체를 사용하는 애플리케이션은 JWS\(또는 JWE\) 메시지에 무결성이 보호된 콘텐츠로 고유한 메시지 식별자를 포함하고 수신자가 해당 메시지가 이전에 수신되거나 조치가 취해지지 않았음을 확인하도록 함으로써 재생 공격을 좌절시킬 수 있습니다.

---
### **10.11.  SHA-1 Certificate Thumbprints**

호환성을 위해 "x5t"\(X.509 인증서 SHA-1 지문\) 값을 계산할 때 SHA-1 해시가 사용됩니다. SHA-1 해시 충돌을 생성하는 효과적인 수단이 개발되고 공격자가 주어진 시스템에서 알려진 인증서의 사용을 방해하려는 경우, SHA-1 해시 값이 동일한 다른 인증서를 생성하여 의도한 피해자가 사용하는 인증서 저장소에 추가하면 이를 달성할 수 있습니다. 이 공격이 성공하기 위한 전제 조건은 공격자가 의도한 피해자의 인증서 저장소에 대한 쓰기 액세스 권한이 있어야 한다는 것입니다.

또는 "x5t#S256"\(X.509 인증서 SHA-256 지문\) 헤더 매개변수를 "x5t" 대신 사용할 수 있습니다. 그러나 이 글을 쓰는 시점에서 SHA-256 인증서 지문을 지원하는 개발 플랫폼은 알려져 있지 않습니다.

---
### **10.12.  JSON Security Considerations**

엄격한 JSON \[RFC7159\] 검증은 보안 요구 사항입니다. 잘못된 JSON이 수신되면 제작자의 의도를 확실하게 식별할 수 없습니다. 사용된 JSON 파서가 잘못된 JSON 구문을 거부하지 않으면 모호하고 잠재적으로 악용될 수 있는 상황이 발생할 수 있습니다. 특히 RFC 7159에 정의된 JSON-text 구문을 따르지 않는 JSON 입력은 JSON 파서에서 전체적으로 거부해야 합니다.

"JavaScript Object Notation\(JSON\) 데이터 교환 형식"\[RFC7159\]의 섹션 4에서는 "객체 내의 이름은 고유해야 합니다"라고 명시하고 있지만 이 사양에서는 다음과 같이 명시합니다.

- JOSE 헤더 내의 헤더 매개변수 이름은 고유해야 합니다. JWS 파서는 중복된 헤더 매개변수 이름이 있는 JWS를 거부하거나 ECMAScript 5.1 \[ECMAScript\]의 섹션 15.12\("JSON 객체"\)에 지정된 대로 어휘적으로 마지막으로 중복된 멤버 이름만 반환하는 JSON 파서를 사용해야 합니다.

따라서 이 사양에서는 \[RFC7159\]의 섹션 4에 있는 "SHOULD"를 생산자가 "MUST"로 처리하고 소비자가 "MUST"로 처리하거나 ECMAScript 5.1에 명시된 방식으로 처리해야 합니다. 사용된 JSON 파서가 멤버 이름의 고유성을 적용하지 않거나 중복된 멤버 이름에 대해 예측할 수 없는 값을 반환하는 경우 모호하고 잠재적으로 악용될 수 있는 상황이 발생할 수 있습니다.

일부 JSON 파서는 유효한 입력 뒤에 추가적으로 중요한 문자가 포함된 입력을 거부하지 않을 수 있습니다. 예를 들어, 입력 "{"tag":"value"}ABCD"에는 유효한 JSON 텍스트 객체와 추가 문자 "ABCD"가 포함됩니다. 구현은 이러한 입력이 포함된 JWS를 무효로 간주해야 합니다.

---
### **10.13.  Unicode Comparison Security Considerations**

헤더 매개변수 이름과 알고리즘 이름은 유니코드 문자열입니다. 보안상의 이유로 이러한 이름의 표현은 이스케이프 처리를 수행한 후 그대로 비교해야 합니다\(RFC 7159 \[RFC7159\]의 섹션 8.3에 따름\). 즉, 예를 들어 이러한 JSON 문자열은 동일하다고 비교해야 하지만\("sig", "\u0073ig"\), 이러한 문자열은 모두 첫 번째 세트 또는 서로 같지 않다고 비교해야 합니다\("SIG", "Sig", "si\u0047"\).

JSON 문자열은 유니코드 기본 다국어 평면 외부의 문자를 포함할 수 있습니다. 예를 들어, G 음자리표 문자\(U+1D11E\)는 JSON 문자열에서 "\uD834\uDD1E"로 표현될 수 있습니다. 이상적으로는 JWS 구현은 기본 다국어 평면 외부의 문자가 보존되고 올바르게 비교되도록 해야 합니다. 또는 이러한 문자가 기본 JSON 구현에 존재하는 제한을 행사하여 이것이 불가능한 경우, 이러한 문자가 포함된 입력은 반드시 거부해야 합니다.

---
## **11.  References**
---
### **11.1.  Normative References**

```text
   [ECMAScript] Ecma International, "ECMAScript Language Specification,
                5.1 Edition", ECMA 262, June 2011,
                <http://www.ecma-international.org/ecma-262/5.1/
                ECMA-262.pdf>.

   [IANA.MediaTypes]
                IANA, "Media Types",
                <http://www.iana.org/assignments/media-types>.

   [ITU.X690.2008]
                International Telecommunications Union, "Information
                Technology - ASN.1 encoding rules: Specification of
                Basic Encoding Rules (BER), Canonical Encoding Rules
                (CER) and Distinguished Encoding Rules (DER)", ITU-T
                Recommendation X.690, 2008.

   [JWA]        Jones, M., "JSON Web Algorithms (JWA)", RFC 7518,
                DOI 10.17487/RFC7518, May 2015,
                <http://www.rfc-editor.org/info/rfc7518>.

   [JWK]        Jones, M., "JSON Web Key (JWK)", RFC 7517,
                DOI 10.17487/RFC7517, May 2015,
                <http://www.rfc-editor.org/info/rfc7517>.

   [RFC20]      Cerf, V., "ASCII format for Network Interchange",
                STD 80, RFC 20, DOI 10.17487/RFC0020, October 1969,
                <http://www.rfc-editor.org/info/rfc20>.

   [RFC2045]    Freed, N. and N. Borenstein, "Multipurpose Internet Mail
                Extensions (MIME) Part One: Format of Internet Message
                Bodies", RFC 2045, DOI 10.17487/RFC2045, November 1996,
                <http://www.rfc-editor.org/info/rfc2045>.

   [RFC2046]    Freed, N. and N. Borenstein, "Multipurpose Internet Mail
                Extensions (MIME) Part Two: Media Types", RFC 2046,
                DOI 10.17487/RFC2046, November 1996,
                <http://www.rfc-editor.org/info/rfc2046>.

   [RFC2119]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", BCP 14, RFC 2119,
                DOI 10.17487/RFC2119, March 1997,
                <http://www.rfc-editor.org/info/rfc2119>.

   [RFC2818]    Rescorla, E., "HTTP Over TLS", RFC 2818,
                DOI 10.17487/RFC2818, May 2000,
                <http://www.rfc-editor.org/info/rfc2818>.

   [RFC3629]    Yergeau, F., "UTF-8, a transformation format of ISO
                10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
                2003, <http://www.rfc-editor.org/info/rfc3629>.

   [RFC3986]    Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
                Resource Identifier (URI): Generic Syntax", STD 66,
                RFC 3986, DOI 10.17487/RFC3986, January 2005,
                <http://www.rfc-editor.org/info/rfc3986>.

   [RFC4648]    Josefsson, S., "The Base16, Base32, and Base64 Data
                Encodings", RFC 4648, DOI 10.17487/RFC4648, October
                2006, <http://www.rfc-editor.org/info/rfc4648>.

   [RFC4945]    Korver, B., "The Internet IP Security PKI Profile of
                IKEv1/ISAKMP, IKEv2, and PKIX", RFC 4945,
                DOI 10.17487/RFC4945, August 2007,
                <http://www.rfc-editor.org/info/rfc4945>.

   [RFC4949]    Shirey, R., "Internet Security Glossary, Version 2",
                FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007,
                <http://www.rfc-editor.org/info/rfc4949>.

   [RFC5246]    Dierks, T. and E. Rescorla, "The Transport Layer
                Security (TLS) Protocol Version 1.2", RFC 5246,
                DOI 10.17487/RFC5246, August 2008,
                <http://www.rfc-editor.org/info/rfc5246>.

   [RFC5280]    Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
                Housley, R., and W. Polk, "Internet X.509 Public Key
                Infrastructure Certificate and Certificate Revocation
                List (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May
                2008, <http://www.rfc-editor.org/info/rfc5280>.

   [RFC6125]    Saint-Andre, P. and J. Hodges, "Representation and
                Verification of Domain-Based Application Service
                Identity within Internet Public Key Infrastructure Using
                X.509 (PKIX) Certificates in the Context of Transport
                Layer Security (TLS)", RFC 6125, DOI 10.17487/RFC6125,
                March 2011, <http://www.rfc-editor.org/info/rfc6125>.

   [RFC6176]    Turner, S. and T. Polk, "Prohibiting Secure Sockets
                Layer (SSL) Version 2.0", RFC 6176,
                DOI 10.17487/RFC6176, March 2011,
                <http://www.rfc-editor.org/info/rfc6176>.

   [RFC7159]    Bray, T., Ed., "The JavaScript Object Notation (JSON)
                Data Interchange Format", RFC 7159,
                DOI 10.17487/RFC7159, March 2014,
                <http://www.rfc-editor.org/info/rfc7159>.

   [UNICODE]    The Unicode Consortium, "The Unicode Standard",
                <http://www.unicode.org/versions/latest/>.
```

---
### **11.2.  Informative References**

```text
   [CanvasApp]  Facebook, "Canvas Applications",
                <http://developers.facebook.com/docs/authentication/
                canvas>.

   [JSS]        Bradley, J. and N. Sakimura, Ed., "JSON Simple Sign",
                September 2010, <http://jsonenc.info/jss/1.0/>.

   [JWE]        Jones, M. and J. Hildebrand, "JSON Web Encryption
                (JWE)", RFC 7516, DOI 10.17487/RFC7516, May 2015,
                <http://www.rfc-editor.org/info/rfc7516>.

   [JWT]        Jones, M., Bradley, J., and N. Sakimura, "JSON Web Token
                (JWT)", RFC 7519, DOI 10.17487/RFC7519, May 2015,
                <http://www.rfc-editor.org/info/rfc7519>.

   [MagicSignatures]
                Panzer, J., Ed., Laurie, B., and D. Balfanz, "Magic
                Signatures", January 2011,
                <http://salmon-protocol.googlecode.com/svn/trunk/
                draft-panzer-magicsig-01.html>.

   [RFC2104]    Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
                Keyed-Hashing for Message Authentication", RFC 2104,
                DOI 10.17487/RFC2104, February 1997,
                <http://www.rfc-editor.org/info/rfc2104>.

   [RFC3447]    Jonsson, J. and B. Kaliski, "Public-Key Cryptography
                Standards (PKCS) #1: RSA Cryptography Specifications
                Version 2.1", RFC 3447, DOI 10.17487/RFC3447, February
                2003, <http://www.rfc-editor.org/info/rfc3447>.

   [RFC4086]    Eastlake 3rd, D., Schiller, J., and S. Crocker,
                "Randomness Requirements for Security", BCP 106,
                RFC 4086, DOI 10.17487/RFC4086, June 2005,
                <http://www.rfc-editor.org/info/rfc4086>.

   [RFC4122]    Leach, P., Mealling, M., and R. Salz, "A Universally
                Unique IDentifier (UUID) URN Namespace", RFC 4122,
                DOI 10.17487/RFC4122, July 2005,
                <http://www.rfc-editor.org/info/rfc4122>.

   [RFC5226]    Narten, T. and H. Alvestrand, "Guidelines for Writing an
                IANA Considerations Section in RFCs", BCP 26, RFC 5226,
                DOI 10.17487/RFC5226, May 2008,
                <http://www.rfc-editor.org/info/rfc5226>.

   [RFC6211]    Schaad, J., "Cryptographic Message Syntax (CMS)
                Algorithm Identifier Protection Attribute", RFC 6211,
                DOI 10.17487/RFC6211, April 2011,
                <http://www.rfc-editor.org/info/rfc6211>.

   [RFC6838]    Freed, N., Klensin, J., and T. Hansen, "Media Type
                Specifications and Registration Procedures", BCP 13,
                RFC 6838, DOI 10.17487/RFC6838, January 2013,
                <http://www.rfc-editor.org/info/rfc6838>.

   [RFC7525]    Sheffer, Y., Holz, R., and P. Saint-Andre,
                "Recommendations for Secure Use of Transport Layer
                Security (TLS) and Datagram Transport Layer Security
                (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May
                2015, <http://www.rfc-editor.org/info/rfc7525>.

   [SHS]        National Institute of Standards and Technology, "Secure
                Hash Standard (SHS)", FIPS PUB 180-4, March 2012,
                <http://csrc.nist.gov/publications/fips/fips180-4/
                fips-180-4.pdf>.

   [W3C.NOTE-xmldsig-bestpractices-20130411]
                Hirsch, F. and P. Datta, "XML Signature Best Practices",
                World Wide Web Consortium Note
                NOTE-xmldsig-bestpractices-20130411, April 2013,
                <http://www.w3.org/TR/2013/
                NOTE-xmldsig-bestpractices-20130411/>.

   [W3C.NOTE-xmldsig-core2-20130411]
                Eastlake, D., Reagle, J., Solo, D., Hirsch, F.,
                Roessler, T., Yiu, K., Datta, P., and S. Cantor, "XML
                Signature Syntax and Processing Version 2.0", World Wide
                Web Consortium Note NOTE-xmldsig-core2-20130411, April
                2013,
                <http://www.w3.org/TR/2013/NOTE-xmldsig-core2-20130411/>.
```

---
# **Appendix A.  JWS Examples**

이 섹션에서는 JWS의 여러 예를 제공합니다. 처음 세 가지 예는 모두 JSON 웹 토큰\(JWT\)\[JWT\]을 나타내지만, 페이로드는 부록 A.4에 표시된 대로 모든 옥텟 시퀀스가 될 수 있습니다.

---
### **A.1.  Example JWS Using HMAC SHA-256**
---
#### **A.1.1.  Encoding**

다음 예제 JWS 보호 헤더는 데이터 구조가 JWT\[JWT\]이고 JWS 서명 입력이 HMAC SHA-256 알고리즘을 사용하여 보안된다고 선언합니다.

```text
     {"typ":"JWT",
      "alg":"HS256"}
```

위의 JSON 객체 표현에서 잠재적인 모호성을 제거하기 위해 이 예에서 사용된 UTF8\(JWS 보호 헤더\)을 나타내는 실제 옥텟 시퀀스도 아래에 포함되어 있습니다. \(모호성은 줄 바꿈에 대한 플랫폼 표현\(CRLF 대 LF\), 줄의 시작과 끝의 간격 차이, 마지막 줄에 종료 줄 바꿈이 있는지 여부 및 기타 원인으로 인해 발생할 수 있습니다. 이 예에서 사용된 표현에서 첫 번째 줄에는 선행 또는 후행 공백이 없고, 첫 번째 줄과 두 번째 줄 사이에 CRLF 줄 바꿈\(13, 10\)이 있으며, 두 번째 줄에는 선행 공백\(32\)이 하나 있고 후행 공백이 없으며, 마지막 줄에는 종료 줄 바꿈이 없습니다.\) 이 예에서 UTF8\(JWS 보호 헤더\)을 나타내는 옥텟\(JSON 배열 표기법 사용\)은 다음과 같습니다.

```text
   [123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32,
   34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125]
```

이 JWS 보호 헤더를 BASE64URL\(UTF8\(JWS 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
```

이 예에서 사용된 JWS 페이로드는 아래 JSON 객체의 UTF-8 표현의 옥텟입니다. \(페이로드는 base64url로 인코딩된 옥텟 시퀀스가 될 수 있으며 base64url로 인코딩된 JSON 객체가 될 필요는 없습니다.\)

```text
     {"iss":"joe",
      "exp":1300819380,
      "http://example.com/is_root":true}
```

다음 옥텟 시퀀스는 위의 JSON 객체에 대한 이 예에서 사용된 UTF-8 표현이며 JWS 페이로드입니다.

```text
   [123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10,
   32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56,
   48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97,
   109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111,
   111, 116, 34, 58, 116, 114, 117, 101, 125]
```

이 JWS 페이로드를 BASE64URL\(UTF8\(JWS 페이로드\)\)로 인코딩하면 다음 값이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\):

```text
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
```

이들을 BASE64URL\(UTF8\(JWS Protected Header\)\) || '.' || BASE64URL\(JWS Payload\)로 결합하면 다음 문자열이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
     .
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
```

위 문자열의 ASCII 표현인 결과 JWS 서명 입력 값은 다음과 같은 옥텟 시퀀스\(JSON 배열 표기법 사용\)입니다.

```text
   [101, 121, 74, 48, 101, 88, 65, 105, 79, 105, 74, 75, 86, 49, 81,
   105, 76, 65, 48, 75, 73, 67, 74, 104, 98, 71, 99, 105, 79, 105, 74,
   73, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51,
   77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67,
   74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84,
   107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100,
   72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76,
   109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73,
   106, 112, 48, 99, 110, 86, 108, 102, 81]
```

HMAC는 키를 사용하여 생성됩니다. 이 예에서는 아래 JSON 웹 키\[JWK\] 형식으로 표현된 대칭 키를 사용합니다\(표시 목적으로만 값 내에 줄 바꿈이 있음\):

```text
     {"kty":"oct",
      "k":"AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75
           aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow"
     }
```

이 키로 JWS 서명 입력에 HMAC SHA-256 알고리즘을 실행하면 다음 JWS 서명 옥텟 시퀀스가 생성됩니다.

```text
   [116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173,
   187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83,
   132, 141, 121]
```

이 JWS 서명을 BASE64URL\(JWS 서명\)로 인코딩하면 다음 값이 생성됩니다.

```text
     dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
```

Header.Payload.Signature 순서로 이러한 값을 연결하고 각 부분 사이에 마침표\(.\)를 사용하면 JWS Compact Serialization을 사용하여 다음과 같은 완전한 JWS 표현이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
     .
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
     .
     dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
```

---
#### **A.1.2.  Validating**

"alg" 헤더 매개변수가 "HS256"이므로 JWS 서명에 포함된 HMAC SHA-256 값을 검증합니다.

HMAC 값을 검증하기 위해 올바른 키와 JWS 서명 입력\(JWS Compact Serialization 표현의 초기 하위 문자열\(두 번째 마침표 문자는 포함하지 않음\)까지\)을 HMAC SHA-256 함수의 입력으로 사용하는 이전 프로세스를 반복한 다음 출력을 가져와 JWS 서명\(JWS 표현에 인코딩된 값에서 base64url로 디코딩됨\)과 일치하는지 확인합니다. 정확히 일치하면 HMAC가 검증된 것입니다.

---
### **A.2.  Example JWS Using RSASSA-PKCS1-v1_5 SHA-256**
---
#### **A.2.1.  Encoding**

이 예에서 JWS 보호 헤더는 두 가지 면에서 이전 예와 다릅니다. 첫째, 다른 알고리즘을 사용하기 때문에 "alg" 값이 다릅니다. 둘째, 설명 목적으로만 선택적 "typ"\(유형\) 헤더 매개변수는 사용하지 않습니다. \(이 차이점은 사용된 알고리즘과 관련이 없습니다.\) 사용된 JWS 보호 헤더는 다음과 같습니다.

```text
     {"alg":"RS256"}
```

이 예에서 UTF8\(JWS 보호 헤더\)을 나타내는 옥텟은 다음과 같습니다\(JSON 배열 표기법 사용\):

```text
   [123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]
```

이 JWS 보호 헤더를 BASE64URL\(UTF8\(JWS 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJSUzI1NiJ9
```

이 예에서 사용된 JWS Payload는 다음 예와 동일합니다. 따라서 BASE64URL\(JWS Payload\) 값이 동일하므로 계산은 여기서 반복되지 않습니다.

```text
     {"iss":"joe",
      "exp":1300819380,
      "http://example.com/is_root":true}
```

이들을 BASE64URL\(UTF8\(JWS Protected Header\)\) || '.' || BASE64URL\(JWS Payload\)로 결합하면 다음 문자열이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJhbGciOiJSUzI1NiJ9
     .
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
```

위 문자열의 ASCII 표현인 결과 JWS 서명 입력 값은 다음 옥텟 시퀀스입니다.

```text
   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73,
   49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105,
   74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72,
   65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68,
   65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76,
   121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118,
   98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48,
   99, 110, 86, 108, 102, 81]
```

이 예제에서는 아래와 같이 JSON 웹 키\[JWK\] 형식으로 표현된 RSA 키를 사용합니다\(표시 목적으로만 값 내에 줄 바꿈이 있음\):

```text
     {"kty":"RSA",
      "n":"ofgWCuLjybRlzo0tZWJjNiuSfb4p4fAkd_wWJcyQoTbji9k0l8W26mPddx
           HmfHQp-Vaw-4qPCJrcS2mJPMEzP1Pt0Bm4d4QlL-yRT-SFd2lZS-pCgNMs
           D1W_YpRPEwOWvG6b32690r2jZ47soMZo9wGzjb_7OMg0LOL-bSf63kpaSH
           SXndS5z5rexMdbBYUsLA9e-KXBdQOS-UTo7WTBEMa2R2CapHg665xsmtdV
           MTBQY4uDZlxvb3qCo5ZwKh9kG4LT6_I5IhlJH7aGhyxXFvUK-DWNmoudF8
           NAco9_h9iaGNj8q2ethFkMLs91kzk2PAcDTW9gb54h4FRWyuXpoQ",
      "e":"AQAB",
      "d":"Eq5xpGnNCivDflJsRQBXHx1hdR1k6Ulwe2JZD50LpXyWPEAeP88vLNO97I
           jlA7_GQ5sLKMgvfTeXZx9SE-7YwVol2NXOoAJe46sui395IW_GO-pWJ1O0
           BkTGoVEn2bKVRUCgu-GjBVaYLU6f3l9kJfFNS3E0QbVdxzubSu3Mkqzjkn
           439X0M_V51gfpRLI9JYanrC4D4qAdGcopV_0ZHHzQlBjudU2QvXt4ehNYT
           CBr6XCLQUShb1juUO1ZdiYoFaFQT5Tw8bGUl_x_jTj3ccPDVZFD9pIuhLh
           BOneufuBiB4cS98l2SR_RQyGWSeWjnczT0QU91p1DhOVRuOopznQ",
      "p":"4BzEEOtIpmVdVEZNCqS7baC4crd0pqnRH_5IB3jw3bcxGn6QLvnEtfdUdi
           YrqBdss1l58BQ3KhooKeQTa9AB0Hw_Py5PJdTJNPY8cQn7ouZ2KKDcmnPG
           BY5t7yLc1QlQ5xHdwW1VhvKn-nXqhJTBgIPgtldC-KDV5z-y2XDwGUc",
      "q":"uQPEfgmVtjL0Uyyx88GZFF1fOunH3-7cepKmtH4pxhtCoHqpWmT8YAmZxa
           ewHgHAjLYsp1ZSe7zFYHj7C6ul7TjeLQeZD_YwD66t62wDmpe_HlB-TnBA
           -njbglfIsRLtXlnDzQkv5dTltRJ11BKBBypeeF6689rjcJIDEz9RWdc",
      "dp":"BwKfV3Akq5_MFZDFZCnW-wzl-CCo83WoZvnLQwCTeDv8uzluRSnm71I3Q
           CLdhrqE2e9YkxvuxdBfpT_PI7Yz-FOKnu1R6HsJeDCjn12Sk3vmAktV2zb
           34MCdy7cpdTh_YVr7tss2u6vneTwrA86rZtu5Mbr1C1XsmvkxHQAdYo0",
      "dq":"h_96-mK1R_7glhsum81dZxjTnYynPbZpHziZjeeHcXYsXaaMwkOlODsWa
           7I9xXDoRwbKgB719rrmI2oKr6N3Do9U0ajaHF-NKJnwgjMd2w9cjz3_-ky
           NlxAr2v4IKhGNpmM5iIgOS1VZnOZ68m6_pbLBSp3nssTdlqvd0tIiTHU",
      "qi":"IYd7DHOhrWvxkwPQsRM2tOgrjbcrfvtQJipd-DlcxyVuuM9sQLdgjVk2o
           y26F0EmpScGLq2MowX7fhd_QJQ3ydy5cY7YIBi87w93IKLEdfnbJtoOPLU
           W0ITrJReOgo1cq9SbsxYawBgfp_gh6A5603k2-ZQwVK0JKSHuLFkuQ3U"
     }
```

그런 다음 RSA 개인 키는 RSA 서명 함수에 전달되고, 이 함수는 해시 유형, SHA-256 및 JWS 서명 입력을 입력으로 사용합니다. 디지털 서명의 결과는 옥텟 시퀀스로, 빅 엔디언 정수를 나타냅니다. 이 예에서는 다음과 같습니다.

```text
   [112, 46, 33, 137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69,
   243, 65, 6, 174, 27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125,
   131, 101, 109, 66, 10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81,
   102, 104, 123, 0, 11, 135, 34, 110, 1, 135, 237, 16, 115, 249, 69,
   229, 130, 173, 252, 239, 22, 216, 90, 121, 142, 232, 198, 109, 219,
   61, 184, 151, 91, 23, 208, 148, 2, 190, 237, 213, 217, 217, 112, 7,
   16, 141, 178, 129, 96, 213, 248, 4, 12, 167, 68, 87, 98, 184, 31,
   190, 127, 249, 217, 46, 10, 231, 111, 36, 242, 91, 51, 187, 230, 244,
   74, 230, 30, 177, 4, 10, 203, 32, 4, 77, 62, 249, 18, 142, 212, 1,
   48, 121, 91, 212, 189, 59, 65, 238, 202, 208, 102, 171, 101, 25, 129,
   253, 228, 141, 247, 127, 55, 45, 195, 139, 159, 175, 221, 59, 239,
   177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65, 214, 18, 202,
   173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175, 132, 157,
   105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14, 96, 69,
   34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247, 202,
   234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90,
   193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238,
   251, 71]
```

서명을 BASE64URL\(JWS Signature\)로 인코딩하면 다음 값이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7
     AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4
     BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K
     0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv
     hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB
     p0igcN_IoypGlUPQGe77Rw
```

Header.Payload.Signature 순서로 이러한 값을 연결하고 각 부분 사이에 마침표\(.\)를 사용하면 JWS Compact Serialization을 사용하여 다음과 같은 완전한 JWS 표현이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJhbGciOiJSUzI1NiJ9
     .
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
     .
     cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7
     AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4
     BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K
     0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv
     hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB
     p0igcN_IoypGlUPQGe77Rw
```

---
#### **A.2.2.  Validating**

"alg" 헤더 매개변수가 "RS256"이므로 JWS 서명에 포함된 RSASSA-PKCS1-v1\_5 SHA-256 디지털 서명을 검증합니다.

JWS 서명을 검증하는 것은 이전 예와 약간 다릅니다. 공개 키\(n, e\), JWS 서명\(JWS 표현에 인코딩된 값에서 base64url로 디코딩됨\), JWS 서명 입력\(JWS Compact Serialization 표현의 초기 하위 문자열\(두 번째 마침표 문자는 포함하지 않음\)\)을 SHA-256 해시 함수를 사용하도록 구성된 RSASSA-PKCS1-v1\_5 서명 검증기에 전달합니다.

---
### **A.3.  Example JWS Using ECDSA P-256 SHA-256**
---
#### **A.3.1.  Encoding**

이 예의 JWS 보호 헤더는 다른 알고리즘이 사용되기 때문에 이전 예와 다릅니다. 사용된 JWS 보호 헤더는 다음과 같습니다.

```text
     {"alg":"ES256"}
```

이 예에서 UTF8\(JWS 보호 헤더\)을 나타내는 옥텟은 다음과 같습니다\(JSON 배열 표기법 사용\):

```text
   [123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125]
```

이 JWS 보호 헤더를 BASE64URL\(UTF8\(JWS 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJFUzI1NiJ9
```

이 예제에서 사용된 JWS Payload는 다음 예제와 동일합니다. 따라서 BASE64URL\(JWS Payload\) 값이 동일하므로 계산은 여기서 반복되지 않습니다.

```text
     {"iss":"joe",
      "exp":1300819380,
      "http://example.com/is_root":true}
```

이들을 BASE64URL\(UTF8\(JWS Protected Header\)\) || '.' || BASE64URL\(JWS Payload\)로 결합하면 다음 문자열이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJhbGciOiJFUzI1NiJ9
     .
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
```

위 문자열의 ASCII 표현인 결과 JWS 서명 입력 값은 다음 옥텟 시퀀스입니다.

```text
   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 73,
   49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105,
   74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72,
   65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68,
   65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76,
   121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118,
   98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48,
   99, 110, 86, 108, 102, 81]
```

이 예제에서는 아래 JSON 웹 키\[JWK\] 형식으로 표현된 타원 곡선 키를 사용합니다.

```text
     {"kty":"EC",
      "crv":"P-256",
      "x":"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU",
      "y":"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0",
      "d":"jpsQnnGQmL-YBIffH1136cspYG6-0iY7X1fCE9-E9LI"
     }
```

타원 곡선 디지털 서명 알고리즘\(ECDSA\) 개인 부분 d는 ECDSA 서명 함수에 전달되고, 이 함수는 곡선 유형 P-256, 해시 유형 SHA-256 및 JWS 서명 입력을 입력으로 받습니다. 디지털 서명의 결과는 타원 곡선입니다.

\(EC\) 포인트\(R, S\), 여기서 R과 S는 부호 없는 정수입니다. 이 예에서, R과 S 값은 빅 엔디언 정수를 나타내는 옥텟 시퀀스로 주어지며 다음과 같습니다.

```text
   +--------+----------------------------------------------------------+
   | Result | Value                                                    |
   | Name   |                                                          |
   +--------+----------------------------------------------------------+
   | R      | [14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, |
   |        | 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129,  |
   |        | 154, 195, 22, 158, 166, 101]                             |
   | S      | [197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175,  |
   |        | 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154,   |
   |        | 143, 63, 127, 138, 131, 163, 84, 213]                    |
   +--------+----------------------------------------------------------+
```

JWS 서명은 값 R || S입니다. 서명을 BASE64URL\(JWS 서명\)로 인코딩하면 이 값이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA
     pmWQxfKTUJqPP3-Kg6NU1Q
```

Header.Payload.Signature 순서로 이러한 값을 연결하고 각 부분 사이에 마침표\(.\)를 사용하면 JWS Compact Serialization을 사용하여 다음과 같은 완전한 JWS 표현이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJhbGciOiJFUzI1NiJ9
     .
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
     .
     DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA
     pmWQxfKTUJqPP3-Kg6NU1Q
```

---
#### **A.3.2.  Validating**

"alg" 헤더 매개변수가 "ES256"이므로 JWS 서명에 포함된 ECDSA P-256 SHA-256 디지털 서명을 검증합니다.

JWS 서명을 검증하는 것은 이전 예제와 약간 다릅니다. JWS 서명의 64개 멤버 옥텟 시퀀스\(JWS 표현에서 인코딩된 값에서 base64url로 디코딩됨\)를 두 개의 32옥텟 시퀀스로 분할해야 합니다. 첫 번째는 R을 나타내고 두 번째는 S를 나타냅니다. 그런 다음 공개 키\(x, y\), 서명\(R, S\) 및 JWS 서명 입력\(JWS Compact Serialization 표현의 초기 하위 문자열\)을 전달합니다.

\(두 번째 마침표 문자는 제외\) SHA-256 해시 함수와 함께 P-256 곡선을 사용하도록 구성된 ECDSA 서명 검증기에 전송합니다.

---
### **A.4.  Example JWS Using ECDSA P-521 SHA-512**
---
#### **A.4.1.  Encoding**

이 예제의 JWS 보호 헤더는 다른 ECDSA 곡선과 해시 함수가 사용되기 때문에 이전 예제와 다릅니다. 사용된 JWS 보호 헤더는 다음과 같습니다.

```text
     {"alg":"ES512"}
```

이 예에서 UTF8\(JWS 보호 헤더\)을 나타내는 옥텟은 다음과 같습니다\(JSON 배열 표기법 사용\):

```text
   [123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 53, 49, 50, 34, 125]
```

이 JWS 보호 헤더를 BASE64URL\(UTF8\(JWS 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJFUzUxMiJ9
```

이 예에서 사용된 JWS Payload는 ASCII 문자열 "Payload"입니다. 이 문자열의 표현은 다음 옥텟 시퀀스입니다.

```text
   [80, 97, 121, 108, 111, 97, 100]
```

이 JWS 페이로드를 BASE64URL\(JWS 페이로드\)로 인코딩하면 다음 값이 생성됩니다.

```text
     UGF5bG9hZA
```

이것들을 BASE64URL\(UTF8\(JWS Protected Header\)\) || '.' || BASE64URL\(JWS Payload\)로 결합하면 다음 문자열이 생성됩니다.

```text
     eyJhbGciOiJFUzUxMiJ9.UGF5bG9hZA
```

위 문자열의 ASCII 표현인 결과 JWS 서명 입력 값은 다음 옥텟 시퀀스입니다.

```text
   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 85,
   120, 77, 105, 74, 57, 46, 85, 71, 70, 53, 98, 71, 57, 104, 90, 65]
```

이 예제에서는 아래 JSON 웹 키\[JWK\] 형식으로 표현된 타원 곡선 키를 사용합니다\(표시 목적으로만 값 내에 줄 바꿈이 있음\):

```text
     {"kty":"EC",
      "crv":"P-521",
      "x":"AekpBQ8ST8a8VcfVOTNl353vSrDCLLJXmPk06wTjxrrjcBpXp5EOnYG_
           NjFZ6OvLFV1jSfS9tsz4qUxcWceqwQGk",
      "y":"ADSmRA43Z1DSNx_RvcLI87cdL07l6jQyyBXMoxVg_l2Th-x3S1WDhjDl
           y79ajL4Kkd0AZMaZmh9ubmf63e3kyMj2",
      "d":"AY5pb7A0UFiB3RELSD64fTLOSV_jazdF7fLYyuTw8lOfRhWg6Y6rUrPA
           xerEzgdRhajnu0ferB0d53vM9mE15j2C"
     }
```

그런 다음 ECDSA 비공개 부분 d가 ECDSA 서명 함수에 전달되고, 이 함수는 곡선 유형 P-521, 해시 유형 SHA-512 및 JWS 서명 입력을 입력으로 사용합니다. 디지털 서명의 결과는 EC 포인트\(R, S\)이며, 여기서 R과 S는 부호 없는 정수입니다. 이 예에서 R과 S 값은 빅 엔디언 정수를 나타내는 옥텟 시퀀스로 주어지며 다음과 같습니다.

```text
   +--------+----------------------------------------------------------+
   | Result | Value                                                    |
   | Name   |                                                          |
   +--------+----------------------------------------------------------+
   | R      | [1, 220, 12, 129, 231, 171, 194, 209, 232, 135, 233,     |
   |        | 117, 247, 105, 122, 210, 26, 125, 192, 1, 217, 21, 82,   |
   |        | 91, 45, 240, 255, 83, 19, 34, 239, 71, 48, 157, 147,     |
   |        | 152, 105, 18, 53, 108, 163, 214, 68, 231, 62, 153, 150,  |
   |        | 106, 194, 164, 246, 72, 143, 138, 24, 50, 129, 223, 133, |
   |        | 206, 209, 172, 63, 237, 119, 109]                        |
   | S      | [0, 111, 6, 105, 44, 5, 41, 208, 128, 61, 152, 40, 92,   |
   |        | 61, 152, 4, 150, 66, 60, 69, 247, 196, 170, 81, 193,     |
   |        | 199, 78, 59, 194, 169, 16, 124, 9, 143, 42, 142, 131,    |
   |        | 48, 206, 238, 34, 175, 83, 203, 220, 159, 3, 107, 155,   |
   |        | 22, 27, 73, 111, 68, 68, 21, 238, 144, 229, 232, 148,    |
   |        | 188, 222, 59, 242, 103]                                  |
   +--------+----------------------------------------------------------+
```

JWS 서명은 값 R || S입니다. 서명을 BASE64URL\(JWS 서명\)로 인코딩하면 이 값이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     AdwMgeerwtHoh-l192l60hp9wAHZFVJbLfD_UxMi70cwnZOYaRI1bKPWROc-mZZq
     wqT2SI-KGDKB34XO0aw_7XdtAG8GaSwFKdCAPZgoXD2YBJZCPEX3xKpRwcdOO8Kp
     EHwJjyqOgzDO7iKvU8vcnwNrmxYbSW9ERBXukOXolLzeO_Jn
```

Header.Payload.Signature 순서로 이러한 값을 연결하고 각 부분 사이에 마침표\(.\)를 사용하면 JWS Compact Serialization을 사용하여 다음과 같은 완전한 JWS 표현이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJhbGciOiJFUzUxMiJ9
     .
     UGF5bG9hZA
     .
     AdwMgeerwtHoh-l192l60hp9wAHZFVJbLfD_UxMi70cwnZOYaRI1bKPWROc-mZZq
     wqT2SI-KGDKB34XO0aw_7XdtAG8GaSwFKdCAPZgoXD2YBJZCPEX3xKpRwcdOO8Kp
     EHwJjyqOgzDO7iKvU8vcnwNrmxYbSW9ERBXukOXolLzeO_Jn
```

---
#### **A.4.2.  Validating**

"alg" 헤더 매개변수가 "ES512"이므로 JWS 서명에 포함된 ECDSA P-521 SHA-512 디지털 서명을 검증합니다.

이 JWS 서명을 검증하는 것은 이전 예와 매우 유사합니다. JWS 서명의 132개 멤버 옥텟 시퀀스를 두 개의 66옥텟 시퀀스로 분할해야 합니다. 첫 번째는 R을 나타내고 두 번째는 S를 나타냅니다. 그런 다음 공개 키\(x, y\), 서명\(R, S\), JWS 서명 입력을 SHA-512 해시 함수와 함께 P-521 곡선을 사용하도록 구성된 ECDSA 서명 검증기에 전달합니다.

---
### **A.5.  Example Unsecured JWS**

다음 예제 JWS 보호 헤더는 인코딩된 객체가 보안되지 않은 JWS임을 선언합니다.

```text
     {"alg":"none"}
```

이 JWS 보호 헤더를 BASE64URL\(UTF8\(JWS 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJub25lIn0
```

이 예제에서 사용된 JWS Payload는 다음 예제와 동일합니다. 따라서 BASE64URL\(JWS Payload\) 값이 동일하므로 계산은 여기서 반복되지 않습니다.

```text
     {"iss":"joe",
      "exp":1300819380,
      "http://example.com/is_root":true}
```

JWS 서명은 빈 옥텟 문자열이고 BASE64URL\(JWS 서명\)은 빈 문자열입니다.

Header.Payload.Signature 순서로 이러한 값을 연결하고 각 부분 사이에 마침표\(.\)를 사용하면 JWS Compact Serialization을 사용하여 다음과 같은 완전한 JWS 표현이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     eyJhbGciOiJub25lIn0
     .
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
     .
```

---
### **A.6.  Example JWS Using General JWS JSON Serialization**

이 섹션에는 일반적인 JWS JSON 직렬화 구문을 사용하는 예가 들어 있습니다. 이 예는 동일한 페이로드에 대해 여러 디지털 서명 및/또는 MAC을 전달하는 기능을 보여줍니다.

이 예에서 사용된 JWS 페이로드는 부록 A.2 및 부록 A.3의 예에서 사용된 것과 동일합니다\(표시 목적으로만 줄 바꿈이 포함됨\).

```text
     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
     cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
```

이 예에서는 두 개의 디지털 서명이 사용됩니다. 첫 번째는 RSASSA-PKCS1-v1\_5 SHA-256을 사용하고 두 번째는 ECDSA P-256 SHA-256을 사용합니다. 첫 번째의 경우 JWS 보호 헤더와 키는 부록 A.2와 동일하여 동일한 JWS 서명 값이 생성됩니다. 따라서 계산은 여기에서 반복되지 않습니다. 두 번째의 경우 JWS 보호 헤더와 키는 부록 A.3과 동일하여 동일한 JWS 서명 값이 생성됩니다. 따라서 계산은 여기에서 반복되지 않습니다.

---
#### **A.6.1.  JWS Per-Signature Protected Headers**

첫 번째 서명에 사용된 JWS 보호 헤더 값은 다음과 같습니다.

```text
     {"alg":"RS256"}
```

이 JWS 보호 헤더를 BASE64URL\(UTF8\(JWS 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJSUzI1NiJ9
```

두 번째 서명에 사용된 JWS 보호 헤더 값은 다음과 같습니다.

```text
     {"alg":"ES256"}
```

이 JWS 보호 헤더를 BASE64URL\(UTF8\(JWS 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJFUzI1NiJ9
```

---
#### **A.6.2.  JWS Per-Signature Unprotected Headers**

키 ID 값은 서명별 헤더 매개변수를 사용하여 두 키에 제공됩니다. 이러한 키 ID를 나타내는 데 사용되는 두 개의 JWS 보호되지 않은 헤더 값은 다음과 같습니다.

```text
     {"kid":"2010-12-29"}

   and

     {"kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"}
```

---
#### **A.6.3.  Complete JOSE Header Values**

제공된 JWS 보호 헤더 및 JWS 보호되지 않은 헤더 값을 결합하면 각각 첫 번째 및 두 번째 서명에 사용되는 JOSE 헤더 값은 다음과 같습니다.

```text
     {"alg":"RS256",
      "kid":"2010-12-29"}

   and

     {"alg":"ES256",
      "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"}
```

---
#### **A.6.4.  Complete JWS JSON Serialization Representation**

이러한 값에 대한 전체 JWS JSON 직렬화는 다음과 같습니다\(표시 목적으로만 값 내에 줄 바꿈이 있음\):

```text
     {
      "payload":
       "eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGF
        tcGxlLmNvbS9pc19yb290Ijp0cnVlfQ",
      "signatures":[
       {"protected":"eyJhbGciOiJSUzI1NiJ9",
        "header":
         {"kid":"2010-12-29"},
        "signature":
         "cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZ
          mh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjb
          KBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHl
          b1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZES
          c6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AX
          LIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw"},
       {"protected":"eyJhbGciOiJFUzI1NiJ9",
        "header":
         {"kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"},
        "signature":
         "DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8IS
          lSApmWQxfKTUJqPP3-Kg6NU1Q"}]
     }
```

---
### **A.7.  Example JWS Using Flattened JWS JSON Serialization**

이 섹션에는 평면화된 JWS JSON 직렬화 구문을 사용하는 예가 들어 있습니다. 이 예는 평면화된 JSON 구조에서 단일 디지털 서명 또는 MAC을 전달하는 기능을 보여줍니다.

이 예의 값은 부록 A.6의 이전 예의 두 번째 서명의 값과 동일합니다.

이러한 값에 대한 전체 JWS JSON 직렬화는 다음과 같습니다\(표시 목적으로만 값 내에 줄 바꿈이 있음\):

```text
     {
      "payload":
       "eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGF
        tcGxlLmNvbS9pc19yb290Ijp0cnVlfQ",
      "protected":"eyJhbGciOiJFUzI1NiJ9",
      "header":
       {"kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"},
      "signature":
       "DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8IS
        lSApmWQxfKTUJqPP3-Kg6NU1Q"
     }
```

---
# **Appendix B.  "x5c" (X.509 Certificate Chain) Example**

아래 JSON 배열은 섹션 4.1.6에 따라 "x5c"\(X.509 인증서 체인\) 헤더 매개변수의 값으로 사용될 수 있는 인증서 체인의 예입니다\(값 내에 줄 바꿈이 있는 것은 표시 목적일 뿐입니다\).

```text
     ["MIIE3jCCA8agAwIBAgICAwEwDQYJKoZIhvcNAQEFBQAwYzELMAkGA1UEBhMCVVM
       xITAfBgNVBAoTGFRoZSBHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR2
       8gRGFkZHkgQ2xhc3MgMiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjExM
       TYwMTU0MzdaFw0yNjExMTYwMTU0MzdaMIHKMQswCQYDVQQGEwJVUzEQMA4GA1UE
       CBMHQXJpem9uYTETMBEGA1UEBxMKU2NvdHRzZGFsZTEaMBgGA1UEChMRR29EYWR
       keS5jb20sIEluYy4xMzAxBgNVBAsTKmh0dHA6Ly9jZXJ0aWZpY2F0ZXMuZ29kYW
       RkeS5jb20vcmVwb3NpdG9yeTEwMC4GA1UEAxMnR28gRGFkZHkgU2VjdXJlIENlc
       nRpZmljYXRpb24gQXV0aG9yaXR5MREwDwYDVQQFEwgwNzk2OTI4NzCCASIwDQYJ
       KoZIhvcNAQEBBQADggEPADCCAQoCggEBAMQt1RWMnCZM7DI161+4WQFapmGBWTt
       wY6vj3D3HKrjJM9N55DrtPDAjhI6zMBS2sofDPZVUBJ7fmd0LJR4h3mUpfjWoqV
       Tr9vcyOdQmVZWt7/v+WIbXnvQAjYwqDL1CBM6nPwT27oDyqu9SoWlm2r4arV3aL
       GbqGmu75RpRSgAvSMeYddi5Kcju+GZtCpyz8/x4fKL4o/K1w/O5epHBp+YlLpyo
       7RJlbmr2EkRTcDCVw5wrWCs9CHRK8r5RsL+H0EwnWGu1NcWdrxcx+AuP7q2BNgW
       JCJjPOq8lh8BJ6qf9Z/dFjpfMFDniNoW1fho3/Rb2cRGadDAW/hOUoz+EDU8CAw
       EAAaOCATIwggEuMB0GA1UdDgQWBBT9rGEyk2xF1uLuhV+auud2mWjM5zAfBgNVH
       SMEGDAWgBTSxLDSkdRMEXGzYcs9of7dqGrU4zASBgNVHRMBAf8ECDAGAQH/AgEA
       MDMGCCsGAQUFBwEBBCcwJTAjBggrBgEFBQcwAYYXaHR0cDovL29jc3AuZ29kYWR
       keS5jb20wRgYDVR0fBD8wPTA7oDmgN4Y1aHR0cDovL2NlcnRpZmljYXRlcy5nb2
       RhZGR5LmNvbS9yZXBvc2l0b3J5L2dkcm9vdC5jcmwwSwYDVR0gBEQwQjBABgRVH
       SAAMDgwNgYIKwYBBQUHAgEWKmh0dHA6Ly9jZXJ0aWZpY2F0ZXMuZ29kYWRkeS5j
       b20vcmVwb3NpdG9yeTAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggE
       BANKGwOy9+aG2Z+5mC6IGOgRQjhVyrEp0lVPLN8tESe8HkGsz2ZbwlFalEzAFPI
       UyIXvJxwqoJKSQ3kbTJSMUA2fCENZvD117esyfxVgqwcSeIaha86ykRvOe5GPLL
       5CkKSkB2XIsKd83ASe8T+5o0yGPwLPk9Qnt0hCqU7S+8MxZC9Y7lhyVJEnfzuz9
       p0iRFEUOOjZv2kWzRaJBydTXRE4+uXR21aITVSzGh6O1mawGhId/dQb8vxRMDsx
       uxN89txJx9OjxUUAiKEngHUuHqDTMBqLdElrRhjZkAzVvb3du6/KFUJheqwNTrZ
       EjYx8WnM25sgVjOuH0aBsXBTWVU+4=",
      "MIIE+zCCBGSgAwIBAgICAQ0wDQYJKoZIhvcNAQEFBQAwgbsxJDAiBgNVBAcTG1Z
       hbGlDZXJ0IFZhbGlkYXRpb24gTmV0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIE
       luYy4xNTAzBgNVBAsTLFZhbGlDZXJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb
       24gQXV0aG9yaXR5MSEwHwYDVQQDExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8x
       IDAeBgkqhkiG9w0BCQEWEWluZm9AdmFsaWNlcnQuY29tMB4XDTA0MDYyOTE3MDY
       yMFoXDTI0MDYyOTE3MDYyMFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRoZS
       BHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR28gRGFkZHkgQ2xhc3MgM
       iBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAwDQYJKoZIhvcNAQEBBQADggEN
       ADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWizV3GgXne77ZtJ6XC
       APVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HFiH7Eux
       6wwdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLO
       tXiEqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWo
       riMYavx4A6lNf4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZ
       Eewo+YihfukEHU1jPEX44dMX4/7VpkI+EdOqXG68CAQOjggHhMIIB3TAdBgNVHQ

       4EFgQU0sSw0pHUTBFxs2HLPaH+3ahq1OMwgdIGA1UdIwSByjCBx6GBwaSBvjCBu
       zEkMCIGA1UEBxMbVmFsaUNlcnQgVmFsaWRhdGlvbiBOZXR3b3JrMRcwFQYDVQQK
       Ew5WYWxpQ2VydCwgSW5jLjE1MDMGA1UECxMsVmFsaUNlcnQgQ2xhc3MgMiBQb2x
       pY3kgVmFsaWRhdGlvbiBBdXRob3JpdHkxITAfBgNVBAMTGGh0dHA6Ly93d3cudm
       FsaWNlcnQuY29tLzEgMB4GCSqGSIb3DQEJARYRaW5mb0B2YWxpY2VydC5jb22CA
       QEwDwYDVR0TAQH/BAUwAwEB/zAzBggrBgEFBQcBAQQnMCUwIwYIKwYBBQUHMAGG
       F2h0dHA6Ly9vY3NwLmdvZGFkZHkuY29tMEQGA1UdHwQ9MDswOaA3oDWGM2h0dHA
       6Ly9jZXJ0aWZpY2F0ZXMuZ29kYWRkeS5jb20vcmVwb3NpdG9yeS9yb290LmNybD
       BLBgNVHSAERDBCMEAGBFUdIAAwODA2BggrBgEFBQcCARYqaHR0cDovL2NlcnRpZ
       mljYXRlcy5nb2RhZGR5LmNvbS9yZXBvc2l0b3J5MA4GA1UdDwEB/wQEAwIBBjAN
       BgkqhkiG9w0BAQUFAAOBgQC1QPmnHfbq/qQaQlpE9xXUhUaJwL6e4+PrxeNYiY+
       Sn1eocSxI0YGyeR+sBjUZsE4OWBsUs5iB0QQeyAfJg594RAoYC5jcdnplDQ1tgM
       QLARzLrUc+cb53S8wGd9D0VmsfSxOaFIqII6hR8INMqzW/Rn453HWkrugp++85j
       09VZw==",
      "MIIC5zCCAlACAQEwDQYJKoZIhvcNAQEFBQAwgbsxJDAiBgNVBAcTG1ZhbGlDZXJ
       0IFZhbGlkYXRpb24gTmV0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIEluYy4xNT
       AzBgNVBAsTLFZhbGlDZXJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb24gQXV0a
       G9yaXR5MSEwHwYDVQQDExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8xIDAeBgkq
       hkiG9w0BCQEWEWluZm9AdmFsaWNlcnQuY29tMB4XDTk5MDYyNjAwMTk1NFoXDTE
       5MDYyNjAwMTk1NFowgbsxJDAiBgNVBAcTG1ZhbGlDZXJ0IFZhbGlkYXRpb24gTm
       V0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIEluYy4xNTAzBgNVBAsTLFZhbGlDZ
       XJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb24gQXV0aG9yaXR5MSEwHwYDVQQD
       ExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8xIDAeBgkqhkiG9w0BCQEWEWluZm9
       AdmFsaWNlcnQuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDOOnHK5a
       vIWZJV16vYdA757tn2VUdZZUcOBVXc65g2PFxTXdMwzzjsvUGJ7SVCCSRrCl6zf
       N1SLUzm1NZ9WlmpZdRJEy0kTRxQb7XBhVQ7/nHk01xC+YDgkRoKWzk2Z/M/VXwb
       P7RfZHM047QSv4dk+NoS/zcnwbNDu+97bi5p9wIDAQABMA0GCSqGSIb3DQEBBQU
       AA4GBADt/UG9vUJSZSWI4OB9L+KXIPqeCgfYrx+jFzug6EILLGACOTb2oWH+heQ
       C1u+mNr0HZDzTuIYEZoDJJKPTEjlbVUjP9UNV+mWwD5MlM/Mtsq2azSiGM5bUMM
       j4QssxsodyamEwCW/POuZ6lcg5Ktz885hZo+L7tdEy8W9ViH0Pd"]
```

---
# **Appendix C.  Notes on Implementing base64url Encoding without Padding**

이 부록에서는 패딩을 사용하는 표준 base64 인코딩 및 디코딩 함수를 기반으로 패딩 없이 base64url 인코딩 및 디코딩 함수를 구현하는 방법을 설명합니다.

구체적으로, 이러한 함수를 구현하는 예시 C# 코드는 아래와 같습니다. 유사한 코드는 다른 언어에서도 사용할 수 있습니다.

```text
     static string base64urlencode(byte [] arg)
     {
       string s = Convert.ToBase64String(arg); // Regular base64 encoder
       s = s.Split('=')[0]; // Remove any trailing '='s
       s = s.Replace('+', '-'); // 62nd char of encoding
       s = s.Replace('/', '_'); // 63rd char of encoding
       return s;
     }

     static byte [] base64urldecode(string arg)
     {
       string s = arg;
       s = s.Replace('-', '+'); // 62nd char of encoding
       s = s.Replace('_', '/'); // 63rd char of encoding
       switch (s.Length % 4) // Pad with trailing '='s
       {
         case 0: break; // No pad chars in this case
         case 2: s += "=="; break; // Two pad chars
         case 3: s += "="; break; // One pad char
         default: throw new System.Exception(
           "Illegal base64url string!");
       }
       return Convert.FromBase64String(s); // Standard base64 decoder
     }
```

위의 예제 코드에 따르면 패딩이 없는 base64url 인코딩된 문자열을 패딩이 있는 문자열로 바꾸기 위해 패딩 없이 base64url로 인코딩된 문자열 끝에 추가해야 하는 '=' 패딩 문자의 수는 인코딩된 문자열의 길이에 대한 결정적 함수입니다. 구체적으로, 길이 mod 4가 0이면 패딩이 추가되지 않습니다. 길이 mod 4가 2이면 두 개의 '=' 패딩 문자가 추가됩니다. 길이 mod 4가 3이면 하나의 '=' 패딩 문자가 추가됩니다. 길이 mod 4가 1이면 입력이 잘못되었습니다.

인코딩되지 않은 값과 인코딩된 값 사이의 대응 예시는 다음과 같습니다. 아래 옥텟 시퀀스는 아래 문자열로 인코딩되고, 디코딩되면 옥텟 시퀀스가 재생성됩니다.

```text
   3 236 255 224 193
   A-z_4ME
```

---
# **Appendix D.  Notes on Key Selection**

이 부록에서는 JWS의 디지털 서명 또는 MAC을 검증하는 데 사용할 키를 선택하거나 JWE를 암호 해독하는 데 사용할 키를 선택하기 위한 가능한 알고리즘 세트를 설명합니다. 이 지침에서는 단일 알고리즘이 아닌 가능한 알고리즘 패밀리를 설명합니다. 왜냐하면 다른 맥락에서 모든 키 소스가 사용되지 않고, 다른 순서로 시도할 수 있으며, 때로는 수집된 모든 키가 시도되지 않기 때문입니다. 따라서 다른 알고리즘이 다른 애플리케이션 맥락에서 사용됩니다.

아래 단계는 설명 목적으로만 설명되었습니다. 특정 애플리케이션은 다른 알고리즘을 사용하거나 일부 단계를 다른 순서로 수행할 수 있으며 그럴 가능성이 높습니다. 특정 애플리케이션은 애플리케이션의 사용을 위해 프로파일링된 키 선택 방법이 하나 또는 두 개일 수 있으므로 사용할 키를 결정하는 훨씬 간단한 방법을 자주 사용합니다. 이 부록은 섹션 6의 키 위치에 대한 규범적 정보를 보완합니다.

이러한 알고리즘에는 다음 단계가 포함됩니다. 단계는 어떤 순서로든 수행할 수 있으며 별개로 취급할 필요가 없습니다. 예를 들어, 키를 찾으면 즉시 시도할 수 있으며, 모든 키를 수집한 후 시도할 필요가 없습니다.

1. 잠재적으로 적용 가능한 키 세트를 수집합니다. 키 소스에는 다음이 포함될 수 있습니다.

- \* 사용 중인 애플리케이션 프로토콜이 제공하는 키.

- \* "jku"\(JWK URL 설정\) 헤더 매개변수에서 참조하는 키입니다.

- \* "jwk"\(JSON 웹 키\) 헤더 매개변수가 제공하는 키입니다.

- \* "x5u" \(X.509 URL\) 헤더 매개변수가 참조하는 키입니다.

```text
       *  The key provided by the "x5c" (X.509 certificate chain) Header
          Parameter.
```

- \* 해당 애플리케이션에 적용 가능한 기타 키입니다.

- 다양한 키 소스에서 키를 수집하고 시도하는 순서는 일반적으로 애플리케이션에 따라 다릅니다. 예를 들어, 로컬 캐시와 같은 한 세트의 위치에서 모든 키를 시도한 후에 다른 위치에서 키를 수집하고 시도하는 경우가 많습니다.

1. 수집된 키 집합을 필터링합니다. 예를 들어, 일부 애플리케이션은 "kid"\(키 ID\) 또는 "x5t"\(X.509 인증서 SHA-1 지문\) 매개변수에서 참조하는 키만 사용합니다. 애플리케이션이 JWK "alg"\(알고리즘\), "use"\(공개 키 사용\) 또는 "key\_ops"\(키 작업\) 매개변수를 사용하는 경우 해당 매개변수의 부적절한 값을 가진 키는 제외됩니다. 또한 애플리케이션별 방식으로 특정 다른 멤버 값을 가진 키를 포함하거나 제외하도록 키를 필터링할 수 있습니다. 일부 애플리케이션의 경우 필터링이 적용되지 않습니다.

1. 수집된 키 집합을 정렬합니다. 예를 들어, "kid"\(키 ID\) 또는 "x5t"\(X.509 인증서 SHA-1 지문\) 매개변수에서 참조하는 키는 이러한 값이 없는 키보다 먼저 시도될 수 있습니다. 마찬가지로, 특정 멤버 값이 있는 키는 다른 멤버 값이 있는 키보다 먼저 정렬될 수 있습니다. 일부 애플리케이션의 경우 정렬이 적용되지 않습니다.

1. 키에 대한 신뢰 결정을 내립니다. 애플리케이션의 신뢰 기준을 충족하지 않는 키로 만든 서명은 허용되지 않습니다. 이러한 기준에는 키의 출처, TLS 인증서가 URL에서 검색된 키에 대해 유효성을 검사하는지 여부, X.509 인증서의 키가 유효한 인증서 체인에 의해 백업되는지 여부 및 애플리케이션에서 알고 있는 기타 정보가 포함될 수 있지만 이에 국한되지 않습니다.

1. 수집되고 필터링되거나 정렬된 키의 일부 또는 전부를 사용하여 JWS에 대한 서명 또는 MAC 검증을 시도하거나 JWE를 복호화합니다. 시도할 키 수에 제한이 적용될 수 있습니다. 이 프로세스는 일반적으로 성공적인 검증 또는 복호화 후에 종료됩니다.

일부 애플리케이션의 경우 키에 대한 신뢰 결정을 내리기 전에 서명 또는 MAC 유효성 검사를 수행하는 것이 합리적입니다. 유효성 검사에 실패한 키는 신뢰 결정이 필요하지 않기 때문입니다.

---
# **Appendix E.  Negative Test Case for "crit" Header Parameter**

준수 구현은 이해되지 않거나 처리할 수 없는 중요한 확장을 포함하는 입력을 거부해야 합니다. 다음 JWS는 모든 구현에서 거부해야 합니다. 이는 JWS가 이해하지 못하는 확장 헤더 매개변수 이름 "http://example.invalid/UNDEFINED"를 사용하기 때문입니다. 구현에서 이해하지 못하는 다른 헤더 매개변수 이름으로 "http://example.invalid/UNDEFINED" 값을 사용하는 다른 유사한 입력도 거부해야 합니다.

이 JWS에 대한 JWS 보호 헤더 값은 다음과 같습니다.

```text
     {"alg":"none",
      "crit":["http://example.invalid/UNDEFINED"],
      "http://example.invalid/UNDEFINED":true
     }
```

거부해야 하는 전체 JWS는 다음과 같습니다\(표시 목적으로만 줄 바꿈 포함\):

```text
     eyJhbGciOiJub25lIiwNCiAiY3JpdCI6WyJodHRwOi8vZXhhbXBsZS5jb20vVU5ERU
     ZJTkVEIl0sDQogImh0dHA6Ly9leGFtcGxlLmNvbS9VTkRFRklORUQiOnRydWUNCn0.
     RkFJTA.
```

---
# **Appendix F.  Detached Content**

일부 컨텍스트에서는 JWS에 포함되지 않은 콘텐츠의 무결성을 보호하는 것이 유용합니다. 이를 수행하는 한 가지 방법은 콘텐츠 표현을 페이로드로 사용하여 일반적인 방식으로 JWS를 만든 다음 JWS에서 페이로드 표현을 삭제하고 이 수정된 객체를 JWS가 아닌 수신자에게 보내는 것입니다. JWS Compact Serialization을 사용하는 경우 삭제는 두 번째 필드\(BASE64URL\(JWS Payload\)가 포함된\) 값을 빈 문자열로 바꿔서 수행됩니다. JWS JSON Serialization을 사용하는 경우 삭제는 "payload" 멤버를 삭제해서 수행됩니다. 이 방법은 수신자가 JWS에서 사용된 정확한 페이로드를 재구성할 수 있다고 가정합니다. 수정된 객체를 사용하려면 수신자가 수정된 객체에 페이로드 표현을 다시 삽입하여 JWS를 재구성하고 일반적인 방식으로 결과 JWS를 사용합니다. 이 방법은 JWS 라이브러리의 지원이 필요하지 않습니다. 애플리케이션은 표준 JWS 라이브러리의 입력과 출력을 수정하여 이 방법을 사용할 수 있기 때문입니다.

---
# **Acknowledgements**

JSON 콘텐츠 서명을 위한 솔루션은 이전에 Magic Signatures \[MagicSignatures\], JSON Simple Sign \[JSS\], Canvas Applications \[CanvasApp\]에서 탐색되었으며, 이는 모두 이 문서에 영향을 미쳤습니다.

JWS와 JWE 사양에 대한 초기 구현과 피드백을 제공해 준 Axel Nennker에게 감사드립니다.

이 사양은 수십 명의 적극적이고 헌신적인 참여자를 포함하는 JOSE 작업 그룹의 작업입니다. 특히, 다음 개인은 이 사양에 영향을 준 아이디어, 피드백 및 문구를 제공했습니다.

디르크 발판츠, 리차드 반스, 브라이언 캠벨, 알리사 쿠퍼, 브레노 데 메데이로스, 스티븐 패럴, 야론 Y. 골랜드, 딕 하트, 조 힐드브랜드, 제프 호지스, 러스 하우스리, 에드먼드 제이, 테로 키비넨, 벤 로리, 테드 레몬, 제임스 맨저, 맷 밀러, 캐슬린 모리아티, 토니 나달린, 히데키 나라, 악셀 넨커, 존 판저, 레이 폴크, 에마뉘엘 라비아르, 에릭 레스콜라, 피트 레스닉, 짐 샤드, 폴 타르잔, 하네스 초페니히, 숀 터너.

짐 샤드와 캐런 오도노휴는 JOSE 작업 그룹의 의장을 맡았고, 숀 터너, 스티븐 패럴, 캐슬린 모리아티는 이 사양을 작성하는 동안 보안 영역 책임자를 맡았습니다.

---
# **Authors' Addresses**

```text
   Michael B. Jones
   Microsoft

   EMail: mbj@microsoft.com
   URI:   http://self-issued.info/

   John Bradley
   Ping Identity

   EMail: ve7jtb@ve7jtb.com
   URI:   http://www.thread-safe.com/

   Nat Sakimura
   Nomura Research Institute

   EMail: n-sakimura@nri.co.jp
   URI:   http://nat.sakimura.org/
```


```text
﻿

Internet Engineering Task Force (IETF)                      W. Eddy, Ed.
STD: 7                                                       MTI Systems
Request for Comments: 9293                                   August 2022
Obsoletes: 793, 879, 2873, 6093, 6429, 6528,                            
           6691                                                         
Updates: 1011, 1122, 5961                                               
Category: Standards Track                                               
ISSN: 2070-1721

                  Transmission Control Protocol (TCP)
```

---
# **Abstract**

이 문서에서는 TCP\(전송 제어 프로토콜\)를 지정합니다. TCP는 인터넷 프로토콜 스택에서 중요한 전송 계층 프로토콜이며, 수십 년 동안 인터넷을 사용하고 성장하면서 지속적으로 발전해 왔습니다. 이 기간 동안 RFC 793에 지정된 대로 TCP에 여러 가지 변경 사항이 적용되었지만 이러한 내용은 단편적으로만 문서화되었습니다. 이 문서는 RFC 793의 프로토콜 사양과 함께 이러한 변경 사항을 수집하고 가져옵니다. 이 문서는 RFC 793과 RFC 793의 일부를 업데이트한 RFC 879, 2873, 6093, 6429, 6528 및 6691을 폐기합니다. RFC 1011 및 6691을 업데이트합니다. 1122이며 TCP 요구 사항을 다루는 문서 부분을 대체하는 것으로 간주되어야 합니다. 또한 SYN-RECEIVED 상태에 있는 동안 재설정 처리에 대한 간단한 설명을 추가하여 RFC 5961을 업데이트합니다. RFC 793의 TCP 헤더 제어 비트도 RFC 3168을 기반으로 업데이트되었습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9293에서 확인할 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2022 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

1. 목적 및 범위 2. 소개 2.1. 요구사항 언어 2.2. 주요 TCP 개념 3. 기능 사양 3.1. 헤더 형식 3.2. 특정 옵션 정의 3.2.1. 기타 공통 옵션 3.2.2. 실험적인 TCP 옵션 3.3. TCP 용어 개요 3.3.1. 주요 연결 상태 변수 3.3.2. 상태 머신 개요 3.4. 시퀀스 번호 3.4.1. 초기 시퀀스 번호 선택 3.4.2. 조용히 있어야 할 때를 아는 것 3.4.3. TCP 조용한 시간 개념 3.5. 연결 설정 3.5.1. 반개방 연결 및 기타 이상 현상 3.5.2. 리셋 생성 3.5.3. 재설정 처리 3.6. 연결 닫기 3.6.1. 반쯤 닫힌 연결 3.7. 분할 3.7.1. 최대 세그먼트 크기 옵션 3.7.2. 경로 MTU 검색 3.7.3. 가변 MTU 값을 갖는 인터페이스 3.7.4. 네이글 알고리즘 3.7.5. IPv6 점보그램 3.8. 데이터 통신 3.8.1. 재전송 시간 초과 3.8.2. TCP 혼잡 제어 3.8.3. TCP 연결 실패 3.8.4. TCP 연결 유지 3.8.5. 긴급정보 전달 3.8.6. 창 관리 3.9. 인터페이스 3.9.1. 사용자/TCP 인터페이스 3.9.2. TCP/하위 인터페이스 3.10. 이벤트 처리 3.10.1. 오픈콜 3.10.2. SEND 콜 3.10.3. 전화 받기 3.10.4. CLOSE 콜 3.10.5. ABORT 호출 3.10.6. 상태 통화 3.10.7. 세그먼트 도착 3.10.8. 시간 초과 4. 용어집 5. RFC 793의 변경 사항 6. IANA 고려 사항 7. 보안 및 개인 정보 보호 고려 사항 8. 참고 자료 8.1. 규범적 참고문헌 8.2. 참고 자료 부록 A. 기타 구현 참고 사항 A.1. IP 보안 구획 및 우선순위 A.1.1. 우선순위 A.1.2. MLS 시스템 A.2. 일련번호 검증 A.3. 네이글 수정 A.4. 로우 워터마크 설정 부록 B. TCP 요구 사항 요약 승인 작성자 주소

---
## **1.  Purpose and Scope**

1981년에 TCP\(전송 제어 프로토콜\)를 문서화하고 이전에 발표된 TCP 사양을 대체하는 RFC 793\[16\]이 출시되었습니다.

그 이후로 TCP는 널리 구현되었으며 인터넷의 수많은 응용 프로그램에 대한 전송 프로토콜로 사용되었습니다.

수십 년 동안 RFC 793과 기타 여러 문서가 결합되어 TCP \[49\]의 핵심 사양으로 사용되었습니다. 시간이 지남에 따라 RFC 793에 대해 수많은 정오표가 제출되었습니다. 또한 보안, 성능 및 기타 여러 측면에서 결함이 발견되어 해결되었습니다. 시간이 지남에 따라 여러 개별 문서에서 향상된 기능의 수가 늘어났습니다. 이는 기본 사양에 대한 포괄적인 업데이트로 함께 누적되지 않았습니다.

이 문서의 목적은 기본 TCP 기능 사양\(RFC 793\)에 적용된 모든 IETF 표준 추적 변경 사항 및 기타 설명을 통합하고 이를 사양의 업데이트된 버전으로 통합하는 것입니다.

일부 동반 문서는 TCP에서 사용되는 중요한 알고리즘\(예: 혼잡 제어\)에 대해 참조되지만 이 문서에 완전히 포함되지는 않았습니다. 이 기본 사양은 별도로 개발 및 통합되는 여러 추가 알고리즘과 함께 사용될 수 있으므로 이는 의식적인 선택입니다. 이 문서는 상호 운용을 위해 모든 TCP 구현이 지원해야 하는 공통 기반에 중점을 둡니다. 일부 추가 TCP 기능은 그 자체로 상당히 복잡해졌기 때문에\(예: 고급 손실 복구 및 혼잡 제어\) 향후 관련 문서에서는 유사하게 이러한 기능을 통합하려고 시도할 수 있습니다.

코드에 구현될 TCP 세그먼트 형식, 생성 및 처리 규칙을 설명하는 프로토콜 사양 외에도 RFC 793 및 기타 업데이트에는 독자가 프로토콜 설계 및 작동 측면을 이해할 수 있도록 정보를 제공하고 설명하는 텍스트도 포함되어 있습니다. 이 문서는 이 정보 텍스트를 변경하거나 업데이트하려고 시도하지 않으며 규범적인 프로토콜 사양 업데이트에만 중점을 둡니다. 이 문서는 해당하는 경우 중요한 설명과 근거가 포함된 문서에 대한 참조를 유지합니다.

이 문서는 적합성을 목적으로 기존 TCP 구현을 확인하고 새로운 구현을 작성하는 데 유용하게 사용되도록 만들어졌습니다.

---
## **2.  Introduction**

RFC 793에는 TCP 설계 목표에 대한 논의가 포함되어 있으며 연결 설정, 연결 종료 및 손실 복구를 위한 패킷 재전송의 예를 포함한 작동 예를 제공합니다.

이 문서는 최신 TCP 구현에서 예상되는 기본 기능을 설명하고 RFC 793의 프로토콜 사양을 대체합니다. RFC 793의 섹션 1 및 2에 있는 소개 및 철학 내용을 복제하거나 업데이트하려고 시도하지 않습니다. 작동 이론, 이론적 근거 및 설계 결정에 대한 자세한 논의. 이 문서는 프로토콜의 규범적인 동작에만 중점을 둡니다.

"TCP 로드맵"\[49\]은 TCP를 정의하고 다양한 중요한 알고리즘을 설명하는 RFC에 대한 보다 광범위한 가이드를 제공합니다. TCP 로드맵에는 이 문서에 지정된 기본 작업 이상으로 TCP의 성능 및 기타 측면을 개선하기 위해 적극 권장되는 개선 사항에 대한 섹션이 포함되어 있습니다. 일례로, 혼잡 제어\(예: \[8\]\) 구현은 TCP 요구 사항이지만 기본 상호 운용성에 영향을 주지 않는 많은 옵션과 가능성이 있기 때문에 그 자체로는 복잡한 주제이며 이 문서에서는 자세히 설명하지 않습니다. . 마찬가지로 오늘날 대부분의 TCP 구현에는 \[47\]의 고성능 확장이 포함되어 있지만 이 문서에서는 이러한 확장이 엄격히 요구되거나 논의되지 않습니다. TCP에 대한 다중 경로 고려 사항도 \[59\]에 별도로 지정되어 있습니다.

RFC 793의 변경 사항 목록은 섹션 5에 포함되어 있습니다.

---
### **2.1.  Requirements Language**

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 여기에 표시된 대로 모두 대문자로 표시되는 경우에만 BCP 14 \[3\] \[12\]에 설명된 대로 해석됩니다.\(MUST NOT\)

문서에서 RFC 2119 키워드를 사용할 때마다 구현 요구 사항을 요약한 부록 B에 개별적으로 레이블이 지정되고 참조됩니다.

"MUST"를 사용하는 문장은 "MUST-X"로 표시되며 X는 부록 B에서 참조할 때 요구 사항을 쉽게 찾을 수 있도록 하는 숫자 식별자입니다.\(MUST\)

마찬가지로, "SHOULD"를 사용하는 문장은 "SHLD-X"로, "MAY"는 "MAY-X"로, "RECOMMENDED"는 "REC-X"로 레이블이 지정됩니다.\(SHOULD\)

이 라벨링의 목적을 위해 "SHOULD NOT" 및 "MUST NOT"은 "SHOULD" 및 "MUST" 인스턴스와 동일하게 라벨링됩니다.\(MUST NOT\)

---
### **2.2.  Key TCP Concepts**

TCP는 애플리케이션에 안정적이고 순서대로 바이트 스트림 서비스를 제공합니다.

애플리케이션 바이트 스트림은 TCP 세그먼트를 통해 네트워크를 통해 전달되며, 각 TCP 세그먼트는 IP\(인터넷 프로토콜\) 데이터그램으로 전송됩니다.

TCP 신뢰성은 패킷 손실\(시퀀스 번호를 통해\)과 오류\(세그먼트별 체크섬을 통해\)를 감지하고 재전송을 통해 수정하는 것으로 구성됩니다.

TCP는 유니캐스트 데이터 전달을 지원합니다. 수정 없이 TCP를 성공적으로 사용할 수 있는 애니캐스트 애플리케이션이 있지만 하위 계층 전달 동작의 변경으로 인해 일부 불안정성의 위험이 있습니다\[46\].

TCP는 연결 지향적이지만 본질적으로 활성 감지 기능을 포함하지는 않습니다.

데이터 흐름은 TCP 연결을 통해 양방향으로 지원되지만 애플리케이션은 원하는 경우 단방향으로만 데이터를 자유롭게 보낼 수 있습니다.

TCP는 포트 번호를 사용하여 애플리케이션 서비스를 식별하고 호스트 간의 고유한 흐름을 다중화합니다.

다른 전송 프로토콜과 비교하여 TCP 기능에 대한 더 자세한 설명은 \[52\]의 섹션 3.1에서 찾을 수 있습니다. TCP 개발 동기와 인터넷 프로토콜 스택에서의 역할에 대한 자세한 설명은 \[16\]의 섹션 2와 TCP 사양의 이전 버전에서 찾을 수 있습니다.

---
## **3.  Functional Specification**
---
### **3.1.  Header Format**

TCP 세그먼트는 인터넷 데이터그램으로 전송됩니다. IP\(인터넷 프로토콜\) 헤더는 소스 및 대상 호스트 주소\[1\] \[13\]를 포함하여 여러 정보 필드를 전달합니다. TCP 헤더는 IP 헤더 다음에 나오며 TCP에 특정한 정보를 제공합니다. 이러한 구분으로 인해 TCP 이외의 호스트 수준 프로토콜이 존재할 수 있습니다. 인터넷 프로토콜 제품군의 초기 개발에서 IP 헤더 필드는 TCP의 일부였습니다.

이 문서에서는 TCP 헤더를 사용하는 TCP에 대해 설명합니다.

세그먼트의 사용자 데이터 뒤에 오는 TCP 헤더는 \[66\]의 스타일을 사용하여 다음과 같이 형식화됩니다.

```text
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Source Port          |       Destination Port        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        Sequence Number                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    Acknowledgment Number                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Data |       |C|E|U|A|P|R|S|F|                               |
      | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
      |       |       |R|E|G|K|H|T|N|N|                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Checksum            |         Urgent Pointer        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           [Options]                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               :
      :                             Data                              :
      :                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- 하나의 눈금 표시는 하나의 비트 위치를 나타냅니다.

```text
                        Figure 1: TCP Header Format

   where:

   Source Port:  16 bits
```

소스 포트 번호입니다.

```text
   Destination Port:  16 bits
```

대상 포트 번호입니다.

```text
   Sequence Number:  32 bits
```

이 세그먼트의 첫 번째 데이터 옥텟의 시퀀스 번호입니다\(SYN 플래그가 설정된 경우 제외\). SYN이 설정된 경우 시퀀스 번호는 ISN\(초기 시퀀스 번호\)이고 첫 번째 데이터 옥텟은 ISN+1입니다.

```text
   Acknowledgment Number:  32 bits
```

ACK 제어 비트가 설정된 경우 이 필드에는 세그먼트 송신자가 수신할 것으로 예상하는 다음 시퀀스 번호의 값이 포함됩니다. 연결이 설정되면 항상 전송됩니다.

```text
   Data Offset (DOffset):  4 bits
```

TCP 헤더의 32비트 단어 수입니다. 이는 데이터가 시작되는 위치를 나타냅니다. TCP 헤더\(옵션을 포함하는 헤더라도\)는 32비트 길이의 정수배입니다.

```text
   Reserved (Rsrvd):  4 bits
```

나중에 사용하기 위해 예약된 제어 비트 세트입니다. 생성된 세그먼트에서는 0이어야 하며, 송신 또는 수신 호스트에서 해당 향후 기능을 구현하지 않는 경우 수신된 세그먼트에서는 무시되어야 합니다.

제어 비트: 제어 비트는 "플래그"라고도 합니다. 할당은 "TCP 헤더 플래그" 레지스트리\[62\]에서 IANA에 의해 관리됩니다. 현재 할당된 제어 비트는 CWR, ECE, URG, ACK, PSH, RST, SYN 및 FIN입니다.

```text
     CWR:  1 bit

         Congestion Window Reduced (see [6]).

     ECE:  1 bit

         ECN-Echo (see [6]).

     URG:  1 bit
```

- 긴급 포인터 필드는 중요합니다.

```text
     ACK:  1 bit
```

- 승인 필드가 중요합니다.

```text
     PSH:  1 bit
```

- 푸시 기능\(섹션 3.9.1의 통화 보내기 설명 참조\).

```text
     RST:  1 bit
```

- 연결을 재설정하세요.

```text
     SYN:  1 bit

         Synchronize sequence numbers.

     FIN:  1 bit
```

- 발신자로부터 더 이상 데이터가 없습니다.

```text
   Window:  16 bits
```

이 세그먼트의 발신자가 수락하려는 승인 필드에 표시된 것으로 시작하는 데이터 옥텟의 수입니다. 창 크기 조정 확장을 사용하면 값이 이동됩니다 \[47\].

창 크기는 부호 없는 숫자로 처리되어야 합니다. 그렇지 않으면 큰 창 크기가 음수 창처럼 나타나고 TCP가 작동하지 않습니다\(MUST-1\). 구현 시 연결 레코드의 전송 및 수신 창 크기에 대해 32비트 필드를 예약하고 모든 창 계산을 32비트\(REC-1\)로 수행하는 것이 권장됩니다.\(MUST, SHOULD\)

```text
   Checksum:  16 bits
```

체크섬 필드는 헤더와 텍스트에 있는 모든 16비트 단어의 1의 보수 합계에 대한 16비트 1의 보수입니다. 체크섬 계산에서는 합산되는 데이터의 16비트 정렬을 보장해야 합니다. 세그먼트에 홀수의 헤더 및 텍스트 옥텟이 포함된 경우 체크섬 목적으로 16비트 단어를 형성하기 위해 마지막 옥텟 오른쪽에 0을 채워 정렬할 수 있습니다. 패드는 세그먼트의 일부로 전송되지 않습니다. 체크섬을 계산하는 동안 체크섬 필드 자체는 0으로 대체됩니다.

체크섬에는 개념적으로 TCP 헤더 앞에 붙는 의사 헤더\(그림 2\)도 포함됩니다. 의사 헤더는 IPv4의 경우 96비트이고 IPv6의 경우 320비트입니다. 체크섬에 의사 헤더를 포함하면 잘못 라우팅된 세그먼트로부터 TCP 연결을 보호할 수 있습니다. 이 정보는 IP 헤더로 전달되며 IP 계층의 TCP 구현에 의한 호출 결과나 인수로 TCP/네트워크 인터페이스를 통해 전송됩니다.

```text
                     +--------+--------+--------+--------+
                     |           Source Address          |
                     +--------+--------+--------+--------+
                     |         Destination Address       |
                     +--------+--------+--------+--------+
                     |  zero  |  PTCL  |    TCP Length   |
                     +--------+--------+--------+--------+

                         Figure 2: IPv4 Pseudo-header

     Pseudo-header components for IPv4:
       Source Address:  the IPv4 source address in network byte order

       Destination Address:  the IPv4 destination address in network
          byte order

       zero:  bits set to zero

       PTCL:  the protocol number from the IP header
```

- TCP 길이: TCP 헤더 길이에 옥텟 단위의 데이터 길이를 더한 값\(명시적으로 전송된 수량은 아니지만 계산됨\)이며 의사 헤더의 12옥텟은 계산되지 않습니다.

IPv6의 경우 의사 헤더는 RFC 8200 \[13\]의 섹션 8.1에 정의되어 있으며 IPv6 소스 주소와 대상 주소, 상위 계층 패킷 길이\(IPv4 의사 헤더의 TCP 길이와 동등한 32비트 값\)를 포함합니다. 헤더\), 3바이트의 제로 패딩, IPv6와 TCP 사이에 확장 헤더가 있는 경우 IPv6 헤더 값과 다른 Next Header 값이 있습니다.

TCP 체크섬은 선택 사항이 아닙니다. 발신자는 이를 생성해야 하며\(MUST-2\), 수신자는 이를 확인해야 합니다\(MUST-3\).\(MUST\)

```text
   Urgent Pointer:  16 bits
```

이 필드는 긴급 포인터의 현재 값을 이 세그먼트의 시퀀스 번호에서 양수 오프셋으로 전달합니다. 긴급 포인터는 긴급 데이터 뒤에 오는 옥텟의 시퀀스 번호를 가리킵니다. 이 필드는 URG 제어 비트가 설정된 세그먼트에서만 해석됩니다.

옵션: \[TCP 옵션\]; size\(옵션\) == \(DOffset-5\)\*32; DOffset \> 5인 경우에만 존재합니다. 이 크기 표현식에는 존재하는 실제 옵션 뒤에 오는 패딩도 포함됩니다.

옵션은 TCP 헤더 끝의 공간을 차지할 수 있으며 길이는 8비트의 배수입니다. 모든 옵션이 체크섬에 포함됩니다. 옵션은 모든 옥텟 경계에서 시작할 수 있습니다. 옵션 형식에는 두 가지 경우가 있습니다.

사례 1: 옵션 종류의 단일 옥텟.

사례 2: 옵션 종류\(Kind\)의 옥텟, 옵션 길이의 옥텟, 실제 옵션-데이터 옥텟.

옵션 길이는 옵션 종류와 옵션 길이의 두 옥텟과 옵션 데이터 옥텟을 계산합니다.

옵션 목록은 데이터 오프셋 필드가 암시하는 것보다 짧을 수 있습니다. 옵션 목록 끝 옵션 이후의 헤더 내용은 0의 헤더 패딩이어야 합니다\(MUST-69\).\(MUST\)

현재 정의된 모든 옵션 목록은 IANA \[62\]에 의해 관리되며, 각 옵션은 표시된 대로 다른 RFC에 정의되어 있습니다. 이 세트에는 여러 동시 사용을 지원하도록 확장할 수 있는 실험적 옵션이 포함되어 있습니다\[45\].

주어진 TCP 구현은 현재 정의된 모든 옵션을 지원할 수 있지만 다음 옵션은 반드시 지원되어야 합니다\(MUST-4 -- 참고 최대 세그먼트 크기 옵션 지원은 섹션 3.7.1의 MUST-14의 일부이기도 함\).\(MUST\)

```text
               +======+========+============================+
               | Kind | Length | Meaning                    |
               +======+========+============================+
               | 0    | -      | End of Option List Option. |
               +------+--------+----------------------------+
               | 1    | -      | No-Operation.              |
               +------+--------+----------------------------+
               | 2    | 4      | Maximum Segment Size.      |
               +------+--------+----------------------------+

                       Table 1: Mandatory Option Set
```

이러한 옵션은 섹션 3.2에 자세히 지정되어 있습니다.

TCP 구현은 모든 세그먼트에서 TCP 옵션을 수신할 수 있어야 합니다\(MUST-5\).\(MUST\)

TCP 구현은 옵션에 길이 필드가 있다고 가정할 때 구현하지 않은 모든 TCP 옵션을 오류 없이 무시해야 합니다\(MUST-6\). EOL\(옵션 목록 끝 옵션\) 및 NOP\(No-Operation\)를 제외한 모든 TCP 옵션에는 모든 향후 옵션\(MUST-68\)을 포함하여 길이 필드가 있어야 합니다. TCP 구현은 잘못된 옵션 길이\(예: 0\)를 처리하도록 준비되어야 합니다. 제안된 절차는 연결을 재설정하고 오류 원인을 기록하는 것입니다\(MUST-7\).\(MUST, MUST, MUST\)

참고: \[65\]와 같은 TCP 옵션에 사용 가능한 공간을 확장하기 위한 작업이 진행 중입니다.

```text
   Data:  variable length
```

TCP 세그먼트에 의해 전달되는 사용자 데이터.

---
### **3.2.  Specific Option Definitions**

필수 옵션 세트에 포함된 TCP 옵션은 옵션 목록 끝 옵션, 무작동 옵션, 최대 세그먼트 크기 옵션 중 하나입니다.

옵션 목록 끝 옵션의 형식은 다음과 같습니다.

```text
       0
       0 1 2 3 4 5 6 7
      +-+-+-+-+-+-+-+-+
      |       0       |
      +-+-+-+-+-+-+-+-+

   where:

   Kind:  1 byte; Kind == 0.
```

이 옵션 코드는 옵션 목록의 끝을 나타냅니다. 이는 데이터 오프셋 필드에 따라 TCP 헤더의 끝과 일치하지 않을 수 있습니다. 이는 각 옵션의 끝이 아닌 모든 옵션의 끝에서 사용되며, 옵션의 끝이 TCP 헤더의 끝과 일치하지 않는 경우에만 사용해야 합니다.

무작동 옵션의 형식은 다음과 같습니다.

```text
       0
       0 1 2 3 4 5 6 7
      +-+-+-+-+-+-+-+-+
      |       1       |
      +-+-+-+-+-+-+-+-+

   where:

   Kind:  1 byte; Kind == 1.
```

예를 들어, 단어 경계에서 후속 옵션의 시작 부분을 정렬하기 위해 이 옵션 코드를 옵션 사이에 사용할 수 있습니다. 발신자가 이 옵션을 사용한다는 보장은 없으므로 수신자는 단어 경계에서 시작하지 않더라도 옵션을 처리할 준비를 해야 합니다\(MUST-64\).\(MUST\)

최대 세그먼트 크기 옵션의 형식은 다음과 같습니다.

```text
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       2       |     Length    |   Maximum Segment Size (MSS)  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   where:

   Kind:  1 byte; Kind == 2.
```

이 옵션이 있으면 이 세그먼트를 보내는 TCP 끝점에서 최대 수신 세그먼트 크기를 전달합니다. 이 값은 IP 리어셈블리 제한에 의해 제한됩니다. 이 필드는 초기 연결 요청\(즉, SYN 제어 비트가 설정된 세그먼트\)에서 전송될 수 있으며 다른 세그먼트에서는 전송되어서는 안 됩니다\(MUST-65\). 이 옵션을 사용하지 않으면 모든 세그먼트 크기가 허용됩니다. 이 옵션에 대한 자세한 설명은 섹션 3.7.1에 나와 있습니다.\(MUST NOT\)

```text
   Length:  1 byte; Length == 4.
```

옵션의 길이\(바이트\)입니다.

```text
   Maximum Segment Size (MSS):  2 bytes.
```

이 세그먼트를 보내는 TCP 끝점의 최대 수신 세그먼트 크기입니다.

---
#### **3.2.1.  Other Common Options**

추가 RFC는 고성능을 구현하는 데 권장되지만 기본 TCP 상호 운용성에는 필요하지 않은 일반적으로 사용되는 몇 가지 다른 옵션을 정의합니다. TCP SACK\(Selective Acknowledgement\) 옵션\[22\]\[26\], TCP Timestamp\(TS\) 옵션\[47\], TCP Window Scale\(WS\) 옵션\[47\]이 있다.

---
#### **3.2.2.  Experimental TCP Options**

실험적인 TCP 옵션 값은 \[30\]에 정의되어 있으며 \[45\]에서는 이러한 실험적인 값에 대한 현재 권장 사용법을 설명합니다.

---
### **3.3.  TCP Terminology Overview**

이 섹션에는 문서의 나머지 부분에서 자세한 프로토콜 작동을 이해하는 데 필요한 주요 용어에 대한 개요가 포함되어 있습니다. 4절에 용어집이 있습니다.

---
#### **3.3.1.  Key Connection State Variables**

TCP 구현의 동작을 자세히 논의하기 전에 몇 가지 자세한 용어를 소개해야 합니다. TCP 연결을 유지하려면 여러 변수의 상태를 유지해야 합니다. 우리는 이러한 변수가 전송 제어 블록\(TCB\)이라는 연결 기록에 저장된다고 생각합니다. TCB에 저장된 변수 중에는 로컬 및 원격 IP 주소와 포트 번호, IP 보안 수준, 연결 구획\(부록 A.1 참조\), 사용자의 송신 및 수신 버퍼에 대한 포인터, 재전송 대기열에 대한 포인터가 있습니다. 현재 세그먼트로 이동합니다. 또한, 송신 및 수신 시퀀스 번호와 관련된 여러 변수가 TCB에 저장됩니다.

```text
    +==========+=====================================================+
    | Variable | Description                                         |
    +==========+=====================================================+
    | SND.UNA  | send unacknowledged                                 |
    +----------+-----------------------------------------------------+
    | SND.NXT  | send next                                           |
    +----------+-----------------------------------------------------+
    | SND.WND  | send window                                         |
    +----------+-----------------------------------------------------+
    | SND.UP   | send urgent pointer                                 |
    +----------+-----------------------------------------------------+
    | SND.WL1  | segment sequence number used for last window update |
    +----------+-----------------------------------------------------+
    | SND.WL2  | segment acknowledgment number used for last window  |
    |          | update                                              |
    +----------+-----------------------------------------------------+
    | ISS      | initial send sequence number                        |
    +----------+-----------------------------------------------------+

                     Table 2: Send Sequence Variables

              +==========+=================================+
              | Variable | Description                     |
              +==========+=================================+
              | RCV.NXT  | receive next                    |
              +----------+---------------------------------+
              | RCV.WND  | receive window                  |
              +----------+---------------------------------+
              | RCV.UP   | receive urgent pointer          |
              +----------+---------------------------------+
              | IRS      | initial receive sequence number |
              +----------+---------------------------------+

                   Table 3: Receive Sequence Variables
```

다음 다이어그램은 이러한 변수 중 일부를 시퀀스 공간과 연관시키는 데 도움이 될 수 있습니다.

```text
                      1         2          3          4
                 ----------|----------|----------|----------
                        SND.UNA    SND.NXT    SND.UNA
                                             +SND.WND
```

1 - 승인된 이전 시퀀스 번호

- 2 - 승인되지 않은 데이터의 시퀀스 번호 3 - 새로운 데이터 전송에 허용되는 시퀀스 번호 4 - 아직 허용되지 않는 향후 시퀀스 번호

```text
                       Figure 3: Send Sequence Space
```

전송 창은 그림 3에서 3으로 표시된 시퀀스 공간의 일부입니다.

```text
                          1          2          3
                      ----------|----------|----------
                             RCV.NXT    RCV.NXT
                                       +RCV.WND
```

1 - 승인된 이전 시퀀스 번호

- 2 - 새로운 수신에 허용되는 시퀀스 번호 3 - 아직 허용되지 않는 향후 시퀀스 번호

```text
                      Figure 4: Receive Sequence Space
```

수신 창은 그림 4에서 2로 표시된 시퀀스 공간의 일부입니다.

현재 세그먼트의 필드에서 해당 값을 가져오는 토론에서 자주 사용되는 일부 변수도 있습니다.

```text
               +==========+===============================+
               | Variable | Description                   |
               +==========+===============================+
               | SEG.SEQ  | segment sequence number       |
               +----------+-------------------------------+
               | SEG.ACK  | segment acknowledgment number |
               +----------+-------------------------------+
               | SEG.LEN  | segment length                |
               +----------+-------------------------------+
               | SEG.WND  | segment window                |
               +----------+-------------------------------+
               | SEG.UP   | segment urgent pointer        |
               +----------+-------------------------------+

                    Table 4: Current Segment Variables
```

---
#### **3.3.2.  State Machine Overview**

연결은 수명 동안 일련의 상태를 통해 진행됩니다. 상태는 LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT 및 가상 상태 CLOSED입니다. CLOSED는 TCB가 없어 연결이 없는 상태를 나타내므로 허구입니다. 간략하게 상태의 의미는 다음과 같습니다.

LISTEN - 원격 TCP 피어 및 포트의 연결 요청을 기다리는 것을 나타냅니다.

SYN-SENT - 연결 요청을 보낸 후 일치하는 연결 요청을 기다리는 것을 나타냅니다.

SYN-RECEIVED - 연결 요청을 수신하고 보낸 후 연결 요청 확인 확인을 기다리는 것을 나타냅니다.

ESTABLISHED - 열린 연결을 나타내며, 수신된 데이터가 사용자에게 전달될 수 있습니다. 연결의 데이터 전송 단계에 대한 정상 상태입니다.

FIN-WAIT-1 - 원격 TCP 피어의 연결 종료 요청을 기다리는 중이거나 이전에 보낸 연결 종료 요청에 대한 승인을 나타냅니다.

FIN-WAIT-2 - 원격 TCP 피어의 연결 종료 요청을 기다리는 것을 나타냅니다.

CLOSE-WAIT - 로컬 사용자의 연결 종료 요청을 기다리는 것을 나타냅니다.

CLOSING - 원격 TCP 피어로부터 연결 종료 요청 승인을 기다리는 것을 나타냅니다.

LAST-ACK - 승인을 기다리는 것을 나타냅니다.

- 이전에 원격 TCP 피어로 전송된 연결 종료 요청\(원격 TCP 피어로 전송된 이 종료 요청에는 이미 원격 TCP 피어에서 전송된 종료 요청에 대한 승인이 포함되어 있음\)

TIME-WAIT - 원격 TCP 피어가 연결 종료 요청에 대한 승인을 받았는지 확인하고 이전 연결에서 지연된 세그먼트로 인해 새 연결이 영향을 받는 것을 방지하기 위해 충분한 시간이 지날 때까지 기다리는 것을 나타냅니다.

CLOSED - 연결 상태가 전혀 없음을 나타냅니다.

TCP 연결은 이벤트에 대한 응답으로 한 상태에서 다른 상태로 진행됩니다. 이벤트는 사용자 호출, OPEN, SEND, RECEIVE, CLOSE, ABORT 및 STATUS입니다. 들어오는 세그먼트, 특히 SYN, ACK, RST 및 FIN 플래그를 포함하는 세그먼트; 그리고 시간 초과.

OPEN 호출은 연결 설정을 적극적으로 추구할지, 아니면 수동적으로 기다릴지를 지정합니다.

수동 OPEN 요청은 연결 시작을 시도하는 활성 OPEN과 달리 프로세스가 들어오는 연결 요청을 수락하려고 함을 의미합니다.

그림 5의 상태 다이어그램은 원인 이벤트 및 결과 동작과 함께 상태 변경만 설명하지만 오류 조건이나 상태 변경과 연결되지 않은 동작은 다루지 않습니다. 이후 섹션에서는 이벤트에 대한 TCP 구현의 반응에 대해 더 자세히 설명합니다. 일부 상태 이름은 문서의 다른 곳에 나타나는 방식과 다르게 다이어그램에서 약어로 표시되거나 하이픈으로 연결됩니다.

참고 사항: 이 다이어그램은 요약일 뿐이므로 전체 사양으로 간주해서는 안 됩니다. 많은 세부 사항이 포함되어 있지 않습니다.

```text
                               +---------+ ---------\      active OPEN
                               |  CLOSED |            \    -----------
                               +---------+<---------\   \   create TCB
                                 |     ^              \   \  snd SYN
                    passive OPEN |     |   CLOSE        \   \
                    ------------ |     | ----------       \   \
                     create TCB  |     | delete TCB         \   \
                                 V     |                      \   \
             rcv RST (note 1)  +---------+            CLOSE    |    \
          -------------------->|  LISTEN |          ---------- |     |
         /                     +---------+          delete TCB |     |
        /           rcv SYN      |     |     SEND              |     |
       /           -----------   |     |    -------            |     V
   +--------+      snd SYN,ACK  /       \   snd SYN          +--------+
   |        |<-----------------           ------------------>|        |
   |  SYN   |                    rcv SYN                     |  SYN   |
   |  RCVD  |<-----------------------------------------------|  SENT  |
   |        |                  snd SYN,ACK                   |        |
   |        |------------------           -------------------|        |
   +--------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +--------+
      |         --------------   |     |   -----------
      |                x         |     |     snd ACK
      |                          V     V
      |  CLOSE                 +---------+
      | -------                |  ESTAB  |
      | snd FIN                +---------+
      |                 CLOSE    |     |    rcv FIN
      V                -------   |     |    -------
   +---------+         snd FIN  /       \   snd ACK         +---------+
   |  FIN    |<----------------          ------------------>|  CLOSE  |
   | WAIT-1  |------------------                            |   WAIT  |
   +---------+          rcv FIN  \                          +---------+
     | rcv ACK of FIN   -------   |                          CLOSE  |
     | --------------   snd ACK   |                         ------- |
     V        x                   V                         snd FIN V
   +---------+               +---------+                    +---------+
   |FINWAIT-2|               | CLOSING |                    | LAST-ACK|
   +---------+               +---------+                    +---------+
     |              rcv ACK of FIN |                 rcv ACK of FIN |
     |  rcv FIN     -------------- |    Timeout=2MSL -------------- |
     |  -------            x       V    ------------        x       V
      \ snd ACK              +---------+delete TCB          +---------+
        -------------------->|TIME-WAIT|------------------->| CLOSED  |
                             +---------+                    +---------+

                   Figure 5: TCP Connection State Diagram
```

그림 5에는 다음 참고 사항이 적용됩니다.

참고 1: RST 수신 시 SYN-RECEIVED에서 LISTEN으로의 전환은 수동 OPEN 이후 SYN-RECEIVED에 도달한 경우에 따라 달라집니다.

참고 2: FIN이 수신되고 로컬 FIN도 승인된 경우 그림에서는 FIN-WAIT-1에서 TIME-WAIT로의 전환이 생략됩니다.

참고 3: RST는 TIME-WAIT로의 해당 전환이 있는 모든 상태에서 전송될 수 있습니다\(이유는 \[70\] 참조\). 이러한 전환은 명시적으로 표시되지 않습니다. 그렇지 않으면 다이어그램을 읽기가 매우 어려워집니다. 마찬가지로 어떤 상태에서든 RST를 수신하면 LISTEN 또는 CLOSED로 전환되지만 가독성을 위해 다이어그램에서는 이 내용도 생략됩니다.

---
### **3.4.  Sequence Numbers**

디자인의 기본 개념은 TCP 연결을 통해 전송되는 모든 데이터 옥텟에 시퀀스 번호가 있다는 것입니다. 모든 옥텟은 순서가 지정되어 있으므로 각각을 인식할 수 있습니다. 사용된 승인 메커니즘은 누적되므로 시퀀스 번호 X의 승인은 X를 포함하지 않는 최대 옥텟이 모두 수신되었음을 나타냅니다. 이 메커니즘을 사용하면 재전송이 있을 때 간단한 중복 감지가 가능합니다. 세그먼트 내 옥텟의 번호 지정 방식은 다음과 같습니다. 헤더 바로 다음의 첫 번째 데이터 옥텟이 가장 낮은 번호가 지정되고 다음 옥텟에는 연속적으로 번호가 지정됩니다.

실제 시퀀스 번호 공간은 크더라도 유한하다는 점을 기억하는 것이 중요합니다. 이 공간의 범위는 0에서 2^32 - 1입니다. 공간은 유한하므로 시퀀스 번호를 다루는 모든 산술은 2^32 모듈로 수행되어야 합니다. 이 부호 없는 산술은 2^32 - 1에서 0으로 다시 순환할 때 시퀀스 번호의 관계를 유지합니다. 컴퓨터 모듈로 연산에는 몇 가지 미묘한 부분이 있으므로 이러한 값의 비교를 프로그래밍할 때는 세심한 주의가 필요합니다. "=<" 기호는 "작거나 같음"\(모듈로 2^32\)을 의미합니다.

TCP 구현에서 수행해야 하는 일반적인 종류의 시퀀스 번호 비교는 다음과 같습니다.

\(a\) 확인이 전송되었지만 아직 확인되지 않은 일부 시퀀스 번호를 참조하는지 결정합니다.

\(b\) 세그먼트가 차지하는 모든 시퀀스 번호가 확인되었는지 확인합니다\(예: 재전송 큐에서 세그먼트를 제거하기 위해\).

\(c\) 들어오는 세그먼트에 예상되는 시퀀스 번호가 포함되어 있는지 확인합니다\(즉, 세그먼트가 수신 창과 "겹친다"\).

데이터 전송에 대한 응답으로 TCP 끝점은 승인을 받습니다. 승인을 처리하려면 다음 비교가 필요합니다.

```text
      SND.UNA = oldest unacknowledged sequence number
```

- SND.NXT = 전송될 다음 시퀀스 번호

```text
      SEG.ACK = acknowledgment from the receiving TCP peer (next
      sequence number expected by the receiving TCP peer)
```

- SEG.SEQ = 세그먼트의 첫 번째 시퀀스 번호

```text
      SEG.LEN = the number of octets occupied by the data in the segment
      (counting SYN and FIN)
```

- SEG.SEQ+SEG.LEN-1 = 세그먼트의 마지막 시퀀스 번호

새로운 승인\("허용 가능한 승인"이라고 함\)은 아래 불평등이 적용되는 승인입니다.

```text
      SND.UNA < SEG.ACK =< SND.NXT
```

재전송 큐의 세그먼트는 해당 시퀀스 번호와 길이의 합이 수신 세그먼트의 승인 값보다 작거나 같을 경우 완전히 승인됩니다.

데이터가 수신되면 다음과 같은 비교가 필요합니다.

- RCV.NXT = 수신 세그먼트에서 예상되는 다음 시퀀스 번호이며 수신 창의 왼쪽 또는 아래쪽 가장자리입니다.

- RCV.NXT+RCV.WND-1 = 수신 세그먼트에서 예상되는 마지막 시퀀스 번호이며 수신 창의 오른쪽 또는 위쪽 가장자리입니다.

- SEG.SEQ = 들어오는 세그먼트가 차지하는 첫 번째 시퀀스 번호

- SEG.SEQ+SEG.LEN-1 = 들어오는 세그먼트가 차지하는 마지막 시퀀스 번호

세그먼트는 다음과 같은 경우 유효한 수신 시퀀스 공간의 일부를 차지하는 것으로 판단됩니다.

```text
      RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

   or

      RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
```

이 테스트의 첫 번째 부분에서는 세그먼트의 시작 부분이 창에 속하는지 확인하고, 테스트의 두 번째 부분에서는 세그먼트의 끝이 창에 속하는지 확인합니다. 세그먼트가 테스트의 두 부분 중 하나를 통과하면 창에 데이터가 포함됩니다.

실제로는 이것보다 조금 더 복잡합니다. 창과 길이가 0인 세그먼트로 인해 수신 세그먼트를 수용할 수 있는 네 가지 경우가 있습니다.

```text
       +=========+=========+======================================+
       | Segment | Receive | Test                                 |
       | Length  | Window  |                                      |
       +=========+=========+======================================+
       | 0       | 0       | SEG.SEQ = RCV.NXT                    |
       +---------+---------+--------------------------------------+
       | 0       | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |
       +---------+---------+--------------------------------------+
       | >0      | 0       | not acceptable                       |
       +---------+---------+--------------------------------------+
       | >0      | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |
       |         |         |                                      |
       |         |         | or                                   |
       |         |         |                                      |
       |         |         | RCV.NXT =< SEG.SEQ+SEG.LEN-1 <       |
       |         |         | RCV.NXT+RCV.WND                      |
       +---------+---------+--------------------------------------+

                   Table 5: Segment Acceptability Tests
```

수신 창이 0이면 ACK 세그먼트를 제외하고는 어떤 세그먼트도 허용되지 않아야 합니다. 따라서 TCP 구현에서는 데이터를 전송하고 ACK를 수신하는 동안 제로 수신 창을 유지하는 것이 가능합니다. TCP 수신기는 수신 창이 0인 경우에도 모든 수신 세그먼트의 RST 및 URG 필드를 처리해야 합니다\(MUST-66\).\(MUST\)

특정 제어 정보도 보호하기 위해 번호 매기기 체계를 활용했습니다. 이는 혼란 없이 재전송 및 승인될 수 있도록 시퀀스 공간에 일부 제어 플래그를 암시적으로 포함함으로써 달성됩니다\(즉, 하나의 제어 복사본만 작동됩니다\). 제어 정보는 세그먼트 데이터 공간에 물리적으로 전달되지 않습니다. 결과적으로 제어에 암시적으로 시퀀스 번호를 할당하는 규칙을 채택해야 합니다. SYN 및 FIN은 이러한 보호가 필요한 유일한 컨트롤이며 이러한 컨트롤은 연결을 열고 닫을 때만 사용됩니다. 시퀀스 번호 목적으로 SYN은 발생하는 세그먼트의 첫 번째 실제 데이터 옥텟 이전에 발생하는 것으로 간주되는 반면, FIN은 발생하는 세그먼트의 마지막 실제 데이터 옥텟 이후에 발생하는 것으로 간주됩니다. 세그먼트 길이\(SEG.LEN\)에는 데이터 및 시퀀스 공간 점유 컨트롤이 모두 포함됩니다. SYN이 있는 경우 SEG.SEQ는 SYN의 시퀀스 번호입니다.

---
#### **3.4.1.  Initial Sequence Number Selection**

연결은 한 쌍의 소켓으로 정의됩니다. 연결을 재사용할 수 있습니다. 연결의 새로운 인스턴스를 연결의 화신이라고 합니다. 이로 인해 발생하는 문제는 "TCP 구현이 이전 연결 구현에서 중복된 세그먼트를 어떻게 식별합니까?"입니다. 이 문제는 연결이 빠르게 연속적으로 열리고 닫히는 경우 또는 메모리 손실로 인해 연결이 끊어졌다가 다시 설정되는 경우에 분명해집니다. 이를 지원하기 위해 TIME-WAIT 상태는 연결 재사용 속도를 제한하는 반면, 아래에 설명된 초기 시퀀스 번호 선택은 들어오는 패킷이 어떤 연결 구현에 해당하는지에 대한 모호성을 방지합니다.

혼란을 피하기 위해 동일한 시퀀스 번호가 이전 구현의 네트워크에 계속 존재할 수 있는 동안 연결의 한 구현에서 세그먼트가 사용되는 것을 방지해야 합니다. 우리는 TCP 엔드포인트가 지금까지 사용해 온 시퀀스 번호에 대한 모든 지식을 잃어버린 경우에도 이를 보장하고 싶습니다. 새로운 연결이 생성되면 새로운 32비트 ISN을 선택하는 초기 시퀀스 번호\(ISN\) 생성기가 사용됩니다. 경로를 벗어난 공격자가 ISN 값을 예측하거나 추측할 수 있는 경우 보안 문제가 발생합니다\[42\].

TCP 초기 시퀀스 번호는 느슨하게 "시계"라고 알려진 래핑될 때까지 단조롭게 증가하는 숫자 시퀀스에서 생성됩니다. 이 클록은 일반적으로 약 4마이크로초마다 적어도 한 번씩 증가하는 32비트 카운터입니다. 하지만 실시간이거나 정확하다고 가정되지 않으며 재부팅 후에도 지속될 필요가 없습니다. 클록 구성 요소는 MSL\(최대 세그먼트 수명\)을 사용하여 생성된 ISN이 MSL보다 훨씬 긴 약 4.55시간마다 주기 때문에 고유하도록 보장하기 위한 것입니다. 연결이 시작되고 시퀀스 번호가 MSL 내에서 겹치도록 빠르게 증가하는 높은 데이터 속도를 지원하는 최신 네트워크의 경우 나중에 섹션 3.4.3에서 언급한 대로 타임스탬프 옵션을 구현하는 것이 좋습니다.

TCP 구현은 초기 시퀀스 번호\(MUST-8\)의 클럭 기반 선택을 위해 위 유형의 "클럭"을 사용해야 하며 다음 표현식을 사용하여 초기 시퀀스 번호를 생성해야 합니다\(SHOULD\).\(MUST\)

```text
   ISN = M + F(localip, localport, remoteip, remoteport, secretkey)
```

여기서 M은 4마이크로초 타이머이고, F\(\)는 연결 식별 매개변수\("localip, localport, Remoteip, Remoteport"\)와 비밀 키\("secretkey"\)\(SHLD-1\)의 의사 난수 함수\(PRF\)입니다. F\(\)는 외부에서 계산할 수 없어야 합니다\(MUST-9\). 그렇지 않으면 공격자가 다른 연결에 사용되는 ISN의 시퀀스 번호를 계속 추측할 수 있습니다. PRF는 TCP 연결 매개변수와 일부 비밀 데이터를 연결한 암호화 해시로 구현될 수 있습니다. 특정 해시 알고리즘 선택 및 비밀 키 데이터 관리에 대한 논의는 \[42\]의 섹션 3을 참조하세요.\(MUST NOT\)

각 연결에는 송신 시퀀스 번호와 수신 시퀀스 번호가 있습니다. 초기 전송 시퀀스 번호\(ISS\)는 데이터 전송 TCP 피어에 의해 선택되고 초기 수신 시퀀스 번호\(IRS\)는 연결 설정 절차 중에 학습됩니다.

연결을 설정하거나 초기화하려면 두 TCP 피어가 서로의 초기 시퀀스 번호를 동기화해야 합니다. 이는 "SYN"\(동기화용\)이라는 제어 비트와 초기 시퀀스 번호를 전달하는 연결 설정 세그먼트의 교환으로 수행됩니다. 간단히 말해서 SYN 비트를 전달하는 세그먼트를 "SYN"이라고도 합니다. 따라서 솔루션에는 초기 시퀀스 번호를 선택하는 데 적합한 메커니즘과 ISN을 교환하기 위한 약간의 핸드셰이크가 필요합니다.

동기화를 위해서는 각 측에서 자체 초기 시퀀스 번호를 보내고 원격 TCP 피어로부터 승인을 통해 이에 대한 확인을 받아야 합니다. 또한 각 측은 원격 피어의 초기 시퀀스 번호를 수신하고 확인 응답을 보내야 합니다.

```text
       1) A --> B  SYN my sequence number is X
       2) A <-- B  ACK your sequence number is X
       3) A <-- B  SYN my sequence number is Y
       4) A --> B  ACK your sequence number is Y
```

2단계와 3단계가 단일 메시지로 결합될 수 있기 때문에 이를 3WHS\(3방향\(또는 3개 메시지\) 핸드셰이크\)라고 합니다.

3WHS는 시퀀스 번호가 네트워크의 글로벌 시계에 연결되어 있지 않고 TCP 구현에 ISN을 선택하는 메커니즘이 다를 수 있기 때문에 필요합니다. 첫 번째 SYN의 수신자는 연결에 사용된 마지막 시퀀스 번호를 기억하지 않는 한\(항상 가능한 것은 아님\) 세그먼트가 이전 세그먼트인지 여부를 알 수 없으므로 발신자에게 이를 확인하도록 요청해야 합니다. SYN. 3방향 핸드셰이크와 ISN 선택을 위한 클록 구동 방식의 장점은 \[69\]에서 논의됩니다.

---
#### **3.4.2.  Knowing When to Keep Quiet**

동일한 포트 번호와 시퀀스 공간을 재사용하는 경우 호스트 재부팅 후 네트워크의 이전 세그먼트와 새 세그먼트 간의 혼동으로 인해 데이터가 손상될 수 있는 이론적인 문제가 존재합니다. 아래에서 논의되는 "조용한 시간" 개념은 이 문제를 다루고 있으며, 이에 대한 논의는 비록 대부분의 현재 구현에서는 필요하다고 느껴지지 않더라도 관련성이 있을 수 있는 상황에 대해 포함되어 있습니다. 이 문제는 TCP 역사 초기에 더 관련이 있었습니다. 오늘날 인터넷에서 실제로 사용하는 경우 오류가 발생하기 쉬운 조건은 무시해도 안전할 가능성이 거의 없습니다. 현재 무시할 수 있는 이유는 다음과 같습니다. \(a\) ISS 및 임시 포트 무작위화로 인해 재부팅 후 포트 번호 및 시퀀스 번호가 재사용될 가능성이 감소했습니다. \(b\) 링크가 빨라짐에 따라 인터넷의 유효 MSL이 감소했습니다. \(c\) \) 재부팅은 어쨌든 MSL보다 오래 걸리는 경우가 많습니다.

TCP 구현이 네트워크에 남아 있는 이전 세그먼트에 의해 복제될 수 있는 시퀀스 번호를 전달하는 세그먼트를 생성하지 않도록 하려면 TCP 엔드포인트는 시작 시 또는 복구 시 시퀀스 번호를 할당하기 전에 MSL에 대해 조용히 유지해야 합니다. 사용 중인 시퀀스 번호의 메모리가 손실된 상황입니다. 이 사양의 경우 MSL은 2분으로 간주됩니다. 이는 공학적 선택이며, 경험상 그렇게 하는 것이 바람직하다고 판단되는 경우 변경될 수 있습니다. 어떤 의미에서 TCP 엔드포인트가 다시 초기화되었지만 사용 중인 시퀀스 번호의 메모리를 유지하는 경우에는 전혀 기다릴 필요가 없습니다. 최근에 사용된 것보다 큰 시퀀스 번호만 사용해야 합니다.

---
#### **3.4.3.  The TCP Quiet Time Concept**

어떤 이유로든 각 활성\(즉, 닫히지 않은\) 연결에서 전송된 마지막 시퀀스 번호에 대한 지식을 잃은 호스트는 호스트가 속한 인터넷 시스템에서 최소한 합의된 MSL에 대해 모든 TCP 세그먼트 방출을 지연해야 합니다. 아래 단락에서는 이 사양에 대한 설명이 제공됩니다. TCP 구현자는 "정적 시간" 제한을 위반할 수 있지만 일부 오래된 데이터가 새 데이터로 승인되거나 인터넷 시스템의 일부 수신자에 의해 오래된 중복 데이터로 거부되는 새 데이터가 발생할 위험이 있습니다.

TCP 끝점은 세그먼트가 형성되어 소스 호스트의 네트워크 출력 대기열에 입력될 때마다 시퀀스 번호 공간을 사용합니다. TCP의 중복 감지 및 시퀀싱 알고리즘은 해당 시퀀스 번호에 바인딩된 세그먼트 데이터가 전달되고 승인되기 전에 시퀀스 번호가 모든 2^32 값을 순환하지 않는 범위까지 세그먼트 데이터의 시퀀스 공간에 대한 고유한 바인딩에 의존합니다. 수신기와 세그먼트의 모든 중복 복사본이 인터넷에서 "소진"되었습니다. 이러한 가정이 없으면 두 개의 서로 다른 TCP 세그먼트에 동일하거나 겹치는 시퀀스 번호가 할당되어 수신자에게 어떤 데이터가 새 데이터이고 어떤 데이터가 오래된 것인지 혼동을 일으킬 수 있습니다. 각 세그먼트는 세그먼트에 있는 데이터 옥텟과 SYN 또는 FIN 플래그 수만큼 연속된 시퀀스 번호에 바인딩된다는 점을 기억하세요.

정상적인 조건에서 TCP 구현은 첫 번째 사용이 승인되기 전에 시퀀스 번호를 실수로 재사용하는 것을 방지하기 위해 내보낼 다음 시퀀스 번호와 가장 오래 대기 중인 승인을 추적합니다. 이것만으로는 오래된 중복 데이터가 네트에서 유출된다는 것을 보장하지 않으므로 떠돌아다니는 중복 데이터가 도착 시 문제를 일으킬 가능성을 줄이기 위해 시퀀스 공간을 크게 만들었습니다. 2메가비트/초에서는 2^32 옥텟의 시퀀스 공간을 모두 사용하는 데 4.5시간이 걸립니다. 네트워크의 최대 세그먼트 수명은 수십 초를 초과할 가능성이 없으므로 이는 데이터 속도가 초당 수십 메가비트로 증가하더라도 예측 가능한 네트워크에 대한 충분한 보호로 간주됩니다. 100메가비트/초에서 주기 시간은 5.4분으로 약간 짧을 수 있지만 여전히 합리적인 수준입니다. 오늘날 훨씬 더 높은 데이터 속도가 가능하며, 이 하위 섹션의 마지막 단락에 설명된 의미가 있습니다.

그러나 TCP의 기본 중복 감지 및 순서 지정 알고리즘은 원본 TCP 끝점이 해당 연결에서 마지막으로 사용한 순서 번호에 대한 메모리가 없는 경우 무효화될 수 있습니다. 예를 들어, TCP 구현이 시퀀스 번호 0으로 모든 연결을 시작하는 경우 호스트가 재부팅되면 TCP 피어는 이전 연결을 재형성하고\(아마도 반 개방 연결 해결 후\) 다음과 동일한 시퀀스 번호를 가진 패킷을 내보낼 수 있습니다. 또는 동일한 연결의 이전 구현에서 방출된 패킷이 여전히 네트워크에 있는 패킷과 겹칩니다. 특정 연결에 사용되는 시퀀스 번호에 대한 정보가 없는 경우 TCP 사양에서는 이전 연결 구현의 세그먼트가 시스템에서 배출되는 시간을 허용하기 위해 연결에서 세그먼트를 방출하기 전에 MSL 초 동안 소스 지연을 허용하도록 권장합니다.

하루 중 시간을 기억하고 이를 사용하여 초기 시퀀스 번호 값을 선택할 수 있는 호스트도 이 문제에서 면역되지 않습니다\(즉, 하루 중 시간이 각각의 새로운 연결 구현에 대한 초기 시퀀스 번호를 선택하는 데 사용되는 경우에도 마찬가지\).

예를 들어 시퀀스 번호 S로 시작하는 연결이 열린다고 가정합니다. 이 연결이 많이 사용되지 않고 결국 초기 시퀀스 번호 함수\(ISN\(t\)\)가 시퀀스 번호와 동일한 값, 즉 S1을 취한다고 가정합니다. , 특정 연결에서 이 TCP 끝점이 보낸 마지막 세그먼트입니다. 이제 이 순간 호스트가 재부팅되고 새로운 연결이 설정된다고 가정해 보겠습니다. 선택된 초기 시퀀스 번호는 S1 = ISN\(t\)입니다. 연결의 이전 구현에서 마지막으로 사용된 시퀀스 번호입니다! 복구가 충분히 빠르게 발생하면 S1 근처에 있는 네트 베어링 시퀀스 번호의 이전 중복 항목이 도착하여 연결의 새로운 구현 수신자에 의해 새 패킷으로 처리될 수 있습니다.

문제는 복구 호스트가 재부팅 사이에 얼마나 오랫동안 다운되었는지 알 수 없으며 시스템에 이전 연결 구현에서 여전히 오래된 중복 항목이 있는지 여부도 알 수 없다는 것입니다.

이 문제를 해결하는 한 가지 방법은 재부팅 후 복구 후 하나의 MSL에 대한 세그먼트 방출을 의도적으로 지연하는 것입니다. 이것이 "자동 시간" 사양입니다. 기다리는 것을 선호하고 주어진 목적지에서 이전 패킷과 새 패킷의 혼동 가능성을 감수하려는 호스트는 "조용한 시간"을 기다리지 않도록 선택할 수 있습니다. 구현자는 TCP 사용자에게 재부팅 후 대기할지 여부를 연결별로 선택할 수 있는 기능을 제공하거나 모든 연결에 대해 "자동 시간"을 비공식적으로 구현할 수 있습니다. 분명히 사용자가 "대기"를 선택하더라도 호스트가 최소 MSL 초 동안 "작동"된 후에는 이것이 필요하지 않습니다.

요약하자면, 방출된 모든 세그먼트는 시퀀스 공간에서 하나 이상의 시퀀스 번호를 차지하고, 세그먼트가 차지하는 숫자는 MSL 초가 지날 때까지 "사용 중"이거나 "사용 중"입니다. 재부팅 시 시공간 블록은 잠재적으로 아직 진행 중인 세그먼트의 옥텟과 SYN 또는 FIN 플래그로 채워집니다. 새 연결이 너무 빨리 시작되고 이전 연결 구현의 잠재적으로 아직 비행 중인 세그먼트의 시공간 공간에서 시퀀스 번호 중 하나를 사용하는 경우 수신기에서 혼란을 일으킬 수 있는 잠재적인 시퀀스 번호 중복 영역이 있습니다. .

고성능 사례는 ​​위에서 설명한 기본 TCP 설계에서 고려하는 초당 메가비트 단위의 주기 시간보다 짧은 주기 시간을 갖습니다. 1Gbps에서 주기 시간은 34초이며, 10Gbps에서는 단 3초, 100Gbps에서는 약 1/3초입니다. 이러한 고성능 사례에서 TCP 타임스탬프 옵션 및 PAWS\(Protection Against Wrapped Sequences\)\[47\]는 오래된 중복을 감지하고 삭제하는 데 필요한 기능을 제공합니다.

---
### **3.5.  Establishing a Connection**

"3방향 핸드셰이크"는 연결을 설정하는 데 사용되는 절차입니다. 이 절차는 일반적으로 하나의 TCP 피어에 의해 시작되고 다른 TCP 피어에 의해 응답됩니다. 두 TCP 피어가 동시에 프로시저를 시작하는 경우에도 이 프로시저가 작동합니다. 동시 열기가 발생하면 각 TCP 피어는 SYN을 보낸 후 승인을 전달하지 않는 SYN 세그먼트를 받습니다. 물론 오래된 중복 SYN 세그먼트가 도착하면 수신자에게 동시 연결 시작이 진행 중인 것처럼 보일 수 있습니다. "재설정" 세그먼트를 올바르게 사용하면 이러한 경우를 명확하게 할 수 있습니다.

연결 시작의 몇 가지 예는 다음과 같습니다. 이러한 예에서는 데이터 전달 세그먼트를 사용한 연결 동기화를 보여주지 않지만 수신 TCP 끝점이 데이터가 유효하다는 것이 명확해질 때까지\(예: 데이터가 버퍼링됨\) 사용자에게 데이터를 전달하지 않는 한 이는 완전히 합법적입니다. 3방향 핸드셰이크가 잘못된 연결 가능성을 줄인다면 연결이 ESTABLISHED 상태에 도달할 때까지 수신기에서 수행됩니다. 이 검사에 대한 정보를 제공하는 것은 메모리와 메시지 사이의 균형입니다.

```text
   The simplest 3WHS is shown in Figure 6.  The figures should be
   interpreted in the following way.  Each line is numbered for
   reference purposes.  Right arrows (-->) indicate departure of a TCP
   segment from TCP Peer A to TCP Peer B or arrival of a segment at B
   from A.  Left arrows (<--) indicate the reverse.  Ellipses (...)
   indicate a segment that is still in the network (delayed).  Comments
   appear in parentheses.  TCP connection states represent the state
   AFTER the departure or arrival of the segment (whose contents are
   shown in the center of each line).  Segment contents are shown in
   abbreviated form, with sequence number, control flags, and ACK field.
   Other fields such as window, addresses, lengths, and text have been
   left out in the interest of clarity.

       TCP Peer A                                           TCP Peer B

   1.  CLOSED                                               LISTEN

   2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

   3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

   4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

   5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED

     Figure 6: Basic Three-Way Handshake for Connection Synchronization
```

그림 6의 라인 2에서 TCP 피어 A는 시퀀스 번호 100으로 시작하는 시퀀스 번호를 사용할 것임을 나타내는 SYN 세그먼트를 보내는 것으로 시작합니다. 라인 3에서 TCP 피어 B는 SYN을 보내고 TCP 피어 A로부터 받은 SYN을 승인합니다. 확인 필드는 TCP 피어 B가 이제 시퀀스 100을 점유한 SYN을 확인하면서 시퀀스 101을 듣기를 기대하고 있음을 나타냅니다.

4행에서 TCP 피어 A는 TCP 피어 B의 SYN에 대한 ACK가 포함된 빈 세그먼트로 응답합니다. 5번째 줄에서는 TCP 피어 A가 일부 데이터를 보냅니다. ACK가 시퀀스 번호 공간을 차지하지 않기 때문에 라인 5에 있는 세그먼트의 시퀀스 번호는 라인 4와 동일합니다\(만약 그렇다면 우리는 ACK를 보내는 ACK를 종료할 것입니다!\).

동시 시작은 그림 7에 표시된 것처럼 약간 더 복잡합니다. 각 TCP 피어의 연결 상태는 CLOSED에서 SYN-SENT, SYN-RECEIVED, ESTABLISHED로 순환됩니다.

```text
       TCP Peer A                                       TCP Peer B

   1.  CLOSED                                           CLOSED

   2.  SYN-SENT     --> <SEQ=100><CTL=SYN>              ...

   3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT

   4.               ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED

   5.  SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...

   6.  ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED

   7.               ... <SEQ=100><ACK=301><CTL=SYN,ACK> --> ESTABLISHED

             Figure 7: Simultaneous Connection Synchronization
```

TCP 구현은 동시 열기 시도를 지원해야 합니다\(MUST-10\).\(MUST\)

TCP 구현은 연결이 수동 OPEN 또는 활성 OPEN\(MUST-11\)의 결과로 SYN-RECEIVED 상태에 도달했는지 여부를 추적해야 합니다.\(MUST\)

3방향 핸드셰이크의 주된 이유는 오래된 중복 연결 시작으로 인해 혼란이 발생하는 것을 방지하기 위한 것입니다. 이를 처리하기 위해 특별한 제어 메시지인 재설정이 지정됩니다. 수신 TCP 피어가 동기화되지 않은 상태\(예: SYN-SENT, SYN-RECEIVED\)인 경우 허용 가능한 재설정을 수신하면 LISTEN으로 돌아갑니다. TCP 피어가 동기화된 상태\(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\) 중 하나에 있으면 연결을 중단하고 사용자에게 알립니다. 우리는 아래의 "반개방" 연결에서 후자의 경우를 논의합니다.

```text
       TCP Peer A                                           TCP Peer B

   1.  CLOSED                                               LISTEN

   2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...

   3.  (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED

   4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED

   5.  SYN-SENT    --> <SEQ=91><CTL=RST>               --> LISTEN

   6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

   7.  ESTABLISHED <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

   8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED

                 Figure 8: Recovery from Old Duplicate SYN
```

오래된 중복으로부터 복구하는 간단한 예로 그림 8을 고려하십시오. 3행에서 오래된 중복 SYN이 TCP 피어 B에 도착합니다. TCP 피어 B는 이것이 오래된 중복임을 알 수 없으므로 정상적으로 응답합니다\(4행\). TCP 피어 A는 ACK 필드가 잘못되었음을 감지하고 세그먼트를 믿을 수 있도록 선택된 SEQ 필드와 함께 RST\(재설정\)를 반환합니다. RST를 수신한 TCP 피어 B는 LISTEN 상태로 돌아갑니다. 원래 SYN이 마침내 라인 6에 도착하면 동기화가 정상적으로 진행됩니다. 6행의 SYN이 RST보다 먼저 도착했다면 RST가 양방향으로 전송되어 더 복잡한 교환이 발생했을 수 있습니다.

---
#### **3.5.1.  Half-Open Connections and Other Anomalies**

TCP 피어 중 하나가 다른 쪽도 모르게 연결을 닫거나 중단한 경우, 또는 연결의 두 끝이 실패로 인해 동기화되지 않은 경우 설정된 연결을 "반개방"이라고 합니다. 재부팅으로 인해 메모리가 손실되었습니다. 이러한 연결은 어느 방향으로든 데이터를 전송하려고 시도하면 자동으로 재설정됩니다. 그러나 반개방 연결은 이례적일 것으로 예상됩니다.

사이트 A에 연결이 더 이상 존재하지 않는 경우 사이트 B의 사용자가 사이트에 데이터를 보내려고 시도하면 사이트 B TCP 끝점이 재설정 제어 메시지를 받게 됩니다. 이러한 메시지는 사이트 B TCP 끝점에 무언가 잘못되었음을 나타내며 연결이 중단될 것으로 예상됩니다.

오류나 재부팅이 발생하여 A의 TCP 구현에 메모리가 손실될 때 두 사용자 프로세스 A와 B가 서로 통신하고 있다고 가정합니다. A의 TCP 구현을 지원하는 운영 체제에 따라 일부 오류 복구 메커니즘이 존재할 수 있습니다. TCP 엔드포인트가 다시 작동되면 A는 처음부터 또는 복구 지점에서 다시 시작할 가능성이 높습니다. 결과적으로 A는 연결을 다시 OPEN하려고 시도하거나 열려 있다고 생각되는 연결에 대해 SEND를 시도할 것입니다. 후자의 경우 로컬\(A의\) TCP 구현으로부터 "연결이 열리지 않음"이라는 오류 메시지를 받습니다. 연결을 설정하려는 시도에서 A의 TCP 구현은 SYN이 포함된 세그먼트를 보냅니다. 이 시나리오는 그림 9에 표시된 예제로 이어집니다. TCP 피어 A가 재부팅된 후 사용자는 연결을 다시 열려고 시도합니다. 그 동안 TCP 피어 B는 연결이 열려 있다고 생각합니다.

```text
         TCP Peer A                                      TCP Peer B

     1.  (REBOOT)                              (send 300,receive 100)

     2.  CLOSED                                           ESTABLISHED

     3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)

     4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED

     5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)

     6.  SYN-SENT                                         CLOSED

     7.  SYN-SENT --> <SEQ=400><CTL=SYN>              -->

                  Figure 9: Half-Open Connection Discovery
```

SYN이 라인 3에 도착하면 동기화된 상태에 있는 TCP 피어 B와 창 외부의 들어오는 세그먼트는 다음에 들을 것으로 예상되는 시퀀스\(ACK 100\)를 나타내는 승인으로 응답합니다. TCP 피어 A는 이 세그먼트가 자신이 보낸 어떤 것도 승인하지 않는다는 것을 확인하고, 동기화되지 않은 상태에서 반개방 연결을 감지했기 때문에 재설정\(RST\)을 보냅니다. TCP 피어 B는 라인 5에서 중단됩니다. TCP 피어 A는 계속해서 연결 설정을 시도합니다. 이제 문제는 그림 6의 기본 3방향 핸드셰이크로 축소되었습니다.

흥미로운 대체 사례는 TCP 피어 A가 재부팅되고 TCP 피어 B가 동기화된 연결이라고 생각하는 데이터를 보내려고 할 때 발생합니다. 이는 그림 10에 설명되어 있습니다. 이 경우 TCP 피어 B\(라인 2\)에서 TCP 피어 A에 도착하는 데이터는 해당 연결이 존재하지 않기 때문에 허용되지 않으므로 TCP 피어 A는 RST를 보냅니다. RST가 허용되므로 TCP 피어 B가 이를 처리하고 연결을 중단합니다.

```text
         TCP Peer A                                         TCP Peer B

   1.  (REBOOT)                                  (send 300,receive 100)

   2.  (??)    <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED

   3.          --> <SEQ=100><CTL=RST>                   --> (ABORT!!)

        Figure 10: Active Side Causes Half-Open Connection Discovery
```

그림 11에는 SYN을 기다리는 수동 연결이 있는 두 개의 TCP 피어 A와 B가 나와 있습니다. TCP 피어 B\(라인 2\)에 도착하는 오래된 복제본이 B를 작동하게 만듭니다. SYN-ACK가 반환되고\(라인 3\) TCP A가 RST를 생성하도록 합니다\(라인 3의 ACK는 허용되지 않음\). TCP 피어 B는 재설정을 수락하고 수동 LISTEN 상태로 돌아갑니다.

```text
       TCP Peer A                                    TCP Peer B

   1.  LISTEN                                        LISTEN

   2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED

   3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED

   4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)

   5.  LISTEN                                        LISTEN
```

그림 11: 이전 중복 SYN이 두 개의 패시브 소켓에서 재설정을 시작합니다.

다양한 다른 경우도 가능하며, 모두 RST 생성 및 처리에 대한 다음 규칙에 따라 설명됩니다.

---
#### **3.5.2.  Reset Generation**

TCP 사용자 또는 애플리케이션은 언제든지 연결에 대한 재설정을 실행할 수 있지만 아래 설명된 것처럼 다양한 오류 조건이 발생할 때 프로토콜 자체에 의해 재설정 이벤트도 생성됩니다. 재설정을 실행하는 연결 측은 TIME-WAIT 상태로 들어가야 합니다. 이는 일반적으로 \[70\]에 설명된 이유로 바쁜 서버의 로드를 줄이는 데 도움이 되기 때문입니다.

일반적으로 현재 연결에 의도되지 않은 세그먼트가 도착할 때마다 재설정\(RST\)이 전송됩니다. 이것이 사실인지 확실하지 않은 경우 재설정을 보내서는 안 됩니다.

상태에는 세 가지 그룹이 있습니다.

1. 연결이 존재하지 않는 경우\(CLOSED\) 다른 재설정을 제외한 모든 수신 세그먼트에 대한 응답으로 재설정이 전송됩니다. 기존 연결과 일치하지 않는 SYN 세그먼트는 이 방법으로 거부됩니다.

- 들어오는 세그먼트에 ACK 비트가 설정된 경우 재설정은 세그먼트의 ACK 필드에서 시퀀스 번호를 가져옵니다. 그렇지 않으면 재설정의 시퀀스 번호가 0이 되고 ACK 필드는 들어오는 세그먼트의 시퀀스 번호와 세그먼트 길이의 합으로 설정됩니다. 연결은 CLOSED 상태로 유지됩니다.

2. 연결이 동기화되지 않은 상태\(LISTEN, SYNSENT, SYN-RECEIVED\)이고 수신 세그먼트가 아직 전송되지 않은 내용을 승인하는 경우\(세그먼트는 허용할 수 없는 ACK를 전달함\) 또는 수신 세그먼트에 보안이 있는 경우 연결을 위해 요청된 레벨 및 구획과 정확히 일치하지 않는 레벨 또는 구획\(부록 A.1\)이 있는 경우 재설정이 전송됩니다.

- 들어오는 세그먼트에 ACK 필드가 있는 경우 재설정은 세그먼트의 ACK 필드에서 시퀀스 번호를 가져옵니다. 그렇지 않으면 재설정의 시퀀스 번호가 0이 되고 ACK 필드는 들어오는 세그먼트의 시퀀스 번호와 세그먼트 길이의 합으로 설정됩니다. 연결은 동일한 상태로 유지됩니다.

3. 연결이 동기화된 상태\(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\)인 경우, 허용되지 않는 세그먼트\(out-of-window 시퀀스\) 번호 또는 승인할 수 없는 승인 번호\)에는 현재 전송 시퀀스 번호와 수신될 것으로 예상되는 다음 시퀀스 번호를 나타내는 승인이 포함된 빈 승인 세그먼트\(사용자 데이터 없음\)로 응답해야 하며 연결은 동일한 상태로 유지됩니다.

- 수신 세그먼트에 연결에 대해 요청된 수준 및 구획과 정확하게 일치하지 않는 보안 수준 또는 구획이 있는 경우 재설정이 전송되고 연결은 CLOSED 상태로 전환됩니다. 재설정은 들어오는 세그먼트의 ACK 필드에서 시퀀스 번호를 가져옵니다.

---
#### **3.5.3.  Reset Processing**

SYN-SENT를 제외한 모든 상태에서 모든 재설정\(RST\) 세그먼트는 SEQ 필드를 확인하여 검증됩니다. 재설정은 해당 시퀀스 번호가 창에 있는 경우 유효합니다. SYN-SENT 상태\(초기 SYN에 대한 응답으로 수신된 RST\)에서 ACK 필드가 SYN을 승인하면 RST가 허용됩니다.

RST의 수신자는 먼저 이를 검증한 다음 상태를 변경합니다. 수신기가 LISTEN 상태인 ​​경우 이를 무시합니다. 수신기가 SYN-RECEIVED 상태이고 이전에 LISTEN 상태였던 경우 수신기는 LISTEN 상태로 돌아갑니다. 그렇지 않으면 수신기는 연결을 중단하고 CLOSED 상태로 전환됩니다. 수신기가 다른 상태에 있었다면 연결을 중단하고 사용자에게 알리고 CLOSED 상태로 이동합니다.

TCP 구현은 수신된 RST 세그먼트가 데이터\(SHLD-2\)를 포함하도록 허용해야 합니다\(SHOULD\). RST 세그먼트에는 RST의 원인을 설명하는 진단 데이터가 포함될 수 있다는 제안이 있었습니다. 그러한 데이터에 대한 표준은 아직 확립되지 않았습니다.\(SHOULD\)

---
### **3.6.  Closing a Connection**

CLOSE는 "더 이상 보낼 데이터가 없습니다."라는 의미의 연산입니다. 물론 전이중 연결을 닫는다는 개념은 연결의 수신 측을 처리하는 방법이 명확하지 않을 수 있으므로 모호하게 해석될 수 있습니다. 우리는 CLOSE를 단순한 방식으로 처리하기로 결정했습니다. CLOSE한 사용자는 TCP 수신자가 원격 피어도 CLOSED되었음을 알릴 때까지 계속해서 RECEIVE를 받을 수 있습니다. 따라서 프로그램은 여러 SEND를 시작한 후 CLOSE를 시작한 다음 원격 피어가 CLOSED되었기 때문에 RECEIVE가 실패했다는 신호를 받을 때까지 RECEIVE를 계속할 수 있습니다. TCP 구현은 처리 중인 RECEIVE가 없더라도 사용자에게 원격 피어가 닫혔다는 신호를 보내므로 사용자는 해당 측을 정상적으로 종료할 수 있습니다. TCP 구현은 연결이 닫히기 전에 보낸 모든 버퍼를 안정적으로 전달하므로 반환되는 데이터가 없을 것으로 예상하는 사용자는 연결이 성공적으로 닫혔다는 소식을 듣기만 기다리면 모든 데이터가 대상 TCP 끝점에서 수신되었음을 알 수 있습니다. 사용자는 TCP 구현에서 더 이상 데이터가 없음을 나타낼 때까지 보내기 위해 닫은 연결을 계속 읽어야 합니다.

본질적으로 세 가지 경우가 있습니다.

1\) 사용자는 TCP 구현에 연결을 닫으라고 지시하여 시작합니다\(그림 12의 TCP 피어 A\).

2\) 원격 TCP 엔드포인트는 FIN 제어 신호\(그림 12의 TCP 피어 B\)를 전송하여 시작됩니다.

```text
   3)  Both users CLOSE simultaneously (Figure 13).
```

사례 1: 로컬 사용자가 닫기를 시작합니다.

- 이 경우 FIN 세그먼트를 구성하여 나가는 세그먼트 큐에 배치할 수 있습니다. 사용자의 더 이상 SEND는 TCP 구현에 의해 허용되지 않으며 FIN-WAIT-1 상태로 들어갑니다. 이 상태에서는 RECEIVE가 허용됩니다. FIN 이전 및 FIN을 포함한 모든 세그먼트는 승인될 때까지 재전송됩니다. 다른 TCP 피어가 FIN을 확인하고 자체 FIN을 보낸 경우 첫 번째 TCP 피어가 이 FIN을 ACK할 수 있습니다. FIN을 수신하는 TCP 엔드포인트는 ACK를 보내지만 사용자가 연결을 종료할 때까지 자체 FIN을 보내지 않습니다.

사례 2: TCP 엔드포인트가 네트워크로부터 FIN을 수신합니다.

- 원치 않는 FIN이 네트워크에서 도착하면 수신 TCP 엔드포인트는 이를 ACK하고 사용자에게 연결이 닫히고 있음을 알릴 수 있습니다. 사용자는 CLOSE로 응답하며, 이에 따라 TCP 끝점은 나머지 데이터를 보낸 후 다른 TCP 피어에 FIN을 보낼 수 있습니다. 그런 다음 TCP 끝점은 자체 FIN이 승인될 때까지 기다린 후 연결을 삭제합니다. ACK가 오지 않으면 사용자 시간 초과 후 연결이 중단되고 사용자에게 알립니다.

```text
   Case 3:  Both users close simultaneously
```

- 연결의 양쪽 끝에서 사용자가 동시에 CLOSE하면 FIN 세그먼트가 교환됩니다\(그림 13\). FIN 앞의 모든 세그먼트가 처리되고 승인되면 각 TCP 피어는 수신한 FIN을 ACK할 수 있습니다. 둘 다 이러한 ACK를 받으면 연결을 삭제합니다.

```text
       TCP Peer A                                           TCP Peer B

   1.  ESTABLISHED                                          ESTABLISHED

   2.  (Close)
       FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT

   3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT

   4.                                                       (Close)
       TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK

   5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED

   6.  (2 MSL)
       CLOSED

                      Figure 12: Normal Close Sequence

       TCP Peer A                                           TCP Peer B

   1.  ESTABLISHED                                          ESTABLISHED

   2.  (Close)                                              (Close)
       FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
                   <-- <SEQ=300><ACK=100><CTL=FIN,ACK>  <--
                   ... <SEQ=100><ACK=300><CTL=FIN,ACK>  -->

   3.  CLOSING     --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
                   <-- <SEQ=301><ACK=101><CTL=ACK>      <--
                   ... <SEQ=101><ACK=301><CTL=ACK>      -->

   4.  TIME-WAIT                                            TIME-WAIT
       (2 MSL)                                              (2 MSL)
       CLOSED                                               CLOSED

                   Figure 13: Simultaneous Close Sequence
```

TCP 연결은 두 가지 방법으로 종료될 수 있습니다. \(1\) FIN 핸드셰이크를 사용하는 일반적인 TCP 닫기 시퀀스\(그림 12\), \(2\) 하나 이상의 RST 세그먼트가 전송되고 연결 상태가 즉시 삭제되는 "중단" . 원격 측에서 수신한 FIN 또는 RST로 인해 원격 측에서 로컬 TCP 연결을 닫은 경우 로컬 애플리케이션은 정상적으로 닫혔는지 아니면 중단되었는지 알려야 합니다\(MUST-12\).\(MUST\)

---
#### **3.6.1.  Half-Closed Connections**

일반적인 TCP 닫기 시퀀스는 버퍼링된 데이터를 양방향으로 안정적으로 전달합니다. TCP 연결의 두 방향이 독립적으로 닫혀 있기 때문에 연결이 "반 폐쇄"될 수 있습니다. 즉, 한 방향으로만 닫혀 있고 호스트는 반만 닫힌 방향으로 계속 데이터를 보내는 것이 허용됩니다. 닫힌 연결.

호스트는 "반이중" TCP 닫기 시퀀스를 구현할 수 있으므로 CLOSE를 호출한 애플리케이션은 연결에서 데이터를 계속 읽을 수 없습니다\(MAY-1\). 이러한 호스트가 TCP 연결에서 수신된 데이터가 아직 보류 중인 동안 CLOSE 호출을 발행하거나 CLOSE가 호출된 후 새 데이터가 수신되는 경우, TCP 구현은 RST를 보내 데이터가 손실되었음을 표시해야 합니다\(SHLD-3\). 논의는 \[23\], 섹션 2.17을 참조하십시오.\(MAY, SHOULD\)

연결이 적극적으로 닫히면 2xMSL\(최대 세그먼트 수명\)\(MUST-13\) 시간 동안 TIME-WAIT 상태를 유지해야 합니다. 그러나 다음과 같은 경우 원격 TCP 끝점에서 새 SYN을 수락하여 TIME-WAIT 상태\(MAY-2\)에서 직접 연결을 다시 열 수 있습니다.\(MUST, MAY\)

\(1\) 새 연결의 초기 시퀀스 번호를 이전 연결 구현에서 사용된 가장 큰 시퀀스 번호보다 크게 할당합니다.

\(2\) SYN이 이전 중복으로 판명되면 TIME-WAIT 상태로 돌아갑니다.

TCP 타임스탬프 옵션을 사용할 수 있는 경우 더 높은 연결 설정 속도를 지원하기 위해 향상된 알고리즘이 \[40\]에 설명되어 있습니다. TIME-WAIT를 줄이기 위한 이 알고리즘은 Timestamp 옵션이 일반적으로 사용되므로 구현해야 하는 현재 모범 사례이며, 이를 사용하여 TIME-WAIT를 줄이는 것은 사용량이 많은 인터넷 서버\(SHLD-4\)에 이점을 제공합니다.\(SHOULD\)

---
### **3.7.  Segmentation**

"세그먼트화"라는 용어는 전송 애플리케이션에서 바이트 스트림을 수집하고 해당 바이트 스트림을 TCP 세그먼트로 패킷화할 때 TCP가 수행하는 활동을 나타냅니다. 개별 TCP 세그먼트는 애플리케이션의 개별 전송\(또는 소켓 쓰기\) 호출에 일대일로 대응하지 않는 경우가 많습니다. 애플리케이션은 상위 계층 프로토콜에서 메시지 단위로 쓰기를 수행할 수 있지만 TCP는 전송 및 수신된 TCP 세그먼트의 경계와 사용자 애플리케이션 데이터의 읽기 또는 쓰기 버퍼 경계 사이의 상관 관계를 보장하지 않습니다. DDP\(Direct Data Placement\) 및 MPA\(Marker PDU Aligned Framing\)를 사용하는 RDMA\(Remote Direct Memory Access\)와 같은 일부 특정 프로토콜에서는 TCP 세그먼트와 애플리케이션 데이터 단위 간의 관계가 다음과 같을 때 성능 최적화가 가능합니다. MPA에는 TCP 세그먼트와 애플리케이션 메시지 데이터 구조 간의 관계를 감지하고 확인하기 위한 특정 메커니즘이 포함되어 있지만 이는 RDMA와 같은 애플리케이션에만 해당됩니다. 일반적으로 여러 목표는 TCP 구현에 의해 생성된 TCP 세그먼트의 크기에 영향을 미칩니다.

더 큰 세그먼트 전송을 추진하는 목표는 다음과 같습니다.

\* 네트워크 내에서 이동 중인 패킷 수를 줄입니다.

\* 더 적은 수의 인터럽트와 계층 간 상호 작용을 활성화하여 처리 효율성과 잠재적 성능을 높입니다.

\* TCP 헤더의 오버헤드를 제한합니다.

더 큰 세그먼트를 전송할 때의 성능 이점은 크기가 증가함에 따라 감소할 수 있으며 이점이 반전되는 경계가 있을 수 있습니다. 예를 들어 일부 구현 아키텍처에서는 순전히 복사 작업의 데이터 정렬로 인해 세그먼트 내의 1025바이트가 1024바이트보다 성능이 저하될 수 있습니다.

더 작은 세그먼트 전송을 추진하는 목표는 다음과 같습니다.

\* IP 네트워크 경로를 따라 가장 작은 MTU보다 큰 IP 데이터그램을 생성하는 TCP 세그먼트 전송을 피하세요. 이렇게 하면 패킷 손실이나 패킷 조각화가 발생하기 때문입니다. 설상가상으로 일부 방화벽이나 미들박스는 조각화된 패킷이나 조각화와 관련된 ICMP 메시지를 삭제할 수 있습니다.

\* 특히 TCP가 애플리케이션에서 더 많은 데이터를 생성하기를 기다리고 있거나 애플리케이션이 더 많은 데이터를 생성하기 위해 피어로부터의 이벤트나 입력을 기다리고 있는 경우 애플리케이션 데이터 스트림의 지연을 방지합니다.

\* TCP 세그먼트와 하위 계층 데이터 단위\(예: IP MTU보다 작은 셀 또는 프레임 크기의 링크의 경우 IP 아래\) 간의 "운명 공유"를 활성화합니다.

이러한 경쟁적인 목표 세트를 충족하기 위해 TCP에는 다음 하위 섹션에서 설명하는 것처럼 최대 세그먼트 크기 옵션, 경로 MTU 검색, Nagle 알고리즘 및 IPv6 점보그램 지원을 포함한 여러 메커니즘이 포함되어 있습니다.

---
#### **3.7.1.  Maximum Segment Size Option**

TCP 엔드포인트는 MSS 옵션 전송 및 수신을 모두 구현해야 합니다\(MUST-14\).\(MUST\)

TCP 구현은 수신 MSS가 IPv4의 경우 기본 536 또는 IPv6의 경우 1220\(SHLD-5\)과 다를 때 모든 SYN 세그먼트에서 MSS 옵션을 보내야 하며 항상 보낼 수 있습니다\(MAY-3\).\(SHOULD\)

연결 설정 시 MSS 옵션이 수신되지 않으면 TCP 구현은 IPv4의 경우 기본 전송 MSS가 536\(576 - 40\)이고 IPv6의 경우 1220\(1280 - 60\)\(MUST-15\)이라고 가정해야 합니다\(MUST-15\).\(MUST\)

TCP 엔드포인트가 실제로 전송하는 세그먼트의 최대 크기인 "유효 전송 MSS"는 전송 MSS보다 더 작아야 합니다\(MUST-16\). 이는 원격 호스트에서 사용 가능한 리어셈블리 버퍼 크기인 EMTU\_R을 반영합니다. \]\) 및 IP 계층에서 허용하는 최대 전송 크기\(EMTU\_S \[19\]\):\(MUST\)

```text
   Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize

   where:
```

\* SendMSS는 원격 호스트로부터 수신된 MSS 값이며, MSS 옵션이 수신되지 않은 경우 IPv4의 경우 기본 536, IPv6의 경우 1220입니다.

\* MMS\_S는 TCP가 보낼 수 있는 전송 계층 메시지의 최대 크기입니다.

\* TCPhdrsize는 고정된 TCP 헤더와 모든 옵션의 크기입니다. 옵션이 없는 \(드문\) 경우에는 20이지만 TCP 옵션이 전송되는 경우 더 클 수 있습니다. 일부 옵션은 모든 세그먼트에 포함되지 않을 수 있지만 전송된 각 세그먼트에 대해 발신자는 Eff.snd.MSS 내에서 이에 따라 데이터 길이를 조정해야 합니다.

\* IOptionsize는 TCP 연결과 관련된 IPv4 옵션 또는 IPv6 확장 헤더의 크기입니다. 일부 옵션이나 확장 헤더는 모든 패킷에 포함되지 않을 수 있지만 전송된 각 세그먼트에 대해 발신자는 Eff.snd.MSS 내에서 이에 따라 데이터 길이를 조정해야 합니다.

MSS 옵션으로 전송되는 MSS 값은 유효 MTU에서 고정 IP 및 TCP 헤더를 뺀 값과 같아야 합니다. MSS 옵션 값을 계산할 때 IP 옵션과 TCP 옵션을 모두 무시함으로써 패킷에 전송할 IP 또는 TCP 옵션이 있는 경우 송신자는 그에 따라 TCP 데이터의 크기를 줄여야 합니다. RFC 6691 \[43\]에서는 이에 대해 더 자세히 논의합니다.

MSS 옵션으로 전송될 MSS 값은 다음 값보다 작거나 같아야 합니다.

```text
      MMS_R - 20
```

여기서 MMS\_R은 수신할 수 있는\(그리고 IP 계층에서 재조립할 수 있는\) 전송 계층 메시지의 최대 크기입니다\(MUST-67\). TCP는 IP 계층에서 MMS\_R 및 MMS\_S를 얻습니다. RFC 1122의 섹션 3.4에 있는 일반 호출 GET\_MAXSIZES를 참조하세요. 이는 해당 IP MTU인 EMTU\_R 및 EMTU\_S\[19\]로 정의됩니다.\(MUST\)

IP 또는 TCP 헤더가 고정되지 않은 상황에서 TCP를 사용하는 경우 보낸 사람은 IP 및 TCP 옵션에서 사용하는 옥텟 수만큼 특정 패킷의 TCP 데이터 양을 줄여야 합니다. RFC 6691, 섹션 3.1에 설명된 것처럼 이는 역사적으로 혼란스러운 지점이었습니다.

---
#### **3.7.2.  Path MTU Discovery**

TCP 구현은 직접 연결된 링크의 MTU를 인식할 수 있지만 전체 네트워크 경로의 MTU에 대한 통찰력은 거의 갖지 않습니다. IPv4의 경우 RFC 1122는 직접 연결되지 않은 대상에 대해 576 이하의 IP 계층 기본 유효 MTU를 권장하며 IPv6의 경우 1280이 됩니다. 이러한 고정 값을 사용하면 TCP 연결 성능과 효율성이 제한됩니다. 대신, TCP가 분할 결정을 개선할 수 있도록 PMTUD\(Path MTU Discovery\) 및 PPLPMTUD\(Packetization Layer Path MTU Discovery\)를 구현하는 것이 좋습니다. PMTUD와 PLPMTUD는 모두 TCP가 경로\(IPv4의 경우\)와 소스 조각화\(IPv4 및 IPv6\)를 모두 방지하는 세그먼트 크기를 선택하는 데 도움이 됩니다.

IPv4\[2\] 또는 IPv6\[14\]용 PMTUD는 TCP, IP 및 ICMP 간에 결합하여 구현됩니다. 이는 소스 조각화를 방지하고 IPv4 DF\(조각화 안 함\) 플래그 설정에 의존하며, 후자는 경로 조각화를 금지합니다. 세그먼트가 너무 커서 링크를 통과할 수 없을 때마다 경로에 있는 라우터의 ICMP 오류에 의존합니다. 실제로 경험하는 문제를 처리하기 위해 PMTUD를 사용한 TCP 구현에 대한 몇 가지 조정 사항이 RFC 2923에 설명되어 있습니다\[27\]. PLPMTUD \[31\]는 경로 전반에 걸쳐 ICMP 지원에 대한 요구 사항을 완화하고 ICMP가 일관되게 전달되지 않지만 여전히 소스 조각화를 피하려고 시도하는 경우 성능을 향상시키는 PMTUD에 대한 표준 트랙 개선입니다. 이러한 네 가지 RFC의 메커니즘은 모두 TCP 구현에 포함되는 것이 좋습니다.

TCP MSS 옵션은 수신할 수 있는 패킷 크기의 상한을 지정합니다\(\[43\] 참조\). 따라서 MSS 옵션의 값을 너무 작게 설정하면 PMTUD 또는 PLPMTUD가 더 큰 경로 MTU를 찾는 기능에 영향을 미칠 수 있습니다. RFC 1191에서는 권장되는 대로 연결된 인터페이스의 MTU에서 파생되는 대신 로컬이 아닌 대상에 대해 TCP MSS를 536\(IPv4 576바이트 기본 MTU에 해당\)으로 설정하는 많은 이전 TCP 구현의 의미를 논의합니다.

---
#### **3.7.3.  Interfaces with Variable MTU Values**

효과적인 MTU는 ROHC\(RObust Header Compression\) \[37\]와 같은 가변 압축과 함께 사용될 때와 같이 때때로 달라질 수 있습니다. 압축된 페이로드의 가장 효율적인 사용을 지원하기 위해 가능한 가장 큰 MSS를 광고하는 것은 TCP 구현에 대한 유혹입니다. 불행하게도 일부 압축 방식은 엔드포인트 압축기/압축 해제기에서 상태를 재동기화하기 위해 전체 헤더\(따라서 더 작은 페이로드\)를 전송해야 하는 경우가 있습니다. MSS 옵션에 광고할 값을 계산하는 데 가장 큰 MTU가 사용되는 경우 TCP 재전송으로 인해 압축기 재동기화가 방해될 수 있습니다.

결과적으로 인터페이스의 유효 MTU가 패킷별로 달라지는 경우 TCP 구현은 인터페이스의 가장 작은 유효 MTU를 사용하여 MSS 옵션\(SHLD-6\)에 광고할 값을 계산해야 합니다.\(SHOULD\)

---
#### **3.7.4.  Nagle Algorithm**

"Nagle 알고리즘"은 RFC 896 \[17\]에 설명되어 있으며 너무 많은 작은 패킷이 생성되는 초기 문제를 완화하기 위해 RFC 1122 \[19\]에서 권장되었습니다. 이는 대부분의 최신 TCP 코드 기반에서 구현되었으며 때로는 약간의 변형이 있었습니다\(부록 A.3 참조\).

확인되지 않은 데이터\(예: SND.NXT \> SND.UNA\)가 있는 경우 전송 TCP 끝점은 미해결 데이터가 확인될 때까지 또는 TCP 끝점에서 전체 데이터를 보낼 수 있을 때까지 PSH 비트에 관계없이 모든 사용자 데이터를 버퍼링합니다. 크기가 지정된 세그먼트\(Eff.snd.MSS 바이트\).

TCP 구현은 짧은 세그먼트\(SHLD-7\)를 통합하기 위해 Nagle 알고리즘을 구현해야 합니다. 그러나 애플리케이션이 개별 연결에서 Nagle 알고리즘을 비활성화할 수 있는 방법이 있어야 합니다\(MUST-17\). 모든 경우에 데이터 전송에는 느린 시작 알고리즘\[8\]에 의해 부과된 제한이 적용됩니다.\(SHOULD, MUST\)

Nagle 알고리즘과 지연된 승인 사이에 문제가 있는 상호 작용이 있을 수 있으므로 일부 구현에서는 부록 A.3에 설명된 것과 같은 Nagle 알고리즘의 사소한 변형을 사용합니다.

---
#### **3.7.5.  IPv6 Jumbograms**

IPv6 점보그램을 통한 TCP를 지원하려면 구현 시 MSS 옵션이 전달할 수 있는 64KB 제한보다 큰 TCP 세그먼트를 보낼 수 있어야 합니다. RFC 2675\[24\]에서는 MSS 값 65,535바이트를 무한대로 처리하도록 정의하고 있으며, Path MTU Discovery\[14\]를 사용하여 실제 MSS를 결정합니다.

점보 페이로드 옵션은 MTU가 65,575보다 큰 링크에 대한 연결을 지원하지 않는 IPv6 노드에서 구현하거나 이해할 필요가 없으며\[24\] 현재 IPv6 노드 요구 사항에는 점보그램\[55\]에 대한 지원이 포함되지 않습니다.

---
### **3.8.  Data Communication**

연결이 설정되면 세그먼트 교환을 통해 데이터가 전달됩니다. 오류\(체크섬 테스트 실패\) 또는 네트워크 정체로 인해 세그먼트가 손실될 수 있으므로 TCP는 재전송을 사용하여 모든 세그먼트의 전달을 보장합니다. 네트워크 또는 TCP 재전송으로 인해 중복 세그먼트가 도착할 수 있습니다. 시퀀스 번호 섹션\(섹션 3.4\)에서 설명한 대로 TCP 구현은 세그먼트의 시퀀스 및 승인 번호에 대한 특정 테스트를 수행하여 허용 여부를 확인합니다.

데이터 송신자는 변수 SND.NXT에서 사용할 다음 시퀀스 번호를 추적합니다. 데이터 수신자는 변수 RCV.NXT에서 예상되는 다음 시퀀스 번호를 추적합니다. 데이터 송신자는 변수 SND.UNA에서 가장 오래되고 승인되지 않은 시퀀스 번호를 추적합니다. 데이터 흐름이 일시적으로 유휴 상태이고 전송된 모든 데이터가 확인된 경우 세 가지 변수는 동일합니다.

송신자가 세그먼트를 생성하여 전송할 때 송신자는 SND.NXT를 진행합니다. 수신자가 세그먼트를 수락하면 RCV.NXT를 진행하고 승인을 보냅니다. 데이터 송신자는 승인을 받으면 SND.UNA를 진행합니다. 이러한 변수의 값이 다른 정도는 통신 지연의 척도입니다. 변수가 향상되는 양은 세그먼트의 데이터 길이와 SYN 또는 FIN 플래그입니다. 일단 ESTABLISHED 상태가 되면 모든 세그먼트는 현재 승인 정보를 전달해야 합니다.

CLOSE 사용자 호출은 들어오는 세그먼트의 FIN 제어 플래그와 마찬가지로 푸시 기능\(섹션 3.9.1 참조\)을 의미합니다.

---
#### **3.8.1.  Retransmission Timeout**

인터네트워크 시스템을 구성하는 네트워크의 가변성과 TCP 연결의 광범위한 사용으로 인해 RTO\(재전송 시간 초과\)를 동적으로 결정해야 합니다.

RTO는 RTT 샘플을 채취하기 위한 Karn의 알고리즘\(MUST-18\)을 포함하여 \[10\]의 알고리즘에 따라 계산되어야 합니다.\(MUST\)

RFC 793에는 IEN 177\[71\]에 언급된 작업을 기반으로 RTO를 계산하기 위한 초기 예제 절차가 포함되어 있습니다. 그런 다음 이는 RFC 1122에 설명된 알고리즘으로 대체되었으며, 이후 RFC 2988에서 업데이트되고 다시 RFC 6298에서 업데이트되었습니다.

RFC 1122에서는 재전송된 패킷이 원래 패킷과 동일한 경우\(이는 데이터 경계가 변경되지 않았을 뿐만 아니라 헤더도 변경되지 않았음을 의미함\) 동일한 IPv4 식별 필드를 사용할 수 있도록 허용합니다\(섹션 참조\). RFC 1122의 3.2.1.5\) \(5월 4일\). 동일한 IP 식별 필드는 데이터그램이 조각화될 때만 의미가 있기 때문에 어쨌든 재사용될 수 있습니다\[44\]. TCP 구현은 어떤 방식으로든 이 IPv4 헤더 필드에 의존하거나 일반적으로 상호 작용해서는 안 됩니다. 중복된 전송 세그먼트를 표시하거나 중복된 수신 세그먼트를 식별하는 것은 합리적인 방법이 아닙니다.\(MAY\)

---
#### **3.8.2.  TCP Congestion Control**

RFC 2914 \[5\]는 인터넷 혼잡 제어의 중요성을 설명합니다.

RFC 1122에서는 동일한 세그먼트에 대한 연속 RTO 값에 대한 지수 백오프와 함께 Van Jacobson의 혼잡 제어 알고리즘 느린 시작 및 혼잡 회피를 구현하도록 요구했습니다. RFC 2581은 빠른 재전송 및 빠른 복구와 함께 느린 시작 및 혼잡 회피에 대한 IETF 표준 트랙 설명을 제공했습니다. RFC 5681은 이러한 알고리즘에 대한 현재 설명이며 TCP 혼잡 제어에 대한 지침을 제공하는 현재 표준 트랙 사양입니다. RFC 6298은 새 데이터가 포함된 후속 세그먼트가 전송되고 재전송 없이 승인될 때까지 백오프 값을 유지하는 것을 포함하여 RTO 값의 지수 백오프에 대해 설명합니다.

TCP 엔드포인트는 혼잡 붕괴 조건 생성을 방지하기 위해 기본 혼잡 제어 알고리즘 느린 시작, 혼잡 회피 및 RTO의 지수 백오프를 구현해야 합니다\(MUST-19\). RFC 5681 및 RFC 6298은 광범위하게 적용할 수 있는 IETF 표준 트랙의 기본 알고리즘을 설명합니다. 다른 여러 가지 적합한 알고리즘이 존재하며 널리 사용되었습니다. 많은 TCP 구현은 엔드포인트에서 사용하도록 구성할 수 있는 대체 알고리즘 세트를 지원합니다. 알고리즘이 RFC 2914, RFC 5033 \[7\] 및 RFC 8961 \[15\]\(5월 18일\)에 설명된 대로 IETF 표준 트랙의 TCP 사양을 준수하는 경우 엔드포인트는 이러한 대체 알고리즘을 구현할 수 있습니다.\(MUST, MAY\)

ECN\(명시적 혼잡 알림\)은 RFC 3168에 정의되어 있으며 많은 이점을 제공하는 IETF 표준 트랙 향상 기능입니다\[51\].

TCP 엔드포인트는 RFC 3168\(SHLD-8\)에 설명된 대로 ECN을 구현해야 합니다\(SHOULD\).\(SHOULD\)

---
#### **3.8.3.  TCP Connection Failures**

TCP 끝점에 의한 동일한 세그먼트의 과도한 재전송은 원격 호스트 또는 인터네트워크 경로에 일부 오류가 있음을 나타냅니다. 이 실패는 짧을 수도 있고 길 수도 있습니다. 데이터 세그먼트의 과도한 재전송을 처리하려면 다음 절차를 사용해야 합니다\(MUST-20\).\(MUST\)

\(a\) 동일한 세그먼트에 대해 발생한 재전송량을 측정하는 두 개의 임계값 R1과 R2가 있습니다. R1 및 R2는 시간 단위 또는 재전송 횟수로 측정될 수 있습니다\(필요한 경우 현재 RTO 및 해당 백오프를 변환 계수로 사용\).

\(b\) 동일한 세그먼트의 전송 횟수가 임계값 R1에 도달하거나 초과하면 부정적인 조언\(\[19\]의 섹션 3.3.1.4 참조\)을 IP 계층에 전달하여 데드 게이트웨이 진단을 트리거합니다.

\(c\) 동일 세그먼트의 전송 횟수가 R1보다 큰 임계값 R2에 도달하면 연결을 닫습니다.

\(d\) 애플리케이션은 특정 연결에 대해 R2 값을 설정할 수 있어야 합니다\(MUST-21\). 예를 들어 대화형 애플리케이션은 R2를 "무한대"로 설정하여 사용자가 연결을 끊을 시기를 제어할 수 있습니다.\(MUST\)

\(e\) TCP 구현은 R1에 도달하고 R2\(SHLD-9\) 이전에 전달 문제를 애플리케이션에 알려야 합니다\(해당 정보가 애플리케이션에 의해 비활성화되지 않은 경우, "비동기 보고서" 섹션\(섹션 3.9.1.8\) 참조\). \). 예를 들어, 이를 통해 원격 로그인 응용 프로그램이 사용자에게 이를 알릴 수 있습니다.\(SHOULD\)

R1의 값은 현재 RTO\(SHLD-10\)에서 최소 3번의 재전송에 해당해야 합니다. R2의 값은 최소 100초에 해당해야 합니다\(SHLD-11\).\(SHOULD, SHOULD\)

SYN 세그먼트의 과도한 재전송이나 RST 세그먼트 수신 또는 ICMP 포트 연결 불가로 인해 TCP 연결을 열려는 시도가 실패할 수 있습니다. SYN 재전송은 애플리케이션 계층 알림을 포함하여 데이터 재전송에 대해 방금 설명한 일반적인 방식으로 처리되어야 합니다.\(MUST\)

그러나 R1과 R2의 값은 SYN 및 데이터 세그먼트에 따라 다를 수 있습니다. 특히, SYN 세그먼트에 대한 R2는 최소 3분 동안 세그먼트 재전송을 제공할 수 있을 만큼 크게 설정되어야 합니다\(MUST-23\). 물론 애플리케이션은 연결을 더 빨리 닫을 수 있습니다\(즉, 열기 시도를 포기함\).\(MUST\)

---
#### **3.8.4.  TCP Keep-Alives**

오랜 시간 동안 수신된 들어오는 세그먼트가 없고 전송될 새 데이터나 승인되지 않은 데이터가 없는 경우 TCP 연결이 "유휴" 상태라고 합니다.

구현자는 TCP 구현에 "keep-alives"를 포함할 수 있지만\(MAY-5\), 이 관행이 보편적으로 허용되지는 않습니다. 그러나 일부 TCP 구현에는 연결 유지 메커니즘이 포함되어 있습니다. 유휴 연결이 여전히 활성 상태인지 확인하기 위해 이러한 구현에서는 TCP 피어로부터 응답을 유도하도록 설계된 프로브 세그먼트를 보냅니다. 이러한 세그먼트에는 일반적으로 SEG.SEQ = SND.NXT-1이 포함되며 하나의 가비지 옥텟 데이터가 포함될 수도 있고 포함되지 않을 수도 있습니다. 연결 유지가 포함된 경우 애플리케이션은 각 TCP 연결에 대해 이를 켜거나 끌 수 있어야 하며\(MUST-24\) 기본적으로 꺼짐으로 설정되어야 합니다\(MUST-25\).\(MAY, MUST\)

Keep-alive 패킷은 전송된 데이터가 미해결 상태이고 간격\(MUST-26\) 내 연결에 대해 데이터 또는 승인 패킷이 수신되지 않은 경우에만 전송되어야 합니다. 이 간격은 구성 가능해야 하며\(MUST-27\) 기본값은 2시간 이상이어야 합니다\(MUST-28\).\(MUST, MUST\)

데이터가 포함되지 않은 ACK 세그먼트는 TCP에 의해 안정적으로 전송되지 않는다는 점을 기억하는 것이 매우 중요합니다. 결과적으로, 연결 유지 메커니즘이 구현된 경우 특정 프로브에 대한 응답 실패를 데드 연결로 해석하면 안 됩니다\(MUST-29\).\(MUST NOT\)

구현은 데이터가 없는 연결 유지 세그먼트\(SHLD-12\)를 보내야 합니다. 그러나 잘못된 TCP 구현과의 호환성을 위해 하나의 가비지 옥텟\(MAY-6\)을 포함하는 연결 유지 세그먼트를 보내도록 구성할 수 있습니다.\(SHOULD\)

---
#### **3.8.5.  The Communication of Urgent Information**

구현 차이와 미들박스 상호 작용의 결과로 새로운 애플리케이션은 TCP 긴급 메커니즘\(SHLD-13\)을 사용해서는 안 됩니다. 그러나 TCP 구현에는 여전히 긴급 메커니즘\(MUST-30\)에 대한 지원이 포함되어야 합니다. 일부 TCP 구현이 긴급 포인터를 해석하는 방법에 대한 정보는 RFC 6093 \[39\]에서 찾을 수 있습니다.\(SHOULD NOT, MUST\)

TCP 긴급 메커니즘의 목적은 송신 사용자가 수신 사용자가 일부 긴급 데이터를 수락하도록 자극하고 수신 TCP 엔드포인트가 현재 알려진 모든 긴급 데이터가 사용자에 의해 수신되었을 때 수신 사용자에게 표시하도록 허용하는 것입니다.

이 메커니즘을 사용하면 데이터 스트림의 한 지점을 긴급 정보의 끝으로 지정할 수 있습니다. 이 지점이 수신 TCP 끝점의 수신 시퀀스 번호\(RCV.NXT\)보다 앞에 있을 때마다 TCP 구현은 사용자에게 "긴급 모드"로 들어가도록 알려야 합니다. 수신 시퀀스 번호가 긴급 포인터를 따라잡으면 TCP 구현은 사용자에게 "일반 모드"로 들어가도록 알려야 합니다. 사용자가 "긴급 모드"에 있는 동안 긴급 포인터가 업데이트되면 업데이트가 사용자에게 표시되지 않습니다.

이 방법은 전송되는 모든 세그먼트에 전달되는 긴급 필드를 사용합니다. URG 제어 플래그는 긴급 필드가 의미가 있으며 긴급 포인터를 생성하기 위해 세그먼트 시퀀스 번호에 추가되어야 함을 나타냅니다. 이 플래그가 없으면 미해결 긴급 데이터가 없음을 나타냅니다.

긴급 표시를 보내려면 사용자는 최소한 하나의 데이터 옥텟도 보내야 합니다. 보내는 사용자가 푸시를 나타내면 긴급 정보를 대상 프로세스에 적시에 전달하는 것이 향상됩니다. 긴급 포인터의 변경 사항은 전송 애플리케이션에서 기록되는 데이터에 해당하기 때문에 긴급 포인터는 시퀀스 공간에서 "후퇴"될 수 없지만 TCP 수신기는 유효하지 않은 긴급 포인터 값에 대해 견고해야 합니다.

TCP 구현은 모든 길이의 긴급 데이터 시퀀스를 지원해야 합니다\(MUST-31\)\[19\].\(MUST\)

긴급 포인터는 긴급 데이터 뒤에 오는 옥텟의 시퀀스 번호를 가리켜야 합니다\(MUST-62\).\(MUST\)

TCP 구현은 긴급 포인터를 수신하고 이전에 보류 중인 긴급 데이터가 없었을 때마다 또는 긴급 포인터가 데이터 스트림에서 진행될 때마다 애플리케이션 계층에 비동기적으로 알려야 합니다\(MUST-32\). TCP 구현은 애플리케이션이 연결에서 읽어야 할 긴급 데이터의 양을 알거나 적어도 더 긴급한 데이터를 읽어야 할지 여부를 판단할 수 있는 방법을 제공해야 합니다\[19\].\(MUST, MUST\)

---
#### **3.8.6.  Managing the Window**

각 세그먼트에 전송된 창은 창의 전송자\(데이터 수신자\)가 현재 수락할 준비가 되어 있는 시퀀스 번호의 범위를 나타냅니다. 이는 현재 이 연결에 사용 가능한 데이터 버퍼 공간과 관련이 있다는 가정이 있습니다.

송신 TCP 엔드포인트는 전송할 데이터를 현재 창에 맞는 세그먼트로 패키징하고 재전송 큐의 세그먼트를 다시 패키징할 수 있습니다. 이러한 재포장은 필수는 아니지만 도움이 될 수 있습니다.

단방향 데이터 흐름과 관련하여 창 정보는 모두 동일한 시퀀스 번호를 갖는 승인 세그먼트에 전달되므로 순서가 잘못되어 도착하면 순서를 바꿀 방법이 없습니다. 이는 심각한 문제는 아니지만 때때로 데이터 수신기의 이전 보고서를 기반으로 창 정보가 일시적으로 표시될 수 있습니다. 이 문제를 피하기 위한 개선 방법은 가장 높은 승인 번호를 전달하는 세그먼트\(즉, 이전에 수신한 가장 높은 승인 번호와 같거나 큰 승인 번호를 가진 세그먼트\)의 창 정보에 대해 조치를 취하는 것입니다.

큰 창을 표시하면 전송이 촉진됩니다. 허용할 수 있는 것보다 더 많은 데이터가 도착하면 해당 데이터는 삭제됩니다. 이로 인해 과도한 재전송이 발생하여 네트워크 및 TCP 끝점에 불필요하게 로드가 추가됩니다. 작은 창을 표시하면 전송된 각 새 세그먼트 사이에 왕복 지연이 도입되는 지점까지 데이터 전송이 제한될 수 있습니다.

제공된 메커니즘을 사용하면 TCP 엔드포인트가 큰 창을 광고하고 이후에 많은 데이터를 허용하지 않고도 훨씬 작은 창을 광고할 수 있습니다. 소위 "창 축소"는 권장되지 않습니다. 견고성 원칙\[19\]은 TCP 피어가 창 자체를 축소하지 않고 다른 TCP 피어 측에서 그러한 동작에 대비하도록 지시합니다.

TCP 수신기는 창을 축소해서는 안 됩니다. 즉, 오른쪽 창 가장자리를 왼쪽으로 이동하면 안 됩니다\(SHLD-14\). 그러나 송신 TCP 피어는 창 축소에 대해 강력해야 하며, 이로 인해 "사용 가능한 창"\(섹션 3.8.6.2.1 참조\)이 음수가 될 수 있습니다\(MUST-34\).\(SHOULD NOT, MUST\)

이런 일이 발생하면 발신자는 새 데이터\(SHLD-15\)를 보내면 안 되지만, SND.UNA와 SND.UNA+SND.WND\(SHLD-16\) 사이에 확인되지 않은 이전 데이터를 정상적으로 재전송해야 합니다. 발신자는 또한 SND.UNA+SND.WND\(MAY-7\)를 넘어 오래된 데이터를 재전송할 수 있지만\(SHLD-17\) 오른쪽 창 가장자리를 넘어선 데이터가 승인되지 않으면 연결 시간을 초과해서는 안 됩니다. 창이 0으로 축소되면 TCP 구현은 표준 방식\(아래 설명\)으로 이를 조사해야 합니다\(MUST-35\).\(SHOULD NOT, SHOULD NOT, MUST\)

---
##### **3.8.6.1.  Zero-Window Probing**

송신 TCP 피어는 창을 "탐색"하기 위해 정기적으로 최소 1옥텟의 새 데이터\(사용 가능한 경우\)를 전송하거나 송신 창이 0인 경우에도 수신 TCP 피어에 재전송해야 합니다. 이 재전송은 TCP 피어 중 하나에 창이 0일 때 창 다시 열기가 다른 쪽에게 안정적으로 보고되도록 보장하는 데 필수적입니다. 다른 문서에서는 이를 ZWP\(Zero-Window Probing\)라고 합니다.

제로\(제공된\) 창의 프로빙이 지원되어야 합니다\(MUST-36\).\(MUST\)

TCP 구현은 제공된 수신 창을 무기한 닫혀 있는 상태로 유지할 수 있습니다\(5월 8일\). 수신 TCP 피어가 프로브 세그먼트에 대한 응답으로 계속해서 승인을 보내는 한, 송신 TCP 피어는 연결이 열린 상태를 유지하도록 허용해야 합니다\(MUST-37\). 이를 통해 \[19\]의 섹션 4.2.2.17에 설명된 "프린터의 용지 부족" 상황과 같은 시나리오에서 TCP가 작동할 수 있습니다. \[41\]에 명시된 대로 동작은 구현의 리소스 관리 문제에 따라 달라집니다.\(MAY, MUST\)

수신 TCP 피어의 창이 0이고 세그먼트가 도착하면 다음 예상 시퀀스 번호와 현재 창\(0\)을 표시하는 승인을 계속 보내야 합니다.

전송 호스트는 재전송 시간 초과 기간\(SHLD-29\)\(섹션 3.8.1\) 동안 제로 윈도우가 존재할 때 첫 번째 제로 윈도우 프로브를 보내야 하며, 연속 프로브\(SHLD-30\) 사이의 간격을 기하급수적으로 늘려야 합니다.\(SHOULD\)

---
##### **3.8.6.2.  Silly Window Syndrome Avoidance**

"바보 창 증후군"\(SWS\)은 작은 증분 창 이동의 안정적인 패턴으로, 이로 인해 TCP 성능이 극도로 저하됩니다. SWS를 방지하는 알고리즘은 송신측과 수신측 모두에 대해 아래에 설명되어 있습니다. RFC 1122에는 SWS 문제에 대한 자세한 설명이 포함되어 있습니다. Nagle 알고리즘과 보낸 사람 SWS 회피 알고리즘은 성능 향상에 보완적인 역할을 합니다. Nagle 알고리즘은 전송될 데이터가 작은 증분으로 증가할 때 작은 세그먼트를 보내는 것을 방지하는 반면, SWS 회피 알고리즘은 작은 증분으로 진행되는 오른쪽 창 가장자리로 인해 발생하는 작은 세그먼트를 보내는 것을 방지합니다.

---
###### **3.8.6.2.1.  Sender's Algorithm -- When to Send Data**

TCP 구현에는 발신자에 SWS 회피 알고리즘이 포함되어야 합니다\(MUST-38\).\(MUST\)

섹션 3.7.4의 Nagle 알고리즘은 짧은 세그먼트를 병합하는 방법을 추가로 설명합니다.

송신자의 SWS 회피 알고리즘은 수신자의 SWS 회피 알고리즘보다 더 어렵습니다. 왜냐하면 송신자는 수신자의 전체 버퍼 공간\(RCV.BUFF\)을 \(직접\) 모르기 때문입니다. 잘 작동하는 것으로 확인된 접근 방식은 송신자가 지금까지 연결에서 본 최대 송신 창인 Max\(SND.WND\)를 계산하고 이 값을 RCV.BUFF의 추정치로 사용하는 것입니다. 안타깝게도 이는 추정치일 뿐입니다. 수신기는 언제든지 RCV.BUFF의 크기를 줄일 수 있습니다. 결과적인 교착 상태를 방지하려면 SWS 회피 알고리즘을 재정의하여 데이터를 강제로 전송하는 시간 초과가 필요합니다. 실제로 이러한 시간 초과는 거의 발생하지 않습니다.

"사용 가능한 창"은 다음과 같습니다.

```text
      U = SND.UNA + SND.WND - SND.NXT
```

즉, 제공된 창에서 전송되었지만 승인되지 않은 데이터의 양이 적습니다. D가 송신 TCP 엔드포인트에 대기 중이지만 아직 전송되지 않은 데이터의 양인 경우 다음 규칙 세트가 권장됩니다.

```text
   Send data:
```

\(1\) 최대 크기의 세그먼트를 전송할 수 있는지, 즉 다음과 같은 경우

```text
           min(D,U) >= Eff.snd.MSS;
```

\(2\) 또는 데이터가 푸시되고 대기 중인 모든 데이터가 지금 전송될 수 있는 경우, 즉 다음과 같은 경우입니다.

- \[SND.NXT = SND.UNA 및\] PUSHed 및 D <= U

```text
        (the bracketed condition is imposed by the Nagle algorithm);
```

\(3\) 또는 최대 창의 최소한 일부 Fs가 전송될 수 있는 경우, 즉 다음과 같은 경우:

```text
           [SND.NXT = SND.UNA and]

              min(D,U) >= Fs * Max(SND.WND);
```

\(4\) 또는 재정의 시간 초과가 발생한 경우.

여기서 Fs는 권장 값이 1/2인 분수입니다. 재정의 시간 제한은 0.1\~1.0초 범위에 있어야 합니다. 이 타이머를 제로 창을 조사하는 데 사용되는 타이머와 결합하는 것이 편리할 수 있습니다\(섹션 3.8.6.1\).

---
###### **3.8.6.2.2.  Receiver's Algorithm -- When to Send a Window Update**

TCP 구현은 수신기에 SWS 회피 알고리즘을 포함해야 합니다\(MUST-39\).\(MUST\)

수신기의 SWS 회피 알고리즘은 오른쪽 창 가장자리가 전진할 수 있는 시기를 결정합니다. 이는 일반적으로 "창 업데이트"로 알려져 있습니다. 이 알고리즘은 지연된 ACK 알고리즘\(섹션 3.8.6.3\)과 결합되어 현재 창을 포함하는 ACK 세그먼트가 실제로 수신자에게 전송되는 시기를 결정합니다.

수신기 SWS에 대한 솔루션은 네트워크에서 작은 세그먼트로 데이터를 수신하더라도 오른쪽 창 가장자리 RCV.NXT+RCV.WND를 작은 증분으로 진행하지 않는 것입니다.

총 수신 버퍼 공간이 RCV.BUFF라고 가정합니다. 언제든지 이 총계의 RCV.USER 옥텟은 수신 및 승인되었지만 사용자 프로세스가 아직 사용하지 않은 데이터와 연결될 수 있습니다. 연결이 정지된 경우 RCV.WND = RCV.BUFF 및 RCV.USER = 0입니다.

데이터가 도착하고 승인될 때 오른쪽 창 가장자리를 고정된 상태로 유지하려면 수신기가 전체 버퍼 공간보다 적은 공간을 제공해야 합니다. 즉, 수신기는 RCV.NXT가 증가함에 따라 RCV.NXT+RCV.WND를 일정하게 유지하는 RCV.WND를 지정해야 합니다. 따라서 총 버퍼 공간 RCV.BUFF는 일반적으로 세 부분으로 나뉩니다.

```text
                  |<------- RCV.BUFF ---------------->|
                       1             2            3
              ----|---------|------------------|------|----
                         RCV.NXT               ^
                                            (Fixed)
```

- 1 - RCV.USER = 데이터가 수신되었지만 아직 소비되지 않았습니다. 2 - RCV.WND = 발신자에게 공지된 공간입니다. 3 - 감소 = 사용 가능한 공간이 있지만 아직 광고되지 않았습니다.

수신기에 대해 제안된 SWS 회피 알고리즘은 감소가 만족될 때까지 RCV.NXT+RCV.WND를 고정된 상태로 유지하는 것입니다.

```text
                RCV.BUFF - RCV.USER - RCV.WND  >=

                       min( Fr * RCV.BUFF, Eff.snd.MSS )
```

여기서 Fr은 ​​권장 값이 1/2인 분수이고 Eff.snd.MSS는 연결에 대한 효과적인 전송 MSS입니다\(섹션 3.7.1 참조\). 부등식이 만족되면 RCV.WND는 RCV.BUFF-RCV.USER로 설정됩니다.

이 알고리즘의 일반적인 효과는 Eff.snd.MSS의 증분으로 RCV.WND를 향상시키는 것입니다\(현실적인 수신 버퍼의 경우: Eff.snd.MSS < RCV.BUFF/2\). 또한 수신자는 자신의 Eff.snd.MSS를 사용해야 하며 송신자의 것과 동일하다고 가정해야 합니다.

---
##### **3.8.6.3.  Delayed Acknowledgments -- When to Send an ACK Segment**

TCP 데이터 세그먼트 스트림을 수신하는 호스트는 수신된 데이터 세그먼트당 1개 미만의 ACK\(승인\) 세그먼트를 전송하여 네트워크와 호스트 모두의 효율성을 높일 수 있습니다. 이를 "지연된 ACK"이라고 합니다.

TCP 엔드포인트는 지연된 ACK\(SHLD-18\)를 구현해야 하지만 ACK가 과도하게 지연되어서는 안 됩니다. 특히 지연은 0.5초 미만이어야 합니다\(MUST-40\). ACK는 적어도 두 번째 전체 크기 세그먼트 또는 새 데이터의 2\*RMSS 바이트마다 생성되어야 합니다\(여기서 RMSS는 승인할 세그먼트를 수신하는 TCP 끝점에 의해 지정된 MSS이거나 지정되지 않은 경우 기본값입니다\)\(SHLD -19\). ACK의 과도한 지연은 왕복 타이밍 및 패킷 "클럭킹" 알고리즘을 방해할 수 있습니다. 지연된 ACK 동작에 대한 보다 완전한 논의는 RFC 5681\[8\]의 섹션 4.2에 있습니다. 여기에는 순서가 잘못된 세그먼트, 시퀀스 공간의 갭 위에 있는 세그먼트 또는 갭의 전부 또는 일부를 채우는 세그먼트를 즉시 승인하는 권장 사항이 포함됩니다. 손실회복을 가속화하기 위해\(MUST, SHOULD\)

일반 수신 오프로드\(GRO\)\[72\], ACK 압축 및 ACK 데시메이션\[28\]을 포함하여 ACK 수를 더욱 줄이는 여러 가지 현재 사례가 있습니다.

---
### **3.9.  Interfaces**

물론 두 가지 인터페이스, 즉 사용자/TCP 인터페이스와 TCP/하위 수준 인터페이스가 있습니다. 우리는 사용자/TCP 인터페이스에 대한 상당히 정교한 모델을 가지고 있지만 하위 수준 프로토콜 모듈에 대한 인터페이스는 하위 수준 프로토콜 사양에 의해 자세히 지정되므로 여기서는 지정되지 않은 채로 남아 있습니다. 하위 수준이 IP인 경우 TCP 구현에서 사용할 수 있는 일부 매개변수 값에 주목합니다.

---
#### **3.9.1.  User/TCP Interface**

TCP 구현에 대한 사용자 명령에 대한 다음 기능 설명은 기껏해야 가상입니다. 모든 운영 체제에는 서로 다른 기능이 있기 때문입니다. 결과적으로 우리는 독자들에게 서로 다른 TCP 구현이 서로 다른 사용자 인터페이스를 가질 수 있음을 경고해야 합니다. 그러나 모든 TCP 구현은 모든 TCP 구현이 동일한 프로토콜 계층을 지원할 수 있도록 보장하기 위해 특정 최소 서비스 집합을 제공해야 합니다. 이 섹션에서는 모든 TCP 구현에 필요한 기능적 인터페이스를 지정합니다.

\[53\]의 섹션 3.1은 또한 TCP가 제공하는 기본 요소를 식별하며 구현자를 위한 추가 참조로 사용될 수 있습니다.

다음 섹션에서는 사용자/TCP 인터페이스의 기능적 특성을 설명합니다. 사용된 표기법은 고급 언어의 대부분 프로시저 또는 함수 호출과 유사하지만 이 사용법이 트랩 유형 서비스 호출을 배제하려는 의미는 아닙니다.

아래에 설명된 사용자 명령은 프로세스 간 통신을 지원하기 위해 TCP 구현이 수행해야 하는 기본 기능을 지정합니다. 개별 구현은 고유한 정확한 형식을 정의해야 하며 단일 호출에서 기본 기능의 조합 또는 하위 집합을 제공할 수 있습니다. 특히, 일부 구현에서는 주어진 연결에 대해 사용자가 발행한 첫 번째 SEND 또는 RECEIVE에서 연결을 자동으로 OPEN하기를 원할 수 있습니다.

프로세스 간 통신 기능을 제공할 때 TCP 구현은 명령을 수락해야 할 뿐만 아니라 서비스를 제공하는 프로세스에 정보를 반환해야 합니다. 후자는 다음으로 구성됩니다.

\(a\) 연결에 관한 일반 정보\(예: 인터럽트, 원격 닫기, 지정되지 않은 원격 소켓 바인딩\)

\(b\) 성공 또는 다양한 유형의 실패를 나타내는 특정 사용자 명령에 응답합니다.

---
##### **3.9.1.1.  Open**

```text
   Format: OPEN (local port, remote socket, active/passive [, timeout]
   [, Diffserv field] [, security/compartment] [, local IP address] [,
   options]) -> local connection name
```

활성/수동 플래그가 수동으로 설정된 경우 이는 들어오는 연결에 대한 LISTEN 호출입니다. 수동 OPEN에는 특정 연결을 기다리는 완전히 지정된 원격 소켓이나 모든 호출을 기다리는 지정되지 않은 원격 소켓이 있을 수 있습니다. 완전히 지정된 수동 호출은 후속 SEND 실행을 통해 활성화될 수 있습니다.

전송 제어 블록\(TCB\)이 생성되고 OPEN 명령 매개변수의 데이터로 부분적으로 채워집니다.

모든 수동 OPEN 호출은 LISTEN 상태에서 새 연결 레코드를 생성하거나 오류를 반환합니다. 이전에 생성된 연결 레코드에 영향을 주어서는 안 됩니다\(MUST-41\).\(MUST NOT\)

여러 동시 연결을 지원하는 TCP 구현은 동일한 로컬 포트가 있는 연결 블록이 SYN-SENT 또는 SYN-RECEIVED 상태\(MUST-42\)에 있는 동안 애플리케이션이 포트에서 LISTEN을 기능적으로 허용하는 OPEN 호출을 제공해야 합니다.\(MUST\)

활성 OPEN 명령에서 TCP 끝점은 연결을 동기화\(즉, 설정\)하는 절차를 즉시 시작합니다.

시간 제한이 있는 경우 호출자는 TCP에 제출된 모든 데이터에 대한 시간 제한을 설정할 수 있습니다. 제한 시간 내에 데이터가 대상으로 성공적으로 전달되지 않으면 TCP 끝점은 연결을 중단합니다. 현재 전역 기본값은 5분입니다.

TCP 구현 또는 운영 체제의 일부 구성 요소는 지정된 Diffserv 필드 값 또는 보안/구획을 사용하여 연결을 열 수 있는 사용자 권한을 확인합니다. OPEN 호출에 Diffserv 필드 값이나 보안/구획 사양이 없으면 기본값을 사용해야 함을 나타냅니다.

TCP는 보안/구획 정보가 OPEN 호출에서 요청한 것과 정확히 동일한 경우에만 들어오는 요청을 일치하는 것으로 받아들입니다.

사용자가 표시한 Diffserv 필드 값은 나가는 패킷에만 영향을 미치고 네트워크를 통해 도중에 변경될 수 있으며 수신된 패킷과 직접적인 관련이나 관련이 없습니다.

로컬 연결 이름은 TCP 구현에 의해 사용자에게 반환됩니다. 그런 다음 로컬 연결 이름을 <로컬 소켓, 원격 소켓\> 쌍으로 정의된 연결에 대한 약식 용어로 사용할 수 있습니다.

로컬 IP 주소 지정을 허용하려면 선택적 "로컬 IP 주소" 매개변수를 지원해야 합니다\(MUST-43\). 이를 통해 멀티호밍이 있을 때 사용되는 로컬 IP 주소를 선택해야 하는 애플리케이션이 가능해집니다.\(MUST\)

지정된 "로컬 IP 주소" 매개변수를 사용한 수동 OPEN 호출은 해당 주소로 들어오는 연결 요청을 기다립니다. 매개변수가 지정되지 않은 경우 수동 OPEN은 로컬 IP 주소에 대한 들어오는 연결 요청을 기다린 다음 연결의 로컬 IP 주소를 사용되는 특정 주소에 바인딩합니다.

활성 OPEN 호출의 경우 지정된 "로컬 IP 주소" 매개변수가 연결을 여는 데 사용됩니다. 매개변수가 지정되지 않은 경우 호스트는 적절한 로컬 IP 주소를 선택합니다\(RFC 1122, 섹션 3.3.4.2 참조\).

멀티홈 호스트의 애플리케이션이 TCP 연결을 적극적으로 열 때 로컬 IP 주소를 지정하지 않으면 TCP 구현은 \(첫 번째\) SYN을 보내기 전에 IP 계층에 로컬 IP 주소를 선택하도록 요청해야 합니다\(MUST-44\). RFC 1122의 섹션 3.4에 있는 GET\_SRCADDR\(\) 함수를 참조하세요.\(MUST\)

다른 모든 경우에는 이전 세그먼트가 이 연결에서 전송되거나 수신되었으며 TCP 구현은 이전 세그먼트에서 사용된 것과 동일한 로컬 주소를 사용해야 합니다\(MUST-45\).\(MUST\)

TCP 구현은 잘못된 원격 IP 주소\(예: 브로드캐스트 또는 멀티캐스트 주소\)에 대한 로컬 OPEN 호출을 오류로 거부해야 합니다\(MUST-46\).\(MUST\)

---
##### **3.9.1.2.  Send**

```text
   Format: SEND (local connection name, buffer address, byte count,
   URGENT flag [, PUSH flag] [, timeout])
```

이 호출을 통해 표시된 사용자 버퍼에 포함된 데이터가 표시된 연결을 통해 전송됩니다. 연결이 열리지 않은 경우 SEND는 오류로 간주됩니다. 일부 구현에서는 사용자가 먼저 SEND를 수행하도록 허용할 수 있습니다. 이 경우 자동 OPEN이 수행됩니다. 예를 들어, 이는 애플리케이션 데이터가 SYN 세그먼트에 포함되는 한 가지 방법일 수 있습니다. 호출 프로세스에 이 연결을 사용할 권한이 없으면 오류가 반환됩니다.

TCP 끝점은 SEND 호출에 PUSH 플래그를 구현할 수 있습니다\(MAY-15\). PUSH 플래그가 구현되지 않은 경우 송신 TCP 피어는 \(1\) 데이터를 무기한 버퍼링해서는 안 되며\(MUST-60\), \(2\) 마지막 버퍼링된 세그먼트에 PSH 비트를 설정해야 합니다\(즉, 더 이상 대기 중인 세그먼트가 없을 때\). 전송될 데이터\) \(MUST-61\). 아래 나머지 설명에서는 SEND 호출에서 PUSH 플래그가 지원된다고 가정합니다.\(MAY, MUST NOT\)

PUSH 플래그가 설정되면 애플리케이션은 데이터가 수신자에게 즉시 전송되도록 의도하며 PSH 비트는 버퍼에서 생성된 마지막 TCP 세그먼트에 설정됩니다.

PSH 비트는 레코드 마커가 아니며 세그먼트 경계와 독립적입니다. 송신기는 가능한 가장 큰 세그먼트\(SHLD-27\)를 전송하기 위해 데이터를 패킷화할 때 연속 비트를 축소해야 합니다.\(SHOULD\)

PUSH 플래그가 설정되지 않은 경우 데이터는 전송 효율성을 위해 후속 SEND의 데이터와 결합될 수 있습니다. 애플리케이션이 PUSH 플래그를 설정하지 않고 일련의 SEND 호출을 발행하면 TCP 구현은 데이터를 전송하지 않고 내부적으로 데이터를 집계할 수 있습니다\(MAY-16\). Nagle 알고리즘이 사용 중일 때 TCP 구현은 PUSH 플래그에 관계없이 전송하기 전에 데이터를 버퍼링할 수 있습니다\(섹션 3.7.4 참조\).\(MAY\)

응용 프로그램은 통신 교착 상태를 피하기 위해 데이터를 강제로 전달해야 할 때마다 논리적으로 SEND 호출에 PUSH 플래그를 설정해야 합니다. 그러나 TCP 구현은 성능 향상을 위해 가능할 때마다 최대 크기의 세그먼트\(SHLD-28\)를 전송해야 합니다\(섹션 3.8.6.2.1 참조\).\(SHOULD\)

새로운 애플리케이션은 구현 차이와 미들박스 문제\(SHLD-13\)로 인해 URGENT 플래그\[39\]를 설정해서는 안 됩니다.\(SHOULD NOT\)

URGENT 플래그가 설정된 경우 대상 TCP 피어로 전송된 세그먼트에는 긴급 포인터가 설정됩니다. 긴급 포인터가 긴급 포인터 이전의 데이터가 수신 프로세스에 의해 소비되지 않았음을 나타내는 경우 수신 TCP 피어는 긴급 상황을 수신 프로세스에 알립니다. URGENT 플래그의 목적은 수신기가 긴급 데이터를 처리하도록 자극하고 현재 알려진 모든 긴급 데이터가 수신되었을 때 수신기에 알리는 것입니다. 송신 사용자의 TCP 구현 신호가 긴급한 횟수는 수신 사용자에게 긴급 데이터가 있음을 알리는 횟수와 반드시 동일하지는 않습니다.

OPEN에 원격 소켓이 지정되지 않았지만 연결이 설정된 경우\(예: 로컬 소켓에 도착하는 원격 세그먼트로 인해 LISTENing 연결이 특정화되었기 때문에\) 지정된 버퍼가 암시된 원격 소켓으로 전송됩니다. 지정되지 않은 원격 소켓으로 OPEN을 사용하는 사용자는 원격 소켓 주소를 명시적으로 알지 않고도 SEND를 사용할 수 있습니다.

그러나 원격 소켓이 지정되기 전에 SEND를 시도하면 오류가 반환됩니다. 사용자는 STATUS 호출을 사용하여 연결 상태를 확인할 수 있습니다. 일부 TCP 구현에서는 지정되지 않은 소켓이 바인딩될 때 사용자에게 알릴 수 있습니다.

시간 초과가 지정되면 이 연결에 대한 현재 사용자 시간 초과가 새 시간 초과로 변경됩니다.

가장 간단한 구현에서 SEND는 전송이 완료되거나 시간 초과가 초과될 때까지 전송 프로세스에 제어권을 반환하지 않습니다. 그러나 이 간단한 방법은 교착 상태에 걸리기 쉽고\(예를 들어 연결 양쪽에서 RECEIVE를 수행하기 전에 SEND를 시도할 수 있음\) 성능이 저하되므로 권장되지 않습니다. 보다 정교한 구현은 프로세스가 네트워크 I/O와 동시에 실행될 수 있도록 즉시 반환하고 더 나아가 여러 SEND가 진행되도록 허용합니다. 여러 개의 SEND가 선착순으로 제공되므로 TCP 엔드포인트는 즉시 서비스할 수 없는 SEND를 대기열에 넣습니다.

우리는 SEND가 나중에 서비스 제공 TCP 끝점에서 일종의 SIGNAL 또는 의사 인터럽트를 유도하는 비동기 사용자 인터페이스를 암시적으로 가정했습니다. 대안은 즉시 응답을 반환하는 것입니다. 예를 들어, 전송된 세그먼트가 먼 TCP 끝점에서 확인되지 않은 경우에도 SEND는 즉각적인 로컬 확인을 반환할 수 있습니다. 우리는 궁극적인 성공을 낙관적으로 가정할 수 있습니다. 우리가 틀렸다면 시간 초과로 인해 연결이 종료됩니다. 이러한 종류의 구현\(동기식\)에는 여전히 일부 비동기식 신호가 있지만 이는 특정 세그먼트나 버퍼가 아닌 연결 자체를 처리합니다.

프로세스가 서로 다른 SEND에 대한 오류 또는 성공 표시를 구별하려면 SEND 요청에 대한 코딩된 응답과 함께 버퍼 주소가 반환되는 것이 적절할 수 있습니다. 호출 프로세스에 반환되어야 하는 정보를 나타내는 TCP-사용자 신호는 아래에 설명되어 있습니다.

---
##### **3.9.1.3.  Receive**

```text
   Format: RECEIVE (local connection name, buffer address, byte count)
   -> byte count, URGENT flag [, PUSH flag]
```

이 명령은 지정된 연결과 관련된 수신 버퍼를 할당합니다. 이 명령 앞에 OPEN이 없거나 호출 프로세스에 이 연결을 사용할 권한이 없으면 오류가 반환됩니다.

가장 간단한 구현에서는 버퍼가 채워지거나 일부 오류가 발생할 때까지 제어가 호출 프로그램으로 반환되지 않지만 이 체계는 교착 상태에 빠지기 쉽습니다. 보다 정교한 구현을 통해 여러 RECEIVE를 동시에 뛰어난 상태로 유지할 수 있습니다. 세그먼트가 도착하면 채워집니다. 이 전략을 사용하면 PUSH가 확인되었거나 버퍼가 채워졌음을 호출 프로그램에 알리기 위해 보다 정교한 체계\(아마도 비동기식\)를 사용하여 처리량을 늘릴 수 있습니다.

TCP 수신기는 수신된 PSH 비트를 인터페이스의 PUSH 플래그를 통해 애플리케이션 계층에 전달할 수 있지만\(MAY-17\) 필수는 아닙니다\(RFC 1122, 섹션 4.2.2.2에 명시되어 있음\). 아래 RECEIVE 호출을 설명하는 나머지 텍스트에서는 PUSH 표시 전달이 지원된다고 가정합니다.\(MAY\)

PUSH가 표시되기 전에 버퍼를 채울 만큼 충분한 데이터가 도착하면 RECEIVE에 대한 응답에 PUSH 플래그가 설정되지 않습니다. 버퍼는 보유할 수 있는 만큼의 데이터로 채워집니다. 버퍼가 채워지기 전에 PUSH가 나타나면 버퍼는 부분적으로 채워진 상태로 반환되고 PUSH가 표시됩니다.

긴급한 데이터가 있는 경우 TCP-사용자 신호를 통해 도착하자마자 사용자에게 알립니다. 따라서 수신 사용자는 "긴급 모드"에 있어야 합니다. URGENT 플래그가 켜져 있으면 추가 긴급 데이터가 남습니다. URGENT 플래그가 꺼진 경우 RECEIVE에 대한 이 호출은 모든 긴급 데이터를 반환했으며 사용자는 이제 "긴급 모드"를 종료할 수 있습니다. 긴급 포인터 뒤의 데이터\(비긴급 데이터\)는 경계가 사용자에게 명확하게 표시되지 않는 한 이전 긴급 데이터와 동일한 버퍼에 있는 사용자에게 전달될 수 없습니다.

여러 미해결 RECEIVE를 구별하고 버퍼가 완전히 채워지지 않은 경우를 처리하기 위해 반환 코드에는 버퍼 포인터와 수신된 데이터의 실제 길이를 나타내는 바이트 수가 함께 제공됩니다.

RECEIVE의 대체 구현에서는 TCP 끝점이 버퍼 저장소를 할당하도록 하거나 TCP 끝점이 사용자와 링 버퍼를 공유할 수 있습니다.

---
##### **3.9.1.4.  Close**

```text
   Format: CLOSE (local connection name)
```

이 명령을 사용하면 지정된 연결이 닫힙니다. 연결이 열려 있지 않거나 호출 프로세스에 이 연결을 사용할 권한이 없으면 오류가 반환됩니다. 연결 닫기는 모든 서비스가 완료될 때까지 흐름 제어가 허용하는 대로 미해결 SEND가 전송\(및 재전송\)된다는 점에서 정상적인 작업을 의미합니다. 따라서 SEND를 여러 번 호출한 후 CLOSE를 호출하고 모든 데이터가 대상으로 전송될 것으로 예상하는 것이 허용됩니다. 또한 원격 피어가 마지막 데이터 전송을 시도할 수 있으므로 사용자는 CLOSING 연결에서 RECEIVE를 계속해야 한다는 점을 분명히 해야 합니다. 따라서 CLOSE는 "더 이상 보낼 것이 없다"는 의미이지 "더 이상 받지 않겠다"는 의미는 아닙니다. \(사용자 수준 프로토콜을 잘 고려하지 않은 경우\) 종료 측이 시간 초과 전에 모든 데이터를 제거하지 못하는 경우가 발생할 수 있습니다. 이 경우 CLOSE는 ABORT로 바뀌고 닫는 TCP 피어는 포기합니다.

사용자는 언제든지 스스로 또는 TCP 구현의 다양한 프롬프트\(예: 원격 닫기 실행, 전송 시간 초과, 대상 액세스 불가\)에 대한 응답으로 연결을 닫을 수 있습니다.

연결을 닫으려면 원격 TCP 피어와의 통신이 필요하므로 연결이 잠시 동안 닫힘 상태로 유지될 수 있습니다. TCP 피어가 CLOSE 명령에 응답하기 전에 연결을 다시 열려고 시도하면 오류 응답이 발생합니다.

```text
   Close also implies push function.
```

---
##### **3.9.1.5.  Status**

```text
   Format: STATUS (local connection name) -> status data
```

이는 구현에 따른 사용자 명령이므로 부정적인 영향 없이 제외될 수 있습니다. 반환된 정보는 일반적으로 연결과 관련된 TCB에서 제공됩니다.

이 명령은 다음 정보가 포함된 데이터 블록을 반환합니다.

```text
      local socket,

      remote socket,

      local connection name,

      receive window,

      send window,

      connection state,
```

- 승인을 기다리는 버퍼의 수,

- 수신 대기 중인 버퍼 수,

```text
      urgent state,

      Diffserv field value,

      security/compartment, and

      transmission timeout.
```

연결 상태나 구현 자체에 따라 이 정보 중 일부는 사용 가능하지 않거나 의미가 없을 수도 있습니다. 호출 프로세스에 이 연결을 사용할 권한이 없으면 오류가 반환됩니다. 이렇게 하면 승인되지 않은 프로세스가 연결에 대한 정보를 얻는 것을 방지할 수 있습니다.

---
##### **3.9.1.6.  Abort**

```text
   Format: ABORT (local connection name)
```

이 명령을 사용하면 보류 중인 모든 SEND 및 RECEIVES가 중단되고 TCB가 제거되며 특수 RST 메시지가 연결의 원격 TCP 피어로 전송됩니다. 구현에 따라 사용자는 미해결된 각 SEND 또는 RECEIVE에 대해 중단 표시를 받거나 단순히 ABORT 승인을 받을 수 있습니다.

---
##### **3.9.1.7.  Flush**

일부 TCP 구현에는 사용자가 SEND 호출을 실행했지만 여전히 현재 전송 창 오른쪽에 있는 모든 데이터의 TCP 전송 대기열을 비우는 FLUSH 호출이 포함되어 있습니다. 즉, 시퀀스 번호 동기화를 잃지 않으면서 대기 중인 전송 데이터를 최대한 많이 플러시합니다. FLUSH 호출이 구현될 수 있습니다\(5월 14일\).\(MAY\)

---
##### **3.9.1.8.  Asynchronous Reports**

소프트 TCP 오류 조건을 애플리케이션에 보고하기 위한 메커니즘이 있어야 합니다\(MUST-47\). 일반적으로 이는 전송 계층에서 비동기적으로 호출될 수 있는 애플리케이션 제공 ERROR\_REPORT 루틴의 형태를 취한다고 가정합니다.\(MUST\)

```text
      ERROR_REPORT(local connection name, reason, subreason)
```

이유 및 하위 이유 매개변수의 정확한 인코딩은 여기에 지정되지 않습니다. 그러나 애플리케이션에 비동기적으로 보고되는 조건에는 다음이 포함되어야 합니다.\(MUST\)

```text
   *  ICMP error message arrived (see Section 3.9.2.2 for description of
      handling each ICMP message type since some message types need to
      be suppressed from generating reports to the application)

   *  Excessive retransmissions (see Section 3.8.3)

   *  Urgent pointer advance (see Section 3.8.5)
```

그러나 그러한 ERROR\_REPORT 호출을 수신하고 싶지 않은 응용 프로그램은 이러한 호출을 효과적으로 비활성화할 수 있어야 합니다\(SHLD-20\).\(SHOULD\)

```text
3.9.1.9.  Set Differentiated Services Field (IPv4 TOS or IPv6 Traffic
          Class)
```

애플리케이션 계층은 연결을 통해 전송되는 세그먼트에 대해 차별화된 서비스 필드를 지정할 수 있어야 합니다\(MUST-48\). 차별화된 서비스 필드에는 6비트 DSCP\(Differentiated Services Codepoint\) 값이 포함됩니다. 필수는 아니지만 애플리케이션은 연결 수명 동안 차별화된 서비스 필드를 변경할 수 있어야 합니다\(SHLD-21\). TCP 구현은 연결\(SHLD-22\)에서 세그먼트를 보낼 때 IP 계층에 대한 변경 없이 현재 차별화된 서비스 필드 값을 전달해야 합니다\(SHOULD\).\(MUST, SHOULD, SHOULD\)

차별화된 서비스 필드는 연결의 각 방향에서 독립적으로 지정되므로 수신기 애플리케이션은 ACK 세그먼트에 사용되는 차별화된 서비스 필드를 지정합니다.

TCP 구현은 가장 최근에 수신된 차별화된 서비스 필드를 애플리케이션에 전달할 수 있습니다\(MAY-9\).\(MAY\)

---
#### **3.9.2.  TCP/Lower-Level Interface**

TCP 끝점은 실제로 네트워크를 통해 정보를 보내고 받기 위해 하위 수준 프로토콜 모듈을 호출합니다. TCP 아래에 계층화된 두 가지 현재 표준 인터넷 프로토콜\(IP\) 버전은 IPv4\[1\]와 IPv6\[13\]입니다.

하위 수준 프로토콜이 IPv4인 경우 서비스 유형\(차별화된 서비스 필드 내에서 사용됨\) 및 TTL\(Time to Live\)에 대한 인수를 제공합니다. TCP는 이러한 매개변수에 대해 다음 설정을 사용합니다.

Diffserv 필드: Diffserv 필드의 IP 헤더 값은 사용자가 제공합니다. 여기에는 DSCP\(Diffserv Codepoint\) 비트가 포함됩니다.

TTL\(Time to Live\): TCP 세그먼트를 보내는 데 사용되는 TTL 값은 구성 가능해야 합니다\(MUST-49\).\(MUST\)

- \* 가정된 최대 세그먼트 수명이 2분이었으므로 RFC 793에서는 TTL의 상수로 1분\(60초\)을 지정했습니다. 이는 인터넷 시스템에서 1분 이내에 세그먼트를 전달할 수 없는 경우 세그먼트를 파기하도록 명시적으로 요청하기 위한 것입니다. RFC 1122는 TTL을 구성할 수 있도록 요구하도록 RFC 793을 업데이트했습니다.

- \* 연결 중에 Diffserv 필드를 변경할 수 있습니다\(RFC 1122의 섹션 4.2.4.2\). 그러나 애플리케이션 인터페이스는 이 기능을 지원하지 않을 수 있으며 애플리케이션은 개별 TCP 세그먼트에 대한 지식이 없으므로 기껏해야 대략적인 세부 수준에서만 수행할 수 있습니다. 이 제한 사항은 RFC 7657\(섹션 5.1, 5.3 및 6\) \[50\]에서 자세히 설명됩니다. 일반적으로 애플리케이션은 연결 과정에서 Diffserv 필드 값을 변경해서는 안 됩니다\(SHLD-23\).\(SHOULD NOT\)

모든 하위 수준 프로토콜은 IP와 기능적으로 동등한 서비스를 제공하고 TCP 체크섬에 사용되기 위해 소스 주소, 대상 주소 및 프로토콜 필드와 "TCP 길이"를 결정하는 방법을 제공해야 합니다.

수신된 옵션이 IP 계층에서 TCP로 전달되면 TCP 구현은 이해하지 못하는 옵션을 무시해야 합니다\(MUST-50\).\(MUST\)

TCP 구현은 타임스탬프\(5월-10\) 및 레코드 경로\(5월-11\) 옵션을 지원할 수 있습니다.\(MAY\)

---
##### **3.9.2.1.  Source Routing**

하위 수준이 IP\(또는 이 기능을 제공하는 다른 프로토콜\)이고 소스 라우팅이 사용되는 경우 인터페이스는 경로 정보 전달을 허용해야 합니다. 이는 TCP 체크섬에 사용된 소스 및 대상 주소가 원래 소스이자 최종 대상이 되기 때문에 특히 중요합니다. 연결 요청에 응답하기 위해 반환 경로를 보존하는 것도 중요합니다.

애플리케이션은 TCP 연결을 적극적으로 열 때 소스 경로를 지정할 수 있어야 하며\(MUST-51\), 이는 데이터그램으로 수신된 소스 경로보다 우선해야 합니다\(MUST-52\).\(MUST\)

TCP 연결이 수동적으로 OPEN되고 패킷이 완전한 IP 소스 경로 옵션\(반환 경로 포함\)과 함께 도착하면 TCP 구현은 반환 경로를 저장하고 이 연결에서 전송된 모든 세그먼트에 대해 이를 사용해야 합니다\(MUST-53\). 다른 소스 경로가 나중 세그먼트에 도착하는 경우 나중 정의가 이전 정의\(SHLD-24\)를 재정의해야 합니다.\(MUST, SHOULD\)

---
##### **3.9.2.2.  ICMP Messages**

TCP 구현은 IP 계층에서 전달된 ICMP 오류 메시지에 따라 이를 오류를 생성한 연결로 전달해야 합니다\(MUST-54\). 필요한 역다중화 정보는 ICMP 메시지에 포함된 IP 헤더에서 찾을 수 있습니다.\(MUST\)

이는 IPv4 ICMP 외에 ICMPv6에도 적용됩니다.

\[35\]에는 다른 응답을 가질 수 있는 "소프트" 또는 "하드" 오류로 분류된 특정 ICMP 및 ICMPv6 메시지에 대한 논의가 포함되어 있습니다. ICMP 메시지 클래스에 대한 처리는 아래에 설명되어 있습니다.

Source Quench TCP 구현은 수신된 모든 ICMP Source Quench 메시지를 자동으로 삭제해야 합니다\(MUST-55\). 논의는 \[11\]을 참조하세요.\(MUST\)

IPv4 ICMP의 경우 소프트 오류에는 다음이 포함됩니다. 대상에 연결할 수 없음 - 코드 0, 1, 5; 시간 초과 - 코드 0, 1; 및 매개변수 문제.

ICMPv6의 경우 여기에는 다음이 포함됩니다. 연결할 수 없는 대상 - 코드 0, 3; 시간 초과 - 코드 0, 1; 및 매개변수 문제 - 코드 0, 1, 2.

이러한 Unreachable 메시지는 소프트 오류 조건을 나타내기 때문에 TCP 구현은 연결을 중단해서는 안 되며\(MUST-56\) 애플리케이션에서 정보를 사용할 수 있도록 해야 합니다\(SHLD-25\).\(MUST NOT\)

ICMP의 경우 하드 오류에는 연결할 수 없는 대상\(코드 2-4\)이 포함됩니다.

이는 심각한 오류 조건이므로 TCP 구현은 연결을 중단해야 합니다\(SHLD-26\). \[35\] 일부 구현에서는 동기화된 상태에 있는 연결에 대해 ICMP 하드 오류가 수신될 때 연결을 중단하지 않습니다.\(SHOULD\)

\[35\], 섹션 4에서는 연결 설정 중 소프트 오류를 ​​하드 오류로 처리하는 광범위한 구현 동작을 설명합니다.

---
##### **3.9.2.3.  Source Address Validation**

RFC 1122에서는 수신 SYN 패킷에서 주소를 검증해야 합니다.

| 유효하지 않은 소스 주소로 들어오는 SYN은 무시되어야 합니다. | TCP 또는 IP 계층\[\(MUST-63\)\]에 의해\(섹션 3.2.1.3 참조\). | | TCP 구현은 들어오는 SYN 세그먼트를 자동으로 삭제해야 합니다. | 브로드캐스트 또는 멀티캐스트 주소로 주소가 지정됩니다\[\(MUST-57\)\].\(MUST, MUST\)

이렇게 하면 연결 상태와 응답이 잘못 생성되는 것을 방지할 수 있으며, 구현자는 RFC 1122에 구체적으로 표시된 대로 이 지침이 SYN뿐만 아니라 모든 수신 세그먼트에 적용된다는 점에 유의해야 합니다.

---
### **3.10.  Event Processing**

이 섹션에 설명된 처리는 가능한 구현 중 하나의 예입니다. 다른 구현은 처리 순서가 약간 다를 수 있지만 이 섹션의 구현과 세부적으로만 다를 뿐 실질적으로 다를 수는 없습니다.

TCP 끝점의 활동은 이벤트에 응답하는 것으로 특징지어질 수 있습니다. 발생하는 이벤트는 사용자 호출, 도착 세그먼트 및 시간 초과의 세 가지 범주로 분류될 수 있습니다. 이 섹션에서는 각 이벤트에 대한 응답으로 TCP 엔드포인트가 수행하는 처리를 설명합니다. 대부분의 경우 필요한 처리는 연결 상태에 따라 다릅니다.

발생하는 이벤트:

```text
      User Calls

         OPEN

         SEND

         RECEIVE

         CLOSE

         ABORT

         STATUS

      Arriving Segments

         SEGMENT ARRIVES

      Timeouts

         USER TIMEOUT

         RETRANSMISSION TIMEOUT

         TIME-WAIT TIMEOUT
```

TCP/사용자 인터페이스 모델은 사용자 명령이 이벤트나 의사 인터럽트를 통해 즉시 반환되고 지연된 응답을 수신한다는 것입니다. 다음 설명에서 "신호"라는 용어는 응답이 지연된다는 의미입니다.

이 문서의 오류 응답은 문자열로 식별됩니다. 예를 들어, 존재하지 않는 연결을 참조하는 사용자 명령은 "오류: 연결이 열리지 않음"을 수신합니다.

다음에서 시퀀스 번호, 승인 번호, 창 등에 대한 모든 산술은 모듈로 2^32\(시퀀스 번호 공간의 크기\)라는 점에 유의하세요. 또한 "=<"는 \(모듈로 2^32\)보다 작거나 같음을 의미합니다.

들어오는 세그먼트를 처리하는 것에 대해 생각하는 자연스러운 방법은 적절한 시퀀스 번호에 대해 먼저 테스트를 거친 다음\(즉, 해당 내용이 시퀀스 번호 공간에서 예상되는 "수신 창" 범위에 있는지\) 생각하는 것입니다. 시퀀스 번호 순서대로 대기하고 처리됩니다.

세그먼트가 이미 수신된 다른 세그먼트와 겹치는 경우 새 데이터만 포함하도록 세그먼트를 재구성하고 헤더 필드가 일관되도록 조정합니다.

상태 변경이 언급되지 않으면 TCP 연결은 동일한 상태로 유지됩니다.

---
#### **3.10.1.  OPEN Call**

```text
   CLOSED STATE (i.e., TCB does not exist)
```

\* 연결 상태 정보를 보관하기 위해 새로운 전송 제어 블록\(TCB\)을 만듭니다. 로컬 소켓 식별자, 원격 소켓, Diffserv 필드, 보안/구획 및 사용자 시간 초과 정보를 입력합니다. 원격 소켓의 일부 부분은 수동 OPEN에서 지정되지 않을 수 있으며 들어오는 SYN 세그먼트의 매개변수로 채워집니다. 요청된 보안 및 Diffserv 값이 이 사용자에게 허용되는지 확인하고, 그렇지 않은 경우 "오류: Diffserv 값이 허용되지 않음" 또는 "오류: 보안/구획이 허용되지 않음"을 반환합니다. 수동인 경우 LISTEN 상태로 들어가고 반환됩니다. 활성 상태이고 원격 소켓이 지정되지 않은 경우 "오류: 원격 소켓이 지정되지 않았습니다"를 반환합니다. 활성화되어 있고 원격 소켓이 지정되어 있으면 SYN 세그먼트를 발행하십시오. 초기 전송 시퀀스 번호\(ISS\)가 선택됩니다. <SEQ=ISS\><CTL=SYN\> 형식의 SYN 세그먼트가 전송됩니다. SND.UNA를 ISS로, SND.NXT를 ISS+1로 설정하고 SYN-SENT 상태로 들어가서 돌아옵니다.

\* 호출자가 지정된 로컬 소켓에 액세스할 수 없는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다. 새 연결을 생성할 공간이 없으면 "오류: 리소스 부족"을 반환합니다.

```text
   LISTEN STATE
```

\* OPEN 호출이 활성이고 원격 소켓이 지정된 경우 연결을 수동에서 활성으로 변경하고 ISS를 선택하십시오. SYN 세그먼트를 보내고 SND.UNA를 ISS로, SND.NXT를 ISS+1로 설정합니다. SYN-SENT 상태로 들어갑니다. SEND와 관련된 데이터는 SYN 세그먼트와 함께 전송되거나 ESTABLISHED 상태로 들어간 후 전송을 위해 대기할 수 있습니다. 명령에서 요청한 경우 긴급 비트는 이 명령의 결과로 전송된 데이터 세그먼트와 함께 전송되어야 합니다. 요청을 대기열에 넣을 공간이 없으면 "오류: 리소스 부족"으로 응답합니다. 원격 소켓이 지정되지 않은 경우 "오류: 원격 소켓이 지정되지 않음"을 반환합니다.

```text
   SYN-SENT STATE

   SYN-RECEIVED STATE

   ESTABLISHED STATE

   FIN-WAIT-1 STATE

   FIN-WAIT-2 STATE

   CLOSE-WAIT STATE

   CLOSING STATE

   LAST-ACK STATE

   TIME-WAIT STATE

   *  Return "error: connection already exists".
```

---
#### **3.10.2.  SEND Call**

```text
   CLOSED STATE (i.e., TCB does not exist)
```

\* 사용자가 해당 연결에 액세스할 수 없는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
   *  Otherwise, return "error: connection does not exist".

   LISTEN STATE
```

\* 원격 소켓이 지정된 경우 연결을 수동에서 활성으로 변경하고 ISS를 선택하십시오. SYN 세그먼트를 보내고 SND.UNA를 ISS로, SND.NXT를 ISS+1로 설정합니다. SYN-SENT 상태로 들어갑니다. SEND와 관련된 데이터는 SYN 세그먼트와 함께 전송되거나 ESTABLISHED 상태로 들어간 후 전송을 위해 대기할 수 있습니다. 명령에서 요청한 경우 긴급 비트는 이 명령의 결과로 전송된 데이터 세그먼트와 함께 전송되어야 합니다. 요청을 대기열에 넣을 공간이 없으면 "오류: 리소스 부족"으로 응답합니다. 원격 소켓이 지정되지 않은 경우 "오류: 원격 소켓이 지정되지 않음"을 반환합니다.

```text
   SYN-SENT STATE

   SYN-RECEIVED STATE
```

\* ESTABLISHED 상태에 진입한 후 전송을 위해 데이터를 대기열에 넣습니다. 대기열에 넣을 공간이 없으면 "오류: 리소스 부족"으로 응답합니다.

```text
   ESTABLISHED STATE

   CLOSE-WAIT STATE
```

\* 버퍼를 분할하여 피기백하여 전송

- 승인\(승인 값 = RCV.NXT\). 이 버퍼를 기억할 공간이 충분하지 않은 경우 간단히 "오류: 리소스 부족"을 반환합니다.

\* URGENT 플래그가 설정된 경우 SND.UP <- SND.NXT이고 나가는 세그먼트에 긴급 포인터를 설정합니다.

```text
   FIN-WAIT-1 STATE

   FIN-WAIT-2 STATE

   CLOSING STATE

   LAST-ACK STATE

   TIME-WAIT STATE
```

\* "오류: 연결 종료"를 반환하고 요청을 서비스하지 않습니다.

---
#### **3.10.3.  RECEIVE Call**

```text
   CLOSED STATE (i.e., TCB does not exist)
```

\* 사용자가 해당 연결에 액세스할 수 없는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
   *  Otherwise, return "error: connection does not exist".

   LISTEN STATE

   SYN-SENT STATE

   SYN-RECEIVED STATE
```

\* ESTABLISHED 상태 진입 후 처리를 위한 큐입니다. 이 요청을 대기열에 넣을 공간이 없으면 "오류: 리소스 부족"으로 응답합니다.

```text
   ESTABLISHED STATE

   FIN-WAIT-1 STATE

   FIN-WAIT-2 STATE
```

\* 요청을 충족하기에 대기열에 들어오는 세그먼트가 충분하지 않은 경우 요청을 대기열에 넣습니다. RECEIVE를 기억할 큐 공간이 없으면 "오류: 리소스 부족"으로 응답합니다.

\* 대기열에 있는 수신 세그먼트를 수신 버퍼로 재조립하고 사용자에게 반환합니다. 이 경우 "푸시 확인"\(PUSH\)으로 표시하세요.

\* 현재 사용자에게 전달되는 데이터보다 RCV.UP이 먼저 전달되는 경우 긴급 데이터가 있음을 사용자에게 알립니다.

\* TCP 끝점이 사용자에게 데이터를 전달하는 책임을 맡는 경우 해당 사실은 승인을 통해 보낸 사람에게 전달되어야 합니다. 이러한 승인의 형성은 아래의 수신 세그먼트 처리에 대한 설명에서 설명됩니다.

```text
   CLOSE-WAIT STATE
```

\* 원격측에서 이미 FIN을 보냈기 때문에 RECEIVE는 이미 보유하고 있지만 아직 사용자에게 전달되지 않은 데이터로 충족되어야 합니다. 배달 대기 중인 텍스트가 없으면 RECEIVE는 "error: 연결 종료" 응답을 받게 됩니다. 그렇지 않으면 남은 데이터를 RECEIVE를 충족하는 데 사용할 수 있습니다.

```text
   CLOSING STATE

   LAST-ACK STATE

   TIME-WAIT STATE

   *  Return "error: connection closing".
```

---
#### **3.10.4.  CLOSE Call**

```text
   CLOSED STATE (i.e., TCB does not exist)
```

\* 사용자가 해당 연결에 액세스할 수 없는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
   *  Otherwise, return "error: connection does not exist".

   LISTEN STATE
```

\* 미해결 RECEIVE는 "오류: 종료" 응답과 함께 반환됩니다. TCB를 삭제하고 CLOSED 상태로 들어간 후 돌아갑니다.

```text
   SYN-SENT STATE
```

\* TCB를 삭제하고 대기 중인 SEND 또는 RECEIVE에 "error:closing" 응답을 반환합니다.

```text
   SYN-RECEIVED STATE
```

\* SEND가 발행되지 않았고 전송 대기 중인 데이터가 없으면 FIN 세그먼트를 구성하여 전송하고 FIN-WAIT-1 상태로 진입합니다. 그렇지 않으면 ESTABLISHED 상태로 들어간 후 처리를 위한 큐입니다.

```text
   ESTABLISHED STATE
```

\* 이전의 모든 SEND가 분할될 때까지 이를 대기열에 넣은 다음 FIN 세그먼트를 구성하여 보냅니다. 어쨌든 FIN-WAIT-1 상태로 들어갑니다.

```text
   FIN-WAIT-1 STATE

   FIN-WAIT-2 STATE
```

\* 엄밀히 말하면 이는 오류이므로 "error:connectionclosing" 응답을 받아야 합니다. 두 번째 FIN이 전송되지 않는 한 "ok" 응답도 허용됩니다\(단, 첫 번째 FIN은 재전송될 수 있음\).

```text
   CLOSE-WAIT STATE
```

\* 이전의 모든 SEND가 완료될 때까지 이 요청을 대기열에 넣습니다.

- 세분화된; 그런 다음 FIN 세그먼트를 보내고 LAST-ACK 상태로 들어갑니다.

```text
   CLOSING STATE

   LAST-ACK STATE

   TIME-WAIT STATE
```

\* "오류: 연결 종료"로 응답합니다.

---
#### **3.10.5.  ABORT Call**

```text
   CLOSED STATE (i.e., TCB does not exist)
```

\* 사용자가 그러한 연결에 액세스할 수 없어야 하는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
   *  Otherwise, return "error: connection does not exist".

   LISTEN STATE
```

\* 미해결 RECEIVE는 "오류:

- 연결 재설정" 응답. TCB를 삭제하고 CLOSED 상태로 들어간 후 돌아갑니다.

```text
   SYN-SENT STATE
```

\* 대기 중인 모든 SEND 및 RECEIVE에는 "연결 재설정" 알림이 제공되어야 합니다. TCB를 삭제하고 CLOSED 상태로 들어간 후 돌아갑니다.

```text
   SYN-RECEIVED STATE

   ESTABLISHED STATE

   FIN-WAIT-1 STATE

   FIN-WAIT-2 STATE

   CLOSE-WAIT STATE
```

\* 재설정 세그먼트 보내기:

```text
      <SEQ=SND.NXT><CTL=RST>
```

\* 대기 중인 모든 SEND 및 RECEIVE에는 "연결 재설정" 알림이 제공되어야 합니다. 전송\(위에 형성된 RST 제외\) 또는 재전송을 위해 대기 중인 모든 세그먼트를 플러시해야 합니다. TCB를 삭제하고 CLOSED 상태로 들어간 후 돌아갑니다.

```text
   CLOSING STATE

   LAST-ACK STATE

   TIME-WAIT STATE
```

\* "ok"로 응답하고 TCB를 삭제한 후 CLOSED 상태로 진입하고 복귀합니다.

---
#### **3.10.6.  STATUS Call**

```text
   CLOSED STATE (i.e., TCB does not exist)
```

\* 사용자가 그러한 연결에 액세스할 수 없어야 하는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
   *  Otherwise, return "error: connection does not exist".

   LISTEN STATE
```

\* "state = LISTEN" 및 TCB 포인터를 반환합니다.

```text
   SYN-SENT STATE
```

\* "state = SYN-SENT" 및 TCB 포인터를 반환합니다.

```text
   SYN-RECEIVED STATE
```

\* "state = SYN-RECEIVED" 및 TCB 포인터를 반환합니다.

```text
   ESTABLISHED STATE
```

\* "state = ESTABLISHED" 및 TCB 포인터를 반환합니다.

```text
   FIN-WAIT-1 STATE
```

\* "state = FIN-WAIT-1"과 TCB 포인터를 반환합니다.

```text
   FIN-WAIT-2 STATE
```

\* "state = FIN-WAIT-2"와 TCB 포인터를 반환합니다.

```text
   CLOSE-WAIT STATE
```

\* "state = CLOSE-WAIT" 및 TCB 포인터를 반환합니다.

```text
   CLOSING STATE
```

\* "state = CLOSING"과 TCB 포인터를 반환합니다.

```text
   LAST-ACK STATE
```

\* "state = LAST-ACK" 및 TCB 포인터를 반환합니다.

```text
   TIME-WAIT STATE
```

\* "state = TIME-WAIT" 및 TCB 포인터를 반환합니다.

---
#### **3.10.7.  SEGMENT ARRIVES**
---
##### **3.10.7.1.  CLOSED STATE**

상태가 CLOSED인 경우\(즉, TCB가 존재하지 않는 경우\)

- 수신 세그먼트의 모든 데이터가 삭제됩니다. RST가 포함된 수신 세그먼트는 삭제됩니다. RST가 포함되지 않은 수신 세그먼트로 인해 RST가 응답으로 전송됩니다. 문제가 있는 세그먼트를 보낸 TCP 엔드포인트가 재설정 시퀀스를 허용할 수 있도록 승인 및 시퀀스 필드 값이 선택됩니다.

- ACK 비트가 OFF이면 시퀀스 번호 0이 사용되며,

```text
         <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
```

- ACK 비트가 ON이면

```text
         <SEQ=SEG.ACK><CTL=RST>

      Return.
```

---
##### **3.10.7.2.  LISTEN STATE**

상태가 LISTEN이면

- 먼저 RST를 확인하세요.

- - 들어오는 RST 세그먼트는 이 연결 화신에 의해 전송된 어떤 것에 대한 응답으로 전송될 수 없기 때문에 유효할 수 없습니다. 들어오는 RST는 무시되어야 합니다. 반품.

- 둘째, ACK를 확인합니다.

- - 여전히 LISTEN 상태인 ​​연결에 도착하면 모든 승인이 잘못된 것입니다. 도착하는 ACK 베어링 세그먼트에 대해 허용 가능한 재설정 세그먼트가 형성되어야 합니다. RST는 다음과 같은 형식이어야 합니다.

```text
            <SEQ=SEG.ACK><CTL=RST>

      -  Return.
```

- 셋째, SYN을 확인합니다.

- - SYN 비트가 설정된 경우 보안을 확인하십시오. 수신 세그먼트의 보안/구획이 TCB의 보안/구획과 정확하게 일치하지 않는 경우 재설정을 보내고 반환합니다.

```text
            <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
```

- - RCV.NXT를 SEG.SEQ+1로 설정하고 IRS를 SEG.SEQ로 설정하며 다른 컨트롤이나 텍스트는 나중에 처리하기 위해 대기열에 있어야 합니다. ISS를 선택하고 다음 형식의 SYN 세그먼트를 전송해야 합니다.

```text
            <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>
```

- - SND.NXT는 ISS+1로 설정되고 SND.UNA는 ISS로 설정됩니다. 연결 상태를 SYN-RECEIVED로 변경해야 합니다. 다른 모든 수신 제어 또는 데이터\(SYN과 결합\)는 SYN-RECEIVED 상태에서 처리되지만 SYN 및 ACK 처리는 반복되어서는 안 됩니다. 청취가 완전히 지정되지 않은 경우\(즉, 원격 소켓이 완전히 지정되지 않은 경우\) 지정되지 않은 필드를 지금 채워야 합니다.

- 넷째, 기타 데이터 또는 제어:

- - 이 곳에 도달하면 안 됩니다. 세그먼트를 삭제하고 돌아옵니다. 다른 모든 제어 또는 데이터 포함 세그먼트\(SYN을 포함하지 않음\)에는 ACK가 있어야 하므로 첫 번째 단계에서 RST 검사를 통해 먼저 삭제되지 않는 한 두 번째 단계의 ACK 처리에서 삭제되었을 것입니다.

---
##### **3.10.7.3.  SYN-SENT STATE**

상태가 SYN-SENT인 경우

- 먼저 ACK 비트를 확인합니다.

- - ACK 비트가 설정된 경우

```text
         o  If SEG.ACK =< ISS or SEG.ACK > SND.NXT, send a reset (unless
            the RST bit is set, if so drop the segment and return)

               <SEQ=SEG.ACK><CTL=RST>
```

-o 그리고 세그먼트를 폐기합니다. 반품.

- o SND.UNA < SEG.ACK =< SND.NXT인 경우 ACK가 허용됩니다. 배포된 일부 TCP 코드에서는 SEG.ACK == SND.NXT 검사\("=<" 대신 "==" 사용\)를 사용했지만 TCP 피어가 SYN에서 데이터를 보낼 수 있기 때문에 스택이 SYN에 데이터를 보낼 수 있는 경우에는 이 방법이 적합하지 않습니다. SYN의 모든 데이터를 수락하고 인정하지 않을 수도 있습니다.

- 둘째, RST 비트를 확인하십시오.

- - RST 비트가 설정된 경우,

- o 잠재적인 블라인드 재설정 공격은 RFC 5961 \[9\]에 설명되어 있습니다. 해당 문서에 설명된 완화에는 특정 적용 가능성이 설명되어 있으며 암호화 보호\(예: IPsec 또는 TCP-AO\)를 대체하지 않습니다. RFC 5961에 설명된 완화를 지원하는 TCP 구현은 다음 단락의 작업을 실행하기 전에 먼저 시퀀스 번호가 RCV.NXT와 정확히 일치하는지 확인해야 합니다.\(SHOULD\)

- o ACK가 허용되면 사용자에게 "오류: 연결 재설정" 신호를 보내고 세그먼트를 삭제하고 CLOSED 상태로 들어간 다음 TCB를 삭제하고 반환합니다. 그렇지 않으면\(ACK 없음\) 세그먼트를 삭제하고 반환합니다.

- 셋째, 보안을 확인하세요.

- - 세그먼트의 보안/구획이 TCB의 보안/구획과 정확히 일치하지 않는 경우 재설정을 보냅니다.

- o ACK가 있는 경우

```text
               <SEQ=SEG.ACK><CTL=RST>

         o  Otherwise,

               <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
```

- - 재설정이 전송된 경우 세그먼트를 버리고 반환합니다.

- 넷째, SYN 비트를 확인하세요.

- - 이 단계는 ACK가 정상이거나 ACK가 없고 세그먼트에 RST가 포함되지 않은 경우에만 도달해야 합니다.

- SYN 비트가 켜져 있고 보안/구획이 켜져 있는 경우

- 수용 가능한 경우 RCV.NXT는 SEG.SEQ+1로 설정되고 IRS는 SEG.SEQ로 설정됩니다. SND.UNA는 SEG.ACK\(ACK가 있는 경우\)와 동일하도록 진행되어야 하며 이로 인해 확인된 재전송 큐의 모든 세그먼트는 제거되어야 합니다.

- SND.UNA \> ISS\(SYN이 ACK됨\)인 경우

- ESTABLISHED에 대한 연결 상태, ACK 세그먼트 형성

```text
            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

- 그리고 보내세요. 대기 중인 데이터 또는 컨트롤

- 전송이 포함될 수 있습니다. 일부 TCP 구현에서는 수신된 세그먼트에 이후 처리 단계에서 승인을 생성하는 데이터가 포함된 경우 이 세그먼트 전송을 억제하여 SYN에 대한 추가 승인이 전송되는 것을 방지합니다. 세그먼트에 다른 컨트롤이나 텍스트가 있는 경우 URG 비트가 확인되는 섹션 3.10.7.4 아래의 여섯 번째 단계에서 처리를 계속합니다. 그렇지 않으면 반환하세요.\(MAY\)

- - 그렇지 않으면 SYN-RECEIVED를 입력하고 SYN,ACK 세그먼트를 형성합니다.

```text
            <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>
```

- - 그리고 보내세요. 변수를 설정합니다.

```text
            SND.WND <- SEG.WND

            SND.WL1 <- SEG.SEQ

            SND.WL2 <- SEG.ACK
```

- 세그먼트에 다른 컨트롤이나 텍스트가 있는 경우 ESTABLISHED 상태에 도달한 후 처리를 위해 대기열에 넣고 반환합니다.

- - SYN 세그먼트\(위에서 언급한 "세그먼트의 텍스트"\)에서 애플리케이션 데이터를 보내고 받는 것이 합법적이라는 점에 유의하세요. 역사적으로 이 주제에 대해 심각한 잘못된 정보와 오해가 있어 왔습니다. 일부 방화벽과 보안 장치는 이를 의심스러운 것으로 간주합니다. 그러나 이 기능은 T/TCP\[21\]에서 사용되었고 TCP Fast Open\(TFO\)\[48\]에서 사용되므로 구현 및 네트워크 장치에서 허용하는 것이 중요합니다.

- 다섯째, SYN 또는 RST 비트가 모두 설정되지 않은 경우 세그먼트를 삭제하고 반환합니다.

---
##### **3.10.7.4.  Other States**

```text
   Otherwise,

      First, check sequence number:

      -  SYN-RECEIVED STATE

      -  ESTABLISHED STATE

      -  FIN-WAIT-1 STATE

      -  FIN-WAIT-2 STATE

      -  CLOSE-WAIT STATE

      -  CLOSING STATE

      -  LAST-ACK STATE

      -  TIME-WAIT STATE
```

- o 세그먼트는 순서대로 처리됩니다. 도착 시 초기 테스트는 오래된 중복 항목을 삭제하는 데 사용되지만 추가 처리는 SEG.SEQ 순서로 수행됩니다. 세그먼트의 내용이 이전 부분과 새 부분 사이의 경계에 걸쳐 있는 경우 새 부분만 처리됩니다.

- o 일반적으로 수신된 세그먼트의 처리는 가능할 때마다 ACK 세그먼트를 집계하도록 구현되어야 합니다\(MUST-58\). 예를 들어, TCP 엔드포인트가 대기열에 있는 일련의 세그먼트를 처리하는 경우 ACK 세그먼트를 보내기 전에 해당 세그먼트를 모두 처리해야 합니다\(MUST-59\).\(MUST, MUST\)

- o 수신 세그먼트에 대한 수용성 테스트에는 네 가지 경우가 있습니다.

```text
            +=========+=========+======================================+
            | Segment | Receive | Test                                 |
            | Length  | Window  |                                      |
            +=========+=========+======================================+
            | 0       | 0       | SEG.SEQ = RCV.NXT                    |
            +---------+---------+--------------------------------------+
            | 0       | >0      | RCV.NXT =< SEG.SEQ <                 |
            |         |         | RCV.NXT+RCV.WND                      |
            +---------+---------+--------------------------------------+
            | >0      | 0       | not acceptable                       |
            +---------+---------+--------------------------------------+
            | >0      | >0      | RCV.NXT =< SEG.SEQ <                 |
            |         |         | RCV.NXT+RCV.WND                      |
            |         |         |                                      |
            |         |         | or                                   |
            |         |         |                                      |
            |         |         | RCV.NXT =< SEG.SEQ+SEG.LEN-1         |
            |         |         | < RCV.NXT+RCV.WND                    |
            +---------+---------+--------------------------------------+

                        Table 6: Segment Acceptability Tests
```

- o 여기에 설명된 대로 시퀀스 번호 확인을 구현할 때 부록 A.2를 참고하세요.

- o RCV.WND가 0이면 어떤 세그먼트도 허용되지 않지만 유효한 ACK, URG 및 RST를 허용하려면 특별한 허용이 이루어져야 합니다.

- o 들어오는 세그먼트가 허용되지 않으면 응답으로 승인을 보내야 합니다\(RST 비트가 설정되지 않은 경우 세그먼트를 삭제하고 반환\).

```text
            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

- o 승인을 보낸 후 허용되지 않는 세그먼트를 삭제하고 반환합니다.

- o TIME-WAIT 상태의 경우 여기에 설명된 시퀀스 번호 확인에 의존하기보다는 타임스탬프를 활용하는 들어오는 SYN 세그먼트를 처리하기 위해 \[40\]에 설명된 향상된 알고리즘이 있습니다. 개선된 알고리즘이 구현되면 위의 논리는 TIME-WAIT 상태의 연결에서 수신되는 타임스탬프 옵션이 있는 수신 SYN 세그먼트에 적용되지 않습니다.

- o 다음에서는 세그먼트가 RCV.NXT에서 시작하고 창을 초과하지 않는 이상적인 세그먼트라고 가정합니다. 창 외부에 있는 부분\(SYN 및 FIN 포함\)을 잘라내고 세그먼트가 RCV.NXT에서 시작하는 경우에만 추가 처리를 수행하여 이 가정에 맞게 실제 세그먼트를 조정할 수 있습니다. 더 높은 시작 시퀀스 번호를 가진 세그먼트는 이후 처리를 위해 보관되어야 합니다\(SHLD-31\).\(SHOULD\)

- 둘째, RST 비트를 확인하십시오.

- - RFC 5961 \[9\], 섹션 3에서는 잠재적인 블라인드 재설정 공격과 선택적 완화 접근 방식을 설명합니다. 이는 암호화 보호\(예: IPsec 또는 TCP-AO\)를 제공하지 않지만 RFC 5961에 설명된 상황에 적용할 수 있습니다. RFC 5961에 설명된 보호를 구현하는 스택의 경우 아래 세 가지 확인 사항이 적용됩니다. 그렇지 않으면 이러한 상태에 대한 처리가 아래에 추가로 표시됩니다.

- 1\) RST 비트가 설정되고 시퀀스 번호가 현재 수신 창 외부에 있으면 세그먼트를 자동으로 삭제합니다.

- 2\) RST 비트가 설정되고 시퀀스 번호가 다음 예상 시퀀스 번호\(RCV.NXT\)와 정확히 일치하는 경우 TCP 끝점은 연결 상태에 따라 아래에 규정된 방식으로 연결을 재설정해야 합니다.\(MUST\)

- 3\) RST 비트가 설정되고 시퀀스 번호가 다음 예상 시퀀스 값과 정확히 일치하지 않지만 현재 수신 창 내에 있는 경우 TCP 끝점은 승인\(챌린지 ACK\)을 보내야 합니다.\(MUST\)

```text
             <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

- Challenge ACK를 보낸 후 TCP 끝점은 허용할 수 없는 세그먼트를 삭제하고 들어오는 패킷 처리를 더 이상 중지해야 합니다. RFC 5961 및 Errata ID 4772 \[99\]에는 구현 시 ACK 제한에 대한 추가 고려 사항이 포함되어 있습니다.\(MUST\)

```text
      -  SYN-RECEIVED STATE
```

- o RST 비트가 설정된 경우,

- + 이 연결이 수동적 OPEN으로 시작된 경우\(즉, LISTEN 상태에서 온 경우\) 이 연결을 LISTEN 상태로 되돌리고 반환합니다. 사용자에게 알릴 필요는 없습니다. 이 연결이 활성 OPEN으로 시작된 경우\(즉, SYN-SENT 상태에서 온 경우\) 연결이 거부되었습니다. 사용자에게 "연결이 거부되었습니다"라는 신호를 보냅니다. 두 경우 모두 재전송 큐를 플러시해야 합니다. 그리고 active OPEN 케이스에서는 CLOSED 상태로 진입하여 TCB를 삭제하고 복귀한다.

```text
      -  ESTABLISHED STATE

      -  FIN-WAIT-1 STATE

      -  FIN-WAIT-2 STATE

      -  CLOSE-WAIT STATE
```

- o RST 비트가 설정된 경우 미해결 RECEIVE 및 SEND는 "재설정" 응답을 받아야 합니다. 모든 세그먼트 대기열을 플러시해야 합니다. 사용자는 원치 않는 일반 "연결 재설정" 신호도 수신해야 합니다. CLOSED 상태로 들어가 TCB를 삭제하고 반환합니다.

```text
      -  CLOSING STATE

      -  LAST-ACK STATE

      -  TIME-WAIT STATE
```

- o RST 비트가 설정되면 CLOSED 상태로 들어가 TCB를 삭제하고 반환합니다.

```text
      Third, check security:

      -  SYN-RECEIVED STATE
```

- o 세그먼트의 보안/구획이 TCB의 보안/구획과 정확히 일치하지 않는 경우 재설정을 보내고 반환합니다.

```text
      -  ESTABLISHED STATE

      -  FIN-WAIT-1 STATE

      -  FIN-WAIT-2 STATE

      -  CLOSE-WAIT STATE

      -  CLOSING STATE

      -  LAST-ACK STATE

      -  TIME-WAIT STATE
```

- o 세그먼트의 보안/구획이 TCB의 보안/구획과 정확히 일치하지 않는 경우 재설정을 보냅니다. 처리되지 않은 RECEIVE 및 SEND는 "재설정" 응답을 받아야 합니다. 모든 세그먼트 대기열을 플러시해야 합니다. 사용자는 원치 않는 일반 "연결 재설정" 신호도 수신해야 합니다. CLOSED 상태로 들어가 TCB를 삭제하고 반환합니다.

- - 이 검사는 보안이 다른 포트 번호 사이의 이전 연결에서 세그먼트가 현재 연결을 중단하는 것을 방지하기 위해 시퀀스 검사 후에 수행됩니다.

- 넷째, SYN 비트를 확인하세요.

```text
      -  SYN-RECEIVED STATE
```

- o 연결이 수동 OPEN으로 시작된 경우 이 연결을 LISTEN 상태로 되돌리고 반환합니다. 그렇지 않은 경우 아래 동기화 상태에 대한 지침에 따라 처리하세요.

```text
      -  ESTABLISHED STATE

      -  FIN-WAIT-1 STATE

      -  FIN-WAIT-2 STATE

      -  CLOSE-WAIT STATE

      -  CLOSING STATE

      -  LAST-ACK STATE

      -  TIME-WAIT STATE
```

- o 이러한 동기화된 상태에서 SYN 비트가 설정된 경우 이는 합법적인 새 연결 시도\(예: TIME-WAIT의 경우\)이거나 연결을 재설정해야 하는 오류이거나 공격 시도의 결과일 수 있습니다. , RFC 5961 \[9\]에 설명된 대로입니다. TIME-WAIT 상태의 경우 타임스탬프 옵션이 사용되고 기대치를 충족하면 새 연결이 허용될 수 있습니다\(\[40\]에 따라\). 다른 모든 경우에 대해 RFC 5961은 일부 상황에 적용 가능한 완화를 제공하지만 암호화 보호를 제공하는 대안도 있습니다\(섹션 7 참조\). RFC 5961에서는 이러한 동기화 상태에서 SYN 비트가 설정된 경우 시퀀스 번호에 관계없이 TCP 끝점이 원격 피어에 "챌린지 ACK"를 보내야 한다고 권장합니다.\(MUST\)

```text
            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

- o 승인을 보낸 후 TCP 구현은 허용할 수 없는 세그먼트를 삭제하고 추가 처리를 중지해야 합니다. RFC 5961 및 Errata ID 4772 \[99\]에는 구현에 대한 추가 ACK 제한 참고 사항이 포함되어 있습니다.\(MUST\)

- o RFC 5961을 따르지 않는 구현의 경우 RFC 793에 설명된 원래 동작이 이 단락에 따릅니다. SYN이 창에 있으면 오류입니다. 재설정을 보내고, 미해결 RECEIVE 및 SEND는 "재설정" 응답을 받아야 하며, 모든 세그먼트 큐는 플러시되어야 하며, 사용자는 원치 않는 일반 "연결 재설정" 신호도 받아야 하며, 다음을 입력해야 합니다. CLOSED 상태, TCB를 삭제하고 반환합니다.

- o SYN이 창에 없으면 이 단계에 도달하지 못하고 첫 번째 단계\(순서 번호 확인\)에서 ACK가 전송됩니다.

- 다섯째, ACK 필드를 확인합니다.

- - ACK 비트가 꺼져 있으면 세그먼트를 삭제하고 반환합니다.

- - ACK 비트가 켜져 있으면

- o RFC 5961 \[9\], 섹션 5에서는 잠재적인 블라인드 데이터 주입 공격과 구현에 포함하도록 선택할 수 있는 완화에 대해 설명합니다\(5월 12일\). RFC 5961을 구현하는 TCP 스택은 ACK 값이 \(\(SND.UNA - MAX.SND.WND\) =< SEG.ACK =< SND.NXT\) 범위에 있는 경우에만 허용되는지 확인하는 입력 검사를 추가해야 합니다. ACK 값이 위 조건을 만족하지 않는 모든 수신 세그먼트는 반드시 폐기되고 ACK가 다시 전송되어야 합니다. 새로운 상태 변수 MAX.SND.WND는 로컬 발신자가 피어로부터 받은 가장 큰 창으로 정의되거나\(창 크기 조정에 따라\) 최대 허용 창 값으로 하드 코딩될 수 있습니다. ACK 값이 허용되면 아래의 상태별 처리가 적용됩니다.\(MAY, MUST, MUST\)

```text
         o  SYN-RECEIVED STATE
```

- + SND.UNA < SEG.ACK =< SND.NXT인 경우 ESTABLISHED 상태로 들어가고 아래 변수를 다음으로 설정하여 처리를 계속합니다.

```text
                  SND.WND <- SEG.WND

                  SND.WL1 <- SEG.SEQ

                  SND.WL2 <- SEG.ACK
```

- + 세그먼트 승인이 허용되지 않으면 재설정 세그먼트를 형성합니다.

```text
                  <SEQ=SEG.ACK><CTL=RST>
```

- + 하고 보내세요.

```text
         o  ESTABLISHED STATE
```

- + SND.UNA < SEG.ACK =< SND.NXT인 경우 SND.UNA <- SEG.ACK를 설정합니다. 완전히 승인된 재전송 큐의 모든 세그먼트는 제거됩니다. 사용자는 SENT되고 완전히 확인된 버퍼에 대해 긍정적인 확인을 받아야 합니다\(즉, SEND 버퍼는 "ok" 응답과 함께 반환되어야 함\). ACK가 중복된 경우\(SEG.ACK =< SND.UNA\) 무시할 수 있습니다. ACK가 아직 전송되지 않은 내용을 확인하는 경우\(SEG.ACK \> SND.NXT\) ACK를 보내고 세그먼트를 삭제한 후 반환합니다.

- + SND.UNA =< SEG.ACK =< SND.NXT인 경우 전송 창을 업데이트해야 합니다. \(SND.WL1 < SEG.SEQ 또는 \(SND.WL1 = SEG.SEQ 및 SND.WL2 =< SEG.ACK\)\)인 경우 SND.WND <- SEG.WND를 설정하고 SND.WL1 <- SEG.SEQ를 설정하고, SND.WL2 <- SEG.ACK를 설정합니다.

- + SND.WND는 SND.UNA의 오프셋이며, SND.WL1은 SND.WND를 업데이트하는 데 사용된 마지막 세그먼트의 시퀀스 번호를 기록하고, SND.WL2는 업데이트에 사용된 마지막 세그먼트의 승인 번호를 기록합니다. SND.WND. 여기서 확인하면 이전 세그먼트를 사용하여 창을 업데이트하는 것을 방지할 수 있습니다.

```text
         o  FIN-WAIT-1 STATE
```

- + ESTABLISHED 상태에 대한 처리 외에 FIN 세그먼트가 이제 승인되면 FIN-WAIT-2를 입력하고 해당 상태에서 처리를 계속합니다.

```text
         o  FIN-WAIT-2 STATE
```

- + ESTABLISHED 상태에 대한 처리 외에도 재전송 큐가 비어 있으면 사용자의 CLOSE를 승인\("ok"\)할 수 있지만 TCB를 삭제하지 마십시오.

```text
         o  CLOSE-WAIT STATE
```

- + ESTABLISHED 상태와 동일한 처리를 수행합니다.

```text
         o  CLOSING STATE
```

- + ESTABLISHED 상태에 대한 처리 외에도 ACK가 FIN을 확인하면 TIME-WAIT 상태로 들어갑니다. 그렇지 않으면 세그먼트를 무시합니다.

```text
         o  LAST-ACK STATE
```

- + 이 상태에 도달할 수 있는 유일한 것은 FIN을 승인하는 것뿐입니다. 이제 FIN이 승인되면 TCB를 삭제하고 CLOSED 상태로 들어간 후 돌아갑니다.

```text
         o  TIME-WAIT STATE
```

- + 이 상태에 도달할 수 있는 유일한 것은 원격 FIN의 재전송입니다. 이를 확인하고 2 MSL 시간 초과를 다시 시작합니다.

- 여섯째, URG 비트를 확인하세요.

```text
      -  ESTABLISHED STATE

      -  FIN-WAIT-1 STATE

      -  FIN-WAIT-2 STATE
```

- o URG 비트가 설정된 경우 RCV.UP <- max\(RCV.UP,SEG.UP\)이고, 긴급 포인터\(RCV.UP\)가 비트보다 앞에 있으면 원격 측에 긴급 데이터가 있음을 사용자에게 알립니다. 소비된 데이터. 사용자가 긴급 데이터의 연속 시퀀스에 대해 이미 신호를 받은 경우\(또는 여전히 "긴급 모드"에 있는 경우\) 사용자에게 다시 신호를 보내지 마세요.

```text
      -  CLOSE-WAIT STATE

      -  CLOSING STATE

      -  LAST-ACK STATE

      -  TIME-WAIT STATE
```

- o 원격 측에서 FIN을 수신했으므로 이러한 현상이 발생해서는 안 됩니다. URG를 무시하세요.

- 일곱째, 세그먼트 텍스트를 처리합니다.

```text
      -  ESTABLISHED STATE

      -  FIN-WAIT-1 STATE

      -  FIN-WAIT-2 STATE
```

- o ESTABLISHED 상태가 되면 세그먼트 데이터를 사용자 RECEIVE 버퍼로 전달할 수 있습니다. 버퍼가 가득 차거나 세그먼트가 비어 있을 때까지 세그먼트의 데이터를 버퍼로 이동할 수 있습니다. 세그먼트가 비어 있고 PUSH 플래그를 전달하는 경우 버퍼가 반환될 때 PUSH가 수신되었음을 사용자에게 알립니다.

- o TCP 엔드포인트가 사용자에게 데이터를 전달하는 책임을 맡을 때 데이터 수신을 승인해야 합니다.

- o TCP 엔드포인트가 데이터에 대한 책임을 지게 되면 수용된 데이터에 대해 RCV.NXT를 진행하고 현재 버퍼 가용성에 맞게 RCV.WND를 조정합니다. RCV.NXT와 RCV.WND의 합계를 줄여서는 안 됩니다.

- o TCP 구현은 창에 있지만 왼쪽 창 가장자리에 있지 않은 유효한 세그먼트가 도착할 때 RCV.NXT를 승인하는 ACK 세그먼트를 보낼 수 있습니다\(MAY-13\).\(MAY\)

o 창 관리 제안 사항을 참고하세요.

- 섹션 3.8.

- o 양식에 대한 확인서를 보내십시오.

```text
            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

- o 이 승인은 가능하면 과도한 지연을 초래하지 않고 전송되는 세그먼트에 피기백되어야 합니다.

```text
      -  CLOSE-WAIT STATE

      -  CLOSING STATE

      -  LAST-ACK STATE

      -  TIME-WAIT STATE
```

- o 원격 측에서 FIN을 수신했으므로 이러한 현상이 발생해서는 안 됩니다. 세그먼트 텍스트를 무시합니다.

- 여덟째, FIN 비트를 확인하세요.

- - SEG.SEQ를 검증할 수 없으므로 상태가 CLOSED, LISTEN 또는 SYNSENT인 경우 FIN을 처리하지 마십시오. 세그먼트를 삭제하고 돌아옵니다.

- - FIN 비트가 설정된 경우 사용자에게 "연결 종료" 신호를 보내고 동일한 메시지와 함께 보류 중인 RECEIVE를 반환하고 FIN을 통해 RCV.NXT를 진행한 다음 FIN에 대한 승인을 보냅니다. FIN은 아직 사용자에게 전달되지 않은 세그먼트 텍스트에 대해 PUSH를 의미합니다.

```text
         o  SYN-RECEIVED STATE

         o  ESTABLISHED STATE
```

- + CLOSE-WAIT 상태로 들어갑니다.

```text
         o  FIN-WAIT-1 STATE
```

- + FIN이 ACK되면\(아마도 이 세그먼트에서\) TIME-WAIT를 입력하고 시간 대기 타이머를 시작한 다음 다른 타이머를 끄십시오. 그렇지 않으면 CLOSING 상태로 들어갑니다.

```text
         o  FIN-WAIT-2 STATE
```

- + TIME-WAIT 상태로 들어갑니다. 시간 대기 타이머를 시작하고 다른 타이머를 끄십시오.

```text
         o  CLOSE-WAIT STATE
```

- + CLOSE-WAIT 상태를 유지한다.

```text
         o  CLOSING STATE
```

- + CLOSING 상태를 유지한다.

```text
         o  LAST-ACK STATE
```

- + LAST-ACK 상태를 유지합니다.

```text
         o  TIME-WAIT STATE
```

- + TIME-WAIT 상태를 유지한다. 2 MSL 시간 대기 시간 초과를 다시 시작합니다.

- 그리고 돌아오세요.

---
#### **3.10.8.  Timeouts**

```text
   USER TIMEOUT
```

\* 어떤 상태에서든 사용자 시간 초과가 만료되면 모든 대기열을 비우고 일반적으로 사용자에게 "오류: 사용자 시간 초과로 인해 연결이 중단되었습니다"라는 신호를 보내고 미해결 호출의 경우 TCB를 삭제하고 CLOSED 상태로 들어간 다음 반환합니다.

```text
   RETRANSMISSION TIMEOUT
```

\* 어떤 상태에서든 재전송 대기열의 세그먼트에서 재전송 시간 초과가 만료되면 재전송 대기열의 앞쪽에 있는 세그먼트를 다시 보내고 재전송 타이머를 다시 초기화한 후 반환합니다.

```text
   TIME-WAIT TIMEOUT
```

\* 커넥션에서 time-wait timeout이 만료되면 TCB를 삭제하고 CLOSED 상태로 진입한 후 복귀한다.

---
## **4.  Glossary**

ACK

- 시퀀스 공간을 차지하지 않는 제어 비트\(승인\). 이는 이 세그먼트의 승인 필드가 이 세그먼트의 송신자가 수신할 것으로 예상하는 다음 시퀀스 번호를 지정하므로 모든 이전 시퀀스 번호의 수신을 승인함을 나타냅니다.

연결

- 한 쌍의 소켓으로 식별되는 논리적 통신 경로입니다.

데이터그램

- 패킷 교환 컴퓨터 통신 네트워크에서 전송되는 메시지입니다.

목적지 주소

- 세그먼트를 수신하려는 엔드포인트의 네트워크 계층 주소입니다.

지느러미

- 하나의 시퀀스 번호를 차지하는 제어 비트\(finis\)는 송신자가 더 이상 데이터를 보내지 않거나 시퀀스 공간을 점유하는 제어를 보내지 않음을 나타냅니다.

플러시

- 저장소\(버퍼 또는 대기열\)에서 모든 콘텐츠\(데이터 또는 세그먼트\)를 제거합니다.

파편

- 데이터의 논리적 단위의 일부입니다. 특히 인터넷 조각은 인터넷 데이터그램의 일부입니다.

머리글

- 메시지, 세그먼트, 조각, 패킷 또는 데이터 블록의 시작 부분에 있는 제어 정보입니다.

주인

-       컴퓨터. 특히, 통신 네트워크의 관점에서 본 메시지의 소스 또는 대상입니다.

신분증

- 인터넷 프로토콜 필드. 송신자가 할당한 이 식별 값은 데이터그램의 조각을 모으는 데 도움이 됩니다.

인터넷 주소

- 네트워크 계층 주소.

인터넷 데이터그램

- 데이터그램이 소스에서 대상으로 라우팅될 수 있도록 하는 인터넷 헤더와 함께 인터넷 호스트 간에 교환되는 데이터 단위입니다.

인터넷 조각

- 인터넷 헤더가 있는 인터넷 데이터그램의 데이터 일부.

IP

- 인터넷 프로토콜. \[1\]과 \[13\]을 참조하세요.

국세청

- 초기 수신 시퀀스 번호입니다. 연결 시 보낸 사람이 사용하는 첫 번째 시퀀스 번호입니다.

ISN

- 초기 시퀀스 번호. 연결\(ISS 또는 IRS\)에 사용되는 첫 번째 시퀀스 번호입니다. 주어진 기간 내에 고유하고 공격자가 예측할 수 없는 방식으로 선택됩니다.

ISS

- 초기 전송 시퀀스 번호입니다. 연결 시 보낸 사람이 사용하는 첫 번째 시퀀스 번호입니다.

왼쪽 순서

- 이는 데이터를 수신하는 TCP 끝점에서 승인할 다음 시퀀스 번호\(또는 현재 승인되지 않은 가장 낮은 시퀀스 번호\)이며 때로는 전송 창의 왼쪽 가장자리라고도 합니다.

기준 치수

- 일반적으로 소프트웨어로 프로토콜이나 기타 절차를 구현하는 것입니다.

MSL

- 최대 세그먼트 수명, TCP 세그먼트가 인터네트워크 시스템에 존재할 수 있는 시간입니다. 2분으로 임의로 정의됩니다.

팔중주

- 8비트 바이트.

옵션

- 옵션 필드에는 여러 옵션이 포함될 수 있으며 각 옵션의 길이는 여러 옥텟일 수 있습니다.

패킷

- 논리적으로 완전할 수도 있고 완전하지 않을 수도 있는 헤더가 있는 데이터 패키지입니다. 데이터의 논리적 패키징보다 물리적 패키징인 경우가 더 많습니다.

포트

- 끝점에서 연결을 역다중화하는 데 사용되는 연결 식별자 부분입니다.

프로세스

- 실행 중인 프로그램입니다. TCP 끝점 또는 기타 호스트 간 프로토콜의 관점에서 본 데이터의 소스 또는 대상입니다.

푸시

- 시퀀스 공간을 차지하지 않는 제어 비트로, 이 세그먼트에는 수신 사용자에게 전달되어야 하는 데이터가 포함되어 있음을 나타냅니다.

```text
   RCV.NXT
           receive next sequence number

   RCV.UP 
           receive urgent pointer

   RCV.WND
           receive window
```

다음 시퀀스 번호 수신

- 이는 로컬 TCP 끝점이 수신할 것으로 예상하는 다음 시퀀스 번호입니다.

수신 창

- 로컬\(수신\) TCP 엔드포인트가 수신하려는 시퀀스 번호를 나타냅니다. 따라서 로컬 TCP 끝점은 RCV.NXT에서 RCV.NXT + RCV.WND - 1 범위와 겹치는 세그먼트가 허용 가능한 데이터 또는 제어를 전달한다고 간주합니다. 이 범위를 완전히 벗어나는 시퀀스 번호를 포함하는 세그먼트는 중복 또는 주입 공격으로 간주되어 삭제됩니다.

RST

- 시퀀스 공간을 차지하지 않는 제어 비트\(리셋\)는 수신기가 추가 상호 작용 없이 연결을 삭제해야 함을 나타냅니다. 수신자는 수신 세그먼트의 시퀀스 번호와 승인 필드를 기반으로 재설정 명령을 수락해야 하는지 아니면 무시해야 하는지 결정할 수 있습니다. 어떤 경우에도 RST가 포함된 세그먼트를 수신하면 이에 대한 응답으로 RST가 발생하지 않습니다.

```text
   SEG.ACK
           segment acknowledgment

   SEG.LEN
           segment length

   SEG.SEQ
           segment sequence

   SEG.UP 
           segment urgent pointer field

   SEG.WND
           segment window field
```

분절

- 데이터의 논리적 단위입니다. 특히, TCP 세그먼트는 한 쌍의 TCP 모듈 간에 전송되는 데이터 단위입니다.

세그먼트 승인

- 도착 세그먼트의 승인 필드에 있는 시퀀스 번호.

세그먼트 길이

- 시퀀스 공간을 차지하는 모든 컨트롤을 포함하여 세그먼트가 차지하는 시퀀스 번호 공간의 양입니다.

세그먼트 순서

- 도착 세그먼트의 시퀀스 필드에 있는 번호입니다.

시퀀스 보내기

- 로컬\(송신\) TCP 엔드포인트가 연결에 사용할 다음 시퀀스 번호입니다. 이는 처음에 초기 ISN\(순서 번호 곡선\)에서 선택되며 전송된 데이터 또는 시퀀스 제어의 각 옥텟에 대해 증가됩니다.

보내기 창

- 원격\(수신\) TCP 엔드포인트가 수신하려는 시퀀스 번호를 나타냅니다. 원격\(데이터 수신\) TCP 끝점의 세그먼트에 지정된 창 필드의 값입니다. TCP 구현에 의해 생성될 수 있는 새 시퀀스 번호의 범위는 SND.NXT와 SND.UNA + SND.WND - 1 사이입니다. \(물론 SND.UNA와 SND.NXT 사이의 시퀀스 번호 재전송이 예상됩니다.\)

```text
   SND.NXT
           send sequence

   SND.UNA
           left sequence

   SND.UP 
           send urgent pointer
```

SND.WL1

- 마지막 창 업데이트 시 세그먼트 시퀀스 번호

SND.WL2

- 마지막 창 업데이트 시 세그먼트 승인 번호

```text
   SND.WND
           send window
```

소켓\(또는 소켓 번호, 소켓 주소 또는 소켓 식별자\) 포트 식별자, 즉 인터넷 주소와 TCP 포트의 연결을 구체적으로 포함하는 주소입니다.

소스 주소

- 송신 엔드포인트의 네트워크 계층 주소입니다.

싱크

- 하나의 시퀀스 번호를 차지하는 수신 세그먼트의 제어 비트로, 시퀀스 번호 지정이 시작되는 위치를 나타내기 위해 연결 시작 시 사용됩니다.

TCB

- 전송 제어 블록, 연결 상태를 기록하는 데이터 구조.

TCP

- 전송 제어 프로토콜\(Transmission Control Protocol\): 인터네트워크 환경에서 안정적인 통신을 위한 호스트 간 프로토콜입니다.

TOS

- 서비스 유형, 더 이상 사용되지 않는 IPv4 필드입니다. DSCP\(Differentiated Services Codepoint\) 값과 2비트 ECN 코드 포인트\[6\]를 포함하는 Differentiated Services 필드\[4\]에 동일한 헤더 비트가 현재 사용됩니다.

서비스 유형

- "TOS"를 참조하세요.

우르그

- 시퀀스 공간을 차지하지 않는 제어 비트\(긴급\), 긴급 포인터가 나타내는 값보다 작은 시퀀스 번호로 소비할 데이터가 있는 한 수신 사용자에게 긴급 처리를 수행하도록 알려야 함을 나타내는 데 사용됩니다.

긴급 포인터

- URG 비트가 켜져 있을 때만 의미가 있는 제어 필드입니다. 이 필드는 보내는 사용자의 긴급 통화와 관련된 데이터 옥텟을 나타내는 긴급 포인터의 값을 전달합니다.

---
## **5.  Changes from RFC 793**

이 문서는 RFC 793과 793을 업데이트한 RFC 6093 및 6528을 폐기합니다. 모든 경우에 규범적 프로토콜 사양 및 요구 사항만 이 문서에 통합되었으며 배경 및 근거가 포함된 일부 정보 텍스트는 포함되지 않았을 수 있습니다. 해당 문서의 정보 내용은 TCP를 배우고 이해하는 데 여전히 가치가 있으며, 비록 규범적인 내용이 이 문서에 통합되어 있더라도 유효한 정보 참조 자료입니다.

이 문서의 본문은 서식과 레이아웃을 최대한 가깝게 유지하기 위해 "기능 사양"이라는 제목의 RFC 793 섹션 3을 수정했습니다.

RFC 793 업데이트를 위해 보고되고 승인되거나 보류된 적용 가능한 RFC 정오표 모음이 통합되었습니다\(Errata ID: 573 \[73\], 574 \[74\], 700 \[75\], 701 \[76\], 1283 \[77 \], 1561 \[78\], 1562 \[79\], 1564 \[80\], 1571 \[81\], 1572 \[82\], 2297 \[83\], 2298 \[84\], 2748 \[85\], 2749 \[86\], 2934 \[87 \], 3213 \[88\], 3300 \[89\], 3301 \[90\], 6222 \[91\]\). 일부 정오표는 다른 변경으로 인해 적용되지 않았습니다\(정오표 ID: 572 \[92\], 575 \[93\], 1565 \[94\], 1569 \[95\], 2296 \[96\], 3305 \[97\], 3602 \[98\]\).

RFC 1011, 1122 및 6093에 설명된 긴급 포인터 사양에 대한 변경 사항이 통합되었습니다. 이러한 변경이 필요한 이유에 대한 자세한 내용은 RFC 6093을 참조하세요.

RFC 793의 RTO에 대한 논의는 RFC 6298을 참조하도록 업데이트되었습니다. RFC 1122의 RTO 텍스트는 원래 RFC 793의 텍스트를 대체했습니다. 그러나 RFC 2988은 RFC 1122를 업데이트해야 했으며 이후 RFC 6298에 의해 폐기되었습니다.

RFC 1011 \[18\]에는 TCP 사양에 필요한 일부 변경 사항을 포함하여 RFC 793에 대한 많은 설명이 포함되어 있습니다. 이는 RFC 793에 대한 기타 변경 사항 및 설명 모음이 포함된 RFC 1122에서 확장되었습니다. 프로토콜에 영향을 미치는 규범적 항목은 여기에 통합되었지만 RFC 1122의 일부 역사적으로 유용한 구현 조언 및 유익한 토론은 여기에 포함되어 있지 않습니다. 이제 RFC 793이 아닌 TCP 사양인 본 문서는 RFC 1011을 업데이트하고 RFC 1011에 언급된 설명이 통합되었습니다.

RFC 1122에는 TCP 요구 사항 이상의 내용이 포함되어 있으므로 이 문서가 RFC 1122를 완전히 폐기할 수는 없습니다. RFC 1122를 "업데이트 중"이라고만 표시되어 있습니다. 그러나 RFC 1122에 있는 TCP의 모든 자료는 사실상 더 이상 사용되지 않는 것으로 이해되어야 합니다.

RFC 6528의 보다 안전한 초기 시퀀스 번호 생성 알고리즘이 통합되었습니다. 이를 통해 완화되는 공격에 대한 논의와 PRF 알고리즘 선택 및 비밀 키 데이터 관리에 대한 조언은 RFC 6528을 참조하세요.

시스템 리소스 관리 문제로 인해 연결 리소스를 회수할 수 있다는 점을 명시적으로 명확히 하기 위해 RFC 6429를 기반으로 한 참고 사항이 추가되었습니다. RFC 6429는 설명된 설명이 이 기본 TCP 사양에 반영되었다는 의미에서 더 이상 사용되지 않습니다.

혼잡 제어 구현에 대한 설명은 해당 주제에 대한 IETF BCP 또는 표준 트랙 문서 집합과 일반적인 구현의 현재 상태를 기반으로 추가되었습니다.

---
## **6.  IANA Considerations**

IANA는 "TCP\(전송 제어 프로토콜\) 헤더 플래그" 레지스트리에서 이 섹션에 설명된 대로 몇 가지 변경 사항을 적용했습니다.

RFC 3168은 원래 이 레지스트리를 만들었지만 RFC 3168에 정의된 새 비트로만 채웠으며 이전에 RFC 793 및 기타 문서에 설명된 다른 비트는 무시했습니다. 이후 비트 7도 RFC 8311 \[54\]에 의해 업데이트되었습니다.

"비트" 열은 그림 1의 TCP 헤더의 16비트 정렬 보기 내에서 각 헤더 플래그의 오프셋을 참조하기 때문에 아래에서 "비트 오프셋" 열로 이름이 변경되었습니다. 오프셋 0부터 3까지의 비트는 TCP 세그먼트 데이터입니다. 헤더 플래그가 아닌 오프셋 필드입니다.

IANA는 "과제 메모" 열을 추가했습니다.

IANA는 아래와 같이 값을 할당했습니다.

```text
      +========+===================+===========+====================+
      | Bit    | Name              | Reference | Assignment Notes   |
      | Offset |                   |           |                    |
      +========+===================+===========+====================+
      | 4      | Reserved for      | RFC 9293  |                    |
      |        | future use        |           |                    |
      +--------+-------------------+-----------+--------------------+
      | 5      | Reserved for      | RFC 9293  |                    |
      |        | future use        |           |                    |
      +--------+-------------------+-----------+--------------------+
      | 6      | Reserved for      | RFC 9293  |                    |
      |        | future use        |           |                    |
      +--------+-------------------+-----------+--------------------+
      | 7      | Reserved for      | RFC 8311  | Previously used by |
      |        | future use        |           | Historic RFC 3540  |
      |        |                   |           | as NS (Nonce Sum). |
      +--------+-------------------+-----------+--------------------+
      | 8      | CWR (Congestion   | RFC 3168  |                    |
      |        | Window Reduced)   |           |                    |
      +--------+-------------------+-----------+--------------------+
      | 9      | ECE (ECN-Echo)    | RFC 3168  |                    |
      +--------+-------------------+-----------+--------------------+
      | 10     | Urgent pointer    | RFC 9293  |                    |
      |        | field is          |           |                    |
      |        | significant (URG) |           |                    |
      +--------+-------------------+-----------+--------------------+
      | 11     | Acknowledgment    | RFC 9293  |                    |
      |        | field is          |           |                    |
      |        | significant (ACK) |           |                    |
      +--------+-------------------+-----------+--------------------+
      | 12     | Push function     | RFC 9293  |                    |
      |        | (PSH)             |           |                    |
      +--------+-------------------+-----------+--------------------+
      | 13     | Reset the         | RFC 9293  |                    |
      |        | connection (RST)  |           |                    |
      +--------+-------------------+-----------+--------------------+
      | 14     | Synchronize       | RFC 9293  |                    |
      |        | sequence numbers  |           |                    |
      |        | (SYN)             |           |                    |
      +--------+-------------------+-----------+--------------------+
      | 15     | No more data from | RFC 9293  |                    |
      |        | sender (FIN)      |           |                    |
      +--------+-------------------+-----------+--------------------+

                         Table 7: TCP Header Flags

   The "TCP Header Flags" registry has also been moved to a subregistry
   under the global "Transmission Control Protocol (TCP) Parameters"
   registry <https://www.iana.org/assignments/tcp-parameters/>.
```

레지스트리의 등록 절차는 표준 조치로 유지되지만 참조는 이 문서에 업데이트되었으며 참고는 제거되었습니다.

---
## **7.  Security and Privacy Considerations**

TCP 설계에는 연결 및 애플리케이션 데이터 전송의 견고성과 신뢰성을 향상시키는 기본적인 보안 기능만 포함되어 있지만 모든 형태의 기밀성, 인증 또는 기타 일반적인 보안 기능을 지원하는 내장된 암호화 기능은 없습니다. 특정 유형의 공격에 대한 TCP 연결의 견고성을 향상시키기 위해 비암호화 개선 사항\(예: \[9\]\)이 개발되었지만 비암호화 개선 사항의 적용 가능성과 보호는 제한적입니다\(예: \[9\]의 섹션 1.1 참조\). 애플리케이션은 일반적으로 하위 계층\(예: IPsec\) 및 상위 계층\(예: TLS\) 프로토콜을 활용하여 TCP 연결 및 TCP에서 전달되는 애플리케이션 데이터에 대한 보안 및 개인 정보 보호를 제공합니다. 일부 보안 기능을 지원하기 위해 TCP 옵션을 기반으로 하는 방법도 개발되었습니다.

TCP 연결\(제어 플래그 포함\)에 대한 기밀성, 무결성 보호 및 인증을 완벽하게 제공하기 위해 IPsec은 현재 유일하게 효과적인 방법입니다. 무결성 보호 및 인증을 위해 TCP-AO\(TCP 인증 옵션\)\[38\]를 사용할 수 있으며, 세그먼트 페이로드에 대한 기밀성을 제공하기 위한 확장도 제안되었습니다. 이 섹션에서 논의된 다른 방법은 페이로드에 대한 기밀성 또는 무결성 보호를 제공할 수 있지만 TCP 헤더의 경우 필드의 하위 집합\(예: tcpcrypt \[57\]\)만 다루거나 전혀 포함하지 않습니다\(예: TLS\). TCP에 추가된 기타 보안 기능\(예: ISN 생성, 시퀀스 번호 확인 등\)은 공격을 부분적으로만 방해할 수 있습니다.

수명이 긴 TCP 흐름을 사용하는 애플리케이션은 이전 TCP 사양\[33\]에 설명된 제어 플래그 처리를 이용하는 공격에 취약했습니다. TCP-MD5는 이러한 연결 중 일부에 대한 인증을 지원하기 위해 일반적으로 구현되는 TCP 옵션이었지만 결함이 있어 현재는 더 이상 사용되지 않습니다. TCP-AO는 장기간 지속되는 TCP 연결을 공격으로부터 보호하는 기능을 제공하며 TCP-MD5보다 우수한 속성을 가지고 있습니다. 애플리케이션 데이터 또는 TCP 헤더에 대한 개인 정보를 제공하지 않습니다.

TCP에 대한 "tcpcrypt" \[57\] 실험적 확장은 연결 데이터를 암호화하여 보호하는 기능을 제공합니다. TCP 흐름의 메타데이터 측면은 여전히 ​​표시되지만 애플리케이션 스트림은 잘 보호됩니다. TCP 헤더 내에서는 긴급 포인터와 FIN 플래그만 tcpcrypt를 통해 보호됩니다.

TCP 로드맵 \[49\]에는 TCP 보안과 관련된 여러 RFC에 대한 참고 사항이 포함되어 있습니다. ISN 생성, 블라인드 창 내 공격 완화, 소프트 오류 및 ICMP 패킷 처리 개선 등 이러한 RFC에서 제공하는 많은 향상된 기능이 현재 문서에 통합되었습니다. 이들 모두는 이전 TCP 사양에 필요한 변경 사항을 원래 설명했던 참조 RFC에서 더 자세히 논의됩니다. 또한 긴급 포인터 필드와 관련된 보안 고려 사항에 대한 논의는 RFC 6093 \[39\]을 참조하세요. 이는 새로운 애플리케이션이 긴급 포인터를 사용하는 것을 방해하기도 합니다.

TCP는 대량 전송 흐름에 자주 사용되므로 TCP 혼잡 제어 논리를 남용하는 일부 공격이 가능합니다. 예를 들어 "ACK 분할" 공격이 있습니다. TCP 혼잡 제어 사양에 대한 업데이트에는 이러한 공격에 대한 완화 역할을 하는 ABC\(Appropriate Byte Counting\) \[29\]와 같은 메커니즘이 포함되어 있습니다.

다른 공격은 TCP 서버의 리소스를 소모하는 데 중점을 둡니다. 예로는 SYN 플러딩\[32\] 또는 진행되지 않는 연결에서 리소스 낭비\[41\]가 있습니다. 운영 체제는 일반적으로 이러한 공격에 대한 완화 기능을 구현합니다. 일부 일반적인 방어에서는 프록시, 상태 저장 방화벽 및 최종 호스트 TCP 구현 외부의 기타 기술도 활용합니다.

프로토콜의 "와이어 이미지" 개념은 RFC 8546 \[56\]에 설명되어 있습니다. 이는 TCP의 일반 텍스트 헤더가 패킷을 대상으로 라우팅하는 데 엄격하게 필요한 것보다 더 많은 메타데이터를 경로의 노드에 노출하는 방법을 설명합니다. 경로에 있는 적들은 이 메타데이터를 활용할 수 있습니다. 이와 관련하여 TCP에서 배운 교훈은 QUIC\[60\]과 같은 최신 전송 설계에 적용되었습니다. 또한 부분적으로 TCP 및 확장에 대한 경험을 바탕으로 RFC 8558 \[58\] 및 \[ 67\].

호스트 TCP 구현\(운영 체제\) 버전이나 플랫폼 정보를 유추하는 데 사용할 수 있는 "핑거프린팅" 방법도 있습니다. 이는 세그먼트에 존재하는 옵션, 옵션 순서, 다양한 조건의 경우 특정 동작, 패킷 타이밍, 패킷 크기 및 프로토콜의 기타 측면과 같은 여러 측면에 대한 관찰을 수집합니다. 구현자는 이러한 관찰을 사용하여 호스트 및 구현에 대한 정보를 식별할 수 있습니다.

ICMP 메시지 처리는 TCP 연결과도 상호 작용할 수 있으므로 TCP 연결에 대한 ICMP 기반 공격 가능성이 있습니다. 이는 구현된 완화 조치와 함께 RFC 5927 \[100\]에서 논의됩니다.

---
## **8.  References**
---
### **8.1.  Normative References**

```text
   [1]        Postel, J., "Internet Protocol", STD 5, RFC 791,
              DOI 10.17487/RFC0791, September 1981,
              <https://www.rfc-editor.org/info/rfc791>.

   [2]        Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,
              DOI 10.17487/RFC1191, November 1990,
              <https://www.rfc-editor.org/info/rfc1191>.

   [3]        Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [4]        Nichols, K., Blake, S., Baker, F., and D. Black,
              "Definition of the Differentiated Services Field (DS
              Field) in the IPv4 and IPv6 Headers", RFC 2474,
              DOI 10.17487/RFC2474, December 1998,
              <https://www.rfc-editor.org/info/rfc2474>.

   [5]        Floyd, S., "Congestion Control Principles", BCP 41,
              RFC 2914, DOI 10.17487/RFC2914, September 2000,
              <https://www.rfc-editor.org/info/rfc2914>.

   [6]        Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              RFC 3168, DOI 10.17487/RFC3168, September 2001,
              <https://www.rfc-editor.org/info/rfc3168>.

   [7]        Floyd, S. and M. Allman, "Specifying New Congestion
              Control Algorithms", BCP 133, RFC 5033,
              DOI 10.17487/RFC5033, August 2007,
              <https://www.rfc-editor.org/info/rfc5033>.

   [8]        Allman, M., Paxson, V., and E. Blanton, "TCP Congestion
              Control", RFC 5681, DOI 10.17487/RFC5681, September 2009,
              <https://www.rfc-editor.org/info/rfc5681>.

   [9]        Ramaiah, A., Stewart, R., and M. Dalal, "Improving TCP's
              Robustness to Blind In-Window Attacks", RFC 5961,
              DOI 10.17487/RFC5961, August 2010,
              <https://www.rfc-editor.org/info/rfc5961>.

   [10]       Paxson, V., Allman, M., Chu, J., and M. Sargent,
              "Computing TCP's Retransmission Timer", RFC 6298,
              DOI 10.17487/RFC6298, June 2011,
              <https://www.rfc-editor.org/info/rfc6298>.

   [11]       Gont, F., "Deprecation of ICMP Source Quench Messages",
              RFC 6633, DOI 10.17487/RFC6633, May 2012,
              <https://www.rfc-editor.org/info/rfc6633>.

   [12]       Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [13]       Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", STD 86, RFC 8200,
              DOI 10.17487/RFC8200, July 2017,
              <https://www.rfc-editor.org/info/rfc8200>.

   [14]       McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed.,
              "Path MTU Discovery for IP version 6", STD 87, RFC 8201,
              DOI 10.17487/RFC8201, July 2017,
              <https://www.rfc-editor.org/info/rfc8201>.

   [15]       Allman, M., "Requirements for Time-Based Loss Detection",
              BCP 233, RFC 8961, DOI 10.17487/RFC8961, November 2020,
              <https://www.rfc-editor.org/info/rfc8961>.
```

---
### **8.2.  Informative References**

```text
   [16]       Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <https://www.rfc-editor.org/info/rfc793>.

   [17]       Nagle, J., "Congestion Control in IP/TCP Internetworks",
              RFC 896, DOI 10.17487/RFC0896, January 1984,
              <https://www.rfc-editor.org/info/rfc896>.

   [18]       Reynolds, J. and J. Postel, "Official Internet protocols",
              RFC 1011, DOI 10.17487/RFC1011, May 1987,
              <https://www.rfc-editor.org/info/rfc1011>.

   [19]       Braden, R., Ed., "Requirements for Internet Hosts -
              Communication Layers", STD 3, RFC 1122,
              DOI 10.17487/RFC1122, October 1989,
              <https://www.rfc-editor.org/info/rfc1122>.

   [20]       Almquist, P., "Type of Service in the Internet Protocol
              Suite", RFC 1349, DOI 10.17487/RFC1349, July 1992,
              <https://www.rfc-editor.org/info/rfc1349>.

   [21]       Braden, R., "T/TCP -- TCP Extensions for Transactions
              Functional Specification", RFC 1644, DOI 10.17487/RFC1644,
              July 1994, <https://www.rfc-editor.org/info/rfc1644>.

   [22]       Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
              Selective Acknowledgment Options", RFC 2018,
              DOI 10.17487/RFC2018, October 1996,
              <https://www.rfc-editor.org/info/rfc2018>.

   [23]       Paxson, V., Allman, M., Dawson, S., Fenner, W., Griner,
              J., Heavens, I., Lahey, K., Semke, J., and B. Volz, "Known
              TCP Implementation Problems", RFC 2525,
              DOI 10.17487/RFC2525, March 1999,
              <https://www.rfc-editor.org/info/rfc2525>.

   [24]       Borman, D., Deering, S., and R. Hinden, "IPv6 Jumbograms",
              RFC 2675, DOI 10.17487/RFC2675, August 1999,
              <https://www.rfc-editor.org/info/rfc2675>.

   [25]       Xiao, X., Hannan, A., Paxson, V., and E. Crabbe, "TCP
              Processing of the IPv4 Precedence Field", RFC 2873,
              DOI 10.17487/RFC2873, June 2000,
              <https://www.rfc-editor.org/info/rfc2873>.

   [26]       Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, "An
              Extension to the Selective Acknowledgement (SACK) Option
              for TCP", RFC 2883, DOI 10.17487/RFC2883, July 2000,
              <https://www.rfc-editor.org/info/rfc2883>.

   [27]       Lahey, K., "TCP Problems with Path MTU Discovery",
              RFC 2923, DOI 10.17487/RFC2923, September 2000,
              <https://www.rfc-editor.org/info/rfc2923>.

   [28]       Balakrishnan, H., Padmanabhan, V., Fairhurst, G., and M.
              Sooriyabandara, "TCP Performance Implications of Network
              Path Asymmetry", BCP 69, RFC 3449, DOI 10.17487/RFC3449,
              December 2002, <https://www.rfc-editor.org/info/rfc3449>.

   [29]       Allman, M., "TCP Congestion Control with Appropriate Byte
              Counting (ABC)", RFC 3465, DOI 10.17487/RFC3465, February
              2003, <https://www.rfc-editor.org/info/rfc3465>.

   [30]       Fenner, B., "Experimental Values In IPv4, IPv6, ICMPv4,
              ICMPv6, UDP, and TCP Headers", RFC 4727,
              DOI 10.17487/RFC4727, November 2006,
              <https://www.rfc-editor.org/info/rfc4727>.

   [31]       Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, DOI 10.17487/RFC4821, March 2007,
              <https://www.rfc-editor.org/info/rfc4821>.

   [32]       Eddy, W., "TCP SYN Flooding Attacks and Common
              Mitigations", RFC 4987, DOI 10.17487/RFC4987, August 2007,
              <https://www.rfc-editor.org/info/rfc4987>.

   [33]       Touch, J., "Defending TCP Against Spoofing Attacks",
              RFC 4953, DOI 10.17487/RFC4953, July 2007,
              <https://www.rfc-editor.org/info/rfc4953>.

   [34]       Culley, P., Elzur, U., Recio, R., Bailey, S., and J.
              Carrier, "Marker PDU Aligned Framing for TCP
              Specification", RFC 5044, DOI 10.17487/RFC5044, October
              2007, <https://www.rfc-editor.org/info/rfc5044>.

   [35]       Gont, F., "TCP's Reaction to Soft Errors", RFC 5461,
              DOI 10.17487/RFC5461, February 2009,
              <https://www.rfc-editor.org/info/rfc5461>.

   [36]       StJohns, M., Atkinson, R., and G. Thomas, "Common
              Architecture Label IPv6 Security Option (CALIPSO)",
              RFC 5570, DOI 10.17487/RFC5570, July 2009,
              <https://www.rfc-editor.org/info/rfc5570>.

   [37]       Sandlund, K., Pelletier, G., and L-E. Jonsson, "The RObust
              Header Compression (ROHC) Framework", RFC 5795,
              DOI 10.17487/RFC5795, March 2010,
              <https://www.rfc-editor.org/info/rfc5795>.

   [38]       Touch, J., Mankin, A., and R. Bonica, "The TCP
              Authentication Option", RFC 5925, DOI 10.17487/RFC5925,
              June 2010, <https://www.rfc-editor.org/info/rfc5925>.

   [39]       Gont, F. and A. Yourtchenko, "On the Implementation of the
              TCP Urgent Mechanism", RFC 6093, DOI 10.17487/RFC6093,
              January 2011, <https://www.rfc-editor.org/info/rfc6093>.

   [40]       Gont, F., "Reducing the TIME-WAIT State Using TCP
              Timestamps", BCP 159, RFC 6191, DOI 10.17487/RFC6191,
              April 2011, <https://www.rfc-editor.org/info/rfc6191>.

   [41]       Bashyam, M., Jethanandani, M., and A. Ramaiah, "TCP Sender
              Clarification for Persist Condition", RFC 6429,
              DOI 10.17487/RFC6429, December 2011,
              <https://www.rfc-editor.org/info/rfc6429>.

   [42]       Gont, F. and S. Bellovin, "Defending against Sequence
              Number Attacks", RFC 6528, DOI 10.17487/RFC6528, February
              2012, <https://www.rfc-editor.org/info/rfc6528>.

   [43]       Borman, D., "TCP Options and Maximum Segment Size (MSS)",
              RFC 6691, DOI 10.17487/RFC6691, July 2012,
              <https://www.rfc-editor.org/info/rfc6691>.

   [44]       Touch, J., "Updated Specification of the IPv4 ID Field",
              RFC 6864, DOI 10.17487/RFC6864, February 2013,
              <https://www.rfc-editor.org/info/rfc6864>.

   [45]       Touch, J., "Shared Use of Experimental TCP Options",
              RFC 6994, DOI 10.17487/RFC6994, August 2013,
              <https://www.rfc-editor.org/info/rfc6994>.

   [46]       McPherson, D., Oran, D., Thaler, D., and E. Osterweil,
              "Architectural Considerations of IP Anycast", RFC 7094,
              DOI 10.17487/RFC7094, January 2014,
              <https://www.rfc-editor.org/info/rfc7094>.

   [47]       Borman, D., Braden, B., Jacobson, V., and R.
              Scheffenegger, Ed., "TCP Extensions for High Performance",
              RFC 7323, DOI 10.17487/RFC7323, September 2014,
              <https://www.rfc-editor.org/info/rfc7323>.

   [48]       Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP
              Fast Open", RFC 7413, DOI 10.17487/RFC7413, December 2014,
              <https://www.rfc-editor.org/info/rfc7413>.

   [49]       Duke, M., Braden, R., Eddy, W., Blanton, E., and A.
              Zimmermann, "A Roadmap for Transmission Control Protocol
              (TCP) Specification Documents", RFC 7414,
              DOI 10.17487/RFC7414, February 2015,
              <https://www.rfc-editor.org/info/rfc7414>.

   [50]       Black, D., Ed. and P. Jones, "Differentiated Services
              (Diffserv) and Real-Time Communication", RFC 7657,
              DOI 10.17487/RFC7657, November 2015,
              <https://www.rfc-editor.org/info/rfc7657>.

   [51]       Fairhurst, G. and M. Welzl, "The Benefits of Using
              Explicit Congestion Notification (ECN)", RFC 8087,
              DOI 10.17487/RFC8087, March 2017,
              <https://www.rfc-editor.org/info/rfc8087>.

   [52]       Fairhurst, G., Ed., Trammell, B., Ed., and M. Kuehlewind,
              Ed., "Services Provided by IETF Transport Protocols and
              Congestion Control Mechanisms", RFC 8095,
              DOI 10.17487/RFC8095, March 2017,
              <https://www.rfc-editor.org/info/rfc8095>.

   [53]       Welzl, M., Tuexen, M., and N. Khademi, "On the Usage of
              Transport Features Provided by IETF Transport Protocols",
              RFC 8303, DOI 10.17487/RFC8303, February 2018,
              <https://www.rfc-editor.org/info/rfc8303>.

   [54]       Black, D., "Relaxing Restrictions on Explicit Congestion
              Notification (ECN) Experimentation", RFC 8311,
              DOI 10.17487/RFC8311, January 2018,
              <https://www.rfc-editor.org/info/rfc8311>.

   [55]       Chown, T., Loughney, J., and T. Winters, "IPv6 Node
              Requirements", BCP 220, RFC 8504, DOI 10.17487/RFC8504,
              January 2019, <https://www.rfc-editor.org/info/rfc8504>.

   [56]       Trammell, B. and M. Kuehlewind, "The Wire Image of a
              Network Protocol", RFC 8546, DOI 10.17487/RFC8546, April
              2019, <https://www.rfc-editor.org/info/rfc8546>.

   [57]       Bittau, A., Giffin, D., Handley, M., Mazieres, D., Slack,
              Q., and E. Smith, "Cryptographic Protection of TCP Streams
              (tcpcrypt)", RFC 8548, DOI 10.17487/RFC8548, May 2019,
              <https://www.rfc-editor.org/info/rfc8548>.

   [58]       Hardie, T., Ed., "Transport Protocol Path Signals",
              RFC 8558, DOI 10.17487/RFC8558, April 2019,
              <https://www.rfc-editor.org/info/rfc8558>.

   [59]       Ford, A., Raiciu, C., Handley, M., Bonaventure, O., and C.
              Paasch, "TCP Extensions for Multipath Operation with
              Multiple Addresses", RFC 8684, DOI 10.17487/RFC8684, March
              2020, <https://www.rfc-editor.org/info/rfc8684>.

   [60]       Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [61]       Fairhurst, G. and C. Perkins, "Considerations around
              Transport Header Confidentiality, Network Operations, and
              the Evolution of Internet Transport Protocols", RFC 9065,
              DOI 10.17487/RFC9065, July 2021,
              <https://www.rfc-editor.org/info/rfc9065>.

   [62]       IANA, "Transmission Control Protocol (TCP) Parameters",
              <https://www.iana.org/assignments/tcp-parameters/>.

   [63]       Gont, F., "Processing of IP Security/Compartment and
              Precedence Information by TCP", Work in Progress,
              Internet-Draft, draft-gont-tcpm-tcp-seccomp-prec-00, 29
              March 2012, <https://datatracker.ietf.org/doc/html/draft-
              gont-tcpm-tcp-seccomp-prec-00>.

   [64]       Gont, F. and D. Borman, "On the Validation of TCP Sequence
              Numbers", Work in Progress, Internet-Draft, draft-gont-
              tcpm-tcp-seq-validation-04, 11 March 2019,
              <https://datatracker.ietf.org/doc/html/draft-gont-tcpm-
              tcp-seq-validation-04>.

   [65]       Touch, J. and W. M. Eddy, "TCP Extended Data Offset
              Option", Work in Progress, Internet-Draft, draft-ietf-
              tcpm-tcp-edo-12, 15 April 2022,
              <https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-
              tcp-edo-12>.

   [66]       McQuistin, S., Band, V., Jacob, D., and C. Perkins,
              "Describing Protocol Data Units with Augmented Packet
              Header Diagrams", Work in Progress, Internet-Draft, draft-
              mcquistin-augmented-ascii-diagrams-10, 7 March 2022,
              <https://datatracker.ietf.org/doc/html/draft-mcquistin-
              augmented-ascii-diagrams-10>.

   [67]       Thomson, M. and T. Pauly, "Long-Term Viability of Protocol
              Extension Mechanisms", RFC 9170, DOI 10.17487/RFC9170,
              December 2021, <https://www.rfc-editor.org/info/rfc9170>.

   [68]       Minshall, G., "A Suggested Modification to Nagle's
              Algorithm", Work in Progress, Internet-Draft, draft-
              minshall-nagle-01, 18 June 1999,
              <https://datatracker.ietf.org/doc/html/draft-minshall-
              nagle-01>.

   [69]       Dalal, Y. and C. Sunshine, "Connection Management in
              Transport Protocols", Computer Networks, Vol. 2, No. 6,
              pp. 454-473, DOI 10.1016/0376-5075(78)90053-3, December
              1978, <https://doi.org/10.1016/0376-5075(78)90053-3>.

   [70]       Faber, T., Touch, J., and W. Yui, "The TIME-WAIT state in
              TCP and Its Effect on Busy Servers", Proceedings of IEEE
              INFOCOM, pp. 1573-1583, DOI 10.1109/INFCOM.1999.752180,
              March 1999, <https://doi.org/10.1109/INFCOM.1999.752180>.

   [71]       Postel, J., "Comments on Action Items from the January
              Meeting", IEN 177, March 1981,
              <https://www.rfc-editor.org/ien/ien177.txt>.

   [72]       "Segmentation Offloads", The Linux Kernel Documentation,
              <https://www.kernel.org/doc/html/latest/networking/
              segmentation-offloads.html>.

   [73]       RFC Errata, Erratum ID 573, RFC 793,
              <https://www.rfc-editor.org/errata/eid573>.

   [74]       RFC Errata, Erratum ID 574, RFC 793,
              <https://www.rfc-editor.org/errata/eid574>.

   [75]       RFC Errata, Erratum ID 700, RFC 793,
              <https://www.rfc-editor.org/errata/eid700>.

   [76]       RFC Errata, Erratum ID 701, RFC 793,
              <https://www.rfc-editor.org/errata/eid701>.

   [77]       RFC Errata, Erratum ID 1283, RFC 793,
              <https://www.rfc-editor.org/errata/eid1283>.

   [78]       RFC Errata, Erratum ID 1561, RFC 793,
              <https://www.rfc-editor.org/errata/eid1561>.

   [79]       RFC Errata, Erratum ID 1562, RFC 793,
              <https://www.rfc-editor.org/errata/eid1562>.

   [80]       RFC Errata, Erratum ID 1564, RFC 793,
              <https://www.rfc-editor.org/errata/eid1564>.

   [81]       RFC Errata, Erratum ID 1571, RFC 793,
              <https://www.rfc-editor.org/errata/eid1571>.

   [82]       RFC Errata, Erratum ID 1572, RFC 793,
              <https://www.rfc-editor.org/errata/eid1572>.

   [83]       RFC Errata, Erratum ID 2297, RFC 793,
              <https://www.rfc-editor.org/errata/eid2297>.

   [84]       RFC Errata, Erratum ID 2298, RFC 793,
              <https://www.rfc-editor.org/errata/eid2298>.

   [85]       RFC Errata, Erratum ID 2748, RFC 793,
              <https://www.rfc-editor.org/errata/eid2748>.

   [86]       RFC Errata, Erratum ID 2749, RFC 793,
              <https://www.rfc-editor.org/errata/eid2749>.

   [87]       RFC Errata, Erratum ID 2934, RFC 793,
              <https://www.rfc-editor.org/errata/eid2934>.

   [88]       RFC Errata, Erratum ID 3213, RFC 793,
              <https://www.rfc-editor.org/errata/eid3213>.

   [89]       RFC Errata, Erratum ID 3300, RFC 793,
              <https://www.rfc-editor.org/errata/eid3300>.

   [90]       RFC Errata, Erratum ID 3301, RFC 793,
              <https://www.rfc-editor.org/errata/eid3301>.

   [91]       RFC Errata, Erratum ID 6222, RFC 793,
              <https://www.rfc-editor.org/errata/eid6222>.

   [92]       RFC Errata, Erratum ID 572, RFC 793,
              <https://www.rfc-editor.org/errata/eid572>.

   [93]       RFC Errata, Erratum ID 575, RFC 793,
              <https://www.rfc-editor.org/errata/eid575>.

   [94]       RFC Errata, Erratum ID 1565, RFC 793,
              <https://www.rfc-editor.org/errata/eid1565>.

   [95]       RFC Errata, Erratum ID 1569, RFC 793,
              <https://www.rfc-editor.org/errata/eid1569>.

   [96]       RFC Errata, Erratum ID 2296, RFC 793,
              <https://www.rfc-editor.org/errata/eid2296>.

   [97]       RFC Errata, Erratum ID 3305, RFC 793,
              <https://www.rfc-editor.org/errata/eid3305>.

   [98]       RFC Errata, Erratum ID 3602, RFC 793,
              <https://www.rfc-editor.org/errata/eid3602>.

   [99]       RFC Errata, Erratum ID 4772, RFC 5961,
              <https://www.rfc-editor.org/errata/eid4772>.

   [100]      Gont, F., "ICMP Attacks against TCP", RFC 5927,
              DOI 10.17487/RFC5927, July 2010,
              <https://www.rfc-editor.org/info/rfc5927>.
```

---
# **Appendix A.  Other Implementation Notes**

이 섹션에는 현재 RFC 시리즈의 일부가 아니거나 TCP 표준에 포함되어 있는 TCP 구현 결정에 대한 추가 참고 사항과 참조가 포함되어 있습니다. 이러한 항목은 구현자가 고려할 수 있지만 아직 표준에 포함시키려는 합의가 이루어지지 않았습니다.

---
### **A.1.  IP Security Compartment and Precedence**

IPv4 사양\[1\]에는 \(현재는 폐기된\) 서비스 유형\(TOS\) 필드의 우선 순위 값이 포함되어 있습니다. 이는 \[20\]에서 수정된 후 차별화된 서비스\(Diffserv\) \[4\]의 정의에 의해 폐기되었습니다. 네트워크 계층, TCP 구현 및 애플리케이션 간의 TOS 설정 및 전달은 더 이상 사용되지 않으며 현재 TCP 사양에서는 Diffserv로 대체됩니다.

RFC 793에서는 연결 내 및 애플리케이션 요청의 일관성을 위해 들어오는 TCP 세그먼트의 IP 보안 구획과 우선 순위를 확인해야 했습니다. IP의 이러한 각 측면은 RFC 793에 대한 특정 업데이트 없이 구식이 되었습니다. 우선순위 문제는 표준 트랙인 \[25\]에 의해 수정되었으므로 현재 TCP 사양에는 이러한 변경 사항이 포함됩니다. 그러나 MLS\(다중 수준 보안\) 시스템에서 사용할 수 있는 IP 보안 옵션의 상태는 현재 IETF에서만큼 명확하지 않습니다.

들어오는 패킷이 예상된 보안 구획이나 우선순위 기대치를 충족하지 못할 때 연결을 재설정하는 것은 가능한 공격 벡터로 인식되었으며\[63\], 일치하지 않는 IP 보안 구획 및 Diffserv로 인해 연결이 중단되는 것을 방지하기 위해 TCP 사양을 수정하는 것에 대한 논의가 있었습니다. 코드포인트 값.

---
#### **A.1.1.  Precedence**

Diffserv에서 이전 우선 순위 값은 클래스 선택기 코드 포인트로 처리되며 호환 가능한 처리 방법은 Diffserv 아키텍처에 설명되어 있습니다. RFC 793 및 1122에 의해 정의된 RFC TCP 사양에는 연결이 끝점 애플리케이션에서 요청한 가장 높은 우선 순위를 사용하고 연결 전체에서 우선 순위를 일관되게 유지하려는 논리가 포함되어 있습니다. 더 이상 사용되지 않는 TOS의 이 논리는 Diffserv에 적용되지 않으며 TCP 구현에 포함되어서는 안 됩니다. 단, 연결 내에서 Diffserv 값을 변경하는 것은 권장되지 않습니다. 이에 대한 논의는 RFC 7657\(섹션 5.1, 5.3 및 6\) \[50\]을 참조하세요.

TCP의 오래된 TOS 처리 규칙은 연결에 사용되는 양방향\(또는 대칭\) 우선 순위 값을 가정하지만 Diffserv 아키텍처는 비대칭입니다. 이와 관련하여 기존 TCP 논리의 문제점은 \[25\]에 설명되어 있으며 설명된 해결 방법은 TCP에서 IP 우선 순위를 무시하는 것입니다. RFC 2873은 표준 추적 문서이므로\(RFC 793 업데이트로 표시되지는 않았지만\) 현재 구현은 이러한 조건에서 강력할 것으로 예상됩니다. 각 방향에서 사용되는 Diffserv 필드 값은 TCP와 네트워크 계층 간 인터페이스의 일부이며, 사용 중인 값은 TCP와 애플리케이션 간 양방향으로 표시될 수 있습니다.

---
#### **A.1.2.  MLS Systems**

\[1\]에 정의된 IP 보안 옵션\(IPSO\) 및 구획은 RFC 1038에서 개선되었으며 나중에 RFC 1108에 의해 폐기되었습니다. CIPSO\(상용 IP 보안 옵션\)는 FIPS-188\(2015년 NIST에서 철회됨\)에 정의되어 있으며 일부 공급업체 및 운영 체제에서 지원됩니다. RFC 1108은 이제 역사적 버전이지만 RFC 791 자체는 IP 보안 옵션을 제거하도록 업데이트되지 않았습니다. IPv6의 경우 유사한 옵션\(CALIPSO\(Common Architecture Label IPv6 Security Option\)\)이 정의되었습니다\[36\]. RFC 793에는 TCP 세그먼트 처리 시 IP 보안/구획 정보를 포함하는 논리가 포함되어 있습니다. 이 문서의 IP "보안/구획"에 대한 참조는 MLS\(다단계 보안\) 시스템 구현자와 관련이 있을 수 있지만 인터넷에서 실행되는 코드와 일치하도록 MLS가 아닌 구현에서는 무시할 수 있습니다. 자세한 내용은 부록 A.1을 참조하세요. RFC 5570은 IPSO, CIPSO 또는 CALIPSO가 사용될 수 있는 일부 MLS 네트워킹 시나리오를 설명합니다. 이러한 특별한 경우에 TCP 구현자는 RFC 5570의 섹션 7.3.1을 참조하고 해당 문서의 지침을 따라야 합니다.

---
### **A.2.  Sequence Number Validation**

TCP 시퀀스 번호 유효성 검사 규칙으로 인해 ACK 필드가 처리되지 않는 경우가 있습니다. 이로 인해 동시 열기, 자체 연결, 동시 닫기 및 동시 창 프로브 조건에서 잠재적인 문제에 대한 설명이 포함된 \[64\]에 설명된 대로 연결 문제가 발생할 수 있습니다. 또한 이 문서에서는 허용 가능한 시퀀스 번호를 확장하여 문제를 완화하기 위한 TCP 사양의 잠재적인 변경 사항에 대해서도 설명합니다.

TCP를 인터넷에서 사용하는 경우 이러한 상황은 거의 발생하지 않습니다. 일반적인 운영 체제에는 다양한 대안 완화가 포함되어 있으며 표준은 아직 업데이트되어 그 중 하나를 성문화하지 않았지만 구현자는 \[64\]에 설명된 문제를 고려해야 합니다.

---
### **A.3.  Nagle Modification**

일반적인 운영 체제에서는 Nagle 알고리즘과 지연된 승인이 모두 기본적으로 구현되고 활성화됩니다. TCP는 요청-응답 스타일의 통신을 사용하는 많은 애플리케이션에서 사용됩니다. 여기서 Nagle 알고리즘과 지연된 승인의 조합으로 인해 애플리케이션 성능이 저하될 수 있습니다. 이러한 애플리케이션의 상황을 개선하는 Nagle 알고리즘 수정이 \[68\]에 설명되어 있습니다.

이 수정은 일부 일반적인 운영 체제에서 구현되며 TCP 상호 운용성에 영향을 주지 않습니다. 또한 일반적으로 소켓 옵션에 의해 지원되기 때문에 많은 응용 프로그램에서는 Nagle을 비활성화합니다. TCP 표준은 이 Nagle 수정 사항을 포함하도록 업데이트되지 않았지만 구현자는 이를 고려하는 것이 유익할 수 있습니다.

---
### **A.4.  Low Watermark Settings**

일부 운영 체제 커널 TCP 구현에는 소켓 계층이 전송된 데이터를 TCP\(SO\_SNDLOWAT\) 또는 수신 시 애플리케이션\(SO\_RCVLOWAT\)에 전달할 때까지 버퍼의 바이트 수를 지정할 수 있는 소켓 옵션이 포함되어 있습니다.

또한 다른 소켓 옵션\(TCP\_NOTSENT\_LOWAT\)을 사용하여 쓰기 대기열에서 전송되지 않은 바이트의 양을 제어할 수 있습니다. 이는 송신 TCP 애플리케이션이 대량의 버퍼링된 데이터\(및 해당 대기 시간\) 생성을 방지하는 데 도움이 될 수 있습니다. 예를 들어, 이는 여러 상위 수준 스트림의 데이터를 연결로 멀티플렉싱하는 애플리케이션에 유용할 수 있으며, 특히 스트림이 대화형/실시간 및 대량 데이터 전송이 혼합된 경우 더욱 그렇습니다.

---
# **Appendix B.  TCP Requirement Summary**

이 섹션은 RFC 1122에서 수정되었습니다.

이 목록에는 PLPMTUD와 관련된 요구 사항이 없지만 PLPMTUD가 권장됩니다.

```text
    +=================+=========+======+========+=====+========+======+
    |     Feature     |  ReqID  | MUST | SHOULD | MAY | SHOULD | MUST |
    |                 |         |      |        |     |  NOT   | NOT  |
    +=================+=========+======+========+=====+========+======+
    | PUSH flag                                                       |
    +=================+=========+======+========+=====+========+======+
    | Aggregate or    | MAY-16  |      |        |  X  |        |      |
    | queue un-pushed |         |      |        |     |        |      |
    | data            |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Sender collapse | SHLD-27 |      |   X    |     |        |      |
    | successive PSH  |         |      |        |     |        |      |
    | bits            |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | SEND call can   | MAY-15  |      |        |  X  |        |      |
    | specify PUSH    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  If cannot:   | MUST-60 |      |        |     |        |  X   |
    |    sender       |         |      |        |     |        |      |
    |    buffer       |         |      |        |     |        |      |
    |    indefinitely |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  If cannot:   | MUST-61 |  X   |        |     |        |      |
    |    PSH last     |         |      |        |     |        |      |
    |    segment      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Notify          | MAY-17  |      |        |  X  |        |      |
    | receiving ALP^1 |         |      |        |     |        |      |
    | of PSH          |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Send max size   | SHLD-28 |      |   X    |     |        |      |
    | segment when    |         |      |        |     |        |      |
    | possible        |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Window                                                          |
    +=================+=========+======+========+=====+========+======+
    | Treat as        | MUST-1  |  X   |        |     |        |      |
    | unsigned number |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Handle as       | REC-1   |      |   X    |     |        |      |
    | 32-bit number   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Shrink window   | SHLD-14 |      |        |     |   X    |      |
    | from right      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Send new     | SHLD-15 |      |        |     |   X    |      |
    |    data when    |         |      |        |     |        |      |
    |    window       |         |      |        |     |        |      |
    |    shrinks      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Retransmit   | SHLD-16 |      |   X    |     |        |      |
    |    old unacked  |         |      |        |     |        |      |
    |    data within  |         |      |        |     |        |      |
    |    window       |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Time out     | SHLD-17 |      |        |     |   X    |      |
    |    conn for     |         |      |        |     |        |      |
    |    data past    |         |      |        |     |        |      |
    |    right edge   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Robust against  | MUST-34 |  X   |        |     |        |      |
    | shrinking       |         |      |        |     |        |      |
    | window          |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Receiver's      | MAY-8   |      |        |  X  |        |      |
    | window closed   |         |      |        |     |        |      |
    | indefinitely    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Use standard    | MUST-35 |  X   |        |     |        |      |
    | probing logic   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Sender probe    | MUST-36 |  X   |        |     |        |      |
    | zero window     |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  First probe  | SHLD-29 |      |   X    |     |        |      |
    |    after RTO    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Exponential  | SHLD-30 |      |   X    |     |        |      |
    |    backoff      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Allow window    | MUST-37 |  X   |        |     |        |      |
    | stay zero       |         |      |        |     |        |      |
    | indefinitely    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Retransmit old  | MAY-7   |      |        |  X  |        |      |
    | data beyond     |         |      |        |     |        |      |
    | SND.UNA+SND.WND |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Process RST and | MUST-66 |  X   |        |     |        |      |
    | URG even with   |         |      |        |     |        |      |
    | zero window     |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Urgent Data                                                     |
    +=================+=========+======+========+=====+========+======+
    | Include support | MUST-30 |  X   |        |     |        |      |
    | for urgent      |         |      |        |     |        |      |
    | pointer         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Pointer         | MUST-62 |  X   |        |     |        |      |
    | indicates first |         |      |        |     |        |      |
    | non-urgent      |         |      |        |     |        |      |
    | octet           |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Arbitrary       | MUST-31 |  X   |        |     |        |      |
    | length urgent   |         |      |        |     |        |      |
    | data sequence   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Inform ALP^1    | MUST-32 |  X   |        |     |        |      |
    | asynchronously  |         |      |        |     |        |      |
    | of urgent data  |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | ALP^1 can learn | MUST-33 |  X   |        |     |        |      |
    | if/how much     |         |      |        |     |        |      |
    | urgent data Q'd |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | ALP employ the  | SHLD-13 |      |        |     |   X    |      |
    | urgent          |         |      |        |     |        |      |
    | mechanism       |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | TCP Options                                                     |
    +=================+=========+======+========+=====+========+======+
    | Support the     | MUST-4  |  X   |        |     |        |      |
    | mandatory       |         |      |        |     |        |      |
    | option set      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Receive TCP     | MUST-5  |  X   |        |     |        |      |
    | Option in any   |         |      |        |     |        |      |
    | segment         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Ignore          | MUST-6  |  X   |        |     |        |      |
    | unsupported     |         |      |        |     |        |      |
    | options         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Include length  | MUST-68 |  X   |        |     |        |      |
    | for all options |         |      |        |     |        |      |
    | except EOL+NOP  |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Cope with       | MUST-7  |  X   |        |     |        |      |
    | illegal option  |         |      |        |     |        |      |
    | length          |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Process options | MUST-64 |  X   |        |     |        |      |
    | regardless of   |         |      |        |     |        |      |
    | word alignment  |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Implement       | MUST-14 |  X   |        |     |        |      |
    | sending &       |         |      |        |     |        |      |
    | receiving MSS   |         |      |        |     |        |      |
    | Option          |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | IPv4 Send MSS   | SHLD-5  |      |   X    |     |        |      |
    | Option unless   |         |      |        |     |        |      |
    | 536             |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | IPv6 Send MSS   | SHLD-5  |      |   X    |     |        |      |
    | Option unless   |         |      |        |     |        |      |
    | 1220            |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Send MSS Option | MAY-3   |      |        |  X  |        |      |
    | always          |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | IPv4 Send-MSS   | MUST-15 |  X   |        |     |        |      |
    | default is 536  |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | IPv6 Send-MSS   | MUST-15 |  X   |        |     |        |      |
    | default is 1220 |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Calculate       | MUST-16 |  X   |        |     |        |      |
    | effective send  |         |      |        |     |        |      |
    | seg size        |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | MSS accounts    | SHLD-6  |      |   X    |     |        |      |
    | for varying MTU |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | MSS not sent on | MUST-65 |      |        |     |        |  X   |
    | non-SYN         |         |      |        |     |        |      |
    | segments        |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | MSS value based | MUST-67 |  X   |        |     |        |      |
    | on MMS_R        |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Pad with zero   | MUST-69 |  X   |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | TCP Checksums                                                   |
    +=================+=========+======+========+=====+========+======+
    | Sender compute  | MUST-2  |  X   |        |     |        |      |
    | checksum        |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Receiver check  | MUST-3  |  X   |        |     |        |      |
    | checksum        |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | ISN Selection                                                   |
    +=================+=========+======+========+=====+========+======+
    | Include a       | MUST-8  |  X   |        |     |        |      |
    | clock-driven    |         |      |        |     |        |      |
    | ISN generator   |         |      |        |     |        |      |
    | component       |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Secure ISN      | SHLD-1  |      |   X    |     |        |      |
    | generator with  |         |      |        |     |        |      |
    | a PRF component |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | PRF computable  | MUST-9  |      |        |     |        |  X   |
    | from outside    |         |      |        |     |        |      |
    | the host        |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Opening Connections                                             |
    +=================+=========+======+========+=====+========+======+
    | Support         | MUST-10 |  X   |        |     |        |      |
    | simultaneous    |         |      |        |     |        |      |
    | open attempts   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | SYN-RECEIVED    | MUST-11 |  X   |        |     |        |      |
    | remembers last  |         |      |        |     |        |      |
    | state           |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Passive OPEN    | MUST-41 |      |        |     |        |  X   |
    | call interfere  |         |      |        |     |        |      |
    | with others     |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Function:       | MUST-42 |  X   |        |     |        |      |
    | simultaneously  |         |      |        |     |        |      |
    | LISTENs for     |         |      |        |     |        |      |
    | same port       |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Ask IP for src  | MUST-44 |  X   |        |     |        |      |
    | address for SYN |         |      |        |     |        |      |
    | if necessary    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Otherwise,   | MUST-45 |  X   |        |     |        |      |
    |    use local    |         |      |        |     |        |      |
    |    addr of      |         |      |        |     |        |      |
    |    connection   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | OPEN to         | MUST-46 |      |        |     |        |  X   |
    | broadcast/      |         |      |        |     |        |      |
    | multicast IP    |         |      |        |     |        |      |
    | address         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Silently        | MUST-57 |  X   |        |     |        |      |
    | discard seg to  |         |      |        |     |        |      |
    | bcast/mcast     |         |      |        |     |        |      |
    | addr            |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Closing Connections                                             |
    +=================+=========+======+========+=====+========+======+
    | RST can contain | SHLD-2  |      |   X    |     |        |      |
    | data            |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Inform          | MUST-12 |  X   |        |     |        |      |
    | application of  |         |      |        |     |        |      |
    | aborted conn    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Half-duplex     | MAY-1   |      |        |  X  |        |      |
    | close           |         |      |        |     |        |      |
    | connections     |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Send RST to  | SHLD-3  |      |   X    |     |        |      |
    |    indicate     |         |      |        |     |        |      |
    |    data lost    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | In TIME-WAIT    | MUST-13 |  X   |        |     |        |      |
    | state for 2MSL  |         |      |        |     |        |      |
    | seconds         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Accept SYN   | MAY-2   |      |        |  X  |        |      |
    |    from TIME-   |         |      |        |     |        |      |
    |    WAIT state   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Use          | SHLD-4  |      |   X    |     |        |      |
    |    Timestamps   |         |      |        |     |        |      |
    |    to reduce    |         |      |        |     |        |      |
    |    TIME-WAIT    |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Retransmissions                                                 |
    +=================+=========+======+========+=====+========+======+
    | Implement       | MUST-19 |  X   |        |     |        |      |
    | exponential     |         |      |        |     |        |      |
    | backoff, slow   |         |      |        |     |        |      |
    | start, and      |         |      |        |     |        |      |
    | congestion      |         |      |        |     |        |      |
    | avoidance       |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Retransmit with | MAY-4   |      |        |  X  |        |      |
    | same IP         |         |      |        |     |        |      |
    | identity        |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Karn's          | MUST-18 |  X   |        |     |        |      |
    | algorithm       |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Generating ACKs                                                 |
    +=================+=========+======+========+=====+========+======+
    | Aggregate       | MUST-58 |  X   |        |     |        |      |
    | whenever        |         |      |        |     |        |      |
    | possible        |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Queue out-of-   | SHLD-31 |      |   X    |     |        |      |
    | order segments  |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Process all Q'd | MUST-59 |  X   |        |     |        |      |
    | before send ACK |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Send ACK for    | MAY-13  |      |        |  X  |        |      |
    | out-of-order    |         |      |        |     |        |      |
    | segment         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Delayed ACKs    | SHLD-18 |      |   X    |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Delay < 0.5  | MUST-40 |  X   |        |     |        |      |
    |    seconds      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Every 2nd    | SHLD-19 |      |   X    |     |        |      |
    |    full-sized   |         |      |        |     |        |      |
    |    segment or   |         |      |        |     |        |      |
    |    2*RMSS ACK'd |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Receiver SWS-   | MUST-39 |  X   |        |     |        |      |
    | Avoidance       |         |      |        |     |        |      |
    | Algorithm       |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Sending Data                                                    |
    +=================+=========+======+========+=====+========+======+
    | Configurable    | MUST-49 |  X   |        |     |        |      |
    | TTL             |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Sender SWS-     | MUST-38 |  X   |        |     |        |      |
    | Avoidance       |         |      |        |     |        |      |
    | Algorithm       |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Nagle algorithm | SHLD-7  |      |   X    |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Application  | MUST-17 |  X   |        |     |        |      |
    |    can disable  |         |      |        |     |        |      |
    |    Nagle        |         |      |        |     |        |      |
    |    algorithm    |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Connection Failures                                             |
    +=================+=========+======+========+=====+========+======+
    | Negative advice | MUST-20 |  X   |        |     |        |      |
    | to IP on R1     |         |      |        |     |        |      |
    | retransmissions |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Close           | MUST-20 |  X   |        |     |        |      |
    | connection on   |         |      |        |     |        |      |
    | R2              |         |      |        |     |        |      |
    | retransmissions |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | ALP^1 can set   | MUST-21 |  X   |        |     |        |      |
    | R2              |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Inform ALP of   | SHLD-9  |      |   X    |     |        |      |
    | R1<=retxs<R2    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Recommended     | SHLD-10 |      |   X    |     |        |      |
    | value for R1    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Recommended     | SHLD-11 |      |   X    |     |        |      |
    | value for R2    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Same mechanism  | MUST-22 |  X   |        |     |        |      |
    | for SYNs        |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  R2 at least  | MUST-23 |  X   |        |     |        |      |
    |    3 minutes    |         |      |        |     |        |      |
    |    for SYN      |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Send Keep-alive Packets                                         |
    +=================+=========+======+========+=====+========+======+
    | Send Keep-alive | MAY-5   |      |   X    |     |        |      |
    | Packets:        |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Application  | MUST-24 |  X   |        |     |        |      |
    |    can request  |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Default is   | MUST-25 |  X   |        |     |        |      |
    |    "off"        |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Only send if | MUST-26 |  X   |        |     |        |      |
    |    idle for     |         |      |        |     |        |      |
    |    interval     |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Interval     | MUST-27 |  X   |        |     |        |      |
    |    configurable |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Default at   | MUST-28 |  X   |        |     |        |      |
    |    least 2 hrs. |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Tolerant of  | MUST-29 |  X   |        |     |        |      |
    |    lost ACKs    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Send with no | SHLD-12 |      |   X    |     |        |      |
    |    data         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Configurable | MAY-6   |      |        |  X  |        |      |
    |    to send      |         |      |        |     |        |      |
    |    garbage      |         |      |        |     |        |      |
    |    octet        |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | IP Options                                                      |
    +=================+=========+======+========+=====+========+======+
    | Ignore options  | MUST-50 |  X   |        |     |        |      |
    | TCP doesn't     |         |      |        |     |        |      |
    | understand      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Timestamp       | MAY-10  |      |   X    |     |        |      |
    | support         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Record Route    | MAY-11  |      |   X    |     |        |      |
    | support         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Source Route:   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  ALP^1 can    | MUST-51 |  X   |        |     |        |      |
    |    specify      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *     Overrides | MUST-52 |  X   |        |     |        |      |
    |       src route |         |      |        |     |        |      |
    |       in        |         |      |        |     |        |      |
    |       datagram  |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Build return | MUST-53 |  X   |        |     |        |      |
    |    route from   |         |      |        |     |        |      |
    |    src route    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Later src    | SHLD-24 |      |   X    |     |        |      |
    |    route        |         |      |        |     |        |      |
    |    overrides    |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Receiving ICMP Messages from IP                                 |
    +=================+=========+======+========+=====+========+======+
    | Receiving ICMP  | MUST-54 |  X   |        |     |        |      |
    | messages from   |         |      |        |     |        |      |
    | IP              |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Dest Unreach | SHLD-25 |  X   |        |     |        |      |
    |    (0,1,5) =>   |         |      |        |     |        |      |
    |    inform ALP   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Abort on     | MUST-56 |      |        |     |        |  X   |
    |    Dest Unreach |         |      |        |     |        |      |
    |    (0,1,5)      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Dest Unreach | SHLD-26 |      |   X    |     |        |      |
    |    (2-4) =>     |         |      |        |     |        |      |
    |    abort conn   |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Source       | MUST-55 |  X   |        |     |        |      |
    |    Quench =>    |         |      |        |     |        |      |
    |    silent       |         |      |        |     |        |      |
    |    discard      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Abort on     | MUST-56 |      |        |     |        |  X   |
    |    Time         |         |      |        |     |        |      |
    |    Exceeded     |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Abort on     | MUST-56 |      |        |     |        |  X   |
    |    Param        |         |      |        |     |        |      |
    |    Problem      |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Address Validation                                              |
    +=================+=========+======+========+=====+========+======+
    | Reject OPEN     | MUST-46 |  X   |        |     |        |      |
    | call to invalid |         |      |        |     |        |      |
    | IP address      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Reject SYN from | MUST-63 |  X   |        |     |        |      |
    | invalid IP      |         |      |        |     |        |      |
    | address         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Silently        | MUST-57 |  X   |        |     |        |      |
    | discard SYN to  |         |      |        |     |        |      |
    | bcast/mcast     |         |      |        |     |        |      |
    | addr            |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | TCP/ALP Interface Services                                      |
    +=================+=========+======+========+=====+========+======+
    | Error Report    | MUST-47 |  X   |        |     |        |      |
    | mechanism       |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | ALP can disable | SHLD-20 |      |   X    |     |        |      |
    | Error Report    |         |      |        |     |        |      |
    | Routine         |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | ALP can specify | MUST-48 |  X   |        |     |        |      |
    | Diffserv field  |         |      |        |     |        |      |
    | for sending     |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | *  Passed       | SHLD-22 |      |   X    |     |        |      |
    |    unchanged to |         |      |        |     |        |      |
    |    IP           |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | ALP can change  | SHLD-21 |      |   X    |     |        |      |
    | Diffserv field  |         |      |        |     |        |      |
    | during          |         |      |        |     |        |      |
    | connection      |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | ALP generally   | SHLD-23 |      |        |     |   X    |      |
    | changing        |         |      |        |     |        |      |
    | Diffserv during |         |      |        |     |        |      |
    | conn.           |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Pass received   | MAY-9   |      |        |  X  |        |      |
    | Diffserv field  |         |      |        |     |        |      |
    | up to ALP       |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | FLUSH call      | MAY-14  |      |        |  X  |        |      |
    +-----------------+---------+------+--------+-----+--------+------+
    | Optional local  | MUST-43 |  X   |        |     |        |      |
    | IP addr param   |         |      |        |     |        |      |
    | in OPEN         |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | RFC 5961 Support                                                |
    +=================+=========+======+========+=====+========+======+
    | Implement data  | MAY-12  |      |        |  X  |        |      |
    | injection       |         |      |        |     |        |      |
    | protection      |         |      |        |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Explicit Congestion Notification                                |
    +=================+=========+======+========+=====+========+======+
    | Support ECN     | SHLD-8  |      |   X    |     |        |      |
    +=================+=========+======+========+=====+========+======+
    | Alternative Congestion Control                                  |
    +=================+=========+======+========+=====+========+======+
    | Implement       | MAY-18  |      |        |  X  |        |      |
    | alternative     |         |      |        |     |        |      |
    | conformant      |         |      |        |     |        |      |
    | algorithm(s)    |         |      |        |     |        |      |
    +-----------------+---------+------+--------+-----+--------+------+

                     Table 8: TCP Requirements Summary

   FOOTNOTES: (1) "ALP" means Application-Layer Program.
```

---
# **Acknowledgments**

이 문서는 Jon Postel이 편집한 RFC 793의 개정판입니다. 그의 훌륭한 작업 덕분에 우리는 개정의 필요성을 느끼기 전까지 30년 동안 지속될 수 있었습니다.

Andre Oppermann은 기고자였으며 이 문서의 첫 번째 개정판을 편집하는 데 도움을 주었습니다.

이 문서 작업 과정에서 IETF TCPM 작업 그룹 의장의 도움에 감사드립니다.

```text
   Michael Scharf

   Yoshifumi Nishida

   Pasi Sarolahti

   Michael Tüxen
```

TCPM 메일링 리스트, 작업 그룹 회의 및 지역 검토를 통해 이 작업에 대한 논의가 진행되는 동안 Praveen Balasubramanian, David Borman, Mohamed Boucadair, Bob으로부터 유용한 의견, 비평 및 리뷰를 받았습니다\(성의 알파벳순으로 나열\). Briscoe, Neal Cardwell, Yuchung Cheng, Martin Duke, Francis Dupont, Ted Faber, Gorry Fairhurst, Fernando Gont, Rodney Grimes, Yi Huang, Rahul Jadhav, Markku Kojo, Mike Kosek, Juhamatti Kuusisaari, Kevin Lahey, Kevin Mason, Matt Mathis, Stephen McQuistin, Jonathan Morton, Matt Olson, Tommy Pauly, Tom Petch, Hagen Paul Pfeifer, Kyle Rose, Anthony Sabatini, Michael Scharf, Greg Skinner, Joe Touch, Michael Tüxen, Reji Varghese, Bernie Volz, Tim Wicinski, Lloyd Wood 및 알렉스 짐머만.

Joe Touch는 세그먼트 크기 매개변수 및 PMTUD/PLPMTUD 권장 사항에 대한 설명을 명확하게 하는 데 추가 도움을 제공했습니다. Markku Kojo는 TCP 혼잡 제어 섹션의 텍스트를 정리하는 데 도움을 주었습니다.

이 문서에는 Yin Shuming, Bob Braden, Morris M. Keesan, Pei-chun Cheng, Constantin Hagemeier, Vishwas Manral, Mykyta Yevstifeyev, EungJun Yi, Botong Huang, Charles Deng, Merlin이 보고한 정오표의 내용이 포함되어 있습니다. 버그.

---
# **Author's Address**

Wesley M. Eddy\(편집자\) MTI Systems 미국 이메일: wes@mti-systems.com
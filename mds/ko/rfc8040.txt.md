

```text
Internet Engineering Task Force (IETF)                        A. Bierman
Request for Comments: 8040                                     YumaWorks
Category: Standards Track                                   M. Bjorklund
ISSN: 2070-1721                                           Tail-f Systems
                                                               K. Watsen
                                                        Juniper Networks
                                                            January 2017

                           RESTCONF Protocol
```

---
# **Abstract**

이 문서에서는 NETCONF\(Network Configuration Protocol\)에 정의된 데이터 저장소 개념을 사용하여 YANG에 정의된 데이터에 액세스하기 위한 프로그래밍 인터페이스를 제공하는 HTTP 기반 프로토콜에 대해 설명합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc8040에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2017 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................5
      1.1. Terminology ................................................5
           1.1.1. NETCONF .............................................6
           1.1.2. HTTP ................................................6
           1.1.3. YANG ................................................7
           1.1.4. NETCONF Notifications ...............................7
           1.1.5. Terms ...............................................8
           1.1.6. URI Template and Examples ..........................10
           1.1.7. Tree Diagrams ......................................11
      1.2. Subset of NETCONF Functionality ...........................11
      1.3. Data-Model-Driven API .....................................12
      1.4. Coexistence with NETCONF ..................................13
      1.5. RESTCONF Extensibility ....................................14
   2. Transport Protocol .............................................15
      2.1. Integrity and Confidentiality .............................15
      2.2. HTTPS with X.509v3 Certificates ...........................16
      2.3. Certificate Validation ....................................16
      2.4. Authenticated Server Identity .............................16
      2.5. Authenticated Client Identity .............................16
   3. Resources ......................................................17
      3.1. Root Resource Discovery ...................................18
      3.2. RESTCONF Media Types ......................................20
      3.3. API Resource ..............................................20
           3.3.1. {+restconf}/data ...................................21
           3.3.2. {+restconf}/operations .............................22
           3.3.3. {+restconf}/yang-library-version ...................22
      3.4. Datastore Resource ........................................23
           3.4.1. Edit Collision Prevention ..........................23
      3.5. Data Resource .............................................24
           3.5.1. Timestamp ..........................................25
           3.5.2. Entity-Tag .........................................25
           3.5.3. Encoding Data Resource Identifiers in the
                  Request URI ........................................26
           3.5.4. Default Handling ...................................29
      3.6. Operation Resource ........................................30
           3.6.1. Encoding Operation Resource Input Parameters .......31
           3.6.2. Encoding Operation Resource Output Parameters ......36
           3.6.3. Encoding Operation Resource Errors .................38
      3.7. Schema Resource ...........................................40
      3.8. Event Stream Resource .....................................41
      3.9. "errors" YANG Data Template ...............................41
   4. RESTCONF Methods ...............................................42
      4.1. OPTIONS ...................................................43
      4.2. HEAD ......................................................43
      4.3. GET .......................................................43
      4.4. POST ......................................................45
           4.4.1. Create Resource Mode ...............................45
           4.4.2. Invoke Operation Mode ..............................47
      4.5. PUT .......................................................48
      4.6. PATCH .....................................................50
           4.6.1. Plain Patch ........................................50
      4.7. DELETE ....................................................51
      4.8. Query Parameters ..........................................52
           4.8.1. The "content" Query Parameter ......................54
           4.8.2. The "depth" Query Parameter ........................54
           4.8.3. The "fields" Query Parameter .......................55
           4.8.4. The "filter" Query Parameter .......................56
           4.8.5. The "insert" Query Parameter .......................57
           4.8.6. The "point" Query Parameter ........................57
           4.8.7. The "start-time" Query Parameter ...................58
           4.8.8. The "stop-time" Query Parameter ....................58
           4.8.9. The "with-defaults" Query Parameter ................59
   5. Messages .......................................................60
      5.1. Request URI Structure .....................................61
      5.2. Message Encoding ..........................................62
      5.3. RESTCONF Metadata .........................................63
           5.3.1. XML Metadata Encoding Example ......................64
           5.3.2. JSON Metadata Encoding Example .....................65
      5.4. Return Status .............................................65
      5.5. Message Caching ...........................................66
   6. Notifications ..................................................66
      6.1. Server Support ............................................66
      6.2. Event Streams .............................................67
      6.3. Subscribing to Receive Notifications ......................68
           6.3.1. NETCONF Event Stream ...............................70
      6.4. Receiving Event Notifications .............................70
   7. Error Reporting ................................................73
      7.1. Error Response Message ....................................75
   8. RESTCONF Module ................................................79
   9. RESTCONF Monitoring ............................................85
      9.1. restconf-state/capabilities ...............................86
           9.1.1. Query Parameter URIs ...............................87
           9.1.2. The "defaults" Protocol Capability URI .............87
      9.2. restconf-state/streams ....................................88
      9.3. RESTCONF Monitoring Module ................................89
   10. YANG Module Library ...........................................93
      10.1. modules-state/module .....................................93
   11. IANA Considerations ...........................................94
      11.1. The "restconf" Relation Type .............................94
      11.2. Registrations for New URIs and YANG Modules ..............94
      11.3. Media Types ..............................................95
           11.3.1. Media Type "application/yang-data+xml" ............95
           11.3.2. Media Type "application/yang-data+json" ...........96
      11.4. RESTCONF Capability URNs .................................97
      11.5. Registration of "restconf" URN Sub-namespace .............98
   12. Security Considerations .......................................99
   13. References ...................................................100
      13.1. Normative References ....................................100
      13.2. Informative References ..................................104
   Appendix A. Example YANG Module ..................................105
     A.1. "example-jukebox" YANG Module .............................106
   Appendix B. RESTCONF Message Examples ............................112
     B.1. Resource Retrieval Examples ...............................112
       B.1.1. Retrieve the Top-Level API Resource ...................112
       B.1.2. Retrieve the Server Module Information ................114
       B.1.3. Retrieve the Server Capability Information ............117
     B.2. Data Resource and Datastore Resource Examples .............118
       B.2.1. Create New Data Resources .............................118
       B.2.2. Detect Datastore Resource Entity-Tag Change ...........119
       B.2.3. Edit a Datastore Resource .............................121
       B.2.4. Replace a Datastore Resource ..........................122
       B.2.5. Edit a Data Resource ..................................122
     B.3. Query Parameter Examples ..................................123
       B.3.1. "content" Parameter ...................................123
       B.3.2. "depth" Parameter .....................................126
       B.3.3. "fields" Parameter ....................................130
       B.3.4. "insert" Parameter ....................................132
       B.3.5. "point" Parameter .....................................133
       B.3.6. "filter" Parameter ....................................134
       B.3.7. "start-time" Parameter ................................134
       B.3.8. "stop-time" Parameter .................................135
       B.3.9. "with-defaults" Parameter .............................135
   Acknowledgements .................................................137
   Authors' Addresses ...............................................137
```

---
## **1.  Introduction**

웹 애플리케이션이 구성 데이터, 상태 데이터, 데이터 모델별 원격 프로시저 호출\(RPC\) 작업 및 네트워킹 장치 내의 이벤트 알림에 모듈식 및 확장 가능한 방식으로 액세스할 수 있도록 하는 표준 메커니즘이 필요합니다.

이 문서는 네트워크 구성 프로토콜\(NETCONF\) \[RFC6241\]에 정의된 데이터 저장소 개념을 사용하여 YANG 버전 1 \[RFC6020\] 또는 YANG 버전 1.1 \[RFC7950\]에 정의된 데이터를 구성하기 위해 "RESTCONF"라는 HTTP \[RFC7230\] 기반 프로토콜을 정의합니다. \].

NETCONF는 구성 데이터 저장소와 이러한 데이터 저장소에 액세스하는 데 사용할 수 있는 CRUD\(생성, 읽기, 업데이트, 삭제\) 작업 집합을 정의합니다. NETCONF는 이러한 작업을 호출하기 위한 프로토콜도 정의합니다. YANG 언어는 데이터 저장소 콘텐츠, 구성, 상태 데이터, RPC 작업 및 이벤트 알림의 구문과 의미를 정의합니다.

RESTCONF는 HTTP 메서드를 사용하여 NETCONF 데이터 저장소를 구현하는 서버와 호환되는 YANG 정의 데이터가 포함된 개념적 데이터 저장소에 대한 CRUD 작업을 제공합니다.

RESTCONF 서버가 NETCONF 서버와 같은 위치에 있으면 NETCONF 프로토콜과 프로토콜 상호 작용이 있습니다. 이러한 상호 작용은 섹션 1.4에 설명되어 있습니다. RESTCONF 서버는 섹션 3.6에 설명된 대로 작업 리소스를 사용하여 특정 데이터 저장소에 대한 액세스를 제공할 수 있습니다. RESTCONF 프로토콜은 필수 작업 리소스를 지정하지 않습니다. 각 작업 리소스의 의미에 따라 데이터 저장소에 액세스할지 여부와 액세스 방법이 결정됩니다.\(MAY\)

구성 데이터와 상태 데이터는 GET 메서드를 사용하여 검색할 수 있는 리소스로 노출됩니다. 구성 데이터를 나타내는 리소스는 DELETE, PATCH, POST 및 PUT 메서드를 사용하여 수정할 수 있습니다. 데이터는 XML \[W3C.REC-xml-20081126\] 또는 JSON \[RFC7159\]로 인코딩됩니다.

YANG "rpc" 또는 "action" 문으로 정의된 데이터 모델별 RPC 작업은 POST 메서드를 통해 호출할 수 있습니다. YANG "알림" 문으로 정의된 데이터 모델별 이벤트 알림에 액세스할 수 있습니다.

---
### **1.1.  Terminology**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
#### **1.1.1.  NETCONF**

다음 용어는 \[RFC6241\]에 정의되어 있습니다.

```text
   o  candidate configuration datastore

   o  configuration data

   o  datastore

   o  configuration datastore

   o  running configuration datastore

   o  startup configuration datastore

   o  state data

   o  user
```

---
#### **1.1.2.  HTTP**

다음 용어는 \[RFC3986\]에 정의되어 있습니다.

```text
   o  fragment

   o  path

   o  query
```

다음 용어는 \[RFC7230\]에 정의되어 있습니다.

```text
   o  header field

   o  message-body

   o  request-line

   o  request URI

   o  status-line
```

다음 용어는 \[RFC7231\]에 정의되어 있습니다.

```text
   o  method

   o  request

   o  resource
```

다음 용어는 \[RFC7232\]에 정의되어 있습니다.

```text
   o  entity-tag
```

---
#### **1.1.3.  YANG**

다음 용어는 \[RFC7950\]에 정의되어 있습니다.

```text
   o  action

   o  container

   o  data node

   o  key leaf

   o  leaf

   o  leaf-list

   o  list

   o  mandatory node

   o  ordered-by user

   o  presence container

   o  RPC operation

   o  top-level data node
```

---
#### **1.1.4.  NETCONF Notifications**

다음 용어는 \[RFC5277\]에 정의되어 있습니다.

```text
   o  notification replay
```

---
#### **1.1.5.  Terms**

이 문서에서는 다음 용어가 사용됩니다.

o API 리소스: YANG 정의 콘텐츠에 액세스하기 위해 RESTCONF 루트 리소스와 하위 리소스를 모델링하는 리소스입니다. 이는 "ietf-restconf" 모듈에서 "yang-api"라는 YANG 데이터 템플릿으로 정의됩니다.

o 클라이언트: RESTCONF 클라이언트.

o 데이터 리소스: YANG 데이터 노드를 모델링하는 리소스. YANG 데이터 정의문으로 정의됩니다.

o 데이터 저장소 리소스: NETCONF 데이터 저장소 개념을 사용하여 프로그래밍 인터페이스를 모델링하는 리소스입니다. 기본적으로 RESTCONF 메소드는 서버의 기본 데이터 저장소 구현에 대한 통합 보기에 액세스합니다. API 리소스 내의 하위 리소스로 정의됩니다.

o 편집 작업: POST, PUT, PATCH 또는 DELETE 메서드를 사용하는 데이터 리소스에 대한 RESTCONF 작업입니다. 이는 NETCONF 편집 작업\(예: "nc:작업" 속성 값 중 하나: "만들기", "교체", "병합", "삭제" 또는 "제거"\)과 동일하지 않습니다.

o 이벤트 스트림 자원: SSE를 나타내는 자원

- \(서버에서 보낸 이벤트\) 이벤트 스트림. 콘텐츠는 SSE 사양 \[W3C.REC-eventsource-20150203\]에 정의된 대로 미디어 유형 "text/event-stream"을 사용하는 텍스트로 구성됩니다. 이벤트 스트림 내용은 섹션 3.8에 설명되어 있습니다.

o 미디어 유형: HTTP는 개방적이고 확장 가능한 데이터 유형 지정 및 유형 협상을 제공하기 위해 "Content-Type" 및 "Accept" 헤더 필드에 인터넷 미디어 유형 \[RFC2046\]을 사용합니다.

o NETCONF 클라이언트: NETCONF 프로토콜을 구현하는 클라이언트. \[RFC6241\]에서는 "클라이언트"라고 합니다.

o NETCONF 서버: NETCONF 프로토콜을 구현하는 서버. \[RFC6241\]에서는 "서버"라고 합니다.

o 작업: HTTP 메서드, 요청 URI, 헤더 필드 및 메시지 본문에서 파생된 메시지에 대한 개념적 RESTCONF 작업입니다.

o 작업 리소스: YANG "rpc" 또는 "action" 문으로 정의되는 데이터 모델별 작업을 모델링하는 리소스입니다. POST 메소드로 호출됩니다.

o 패치: 대상 데이터 저장소 또는 데이터 리소스에 대한 PATCH 방법입니다. 메시지 본문 내용의 미디어 유형은 사용 중인 패치 유형을 식별합니다.

o 일반 패치: PATCH 방법과 함께 사용하기 위한 특정 미디어 유형입니다. 섹션 4.6.1을 참조하세요. 간단한 "병합" 편집 작업에 사용할 수 있습니다. 이는 "application/yang-data+xml" 또는 "application/yang-data+json"의 요청 Content-Type으로 지정됩니다.

o 쿼리 매개변수: 요청 URI의 쿼리 구성요소 내에 인코딩된 매개변수\(및 해당 값\)입니다.

o 자원 유형: 이 문서에 정의된 RESTCONF 자원 클래스 중 하나입니다. "api", "datastore", "data", "작업", "스키마" 또는 "이벤트 스트림" 중 하나입니다.

o RESTCONF 기능: 특정 서버에서 해당 기능이 지원되는 경우 해당 서버에서 광고하는 선택적 RESTCONF 프로토콜 기능입니다. 이 기능은 IANA에 등록된 NETCONF 기능 URI로 식별되며 섹션 9.3에 정의된 "기능" 리프 목록의 항목으로 광고됩니다.

o RESTCONF 클라이언트: RESTCONF 프로토콜을 구현하는 클라이언트입니다.

o RESTCONF 서버: RESTCONF 프로토콜을 구현하는 서버입니다.

o 검색 요청: GET 또는 HEAD 메소드를 사용하는 요청입니다.

o 스키마 리소스: 클라이언트가 GET 메서드를 사용하여 YANG 스키마를 검색하는 데 사용하는 리소스입니다. 미디어 유형이 "application/yang"인 표현이 있습니다.

o 서버: RESTCONF 서버.

o "스트림" 목록: 서버에서 사용할 수 있는 이벤트 스트림 리소스를 설명하는 데이터 리소스 인스턴스 집합입니다. 이 정보는 "ietf-restconf-monitoring" 모듈에서 "스트림" 목록으로 정의됩니다. 대상 리소스 "{+restconf}/data/ietf-restconf-monitoring:restconf-state/streams/ stream"을 사용하여 검색할 수 있습니다. "스트림" 목록에는 이벤트 스트림 데이터를 검색하기 위한 URL과 같은 각 스트림에 대한 정보가 포함되어 있습니다.

o 스트림 자원: 이벤트 스트림 자원.

o 대상 자원: 요청 URI의 "경로" 구성요소로 식별되는 특정 메시지와 연관된 자원입니다.

o yang-data 확장: 섹션 8에 있는 "yang-data" 확장 문을 따르는 YANG 외부 문입니다. yang-data 확장은 YANG 데이터 템플릿으로 사용되는 YANG 데이터 구조를 정의하는 데 사용됩니다. 이러한 데이터 구조는 구성 데이터 저장소의 일부로 또는 서버 내 작동 상태로 구현되지 않으므로 일반 YANG 데이터 정의 문을 사용할 수 없습니다.

o YANG 데이터 템플릿: YANG을 사용하여 프로토콜 메시지 구성 요소를 개념적 데이터 구조로 모델링하기 위한 스키마입니다. 이를 통해 메시지를 인코딩 독립적인 방식으로 정의할 수 있습니다. 각 YANG 데이터 템플릿은 섹션 8에 있는 "yang-data" 확장자로 정의됩니다. 특정 YANG 데이터 템플릿을 준수하는 인스턴스의 표현은 YANG에 대해 정의될 수 있습니다. XML 표현은 YANG 버전 1.1 \[RFC7950\]에 정의되어 있으며 "application/yang-data+xml" 미디어 유형으로 지원됩니다. JSON 표현은 "YANG으로 모델링된 데이터의 JSON 인코딩" \[RFC7951\]에 정의되어 있으며 "application/yang-data+json" 미디어 유형으로 지원됩니다.

---
#### **1.1.6.  URI Template and Examples**

이 문서 전체에서 URI 템플릿 \[RFC6570\] 구문 "{+restconf}"는 예제 외부에서 RESTCONF 루트 리소스를 참조하는 데 사용됩니다. 자세한 내용은 섹션 3.1을 참조하세요.

단순화를 위해 이 문서의 모든 예제에서는 검색된 RESTCONF API 루트 경로로 "/restconf"를 사용합니다. 문서 전체의 많은 예제는 부록 A.1에 정의된 "example-jukebox" YANG 모듈을 기반으로 합니다.

문서 전반에 걸쳐 예제에 포함된 많은 프로토콜 헤더 줄과 메시지 본문 텍스트는 표시 목적으로만 여러 줄로 분할됩니다. 행이 마지막 문자로 백슬래시\("\"\)로 끝나는 경우 해당 행은 표시 목적으로 줄바꿈됩니다. 백슬래시, 다음 줄 바꿈, 다음 줄의 선행 공백을 삭제하면 다음 줄에 합류하는 것으로 간주됩니다.

---
#### **1.1.7.  Tree Diagrams**

이 문서에서는 데이터 모델의 단순화된 그래픽 표현이 사용됩니다. 이 다이어그램에 있는 기호의 의미는 다음과 같습니다.

o 대괄호 "\[" 및 "\]"는 목록 키를 묶습니다.

o 데이터 노드 이름 앞의 약어: "rw"는 구성 데이터\(읽기-쓰기\)를 의미하고, "ro"는 상태 데이터\(읽기 전용\)를 의미하며, "x"는 작업 리소스\(실행 가능\)를 의미합니다.

o 데이터 노드 이름 뒤의 기호: "?" 선택적 노드 "!"를 의미합니다. 현재 상태 컨테이너를 의미하고 "\*"는 목록과 리프 목록을 나타냅니다.

o 선택 노드와 사례 노드를 괄호로 묶고 사례 노드에도 콜론\(":"\)을 표시합니다.

o 줄임표\("..."\)는 표시되지 않는 하위 트리의 내용을 나타냅니다.

---
### **1.2.  Subset of NETCONF Functionality**

RESTCONF는 NETCONF 프로토콜의 전체 기능을 미러링할 필요는 없지만 NETCONF와 호환되어야 합니다. RESTCONF는 NETCONF 프로토콜에서 제공하는 상호 작용 기능의 하위 집합을 구현하여 이를 달성합니다. 예를 들어 데이터 저장소 및 명시적 잠금을 제거합니다.

RESTCONF는 HTTP 메서드를 사용하여 NETCONF 작업과 동등한 작업을 구현하여 개념적 리소스 계층 구조에서 기본 CRUD 작업을 활성화합니다.

HTTP POST, PUT, PATCH 및 DELETE 메소드는 YANG 데이터 모델이 나타내는 데이터 자원을 편집하는 데 사용됩니다. 이러한 기본 편집 작업을 통해 실행 중인 구성을 RESTCONF 클라이언트로 변경할 수 있습니다.

RESTCONF는 NETCONF를 대체하기 위한 것이 아니라 REST\(Representational State Transfer\) 원칙\[REST-논문\]을 따르고 NETCONF 데이터 저장소 모델과 호환되는 HTTP 인터페이스를 제공하기 위한 것입니다.

---
### **1.3.  Data-Model-Driven API**

RESTCONF는 HTTP의 단순성과 스키마 기반 API의 예측 가능성 및 자동화 잠재력을 결합합니다. 서버에서 사용하는 YANG 모듈을 알면 클라이언트는 모든 관리 리소스 URL과 모든 RESTCONF 요청 및 응답의 적절한 구조를 파생할 수 있습니다. 이 전략은 원래 Roy Fielding의 박사 논문 \[REST-Dissertation\]에 설명된 HATEOAS\(응용 프로그램 상태 엔진\) 링크로 하이퍼미디어를 포함하기 위해 서버가 제공하는 응답의 필요성을 제거합니다. 왜냐하면 클라이언트가 YANG에서 필요한 링크를 결정할 수 있기 때문입니다. 모듈.

RESTCONF는 YANG 라이브러리 \[RFC7895\]를 활용하여 클라이언트가 이를 사용하려는 경우 서버에 대한 YANG 모듈 적합성 정보를 검색할 수 있도록 합니다.

서버는 YANG 라이브러리에서 식별된 대로 사용하는 YANG 모듈의 검색을 선택적으로 지원할 수 있습니다. 자세한 내용은 섹션 3.7을 참조하세요.

데이터 모델별 RPC 작업 및 데이터 저장소 콘텐츠에 대한 URI는 YANG 모듈 정의를 기반으로 예측 가능합니다.

RESTCONF 프로토콜은 YANG 데이터 모델링 언어로 정의된 개념적 데이터 저장소에서 작동합니다. 서버는 \[RFC7895\]에 정의된 "ietf-yang-library" YANG 모듈을 사용하여 지원하는 각 YANG 모듈을 나열합니다. 서버는 "modules-state/module" 목록에서 서버가 사용하는 모든 YANG 모듈을 식별해야 하는 "ietf-yang-library" 모듈을 구현해야 합니다. 개념적 데이터 저장소 콘텐츠, 데이터 모델별 RPC 작업 및 이벤트 알림은 이 YANG 모듈 세트로 식별됩니다.\(MUST\)

구성 데이터 또는 비구성 데이터로 데이터를 분류하는 것은 YANG "config" 문에서 파생됩니다. 데이터 순서와 관련된 동작은 YANG "ordered-by" 문에서 파생됩니다. 비구성 데이터는 "상태 데이터"라고도 합니다.

RESTCONF 데이터 저장소 편집 모델은 NETCONF의 :writable-running 기능의 동작과 유사하게 간단하고 직접적입니다. 데이터 저장소 리소스 내 데이터 리소스의 각 RESTCONF 편집은 편집이 성공적으로 완료되면 활성화됩니다.

---
### **1.4.  Coexistence with NETCONF**

RESTCONF는 NETCONF 프로토콜을 지원하는 장치에서 구현될 수 있습니다.

다음 그림은 RESTCONF 서버가 NETCONF 서버와 같은 위치에 있는 경우 시스템 구성 요소를 보여줍니다.

```text
         +-----------+           +-----------------+
         |  Web app  | <-------> |                 |
         +-----------+  RESTCONF | network device  |
                                 |                 |
         +-----------+           |   +-----------+ |
         | NETCONF   | <-------> |   | datastore | |
         | Client    |  NETCONF  |   |           | |
         +-----------+           |   +-----------+ |
                                 +-----------------+
```

다음 그림은 NETCONF 서버가 없는 장치에 RESTCONF 서버가 구현된 경우 시스템 구성 요소를 보여줍니다.

```text
         +-----------+           +-----------------+
         |  Web app  | <-------> |                 |
         +-----------+  RESTCONF | network device  |
                                 |                 |
                                 +-----------------+
```

편집 작업과 관련된 NETCONF 프로토콜과 RESTCONF 프로토콜 간에 상호 작용이 있습니다. RESTCONF가 잠금을 조작할 수 없더라도 RESTCONF 서버에서 잠금이 사용 중일 수 있습니다. 이러한 경우 RESTCONF 프로토콜에는 데이터 저장소 내의 데이터 리소스에 대한 쓰기 액세스 권한이 부여되지 않습니다.

NETCONF 서버가 :writable-running을 지원하는 경우 {+restconf}/data의 구성 노드에 대한 모든 편집은 실행 중인 구성 데이터 저장소에서 수행됩니다. URI 템플릿 "{+restconf}"는 섹션 1.1.6에 정의되어 있습니다.

그렇지 않고 장치가 :candidate를 지원하는 경우 {+restconf}/data의 구성 노드에 대한 모든 편집은 후보 구성 데이터 저장소에서 수행됩니다. 후보자는 각 편집이 성공한 후 즉시 자동으로 실행되도록 커밋되어야 합니다. 후보 데이터 저장소에 있는 다른 소스의 모든 편집 내용도 커밋됩니다. NETCONF 클라이언트에서 확인된 커밋 절차가 진행 중인 경우 새 커밋이 확인 커밋으로 작동합니다. NETCONF 서버가\(MUST\)

확인된 커밋 절차를 완료하기 위해 "persist-id" 매개변수를 사용하면 RESTCONF 편집 작업이 "409 충돌" 상태 줄과 함께 실패해야 합니다. 이 경우에는 오류 태그 "사용 중"이 사용됩니다.\(MUST\)

NETCONF 서버가 :startup을 지원하는 경우 RESTCONF 서버는 RESTCONF 편집 작업의 결과로 "실행 중인" 데이터 저장소가 변경된 후 비휘발성 시작 구성 데이터 저장소를 자동으로 업데이트해야 합니다.\(MUST\)

RESTCONF 작업에 의해 수정될 데이터 저장소에 NETCONF 클라이언트의 활성 잠금이 있는 경우 RESTCONF 편집 작업은 "409 충돌" 상태 표시줄과 함께 실패해야 합니다. 이 경우 오류 태그 값 "in-use"가 반환됩니다.\(MUST\)

---
### **1.5.  RESTCONF Extensibility**

RESTCONF에는 두 가지 확장성 메커니즘이 내장되어 있습니다.

```text
   o  protocol version

   o  optional capabilities
```

이 문서는 RESTCONF 프로토콜 버전 1을 정의합니다. 이 프로토콜의 향후 버전이 정의되면 해당 문서는 RESTCONF의 새 버전을 식별하는 방법을 지정합니다. 다른 링크 관계를 사용하여 위치가 결정되는 다른 RESTCONF 루트 리소스가 사용될 것으로 예상됩니다\(섹션 3.1 참조\).

서버는 호스트 메타 데이터에서 지원하는 모든 프로토콜 버전을 광고합니다.

이 예에서 서버는 RESTCONF 버전 1과 가상 버전 2를 모두 지원합니다.

클라이언트는 다음을 보낼 수 있습니다.

```text
      GET /.well-known/host-meta HTTP/1.1
      Host: example.com
      Accept: application/xrd+xml
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Content-Type: application/xrd+xml
      Content-Length: nnn

      <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
          <Link rel='restconf' href='/restconf'/>
          <Link rel='restconf2' href='/restconf2'/>
      </XRD>
```

RESTCONF는 또한 섹션 9.3에 정의된 "ietf-restconf-monitoring" 모듈을 사용하여 서버에서 나열하는 선택적 기능의 서버 정의 목록을 지원합니다. 이 문서는 섹션 4.8에서 여러 쿼리 매개변수를 정의합니다. 각 선택적 매개변수에는 섹션 9.1.1에 정의된 해당 기능 URI가 있으며 지원되는 경우 서버에서 광고합니다.

"기능" 리프 목록은 모든 종류의 서버 확장을 식별할 수 있습니다. 현재 이 확장 메커니즘은 지원되는 선택적 쿼리 매개변수를 식별하는 데 사용되지만 해당 목적으로 제한되지는 않습니다. 예를 들어, 섹션 9.1.2에 정의된 "기본값" URI는 서버 기본 처리 동작을 식별하는 필수 URI를 지정합니다.

구현이 선택 사항인 경우 새로운 하위 리소스 유형을 기능으로 식별할 수 있습니다. 필수 프로토콜 기능과 새로운 리소스 유형에는 RESTCONF 프로토콜의 새로운 개정판이 필요합니다.

---
## **2.  Transport Protocol**
---
### **2.1.  Integrity and Confidentiality**

HTTP \[RFC7230\]은 신뢰할 수 있는 전송 계층 프로토콜에 계층화될 수 있는 애플리케이션 계층 프로토콜입니다. RESTCONF는 HTTP 위에 정의되지만 전달되는 정보의 민감한 특성으로 인해 RESTCONF에서는 전송 계층 프로토콜이 데이터 무결성과 기밀성을 모두 제공해야 합니다. RESTCONF 서버는 TLS\(Transport Layer Security\) 프로토콜 \[RFC5246\]을 지원해야 하며 \[RFC7525\]를 준수해야 합니다. RESTCONF 프로토콜은 TLS 프로토콜을 사용하지 않고 HTTP를 통해 사용되어서는 안 됩니다.\(MUST, MUST NOT\)

RESTCONF에는 특정 버전의 HTTP가 필요하지 않습니다. 그러나 모든 구현에서 최소한 HTTP/1.1 \[RFC7230\]을 지원하는 것이 권장됩니다.\(SHOULD\)

---
### **2.2.  HTTPS with X.509v3 Certificates**

TLS \[RFC7230\]를 통한 HTTP에 대한 거의 유비쿼터스 지원을 고려할 때 RESTCONF 구현은 IANA 할당 기본 포트 443이 있는 "https" URI 체계를 지원해야 합니다.\(MUST\)

RESTCONF 서버는 RESTCONF 클라이언트와 TLS 연결을 설정할 때 X.509v3 기반 인증서를 제시해야 합니다. X.509v3 기반 인증서의 사용은 TLS \[RFC7589\]를 통한 NETCONF와 일치합니다.\(MUST\)

---
### **2.3.  Certificate Validation**

RESTCONF 클라이언트는 \(1\) X.509 인증서 경로 유효성 검사 \[RFC5280\]를 사용하여 RESTCONF 서버의 TLS 인증서의 무결성을 확인하거나 \(2\) 서버의 TLS 인증서를 신뢰할 수 있는 메커니즘\(예: 고정된 메커니즘\)에서 얻은 인증서와 일치시켜야 합니다. 자격증\). X.509 인증서 경로 유효성 검사가 실패하고 제시된 X.509 인증서가 신뢰할 수 있는 메커니즘에서 얻은 인증서와 일치하지 않는 경우 \[RFC5246\]의 섹션 7.2.1에 설명된 대로 연결을 종료해야 합니다.\(MUST, MUST\)

---
### **2.4.  Authenticated Server Identity**

RESTCONF 클라이언트는 \[RFC2818\]의 섹션 3.1에 따라 서버의 ID를 확인해야 합니다.\(MUST\)

---
### **2.5.  Authenticated Client Identity**

RESTCONF 서버는 보호되는 리소스에 대한 클라이언트 액세스를 인증해야 합니다. RESTCONF 클라이언트가 인증되지 않은 경우 서버는 \[RFC7235\]의 섹션 3.1에 정의된 대로 "401 Unauthorized" 상태 라인과 함께 HTTP 응답을 보내야 합니다. 이 경우 오류 태그 값 "access-denied"가 사용됩니다.\(MUST, SHOULD\)

클라이언트를 인증하기 위해 RESTCONF 서버는 TLS 클라이언트 인증서\(\[RFC5246\]의 섹션 7.4.6\)에 기반한 인증을 요구해야 합니다. 인증서 기반 인증이 가능하지 않은 경우\(예: 클라이언트에 필요한 PKI를 구축할 수 없기 때문에\) HTTP 인증을 사용할 수 있습니다. 후자의 경우 "HTTP\(Hypertext Transfer Protocol\) 인증 체계 레지스트리"\(\[RFC7235\]의 섹션 5.1\)에 정의된 HTTP 인증 체계 중 하나를 사용해야 합니다.\(SHOULD, MAY, MUST\)

서버는 또한 클라이언트 인증서와 HTTP 클라이언트 인증 체계의 조합을 지원할 수도 있으며, 이 조합을 처리하는 방법에 대한 결정은 구현 결정으로 남겨집니다.\(MAY\)

사용된 인증 메커니즘에서 파생된 RESTCONF 클라이언트 ID는 이후 "RESTCONF 사용자 이름"으로 알려져 있으며 NACM\(NETCONF 액세스 제어 모델\) \[RFC6536\]을 따릅니다. 클라이언트 인증서가 제시되면 RESTCONF 사용자 이름은 \[RFC7589\]의 섹션 7에 정의된 알고리즘을 사용하여 파생되어야 합니다. 다른 모든 경우에는 HTTP 인증이 사용될 때 RESTCONF 사용자 이름이 사용된 HTTP 인증 체계에 의해 제공되어야 합니다.\(MUST, MUST\)

---
## **3.  Resources**

RESTCONF 프로토콜은 최상위 API 리소스 자체\(섹션 3.1\)부터 시작하여 리소스 계층 구조에서 작동합니다. 각 리소스는 장치 내에서 관리 가능한 구성 요소를 나타냅니다.

리소스는 데이터 모음과 해당 데이터에 대해 허용되는 메서드 집합으로 간주될 수 있습니다. 중첩된 하위 리소스를 포함할 수 있습니다. 하위 리소스 유형과 허용되는 메서드는 데이터 모델에 따라 다릅니다.

리소스에는 HTTP 응답 메시지의 "Content-Type" 헤더 필드로 표시되는 미디어 유형 식별자와 관련된 표현이 있습니다. 리소스에는 각각 다른 미디어 유형과 연관된 하나 이상의 표현이 있습니다. 리소스 표현이 HTTP 메시지로 전송되면 관련 미디어 유형이 "Content-Type" 헤더에 제공됩니다. 리소스에는 0개 이상의 중첩 리소스가 포함될 수 있습니다. 상위 리소스가 존재하는 한 리소스는 상위 리소스와 독립적으로 생성 및 삭제될 수 있습니다.

RESTCONF 리소스는 이 문서에 정의된 URI 세트를 통해 액세스됩니다. 서버에서 지원하는 YANG 모듈 세트는 서버에서 지원하는 데이터 모델별 RPC 작업, 최상위 데이터 노드 및 이벤트 알림 메시지를 결정합니다.

RESTCONF 프로토콜에는 데이터 리소스 검색 메커니즘이 포함되어 있지 않습니다. 대신, 서버가 광고하는 YANG 모듈 내의 정의는 RPC 작업이나 데이터 리소스 식별자를 구성하는 데 사용됩니다.

---
### **3.1.  Root Resource Discovery**

\[RFC7320\]에 정의된 모범 사례에 따라 RESTCONF를 사용하면 배포 시 RESTCONF API가 있는 위치를 지정할 수 있습니다. RESTCONF 서버에 처음 연결할 때 RESTCONF 클라이언트는 RESTCONF API의 루트를 결정해야 합니다. 장치에서 반환된 "restconf" 링크 관계가 정확히 하나 있어야 합니다.\(MUST, MUST\)

클라이언트는 "/.well-known/host-meta" 리소스\(\[RFC6415\]\)를 가져오고 "restconf" 속성이 포함된 <Link\> 요소를 사용하여 이를 발견합니다.

```text
   Example returning /restconf:
```

클라이언트는 다음을 보낼 수 있습니다.

```text
      GET /.well-known/host-meta HTTP/1.1
      Host: example.com
      Accept: application/xrd+xml
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Content-Type: application/xrd+xml
      Content-Length: nnn

      <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
          <Link rel='restconf' href='/restconf'/>
      </XRD>
```

RESTCONF API 루트를 검색한 후 클라이언트는 RESTCONF 리소스에 대한 후속 요청에서 요청 URI에 있는 경로의 초기 부분으로 이 값을 사용해야 합니다.\(MUST\)

이 예에서 클라이언트는 "/restconf" 경로를 RESTCONF 루트 리소스로 사용합니다.

```text
   Example returning /top/restconf:
```

클라이언트는 다음을 보낼 수 있습니다.

```text
      GET /.well-known/host-meta HTTP/1.1
      Host: example.com
      Accept: application/xrd+xml
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Content-Type: application/xrd+xml
      Content-Length: nnn

      <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
          <Link rel='restconf' href='/top/restconf'/>
      </XRD>
```

이 예에서 클라이언트는 "/top/restconf" 경로를 RESTCONF 루트 리소스로 사용합니다.

이제 클라이언트는 서버가 지원하는 작업 리소스를 결정할 수 있습니다. 이 예에서는 사용자 정의 "재생" 작업이 지원됩니다.

클라이언트는 다음을 보낼 수 있습니다.

```text
      GET /top/restconf/operations HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Last-Modified: Thu, 26 Jan 2017 16:00:14 GMT
      Content-Type: application/yang-data+json

      { "operations" : { "example-jukebox:play" : [null] } }
```

확장 가능 자원 설명자\(XRD\)에 둘 이상의 링크 관계가 포함된 경우 "restconf"라는 관계만 이 사양과 관련됩니다.

루트 리소스 검색 메커니즘으로 인해 특정 엔드포인트\(호스트:포트\)는 하나의 RESTCONF 서버만 지원할 수 있습니다. 이는 각 서버가 서로 다른 포트를 사용해야 하므로 호스트에서 동시에 실행할 수 있는 RESTCONF 서버의 수를 제한합니다.

---
### **3.2.  RESTCONF Media Types**

RESTCONF 프로토콜은 특정 YANG 구성에 대한 스키마를 준수하는 데이터 표현을 식별하기 위해 두 가지 애플리케이션별 미디어 유형을 정의합니다.

이 문서는 YANG 데이터의 XML 및 JSON 직렬화를 위한 미디어 유형을 정의합니다. 다른 문서에서는 YANG 데이터의 다양한 직렬화에 대해 다른 미디어 유형을 정의할 수 있습니다. "application/yang-data+xml" 미디어 유형은 섹션 11.3.1에 정의되어 있습니다. "application/yang-data+json" 미디어 유형은 섹션 11.3.2에 정의되어 있습니다.\(MAY\)

---
### **3.3.  API Resource**

API 리소스에는 RESTCONF 데이터 저장소 및 작업 리소스에 대한 RESTCONF 루트 리소스가 포함되어 있습니다. {+restconf}에 위치한 최상위 리소스이며 미디어 유형이 "application/yang-data+xml" 또는 "application/yang-data+json"입니다.

API 리소스에 대한 YANG 트리 다이어그램:

```text
     +---- {+restconf}
           +---- data
           | ...
           +---- operations?
           | ...
           +--ro yang-library-version    string
```

"yang-api" YANG 데이터 템플릿은 섹션 8에 있는 "ietf-restconf" 모듈의 "yang-data" 확장을 사용하여 정의됩니다. 이는 API 리소스 내의 개념적 하위 리소스의 구조와 구문을 지정합니다.

API 리소스는 GET 메서드를 사용하여 검색할 수 있습니다.

"ietf-restconf" 모듈의 루트를 나타내는 응답에 사용된 {+restconf} 루트 리소스 이름은 "ietf-restconf" YANG 모듈을 식별해야 합니다. 예를 들어, JSON 형식의 루트 리소스 "/restconf"를 GET하라는 요청은 "ietf-restconf:restconf"라는 API 리소스 표현을 반환합니다.\(MUST\)

이 리소스에는 다음과 같은 하위 리소스가 있습니다.

```text
        +----------------------+---------------------------------+
        | Child Resource       | Description                     |
        +----------------------+---------------------------------+
        | data                 | Contains all data resources     |
        | operations           | Data-model-specific operations  |
        | yang-library-version | "ietf-yang-library" module date |
        +----------------------+---------------------------------+

                           RESTCONF API Resource
```

---
#### **3.3.1.  {+restconf}/data**

이 필수 리소스는 클라이언트가 액세스할 수 있는 결합된 구성 및 상태 데이터 리소스를 나타냅니다. 클라이언트가 생성하거나 삭제할 수 없습니다. 데이터 저장소 리소스 유형은 섹션 3.4에 정의되어 있습니다.

```text
   Example:
```

클라이언트의 이 예제 요청은 "content" 쿼리 매개변수를 사용하여 "라이브러리" 리소스 내에 존재하는 비구성 데이터 노드만 검색합니다\(섹션 4.8.1 참조\).

```text
      GET /restconf/data/example-jukebox:jukebox/library\
          ?content=nonconfig HTTP/1.1
      Host: example.com
      Accept: application/yang-data+xml
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Content-Type: application/yang-data+xml

      <library xmlns="https://example.com/ns/example-jukebox">
        <artist-count>42</artist-count>
        <album-count>59</album-count>
        <song-count>374</song-count>
      </library>
```

---
#### **3.3.2.  {+restconf}/operations**

이 선택적 리소스는 서버에서 지원하는 데이터 모델별 RPC 작업에 대한 액세스를 제공하는 컨테이너입니다. 데이터 모델별 RPC 작업이 광고되지 않으면 서버는 이 리소스를 생략할 수 있습니다.\(MAY\)

서버가 광고하는 YANG 모듈에 정의된 모든 데이터 모델별 RPC 작업은 이 리소스의 하위 노드로 사용 가능해야 합니다.\(MUST\)

각 RPC 작업에 대한 액세스 지점은 빈 리프로 표시됩니다. 작업 리소스가 검색되면 서버는 빈 리프 표현을 반환합니다.

운영 자원은 섹션 3.6에 정의되어 있습니다.

---
#### **3.3.3.  {+restconf}/yang-library-version**

이 필수 리프는 이 서버에서 구현되는 "ietf-yang-library" YANG 모듈의 개정 날짜를 식별합니다. 다음 예에서는 \[RFC7895\]에 있는 모듈 버전의 개정 날짜가 사용됩니다.

```text
   Example:

      GET /restconf/yang-library-version HTTP/1.1
      Host: example.com
      Accept: application/yang-data+xml
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Content-Type: application/yang-data+xml

      <yang-library-version
        xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">\
        2016-06-21\
      </yang-library-version>
```

---
### **3.4.  Datastore Resource**

"{+restconf}/data" 하위 트리는 구성 데이터 및 상태 데이터 노드의 컬렉션인 데이터 저장소 리소스를 나타냅니다.

이 리소스 유형은 시스템의 기본 데이터 저장소 구현을 추상화한 것입니다. 클라이언트는 이를 사용하여 장치에 있는 모든 구성 및 상태 데이터의 개념적 루트로서 데이터 리소스를 편집하고 검색합니다.

구성 편집 트랜잭션 관리 및 구성 지속성은 서버에 의해 처리되며 클라이언트에 의해 제어되지 않습니다. 데이터 저장소 리소스는 POST 및 PATCH 메서드를 사용하여 직접 작성할 수 있습니다. 섹션 1.4에 설명된 대로 서버가 구성 데이터의 비휘발성 저장소를 지원하는 경우 데이터 저장소 리소스의 각 RESTCONF 편집 내용은 서버에 의해 비휘발성 저장소에 저장됩니다.

"{+restconf}/data" 하위 트리로 표시되는 데이터 저장소 리소스가 검색되면 데이터 저장소와 해당 콘텐츠가 서버에 의해 반환됩니다. 데이터 저장소는 "ietf-restconf" 모듈 네임스페이스에서 "data"라는 노드로 표시됩니다.

---
#### **3.4.1.  Edit Collision Prevention**

데이터 저장소 리소스에 대한 RESTCONF에는 타임스탬프와 엔터티 태그라는 두 가지 편집 충돌 감지 및 방지 메커니즘이 제공됩니다. 구성 데이터 리소스를 변경하면 데이터 저장소 리소스의 타임스탬프와 엔터티 태그가 업데이트됩니다. 또한 데이터 저장소가 외부 소스\(예: NETCONF 서버\)에 의해 잠긴 경우 RESTCONF 서버는 오류를 반환해야 합니다.\(MUST\)

---
##### **3.4.1.1.  Timestamp**

마지막 변경 시간이 유지되며, 검색 요청에 대한 응답으로 "Last-Modified" 헤더 필드\(\[RFC7232\]의 섹션 2.2\)가 반환됩니다. "If-Unmodified-Since" 헤더 필드\(\[RFC7232\]의 섹션 3.4\)는 지정된 타임스탬프 이후 리소스가 수정된 경우 서버가 요청을 거부하도록 편집 작업 요청에 사용될 수 있습니다.

서버는 섹션 3.4에 정의된 데이터 저장소 리소스에 대해 마지막으로 수정된 타임스탬프를 유지해야 합니다\(SHOULD\). 이 타임스탬프는 구성 하위 데이터 리소스에 의해서만 영향을 받으며 비구성 하위 데이터 리소스에 대한 변경 사항에 대해 업데이트되어서는 안 됩니다. 데이터 리소스의 마지막 수정 타임스탬프는 섹션 3.5에서 논의됩니다.\(SHOULD, MUST NOT\)

RESTCONF 서버가 NETCONF 서버와 같은 위치에 있는 경우 마지막으로 수정된 타임스탬프는 "실행 중인" 데이터 저장소에 대한 것이어야 합니다. 다른 프로토콜로 인해 마지막으로 수정된 타임스탬프가 업데이트될 수도 있습니다. 이러한 메커니즘은 이 문서의 범위를 벗어납니다.\(MUST\)

---
##### **3.4.1.2.  Entity-Tag**

서버는 데이터 저장소 리소스에 대한 고유한 불투명 엔터티 태그를 유지해야 하며\(MUST\) 검색 요청에 대한 응답의 "ETag"\(\[RFC7232\] 섹션 2.3\) 헤더에 이를 반환해야 합니다\(MUST\). 클라이언트는 편집 작업 요청에서 "If-Match" 헤더를 사용하여 리소스 엔터티 태그가 지정된 값과 일치하지 않는 경우 서버가 요청을 거부하도록 할 수 있습니다.\(MUST, MAY\)

서버는 최상위 {+restconf}/data 리소스에 대한 엔터티 태그를 유지해야 합니다. 이 엔터티 태그는 구성 데이터 리소스에 의해서만 영향을 받으며 비구성 데이터 변경에 대해 업데이트되어서는 안 됩니다. 데이터 리소스의 엔터티 태그는 섹션 3.5에서 논의됩니다. 각 표현\(예: XML과 JSON\)에는 서로 다른 엔터티 태그가 필요합니다.\(MUST, MUST NOT\)

RESTCONF 서버가 NETCONF 서버와 같은 위치에 있는 경우 이 엔터티 태그는 "실행 중인" 데이터 저장소용이어야 합니다. 다른 프로토콜로 인해 엔터티 태그가 업데이트될 수도 있습니다. 이러한 메커니즘은 이 문서의 범위를 벗어납니다.\(MUST\)

---
##### **3.4.1.3.  Update Procedure**

구성 데이터 리소스에 대한 변경 사항은 해당 리소스, 상위 데이터 리소스 및 데이터 저장소 리소스의 타임스탬프와 엔터티 태그에 영향을 줍니다.

예를 들어 인터페이스를 비활성화하는 편집은 리프 "/interfaces/interface/enabled"를 "false"로 설정하여 수행할 수 있습니다. "활성화된" 데이터 노드와 그 상위 노드\(하나의 "인터페이스" 목록 인스턴스와 "인터페이스" 컨테이너\)는 변경된 것으로 간주됩니다. 최상위 구성 데이터 노드\(예: "인터페이스"\)가 변경되면 데이터 저장소가 변경된 것으로 간주됩니다.

---
### **3.5.  Data Resource**

데이터 리소스는 데이터 저장소 리소스의 하위 노드인 YANG 데이터 노드를 나타냅니다. 각 YANG 정의 데이터 노드는 HTTP 메소드의 요청 라인에 의해 고유하게 대상이 될 수 있습니다. 컨테이너, 리프, 리프 목록 항목, 목록 항목, anydata 노드 및 anyxml 노드는 데이터 리소스입니다.

각 데이터 리소스에 대해 유지되는 표현은 해당 노드에 대해 YANG으로 정의된 하위 트리입니다. 데이터 리소스의 HTTP 메소드는 대상 데이터 노드와 모든 하위 항목\(있는 경우\) 모두에 영향을 미칩니다.

GET 메소드를 사용하여 데이터 리소스를 검색할 수 있습니다. 데이터 리소스는 "{+restconf}/data" URI를 통해 액세스됩니다. 이 하위 트리는 데이터 리소스를 검색하고 편집하는 데 사용됩니다.

---
#### **3.5.1.  Timestamp**

구성 데이터 리소스의 경우 서버는 리소스에 대해 마지막으로 수정된 타임스탬프를 유지하고 GET 또는 HEAD 메서드로 검색할 때 "Last-Modified" 헤더 필드를 반환할 수 있습니다.\(MAY\)

"Last-Modified" 헤더 필드는 "If-Modified-Since" 및 "If-Unmodified-Since" 헤더 필드 내에서 후속 요청의 RESTCONF 클라이언트에 의해 사용될 수 있습니다.

유지되는 경우 리소스 타임스탬프는 리소스 또는 리소스 내의 구성 리소스가 변경될 때마다 현재 시간으로 설정되어야 합니다. 유지 관리되지 않는 경우 데이터 저장소의 리소스 타임스탬프를 대신 사용해야 합니다. RESTCONF 서버가 NETCONF 서버와 같은 위치에 있는 경우 구성 데이터 리소스의 마지막 수정 타임스탬프는 "실행 중인" 데이터 저장소 내의 인스턴스를 나타내야 합니다.\(MUST, MUST, MUST\)

이 타임스탬프는 구성 데이터 리소스에 의해서만 영향을 받으며 비구성 데이터 변경에 대해 업데이트되어서는 안 됩니다.\(MUST NOT\)

---
#### **3.5.2.  Entity-Tag**

구성 데이터 리소스의 경우 서버는 각 리소스에 대한 리소스 엔터티 태그를 유지해야 하며 GET 또는 HEAD 메서드를 사용하여 대상 리소스로 검색될 때 "ETag" 헤더 필드를 반환해야 합니다. 유지되는 경우 리소스 엔터티 태그는 리소스 또는 리소스 내의 구성 리소스가 변경될 때마다 업데이트되어야 합니다. 유지 관리되지 않는 경우 데이터 저장소의 리소스 엔터티 태그를 대신 사용해야 합니다.\(SHOULD, MUST, MUST\)

"ETag" 헤더 필드는 "If-Match" 및 "If-None-Match" 헤더 필드 내에서 후속 요청의 RESTCONF 클라이언트에 의해 사용될 수 있습니다.

이 엔터티 태그는 구성 데이터 리소스에 의해서만 영향을 받으며 비구성 데이터 변경에 대해 업데이트되어서는 안 됩니다. RESTCONF 서버가 NETCONF 서버와 같은 위치에 있는 경우 구성 데이터 리소스의 엔터티 태그는 "실행 중인" 데이터 저장소 내의 인스턴스를 나타내야 합니다.\(MUST NOT, MUST\)

---
#### **3.5.3.  Encoding Data Resource Identifiers in the Request URI**

YANG에서는 문서 루트부터 대상 리소스까지 \[XPath\]에 정의된 절대 XPath 표현으로 데이터 노드를 식별할 수 있습니다. RESTCONF에서는 URI로 인코딩된 경로 표현식이 대신 사용됩니다.

애플리케이션은 정적 이름 지정을 사용하고 모든 데이터 노드에 대한 절대 경로 위치를 정의하는 YANG 데이터 모델 모듈에 코딩하므로 데이터 리소스의 예측 가능한 위치가 중요합니다.

RESTCONF 데이터 리소스 식별자는 섹션 3.5.3.1의 "api-path" 규칙에 따라 최상위 데이터 노드부터 시작하여 왼쪽에서 오른쪽으로 인코딩됩니다. 대상 리소스 노드의 각 조상 노드 이름은 대상 리소스의 노드 이름으로 끝나는 순서대로 인코딩됩니다. 경로의 노드가 상위 노드 이외의 모듈에 정의되어 있거나 해당 상위 노드가 데이터 저장소인 경우 리소스 식별자의 노드 이름 앞에 모듈 이름 뒤에 콜론 문자\(":"\)를 추가해야 합니다. 자세한 내용은 섹션 3.5.3.1을 참조하세요.\(MUST\)

경로 표현식의 데이터 노드가 YANG 리프 목록 노드인 경우 리프 목록 값은 다음 규칙에 따라 인코딩되어야 합니다.\(MUST\)

o 리프 목록의 식별자는 하나의 경로 세그먼트 \[RFC3986\]를 사용하여 인코딩되어야 합니다.\(MUST\)

o 경로 세그먼트는 리프 목록 이름, "=" 문자, 리프 목록 값으로 구성됩니다\(예: /restconf/data/top-leaflist=fred\).

o 리프 목록 값은 YANG 데이터 유형에 대한 표준 표현을 사용하여 문자열로 지정됩니다. 모든 예약된 문자는 \[RFC3986\]의 섹션 2.1 및 2.5에 따라 백분율로 인코딩되어야 합니다.\(MUST\)

o YANG 1.1에서는 비구성 데이터에 대한 중복 리프 목록 값을 허용합니다. 이 경우 정확히 일치하는 리프 목록 인스턴스를 지정하는 메커니즘이 없습니다.

o 리프 목록에 여러 키 값을 사용할 수 없더라도 쉼표\(","\) 문자는 백분율로 인코딩됩니다\[RFC3986\]. 이는 보다 일관성이 있으며 특별한 처리 규칙을 피합니다.

경로 표현식의 데이터 노드가 YANG 목록 노드인 경우 목록의 키 값\(있는 경우\)은 다음 규칙에 따라 인코딩되어야 합니다.\(MUST\)

o YANG 목록을 나타내는 데이터 리소스의 키 리프 값은 하나의 경로 세그먼트 \[RFC3986\]를 사용하여 인코딩되어야 합니다.\(MUST\)

o 키 리프 값이 하나만 있는 경우 경로 세그먼트는 다음과 같습니다.

- 목록 이름, "=" 문자, 단일 키 리프 값으로 구성됩니다.

o 여러 개의 키 리프 값이 있는 경우 경로 세그먼트는 목록 이름과 "키" 문에서 식별된 각 리프의 값을 포함하여 구성되며 YANG "키" 문에 지정된 순서로 인코딩됩니다. 마지막 값을 제외한 각 키 리프 값 뒤에는 쉼표 문자가 옵니다.

o 키 값은 YANG 데이터 유형에 대한 표준 표현을 사용하여 문자열로 지정됩니다. 모든 예약된 문자는 \[RFC3986\]의 섹션 2.1 및 2.5에 따라 백분율로 인코딩되어야 합니다. 쉼표\(","\) 문자가 키 값에 있는 경우 백분율로 인코딩되어야 합니다.\(MUST, MUST\)

o "키" 문의 모든 구성 요소는 인코딩되어야 합니다. 부분 인스턴스 식별자는 지원되지 않습니다.\(MUST\)

o 누락된 키 값은 허용되지 않으므로 두 개의 연속 쉼표는 쉼표, 길이가 0인 문자열, 쉼표로 해석됩니다. 예를 들어, "list1=foo,,baz"는 세 개의 키 값이 있는 "list1"이라는 목록으로 해석되며 두 번째 키 값은 길이가 0인 문자열입니다.

o 키를 정의하는 데 비구성 목록이 필요하지 않습니다. 이 경우 단일 목록 인스턴스에 액세스할 수 없습니다.

o 섹션 3.5.3.1에 정의된 "list-instance" ABNF\(Augmented Backus-Naur Form\) \[RFC5234\] 규칙은 목록 인스턴스 식별자의 구문을 나타냅니다.

```text
   Examples:

      container top {
          list list1 {
              key "key1 key2 key3";
               ...
               list list2 {
                   key "key4 key5";
                   ...
                   leaf X { type string; }
               }
           }
           leaf-list Y {
             type uint32;
           }
       }
```

위의 YANG 정의에서 컨테이너 "top"은 "example-top" YANG 모듈에 정의되어 있으며 리프 "X"에 대한 대상 리소스 URI는 다음과 같이 인코딩됩니다.

```text
       /restconf/data/example-top:top/list1=key1,key2,key3/\
          list2=key4,key5/X
```

위의 YANG 정의의 경우 리프 목록 "Y"에 대한 대상 리소스 URI는 다음과 같이 인코딩됩니다.

```text
       /restconf/data/example-top:top/Y=instance-value
```

다음 예에서는 키 값 내에서 예약된 문자가 백분율로 인코딩되는 방식을 보여줍니다. "key1"의 값에는 쉼표, 작은따옴표, 큰따옴표, 콜론, 큰따옴표, 공백 및 슬래시\(,'":" /\)가 포함됩니다. 큰따옴표는 예약된 문자가 아니므로 백분율로 인코딩할 필요가 없습니다. "key2"의 값은 빈 문자열이고 "key3"의 값은 "foo" 문자열입니다.

```text
   Example URL:

      /restconf/data/example-top:top/list1=%2C%27"%3A"%20%2F,,foo
```

---
##### **3.5.3.1.  ABNF for Data Resource Identifiers**

"api-path" ABNF \[RFC5234\] 구문은 RESTCONF 경로 식별자를 구성하는 데 사용됩니다. 이 구문은 모든 리소스에 사용되며 API 경로는 RESTCONF 루트 리소스로 시작됩니다. 데이터 리소스는 "{+restconf}/data" 하위 트리에서 식별되어야 합니다.

YANG 식별자 규칙에 따라 식별자는 대소문자를 구분하지 않는 문자열 "XML"로 시작할 수 없습니다. "api-identifier" 및 "key-value" 구문은 \[RFC7951\] 섹션 4의 JSON 식별자 인코딩 규칙을 준수해야 합니다. RESTCONF 루트 리소스 경로가 필요합니다. 추가 하위 리소스 식별자는 선택 사항입니다. 키 값 문자열의 문자는 제한되어 있으며 일부 문자는 섹션 3.5.3에 설명된 대로 백분율로 인코딩되어야 합니다.\(MUST\)

```text
   api-path = root *("/" (api-identifier / list-instance))

   root = string  ;; replacement string for {+restconf}

   api-identifier = [module-name ":"] identifier

   module-name = identifier

   list-instance = api-identifier "=" key-value *("," key-value)
```

키-값 = 문자열 ;; 제한된 문자는 백분율로 인코딩됩니다.

```text
   string = <an unquoted string>

   identifier = (ALPHA / "_")
                *(ALPHA / DIGIT / "_" / "-" / ".")
```

---
#### **3.5.4.  Default Handling**

RESTCONF에서는 서버가 기본 처리 모드를 보고해야 합니다\(자세한 내용은 섹션 9.1.2 참조\). 선택적 "with-defaults" 쿼리 매개변수가 서버에서 지원되는 경우 클라이언트는 이를 사용하여 기본값 검색을 제어할 수 있습니다\(자세한 내용은 섹션 4.8.9 참조\).

구성에서 리프 또는 리프 목록이 누락되고 해당 데이터 리소스에 대해 YANG 정의 기본값이 있는 경우 서버는 YANG 정의 기본값을 구성된 값으로 사용해야 합니다.\(MUST\)

GET 메소드의 대상이 기본값이 있는 리프 또는 리프 목록을 나타내는 데이터 노드이고 리프 또는 리프 목록이 아직 인스턴스화되지 않은 경우 서버는 기본값 또는 사용 중인 값을 반환해야 합니다. 서버에 의해. 이 경우 서버는 섹션 4.8.9에 설명된 "기본 모드"를 무시하고 기본값을 반환해야 합니다.\(MUST, MUST\)

GET 메소드의 대상이 기본값이 있는 하위 리소스가 있는 컨테이너 또는 목록을 나타내는 데이터 노드인 경우 아직 값이 제공되지 않은 하위 리소스에 대해

서버는 보고된 기본 처리 모드 및 클라이언트가 전달한 쿼리 매개변수에 따라 서버에서 사용 중인 기본값을 반환할 수 있습니다.\(MAY\)

---
### **3.6.  Operation Resource**

작업 리소스는 YANG "rpc" 문으로 정의된 RPC 작업 또는 YANG "action" 문으로 정의된 데이터 모델별 작업을 나타냅니다. 작업 리소스의 POST 메서드를 사용하여 호출됩니다.

RPC 작업은 다음과 같이 호출됩니다.

```text
      POST {+restconf}/operations/<operation>
```

<작업\> 필드는 원하는 작업에 대한 모듈 이름과 rpc 식별자 문자열을 식별합니다.

예를 들어, "모듈 A"가 "재설정" RPC 작업을 정의한 경우 작업 호출은 다음과 같이 요청됩니다.

```text
      POST /restconf/operations/module-A:reset HTTP/1.1
      Server: example.com
```

작업은 다음과 같이 호출됩니다.

```text
      POST {+restconf}/data/<data-resource-identifier>/<action>
```

여기서 <data-resource-identifier\>에는 작업이 정의된 데이터 노드에 대한 경로가 포함되고 <action\>은 작업의 이름입니다.

예를 들어, "모듈-A"가 컨테이너 "인터페이스"에서 "모두 재설정" 작업을 정의한 경우 이 작업 호출은 다음과 같이 요청됩니다.

```text
      POST /restconf/data/module-A:interfaces/reset-all HTTP/1.1
      Server: example.com
```

RPC 작업이 오류 없이 호출되고 "rpc" 또는 "action" 문에 "output" 섹션이 없는 경우 응답 메시지는 메시지 본문을 포함해서는 안 되며 대신 "204 No Content" 상태 라인을 보내야 합니다.\(MUST NOT\)

서버가 지원하는 RPC 작업을 나타내는 모든 작업 리소스는 섹션 3.3.2에 정의된 "{+restconf}/Operations" 하위 트리에서 식별되어야 합니다. YANG 작업을 나타내는 작업 리소스는 "{+restconf}/data" 하위 트리 내의 URI를 사용하여 호출되므로 이 하위 트리에서 식별되지 않습니다.\(MUST\)

---
#### **3.6.1.  Encoding Operation Resource Input Parameters**

"rpc" 또는 "action" 문에 "input" 섹션이 있는 경우 이러한 입력 매개 변수의 인스턴스는 "rpc" 또는 "action" 문이 정의된 모듈 네임스페이스, XML 요소 또는 JSON 개체에 인코딩됩니다. "rpc" 또는 "action" 문이 정의된 모듈 네임스페이스에 있는 "input"입니다.

"rpc" 또는 "action" 문에 "input" 섹션이 있고 "input" 개체 트리에 필수 노드로 간주되는 하위 데이터 노드가 포함되어 있는 경우 메시지 본문은 요청에서 클라이언트에 의해 전송되어야 합니다.\(MUST\)

"rpc" 또는 "action" 문에 "input" 섹션이 있고 "input" 개체 트리에 필수 노드로 간주되는 하위 노드가 포함되어 있지 않은 경우 클라이언트는 요청에서 메시지 본문을 보낼 수 있습니다.\(MAY\)

"rpc" 또는 "action" 문에 "input" 섹션이 없는 경우 요청 메시지에는 메시지 본문이 포함되어서는 안 됩니다.\(MUST NOT\)

```text
   Examples:
```

이 섹션의 RPC 작업 예제에는 다음 YANG 모듈이 사용됩니다.

```text
   module example-ops {
     namespace "https://example.com/ns/example-ops";
     prefix "ops";

     organization "Example, Inc.";
     contact "support at example.com";
     description "Example Operations Data Model Module.";
     revision "2016-07-07" {
       description "Initial version.";
       reference "example.com document 3-3373.";
     }

     rpc reboot {
       description "Reboot operation.";
       input {
         leaf delay {
           type uint32;
           units "seconds";
           default 0;
           description
             "Number of seconds to wait before initiating the
              reboot operation.";
         }
         leaf message {
           type string;
           description
             "Log message to display when reboot is started.";
         }
         leaf language {
           type string;
           description "Language identifier string.";
           reference "RFC 5646.";
         }
       }
     }

     rpc get-reboot-info {
       description
         "Retrieve parameters used in the last reboot operation.";
       output {
         leaf reboot-time {
           type uint32;
           description
             "The 'delay' parameter used in the last reboot
              operation.";
         }
         leaf message {
           type string;
           description
             "The 'message' parameter used in the last reboot
              operation.";
         }
         leaf language {
           type string;
           description
             "The 'language' parameter used in the last reboot
              operation.";
         }
       }
     }
   }
```

다음 YANG 모듈은 이 섹션의 YANG 작업 예제에 사용됩니다.

```text
   module example-actions {
     yang-version 1.1;
     namespace "https://example.com/ns/example-actions";
     prefix "act";
     import ietf-yang-types { prefix yang; }

     organization "Example, Inc.";
     contact "support at example.com";
     description "Example Actions Data Model Module.";
     revision "2016-07-07" {
       description "Initial version.";
       reference "example.com document 2-9973.";
     }

     container interfaces {
       description "System interfaces.";
       list interface {
         key name;
         description "One interface entry.";
         leaf name {
           type string;
           description "Interface name.";
         }

         action reset {
           description "Reset an interface.";
           input {
             leaf delay {
               type uint32;
               units "seconds";
               default 0;
               description
                 "Number of seconds to wait before starting the
                  interface reset.";
             }
           }
         }

         action get-last-reset-time {
           description
             "Retrieve the last interface reset time.";
           output {
             leaf last-reset {
               type yang:date-and-time;
               mandatory true;
               description
                 "Date and time of the last interface reset, or
                  the last reboot time of the device.";
             }
           }
         }
       }
     }

   }

   RPC Input Example:
```

클라이언트는 "재부팅" RPC 작업을 호출하기 위해 다음 POST 요청 메시지를 보낼 수 있습니다.

```text
      POST /restconf/operations/example-ops:reboot HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+xml
```

<input xmlns="https://example.com/ns/example-ops"\>

- <delay\>600</delay\> <message\>시스템 점검을 위해 다운됩니다</message\> <언어\>en-US</언어\> </input\>

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 204 No Content
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
```

JSON 인코딩을 사용하여 동일한 요청 메시지 예시가 여기에 표시됩니다.

```text
      POST /restconf/operations/example-ops:reboot HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+json

      {
        "example-ops:input" : {
          "delay" : 600,
          "message" : "Going down for system maintenance",
          "language" : "en-US"
        }
      }

   Action Input Example:
```

클라이언트는 "재설정" 작업을 호출하기 위해 다음 POST 요청 메시지를 보낼 수 있습니다.

```text
      POST /restconf/data/example-actions:interfaces/\
         interface=eth0/reset HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+xml

      <input xmlns="https://example.com/ns/example-actions">
        <delay>600</delay>
      </input>
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 204 No Content
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
```

JSON 인코딩을 사용하여 동일한 요청 메시지 예시가 여기에 표시됩니다.

```text
      POST /restconf/data/example-actions:interfaces/\
        interface=eth0/reset HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+json

      { "example-actions:input" : {
          "delay" : 600
        }
      }
```

---
#### **3.6.2.  Encoding Operation Resource Output Parameters**

"rpc" 또는 "action" 문에 "output" 섹션이 있는 경우 이러한 출력 매개 변수의 인스턴스는 "rpc" 또는 "action" 문이 정의된 모듈 네임스페이스, XML 요소 또는 JSON 개체에 인코딩됩니다. "rpc" 또는 "action" 문이 정의된 모듈 네임스페이스에 있는 "output"입니다.

RPC 작업이 오류 없이 호출되고 "rpc" 또는 "action" 문에 "output" 섹션이 있고 "output" 개체 트리에 필수 노드로 간주되는 하위 데이터 노드가 포함되어 있는 경우 응답 메시지 본문 응답으로 서버에서 전송해야 합니다.\(MUST\)

RPC 작업이 오류 없이 호출되고 "rpc" 또는 "action" 문에 "output" 섹션이 있고 "output" 개체 트리에 필수 노드로 간주되는 하위 노드가 포함되어 있지 않은 경우 응답 메시지는 다음과 같습니다. 본문은 응답으로 서버에 의해 전송될 수 있습니다.\(MAY\)

요청 URI는 응답으로 반환되지 않습니다. 출력을 요청에 사용된 특정 "rpc" 또는 "action" 문과 연결하려면 요청 URI에 대한 지식이 필요할 수 있습니다.

```text
   Examples:

   RPC Output Example:
```

이 예에는 섹션 3.6.1에 정의된 "example-ops" YANG 모듈이 사용되었습니다.

클라이언트는 "get-reboot-info" 작업을 호출하기 위해 다음 POST 요청 메시지를 보낼 수 있습니다.

```text
      POST /restconf/operations/example-ops:get-reboot-info HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      {
        "example-ops:output" : {
          "reboot-time" : 30,
          "message" : "Going down for system maintenance",
          "language" : "en-US"
        }
      }
```

XML 인코딩을 사용하여 동일한 응답이 여기에 표시됩니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+xml
```

<output xmlns="https://example.com/ns/example-ops"\>

- <reboot-time\>30</reboot-time\> <message\>시스템 유지 관리를 위해 다운됩니다</message\> <언어\>en-US</언어\> </output\>

```text
   Action Output Example:
```

이 예제에는 섹션 3.6.1에 정의된 "example-actions" YANG 모듈이 사용되었습니다.

클라이언트는 "get-last-reset-time" 작업을 호출하기 위해 다음 POST 요청 메시지를 보낼 수 있습니다.

```text
      POST /restconf/data/example-actions:interfaces/\
         interface=eth0/get-last-reset-time HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      {
        "example-actions:output" : {
          "last-reset" : "2015-10-10T02:14:11Z"
        }
      }
```

---
#### **3.6.3.  Encoding Operation Resource Errors**

작업이나 작업을 호출하는 동안 오류가 발생하면 적절한 오류 상태와 함께 "오류" 미디어 유형이 반환됩니다.

\(1\) RPC 작업 입력이 유효하지 않거나 \(2\) RPC 작업이 호출되었지만 오류가 발생한 경우 섹션 3.9에 정의된 대로 "오류" 리소스가 포함된 메시지 본문을 서버에서 전송해야 합니다.\(MUST\)

섹션 3.6.1의 예에서 "재부팅" RPC 작업을 사용하여 클라이언트는 다음 POST 요청 메시지를 보낼 수 있습니다.

```text
      POST /restconf/operations/example-ops:reboot HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+xml
```

<input xmlns="https://example.com/ns/example-ops"\>

- <delay\>-33</delay\> <message\>시스템 점검을 위해 내려갑니다</message\> <언어\>en-US</언어\> </input\>

서버가 "잘못된 값" 오류로 응답할 수 있습니다.

```text
      HTTP/1.1 400 Bad Request
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+xml

      <errors xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
        <error>
          <error-type>protocol</error-type>
          <error-tag>invalid-value</error-tag>
          <error-path xmlns:ops="https://example.com/ns/example-ops">
            /ops:input/ops:delay
          </error-path>
          <error-message>Invalid input parameter</error-message>
        </error>
      </errors>
```

JSON 인코딩을 사용하여 동일한 응답이 여기에 표시됩니다.

```text
      HTTP/1.1 400 Bad Request
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      { "ietf-restconf:errors" : {
          "error" : [
            {
              "error-type" : "protocol",
              "error-tag" : "invalid-value",
              "error-path" : "/example-ops:input/delay",
              "error-message" : "Invalid input parameter"
            }
          ]
        }
      }
```

---
### **3.7.  Schema Resource**

서버는 선택적으로 자신이 사용하는 YANG 모듈 검색을 지원할 수 있습니다. 검색이 지원되는 경우 "스키마" 리프는 \[RFC7895\]에 정의된 관련 "모듈" 목록 항목에 있어야 합니다.\(MUST\)

YANG 모듈을 검색하려면 클라이언트는 먼저 "스키마" 리프에 저장된 스키마 검색을 위한 URL을 가져와야 합니다. 이 URL에는 필수 구조가 없습니다. 아래에 표시된 URL 값은 단지 예일 뿐입니다.

클라이언트는 다음 GET 요청 메시지를 보낼 수 있습니다.

```text
      GET /restconf/data/ietf-yang-library:modules-state/\
          module=example-jukebox,2016-08-15/schema HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      {
        "ietf-yang-library:schema" :
         "https://example.com/mymodules/example-jukebox/2016-08-15"
      }
```

다음으로 클라이언트는 실제 YANG 스키마를 검색해야 합니다.

클라이언트는 다음 GET 요청 메시지를 보낼 수 있습니다.

```text
      GET https://example.com/mymodules/example-jukebox/\
         2016-08-15 HTTP/1.1
      Host: example.com
      Accept: application/yang
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang

         // entire YANG module contents deleted for this example...
```

---
### **3.8.  Event Stream Resource**

이벤트 스트림 리소스는 시스템 생성 이벤트 알림의 소스를 나타냅니다. 각 스트림은 서버에서만 생성되고 수정됩니다. 클라이언트는 섹션 6.3에 지정된 절차를 사용하여 스트림 리소스를 검색하거나 긴 폴링 서버에서 보낸 이벤트 스트림\[W3C.REC-eventsource-20150203\]을 시작할 수 있습니다.

이벤트 스트림은 "NETCONF 이벤트 알림" 사양 \[RFC5277\]에 따라 작동합니다. 사용 가능한 스트림은 스트림 리소스의 구문과 의미를 지정하는 "스트림" 목록에서 검색할 수 있습니다.

---
### **3.9.  "errors" YANG Data Template**

"errors" YANG 데이터 템플릿은 요청 메시지를 처리하는 동안 오류가 발생할 경우 서버 응답 메시지의 메시지 본문으로 전송되는 오류 정보 모음을 모델로 합니다. GET 요청으로 인스턴스를 검색할 수 없으므로 리소스 유형으로 간주되지 않습니다.

"ietf-restconf" YANG 모듈에는 RESTCONF 응답 내에서 "오류" 컨테이너의 구문과 의미를 지정하는 "yang-errors" YANG 데이터 템플릿이 포함되어 있습니다. RESTCONF 오류 처리 동작은 섹션 7에 정의되어 있습니다.

---
## **4.  RESTCONF Methods**

RESTCONF 프로토콜은 HTTP 메서드를 사용하여 특정 리소스에 대해 요청된 CRUD 작업을 식별합니다.

다음 표에서는 RESTCONF 작업이 NETCONF 프로토콜 작업과 어떻게 관련되는지 보여줍니다.

```text
   +----------+-------------------------------------------------------+
   | RESTCONF | NETCONF                                               |
   +----------+-------------------------------------------------------+
   | OPTIONS  | none                                                  |
   |          |                                                       |
   | HEAD     | <get-config>, <get>                                   |
   |          |                                                       |
   | GET      | <get-config>, <get>                                   |
   |          |                                                       |
   | POST     | <edit-config> (nc:operation="create")                 |
   |          |                                                       |
   | POST     | invoke an RPC operation                               |
   |          |                                                       |
   | PUT      | <copy-config> (PUT on datastore)                      |
   |          |                                                       |
   | PUT      | <edit-config> (nc:operation="create/replace")         |
   |          |                                                       |
   | PATCH    | <edit-config> (nc:operation depends on PATCH content) |
   |          |                                                       |
   | DELETE   | <edit-config> (nc:operation="delete")                 |
   +----------+-------------------------------------------------------+

                         CRUD Methods in RESTCONF
```

NETCONF <edit-config\> RPC 작업에 대한 "제거" 편집 작업 속성은 HTTP DELETE 메서드에서 지원되지 않습니다. 리소스가 존재해야 합니다. 그렇지 않으면 DELETE 메서드가 실패합니다. PATCH 방법은 일반 패치를 사용할 때 "병합" 편집 작업과 동일합니다\(섹션 4.6.1 참조\). 다른 미디어 유형은 보다 세부적인 제어를 제공할 수 있습니다.

액세스 제어 메커니즘은 사용할 수 있는 CRUD 작업을 제한하는 데 사용됩니다. 특히 RESTCONF와 NETCONF 작업 사이에 특정 매핑이 있으므로 RESTCONF는 NACM\(NETCONF 액세스 제어 모델\) \[RFC6536\]과 호환됩니다. 리소스 경로는 서버에 의해 내부적으로 해당 YANG 인스턴스 식별자로 변환되어야 합니다. 이 정보를 사용하여 서버는 NACM 액세스 제어 규칙을 RESTCONF 메시지에 적용할 수 있습니다.

서버는 클라이언트가 액세스할 권한이 없는 리소스에 대해 RESTCONF 작업을 허용해서는 안 됩니다.\(MUST NOT\)

모든 메소드\(PATCH \[RFC5789\] 제외\)의 구현은 \[RFC7231\]에 정의되어 있습니다. 이 섹션에서는 각 HTTP 메서드에 대한 RESTCONF 프로토콜 사용법을 정의합니다.

---
### **4.1.  OPTIONS**

OPTIONS 메소드는 클라이언트가 특정 리소스\(예: GET, POST, DELETE\)에 대해 서버에서 지원하는 메소드를 검색하기 위해 전송됩니다. 서버는 이 메서드를 구현해야 합니다.\(MUST\)

"Accept-Patch" 헤더 필드는 \[RFC5789\]에 정의된 대로 OPTIONS 요청에 대한 응답으로 지원되고 반환되어야 합니다.\(MUST\)

---
### **4.2.  HEAD**

RESTCONF 서버는 HEAD 메소드를 지원해야 합니다. HEAD 메소드는 응답 메시지 본문 없이 유사한 GET 메소드에 대해 반환되는 헤더 필드\(리소스에 대한 메타데이터 포함\)만 검색하기 위해 클라이언트에 의해 전송됩니다. GET 메서드를 지원하는 모든 리소스에 대해 지원됩니다.\(MUST\)

요청에는 최소한 루트 리소스가 포함된 요청 URI가 포함되어야 합니다. GET 메소드에서 지원되는 동일한 쿼리 매개변수가 HEAD 메소드에서도 지원됩니다.\(MUST\)

액세스 제어 동작은 메소드가 HEAD 대신 GET인 것처럼 적용됩니다. 서버는 응답 메시지 본문이 포함되지 않는다는 점을 제외하고는 메소드가 HEAD 대신 GET인 것처럼 동일하게 응답해야 합니다.\(MUST\)

---
### **4.3.  GET**

RESTCONF 서버는 GET 메소드를 지원해야 합니다. GET 메소드는 리소스에 대한 데이터 및 메타데이터를 검색하기 위해 클라이언트에서 전송됩니다. 운영 자원을 제외한 모든 자원 유형에 대해 지원됩니다. 요청에는 최소한 루트 리소스가 포함된 요청 URI가 포함되어야 합니다.\(MUST, MUST\)

서버는 사용자에게 읽기 권한이 없는 데이터 리소스를 반환해서는 안 됩니다. 사용자에게 대상 리소스를 읽을 수 있는 권한이 없으면 "401 Unauthorized" 상태 줄이 포함된 오류 응답이 반환되어야 합니다. 이 경우 오류 태그 값 "access-denied"가 반환됩니다. 서버는 \[RFC7231\]의 섹션 6.5.4에 설명된 대로 "404 Not Found" 상태 라인을 반환할 수 있습니다. 이 경우 오류 태그 값 "invalid-value"가 반환됩니다.\(MUST NOT, SHOULD, MAY\)

사용자가 대상 리소스의 전부가 아닌 일부를 읽을 수 있는 권한이 있는 경우 승인되지 않은 콘텐츠는 응답 메시지 본문에서 생략되고 승인된 콘텐츠가 클라이언트에 반환됩니다.

콘텐츠가 클라이언트에 반환되면 서버는 유효한 응답 메시지 본문을 보내야 합니다. XML 인코딩에 대해 둘 이상의 요소가 반환되어서는 안 됩니다. 여러 요소가 JSON 메시지 본문으로 전송되는 경우 JSON 배열로 전송되어야 합니다. 이 경우 응답에 반환된 모든 타임스탬프 또는 엔터티 태그는 반환된 첫 번째 요소와 연결되어야 합니다.\(MUST, MUST NOT, MUST, MUST\)

YANG 리프 목록 또는 목록 객체를 나타내는 데이터 리소스에 대한 검색 요청이 둘 이상의 인스턴스를 식별하고 XML 인코딩이 응답에 사용되는 경우 "400 Bad Request" 상태 라인을 포함하는 오류 응답이 반환되어야 합니다. 섬기는 사람. 이 경우 오류 태그 값 "invalid-value"가 사용됩니다. 키를 정의하는 데 비구성 목록이 필요하지 않습니다. 이 경우 단일 목록 인스턴스를 검색할 수 없습니다.\(MUST\)

데이터 리소스에 대한 검색 요청이 존재하지 않는 인스턴스를 나타내는 경우 "404 찾을 수 없음" 상태 라인을 포함하는 오류 응답이 서버에서 반환되어야 합니다. 이 경우 오류 태그 값 "invalid-value"가 사용됩니다.\(MUST\)

검색 요청의 대상 리소스가 작업 리소스에 대한 것이라면 서버는 "405 메서드가 허용되지 않음" 상태 라인을 반환해야 합니다. 이 경우에는 오류 태그 값 "option-not-supported"가 사용됩니다.\(MUST\)

액세스 제어가 데이터 리소스에 적용되는 방식은 HTTP 캐싱과 완전히 호환되지 않을 수 있습니다. 데이터 리소스에 대해 유지되는 "Last-Modified" 및 "ETag" 헤더 필드는 해당 데이터 리소스에 대한 액세스 제어 규칙 변경의 영향을 받지 않습니다. 특정 클라이언트에 표시되는 데이터 리소스의 표현은 "Last-Modified" 또는 "ETag" 값을 통해 감지되지 않고 변경될 수 있습니다.

```text
   Example:
```

클라이언트는 특정 "앨범" 리소스의 XML 표현에 대한 응답 헤더 필드를 요청할 수 있습니다.

```text
      GET /restconf/data/example-jukebox:jukebox/\
         library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
      Host: example.com
      Accept: application/yang-data+xml
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+xml
      Cache-Control: no-cache
      ETag: "a74eefc993a2b"
      Last-Modified: Thu, 26 Jan 2017 14:02:14 GMT

      <album xmlns="http://example.com/ns/example-jukebox"
             xmlns:jbox="http://example.com/ns/example-jukebox">
        <name>Wasting Light</name>
        <genre>jbox:alternative</genre>
        <year>2011</year>
      </album>
```

더 많은 리소스 검색 예제는 부록 B.1을 참조하세요.

---
### **4.4.  POST**

RESTCONF 서버는 POST 메소드를 지원해야 합니다. POST 메서드는 클라이언트에서 데이터 리소스를 생성하거나 작업 리소스를 호출하기 위해 전송됩니다. 서버는 대상 리소스 유형을 사용하여 요청을 처리하는 방법을 결정합니다.\(MUST\)

```text
      +-----------+------------------------------------------------+
      | Type      | Description                                    |
      +-----------+------------------------------------------------+
      | Datastore | Create a top-level configuration data resource |
      | Data      | Create a configuration data child resource     |
      | Operation | Invoke an RPC operation                        |
      +-----------+------------------------------------------------+
```

- POST를 지원하는 리소스 유형

---
#### **4.4.1.  Create Resource Mode**

대상 리소스 유형이 데이터 저장소 또는 데이터 리소스인 경우 POST는 각각 최상위 리소스 또는 하위 리소스를 생성하라는 요청으로 처리됩니다. 메시지 본문에는 상위\(대상 리소스\) 내에서 생성할 하위 리소스의 콘텐츠가 포함될 것으로 예상됩니다. 메시지 본문에는 예상되는 데이터 리소스의 인스턴스가 정확히 하나만 포함되어야 합니다. 하위 트리의 데이터 모델은 하위 리소스에 대해 YANG에서 정의한 하위 트리입니다.\(MUST\)

"삽입"\(섹션 4.8.5\) 및 "포인트"\(섹션 4.8.6\) 쿼리 매개변수는 데이터 저장소 및 데이터 리소스에 대한 POST 메서드에서 지원되어야 합니다. 이러한 매개변수는 목록 또는 리프 목록이 "사용자별 정렬"인 경우에만 허용됩니다.\(MUST\)

POST 메서드가 성공하면 "201 Created" 상태 줄이 반환되고 응답 메시지 본문이 없습니다. 이 경우 생성된 하위 리소스를 식별하는 "Location" 헤더 필드가 응답에 있어야 합니다.\(MUST\)

데이터 리소스가 이미 존재하는 경우 POST 요청은 반드시 실패해야 하며 "409 충돌" 상태 라인이 반환되어야 합니다. 이 경우 오류 태그 값 "resource-denied"가 사용됩니다.\(MUST\)

사용자에게 대상 리소스를 생성할 권한이 없으면 "403 Forbidden" 상태 줄이 포함된 오류 응답이 반환되어야 합니다. 이 경우 오류 태그 값 "access-denied"가 사용됩니다. 서버는 \[RFC7231\]의 섹션 6.5.4에 설명된 대로 "404 Not Found" 상태 라인을 반환할 수 있습니다. 이 경우 오류 태그 값 "invalid-value"가 사용됩니다. 다른 모든 오류 응답은 섹션 7에 정의된 절차에 따라 처리됩니다.\(SHOULD, MAY\)

```text
   Example:
```

새로운 "주크박스" 리소스를 생성하기 위해 클라이언트는 다음을 보낼 수 있습니다.

```text
      POST /restconf/data HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+json

      { "example-jukebox:jukebox" : {} }
```

리소스가 생성되면 서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 201 Created
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Location: https://example.com/restconf/data/\
          example-jukebox:jukebox
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      ETag: "b3a3e673be2"
```

더 많은 리소스 생성 예시는 부록 B.2.1을 참조하세요.

---
#### **4.4.2.  Invoke Operation Mode**

대상 리소스 유형이 작업 리소스인 경우 POST 메서드는 해당 작업을 호출하기 위한 요청으로 처리됩니다. 메시지 본문\(있는 경우\)은 작업 입력 매개변수로 처리됩니다. 운영 자원에 대한 자세한 내용은 섹션 3.6을 참조하세요.

POST 요청이 성공하면 응답 메시지 본문이 있으면 "200 OK" 상태 라인이 반환되고, 응답 메시지 본문이 없으면 "204 No Content" 상태 라인이 반환됩니다.

사용자에게 대상 작업을 호출할 권한이 없으면 "403 Forbidden" 상태 줄이 포함된 오류 응답이 반환되어야 합니다. 이 경우 오류 태그 값 "access-denied"가 사용됩니다. 서버는 \[RFC7231\]의 섹션 6.5.4에 설명된 대로 "404 Not Found" 상태 라인을 반환할 수 있습니다. 다른 모든 오류 응답은 섹션 7에 정의된 절차에 따라 처리됩니다.\(SHOULD, MAY\)

```text
   Example:
```

이 예에서 클라이언트는 "example-jukebox" YANG 모듈에 정의된 "재생" 작업을 호출합니다.

클라이언트는 다음과 같이 "재생" 요청을 보낼 수 있습니다.

```text
      POST /restconf/operations/example-jukebox:play HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+json

      {
        "example-jukebox:input" : {
          "playlist" : "Foo-One",
          "song-number" : 2
        }
      }
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 204 No Content
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
```

---
### **4.5.  PUT**

RESTCONF 서버는 PUT 메소드를 지원해야 합니다. PUT 메서드는 대상 데이터 리소스를 생성하거나 교체하기 위해 클라이언트에서 전송됩니다. 새로운 데이터 리소스를 나타내는 요청 메시지 본문이 있어야 하며, 그렇지 않으면 서버가 "400 Bad Request" 상태 라인을 반환해야 합니다. 이 경우 오류 태그 값 "invalid-value"가 사용됩니다.\(MUST, MUST\)

POST 및 PUT 메소드를 모두 사용하여 데이터 리소스를 생성할 수 있습니다. 차이점은 POST의 경우 클라이언트가 생성될 리소스에 대한 리소스 식별자를 제공하지 않는다는 것입니다. 리소스 생성을 위한 POST 메서드의 대상 리소스는 새 리소스의 상위 리소스입니다. 리소스 생성을 위한 PUT 메서드의 대상 리소스는 새 리소스입니다.

PUT 메서드는 데이터 및 데이터 저장소 리소스에 대해 지원되어야 합니다. 데이터 저장소 리소스에 대한 PUT는 데이터 저장소의 전체 콘텐츠를 바꾸는 데 사용됩니다. 데이터 리소스에 대한 PUT은 데이터 저장소 내의 해당 데이터 리소스만 대체합니다.\(MUST\)

"삽입"\(섹션 4.8.5\) 및 "포인트"\(섹션 4.8.6\) 쿼리 매개변수는 데이터 리소스에 대한 PUT 메서드에서 지원되어야 합니다. 이러한 매개변수는 목록 또는 리프 목록이 "사용자별 정렬"인 경우에만 허용됩니다.\(MUST\)

\[RFC7231\]에 따라 PUT 요청이 새 리소스를 생성하는 경우 "201 Created" 상태 줄이 반환됩니다. 기존 리소스가 수정되면 "204 콘텐츠 없음" 상태 표시줄이 반환됩니다.

사용자가 대상 리소스를 생성하거나 교체할 권한이 없는 경우 "403 Forbidden" 상태 라인을 포함하는 오류 응답이 반환되어야 합니다. 이 경우 오류 태그 값 "access-denied"가 사용됩니다.\(SHOULD\)

서버는 \[RFC7231\]의 섹션 6.5.4에 설명된 대로 "404 Not Found" 상태 라인을 반환할 수 있습니다. 이 경우 오류 태그 값 "invalid-value"가 사용됩니다. 다른 모든 오류 응답은 섹션 7에 정의된 절차에 따라 처리됩니다.\(MAY\)

대상 리소스가 YANG 리프 목록을 나타내는 경우 PUT 메소드는 리프 목록 인스턴스의 값을 변경해서는 안 됩니다.\(MUST NOT\)

대상 리소스가 YANG 목록 인스턴스를 나타내는 경우 메시지 본문 표현의 키 리프 값은 요청 URI의 키 리프 값과 동일해야 합니다. PUT 메소드는 데이터 리소스 인스턴스의 키 리프 값을 변경하는 데 사용되어서는 안 됩니다.\(MUST, MUST NOT\)

```text
   Example:
```

"example-jukebox" YANG 모듈에 정의된 "앨범" 하위 리소스가 대체되거나, 아직 존재하지 않는 경우 생성됩니다.

"앨범" 리소스 콘텐츠를 교체하기 위해 클라이언트는 다음을 보낼 수 있습니다.

```text
      PUT /restconf/data/example-jukebox:jukebox/\
          library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+json

      {
        "example-jukebox:album" : [
          {
            "name" : "Wasting Light",
            "genre" : "example-jukebox:alternative",
            "year" : 2011
          }
        ]
      }
```

리소스가 업데이트되면 서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 204 No Content
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      ETag: "b27480aeda4c"
```

XML 인코딩을 사용하여 동일한 요청이 여기에 표시됩니다.

```text
      PUT /restconf/data/example-jukebox:jukebox/\
          library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+xml

      <album xmlns="http://example.com/ns/example-jukebox"
             xmlns:jbox="http://example.com/ns/example-jukebox">
        <name>Wasting Light</name>
        <genre>jbox:alternative</genre>
        <year>2011</year>
      </album>
```

PUT 메서드를 사용하여 데이터 저장소 리소스의 콘텐츠를 바꾸는 예는 부록 B.2.4를 참조하세요.

---
### **4.6.  PATCH**

RESTCONF 서버는 일반 패치에 대한 PATCH 방법을 지원해야 하며 추가 미디어 유형을 지원할 수 있습니다. 서버가 지원하는 PATCH 메서드에 대한 미디어 유형은 클라이언트가 OPTIONS 요청을 보내고 응답의 "Accept-Patch" 헤더 필드를 검사하여 검색할 수 있습니다\(섹션 4.1 참조\).\(MUST\)

RESTCONF는 \[RFC5789\]에 정의된 HTTP PATCH 방법을 사용하여 리소스 패치 메커니즘을 위한 확장 가능한 프레임워크를 제공합니다. 각 패치 메커니즘에는 고유한 미디어 유형이 필요합니다.

이 문서는 하나의 패치 메커니즘을 정의합니다\(섹션 4.6.1\). 또 다른 패치 메커니즘인 YANG Patch 메커니즘은 \[YANG-Patch\]에 정의되어 있습니다. 다른 패치 메커니즘은 향후 사양에 따라 정의될 수 있습니다.

대상 리소스 인스턴스가 존재하지 않는 경우 서버는 이를 생성해서는 안 됩니다.\(MUST NOT\)

PATCH 요청이 성공하면 message-body가 있으면 "200 OK" 상태 라인이 반환되고, 응답 message-body가 전송되지 않으면 "204 No Content"가 반환됩니다.

사용자에게 대상 리소스를 변경할 권한이 없으면 "403 Forbidden" 상태 줄이 포함된 오류 응답이 반환되어야 합니다. 서버는 \[RFC7231\]의 섹션 6.5.4에 설명된 대로 "404 Not Found" 상태 라인을 반환할 수 있습니다. 이 경우 오류 태그 값 "invalid-value"가 사용됩니다. 다른 모든 오류 응답은 섹션 7에 정의된 절차에 따라 처리됩니다.\(SHOULD, MAY\)

---
#### **4.6.1.  Plain Patch**

일반 패치 메커니즘은 메시지 본문의 내용을 대상 리소스와 병합합니다. 일반 패치의 메시지 본문은 반드시 존재해야 하며 미디어 유형 "application/yang-data+xml" 또는 "application/yang-data+json"으로 표시되어야 합니다.\(MUST\)

일반 패치를 사용하면 대상 리소스 내의 하위 리소스를 생성하거나 업데이트할 수 있지만 삭제할 수는 없습니다. 하위 리소스 삭제 기능을 지원하는 대체 미디어 유형은 \[YANG-Patch\]를 참조하세요. YANG Patch 미디어 유형은 단일 PATCH 메서드 내에서 여러 하위 작업\(예: "병합", "삭제"\)을 허용합니다.

대상 리소스가 YANG 리프 목록을 나타내는 경우 PATCH 메서드는 리프 목록 인스턴스의 값을 변경해서는 안 됩니다.\(MUST NOT\)

대상 리소스가 YANG 목록 인스턴스를 나타내는 경우 메시지 본문 표현의 키 리프 값은 요청 URI의 키 리프 값과 동일해야 합니다. PATCH 메소드는 데이터 리소스 인스턴스의 키 리프 값을 변경하는 데 사용되어서는 안 됩니다.\(MUST, MUST NOT\)

서버에서 일반 패치를 처리한 후 섹션 4.6에 지정된 대로 응답이 클라이언트에 반환됩니다.

```text
   Example:
```

"album" 리소스의 "연도" 필드만 바꾸려면\(전체 리소스를 PUT 메서드로 바꾸는 대신\) 클라이언트는 다음과 같이 일반 패치를 보낼 수 있습니다.

```text
      PATCH /restconf/data/example-jukebox:jukebox/\
          library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
      Host: example.com
      If-Match: "b8389233a4c"
      Content-Type: application/yang-data+xml

      <album xmlns="http://example.com/ns/example-jukebox">
       <year>2011</year>
      </album>
```

필드가 업데이트되면 서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 204 No Content
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      ETag: "b2788923da4c"
```

---
### **4.7.  DELETE**

RESTCONF 서버는 DELETE 메소드를 지원해야 합니다. DELETE 메소드는 대상 리소스를 삭제하는 데 사용됩니다. DELETE 요청이 성공하면 "204 No Content" 상태 줄이 반환됩니다.\(MUST\)

사용자에게 대상 리소스를 삭제할 권한이 없으면 "403 Forbidden" 상태 줄이 포함된 오류 응답이 반환되어야 합니다. 이 경우 오류 태그 값 "access-denied"가 반환됩니다. 서버는 \[RFC7231\]의 섹션 6.5.4에 설명된 대로 "404 Not Found" 상태 라인을 반환할 수 있습니다. 이 경우 오류 태그 값 "invalid-value"가 반환됩니다. 다른 모든 오류 응답은 섹션 7에 정의된 절차에 따라 처리됩니다.\(SHOULD, MAY\)

대상 리소스가 구성 리프 목록 또는 목록 데이터 노드를 나타내는 경우 단일 YANG 리프 목록 또는 목록 인스턴스를 나타내야 합니다. 서버는 그러한 인스턴스를 두 개 이상 삭제하기 위해 DELETE 메소드를 사용해서는 안 됩니다.\(MUST, MUST NOT\)

```text
   Example:
```

"Wasting Light" 키가 있는 "앨범" 리소스를 삭제하기 위해 클라이언트는 다음을 보낼 수 있습니다.

```text
      DELETE /restconf/data/example-jukebox:jukebox/\
          library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
      Host: example.com
```

리소스가 삭제되면 서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 204 No Content
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
```

---
### **4.8.  Query Parameters**

각 RESTCONF 작업에서는 요청 URI에 0개 이상의 쿼리 매개변수가 존재할 수 있습니다. 허용되는 특정 매개변수는 리소스 유형에 따라 달라지며 때로는 요청에 사용되는 특정 대상 리소스에 따라 달라집니다.

o 쿼리 매개변수는 순서에 관계없이 제공될 수 있습니다.

o 각 매개변수는 요청 URI에 최대 한 번 나타날 수 있습니다.

o 쿼리 매개변수의 인스턴스가 두 개 이상 존재하는 경우 서버는 "400 Bad Request" 상태 라인을 반환해야 합니다. 이 경우 오류 태그 값 "invalid-value"가 반환됩니다.\(MUST\)

o 매개변수가 누락된 경우 기본값이 적용될 수 있습니다.

o 쿼리 매개변수 이름과 값은 대소문자를 구분합니다.

o 쿼리 매개변수가 예상치 못한 경우 서버는 "400 Bad Request" 상태 라인과 함께 오류를 반환해야 합니다. 이 경우 오류 태그 값 "invalid-value"가 반환됩니다.\(MUST\)

```text
   +---------------+---------+-----------------------------------------+
   | Name          | Methods | Description                             |
   +---------------+---------+-----------------------------------------+
   | content       | GET,    | Select config and/or non-config data    |
   |               | HEAD    | resources                               |
   |               |         |                                         |
   | depth         | GET,    | Request limited subtree depth in the    |
   |               | HEAD    | reply content                           |
   |               |         |                                         |
   | fields        | GET,    | Request a subset of the target resource |
   |               | HEAD    | contents                                |
   |               |         |                                         |
   | filter        | GET,    | Boolean notification filter for event   |
   |               | HEAD    | stream resources                        |
   |               |         |                                         |
   | insert        | POST,   | Insertion mode for "ordered-by user"    |
   |               | PUT     | data resources                          |
   |               |         |                                         |
   | point         | POST,   | Insertion point for "ordered-by user"   |
   |               | PUT     | data resources                          |
   |               |         |                                         |
   | start-time    | GET,    | Replay buffer start time for event      |
   |               | HEAD    | stream resources                        |
   |               |         |                                         |
   | stop-time     | GET,    | Replay buffer stop time for event       |
   |               | HEAD    | stream resources                        |
   |               |         |                                         |
   | with-defaults | GET,    | Control the retrieval of default values |
   |               | HEAD    |                                         |
   +---------------+---------+-----------------------------------------+

                         RESTCONF Query Parameters
```

쿼리 매개변수 사용 예는 부록 B.3을 참조하세요.

공급업체가 추가 쿼리 매개변수를 정의하는 경우 다른 매개변수와의 충돌을 피하기 위해 쿼리 매개변수 이름에 접두사\(예: 기업 또는 조직 이름\)를 사용해야 합니다.\(SHOULD\)

---
#### **4.8.1.  The "content" Query Parameter**

"content" 쿼리 매개변수는 요청된 데이터 노드의 하위 노드가 응답에서 처리되는 방식을 제어합니다.

허용되는 값은 다음과 같습니다.

```text
    +-----------+-----------------------------------------------------+
    | Value     | Description                                         |
    +-----------+-----------------------------------------------------+
    | config    | Return only configuration descendant data nodes     |
    |           |                                                     |
    | nonconfig | Return only non-configuration descendant data nodes |
    |           |                                                     |
    | all       | Return all descendant data nodes                    |
    +-----------+-----------------------------------------------------+
```

이 매개변수는 데이터 저장소 및 데이터 리소스의 GET 메서드에만 허용됩니다. 다른 방법이나 리소스 유형에 사용되는 경우 "400 잘못된 요청" 상태 표시줄이 반환됩니다.

이 쿼리 매개변수가 없으면 기본값은 "all"입니다. 이 쿼리 매개변수는 서버에서 지원되어야 합니다.\(MUST\)

---
#### **4.8.2.  The "depth" Query Parameter**

"깊이" 쿼리 매개변수는 서버가 반환하는 하위 트리의 깊이를 제한하는 데 사용됩니다. "깊이" 매개변수보다 큰 "깊이" 값을 가진 데이터 노드는 GET 메서드에 대한 응답으로 반환되지 않습니다.

요청된 데이터 노드의 깊이 수준은 "1"입니다. "fields" 매개변수\(섹션 4.8.3\)를 사용하여 하위 데이터 노드를 선택하는 경우 이러한 노드와 모든 상위 노드는 "1"의 "깊이" 값을 갖습니다. \(이것은 "깊이" 값이 지정된 필드의 실제 깊이 수준보다 작은 경우에도 필드에 지정된 노드를 포함하는 효과가 있습니다.\) 다른 모든 하위 노드는 해당 노드보다 1 큰 "깊이" 값을 갖습니다. 부모의.

"깊이" 매개변수의 값은 1에서 65535 사이의 정수이거나 "unbounded" 문자열입니다. "무제한"이 기본값입니다.

이 매개변수는 API, 데이터 저장소 및 데이터 리소스의 GET 메서드에만 허용됩니다. 다른 방법이나 리소스 유형에 사용되는 경우 "400 잘못된 요청" 상태 표시줄이 반환됩니다.

기본적으로 서버는 요청된 리소스와 동일한 리소스 유형을 가진 검색된 리소스 내의 모든 하위 리소스를 포함합니다. 데이터 저장소 리소스는 예외입니다. 이 리소스 유형이 검색되면 기본적으로 데이터 저장소와 모든 하위 데이터 리소스가 반환됩니다.

"깊이" 쿼리 매개변수 URI가 섹션 9.3에 정의된 "능력" 리프 목록에 나열되어 있는 경우 서버는 "깊이" 쿼리 매개변수를 지원합니다.

---
#### **4.8.3.  The "fields" Query Parameter**

"필드" 쿼리 매개변수는 GET 메소드에서 검색할 대상 리소스 내의 데이터 노드를 선택적으로 식별하는 데 사용됩니다. 클라이언트는 이 매개변수를 사용하여 리소스에 있는 모든 노드의 하위 집합을 검색할 수 있습니다.

서버는 "fields-expr" 값에 지정된 대로 하위 노드를 정리하여 대상 리소스를 나타내는 메시지 본문을 반환합니다. 서버는 별도의 하위 리소스 집합을 반환하지 않습니다.

"fields" 쿼리 매개변수의 값은 다음 규칙과 일치합니다.

```text
    fields-expr = path "(" fields-expr ")" / path ";" fields-expr / path
    path = api-identifier [ "/" path ]
```

"api-식별자"는 섹션 3.5.3.1에 정의되어 있습니다.

";" 여러 노드를 선택하는 데 사용됩니다. 예를 들어 앨범의 "장르"와 "연도"만 검색하려면 "fields=genre;year"를 사용합니다.

괄호는 노드의 하위 선택기를 지정하는 데 사용됩니다. "경로" 필드와 왼쪽 괄호 문자 "\(" 사이에는 경로 구분 문자 "/"가 없습니다.

예를 들어, 대상 리소스가 "앨범" 목록이라고 가정합니다. 앨범 내 "admin" 컨테이너의 "레이블"과 "카탈로그 번호"만 검색하려면 "fields=admin\(label;catalogue-number\)"를 사용하세요.

"/"는 노드의 하위 노드를 검색하는 경로에 사용됩니다. 예를 들어 앨범의 "레이블"만 검색하려면 "fields=admin/label"을 사용합니다.

이 매개변수는 API, 데이터 저장소 및 데이터 리소스의 GET 메서드에만 허용됩니다. 다른 방법이나 리소스 유형에 사용되는 경우 "400 잘못된 요청" 상태 표시줄이 반환됩니다.

"fields" 쿼리 매개변수 URI가 섹션 9.3에 정의된 "capability" 리프 목록에 나열되어 있으면 서버는 "fields" 매개변수를 지원합니다.

---
#### **4.8.4.  The "filter" Query Parameter**

"필터" 쿼리 매개변수는 가능한 모든 이벤트 중 관심 있는 하위 집합을 나타내는 데 사용됩니다. 존재하지 않는 경우 다른 매개변수에 의해 제외되지 않은 모든 이벤트가 전송됩니다.

이 매개변수는 이벤트 스트림 리소스의 GET 메소드에만 허용됩니다. 다른 방법이나 리소스 유형에 사용되는 경우 "400 잘못된 요청" 상태 표시줄이 반환됩니다.

이 매개변수의 형식은 XPath 1.0 표현식 \[XPath\]이며 다음 컨텍스트에서 평가됩니다.

o 네임스페이스 선언 세트는 지원되는 모든 YANG 모듈에 대한 접두사 및 네임스페이스 쌍 세트입니다. 여기서 접두사는 YANG 모듈 이름이고 네임스페이스는 YANG 모듈의 "네임스페이스" 문에 의해 정의됩니다.

o 함수 라이브러리는 XPath 1.0에 정의된 핵심 함수 라이브러리와 데이터 모델에 의해 정의된 모든 함수입니다.

o 변수 바인딩 세트가 비어 있습니다.

o 컨텍스트 노드는 루트 노드입니다.

"filter" 쿼리 매개변수는 \[RFC5277\]의 섹션 3.6에 정의된 대로 사용됩니다. 개념적 "알림" 문서 루트에 적용될 때 표현식의 부울 결과가 "true"이면 이벤트 알림이 클라이언트에 전달됩니다.

"필터" 쿼리 매개변수 URI가 섹션 9.3에 정의된 "능력" 리프 목록에 나열되어 있는 경우 서버는 "필터" 쿼리 매개변수를 지원합니다.

---
#### **4.8.5.  The "insert" Query Parameter**

"삽입" 쿼리 매개변수는 "사용자가 정렬한" 목록 내에 리소스를 삽입하는 방법을 지정하는 데 사용됩니다.

허용되는 값은 다음과 같습니다.

```text
   +--------+----------------------------------------------------------+
   | Value  | Description                                              |
   +--------+----------------------------------------------------------+
   | first  | Insert the new data as the new first entry.              |
   |        |                                                          |
   | last   | Insert the new data as the new last entry.               |
   |        |                                                          |
   | before | Insert the new data before the insertion point, as       |
   |        | specified by the value of the "point" parameter.         |
   |        |                                                          |
   | after  | Insert the new data after the insertion point, as        |
   |        | specified by the value of the "point" parameter.         |
   +--------+----------------------------------------------------------+
```

기본값은 "마지막"입니다.

이 매개변수는 POST 및 PUT 메소드에만 지원됩니다. 또한 대상 리소스가 데이터 리소스이고 해당 데이터가 "사용자가 정렬한" YANG 목록 또는 리프 목록을 나타내는 경우에만 지원됩니다.

"이전" 또는 "이후" 값이 사용되는 경우 "삽입" 쿼리 매개변수에 대한 "포인트" 쿼리 매개변수도 있어야 하며, 그렇지 않으면 "400 잘못된 요청" 상태 표시줄이 반환됩니다.\(MUST\)

"삽입" 쿼리 매개변수는 서버에서 지원되어야 합니다.\(MUST\)

---
#### **4.8.6.  The "point" Query Parameter**

"포인트" 쿼리 매개변수는 "사용자가 정렬한" 목록 또는 리프 목록 내에서 생성되거나 이동되는 데이터 리소스의 삽입 지점을 지정하는 데 사용됩니다.

"point" 매개변수의 값은 삽입 지점 개체에 대한 경로를 식별하는 문자열입니다. 형식은 대상 리소스 URI 문자열과 동일합니다.

이 매개변수는 POST 및 PUT 메소드에만 지원됩니다. 또한 대상 리소스가 데이터 리소스이고 해당 데이터가 "사용자가 정렬한" YANG 목록 또는 리프 목록을 나타내는 경우에만 지원됩니다.

"삽입" 쿼리 매개변수가 없거나 "이전" 또는 "이후" 이외의 값을 갖는 경우 "400 잘못된 요청" 상태 줄이 반환됩니다.

이 매개변수에는 POST 또는 PUT 메소드의 삽입 지점으로 사용될 리소스의 인스턴스 식별자가 포함되어 있습니다.

"point" 쿼리 매개변수는 서버에서 지원되어야 합니다.\(MUST\)

---
#### **4.8.7.  The "start-time" Query Parameter**

"start-time" 쿼리 매개변수는 \[RFC5277\]에 정의된 알림 재생 기능을 트리거하고 재생이 지정된 시간에 시작되어야 함을 나타내는 데 사용됩니다. 스트림이 스트림 리소스에 대한 "스트림" 목록 항목에 의해 반환된 "replay-support" 속성에 따라 재생을 지원하지 않는 경우 서버는 "400 Bad Request" 상태 라인을 반환해야 합니다.\(MUST\)

"start-time" 매개변수의 값은 "ietf-yang-types" YANG 모듈 \[RFC6991\]에 정의된 "날짜 및 시간" 유형입니다.

이 매개변수는 "text/event-stream" 데이터 리소스의 GET 메소드에만 허용됩니다. 다른 방법이나 리소스 유형에 사용되는 경우 "400 잘못된 요청" 상태 표시줄이 반환됩니다.

이 매개변수가 없으면 재생 구독이 요청되지 않습니다. 현재 시간보다 이후의 시작 시간을 지정하는 것은 유효하지 않습니다. 지정된 값이 로그가 지원할 수 있는 것보다 이전인 경우 사용 가능한 가장 빠른 알림으로 재생이 시작됩니다. 클라이언트는 \[RFC7231\]에 따라 서버가 응답 메시지로 반환하는 "Date" 헤더 필드를 검사하여 서버의 현재 시간을 얻을 수 있습니다.

이 쿼리 매개변수가 서버에서 지원되는 경우 "재생" 쿼리 매개변수 URI는 섹션 9.3에 정의된 "능력" 리프 목록에 나열되어야 하며 "중지 시간" 쿼리 매개변수도 서버에서 지원되어야 합니다. .\(MUST\)

"재생 지원" 리프의 "스트림" 항목\(섹션 9.3에 정의됨\)에 "true" 값이 있는 경우 서버는 해당 스트림에 대한 "시작 시간" 및 "중지 시간" 쿼리 매개변수를 지원해야 합니다.\(MUST\)

---
#### **4.8.8.  The "stop-time" Query Parameter**

"stop-time" 쿼리 매개변수는 재생 기능과 함께 사용되어 관심 있는 최신 알림을 나타냅니다. 이 매개변수는 "start-time" 매개변수와 함께 사용해야 하며 이 매개변수보다 이후의 값을 가져야 합니다.\(MUST\)

"stop-time" 매개변수의 값은 "ietf-yang-types" YANG 모듈 \[RFC6991\]에 정의된 "날짜 및 시간" 유형입니다.

이 매개변수는 "text/event-stream" 데이터 리소스의 GET 메소드에만 허용됩니다. 다른 방법이나 리소스 유형에 사용되는 경우 "400 잘못된 요청" 상태 표시줄이 반환됩니다.

이 매개변수가 없으면 구독이 종료될 때까지 알림이 계속됩니다. 미래의 값이 유효합니다.

이 쿼리 매개변수가 서버에서 지원되는 경우 "재생" 쿼리 매개변수 URI는 섹션 9.3에 정의된 "능력" 리프 목록에 나열되어야 하며 "시작 시간" 쿼리 매개변수도 서버에서 지원되어야 합니다. .\(MUST\)

"재생 지원" 리프가 "스트림" 항목\(섹션 9.3에 정의됨\)에 있는 경우 서버는 해당 스트림에 대한 "시작 시간" 및 "중지 시간" 쿼리 매개변수를 지원해야 합니다.\(MUST\)

---
#### **4.8.9.  The "with-defaults" Query Parameter**

"with-defaults" 쿼리 매개변수는 데이터 리소스에 대한 GET 요청에 대한 응답으로 기본 데이터 노드에 대한 정보가 반환되는 방법을 지정하는 데 사용됩니다.

서버가 이 기능을 지원하는 경우 NETCONF 작업 대신 RESTCONF GET 작업에 적용되는 것을 제외하고 \[RFC6243\]의 섹션 4.5.1에 ​​설명된 동작을 구현해야 합니다.\(MUST\)

```text
   +-------------------+-----------------------------------------------+
   | Value             | Description                                   |
   +-------------------+-----------------------------------------------+
   | report-all        | All data nodes are reported                   |
   |                   |                                               |
   | trim              | Data nodes set to the YANG default are not    |
   |                   | reported                                      |
   |                   |                                               |
   | explicit          | Data nodes set to the YANG default by the     |
   |                   | client are reported                           |
   |                   |                                               |
   | report-all-tagged | All data nodes are reported, and defaults are |
   |                   | tagged                                        |
   +-------------------+-----------------------------------------------+
```

"with-defaults" 매개변수가 "report-all"로 설정된 경우 서버는 \[RFC6243\]의 섹션 3.1에 정의된 기본 보고 동작을 준수해야 합니다.\(MUST\)

"with-defaults" 매개변수가 "trim"으로 설정된 경우 서버는 \[RFC6243\]의 섹션 3.2에 정의된 기본 보고 동작을 준수해야 합니다.\(MUST\)

"with-defaults" 매개변수가 "explicit"로 설정된 경우 서버는 \[RFC6243\]의 섹션 3.3에 정의된 기본 보고 동작을 준수해야 합니다.\(MUST\)

"with-defaults" 매개변수가 "report-all-tagged"로 설정된 경우 서버는 \[RFC6243\]의 섹션 3.4에 정의된 기본 보고 동작을 준수해야 합니다. 메타데이터는 섹션 5.3에 지정된 대로 서버에 의해 보고됩니다. 기본 노드에 대해 서버가 보낸 "default" 속성에 대한 XML 인코딩은 \[RFC6243\]의 섹션 6에 정의되어 있습니다. "default" 속성에 대한 JSON 인코딩은 \[RFC6243\]에 정의된 것과 동일한 값을 사용해야 하지만 \[RFC7952\]의 규칙에 따라 인코딩되어야 합니다. 모듈 이름 "ietf-netconf-with-defaults"는 "default" 속성에 사용해야 합니다.\(MUST, MUST, MUST\)

"with-defaults" 매개변수가 없으면 서버는 섹션 9.1.2에 정의된 "defaults" 프로토콜 기능 URI에 대한 "basic-mode" 매개변수에 정의된 기본 보고 동작을 준수해야 합니다.\(MUST\)

서버가 섹션 9.3에 정의된 "capability" 리프 목록에 "with-defaults" 쿼리 매개변수 URI를 포함하는 경우 "with-defaults" 쿼리 매개변수가 지원되어야 합니다.\(MUST\)

서버가 \[RFC6243\]의 4.3절에 설명된 대로 " also-supported" 매개변수를 보고하지 않으므로 "with-defaults" 매개변수에 대한 일부 값이 지원되지 않을 수 있습니다. 서버가 "with-defaults" 매개변수의 요청된 값을 지원하지 않는 경우, 서버는 "400 Bad Request" 상태 라인과 함께 응답을 반환해야 합니다. 이 경우 오류 태그 값 "invalid-value"가 사용됩니다.\(MUST\)

---
## **5.  Messages**

RESTCONF 프로토콜은 HTTP 메시지를 사용합니다. 단일 HTTP 메시지는 단일 프로토콜 방법에 해당합니다. 대부분의 메시지는 리소스 검색, 리소스 편집 등 단일 리소스에 대해 단일 작업을 수행할 수 있습니다. 단, 단일 메시지 내에서 여러 데이터 저장소 편집을 허용하는 PATCH 메서드는 예외입니다.

---
### **5.1.  Request URI Structure**

리소스는 \[RFC3986\]의 일반 URI 구조를 따르는 URI로 표현됩니다.

RESTCONF 작업은 다음 개념 필드를 사용하여 HTTP 메서드와 요청 URI에서 파생됩니다.

```text
        <OP> /<restconf>/<path>?<query>

          ^       ^        ^       ^
          |       |        |       |
        method  entry  resource  query

          M       M        O        O

       M=mandatory, O=optional

       where:
```

<OP\>는 HTTP 메서드입니다.

- <restconf\>는 RESTCONF 루트 리소스입니다. <path\>는 대상 리소스 URI입니다. <query\>는 쿼리 매개변수 목록입니다.

o 메소드: 요청 URI에 지정된 대상 자원에 대해 작동하기 위해 클라이언트가 요청한 RESTCONF 작업을 식별하는 HTTP 메소드입니다. RESTCONF 작업 세부 사항은 섹션 4에 설명되어 있습니다.

o 항목: 섹션 3.1에 설명된 대로 "/.well-known/host-meta" 리소스를 가져와 검색한 이 HTTP 서버에 구성된 RESTCONF API의 루트입니다.

o 자원: RESTCONF 작업에 의해 액세스되는 자원을 식별하는 경로 표현식입니다. 이 필드가 없으면 대상 리소스는 섹션 8에 있는 "yang-api"라는 YANG 데이터 템플릿으로 표시되는 API 자체입니다.

o 쿼리: RESTCONF 메시지와 연관된 매개변수 세트; \[RFC3986\]의 섹션 3.4를 참조하세요. RESTCONF 매개변수는 "이름=값" 쌍의 친숙한 형식을 갖습니다. 대부분의 쿼리 매개변수는 서버에서 구현하는 경우 선택 사항이고 클라이언트에서 사용하는 경우에는 선택 사항입니다. 각 선택적 쿼리 매개변수는 URI로 식별됩니다. 서버는 섹션 9.3에 정의된 "능력" 리프 목록에서 지원하는 선택적 쿼리 매개변수 URI를 나열해야 합니다.\(MUST\)

서버는 이 문서에 정의되지 않은 쿼리 매개변수를 지원하도록 선택할 수 있지만 특정 매개변수 세트가 정의되어 있습니다. 모든 쿼리 매개변수 값의 내용은 \[RFC3986\]의 섹션 3.4에 따라 인코딩되어야 합니다. 모든 예약된 문자는 \[RFC3986\]의 섹션 2.1 및 2.5에 따라 백분율로 인코딩되어야 합니다.\(MAY, MUST, MUST\)

조각 구성 요소는 RESTCONF 프로토콜에서 사용되지 않습니다. \[RFC7230\]의 섹션 5.1에 설명된 대로 조각은 서버에 의해 대상 URI에서 제외됩니다.

클라이언트가 새 리소스를 생성하면 새로 생성된 리소스의 경로를 식별하는 "Location" 헤더 필드가 반환됩니다. 클라이언트는 생성된 리소스에 액세스하기 위해 이 정확한 경로 식별자를 사용합니다.

RESTCONF 작업의 대상은 리소스입니다. 요청 URI의 "경로" 필드는 RESTCONF 작업의 대상 리소스를 나타냅니다.

RESTCONF 요청 URI의 예는 부록 B를 참조하세요.

---
### **5.2.  Message Encoding**

RESTCONF 메시지는 \[RFC7230\]에 따라 HTTP로 인코딩됩니다. 모든 메시지에는 "utf-8" 문자 집합이 사용됩니다. RESTCONF 메시지 내용은 HTTP 메시지 본문으로 전송됩니다.

콘텐츠는 JSON 또는 XML 형식으로 인코딩됩니다. 서버는 XML 또는 JSON 인코딩 중 하나를 지원해야 합니다. 서버는 XML과 JSON 인코딩을 모두 지원할 수 있습니다. 모든 RESTCONF 서버와 상호 운용하려면 클라이언트가 XML과 JSON을 모두 지원해야 합니다.\(MUST, MAY\)

데이터 노드에 대한 XML 인코딩 규칙은 \[RFC7950\]에 정의되어 있습니다. 모든 XML 콘텐츠에는 동일한 인코딩 규칙이 사용됩니다. JSON 인코딩 규칙은 \[RFC7951\]에 정의되어 있습니다. 메타데이터에 대한 추가 JSON 인코딩 규칙은 \[RFC7952\]에 정의되어 있습니다. 이 인코딩은 유효한 JSON이지만 모듈 네임스페이스를 식별하고 YANG 데이터의 일관된 유형 처리를 제공하는 특수 인코딩 규칙도 있습니다.

요청 입력 콘텐츠 인코딩 형식은 "Content-Type" 헤더 필드로 식별됩니다. 클라이언트가 메시지 본문을 보낸 경우 이 필드가 있어야 합니다.\(MUST\)

서버는 \[RFC7231\]에 정의된 대로 "Accept" 헤더 필드와 "406 Not Acceptable" 상태 라인을 지원해야 합니다. 클라이언트가 수락할 응답 출력 콘텐츠 인코딩 형식은 요청의 "Accept" 헤더 필드로 식별됩니다. 지정되지 않은 경우 요청 입력 인코딩 형식을 사용해야 하며, 그렇지 않으면 서버가 지원되는 콘텐츠 인코딩 형식을 선택할 수 있습니다.\(MUST, SHOULD\)

요청 입력이 없는 경우 기본 출력 인코딩은 서버 기본 설정에 따라 XML 또는 JSON입니다. 요청에 인코딩된 파일 확장자는 형식 인코딩을 식별하는 데 사용되지 않습니다.

클라이언트는 "Content-Type" 및/또는 "Accept" 헤더 필드에서 특정 형식을 사용하여 요청을 보내 RESTCONF 서버가 인코딩 형식을 지원하는지 확인할 수 있습니다. 서버가 요청에 대해 요청된 입력 인코딩을 지원하지 않는 경우 "415 지원되지 않는 미디어 유형" 상태 줄과 함께 오류 응답을 반환해야 합니다. 서버가 요청에 대해 요청된 출력 인코딩을 지원하지 않는 경우 "406 Not Acceptable" 상태 라인과 함께 오류 응답을 반환해야 합니다.\(MUST, MUST\)

---
### **5.3.  RESTCONF Metadata**

RESTCONF 프로토콜은 NETCONF 프로토콜에서 사용되는 것과 동일한 메타데이터 검색을 지원해야 합니다. 기본 리프, 마지막 수정 타임스탬프 등에 대한 정보는 일반적으로 데이터 저장소 콘텐츠 표현에 주석을 다는 데 사용됩니다.

XML 인코딩을 사용하면 메타데이터는 \[W3C.REC-xml-20081126\]의 섹션 3.3에 따라 XML의 속성으로 인코딩됩니다. JSON 인코딩을 사용하면 메타데이터가 \[RFC7952\]에 지정된 대로 인코딩됩니다.

다음 예는 부록 B.3.9의 예를 기반으로 합니다. "with-defaults" 쿼리 매개변수에 대한 "report-all-tagged" 모드에서는 기본 노드에 대해 "default" 속성이 반환되어야 합니다. 다음 예는 "mtu" 리프에 대한 해당 속성을 보여줍니다.

---
#### **5.3.1.  XML Metadata Encoding Example**

```text
      GET /restconf/data/interfaces/interface=eth1
          ?with-defaults=report-all-tagged HTTP/1.1
      Host: example.com
      Accept: application/yang-data+xml
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+xml

      <interface
        xmlns="urn:example.com:params:xml:ns:yang:example-interface">
        <name>eth1</name>
        <mtu xmlns:wd="urn:ietf:params:xml:ns:netconf:default:1.0"
          wd:default="true">1500</mtu>
        <status>up</status>
      </interface>
```

---
#### **5.3.2.  JSON Metadata Encoding Example**

RFC 6243은 YANG이 아닌 XSD\(XML 스키마 정의\)를 사용하여 "기본" 특성을 정의하므로 YANG 모듈에서 파생되는 대신 YANG 모듈 이름을 할당해야 합니다. JSON 메타데이터 인코딩에는 "ietf-netconf-with-defaults" 값이 할당됩니다.

```text
      GET /restconf/data/interfaces/interface=eth1\
          ?with-defaults=report-all-tagged HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      {
        "example:interface" : [
          {
            "name" : "eth1",
            "mtu" : 1500,
            "@mtu" : {
               "ietf-netconf-with-defaults:default" : true
            },
            "status" : "up"
          }
        ]
      }
```

---
### **5.4.  Return Status**

각 메시지는 일종의 리소스 액세스를 나타냅니다. 각 요청에 대해 HTTP "상태 줄" 헤더 필드가 반환됩니다. "4xx" 범위의 상태 코드가 상태 줄에 반환되면 섹션 7.1에 정의된 형식에 따라 오류 정보가 응답으로 반환되어야 합니다. "5xx" 범위의 상태 코드가 상태 줄에 반환되면 섹션 7.1에 정의된 형식에 따라 오류 정보가 응답으로 반환될 수 있습니다. "1xx", "2xx" 또는 "3xx" 범위의 상태 코드가 상태 줄에 반환되면 오류 정보는 응답으로 반환되어서는 안 됩니다. 이러한 범위는 오류 조건을 나타내지 않기 때문입니다.\(SHOULD, MAY, MUST NOT\)

---
### **5.5.  Message Caching**

데이터 저장소 내용은 예측할 수 없는 시간에 변경되므로 RESTCONF 서버의 응답은 일반적으로 캐시되어서는 안 됩니다.\(SHOULD NOT\)

서버는 응답을 캐시해야 하는지 여부를 지정하는 모든 응답에 "Cache-Control" 헤더 필드를 포함해야 합니다.\(MUST\)

HTTP 캐싱에 의존하는 대신 클라이언트는 데이터 저장소 리소스\(또는 서버가 지원하는 경우 데이터 리소스\)에 대해 서버에서 반환한 "ETag" 및/또는 "Last-Modified" 헤더 필드를 추적해야 합니다. 리소스에 대한 검색 요청에는 "If-None-Match" 및/또는 "If-Modified-Since" 헤더 필드가 포함될 수 있으며, 이로 인해 리소스가 검색되지 않은 경우 서버는 "304 Not Modified" 상태 줄을 반환하게 됩니다. 변경되었습니다. 클라이언트는 HEAD 메소드를 사용하여 "ETag" 및 "Last-Modified" 헤더 필드를 포함해야 하는 메시지 헤더 필드만 검색할 수 있습니다\(이 메타데이터가 대상 리소스에 대해 유지되는 경우\).\(SHOULD, SHOULD\)

섹션 4.3에 설명된 대로 데이터 리소스에 대해 유지되는 "Last-Modified" 및 "ETag" 헤더의 값이 신뢰할 수 없을 수 있도록 액세스 제어가 데이터 리소스에 적용될 수 있습니다.

---
## **6.  Notifications**

RESTCONF 프로토콜은 YANG 정의 이벤트 알림을 지원합니다. 이 솔루션은 서버에서 보낸 이벤트\[W3C.REC-eventsource-20150203\] 전송 전략을 활용하면서 NETCONF 이벤트 알림\[RFC5277\]의 측면을 유지합니다.

---
### **6.1.  Server Support**

RESTCONF 서버는 RESTCONF 알림을 지원할 수 있습니다. 클라이언트는 "스트림" 목록에서 HTTP OPTIONS, HEAD 또는 GET 메서드를 사용하여 서버가 RESTCONF 알림을 지원하는지 확인할 수 있습니다. HTTP 오류 코드가 반환되는 경우\(예: "404 찾을 수 없음" 상태 표시줄\) 서버는 RESTCONF 알림을 지원하지 않습니다.\(MAY\)

---
### **6.2.  Event Streams**

알림을 지원하는 RESTCONF 서버는 각 알림 전달 서비스 액세스 지점에 대한 스트림 리소스를 채웁니다. RESTCONF 클라이언트는 "스트림" 목록에서 GET 메소드를 사용하여 RESTCONF 서버에서 지원되는 이벤트 스트림 목록을 검색할 수 있습니다.

"ietf-restconf-monitoring" 모듈의 "restconf-state/streams" 컨테이너 정의\(9.3절에 정의됨\)는 "streams" 리소스 내 개념적 하위 리소스의 구조와 구문을 지정하는 데 사용됩니다.

예를 들어:

클라이언트는 다음 요청을 보낼 수 있습니다.

```text
      GET /restconf/data/ietf-restconf-monitoring:restconf-state/\
          streams HTTP/1.1
      Host: example.com
      Accept: application/yang-data+xml
```

서버는 다음 응답을 보낼 수 있습니다.

```text
      HTTP/1.1 200 OK
      Content-Type: application/yang-data+xml

      <streams
        xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring">
         <stream>
            <name>NETCONF</name>
            <description>default NETCONF event stream</description>
            <replay-support>true</replay-support>
            <replay-log-creation-time>\
               2007-07-08T00:00:00Z\
            </replay-log-creation-time>
            <access>
               <encoding>xml</encoding>
               <location>https://example.com/streams/NETCONF\
               </location>
            </access>
            <access>
               <encoding>json</encoding>
               <location>https://example.com/streams/NETCONF-JSON\
               </location>
            </access>
         </stream>
```

<스트림\>

- <name\>SNMP</name\> <description\>SNMP 알림</description\> <replay-support\>false</replay-support\> <access\> <encoding\>xml</encoding\> <location\>https://example. com/streams/SNMP</location\> </access\> </stream\> <stream\> <name\>syslog-중요</name\> <description\>위험 및 더 높은 심각도</description\> <replay-support\>true</replay -support\> <replay-log-creation-time\> 2007-07-01T00:00:00Z </replay-log-creation-time\> <access\> <encoding\>xml</encoding\> <location\>\ https:// example.com/streams/syslog-tical\ </location\> </access\> </stream\> </streams\>

---
### **6.3.  Subscribing to Receive Notifications**

RESTCONF 클라이언트는 "스트림" 목록 항목이 포함된 "위치" 리프에 대한 HTTP GET 요청을 보내 구독 리소스\(알림 수신\)에 대한 URL을 결정할 수 있습니다. 서버에서 반환된 값은 실제 알림 구독에 사용될 수 있습니다.

클라이언트는 "수락" 유형 "text/event-stream"을 사용하여 서버에서 반환한 URL에 대한 HTTP GET 요청을 보냅니다.

서버는 서버에서 보낸 이벤트 \[W3C.REC-eventsource-20150203\] 전송 전략을 사용하여 연결을 이벤트 스트림으로 처리합니다.

서버는 이 리소스에 대한 GET 메소드에 대한 쿼리 매개변수를 지원할 수 있습니다. 이러한 매개변수는 각 이벤트 스트림에 따라 다릅니다.\(MAY\)

예를 들어:

클라이언트는 다음 요청을 보낼 수 있습니다.

```text
      GET /restconf/data/ietf-restconf-monitoring:restconf-state/\
          streams/stream=NETCONF/access=xml/location HTTP/1.1
      Host: example.com
      Accept: application/yang-data+xml
```

서버는 다음 응답을 보낼 수 있습니다.

```text
      HTTP/1.1 200 OK
      Content-Type: application/yang-data+xml

      <location
        xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring">\
        https://example.com/streams/NETCONF\
      </location>
```

그러면 RESTCONF 클라이언트는 이 URL 값을 사용하여 이벤트 스트림 모니터링을 시작할 수 있습니다.

```text
      GET /streams/NETCONF HTTP/1.1
      Host: example.com
      Accept: text/event-stream
      Cache-Control: no-cache
      Connection: keep-alive
```

RESTCONF 클라이언트는 서버가 HTTP 헤더 필드 "Accept-Encoding"을 사용하여 이벤트를 압축하도록 요청할 수 있습니다. 예를 들어:\(MAY\)

```text
      GET /streams/NETCONF HTTP/1.1
      Host: example.com
      Accept: text/event-stream
      Cache-Control: no-cache
      Connection: keep-alive
      Accept-Encoding: gzip, deflate
```

---
#### **6.3.1.  NETCONF Event Stream**

서버는 \[RFC5277\]의 섹션 3.2.3에 정의된 NETCONF 이벤트 스트림을 지원해야 합니다. 이 스트림에 대한 알림 메시지는 XML로 인코딩됩니다.\(SHOULD\)

서버는 NETCONF 이벤트 스트림의 의미론적 콘텐츠를 나타내는 추가 스트림을 지원할 수 있지만 다른 미디어 유형의 표현을 사용합니다.\(MAY\)

서버는 섹션 4.8에 정의된 "시작 시간", "중지 시간" 및 "필터" 쿼리 매개변수를 지원할 수 있습니다. 필터 매개변수 예시는 부록 B.3.6을 참조하세요.\(MAY\)

---
### **6.4.  Receiving Event Notifications**

RESTCONF 알림은 이벤트 스트림의 정의에 따라 인코딩됩니다.

이벤트 데이터의 구조는 \[RFC5277\] 섹션 4의 <notification\> 요소 정의를 기반으로 합니다. 이는 다음과 같이 XSD에 정의된 XML 네임스페이스를 사용하여 \[RFC5277\] 섹션 4의 <notification\> 요소에 대한 스키마를 준수해야 합니다.\(MUST\)

```text
     urn:ietf:params:xml:ns:netconf:notification:1.0
```

JSON 인코딩 목적의 경우 "알림" 요소의 모듈 이름은 "ietf-restconf"입니다.

"알림" 컨테이너 내에는 이벤트 시간과 이벤트 페이로드를 나타내는 두 개의 하위 노드가 있어야 합니다. "eventTime" 노드는 <notification\> 요소와 동일한 XML 네임스페이스 내에 정의됩니다. JSON 인코딩 목적을 위해 "ietf-restconf" 모듈 네임스페이스 내에 있도록 정의됩니다.

페이로드 요소의 이름과 네임스페이스는 알림 메시지를 나타내는 알림 stmt가 포함된 YANG 모듈에 의해 결정됩니다.

다음 예에서는 YANG 모듈 "example-mod"가 사용됩니다.

```text
     module example-mod {
       namespace "http://example.com/event/1.0";
       prefix ex;

       organization "Example, Inc.";
       contact "support at example.com";
       description "Example Notification Data Model Module.";
       revision "2016-07-07" {
         description "Initial version.";
         reference "example.com document 2-9976.";
       }

       notification event {
         description "Example notification event.";
         leaf event-class {
           type string;
           description "Event class identifier.";
         }
         container reporting-entity {
           description "Event specific information.";
           leaf card {
             type string;
             description "Line card identifier.";
           }
         }
         leaf severity {
           type string;
           description "Event severity description.";
         }
       }
     }
```

XML을 사용하여 인코딩된 SSE 이벤트 알림의 예:

```text
      data: <notification
      data:    xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
      data:    <eventTime>2013-12-21T00:01:00Z</eventTime>
      data:    <event xmlns="http://example.com/event/1.0">
      data:       <event-class>fault</event-class>
      data:       <reporting-entity>
      data:           <card>Ethernet0</card>
      data:       </reporting-entity>
      data:       <severity>major</severity>
      data:     </event>
      data: </notification>
```

JSON을 사용하여 인코딩된 SSE 이벤트 알림의 예:

```text
      data: {
      data:   "ietf-restconf:notification" : {
      data:     "eventTime" : "2013-12-21T00:01:00Z",
      data:     "example-mod:event" : {
      data:       "event-class" : "fault",
      data:       "reporting-entity" : { "card" : "Ethernet0" },
      data:       "severity" : "major"
      data:     }
      data:   }
      data: }
```

또는 XML이나 JSON 모두 공백을 구분하지 않으므로 위 메시지를 한 줄에 인코딩할 수 있습니다. 예를 들어:

```text
      XML:

      data: <notification xmlns="urn:ietf:params:xml:ns:netconf:notif\
      ication:1.0"><eventTime>2013-12-21T00:01:00Z</eventTime><event \
      xmlns="http://example.com/event/1.0"><event-class>fault</event-\
      class><reportingEntity><card>Ethernet0</card></reporting-entity>\
      <severity>major</severity></event></notification>

      JSON:

      data: {"ietf-restconf:notification":{"eventTime":"2013-12-21\
      T00:01:00Z","example-mod:event":{"event-class": "fault","repor\
      tingEntity":{"card":"Ethernet0"},"severity":"major"}}}
```

SSE 사양은 "event", "id" 및 "retry"라는 추가 필드를 지원합니다. RESTCONF 서버는 "재시도" 필드를 보낼 수 있으며, 그렇다면 RESTCONF 클라이언트는 이를 사용해야 합니다. RESTCONF 서버는 "event" 또는 "id" 필드를 보내면 안 됩니다. 왜냐하면 알림 자체의 내용과 중복되지 않는 의미 있는 값이 사용될 수 없기 때문입니다. "id" 필드를 보내지 않는 RESTCONF 서버는 HTTP 헤더 필드 "Last-Event-ID" \[W3C.REC-eventsource-20150203\]를 지원할 필요도 없습니다. "id" 필드를 전송하는 RESTCONF 서버는 클라이언트가 이벤트 스트림을 다시 시작할 위치를 지정하는 기본 수단으로 "start-time" 쿼리 매개변수를 지원해야 합니다.\(SHOULD, SHOULD NOT, SHOULD\)

---
## **7.  Error Reporting**

HTTP 상태 코드는 RESTCONF 작업의 성공 또는 실패를 보고하는 데 사용됩니다. NETCONF 오류 응답의 <rpc-error\> 요소에 포함된 오류 정보는 RESTCONF에서 사용하도록 조정되었으며 <errors\> 데이터 트리 정보는 상태 코드의 "4xx" 및 "5xx" 클래스에 대해 반환됩니다.

작업 리소스는 YANG "rpc" 문으로 정의되고 작업은 YANG "action" 문으로 정의되므로 NETCONF <error-tag\> 값에서 HTTP 상태 코드로의 매핑이 필요합니다. 사용할 특정 오류 태그 및 응답 코드는 데이터 모델에 따라 다르며 "action" 또는 "rpc" 문에 대한 YANG "설명" 문에 포함될 수 있습니다.

```text
              +-------------------------+------------------+
              | error-tag               | status code      |
              +-------------------------+------------------+
              | in-use                  | 409              |
              |                         |                  |
              | invalid-value           | 400, 404, or 406 |
              |                         |                  |
              | (request) too-big       | 413              |
              |                         |                  |
              | (response) too-big      | 400              |
              |                         |                  |
              | missing-attribute       | 400              |
              |                         |                  |
              | bad-attribute           | 400              |
              |                         |                  |
              | unknown-attribute       | 400              |
              |                         |                  |
              | bad-element             | 400              |
              |                         |                  |
              | unknown-element         | 400              |
              |                         |                  |
              | unknown-namespace       | 400              |
              |                         |                  |
              | access-denied           | 401 or 403       |
              |                         |                  |
              | lock-denied             | 409              |
              |                         |                  |
              | resource-denied         | 409              |
              |                         |                  |
              | rollback-failed         | 500              |
              |                         |                  |
              | data-exists             | 409              |
              |                         |                  |
              | data-missing            | 409              |
              |                         |                  |
              | operation-not-supported | 405 or 501       |
              |                         |                  |
              | operation-failed        | 412 or 500       |
              |                         |                  |
              | partial-operation       | 500              |
              |                         |                  |
              | malformed-message       | 400              |
              +-------------------------+------------------+
```

- <error-tag\>에서 상태 코드로 매핑

---
### **7.1.  Error Response Message**

모든 리소스 유형에 대한 요청 메시지에 대해 오류가 발생하고 반환될 상태 코드가 "4xx" 범위\(상태 코드 "403 Forbidden" 제외\)에 있는 경우 서버는 해당 정보가 포함된 응답 메시지 본문을 보내야 합니다. 섹션 8에 있는 "ietf-restconf" 모듈 내의 "yang-errors" YANG 데이터 템플릿에 의해 설명됩니다. 이 응답 메시지의 Content-Type은 반드시 "application/yang-data"여야 하며, 선택적으로 구조화된 구문 이름도 있어야 합니다. 접미사.\(SHOULD, MUST\)

클라이언트는 "Accept" 헤더에 적절한 미디어 유형을 지정하여 응답 메시지에 대해 원하는 인코딩을 지정해야 합니다. 클라이언트가 "Accept" 헤더를 지정하지 않은 경우 요청 메시지에 사용된 것과 동일한 구조화된 구문 이름 접미사를 사용해야 합니다. 그렇지 않으면 서버가 지원되는 메시지 인코딩 형식을 선택할 수 있습니다. 요청 메시지가 없는 경우 서버는 서버 기본 설정에 따라 "application/yang-data+xml" 또는 "application/yang-data+json"을 선택해야 합니다. 아래 예제를 제외하고 이 문서의 모든 예제에서는 오류가 있는 경우 XML 인코딩이 반환된다고 가정합니다.\(SHOULD, SHOULD, MUST\)

<errors\> 데이터에 대한 YANG 트리 다이어그램:

```text
     +---- errors
           +---- error*
              +---- error-type       enumeration
              +---- error-tag        string
              +---- error-app-tag?   string
              +---- error-path?      instance-identifier
              +---- error-message?   string
              +---- error-info?
```

RESTCONF 오류 메시지의 의미와 구문은 섹션 8에 있는 "yang-errors" YANG 데이터 템플릿 확장으로 정의됩니다.

```text
   Examples:
```

다음 예에서는 NETCONF 클라이언트가 데이터 저장소를 잠근 경우 발생할 수 있는 "잠금 거부" 오류에 대해 반환된 오류를 보여줍니다. RESTCONF 클라이언트가 데이터 리소스 삭제를 시도하고 있습니다. "Accept" 헤더 필드는 오류 메시지에 대해 원하는 인코딩을 지정하는 데 사용됩니다. 이 작업이 성공하면 응답 메시지 본문 내용이 없습니다.

```text
      DELETE /restconf/data/example-jukebox:jukebox/\
         library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 409 Conflict
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      {
        "ietf-restconf:errors" : {
          "error" : [
            {
              "error-type" : "protocol",
              "error-tag" : "lock-denied",
              "error-message" : "Lock failed; lock already held"
            }
          ]
        }
      }
```

다음 예에서는 데이터 리소스의 "data-exists" 오류에 대해 반환된 오류를 보여줍니다. "주크박스" 리소스가 이미 존재하므로 생성할 수 없습니다.

클라이언트는 다음을 보낼 수 있습니다.

```text
      POST /restconf/data/example-jukebox:jukebox HTTP/1.1
      Host: example.com
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 409 Conflict
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+xml
```

- <errors xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf"\> <error\> <error-type\>프로토콜</error-type\> <error-tag\>데이터가 존재합니다</error- 태그\> <error-path xmlns:rc="urn:ietf:params:xml:ns:yang:ietf-restconf" xmlns:jbox="https://example.com/ns/example-jukebox"\>\ /rc :restconf/rc:data/jbox:jukebox </error-path\> <error-message\> 데이터가 이미 존재합니다. 새 리소스를 생성할 수 없습니다. </error-message\> </error\> </errors\>

---
## **8.  RESTCONF Module**

"ietf-restconf" 모듈은 서버에 의해 데이터 저장소 콘텐츠로 구현되지 않는 확장 및 두 그룹 내의 개념적 정의를 정의합니다. 예를 들어, "restconf" 컨테이너는 최상위 데이터 노드\("/restconf/data" URI 아래\)로 구현하기 위한 것이 아닙니다.

"ietf-restconf" 모듈에는 프로토콜에 액세스할 수 있는 개체가 없으므로 YANG 트리 다이어그램이 표시되지 않습니다.

```text
   <CODE BEGINS>

   file "ietf-restconf@2017-01-26.yang"

   module ietf-restconf {
     yang-version 1.1;
     namespace "urn:ietf:params:xml:ns:yang:ietf-restconf";
     prefix "rc";

     organization
       "IETF NETCONF (Network Configuration) Working Group";

     contact
       "WG Web:   <https://datatracker.ietf.org/wg/netconf/>
        WG List:  <mailto:netconf@ietf.org>

        Author:   Andy Bierman
                  <mailto:andy@yumaworks.com>

        Author:   Martin Bjorklund
                  <mailto:mbj@tail-f.com>

        Author:   Kent Watsen
                  <mailto:kwatsen@juniper.net>";
```

설명

- "이 모듈에는 RESTCONF 프로토콜 메시지에 사용되는 기본 RESTCONF 미디어 유형 정의에 대한 개념적 YANG 사양이 포함되어 있습니다.

- 이 모듈 내의 YANG 정의는 어떤 종류의 구성 데이터도 나타내지 않습니다. 'restconf-media-type' YANG 확장 문은 XML 및 JSON 메시지 인코딩 목적을 위한 규범적인 구문을 제공합니다.

- Copyright \(c\) 2017 IETF Trust 및 코드 작성자로 식별된 사람. 판권 소유.

- 수정 여부에 관계없이 소스 및 바이너리 형식의 재배포 및 사용은 IETF 문서와 관련된 IETF Trust 법률 조항 섹션 4.c에 명시된 Simplified BSD 라이센스에 포함된 라이센스 조건에 따라 허용됩니다. \(http://trustee.ietf.org/license-info\).

```text
        This version of this YANG module is part of RFC 8040; see
        the RFC itself for full legal notices.";

     revision 2017-01-26 {
       description
         "Initial revision.";
       reference
         "RFC 8040: RESTCONF Protocol.";
     }
```

확장 양 데이터 {

- 인수 이름 { yin-element true; } 설명 "이 확장은 YANG에 정의된 개념적 데이터를 나타내는 YANG 데이터 템플릿을 지정하는 데 사용됩니다. 이는 프로토콜 컨텍스트 또는 특정 메시지 인코딩 형식과 관계없이 계층적 데이터를 설명하기 위한 것입니다. yang-data 확장 내의 데이터 정의 문은 이름이 'yang-data' 확장 문의 인수인 특정 YANG 데이터 템플릿에 대한 일반 구문입니다.

- 이 확장은 미디어 유형을 정의하지 않습니다. 이 확장을 사용하는 사양은 콘텐츠 미디어 유형을 포함하여 메시지 인코딩 규칙을 지정해야 합니다.\(MUST\)

- 필수 'name' 매개변수 값은 정의 중인 YANG 데이터 템플릿을 식별합니다. 여기에는 템플릿 이름이 포함됩니다.

- 이 확장은 최상위 명령문으로 표시되지 않는 한 무시됩니다. 여기에는 정확히 하나의 컨테이너 데이터 노드 정의를 생성하는 데이터 정의 문이 포함되어야 합니다. 따라서 YANG 데이터 템플릿의 인스턴스는 최상위 요소가 최상위 컨테이너에 해당하는 XML 인스턴스 문서로 변환될 수 있습니다.\(MUST\)

- 확장문을 사용하는 YANG 모듈의 모듈 이름과 네임스페이스 값은 이 확장 내의 데이터 정의문을 따르는 인스턴스 문서 데이터에 할당됩니다.

이 확장의 하위 설명은 다음을 따라야 합니다.

- YANG ABNF의 'data-def-stmt' 규칙.\(MUST\)

- XPath 문서 루트는 확장 문 자체이므로 문서 루트의 하위 노드는 이 확장 내의 data-def-stmt 하위 문으로 표시됩니다. 이 개념 문서는 다음 YANG 문에 대한 컨텍스트입니다.

```text
            - must-stmt
            - when-stmt
            - path-stmt
            - min-elements-stmt
            - max-elements-stmt
            - mandatory-stmt
            - unique-stmt
            - ordered-by
            - instance-identifier data type
```

- 다음 data-def-stmt 하위 문은 'yang-data' 확장 문 내에서 사용될 때 제한됩니다.

```text
            - The list-stmt is not required to have a key-stmt defined.
            - The if-feature-stmt is ignored if present.
            - The config-stmt is ignored if present.
            - The available identity values for any 'identityref'
              leaf or leaf-list nodes are limited to the module
              containing this extension statement and the modules
              imported into that module.
         ";
     }

     rc:yang-data yang-errors {
       uses errors;
     }

     rc:yang-data yang-api {
       uses restconf;
     }

     grouping errors {
       description
         "A grouping that contains a YANG container
          representing the syntax and semantics of a
          YANG Patch error report within a response message.";

       container errors {
         description
           "Represents an error report returned by the server if
            a request results in an error.";

         list error {
           description
             "An entry containing information about one
              specific error that occurred while processing
              a RESTCONF request.";
           reference
             "RFC 6241, Section 4.3.";

           leaf error-type {
             type enumeration {
               enum transport {
                 description
                   "The transport layer.";
               }
               enum rpc {
                 description
                   "The rpc or notification layer.";
               }
               enum protocol {
                 description
                   "The protocol operation layer.";
               }
               enum application {
                 description
                   "The server application layer.";
               }
             }
             mandatory true;
             description
               "The protocol layer where the error occurred.";
           }

           leaf error-tag {
             type string;
             mandatory true;
             description
               "The enumerated error-tag.";
           }

           leaf error-app-tag {
             type string;
             description
               "The application-specific error-tag.";
           }

           leaf error-path {
             type instance-identifier;
             description
               "The YANG instance identifier associated
                with the error node.";
           }

           leaf error-message {
             type string;
             description
               "A message describing the error.";
           }

           anydata error-info {
              description
                "This anydata value MUST represent a container with
                 zero or more data nodes representing additional
                 error information.";
           }
         }
       }
     }

     grouping restconf {
       description
         "Conceptual grouping representing the RESTCONF
          root resource.";

       container restconf {
         description
           "Conceptual container representing the RESTCONF
            root resource.";

         container data {
           description
             "Container representing the datastore resource.
              Represents the conceptual root of all state data
              and configuration data supported by the server.
              The child nodes of this container can be any data
              resources that are defined as top-level data nodes
              from the YANG modules advertised by the server in
              the 'ietf-yang-library' module.";
         }
```

컨테이너 작업 {

- 설명 "모든 운영 자원을 담는 컨테이너입니다.

- 각 리소스는 YANG 'rpc' 문의 RPC 작업 이름이 포함된 빈 리프로 표시됩니다.

- 예를 들어 'ietf-system' 모듈에 정의된 'system-restart' RPC 작업은 'ietf-system' 네임스페이스에서 빈 리프로 표시됩니다. 이는 개념적 리프이며 실제로 모듈에서 찾을 수 없습니다.

```text
                 module ietf-system {
                   leaf system-reset {
                     type empty;
                   }
                 }
```

- '시스템 다시 시작' RPC 작업을 호출하려면:

```text
                 POST /restconf/operations/ietf-system:system-restart
```

- 서버에서 지원하는 RPC 작업을 검색하려면:

```text
                 GET /restconf/operations
```

- XML에서 YANG 모듈 네임스페이스는 모듈을 식별합니다.

```text
                <system-restart
                   xmlns='urn:ietf:params:xml:ns:yang:ietf-system'/>
```

- JSON에서 YANG 모듈 이름은 모듈을 식별합니다.

```text
                { 'ietf-system:system-restart' : [null] }
             ";
         }

         leaf yang-library-version {
           type string {
             pattern '\d{4}-\d{2}-\d{2}';
           }
           config false;
           mandatory true;
           description
             "Identifies the revision date of the 'ietf-yang-library'
              module that is implemented by this RESTCONF server.
              Indicates the year, month, and day in YYYY-MM-DD
              numeric format.";
         }
       }
     }

   }

   <CODE ENDS>
```

---
## **9.  RESTCONF Monitoring**

"ietf-restconf-monitoring" 모듈은 서버에서 사용 가능한 RESTCONF 프로토콜 기능 및 이벤트 스트림에 대한 정보를 제공합니다. RESTCONF 서버는 "ietf-restconf-monitoring" 모듈을 구현해야 합니다.\(MUST\)

"ietf-restconf-monitoring" 모듈에 대한 YANG 트리 다이어그램:

```text
      +--ro restconf-state
         +--ro capabilities
         |  +--ro capability*   inet:uri
         +--ro streams
            +--ro stream* [name]
               +--ro name                        string
               +--ro description?                string
               +--ro replay-support?             boolean
               +--ro replay-log-creation-time?   yang:date-and-time
               +--ro access* [encoding]
                  +--ro encoding  string
                  +--ro location  inet:uri
```

---
### **9.1.  restconf-state/capabilities**

이 필수 컨테이너는 서버에서 지원하는 RESTCONF 프로토콜 기능 URI를 보유합니다.

서버는 이 컨테이너에 대해 마지막으로 수정된 타임스탬프를 유지하고 이 데이터 노드가 GET 또는 HEAD 메소드로 검색될 때 "Last-Modified" 헤더 필드를 반환할 수 있습니다. 데이터 저장소 리소스의 마지막 수정 타임스탬프는 이 하위 트리에 대한 변경 사항의 영향을 받지 않습니다.\(MAY\)

서버는 이 컨테이너에 대한 엔터티 태그를 유지해야 하며 이 데이터 노드가 GET 또는 HEAD 메서드로 검색될 때 "ETag" 헤더 필드를 반환해야 합니다. 데이터 저장소 리소스의 엔터티 태그는 이 하위 트리에 대한 변경 사항의 영향을 받지 않습니다.\(SHOULD\)

서버는 섹션 9.1.2에 정의된 대로 서버가 사용하는 "기본값" 모드에 대한 "기능" URI 리프 목록 항목을 포함해야 합니다.\(MUST\)

서버는 지원되는 각 선택적 프로토콜 기능을 식별하는 "성능" URI 리프 목록 항목을 포함해야 합니다. 여기에는 선택적 쿼리 매개변수가 포함되며 이 문서 외부에 정의된 다른 기능 URI가 포함될 수 있습니다.\(MUST, MAY\)

---
#### **9.1.1.  Query Parameter URIs**

서버에서 지원하는 특정 쿼리 매개변수\(섹션 4.8에 정의됨\)를 식별하기 위해 새로운 RESTCONF 기능 URI 세트가 정의되었습니다.

서버는 지원하는 각 선택적 쿼리 매개변수에 대한 "기능" 리프 목록 항목을 포함해야 합니다.\(MUST\)

```text
   +----------------+---------+---------------------------------------+
   | Name           | Section | URI                                   |
   |                |         |                                       |
   +----------------+---------+---------------------------------------+
   | depth          | 4.8.2   | urn:ietf:params:restconf:capability:  |
   |                |         | depth:1.0                             |
   |                |         |                                       |
   | fields         | 4.8.3   | urn:ietf:params:restconf:capability:  |
   |                |         | fields:1.0                            |
   |                |         |                                       |
   | filter         | 4.8.4   | urn:ietf:params:restconf:capability:  |
   |                |         | filter:1.0                            |
   |                |         |                                       |
   | replay         | 4.8.7   | urn:ietf:params:restconf:capability:  |
   |                | 4.8.8   | replay:1.0                            |
   |                |         |                                       |
   | with-defaults  | 4.8.9   | urn:ietf:params:restconf:capability:  |
   |                |         | with-defaults:1.0                     |
   +----------------+---------+---------------------------------------+

                       RESTCONF Query Parameter URIs
```

---
#### **9.1.2.  The "defaults" Protocol Capability URI**

이 URI는 데이터 리소스 요청의 기본 리프를 처리하기 위해 서버에서 사용하는 "기본 모드" 기본 처리 모드를 식별합니다. 이 프로토콜 기능 URI는 서버에서 지원되어야 하며 섹션 9.3에 정의된 "기능" 리프 목록에 나열되어야 합니다.\(MUST\)

```text
      +----------+--------------------------------------------------+
      | Name     | URI                                              |
      +----------+--------------------------------------------------+
      | defaults | urn:ietf:params:restconf:capability:defaults:1.0 |
      +----------+--------------------------------------------------+

                    RESTCONF "defaults" Capability URI
```

URI에는 아래 나열된 값 중 하나와 함께 "basic-mode"라는 쿼리 매개변수가 포함되어야 합니다.\(MUST\)

```text
   +------------+------------------------------------------------------+
   | Value      | Description                                          |
   +------------+------------------------------------------------------+
   | report-all | No data nodes are considered default                 |
   |            |                                                      |
   | trim       | Values set to the YANG default-stmt value are        |
   |            | default                                              |
   |            |                                                      |
   | explicit   | Values set by the client are never considered        |
   |            | default                                              |
   +------------+------------------------------------------------------+
```

"기본 모드" 정의는 "NETCONF에 대한 기본값 사용 기능" \[RFC6243\]에 지정되어 있습니다.

"basic-mode"가 "report-all"로 설정된 경우 서버는 \[RFC6243\]의 섹션 2.1에 정의된 기본 처리 동작을 준수해야 합니다.\(MUST\)

"basic-mode"가 "trim"으로 설정된 경우 서버는 \[RFC6243\]의 섹션 2.2에 정의된 기본 처리 동작을 준수해야 합니다.\(MUST\)

"basic-mode"가 "explicit"로 설정된 경우 서버는 \[RFC6243\]의 섹션 2.3에 정의된 기본 처리 동작을 준수해야 합니다.\(MUST\)

예\(표시 목적으로만 분할\):

```text
      urn:ietf:params:restconf:capability:defaults:1.0?
           basic-mode=explicit
```

---
### **9.2.  restconf-state/streams**

이 선택적 컨테이너는 서버에서 지원하는 이벤트 스트림에 대한 액세스를 제공합니다. 이벤트 스트림이 지원되지 않으면 서버는 이 컨테이너를 생략할 수 있습니다.\(MAY\)

서버는 지원하는 각 스트림 유형에 대한 "스트림" 목록 항목으로 이 컨테이너를 채웁니다. 각 스트림에는 이벤트 스트림 리소스를 나타내는 URI가 포함된 "이벤트"라는 리프가 포함되어 있습니다.

스트림 자원은 섹션 3.8에 정의되어 있습니다. 통지는 섹션 6에 정의되어 있습니다.

---
### **9.3.  RESTCONF Monitoring Module**

"ietf-restconf-monitoring" 모듈은 RESTCONF 프로토콜에 대한 모니터링 정보를 정의합니다.

\[RFC6991\]의 "ietf-yang-types" 및 "ietf-inet-types" 모듈은 일부 유형 정의를 위해 이 모듈에서 사용됩니다.

```text
   <CODE BEGINS>

   file "ietf-restconf-monitoring@2017-01-26.yang"

   module ietf-restconf-monitoring {
     namespace "urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring";
     prefix "rcmon";

     import ietf-yang-types { prefix yang; }
     import ietf-inet-types { prefix inet; }

     organization
       "IETF NETCONF (Network Configuration) Working Group";

     contact
       "WG Web:   <https://datatracker.ietf.org/wg/netconf/>
        WG List:  <mailto:netconf@ietf.org>

        Author:   Andy Bierman
                  <mailto:andy@yumaworks.com>

        Author:   Martin Bjorklund
                  <mailto:mbj@tail-f.com>

        Author:   Kent Watsen
                  <mailto:kwatsen@juniper.net>";
```

설명

- "이 모듈에는 RESTCONF 프로토콜에 대한 모니터링 정보가 포함되어 있습니다.

- Copyright \(c\) 2017 IETF Trust 및 코드 작성자로 식별된 사람. 판권 소유.

- 수정 여부에 관계없이 소스 및 바이너리 형식의 재배포 및 사용은 IETF 문서와 관련된 IETF Trust 법률 조항 섹션 4.c에 명시된 Simplified BSD 라이센스에 포함된 라이센스 조건에 따라 허용됩니다. \(http://trustee.ietf.org/license-info\).

```text
        This version of this YANG module is part of RFC 8040; see
        the RFC itself for full legal notices.";

     revision 2017-01-26 {
       description
         "Initial revision.";
       reference
         "RFC 8040: RESTCONF Protocol.";
     }

     container restconf-state {
       config false;
       description
         "Contains RESTCONF protocol monitoring information.";

       container capabilities {
         description
           "Contains a list of protocol capability URIs.";

         leaf-list capability {
           type inet:uri;
           description
             "A RESTCONF protocol capability URI.";
         }
       }

       container streams {
         description
           "Container representing the notification event streams
            supported by the server.";
          reference
            "RFC 5277, Section 3.4, <streams> element.";

         list stream {
           key name;
           description
             "Each entry describes an event stream supported by
              the server.";

           leaf name {
             type string;
             description
               "The stream name.";
             reference
               "RFC 5277, Section 3.4, <name> element.";
           }

           leaf description {
             type string;
             description
               "Description of stream content.";
             reference
               "RFC 5277, Section 3.4, <description> element.";
           }

           leaf replay-support {
             type boolean;
             default false;
             description
               "Indicates if replay buffer is supported for this stream.
                If 'true', then the server MUST support the 'start-time'
                and 'stop-time' query parameters for this stream.";
             reference
               "RFC 5277, Section 3.4, <replaySupport> element.";
           }

           leaf replay-log-creation-time {
             when "../replay-support" {
               description
                 "Only present if notification replay is supported.";
             }
             type yang:date-and-time;
             description
               "Indicates the time the replay log for this stream
                was created.";
             reference
               "RFC 5277, Section 3.4, <replayLogCreationTime>
                element.";
           }

           list access {
             key encoding;
             min-elements 1;
             description
               "The server will create an entry in this list for each
                encoding format that is supported for this stream.
                The media type 'text/event-stream' is expected
                for all event streams.  This list identifies the
                subtypes supported for this stream.";

             leaf encoding {
               type string;
               description
                 "This is the secondary encoding format within the
                  'text/event-stream' encoding used by all streams.
                  The type 'xml' is supported for XML encoding.
                  The type 'json' is supported for JSON encoding.";
             }

             leaf location {
               type inet:uri;
               mandatory true;
               description
                 "Contains a URL that represents the entry point
                  for establishing notification delivery via
                  server-sent events.";
             }
           }
         }
       }
     }

   }

   <CODE ENDS>
```

---
## **10.  YANG Module Library**

\[RFC7895\]에 정의된 "ietf-yang-library" 모듈은 RESTCONF 서버에서 사용하는 YANG 모듈 및 하위 모듈에 대한 정보를 제공합니다. RESTCONF 서버에는 구현이 필수입니다. 서버에서 사용하는 모든 YANG 모듈과 하위 모듈은 YANG 모듈 라이브러리에서 식별되어야 합니다.\(MUST\)

---
### **10.1.  modules-state/module**

이 필수 목록에는 서버에서 지원하는 각 YANG 데이터 모델 모듈에 대한 하나의 항목이 포함되어 있습니다. 서버에서 사용하는 모든 YANG 모듈에 대해 이 목록의 인스턴스가 있어야 합니다.\(MUST\)

이 목록의 내용은 \[RFC7895\]의 "모듈" YANG 목록 문에 정의되어 있습니다.

"ietf-restconf" 모듈에는 구현할 프로토콜 액세스 가능 개체가 없지만 다음 방법으로 \(직접 또는 간접적으로\) 가져오는 경우 서버가 YANG 라이브러리에 "ietf-restconf" 모듈을 나열할 수 있습니다. 구현된 모듈.

---
## **11.  IANA Considerations**
---
### **11.1.  The "restconf" Relation Type**

이 사양은 \[RFC5988\]에 정의된 "링크 관계 유형" 레지스트리에 "restconf" 관계 유형을 등록합니다.

```text
      Relation Name: restconf
```

- 설명: 이 HTTP 서버에 구성된 RESTCONF API의 루트를 식별합니다. "restconf" 관계는 RFC 8040에 정의된 API의 루트를 정의합니다. RESTCONF의 후속 개정판에서는 대체 관계 값을 사용하여 프로토콜 버전 관리를 지원합니다.

```text
      Reference: RFC 8040
```

---
### **11.2.  Registrations for New URIs and YANG Modules**

이 문서는 "IETF XML 레지스트리" \[RFC3688\]에 두 개의 URI를 네임스페이스로 등록합니다.

URI: urn:ietf:params:xml:ns:yang:ietf-restconf 등록자 연락처: IESG. XML: 해당 없음; 요청된 URI는 XML 네임스페이스입니다.

URI: urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring 등록자 연락처: IESG. XML: 해당 없음; 요청된 URI는 XML 네임스페이스입니다.

이 문서는 "YANG 모듈 이름" 레지스트리 \[RFC6020\]에 두 개의 YANG 모듈을 등록합니다.

```text
     name:         ietf-restconf
     namespace:    urn:ietf:params:xml:ns:yang:ietf-restconf
     prefix:       rc
     reference:    RFC 8040

     name:         ietf-restconf-monitoring
     namespace:    urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring
     prefix:       rcmon
     reference:    RFC 8040
```

---
### **11.3.  Media Types**
---
#### **11.3.1.  Media Type "application/yang-data+xml"**

```text
   Type name: application

   Subtype name: yang-data+xml

   Required parameters: None

   Optional parameters: None
```

인코딩 고려 사항: 8비트

- 각 개념적 YANG 데이터 노드는 \[RFC7950\]에 정의된 특정 YANG 데이터 노드 유형에 대한 XML 인코딩 규칙 및 정식 형식에 따라 인코딩됩니다.

보안 고려 사항: 관련 보안 고려 사항

- RESTCONF 메시지의 생성 및 소비는 RFC 8040의 섹션 12에서 논의됩니다. 추가 보안 고려 사항은 특정 YANG 데이터 모델의 의미에 따라 다릅니다. 각 YANG 모듈은 해당 모듈에 정의된 YANG 데이터에 대한 보안 고려 사항을 지정해야 합니다.

상호 운용성 고려 사항: RFC 8040은 다음을 지정합니다.

- 메시지를 준수하는 형식과 그 해석.

```text
   Published specification: RFC 8040
```

이 미디어 유형을 사용하는 애플리케이션: 인스턴스 문서

- YANG 정의 데이터 구조를 활용하는 프로토콜 또는 자동화 도구 내에서 사용되는 데이터 파서.

조각 식별자 고려 사항: 조각 식별자

- 이 유형은 정의되지 않았습니다. 모든 YANG 데이터 노드는 요청 URI의 경로를 사용하여 리소스로 액세스할 수 있습니다.

```text
   Additional information:

      Deprecated alias names for this type: N/A
      Magic number(s): N/A
      File extension(s): None
      Macintosh file type code(s): "TEXT"
```

자세한 내용은 연락할 사람 및 이메일 주소: RFC 8040의 작성자 주소 섹션을 참조하세요.

```text
   Intended usage: COMMON
```

이용 제한 : 해당 없음

작성자: RFC 8040의 작성자 주소 섹션을 참조하세요.

```text
   Change controller: Internet Engineering Task Force
      (mailto:iesg@ietf.org).

   Provisional registration? (standards tree only): no
```

---
#### **11.3.2.  Media Type "application/yang-data+json"**

```text
   Type name: application

   Subtype name: yang-data+json

   Required parameters: None

   Optional parameters: None
```

인코딩 고려 사항: 8비트

- 각 개념적 YANG 데이터 노드는 \[RFC7951\]에 따라 인코딩됩니다. 메타데이터 주석은 \[RFC7952\]에 따라 인코딩됩니다.

보안 고려 사항: 관련 보안 고려 사항

- RESTCONF 메시지의 생성 및 소비는 RFC 8040의 섹션 12에서 논의됩니다. 추가 보안 고려 사항은 특정 YANG 데이터 모델의 의미에 따라 다릅니다. 각 YANG 모듈은 해당 모듈에 정의된 YANG 데이터에 대한 보안 고려 사항을 지정해야 합니다.

상호 운용성 고려 사항: RFC 8040은 적합한 메시지의 형식과 그 해석을 지정합니다.

```text
   Published specification: RFC 8040
```

이 미디어 유형을 사용하는 애플리케이션: 인스턴스 문서

- YANG 정의 데이터 구조를 활용하는 프로토콜 또는 자동화 도구 내에서 사용되는 데이터 파서.

조각 식별자 고려 사항: 구문 및 의미

- 조각 식별자는 "application/json" 미디어 유형에 지정된 구문 및 의미와 동일합니다.

```text
   Additional information:

      Deprecated alias names for this type: N/A
      Magic number(s): N/A
      File extension(s): None
      Macintosh file type code(s): "TEXT"
```

자세한 내용은 연락할 사람 및 이메일 주소: RFC 8040의 작성자 주소 섹션을 참조하세요.

```text
   Intended usage: COMMON
```

이용 제한 : 해당 없음

작성자: RFC 8040의 작성자 주소 섹션을 참조하세요.

```text
   Change controller: Internet Engineering Task Force
      (mailto:iesg@ietf.org).

   Provisional registration? (standards tree only): no
```

---
### **11.4.  RESTCONF Capability URNs**

이 문서는 RESTCONF 기능 식별자에 대한 레지스트리를 정의합니다. 레지스트리 이름은 "RESTCONF Capability URN"입니다. 이 레지스트리에 대한 검토 정책은 "IETF 검토" \[RFC5226\]입니다. 등록소는 각 항목에 대해 다음을 기록해야 합니다.

o RESTCONF 기능의 이름. 관례적으로 이 이름은 콜론\(":"\) 문자로 시작됩니다.

o RESTCONF 기능에 대한 URN.

o 값을 등록하는 문서에 대한 참조.

이 문서는 "RESTCONF 기능 URN" 레지스트리에 여러 기능 식별자를 등록합니다.

```text
   Index           Capability Identifier
   ---------------------------------------------------------------------
   :defaults       urn:ietf:params:restconf:capability:defaults:1.0

   :depth          urn:ietf:params:restconf:capability:depth:1.0

   :fields         urn:ietf:params:restconf:capability:fields:1.0

   :filter         urn:ietf:params:restconf:capability:filter:1.0

   :replay         urn:ietf:params:restconf:capability:replay:1.0

   :with-defaults  urn:ietf:params:restconf:capability:with-defaults:1.0
```

---
### **11.5.  Registration of "restconf" URN Sub-namespace**

IANA는 \[RFC3553\]에 정의된 "등록된 프로토콜 매개변수 식별자를 위한 IETF URN 하위 네임스페이스" 레지스트리 내에 새로운 URN 하위 네임스페이스를 등록했습니다.

```text
      Registry Name: restconf

      Specification: RFC 8040

      Repository: "RESTCONF Capability URNs" registry (Section 11.4)
```

- 인덱스 값: 하위 매개변수는 필요한 경우 표준 URI 인코딩을 사용하여 UTF-8로 지정되어야 합니다.\(MUST\)

---
## **12.  Security Considerations**

섹션 2.1에는 "RESTCONF 서버는 TLS 프로토콜 \[RFC5246\]을 지원해야 합니다."라고 명시되어 있습니다. 이 언어는 RESTCONF 서버가 TLS 프로토콜의 향후 버전도 지원할 가능성을 열어 둡니다. 특히 TLS 1.3 \[TLS1.3\]에서는 TLS 1.3 문서의 부록 B.1에 설명된 대로 RESTCONF API에 대한 보안 문제를 일으킬 수 있는 0-RTT 핸드셰이크에 대한 지원을 도입합니다. 따라서 이 RFC에 대한 업데이트가 별도로 안내할 때까지 RESTCONF 서버는 0-RTT를 전혀 지원하지 않는 것이 좋습니다\(멱등성 요청의 경우에도 해당\).\(MUST, SHOULD\)

섹션 2.5에서는 TLS 클라이언트 인증서를 기반으로 한 인증을 권장하지만 "HTTP\(Hypertext Transfer Protocol\) 인증 체계 레지스트리"에 정의된 모든 인증 체계의 사용을 허용합니다. 구현에서는 이러한 방법의 장점이 크게 다르며 일부는 실험적인 것으로 간주될 수 있다는 점을 인식해야 합니다. 이러한 체계 중 하나를 선택하려면 해당 체계의 레지스트리 항목과 관련된 RFC의 보안 고려 사항 섹션을 읽은 후에 수행해야 합니다.\(SHOULD\)

이 메모에 정의된 "ietf-restconf-monitoring" YANG 모듈은 NETCONF 프로토콜 \[RFC6241\]을 통해 액세스되도록 설계되었습니다. 가장 낮은 NETCONF 계층은 보안 전송 계층이며, 반드시 구현해야 하는 보안 전송은 SSH\(Secure Shell\) \[RFC6242\]입니다. NETCONF 액세스 제어 모델 \[RFC6536\]은 특정 NETCONF 사용자에 대한 액세스를 사용 가능한 모든 NETCONF 프로토콜 작업 및 콘텐츠의 사전 구성된 하위 집합으로 제한하는 수단을 제공합니다.

가장 낮은 RESTCONF 계층은 HTTPS이며, 필수 보안 전송 구현은 TLS \[RFC5246\]입니다. RESTCONF 프로토콜은 NETCONF 액세스 제어 모델 \[RFC6536\]을 사용합니다. 이는 특정 RESTCONF 사용자에 대한 액세스를 사용 가능한 모든 RESTCONF 프로토콜 작업 및 콘텐츠의 사전 구성된 하위 집합으로 제한하는 수단을 제공합니다.

이 섹션에서는 RESTCONF 프로토콜에 의해 정의된 리소스에 대한 보안 고려 사항을 제공합니다. HTTPS에 대한 보안 고려사항은 \[RFC7230\]에 정의되어 있습니다. "ietf-restconf-monitoring" 모듈\(섹션 9\) 및 "ietf-yang-library" 모듈\(섹션 10\)을 제외하고 RESTCONF는 서버가 지원해야 하는 YANG 모듈을 지정하지 않습니다. RESTCONF에 의해 조작되는 다른 모듈에 대한 보안 고려 사항은 해당 YANG 모듈을 정의하는 문서에서 찾을 수 있습니다.

구성 정보는 본질적으로 민감합니다. 무결성 검사 없이 명확하게 전송되므로 장치는 전형적인 도청 및 허위 데이터 주입에 노출됩니다.

공격. 구성 정보에는 비밀번호, 사용자 이름, 서비스 설명, 토폴로지 정보가 포함되는 경우가 많으며 모두 민감한 정보입니다. 기존 관리 인터페이스를 사용한 운영 관행을 통해 관찰된 공격 패턴은 다양합니다. 구현자가 이 프로토콜을 구현할 때 이를 조사하고 고려하는 것이 현명할 것입니다.

환경에 따라 인증 전후에 서로 다른 권한이 허용될 수도 있습니다. RESTCONF 작업이 적절하게 인증되지 않은 경우 RESTCONF 서버는 "401 Unauthorized" 상태 라인을 반환해야 합니다. 인증 정보는 구성 정보의 형태로 교환될 수 있으며 이는 연결 보안을 보장하는 더욱 중요한 이유입니다. 클라이언트는 데이터 저장소 리소스에 대해 서버에서 반환한 "ETag" 및 "Last-Modified" 헤더 필드의 변경 사항을 모니터링하여 액세스 권한이 부여되지 않은 데이터 리소스의 구성 변경 사항을 감지할 수 있습니다.\(MUST\)

RESTCONF 서버 구현은 POST, PUT 및 PATCH 메서드를 통해 편집 요청을 이행하는 데 필요한 과도한 리소스 소비로 인한 시스템 중단을 방지하려고 시도해야 합니다\(SHOULD\). 이러한 구현에서는 사용 가능한 모든 메모리나 기타 리소스 유형을 소비하려고 시도하는 공격을 구성하는 것이 가능할 수 있습니다.\(SHOULD\)

---
## **13.  References**
---
### **13.1.  Normative References**

```text
   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", RFC 2046,
              DOI 10.17487/RFC2046, November 1996,
              <http://www.rfc-editor.org/info/rfc2046>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC3553]  Mealling, M., Masinter, L., Hardie, T., and G. Klyne, "An
              IETF URN Sub-namespace for Registered Protocol
              Parameters", BCP 73, RFC 3553, DOI 10.17487/RFC3553,
              June 2003, <http://www.rfc-editor.org/info/rfc3553>.

   [RFC3688]  Mealling, M., "The IETF XML Registry", BCP 81, RFC 3688,
              DOI 10.17487/RFC3688, January 2004,
              <http://www.rfc-editor.org/info/rfc3688>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <http://www.rfc-editor.org/info/rfc3986>.

   [RFC5234]  Crocker, D., Ed., and P. Overell, "Augmented BNF for
              Syntax Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <http://www.rfc-editor.org/info/rfc5234>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <http://www.rfc-editor.org/info/rfc5246>.

   [RFC5277]  Chisholm, S. and H. Trevino, "NETCONF Event
              Notifications", RFC 5277, DOI 10.17487/RFC5277, July 2008,
              <http://www.rfc-editor.org/info/rfc5277>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <http://www.rfc-editor.org/info/rfc5280>.

   [RFC5789]  Dusseault, L. and J. Snell, "PATCH Method for HTTP",
              RFC 5789, DOI 10.17487/RFC5789, March 2010,
              <http://www.rfc-editor.org/info/rfc5789>.

   [RFC5988]  Nottingham, M., "Web Linking", RFC 5988,
              DOI 10.17487/RFC5988, October 2010,
              <http://www.rfc-editor.org/info/rfc5988>.

   [RFC6020]  Bjorklund, M., Ed., "YANG - A Data Modeling Language for
              the Network Configuration Protocol (NETCONF)", RFC 6020,
              DOI 10.17487/RFC6020, October 2010,
              <http://www.rfc-editor.org/info/rfc6020>.

   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,
              and A. Bierman, Ed., "Network Configuration Protocol
              (NETCONF)", RFC 6241, DOI 10.17487/RFC6241, June 2011,
              <http://www.rfc-editor.org/info/rfc6241>.

   [RFC6242]  Wasserman, M., "Using the NETCONF Protocol over Secure
              Shell (SSH)", RFC 6242, DOI 10.17487/RFC6242, June 2011,
              <http://www.rfc-editor.org/info/rfc6242>.

   [RFC6243]  Bierman, A. and B. Lengyel, "With-defaults Capability for
              NETCONF", RFC 6243, DOI 10.17487/RFC6243, June 2011,
              <http://www.rfc-editor.org/info/rfc6243>.

   [RFC6415]  Hammer-Lahav, E., Ed., and B. Cook, "Web Host Metadata",
              RFC 6415, DOI 10.17487/RFC6415, October 2011,
              <http://www.rfc-editor.org/info/rfc6415>.

   [RFC6536]  Bierman, A. and M. Bjorklund, "Network Configuration
              Protocol (NETCONF) Access Control Model", RFC 6536,
              DOI 10.17487/RFC6536, March 2012,
              <http://www.rfc-editor.org/info/rfc6536>.

   [RFC6570]  Gregorio, J., Fielding, R., Hadley, M., Nottingham, M.,
              and D. Orchard, "URI Template", RFC 6570,
              DOI 10.17487/RFC6570, March 2012,
              <http://www.rfc-editor.org/info/rfc6570>.

   [RFC6991]  Schoenwaelder, J., Ed., "Common YANG Data Types",
              RFC 6991, DOI 10.17487/RFC6991, July 2013,
              <http://www.rfc-editor.org/info/rfc6991>.

   [RFC7159]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, DOI 10.17487/RFC7159,
              March 2014, <http://www.rfc-editor.org/info/rfc7159>.

   [RFC7230]  Fielding, R., Ed., and J. Reschke, Ed., "Hypertext
              Transfer Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <http://www.rfc-editor.org/info/rfc7230>.

   [RFC7231]  Fielding, R., Ed., and J. Reschke, Ed., "Hypertext
              Transfer Protocol (HTTP/1.1): Semantics and Content",
              RFC 7231, DOI 10.17487/RFC7231, June 2014,
              <http://www.rfc-editor.org/info/rfc7231>.

   [RFC7232]  Fielding, R., Ed., and J. Reschke, Ed., "Hypertext
              Transfer Protocol (HTTP/1.1): Conditional Requests",
              RFC 7232, DOI 10.17487/RFC7232, June 2014,
              <http://www.rfc-editor.org/info/rfc7232>.

   [RFC7235]  Fielding, R., Ed., and J. Reschke, Ed., "Hypertext
              Transfer Protocol (HTTP/1.1): Authentication", RFC 7235,
              DOI 10.17487/RFC7235, June 2014,
              <http://www.rfc-editor.org/info/rfc7235>.

   [RFC7320]  Nottingham, M., "URI Design and Ownership", BCP 190,
              RFC 7320, DOI 10.17487/RFC7320, July 2014,
              <http://www.rfc-editor.org/info/rfc7320>.

   [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525,
              May 2015, <http://www.rfc-editor.org/info/rfc7525>.

   [RFC7589]  Badra, M., Luchuk, A., and J. Schoenwaelder, "Using the
              NETCONF Protocol over Transport Layer Security (TLS) with
              Mutual X.509 Authentication", RFC 7589,
              DOI 10.17487/RFC7589, June 2015,
              <http://www.rfc-editor.org/info/rfc7589>.

   [RFC7895]  Bierman, A., Bjorklund, M., and K. Watsen, "YANG Module
              Library", RFC 7895, DOI 10.17487/RFC7895, June 2016,
              <http://www.rfc-editor.org/info/rfc7895>.

   [RFC7950]  Bjorklund, M., Ed., "The YANG 1.1 Data Modeling Language",
              RFC 7950, DOI 10.17487/RFC7950, August 2016,
              <http://www.rfc-editor.org/info/rfc7950>.

   [RFC7951]  Lhotka, L., "JSON Encoding of Data Modeled with YANG",
              RFC 7951, DOI 10.17487/RFC7951, August 2016,
              <http://www.rfc-editor.org/info/rfc7951>.

   [RFC7952]  Lhotka, L., "Defining and Using Metadata with YANG",
              RFC 7952, DOI 10.17487/RFC7952, August 2016,
              <http://www.rfc-editor.org/info/rfc7952>.

   [W3C.REC-eventsource-20150203]
              Hickson, I., "Server-Sent Events", World Wide Web
              Consortium Recommendation REC-eventsource-20150203,
              February 2015,
              <http://www.w3.org/TR/2015/REC-eventsource-20150203>.

   [W3C.REC-xml-20081126]
              Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E.,
              and F. Yergeau, "Extensible Markup Language (XML) 1.0
              (Fifth Edition)", World Wide Web Consortium Recommendation
              REC-xml-20081126, November 2008,
              <http://www.w3.org/TR/2008/REC-xml-20081126>.

   [XPath]    Clark, J. and S. DeRose, "XML Path Language (XPath)
              Version 1.0", World Wide Web Consortium Recommendation
              REC-xpath-19991116, November 1999,
              <http://www.w3.org/TR/1999/REC-xpath-19991116>.
```

---
### **13.2.  Informative References**

\[REST-논문\]

- Fielding, R., "아키텍처 스타일 및 네트워크 기반 소프트웨어 아키텍처의 설계", 2000.

```text
   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818,
              DOI 10.17487/RFC2818, May 2000,
              <http://www.rfc-editor.org/info/rfc2818>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              DOI 10.17487/RFC5226, May 2008,
              <http://www.rfc-editor.org/info/rfc5226>.
```

\[TLS1.3\] Rescorla, E., "TLS\(전송 계층 보안\) 프로토콜 버전 1.3", 진행 중인 작업, 초안-ietf-tls-tls13-18, 2016년 10월.

\[YANG-패치\]

- Bierman, A., Bjorklund, M. 및 K. Watsen, "YANG 패치 미디어 유형", 진행 중인 작업, 초안-ietf-netconf-yang-patch-14, 2016년 11월.

---
# **Appendix A.  Example YANG Module**

이 문서에 사용된 YANG 모듈 예제는 간단한 미디어 주크박스 인터페이스를 나타냅니다.

"example-jukebox" 모듈에 대한 YANG 트리 다이어그램:

```text
      +--rw jukebox!
         +--rw library
         |  +--rw artist* [name]
         |  |  +--rw name     string
         |  |  +--rw album* [name]
         |  |     +--rw name     string
         |  |     +--rw genre?   identityref
         |  |     +--rw year?    uint16
         |  |     +--rw admin
         |  |     |  +--rw label?              string
         |  |     |  +--rw catalogue-number?   string
         |  |     +--rw song* [name]
         |  |        +--rw name        string
         |  |        +--rw location    string
         |  |        +--rw format?     string
         |  |        +--rw length?     uint32
         |  +--ro artist-count?   uint32
         |  +--ro album-count?    uint32
         |  +--ro song-count?     uint32
         +--rw playlist* [name]
         |  +--rw name           string
         |  +--rw description?   string
         |  +--rw song* [index]
         |     +--rw index    uint32
         |     +--rw id       instance-identifier
         +--rw player
            +--rw gap?   decimal64

     rpcs:

     +---x play
         +--ro input
            +--ro playlist       string
            +--ro song-number    uint32
```

---
### **A.1.  "example-jukebox" YANG Module**

```text
   module example-jukebox {

      namespace "http://example.com/ns/example-jukebox";
      prefix "jbox";

      organization "Example, Inc.";
      contact "support at example.com";
      description "Example Jukebox Data Model Module.";
      revision "2016-08-15" {
        description "Initial version.";
        reference "example.com document 1-4673.";
      }

      identity genre {
        description
          "Base for all genre types.";
      }

      // abbreviated list of genre classifications
      identity alternative {
        base genre;
        description
          "Alternative music.";
      }
      identity blues {
        base genre;
        description
          "Blues music.";
      }
      identity country {
        base genre;
        description
          "Country music.";
      }
      identity jazz {
        base genre;
        description
          "Jazz music.";
      }
      identity pop {
        base genre;
        description
          "Pop music.";
      }

      identity rock {
        base genre;
        description
          "Rock music.";
      }

      container jukebox {
        presence
          "An empty container indicates that the jukebox
           service is available.";

        description
          "Represents a 'jukebox' resource, with a library, playlists,
           and a 'play' operation.";

        container library {

          description
            "Represents the 'jukebox' library resource.";

          list artist {
            key name;
            description
              "Represents one 'artist' resource within the
               'jukebox' library resource.";

            leaf name {
              type string {
                length "1 .. max";
              }
              description
                "The name of the artist.";
            }

            list album {
              key name;
              description
                "Represents one 'album' resource within one
                 'artist' resource, within the jukebox library.";

              leaf name {
                type string {
                  length "1 .. max";
                }
                description
                  "The name of the album.";
              }

              leaf genre {
                type identityref { base genre; }
                description
                  "The genre identifying the type of music on
                   the album.";
              }

              leaf year {
                type uint16 {
                  range "1900 .. max";
                }
                description
                  "The year the album was released.";
              }

              container admin {
                description
                  "Administrative information for the album.";

                leaf label {
                  type string;
                  description
                    "The label that released the album.";
                }
                leaf catalogue-number {
                  type string;
                  description
                    "The album's catalogue number.";
                }
              }

              list song {
                key name;
                description
                  "Represents one 'song' resource within one
                   'album' resource, within the jukebox library.";

                leaf name {
                  type string {
                     length "1 .. max";
                  }
                  description
                    "The name of the song.";
                }

                leaf location {
                  type string;
                  mandatory true;
                  description
                    "The file location string of the
                     media file for the song.";
                }
                leaf format {
                  type string;
                  description
                    "An identifier string for the media type
                     for the file associated with the
                     'location' leaf for this entry.";
                }
                leaf length {
                  type uint32;
                  units "seconds";
                  description
                    "The duration of this song in seconds.";
                }
              }   // end list 'song'
            }   // end list 'album'
          }  // end list 'artist'

          leaf artist-count {
             type uint32;
             units "artists";
             config false;
             description
               "Number of artists in the library.";
          }
          leaf album-count {
             type uint32;
             units "albums";
             config false;
             description
               "Number of albums in the library.";
          }
          leaf song-count {
             type uint32;
             units "songs";
             config false;
             description
               "Number of songs in the library.";
          }
        }  // end library

        list playlist {
          key name;
          description
            "Example configuration data resource.";

          leaf name {
            type string;
            description
              "The name of the playlist.";
          }
          leaf description {
            type string;
            description
              "A comment describing the playlist.";
          }
          list song {
            key index;
            ordered-by user;

            description
              "Example nested configuration data resource.";

            leaf index {    // not really needed
              type uint32;
              description
                "An arbitrary integer index for this playlist song.";
            }
            leaf id {
              type instance-identifier;
              mandatory true;
              description
                "Song identifier.  Must identify an instance of
                 /jukebox/library/artist/album/song/name.";
            }
          }
        }

        container player {
          description
            "Represents the jukebox player resource.";

          leaf gap {
            type decimal64 {
              fraction-digits 1;
              range "0.0 .. 2.0";
            }
            units "tenths of seconds";
            description
              "Time gap between each song.";
          }
        }
      }

      rpc play {
        description
          "Control function for the jukebox player.";
        input {
          leaf playlist {
            type string;
            mandatory true;
            description
              "The playlist name.";
          }
          leaf song-number {
            type uint32;
            mandatory true;
            description
              "Song number in playlist to play.";
          }
        }
      }
   }
```

---
# **Appendix B.  RESTCONF Message Examples**

이 문서 내의 예제에서는 섹션 8에 정의된 표준 YANG 모듈 "ietf-restconf"와 부록 A.1에 정의된 비표준 예제 YANG 모듈 "example-jukebox"를 사용합니다.

이 섹션에서는 몇 가지 일반적인 RESTCONF 메시지 교환을 보여줍니다.

---
### **B.1.  Resource Retrieval Examples**
---
#### **B.1.1.  Retrieve the Top-Level API Resource**

클라이언트는 RESTCONF 루트 리소스를 검색하여 시작합니다.

```text
      GET /.well-known/host-meta HTTP/1.1
      Host: example.com
      Accept: application/xrd+xml
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Content-Type: application/xrd+xml
      Content-Length: nnn

      <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
          <Link rel='restconf' href='/restconf'/>
      </XRD>
```

그런 다음 클라이언트는 루트 리소스 "/restconf"를 사용하여 최상위 API 리소스를 검색할 수 있습니다.

```text
      GET /restconf HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      {
        "ietf-restconf:restconf" : {
          "data" : {},
          "operations" : {},
          "yang-library-version" : "2016-06-21"
        }
      }
```

응답 콘텐츠가 XML로 인코딩되도록 요청하려면 다음 요청 예시와 같이 "Accept" 헤더를 사용할 수 있습니다.

```text
      GET /restconf HTTP/1.1
      Host: example.com
      Accept: application/yang-data+xml
```

서버는 어느 쪽이든 동일한 개념적 데이터를 반환합니다. 이는 다음과 같습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Content-Type: application/yang-data+xml

      <restconf xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
        <data/>
        <operations/>
        <yang-library-version>2016-06-21</yang-library-version>
      </restconf>
```

---
#### **B.1.2.  Retrieve the Server Module Information**

YANG 라이브러리 모듈은 시간이 지남에 따라 변경될 수 있습니다. 클라이언트는 이전 섹션에서 설명한 대로 API 리소스에서 서버가 지원하는 "ietf-yang-library" 모듈의 개정 날짜를 검색할 수 있습니다.

이 예에서 클라이언트는 JSON 형식으로 서버에서 모듈 정보를 검색합니다.

```text
      GET /restconf/data/ietf-yang-library:modules-state HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Last-Modified: Thu, 26 Jan 2017 14:00:14 GMT
      Content-Type: application/yang-data+json

      {
        "ietf-yang-library:modules-state" : {
          "module-set-id" : "5479120c17a619545ea6aff7aa19838b036ebbd7",
          "module" : [
            {
              "name" : "foo",
              "revision" : "2012-01-02",
              "schema" : "https://example.com/modules/foo/2012-01-02",
              "namespace" : "http://example.com/ns/foo",
              "feature" : [ "feature1", "feature2" ],
              "deviation" : [
                {
                  "name" : "foo-dev",
                  "revision" : "2012-02-16"
                }
              ],
              "conformance-type" : "implement"
            },
            {
              "name" : "ietf-yang-library",
              "revision" : "2016-06-21",
              "schema" : "https://example.com/modules/\
                ietf-yang-library/2016-06-21",
              "namespace" :
                "urn:ietf:params:xml:ns:yang:ietf-yang-library",
              "conformance-type" : "implement"
            },
            {
              "name" : "foo-types",
              "revision" : "2012-01-05",
              "schema" :
                "https://example.com/modules/foo-types/2012-01-05",
              "namespace" : "http://example.com/ns/foo-types",
              "conformance-type" : "import"
            },

            {
              "name" : "bar",
              "revision" : "2012-11-05",
              "schema" : "https://example.com/modules/bar/2012-11-05",
              "namespace" : "http://example.com/ns/bar",
              "feature" : [ "bar-ext" ],
              "conformance-type" : "implement",
              "submodule" : [
                {
                  "name" : "bar-submod1",
                  "revision" : "2012-11-05",
                  "schema" :
                   "https://example.com/modules/bar-submod1/2012-11-05"
                },
                {
                  "name" : "bar-submod2",
                  "revision" : "2012-11-05",
                  "schema" :
                   "https://example.com/modules/bar-submod2/2012-11-05"
                }
              ]
            }
          ]
        }
      }
```

---
#### **B.1.3.  Retrieve the Server Capability Information**

이 예에서 클라이언트는 서버에서 XML 형식으로 기능 정보를 검색하고 있으며 서버는 모든 RESTCONF 쿼리 매개변수와 하나의 공급업체 매개변수를 지원합니다.

```text
      GET /restconf/data/ietf-restconf-monitoring:restconf-state/\
          capabilities HTTP/1.1
      Host: example.com
      Accept: application/yang-data+xml
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Last-Modified: Thu, 26 Jan 2017 16:00:14 GMT
      Content-Type: application/yang-data+xml

      <capabilities
          xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring">
       <capability>\
        urn:ietf:params:restconf:capability:defaults:1.0?\
           basic-mode=explicit\
       </capability>
       <capability>\
        urn:ietf:params:restconf:capability:with-defaults:1.0\
       </capability>
       <capability>\
        urn:ietf:params:restconf:capability:depth:1.0\
       </capability>
       <capability>\
        urn:ietf:params:restconf:capability:fields:1.0\
       </capability>
       <capability>\
        urn:ietf:params:restconf:capability:filter:1.0\
       </capability>
       <capability>\
        urn:ietf:params:restconf:capability:start-time:1.0\
       </capability>
       <capability>\
        urn:ietf:params:restconf:capability:stop-time:1.0\
       </capability>
       <capability>\
        http://example.com/capabilities/myparam\
       </capability>
      </capabilities>
```

---
### **B.2.  Data Resource and Datastore Resource Examples**
---
#### **B.2.1.  Create New Data Resources**

"라이브러리" 리소스 내에 새로운 "아티스트" 리소스를 생성하기 위해 클라이언트는 다음 요청을 보낼 수 있습니다.

```text
      POST /restconf/data/example-jukebox:jukebox/library HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+json

      {
        "example-jukebox:artist" : [
          {
            "name" : "Foo Fighters"
          }
        ]
      }
```

리소스가 생성되면 서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 201 Created
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Location: https://example.com/restconf/data/\
          example-jukebox:jukebox/library/artist=Foo%20Fighters
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      ETag: "b3830f23a4c"
```

"주크박스" 리소스 내에서 이 아티스트에 대한 새 "앨범" 리소스를 생성하기 위해 클라이언트는 다음 요청을 보낼 수 있습니다.

```text
      POST /restconf/data/example-jukebox:jukebox/\
          library/artist=Foo%20Fighters HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+xml

      <album xmlns="http://example.com/ns/example-jukebox">
        <name>Wasting Light</name>
        <year>2011</year>
      </album>
```

리소스가 생성되면 서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 201 Created
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Location: https://example.com/restconf/data/\
          example-jukebox:jukebox/library/artist=Foo%20Fighters/\
          album=Wasting%20Light
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      ETag: "b8389233a4c"
```

---
#### **B.2.2.  Detect Datastore Resource Entity-Tag Change**

이 예에서 서버는 데이터 저장소의 마지막 변경 타임스탬프만 지원합니다. 클라이언트가 이전 요청에 대한 응답에서 "Last-Modified" 헤더를 캐시했다고 가정합니다. 이 값은 키 값이 "Wasting Light"인 "앨범" 목록 항목을 패치하기 위해 다음 요청의 "If-Unmodified-Since" 헤더에서 사용됩니다. '장르' 필드만 업데이트됩니다.

```text
      PATCH /restconf/data/example-jukebox:jukebox/\
          library/artist=Foo%20Fighters/album=Wasting%20Light/\
          genre HTTP/1.1
      Host: example.com
      If-Unmodified-Since: Thu, 26 Jan 2017 20:56:30 GMT
      Content-Type: application/yang-data+json

      { "example-jukebox:genre" : "example-jukebox:alternative" }
```

이 예에서는 "If-Unmodified-Since" 헤더에 지정된 시간 이후 데이터 저장소 리소스가 변경되었습니다. 서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 412 Precondition Failed
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 19:41:00 GMT
      ETag: "b34aed893a4c"
```

---
#### **B.2.3.  Edit a Datastore Resource**

이 예에서는 example-system 모듈의 "system"이라는 최상위 데이터 리소스가 있고 이 컨테이너에 "enable-jukebox-streaming"이라는 하위 리프가 있다고 가정합니다.

```text
      container system {
        leaf enable-jukebox-streaming {
          type boolean;
        }
      }
```

이 예에서는 주크박스 스트리밍을 활성화하고 두 개의 "아티스트" 리소스 각각에 "앨범" 하위 리소스를 추가하기 위해 클라이언트가 PATCH를 사용하여 두 개의 최상위 리소스를 한 번에 수정합니다.

```text
      PATCH /restconf/data HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+xml
```

<data xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf"\>

- <system xmlns="http://example.com/ns/example-system"\> <enable-jukebox-streaming\>true</enable-jukebox-streaming\> </system\> <jukebox xmlns="http:// example.com/ns/example-jukebox"\> <library\> <artist\> <name\>Foo Fighters</name\> <album\> <name\>One by One</name\> <year\>2012</year\> </album \> </artist\> <artist\> <name\>Nick Cave and the Bad Seeds</name\> <album\> <name\>Tender Prey</name\> <year\>1988</year\> </album\> </artist\> < /library\> </jukebox\> </data\>

---
#### **B.2.4.  Replace a Datastore Resource**

이 예에서는 전체 구성 데이터 저장소 콘텐츠가 교체됩니다. <data\> 요소에는 없지만 서버에는 있는 모든 하위 노드가 삭제됩니다.

```text
      PUT /restconf/data HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+xml
```

<data xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf"\>

- <jukebox xmlns="http://example.com/ns/example-jukebox"\> <라이브러리\> <아티스트\> <name\>푸 파이터스</name\> <앨범\> <name\>One by One</name\> < year\>2012</year\> </album\> </artist\> <artist\> <name\>Nick Cave and the Bad Seeds</name\> <album\> <name\>Tender Prey</name\> <year\>1988</year\> \> </album\> </artist\> </library\> </jukebox\> </data\>

---
#### **B.2.5.  Edit a Data Resource**

이 예에서 클라이언트는 데이터 리소스에 대한 PATCH를 전송하여 "앨범" 하위 리소스를 추가하여 하나의 데이터 노드를 수정합니다.

```text
      PATCH /restconf/data/example-jukebox:jukebox/library/\
         artist=Nick%20Cave%20and%20the%20Bad%20Seeds HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+xml
```

<아티스트 xmlns="http://example.com/ns/example-jukebox"\>

- <name\>Nick Cave and the Bad Seeds</name\> <album\> <name\>The Good Son</name\> <year\>1990</year\> </album\> </artist\>

---
### **B.3.  Query Parameter Examples**
---
#### **B.3.1.  "content" Parameter**

"content" 매개변수는 GET 메소드 요청에 대해 서버가 반환하는 데이터 하위 리소스 유형\(구성 및/또는 비구성\)을 선택하는 데 사용됩니다.

이 예에서는 구성 및 비구성 하위 리소스가 있는 간단한 YANG 목록이 사용됩니다.

```text
     container events {
       list event {
         key name;
         leaf name { type string; }
         leaf description { type string; }
         leaf event-count {
           type uint32;
           config false;
         }
       }
     }

   Example 1: content=all
```

모든 하위 리소스를 검색하려면 "content" 매개변수를 "all"로 설정하거나 기본값이므로 생략합니다. 클라이언트는 다음을 보낼 수 있습니다.

```text
      GET /restconf/data/example-events:events?\
          content=all HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Content-Type: application/yang-data+json

      {
        "example-events:events" : {
          "event" : [
            {
              "name" : "interface-up",
              "description" : "Interface up notification count",
              "event-count" : 42
            },
            {
              "name" : "interface-down",
              "description" : "Interface down notification count",
              "event-count" : 4
            }
          ]
        }
      }

   Example 2: content=config
```

구성 하위 리소스만 검색하려면 "content" 매개변수가 "config"로 설정됩니다. "ETag" 및 "Last-Modified" 헤더는 "content" 매개변수 값이 "config"인 경우에만 반환됩니다.

```text
      GET /restconf/data/example-events:events?\
          content=config HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 16:45:20 GMT
      ETag: "eeeada438af"
      Cache-Control: no-cache
      Content-Type: application/yang-data+json

      {
        "example-events:events" : {
          "event" : [
            {
              "name" : "interface-up",
              "description" : "Interface up notification count"
            },
            {
              "name" : "interface-down",
              "description" : "Interface down notification count"
            }
          ]
        }
      }

   Example 3: content=nonconfig
```

구성이 아닌 하위 리소스만 검색하려면 "content" 매개변수가 "nonconfig"로 설정됩니다. 구성 상위 항목\(있는 경우\) 및 목록 키 리프\(있는 경우\)도 반환됩니다. 클라이언트는 다음을 보낼 수 있습니다.

```text
      GET /restconf/data/example-events:events?\
         content=nonconfig HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Content-Type: application/yang-data+json

      {
        "example-events:events" : {
          "event" : [
            {
              "name" : "interface-up",
              "event-count" : 42
            },
            {
              "name" : "interface-down",
              "event-count" : 4
            }
          ]
        }
      }
```

---
#### **B.3.2.  "depth" Parameter**

"깊이" 매개변수는 GET 메소드 요청에 대해 서버가 반환하는 하위 리소스의 수준 수를 제한하는 데 사용됩니다.

"깊이" 매개변수는 지정된 대상 리소스 수준에서 수준 계산을 시작하므로 깊이 수준 "1"에는 대상 리소스 수준 자체만 포함됩니다. "2"의 깊이 수준에는 대상 리소스 수준과 해당 하위 노드가 포함됩니다.

이 예에서는 "깊이" 매개변수의 다양한 값이 최상위 "주크박스" 데이터 리소스 검색에 대한 응답 내용에 어떤 영향을 미치는지 보여줍니다.

```text
   Example 1: depth=unbounded
```

모든 하위 리소스를 검색하려면 "깊이" 매개변수가 존재하지 않거나 기본값 "unbounded"로 설정됩니다.

```text
      GET /restconf/data/example-jukebox:jukebox?\
          depth=unbounded HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Content-Type: application/yang-data+json

      {
        "example-jukebox:jukebox" : {
          "library" : {
            "artist" : [
              {
                "name" : "Foo Fighters",
                "album" : [
                  {
                    "name" : "Wasting Light",
                    "genre" : "example-jukebox:alternative",
                    "year" : 2011,
                    "song" : [
                      {
                        "name" : "Wasting Light",
                        "location" :
                          "/media/foo/a7/wasting-light.mp3",
                        "format" : "MP3",
                        "length" : 286
                      },

                      {
                        "name" : "Rope",
                        "location" : "/media/foo/a7/rope.mp3",
                        "format" : "MP3",
                        "length" : 259
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "playlist" : [
            {
              "name" : "Foo-One",
              "description" : "example playlist 1",
              "song" : [
                {
                  "index" : 1,
                  "id" : "/example-jukebox:jukebox/library\
                     /artist[name='Foo Fighters']\
                     /album[name='Wasting Light']\
                     /song[name='Rope']"
                },
                {
                  "index" : 2,
                  "id" : "/example-jukebox:jukebox/library\
                     /artist[name='Foo Fighters']\
                     /album[name='Wasting Light']\
                     /song[name='Bridge Burning']"
                }
              ]
            }
          ],
          "player" : {
            "gap" : 0.5
          }
        }
      }

   Example 2: depth=1
```

지정된 대상 리소스에 대해 하나 이상의 리소스 인스턴스가 존재하는지 확인하려면 값 "1"이 사용됩니다.

```text
      GET /restconf/data/example-jukebox:jukebox?depth=1 HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Content-Type: application/yang-data+json

      {
        "example-jukebox:jukebox" : {}
      }

   Example 3: depth=3
```

깊이 수준을 대상 리소스와 두 개의 하위 리소스 레이어로 제한하려면 값 "3"이 사용됩니다.

```text
      GET /restconf/data/example-jukebox:jukebox?depth=3 HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Cache-Control: no-cache
      Content-Type: application/yang-data+json

      {
        "example-jukebox:jukebox" : {
          "library" : {
            "artist" : {}
          },
          "playlist" : [
            {
              "name" : "Foo-One",
              "description" : "example playlist 1",
              "song" : {}
            }
          ],
          "player" : {
            "gap" : 0.5
          }
        }
      }
```

---
#### **B.3.3.  "fields" Parameter**

이 예에서 클라이언트는 JSON 형식의 데이터 저장소 리소스를 검색하지만 "modules-state/module" 목록만 검색하고 각 목록 항목에서는 "name" 및 "revision" 노드만 검색합니다. 서버에서 반환된 최상위 노드는 대상 리소스 노드\(이 예에서는 "데이터"\)와 일치합니다. "module-set-id" 리프는 필드 표현식에서 선택되지 않았기 때문에 반환되지 않습니다.

```text
      GET /restconf/data?fields=ietf-yang-library:modules-state/\
          module(name;revision) HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      {
        "ietf-restconf:data" : {
          "ietf-yang-library:modules-state" : {
            "module" : [
              {
                "name" : "example-jukebox",
                "revision" : "2016-08-15"
              },
              {
                "name" : "ietf-inet-types",
                "revision" : "2013-07-15"
              },
              {
                "name" : "ietf-restconf-monitoring",
                "revision" : "2017-01-26"
              },
              {
                "name" : "ietf-yang-library",
                "revision" : "2016-06-21"
              },
              {
                "name" : "ietf-yang-types",
                "revision" : "2013-07-15"
              }
            ]
          }
        }
      }
```

---
#### **B.3.4.  "insert" Parameter**

이 예에서는 "Foo-One" 재생 목록의 새로운 첫 번째 노래 항목이 생성됩니다.

클라이언트의 요청:

```text
      POST /restconf/data/example-jukebox:jukebox/\
          playlist=Foo-One?insert=first HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+json

      {
        "example-jukebox:song" : [
           {
             "index" : 1,
             "id" : "/example-jukebox:jukebox/library\
                /artist[name='Foo Fighters']\
                /album[name='Wasting Light']\
                /song[name='Rope']"
           }
         ]
      }
```

서버의 응답:

```text
      HTTP/1.1 201 Created
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      Location: https://example.com/restconf/data/\
          example-jukebox:jukebox/playlist=Foo-One/song=1
      ETag: "eeeada438af"
```

---
#### **B.3.5.  "point" Parameter**

이 예에서 클라이언트는 첫 번째 노래 다음에 "Foo-One" 재생 목록에 새 노래 항목을 삽입합니다.

클라이언트의 요청:

```text
      POST /restconf/data/example-jukebox:jukebox/\
          playlist=Foo-One?insert=after&point=\
          %2Fexample-jukebox%3Ajukebox\
          %2Fplaylist%3DFoo-One%2Fsong%3D1 HTTP/1.1
      Host: example.com
      Content-Type: application/yang-data+json

      {
        "example-jukebox:song" : [
           {
             "index" : 2,
             "id" : "/example-jukebox:jukebox/library\
                /artist[name='Foo Fighters']\
                /album[name='Wasting Light']\
                /song[name='Bridge Burning']"
           }
         ]
      }
```

서버의 응답:

```text
      HTTP/1.1 201 Created
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      Location: https://example.com/restconf/data/\
          example-jukebox:jukebox/playlist=Foo-One/song=2
      ETag: "abcada438af"
```

---
#### **B.3.6.  "filter" Parameter**

다음 URI는 알림 필터 사양의 몇 가지 예를 보여줍니다.

```text
      // filter = /event/event-class='fault'
      GET /streams/NETCONF?filter=%2Fevent%2Fevent-class%3D'fault'

      // filter = /event/severity<=4
      GET /streams/NETCONF?filter=%2Fevent%2Fseverity%3C%3D4

      // filter = /linkUp|/linkDown
      GET /streams/SNMP?filter=%2FlinkUp%7C%2FlinkDown

      // filter = /*/reporting-entity/card!='Ethernet0'
      GET /streams/NETCONF?\
         filter=%2F*%2Freporting-entity%2Fcard%21%3D'Ethernet0'

      // filter = /*/email-addr[contains(.,'company.com')]
      GET /streams/critical-syslog?\
         filter=%2F*%2Femail-addr[contains(.%2C'company.com')]

      // Note: The module name is used as the prefix.
      // filter = (/example-mod:event1/name='joe' and
      //           /example-mod:event1/status='online')
      GET /streams/NETCONF?\
        filter=(%2Fexample-mod%3Aevent1%2Fname%3D'joe'%20and\
                %20%2Fexample-mod%3Aevent1%2Fstatus%3D'online')

      // To get notifications from just two modules (e.g., m1 + m2)
      // filter=(/m1:* or /m2:*)
      GET /streams/NETCONF?filter=(%2Fm1%3A*%20or%20%2Fm2%3A*)
```

---
#### **B.3.7.  "start-time" Parameter**

다음 URI는 "시작 시간" 쿼리 매개변수의 예를 보여줍니다.

```text
      // start-time = 2014-10-25T10:02:00Z
      GET /streams/NETCONF?start-time=2014-10-25T10%3A02%3A00Z
```

---
#### **B.3.8.  "stop-time" Parameter**

다음 URI는 "stop-time" 쿼리 매개변수의 예를 보여줍니다.

```text
      // start-time = 2014-10-25T10:02:00Z
      // stop-time = 2014-10-25T12:31:00Z
      GET /mystreams/NETCONF?start-time=2014-10-25T10%3A02%3A00Z\
         &stop-time=2014-10-25T12%3A31%3A00Z
```

---
#### **B.3.9.  "with-defaults" Parameter**

서버가 \[RFC6243\]의 부록 A.1에 정의된 모듈 "example"을 구현하고, 서버의 데이터 저장소가 \[RFC6243\]의 부록 A.2에 정의된 것과 같다고 가정합니다.

"defaults" 프로토콜 기능 URI\(9.1.2절\)에 있는 서버의 "basic-mode" 매개변수가 "trim"인 경우 인터페이스 "eth1"에 대한 다음 요청은 다음과 같을 수 있습니다.

쿼리 매개변수가 없는 경우:

```text
      GET /restconf/data/example:interfaces/interface=eth1 HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      {
        "example:interface" : [
          {
            "name" : "eth1",
            "status" : "up"
          }
        ]
      }
```

"mtu" 리프는 기본 "1500"으로 설정되어 있고 서버의 기본 처리 "basic-mode" 매개변수가 "trim"이므로 누락되었습니다.

쿼리 매개변수 사용:

```text
      GET /restconf/data/example:interfaces/interface=eth1\
          ?with-defaults=report-all HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
```

서버는 다음과 같이 응답할 수 있습니다.

```text
      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Content-Type: application/yang-data+json

      {
        "example:interface" : [
          {
            "name" : "eth1",
            "mtu" : 1500,
            "status" : "up"
          }
        ]
      }
```

"with-defaults" 쿼리 매개변수를 사용하여 "report-all" 모드가 요청되었기 때문에 서버는 "mtu" 리프를 반환합니다.

---
# **Acknowledgements**

저자는 이 문서에 기여한 Ladislav Lhotka, Juergen Schoenwaelder, Rex Fernando, Robert Wilton 및 Jonathan Hansford에게 감사의 말씀을 전하고 싶습니다.

저자는 이 문서에 대한 훌륭한 기술 검토를 해주신 다음 분들께 감사의 말씀을 전합니다: Mehmet Ersue, Mahesh Jethanandani, Qin Wu, Joe Clarke, Bert Wijnen, Ladislav Lhotka, Rodney Cummings, Frank Xialiang, Tom Petch, Robert Sparks, Balint Uveges , Randy Presuhn, Sue Hares, Mark Nottingham, Benoit Claise, Dale Worley 및 Lionel Morand.

Andy Bierman이 이 자료에 기여한 내용은 계약 번호 W15P7T-13-C-A616에 따라 미 육군, 우주 및 지상파 통신국\(S&TCD\)이 지원한 작업을 기반으로 합니다. 이 자료에 표현된 모든 의견, 조사 결과, 결론 또는 권장 사항은 저자의 것이며 반드시 S&TCD의 견해를 반영하는 것은 아닙니다.

---
# **Authors' Addresses**

```text
   Andy Bierman
   YumaWorks

   Email: andy@yumaworks.com

   Martin Bjorklund
   Tail-f Systems

   Email: mbj@tail-f.com

   Kent Watsen
   Juniper Networks

   Email: kwatsen@juniper.net
```
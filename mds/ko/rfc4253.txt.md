

```text
Network Working Group                                          T. Ylonen
Request for Comments: 4253              SSH Communications Security Corp
Category: Standards Track                                C. Lonvick, Ed.
                                                     Cisco Systems, Inc.
                                                            January 2006
```

- SSH\(Secure Shell\) 전송 계층 프로토콜

---
# **Status of This Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(2006\).

---
# **Abstract**

SSH\(Secure Shell\)는 안전하지 않은 네트워크를 통한 보안 원격 로그인 및 기타 보안 네트워크 서비스를 위한 프로토콜입니다.

이 문서에서는 일반적으로 TCP/IP 위에서 실행되는 SSH 전송 계층 프로토콜에 대해 설명합니다. 이 프로토콜은 다양한 보안 네트워크 서비스의 기초로 사용될 수 있습니다. 강력한 암호화, 서버 인증 및 무결성 보호를 제공합니다. 압축을 제공할 수도 있습니다.

키 교환 방법, 공개 키 알고리즘, 대칭 암호화 알고리즘, 메시지 인증 알고리즘, 해시 알고리즘이 모두 협상됩니다.

이 문서에서는 또한 Diffie-Hellman 키 교환 방법과 SSH 전송 계층 프로토콜을 구현하는 데 필요한 최소 알고리즘 세트에 대해 설명합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................3
   2. Contributors ....................................................3
   3. Conventions Used in This Document ...............................3
   4. Connection Setup ................................................4
      4.1. Use over TCP/IP ............................................4
      4.2. Protocol Version Exchange ..................................4
   5. Compatibility With Old SSH Versions .............................5
      5.1. Old Client, New Server .....................................6
      5.2. New Client, Old Server .....................................6
      5.3. Packet Size and Overhead ...................................6
   6. Binary Packet Protocol ..........................................7
      6.1. Maximum Packet Length ......................................8
      6.2. Compression ................................................8
      6.3. Encryption .................................................9
      6.4. Data Integrity ............................................12
      6.5. Key Exchange Methods ......................................13
      6.6. Public Key Algorithms .....................................13
   7. Key Exchange ...................................................15
      7.1. Algorithm Negotiation .....................................17
      7.2. Output from Key Exchange ..................................20
      7.3. Taking Keys Into Use ......................................21
   8. Diffie-Hellman Key Exchange ....................................21
      8.1. diffie-hellman-group1-sha1 ................................23
      8.2. diffie-hellman-group14-sha1 ...............................23
   9. Key Re-Exchange ................................................23
   10. Service Request ...............................................24
   11. Additional Messages ...........................................25
      11.1. Disconnection Message ....................................25
      11.2. Ignored Data Message .....................................26
      11.3. Debug Message ............................................26
      11.4. Reserved Messages ........................................27
   12. Summary of Message Numbers ....................................27
   13. IANA Considerations ...........................................27
   14. Security Considerations .......................................28
   15. References ....................................................29
      15.1. Normative References .....................................29
      15.2. Informative References ...................................30
   Authors' Addresses ................................................31
   Trademark Notice ..................................................31
```

---
## **1.  Introduction**

SSH 전송 계층은 안전한 하위 수준 전송 프로토콜입니다. 강력한 암호화, 암호화 호스트 인증 및 무결성 보호를 제공합니다.

이 프로토콜 수준의 인증은 호스트 기반입니다. 이 프로토콜은 사용자 인증을 수행하지 않습니다. 이 프로토콜 위에 사용자 인증을 위한 더 높은 수준의 프로토콜을 설계할 수 있습니다.

프로토콜은 매개변수 협상을 허용하고 왕복 횟수를 최소화하기 위해 간단하고 유연하게 설계되었습니다. 키 교환 방법, 공개 키 알고리즘, 대칭 암호화 알고리즘, 메시지 인증 알고리즘, 해시 알고리즘이 모두 협상됩니다. 대부분의 환경에서는 전체 키 교환, 서버 인증, 서비스 요청 및 서비스 요청 수락 알림을 위해 2번의 왕복만 필요할 것으로 예상됩니다. 최악의 경우는 3왕복이다.

---
## **2.  Contributors**

이 문서 세트의 주요 원본 기여자는 Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen\(모두 SSH Communications Security Corp 소속\) 및 Markku-Juhani O. Saarinen\(Jyvaskyla 대학교\)입니다. Darren Moffat는 이 문서 세트의 최초 편집자였으며 또한 매우 상당한 기여를 했습니다.

수년에 걸쳐 많은 사람들이 이 문서의 개발에 기여했습니다. 인정받아야 할 사람들로는 Mats Andersson, Ben Harris, Bill Sommerfeld, Brent McClure, Niels Moller, Damien Miller, Derek Fawcus, Frank Cusack, Heikki Nousiainen, Jakob Schlyter, Jeff Van Dyke, Jeffrey Altman, Jeffrey Hutzelman, Jon Bright, Joseph이 있습니다. Galbraith, Ken Hornstein, Markus Friedl, Martin Forssen, Nicolas Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse 및 Tadayoshi Kohno. 여기에 그들의 이름을 나열한다는 것은 그들이 이 문서를 지지한다는 의미가 아니라 문서에 기여했다는 의미입니다.

---
## **3.  Conventions Used in This Document**

SSH 프로토콜과 관련된 모든 문서는 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY"라는 키워드를 사용해야 합니다. 요구 사항을 설명하는 "선택 사항"입니다. 이러한 키워드는 \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

이 문서에 나타나는 키워드 "개인 사용", "계층적 할당", "선착순", "전문가 검토", "사양 필요", "IESG 승인", "IETF 합의" 및 "표준 조치" 네임스페이스 할당을 설명하는 데 사용되는 용어는 \[RFC2434\]에 설명된 대로 해석됩니다.\(MUST\)

프로토콜 필드와 이를 채울 수 있는 값은 이 문서 세트에 정의되어 있습니다. 프로토콜 필드는 메시지 정의에서 정의됩니다. 예를 들어 SSH\_MSG\_CHANNEL\_DATA는 다음과 같이 정의됩니다.

```text
      byte      SSH_MSG_CHANNEL_DATA
      uint32    recipient channel
      string    data
```

이러한 문서 전체에서 필드를 참조할 때 필드는 작은따옴표 안에 표시됩니다. 해당 필드를 채울 값이 참조되면 큰따옴표 안에 표시됩니다. 위의 예를 사용하면 'data'에 가능한 값은 "foo" 및 "bar"입니다.

---
## **4.  Connection Setup**

SSH는 8비트의 깨끗하고 이진 투명한 전송을 통해 작동합니다. 기본 전송은 전송 오류로부터 보호해야 합니다. 이러한 오류로 인해 SSH 연결이 종료되기 때문입니다.\(SHOULD\)

클라이언트가 연결을 시작합니다.

---
### **4.1.  Use over TCP/IP**

TCP/IP를 통해 사용될 때 서버는 일반적으로 포트 22에서 연결을 수신합니다. 이 포트 번호는 IANA에 등록되었으며 SSH에 공식적으로 할당되었습니다.

---
### **4.2.  Protocol Version Exchange**

연결이 설정되면 양측은 식별 문자열을 보내야 합니다. 이 식별 문자열은 다음과 같아야 합니다.\(MUST, MUST\)

```text
      SSH-protoversion-softwareversion SP comments CR LF
```

이 문서 세트에 정의된 프로토콜은 버전 2.0이므로 '프로토버전'은 "2.0"이어야 합니다. '설명' 문자열은 선택사항입니다. '주석' 문자열이 포함된 경우 '공백' 문자\(위에서 SP, ASCII 32로 표시됨\)는 '소프트웨어 버전'과 '주석' 문자열을 구분해야 합니다. 식별은 단일 캐리지 리턴\(CR\) 및 단일 라인 피드\(LF\) 문자\(각각 ASCII 13 및 10\)로 종료되어야 합니다. 유지를 원하는 시행자\(MUST, MAY, MUST, MUST\)

이 프로토콜의 문서화되지 않은 이전 버전과의 호환성을 위해 이 문서의 섹션 5에 설명된 이유로 캐리지 리턴 문자의 존재를 예상하지 않고 식별 문자열을 처리해야 할 수 있습니다. 널 문자는 전송되어서는 안 됩니다. 문자열의 최대 길이는 캐리지 리턴 및 줄 바꿈을 포함하여 255자입니다.\(MUST NOT\)

캐리지 리턴 및 라인 피드 앞의 식별 문자열 부분은 Diffie-Hellman 키 교환에 사용됩니다\(섹션 8 참조\).

서버는 버전 문자열을 보내기 전에 다른 데이터 줄을 보낼 수도 있습니다. 각 줄은 캐리지 리턴\(Carriage Return\)과 줄 바꿈\(Line Feed\)으로 종료되어야 합니다\(SHOULD\). 이러한 줄은 "SSH-"로 시작해서는 안 되며 ISO-10646 UTF-8 \[RFC3629\]\(언어가 지정되지 않음\)로 인코딩되어야 합니다. 클라이언트는 이러한 라인을 처리할 수 있어야 합니다. 이러한 줄은 자동으로 무시되거나 클라이언트 사용자에게 표시될 수 있습니다. 표시되는 경우 \[SSH-ARCH\]에서 설명한 대로 제어 문자 필터링을 사용해야 합니다. 이 기능의 주요 용도는 TCP 래퍼가 연결을 끊기 전에 오류 메시지를 표시하도록 허용하는 것입니다.\(MAY, SHOULD, MUST NOT, MUST, MAY, SHOULD\)

'protoversion' 및 'softwareversion' 문자열은 모두 공백 문자와 빼기 기호\(-\)를 제외하고 인쇄 가능한 US-ASCII 문자로 구성되어야 합니다. 'softwareversion' 문자열은 주로 호환성 확장을 실행하고 구현 기능을 나타내는 데 사용됩니다. '설명' 문자열에는 사용자 문제를 해결하는 데 유용할 수 있는 추가 정보가 포함되어야 합니다. 따라서 유효한 식별 문자열의 예는 다음과 같습니다.\(MUST, SHOULD\)

```text
      SSH-2.0-billsSSH_3.6.3q3<CR><LF>
```

이 식별 문자열은 선택적 '설명' 문자열을 포함하지 않으므로 'softwareversion' 문자열 바로 뒤에 CR 및 LF로 종료됩니다.

이 식별자를 전송한 후 즉시 키 교환이 시작됩니다. 식별 문자열 다음의 모든 패킷은 섹션 6에 설명된 바이너리 패킷 프로토콜을 사용해야 합니다.\(MUST\)

---
## **5.  Compatibility With Old SSH Versions**

앞서 설명한 대로 이 프로토콜에 지정된 '프로토버전'은 "2.0"입니다. 이 프로토콜의 이전 버전은 공식적으로 문서화되지 않았지만 "1.x"의 '프로토버전'\(예: "1.5" 또는 "1.3"\)을 사용하는 것으로 널리 알려져 있습니다. 이 글을 쓰는 시점에서 SSH의 많은 구현은 프로토콜 버전 2.0을 활용하고 있지만 여전히 이전 버전을 사용하는 장치가 있는 것으로 알려져 있습니다. 전환 기간 동안 일할 수 있는 능력이 중요합니다.

이전 버전의 프로토콜을 사용하는 설치된 SSH 클라이언트 및 서버와 호환되는 방식입니다. 이 섹션의 정보는 SSH 버전 1.x와의 호환성을 지원하는 구현에만 관련됩니다. 관심 있는 분들을 위해 1.x 프로토콜에 대해 유일하게 알려진 문서는 소스 코드 \[ssh-1.2.30\]와 함께 제공되는 README 파일에 포함되어 있습니다.

---
### **5.1.  Old Client, New Server**

서버 구현은 이전 버전과의 호환성을 가능하게 하는 구성 가능한 호환성 플래그를 지원할 수 있습니다\(MAY\). 이 플래그가 켜져 있으면 서버는 '프로토버전'을 "1.99"로 식별해야 합니다. 프로토콜 2.0을 사용하는 클라이언트는 이를 "2.0"과 동일한 것으로 식별할 수 있어야 합니다. 이 모드에서 서버는 식별 문자열 뒤에 캐리지 리턴 문자\(ASCII 13\)를 전송해서는 안 됩니다.\(MAY, SHOULD, MUST, SHOULD NOT\)

호환 모드에서 서버는 클라이언트로부터 식별 문자열을 수신할 때까지 식별 문자열을 보낸 후 추가 데이터를 전송해서는 안 됩니다. 그런 다음 서버는 클라이언트가 이전 프로토콜을 사용하고 있는지 확인하고 필요한 경우 이전 프로토콜로 되돌릴 수 있습니다. 호환 모드에서 서버는 식별 문자열 앞에 추가 데이터를 보내면 안 됩니다.\(SHOULD NOT, MUST NOT\)

이전 클라이언트와의 호환성이 필요하지 않은 경우 서버는 식별 문자열 바로 뒤에 초기 키 교환 데이터를 보낼 수 있습니다.\(MAY\)

---
### **5.2.  New Client, Old Server**

새 클라이언트는 식별 문자열 다음에 추가 데이터를 즉시 보낼 수 있으므로\(서버의 식별 문자열을 받기 전\) 클라이언트가 서버가 오래되었다는 것을 알게 되면 이전 프로토콜이 이미 손상되었을 수 있습니다. 이런 일이 발생하면 클라이언트는 서버에 대한 연결을 닫고 이전 프로토콜을 사용하여 다시 연결해야 합니다.\(MAY, SHOULD\)

---
### **5.3.  Packet Size and Overhead**

일부 독자들은 새로운 헤더, 패딩, 메시지 인증 코드\(MAC\)로 인한 패킷 크기 증가를 걱정할 것입니다. 최소 패킷 크기는 28바이트 정도입니다\(협상된 알고리즘에 따라 다름\). 큰 패킷의 경우 증가가 미미하지만 1바이트 패킷\(텔넷 유형 세션\)의 경우 매우 중요합니다. 그러나 거의 모든 경우에 문제가 되지 않는 몇 가지 요인이 있습니다.

o TCP/IP 헤더의 최소 크기는 32바이트입니다. 따라서 실제로는 33바이트에서 51바이트\(대략\)로 증가합니다.

o 이더넷 패킷의 데이터 필드의 최소 크기는 46바이트입니다\[RFC0894\]. 따라서 증가폭은 5바이트를 넘지 않습니다. 이더넷 헤더를 고려하면 증가율은 10% 미만입니다.

o 인터넷에 있는 텔넷 유형 데이터의 전체 비율은

- 패킷 크기가 증가하더라도 무시할 수 있습니다.

패킷 크기 증가가 상당한 영향을 미칠 수 있는 유일한 환경은 느린 모뎀 회선을 통한 PPP \[RFC1661\]입니다\(PPP는 TCP/IP 헤더를 압축하여 패킷 크기 증가를 강조합니다\). 그러나 최신 모뎀을 사용하면 전송하는 데 필요한 시간이 2밀리초 정도인데, 이는 사람이 입력할 수 있는 것보다 훨씬 빠릅니다.

최대 패킷 크기와 관련된 문제도 있습니다. 화면 업데이트 지연을 최소화하려면 대화형 세션에 대해 지나치게 큰 패킷을 원하지 않습니다. 최대 패킷 크기는 각 채널에 대해 개별적으로 협상됩니다.

---
## **6.  Binary Packet Protocol**

각 패킷의 형식은 다음과 같습니다.

```text
      uint32    packet_length
      byte      padding_length
      byte[n1]  payload; n1 = packet_length - padding_length - 1
      byte[n2]  random padding; n2 = padding_length
      byte[m]   mac (Message Authentication Code - MAC); m = mac_length
```

패킷\_길이

- 'mac' 또는 'packet\_length' 필드 자체를 제외하고 바이트 단위의 패킷 길이입니다.

padding\_length

- '랜덤 패딩'의 길이\(바이트\)입니다.

유효 탑재량

- 패킷의 유용한 내용. 압축이 협상된 경우 이 필드는 압축됩니다. 처음에는 압축이 "없음"이어야 합니다.\(MUST\)

무작위 패딩

- \(packet\_length || padding\_length || 페이로드 || 랜덤 패딩\)의 총 길이가 암호 블록 크기의 배수 또는 8 중 하나인 임의 길이 패딩입니다.

- 더 크다. 패딩은 최소 4바이트 이상이어야 합니다. 패딩은 임의의 바이트로 구성되어야 합니다. 최대 패딩 크기는 255바이트입니다.\(MUST, SHOULD\)

맥

- 메시지 인증 코드. 메시지 인증이 협상된 경우 이 필드에는 MAC 바이트가 포함됩니다. 처음에 MAC 알고리즘은 "없음"이어야 합니다.\(MUST\)

'packet\_length', 'padding\_length', 'payload' 및 'random padding'의 연결 길이는 암호 블록 크기의 배수 또는 8 중 더 큰 값이어야 합니다. 스트림 암호를 사용하는 경우에도 이 제약 조건을 적용해야 합니다. 'packet\_length' 필드도 암호화되어 있으므로 이를 처리하려면 패킷을 보내거나 받을 때 특별한 주의가 필요합니다. 또한 다양한 양의 '임의 패딩'을 삽입하면 트래픽 분석을 방해하는 데 도움이 될 수 있습니다.\(MUST, MUST\)

패킷의 최소 크기는 16바이트\(또는 암호화 블록 크기 중 더 큰 값\)바이트\(+'mac'\)입니다. 구현에서는 패킷의 처음 8바이트\(또는 암호화 블록 크기 중 더 큰 쪽\)를 수신한 후 길이를 해독해야 합니다.\(SHOULD\)

---
### **6.1.  Maximum Packet Length**

모든 구현은 압축되지 않은 페이로드 길이가 32768바이트 이하이고 총 패킷 크기가 35000바이트 이하인 패킷\('packet\_length', 'padding\_length', 'payload', 'random padding' 및 'mac 포함\)을 처리할 수 있어야 합니다\(MUST\). '\). 최대 35000바이트는 위에서 언급한 압축되지 않은 길이보다 큰 임의로 선택한 값입니다. 구현은 필요할 수 있는 더 긴 패킷을 지원해야 합니다\(SHOULD\). 예를 들어, 구현이 매우 많은 수의 인증서를 전송하려는 경우 식별 문자열이 상대방이 이를 처리할 수 있음을 나타내면 더 큰 패킷이 전송될 수 있습니다. 그러나 구현에서는 서비스 거부 및/또는 버퍼 오버플로 공격을 방지하기 위해 패킷 길이가 합리적인지 확인해야 합니다.\(MUST, SHOULD, MAY, SHOULD\)

---
### **6.2.  Compression**

압축이 협상된 경우 '페이로드' 필드\(및 해당 필드만\)가 협상된 알고리즘을 사용하여 압축됩니다. 'packet\_length' 필드와 'mac'은 압축된 페이로드에서 계산됩니다. 압축 후 암호화가 수행됩니다.

압축은 방법에 따라 상태 저장이 가능합니다. 압축은 각 방향에 대해 독립적이어야 하며, 구현에서는 각 방향에 대해 독립적인 알고리즘 선택을 허용해야 합니다\(MUST\). 그러나 실제로는 압축 방법이 양방향에서 동일한 것이 권장됩니다.\(MAY, MUST, SHOULD\)

현재 정의된 압축 방법은 다음과 같습니다.

```text
      none     REQUIRED        no compression
      zlib     OPTIONAL        ZLIB (LZ77) compression
```

"zlib" 압축은 \[RFC1950\] 및 \[RFC1951\]에 설명되어 있습니다. 압축 컨텍스트는 각 키 교환 후에 초기화되고 한 패킷에서 다음 패킷으로 전달되며 각 패킷의 끝에서 부분 플러시만 수행됩니다. 부분 플러시는 현재 압축된 블록이 종료되고 모든 데이터가 출력된다는 의미입니다. 현재 블록이 저장된 블록이 아닌 경우 현재 블록 뒤에 하나 이상의 빈 블록이 추가되어 현재 블록의 블록 끝 코드 시작부터 끝까지 계산하여 최소 8비트가 있는지 확인합니다. 패킷 페이로드의.

\[SSH-ARCH\] 및 \[SSH-NUMBERS\]에 지정된 대로 추가 방법을 정의할 수 있습니다.

---
### **6.3.  Encryption**

암호화 알고리즘과 키는 키 교환 중에 협상됩니다. 암호화가 적용되면 각 패킷의 패킷 길이, 패딩 길이, 페이로드 및 패딩 필드를 지정된 알고리즘으로 암호화해야 합니다.\(MUST\)

한 방향으로 전송된 모든 패킷의 암호화된 데이터는 단일 데이터 스트림으로 간주되어야 합니다. 예를 들어, 초기화 벡터는 한 패킷의 끝에서 다음 패킷의 시작 부분까지 전달되어야 합니다. 모든 암호는 유효 키 길이가 128비트 이상인 키를 사용해야 합니다.\(SHOULD, SHOULD, SHOULD\)

각 방향의 암호는 서로 독립적으로 실행되어야 합니다. 구현 시 로컬 정책에서 여러 알고리즘이 허용되는 경우 각 방향에 대한 알고리즘이 독립적으로 선택되도록 허용해야 합니다\(MUST\). 그러나 실제로는 동일한 알고리즘을 양방향으로 사용하는 것이 권장됩니다.\(MUST, MUST, SHOULD\)

현재 정의된 암호는 다음과 같습니다.

```text
      3des-cbc         REQUIRED          three-key 3DES in CBC mode
      blowfish-cbc     OPTIONAL          Blowfish in CBC mode
      twofish256-cbc   OPTIONAL          Twofish in CBC mode,
                                         with a 256-bit key
      twofish-cbc      OPTIONAL          alias for "twofish256-cbc"
                                         (this is being retained
                                         for historical reasons)
      twofish192-cbc   OPTIONAL          Twofish with a 192-bit key
      twofish128-cbc   OPTIONAL          Twofish with a 128-bit key
      aes256-cbc       OPTIONAL          AES in CBC mode,
                                         with a 256-bit key
      aes192-cbc       OPTIONAL          AES with a 192-bit key
      aes128-cbc       RECOMMENDED       AES with a 128-bit key
      serpent256-cbc   OPTIONAL          Serpent in CBC mode, with
                                         a 256-bit key
      serpent192-cbc   OPTIONAL          Serpent with a 192-bit key
      serpent128-cbc   OPTIONAL          Serpent with a 128-bit key
      arcfour          OPTIONAL          the ARCFOUR stream cipher
                                         with a 128-bit key
      idea-cbc         OPTIONAL          IDEA in CBC mode
      cast128-cbc      OPTIONAL          CAST-128 in CBC mode
      none             OPTIONAL          no encryption; NOT RECOMMENDED
```

"3des-cbc" 암호는 3개 키 삼중 DES\(암호화-복호화-암호화\)입니다. 여기서 키의 처음 8바이트는 첫 번째 암호화에 사용되고 다음 8바이트는 암호 해독에 사용되며 다음 8바이트는 암호 해독에 사용됩니다. 최종 암호화를 위해 이를 위해서는 24바이트의 키 데이터가 필요합니다\(실제로는 168비트가 사용됨\). CBC 모드를 구현하려면 외부 체인을 사용해야 합니다\(즉, 초기화 벡터가 하나만 있음\). 이것은 8바이트 블록으로 구성된 블록 암호입니다. 이 알고리즘은 \[FIPS-46-3\]에 정의되어 있습니다. 이 알고리즘은 유효 키 길이가 112비트\(\[SCHNEIER\]\)뿐이므로 SSH 암호화 알고리즘이 128비트 이상의 키를 사용해야 한다는 사양을 충족하지 않습니다. 그러나 이 알고리즘은 역사적인 이유로 여전히 필수입니다. 본질적으로 이 글을 쓰는 시점에 알려진 모든 구현은 이 알고리즘을 지원하며 기본적인 상호 운용 가능한 알고리즘이기 때문에 일반적으로 사용됩니다. 언젠가는 더 나은 강도를 가진 또 다른 알고리즘이 너무 널리 퍼져서 "3des-cbc"의 사용이 다른 표준 조치에 의해 더 이상 사용되지 않을 것으로 예상됩니다.\(MUST, MUST\)

"blowfish-cbc" 암호는 128비트 키를 사용하는 CBC 모드의 Blowfish입니다\[SCHNEIER\]. 이것은 8바이트 블록으로 구성된 블록 암호입니다.

"twofish-cbc" 또는 "twofish256-cbc" 암호는 \[TWOFISH\]에 설명된 대로 256비트 키를 사용하는 CBC 모드의 Twofish입니다. 이는 16바이트 블록으로 구성된 블록 암호입니다.

"twofish192-cbc" 암호는 위와 동일하지만 192비트 키를 사용합니다.

"twofish128-cbc" 암호는 위와 동일하지만 128비트 키를 사용합니다.

"aes256-cbc" 암호는 CBC 모드의 AES\(Advanced Encryption Standard\) \[FIPS-197\]입니다. 이 버전은 256비트 키를 사용합니다.

"aes192-cbc" 암호는 위와 동일하지만 192비트 키를 사용합니다.

"aes128-cbc" 암호는 위와 동일하지만 128비트 키를 사용합니다.

Serpent AES 제출에 설명된 대로 256비트 키를 사용하는 CBC 모드의 "serpent256-cbc" 암호입니다.

"serpent192-cbc" 암호는 위와 동일하지만 192비트 키를 사용합니다.

"serpent128-cbc" 암호는 위와 동일하지만 128비트 키를 사용합니다.

"arcfour" 암호는 128비트 키를 사용하는 Arcfour 스트림 암호입니다. Arcfour 암호는 RC4 암호 \[SCHNEIER\]와 호환되는 것으로 알려져 있습니다. Arcfour\(및 RC4\)는 약한 키에 문제가 있으므로 주의해서 사용해야 합니다.

"idea-cbc" 암호는 CBC 모드\[SCHNEIER\]의 IDEA 암호입니다.

"cast128-cbc" 암호는 128비트 키\[RFC2144\]를 사용하는 CBC 모드의 CAST-128 암호입니다.

"없음" 알고리즘은 암호화가 수행되지 않음을 지정합니다. 이 방법은 기밀 보호 기능을 제공하지 않으므로 권장되지 않습니다. 이 암호를 선택하면 보안상의 이유로 일부 기능\(예: 비밀번호 인증\)이 비활성화될 수 있습니다.\(SHOULD NOT\)

\[SSH-ARCH\] 및 \[SSH-NUMBERS\]에 지정된 대로 추가 방법을 정의할 수 있습니다.

---
### **6.4.  Data Integrity**

데이터 무결성은 각 패킷에 공유 비밀, 패킷 시퀀스 번호 및 패킷 콘텐츠로부터 계산된 MAC을 포함하여 보호됩니다.

메시지 인증 알고리즘과 키는 키 교환 중에 협상됩니다. 처음에는 MAC이 적용되지 않으며 길이는 0이어야 합니다. 키 교환 후 선택한 MAC 알고리즘에 대한 'mac'은 패킷 데이터 연결을 통해 암호화되기 전에 계산됩니다.\(MUST\)

```text
      mac = MAC(key, sequence_number || unencrypted_packet)
```

여기서 unencrypted\_packet은 'mac'\(길이 필드, 'payload' 및 'random padding'\)이 없는 전체 패킷이고, sequence\_number는 uint32로 표시되는 암시적 패킷 시퀀스 번호입니다. 시퀀스 번호는 첫 번째 패킷에 대해 0으로 초기화되고 매 패킷마다 증가됩니다\(암호화 또는 MAC 사용 여부에 관계없이\). 나중에 키/알고리즘을 재협상하더라도 재설정되지 않습니다. 2^32 패킷마다 0으로 래핑됩니다. 패킷 시퀀스\_번호 자체는 유선으로 전송되는 패킷에 포함되지 않습니다.

각 방향에 대한 MAC 알고리즘은 독립적으로 실행되어야 하며 구현에서는 양방향에 대해 독립적으로 알고리즘을 선택할 수 있도록 허용해야 합니다\(MUST\). 그러나 실제로는 동일한 알고리즘을 양방향으로 사용하는 것이 권장됩니다.\(MUST, SHOULD\)

MAC 알고리즘의 결과인 'mac' 값은 패킷의 마지막 부분으로 암호화 없이 전송되어야 합니다. 'mac' 바이트 수는 선택한 알고리즘에 따라 다릅니다.\(MUST\)

현재 정의된 MAC 알고리즘은 다음과 같습니다.

```text
      hmac-sha1    REQUIRED        HMAC-SHA1 (digest length = key
                                   length = 20)
      hmac-sha1-96 RECOMMENDED     first 96 bits of HMAC-SHA1 (digest
                                   length = 12, key length = 20)
      hmac-md5     OPTIONAL        HMAC-MD5 (digest length = key
                                   length = 16)
      hmac-md5-96  OPTIONAL        first 96 bits of HMAC-MD5 (digest
                                   length = 12, key length = 16)
      none         OPTIONAL        no MAC; NOT RECOMMENDED
```

"hmac-\*" 알고리즘은 \[RFC2104\]에 설명되어 있습니다. "\*-n" MAC은 결과 값의 처음 n 비트만 사용합니다.

SHA-1은 \[FIPS-180-2\]에 설명되어 있고 MD5는 \[RFC1321\]에 설명되어 있습니다.

\[SSH-ARCH\] 및 \[SSH-NUMBERS\]에 지정된 대로 추가 방법을 정의할 수 있습니다.

---
### **6.5.  Key Exchange Methods**

키 교환 방법은 암호화 및 인증을 위해 일회성 세션 키가 생성되는 방법과 서버 인증이 수행되는 방법을 지정합니다.

두 가지 필수 키 교환 방법이 정의되었습니다.\(MUST\)

```text
      diffie-hellman-group1-sha1 REQUIRED
      diffie-hellman-group14-sha1 REQUIRED
```

이러한 방법은 섹션 8에 설명되어 있습니다.

\[SSH-NUMBERS\]에 지정된 대로 추가 메소드를 정의할 수 있습니다. "diffie-hellman-group1-sha1"이라는 이름은 \[RFC2409\]에 정의된 Oakley 그룹을 사용한 키 교환 방법에 사용됩니다. SSH는 Oakley \[RFC2412\] 및 IKE와 논리적으로 구별되는 자체 그룹 식별자 공간을 유지 관리합니다. 그러나 하나의 추가 그룹에 대해 작업 그룹은 두 번째 정의된 그룹의 이름으로 diffie-helman-group14-sha1을 사용하여 \[RFC3526\]에서 할당한 번호를 채택했습니다. 구현에서는 이러한 이름을 불투명 식별자로 처리해야 하며 SSH에서 사용하는 그룹과 IKE에 정의된 그룹 간의 관계를 가정해서는 안 됩니다.

---
### **6.6.  Public Key Algorithms**

이 프로토콜은 거의 모든 공개 키 형식, 인코딩 및 알고리즘\(서명 및/또는 암호화\)에서 작동하도록 설계되었습니다.

공개 키 유형을 정의하는 여러 측면이 있습니다.

o 키 형식: 키는 어떻게 인코딩되고 인증서는 어떻게 표시됩니까? 이 프로토콜의 키 blob에는 키 외에 인증서가 포함될 수 있습니다.\(MAY\)

o 서명 및/또는 암호화 알고리즘. 일부 키 유형은 서명과 암호화를 모두 지원하지 않을 수 있습니다. 키 사용은 정책 설명\(예: 인증서\)에 의해 제한될 수도 있습니다. 이 경우 다양한 정책 대안에 대해 다양한 키 유형을 정의해야 합니다.\(SHOULD\)

o 서명 및/또는 암호화된 데이터의 인코딩. 여기에는 패딩, 바이트 순서 및 데이터 형식이 포함되지만 이에 국한되지는 않습니다.

현재 정의된 공개 키 및/또는 인증서 형식은 다음과 같습니다.

```text
   ssh-dss           REQUIRED     sign   Raw DSS Key
   ssh-rsa           RECOMMENDED  sign   Raw RSA Key
   pgp-sign-rsa      OPTIONAL     sign   OpenPGP certificates (RSA key)
   pgp-sign-dss      OPTIONAL     sign   OpenPGP certificates (DSS key)
```

\[SSH-ARCH\] 및 \[SSH-NUMBERS\]에 지정된 대로 추가 키 유형을 정의할 수 있습니다.

키 유형은 항상 명시적으로 알려져 있어야 합니다\(알고리즘 협상 또는 기타 소스를 통해\). 일반적으로 키 blob에 포함되지 않습니다.\(MUST\)

인증서와 공개 키는 다음과 같이 인코딩됩니다.

```text
      string    certificate or public key format identifier
      byte[n]   key/certificate data
```

인증서 부분은 길이가 0인 문자열일 수 있지만 공개 키가 필요합니다. 인증에 사용될 공개 키입니다. 인증서 blob에 포함된 인증서 시퀀스를 사용하여 인증을 제공할 수 있습니다.

서명 형식 식별자를 명시적으로 지정하지 않는 공개 키/인증서 형식은 공개 키/인증서 형식 식별자를 서명 식별자로 사용해야 합니다.\(MUST\)

서명은 다음과 같이 인코딩됩니다.

- 문자열 서명 형식 식별자\(공개 키/인증서 형식으로 지정됨\) 형식별 인코딩의 바이트\[n\] 서명 blob입니다.

"ssh-dss" 키 형식에는 다음과 같은 특정 인코딩이 있습니다.

```text
      string    "ssh-dss"
      mpint     p
      mpint     q
      mpint     g
      mpint     y
```

여기서 'p', 'q', 'g' 및 'y' 매개변수는 서명 키 blob을 형성합니다.

이 키 형식을 사용한 서명 및 확인은 SHA-1 해시\[FIPS-180-2\]를 사용하는 디지털 서명 표준\[FIPS-186-2\]에 따라 수행됩니다.

결과 서명은 다음과 같이 인코딩됩니다.

```text
      string    "ssh-dss"
      string    dss_signature_blob
```

'dss\_signature\_blob'의 값은 r과 그 뒤에 오는 s\(길이나 패딩이 없고 부호가 없으며 네트워크 바이트 순서인 160비트 정수\)를 포함하는 문자열로 인코딩됩니다.

"ssh-rsa" 키 형식에는 다음과 같은 특정 인코딩이 있습니다.

```text
      string    "ssh-rsa"
      mpint     e
      mpint     n
```

여기서 'e' 및 'n' 매개변수는 서명 키 blob을 형성합니다.

이 키 형식을 사용한 서명 및 확인은 SHA-1 해시를 사용하는 \[RFC3447\]의 RSASSA-PKCS1-v1\_5 체계에 따라 수행됩니다.

결과 서명은 다음과 같이 인코딩됩니다.

```text
      string    "ssh-rsa"
      string    rsa_signature_blob
```

'rsa\_signature\_blob'의 값은 s\(길이나 패딩이 없고 부호가 없으며 네트워크 바이트 순서의 정수\)를 포함하는 문자열로 인코딩됩니다.

"pgp-sign-rsa" 메소드는 인증서, 공개 키 및 서명이 OpenPGP 호환 바이너리 형식\(\[RFC2440\]\)임을 나타냅니다. 이 방법은 키가 RSA 키임을 나타냅니다.

"pgp-sign-dss"는 위와 같지만 해당 키가 DSS 키임을 나타냅니다.

---
## **7.  Key Exchange**

키 교환\(kex\)은 양측이 지원되는 알고리즘의 이름 목록을 보내는 것으로 시작됩니다. 각 측면에는 각 범주에서 선호하는 알고리즘이 있으며, 주어진 시간에 대부분의 구현에서는 동일한 선호 알고리즘을 사용한다고 가정합니다. 각 측은 추측할 수 있습니다.\(MAY\)

상대방이 어떤 알고리즘을 사용하고 있는지, 선호하는 방법에 적합한 경우 알고리즘에 따라 초기 키 교환 패킷을 보낼 수 있습니다.\(MAY\)

다음과 같은 경우 추측이 잘못된 것으로 간주됩니다.

o kex 알고리즘 및/또는 호스트 키 알고리즘이 잘못 추측되었습니다\(서버와 클라이언트가 선호하는 알고리즘이 서로 다름\).

o 다른 알고리즘 중 하나라도 합의할 수 없는 경우\(

- 절차는 아래 섹션 7.1에 정의되어 있습니다.

그렇지 않으면 추측이 옳은 것으로 간주되며 낙관적으로 전송된 패킷은 첫 번째 키 교환 패킷으로 처리되어야 합니다.\(MUST\)

그러나 추측이 틀렸고 패킷이 한쪽 또는 양쪽 당사자에 의해 낙관적으로 전송된 경우 해당 패킷은 무시되어야 하며\(추측 오류가 초기 패킷의 내용에 영향을 미치지 않더라도\) 적절한 조치를 취해야 합니다. 측은 올바른 초기 패킷을 보내야 합니다.\(MUST\)

키 교환 방법에서는 키 교환 메시지에 서명이나 서버 신뢰성에 대한 기타 증거가 포함된 경우 명시적 서버 인증을 사용합니다. 키 교환 방법은 진위를 증명하기 위해 서버가 메시지와 클라이언트가 확인할 수 있는 해당 MAC을 전송하여 공유 비밀 K를 알고 있음을 증명해야 하는 경우 암시적 서버 인증을 사용합니다.

이 문서에서 정의한 키 교환 방법은 명시적인 서버 인증을 사용합니다. 그러나 암시적 서버 인증을 통한 키 교환 방법은 이 프로토콜과 함께 사용될 수 있습니다. 암시적 서버 인증을 통한 키 교환 후 클라이언트는 추가 데이터를 보내기 전에 서비스 요청 메시지에 대한 응답을 기다려야 합니다.\(MAY, MUST\)

---
### **7.1.  Algorithm Negotiation**

키 교환은 각 측에서 다음 패킷을 보내는 것으로 시작됩니다.

```text
      byte         SSH_MSG_KEXINIT
      byte[16]     cookie (random bytes)
      name-list    kex_algorithms
      name-list    server_host_key_algorithms
      name-list    encryption_algorithms_client_to_server
      name-list    encryption_algorithms_server_to_client
      name-list    mac_algorithms_client_to_server
      name-list    mac_algorithms_server_to_client
      name-list    compression_algorithms_client_to_server
      name-list    compression_algorithms_server_to_client
      name-list    languages_client_to_server
      name-list    languages_server_to_client
      boolean      first_kex_packet_follows
      uint32       0 (reserved for future extension)
```

각 알고리즘 이름 목록은 쉼표로 구분된 알고리즘 이름 목록이어야 합니다\(\[SSH-ARCH\]의 알고리즘 명명 및 \[SSH-NUMBERS\]의 추가 정보 참조\). 지원되는\(허용되는\) 각 알고리즘은 가장 선호하는 것부터 가장 낮은 것 순으로 나열되어야 합니다.\(MUST, MUST\)

각 이름 목록의 첫 번째 알고리즘은 반드시 선호되는\(추측된\) 알고리즘이어야 합니다. 각 이름 목록에는 알고리즘 이름이 하나 이상 포함되어야 합니다.\(MUST, MUST\)

쿠키

- '쿠키'는 보낸 사람이 생성한 임의의 값이어야 합니다. 그 목적은 양측이 키와 세션 식별자를 완전히 결정하는 것을 불가능하게 만드는 것입니다.\(MUST\)

kex\_알고리즘

- 키 교환 알고리즘은 위에서 정의되었습니다. 첫 번째 알고리즘은 선호되는\(그리고 추측된\) 알고리즘이어야 합니다. 양측이 동일한 추측을 한다면 해당 알고리즘을 사용해야 합니다. 그렇지 않은 경우 키 교환 방법을 선택하려면 다음 알고리즘을 사용해야 합니다. 클라이언트의 kex 알고리즘을 한 번에 하나씩 반복합니다. 다음 조건을 만족하는 첫 번째 알고리즘을 선택하십시오.\(MUST, MUST, MUST\)

- + 서버는 또한 알고리즘을 지원합니다.

- + 알고리즘에 암호화 가능 호스트 키가 필요한 경우 클라이언트에서도 지원되는 서버의 server\_host\_key\_algorithms에 암호화 가능 알고리즘이 있습니다.

- + 알고리즘에 서명 가능 호스트 키가 필요한 경우 클라이언트에서도 지원되는 서버의 server\_host\_key\_algorithms에 서명 가능 알고리즘이 있습니다.

- 이러한 조건을 모두 만족하는 알고리즘을 찾을 수 없으면 연결이 실패하며 양쪽 모두 연결을 끊어야 합니다.\(MUST\)

서버\_호스트\_키\_알고리즘

- 서버 호스트 키에 대해 지원되는 알고리즘의 이름 목록입니다. 서버는 호스트 키가 있는 알고리즘을 나열합니다. 클라이언트는 기꺼이 수락할 알고리즘을 나열합니다. 호스트에는 여러 개의 호스트 키가 있을 수 있으며, 알고리즘은 다를 수 있습니다.\(MAY\)

- 일부 호스트 키는 서명과 암호화를 모두 지원하지 않을 수 있으므로\(알고리즘에서 확인할 수 있음\) 모든 호스트 키가 모든 키 교환 방법에 유효한 것은 아닙니다.

- 알고리즘 선택은 선택한 키 교환 알고리즘에 서명이 필요한지 또는 암호화 가능 호스트 키가 필요한지 여부에 따라 달라집니다. 공개 키 알고리즘 이름에서 이를 확인하는 것이 가능해야 합니다. 요구 사항을 충족하고 서버에서도 지원하는 클라이언트 이름 목록의 첫 번째 알고리즘을 선택해야 합니다. 그러한 알고리즘이 없으면 양쪽 모두 연결을 끊어야 합니다.\(MUST, MUST, MUST\)

암호화 알고리즘

- 선호하는 순서대로 허용되는 대칭 암호화 알고리즘\(암호라고도 함\)의 이름 목록입니다. 각 방향에 대해 선택된 암호화 알고리즘은 서버 이름 목록에도 있는 클라이언트 이름 목록의 첫 번째 알고리즘이어야 합니다. 그러한 알고리즘이 없으면 양쪽 모두 연결을 끊어야 합니다.\(MUST, MUST\)

- 허용되려면 "없음"을 명시적으로 나열해야 합니다. 정의된 알고리즘 이름은 섹션 6.3에 나열되어 있습니다.

mac\_algorithms

- 선호하는 순서대로 허용되는 MAC 알고리즘의 이름 목록입니다. 선택된 MAC 알고리즘은 서버 이름 목록에도 있는 클라이언트 이름 목록의 첫 번째 알고리즘이어야 합니다. 그러한 알고리즘이 없으면 양쪽 모두 연결을 끊어야 합니다.\(MUST, MUST\)

- 허용되려면 "없음"을 명시적으로 나열해야 합니다. MAC 알고리즘 이름은 섹션 6.4에 나열되어 있습니다.

압축 알고리즘

- 선호도 순으로 허용되는 압축 알고리즘의 이름 목록입니다. 선택한 압축 알고리즘은 서버 이름 목록에도 있는 클라이언트 이름 목록의 첫 번째 알고리즘이어야 합니다. 그러한 알고리즘이 없으면 양쪽 모두 연결을 끊어야 합니다.\(MUST, MUST\)

- 허용되려면 "없음"을 명시적으로 나열해야 합니다. 압축 알고리즘 이름은 섹션 6.2에 나열되어 있습니다.

언어

- 선호도에 따른 언어 태그의 이름 목록이다\[RFC3066\]. 양 당사자는 이 이름 목록을 무시할 수 있습니다. 언어 기본 설정이 없는 경우 이 이름 목록은 \[SSH-ARCH\]의 섹션 5에 정의된 대로 비어 있어야 합니다. 보내는 당사자가 필요하다고 알지 않는 한 언어 태그는 존재해서는 안 됩니다.\(MAY, SHOULD, SHOULD NOT\)

first\_kex\_packet\_follows

- 추측된 키 교환 패킷이 뒤따르는지 여부를 나타냅니다. 추측된 패킷이 전송된다면 이는 반드시 TRUE여야 합니다. 추측된 패킷이 전송되지 않으면 이는 FALSE여야 합니다.\(MUST, MUST\)

- 상대방으로부터 SSH\_MSG\_KEXINIT 패킷을 수신한 후 각 당사자는 자신의 추측이 맞았는지 여부를 알게 됩니다. 상대방의 추측이 틀렸고 이 필드가 TRUE인 경우 다음 패킷은 자동으로 무시되어야 하며 양측은 협상된 키 교환 방법에 따라 결정된 대로 행동해야 합니다. 추측이 맞다면 키 교환은 추측된 패킷을 사용하여 계속되어야 합니다.\(MUST, MUST\)

SSH\_MSG\_KEXINIT 메시지 교환 후 키 교환 알고리즘이 실행됩니다. 키 교환 방법에 지정된 대로 여러 패킷 교환이 포함될 수 있습니다.

당사자가 키 교환 또는 재교환을 위해 SSH\_MSG\_KEXINIT 메시지를 보낸 후에는 SSH\_MSG\_NEWKEYS 메시지\(섹션 7.3\)를 보낼 때까지 다음 이외의 메시지를 보내서는 안 됩니다.\(MUST NOT\)

```text
   o  Transport layer generic messages (1 to 19) (but
      SSH_MSG_SERVICE_REQUEST and SSH_MSG_SERVICE_ACCEPT MUST NOT be
      sent);

   o  Algorithm negotiation messages (20 to 29) (but further
      SSH_MSG_KEXINIT messages MUST NOT be sent);
```

o 특정 키 교환 방법 메시지\(30\~49\).

인식할 수 없는 메시지에는 섹션 11의 조항이 적용됩니다.

그러나 키 재교환 중에 SSH\_MSG\_KEXINIT 메시지를 보낸 후 각 당사자는 상대방으로부터 SSH\_MSG\_KEXINIT 메시지를 수신하기 전에 진행 중인 임의 수의 메시지를 처리할 준비를 해야 합니다.\(MUST\)

---
### **7.2.  Output from Key Exchange**

키 교환은 공유 비밀 K와 교환 해시 H라는 두 가지 값을 생성합니다. 암호화 및 인증 키는 이 값에서 파생됩니다. 첫 번째 키 교환의 교환 해시 H는 이 연결의 고유 식별자인 세션 식별자로 추가로 사용됩니다. 이는 개인 키 소유 증명으로 서명되는 데이터의 일부로 인증 방법에서 사용됩니다. 일단 계산되면 세션 식별자는 나중에 키가 다시 교환되더라도 변경되지 않습니다.

각 키 교환 방법은 키 교환에 사용되는 해시 함수를 지정합니다. 키 파생에는 동일한 해시 알고리즘을 사용해야 합니다. 여기서는 HASH라고 부르겠습니다.\(MUST\)

암호화 키는 다음과 같이 알려진 값과 K의 HASH로 계산되어야 합니다.\(MUST\)

o 서버에 대한 초기 IV 클라이언트: HASH\(K || H || "A" || session\_id\) \(여기서 K는 mpint로 인코딩되고 "A"는 바이트로, session\_id는 원시 데이터로 인코딩됩니다. "A"는 단일 문자 A를 의미합니다. ASCII 65\).

```text
   o  Initial IV server to client: HASH(K || H || "B" || session_id)

   o  Encryption key client to server: HASH(K || H || "C" || session_id)

   o  Encryption key server to client: HASH(K || H || "D" || session_id)

   o  Integrity key client to server: HASH(K || H || "E" || session_id)

   o  Integrity key server to client: HASH(K || H || "F" || session_id)
```

키 데이터는 해시 출력 시작 부분부터 가져와야 합니다. 해시 값의 시작 부분에서 필요한 만큼의 바이트를 가져옵니다. 필요한 키 길이가 HASH의 출력보다 긴 경우 K와 H를 연결한 HASH와 지금까지의 전체 키를 계산하고 결과 바이트\(HASH가 생성한 만큼\)를 키에 추가하여 키를 확장합니다. . 이 프로세스는 충분한 키 자료를 사용할 수 있을 때까지 반복됩니다. 키는 이 값의 시작 부분에서 가져옵니다. 다시 말해서:\(MUST\)

```text
      K1 = HASH(K || H || X || session_id)   (X is e.g., "A")
      K2 = HASH(K || H || K1)
      K3 = HASH(K || H || K1 || K2)
      ...
      key = K1 || K2 || K3 || ...
```

K의 엔트로피 양이 HASH의 내부 상태 크기보다 크면 이 프로세스는 엔트로피를 잃습니다.

---
### **7.3.  Taking Keys Into Use**

키 교환은 양측이 SSH\_MSG\_NEWKEYS 메시지를 보내면서 종료됩니다. 이 메시지는 이전 키 및 알고리즘과 함께 전송됩니다. 이 메시지 이후에 전송되는 모든 메시지는 새로운 키와 알고리즘을 사용해야 합니다.\(MUST\)

이 메시지가 수신되면 새로운 키와 알고리즘을 수신에 사용해야 합니다.\(MUST\)

이 메시지의 목적은 키 교환에 문제가 있을 경우 상대방이 이해할 수 있는 SSH\_MSG\_DISCONNECT 메시지로 당사자가 응답할 수 있도록 하는 것입니다.

```text
      byte      SSH_MSG_NEWKEYS
```

---
## **8.  Diffie-Hellman Key Exchange**

DH\(Diffie-Hellman\) 키 교환은 어느 쪽도 단독으로 확인할 수 없는 공유 비밀을 제공합니다. 키 교환은 호스트 키와 서명과 결합되어 호스트 인증을 제공합니다. 이 키 교환 방법은 섹션 7에 정의된 대로 명시적인 서버 인증을 제공합니다.

키를 교환하려면 다음 단계를 따르세요. 여기서 C는 클라이언트입니다. S는 서버입니다. p는 크고 안전한 소수이다. g는 GF\(p\)의 하위 그룹에 대한 생성기입니다. q는 부분군의 차수입니다. V\_S는 S의 식별 문자열입니다. V\_C는 C의 식별 문자열입니다. K\_S는 S의 공개 호스트 키입니다. I\_C는 C의 SSH\_MSG\_KEXINIT 메시지이고, I\_S는 본 부분이 시작되기 전에 주고받은 S의 SSH\_MSG\_KEXINIT 메시지이다.

1. C는 난수 x\(1 < x < q\)를 생성하고 다음을 계산합니다.

- e = g^x mod p. C는 S에게 e를 보낸다.

2. S는 난수 y\(0 < y < q\)를 생성하고 다음을 계산합니다.

- f = g^y mod p. S는 e를 받습니다. K = e^y mod p, H = hash\(V\_C || V\_S || I\_C || I\_S || K\_S || e || f || K\)를 계산합니다\(이러한 요소는 유형에 따라 인코딩됩니다. 아래 참조\). , 개인 호스트 키를 사용하여 H의 서명 s입니다. S는 \(K\_S || f || s\)를 C로 보냅니다. 서명 작업에는 두 번째 해싱 작업이 포함될 수 있습니다.

3. C는 K\_S가 실제로 S의 호스트 키인지 확인합니다\(예: 인증서 또는 로컬 데이터베이스 사용\). C는 검증 없이 키를 수락할 수도 있습니다. 그러나 그렇게 하면 프로토콜이 활성 공격에 대해 안전하지 않게 됩니다\(그러나 많은 환경에서 단기적으로는 실용적인 이유로 바람직할 수 있음\). 그런 다음 C는 K = f^x mod p, H = hash\(V\_C || V\_S || I\_C || I\_S || K\_S || e || f || K\)를 계산하고 H의 서명 s를 확인합니다.

\[1, p-1\] 범위에 없는 'e' 또는 'f' 값은 어느 쪽에서도 전송되거나 수락되어서는 안 됩니다. 이 조건을 위반하면 키 교환이 실패합니다.\(MUST NOT\)

이는 다음 메시지로 구현됩니다. 교환 해시를 계산하기 위한 해시 알고리즘은 메소드 이름으로 정의되며 HASH라고 합니다. 서명을 위한 공개 키 알고리즘은 SSH\_MSG\_KEXINIT 메시지와 협상됩니다.

먼저 클라이언트는 다음을 보냅니다.

```text
      byte      SSH_MSG_KEXDH_INIT
      mpint     e
```

그러면 서버는 다음과 같이 응답합니다.

```text
      byte      SSH_MSG_KEXDH_REPLY
      string    server public host key and certificates (K_S)
      mpint     f
      string    signature of H
```

해시 H는 다음을 연결한 HASH 해시로 계산됩니다.

```text
      string    V_C, the client's identification string (CR and LF
                excluded)
      string    V_S, the server's identification string (CR and LF
                excluded)
      string    I_C, the payload of the client's SSH_MSG_KEXINIT
      string    I_S, the payload of the server's SSH_MSG_KEXINIT
      string    K_S, the host key
      mpint     e, exchange value sent by the client
      mpint     f, exchange value sent by the server
      mpint     K, the shared secret
```

이 값을 교환 해시라고 하며 키 교환을 인증하는 데 사용됩니다. 교환 해시는 비밀로 유지되어야 합니다.\(SHOULD\)

서명 알고리즘은 원본 데이터가 아닌 H에 적용되어야 합니다. 대부분의 서명 알고리즘에는 해싱과 추가 패딩이 포함됩니다\(예: "ssh-dss"는 SHA-1 해싱을 지정함\). 이 경우 데이터는 먼저 HASH로 해시되어 H를 계산한 다음 서명 작업의 일부로 H를 SHA-1로 해시합니다.\(MUST\)

---
### **8.1.  diffie-hellman-group1-sha1**

"diffie-hellman-group1-sha1" 방법은 SHA-1과의 Diffie-Hellman 키 교환을 HASH로 지정하고 Oakley Group 2 \[RFC2409\]\(1024비트 MODP 그룹\)입니다. 이 방법은 현재 알려진 모든 구현에서 지원되므로 상호 운용성을 위해 지원되어야 합니다. 이 메서드는 Oakley 그룹 2의 사용을 지정하더라도 "group1"이라는 문구를 사용하여 이름이 지정됩니다.\(MUST\)

---
### **8.2.  diffie-hellman-group14-sha1**

"diffie-hellman-group14-sha1" 방법은 SHA-1과의 Diffie-Hellman 키 교환을 HASH 및 Oakley 그룹 14 \[RFC3526\]\(2048비트 MODP 그룹\)으로 지정하며 이 방법도 지원되어야 합니다.\(MUST\)

---
## **9.  Key Re-Exchange**

키 재교환은 아직 키 교환을 수행하지 않은 경우\(섹션 7.1에 설명된 대로\) SSH\_MSG\_KEXINIT 패킷을 전송하여 시작됩니다. 이 메시지가 수신되면 당사자는 수신된 SSH\_MSG\_KEXINIT가 이미 응답인 경우를 제외하고 자체 SSH\_MSG\_KEXINIT 메시지로 응답해야 합니다. 어느 쪽이든 재교환을 시작할 수 있지만 역할은 변경되어서는 안 됩니다. 즉, 서버는 서버로 남아 있고 클라이언트는 클라이언트로 남아 있습니다.\(MUST, MUST NOT\)

키 재교환은 교환이 시작될 때 적용되었던 암호화를 사용하여 수행됩니다. 암호화, 압축 및 MAC 방법은 키 교환 후\(초기 키 교환에서와 같이\) 새 SSH\_MSG\_NEWKEYS가 전송되기 전에는 변경되지 않습니다. 재교환은 변경되지 않은 세션 식별자를 제외하고 초기 키 교환과 동일하게 처리됩니다. 재교환 중에 알고리즘의 일부 또는 전체를 변경하는 것이 허용됩니다. 호스트 키도 변경될 수 있습니다. 모든 키와 초기화 벡터는 교환 후 다시 계산됩니다. 압축 및 암호화 컨텍스트가 재설정됩니다.

전송된 데이터의 기가바이트마다 또는 연결 시간의 매 시간 중 더 빠른 쪽을 기준으로 키를 변경하는 것이 좋습니다. 그러나 재교환은 공개 키 작업이므로 상당한 처리 능력이 필요하므로 너무 자주 수행해서는 안 됩니다.\(SHOULD\)

SSH\_MSG\_NEWKEYS 패킷이 전송된 후에 더 많은 애플리케이션 데이터가 전송될 수 있습니다. 키 교환은 SSH 전송 계층 위에 있는 프로토콜에 영향을 주지 않습니다.

---
## **10.  Service Request**

키 교환 후 클라이언트는 서비스를 요청합니다. 서비스는 이름으로 식별됩니다. 이름의 형식과 새로운 이름을 정의하는 절차는 \[SSH-ARCH\]와 \[SSH-NUMBERS\]에 정의되어 있다.

현재 다음 이름이 예약되어 있습니다.

```text
      ssh-userauth
      ssh-connection
```

알고리즘 이름에 적용되는 것과 유사한 로컬 명명 정책이 서비스 이름에 적용됩니다. 로컬 서비스는 "servicename@domain"의 PRIVATE USE 구문을 사용해야 합니다.

```text
      byte      SSH_MSG_SERVICE_REQUEST
      string    service name
```

서버가 서비스 요청을 거부하는 경우 적절한 SSH\_MSG\_DISCONNECT 메시지를 보내고 연결을 끊어야 합니다.\(MUST\)

서비스가 시작되면 키 교환 중에 생성된 세션 식별자에 액세스할 수 있습니다.

서버가 서비스를 지원하고 클라이언트가 서비스를 사용하도록 허용하는 경우 다음과 같이 응답해야 합니다.\(MUST\)

```text
      byte      SSH_MSG_SERVICE_ACCEPT
      string    service name
```

서비스에서 사용하는 메시지 번호는 해당 서비스를 위해 예약된 영역에 있어야 합니다\(\[SSH-ARCH\] 및 \[SSH-NUMBERS\] 참조\). 전송 수준은 계속해서 자체 메시지를 처리합니다.

암시적 서버 인증을 통한 키 교환 후 클라이언트는 추가 데이터를 보내기 전에 서비스 요청 메시지에 대한 응답을 기다려야 합니다.\(MUST\)

---
## **11.  Additional Messages**

어느 쪽이든 언제든지 다음 메시지를 보낼 수 있습니다.

---
### **11.1.  Disconnection Message**

```text
      byte      SSH_MSG_DISCONNECT
      uint32    reason code
      string    description in ISO-10646 UTF-8 encoding [RFC3629]
      string    language tag [RFC3066]
```

이 메시지로 인해 연결이 즉시 종료됩니다. 모든 구현은 이 메시지를 처리할 수 있어야 합니다. 그들은 이 메시지를 보낼 수 있어야 합니다.\(MUST\)

발신자는 이 메시지 이후에 어떤 데이터도 보내거나 받아서는 안 되며, 수신자는 이 메시지를 받은 후에 어떤 데이터도 수락해서는 안 됩니다. 연결 해제 메시지 '설명' 문자열은 사람이 읽을 수 있는 형식으로 보다 구체적인 설명을 제공합니다. 연결 끊김 메시지 '이유 코드'는 기계가 더 쉽게 읽을 수 있는 형식\(현지화에 적합\)으로 이유를 제공하며 아래 표에 표시된 값을 가질 수 있습니다. 가독성을 위해 이 표에는 10진수 표현이 표시되어 있지만 값은 실제로 uint32 값입니다.\(MUST NOT\)

```text
           Symbolic name                                reason code
           -------------                                -----------
      SSH_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT             1
      SSH_DISCONNECT_PROTOCOL_ERROR                          2
      SSH_DISCONNECT_KEY_EXCHANGE_FAILED                     3
      SSH_DISCONNECT_RESERVED                                4
      SSH_DISCONNECT_MAC_ERROR                               5
      SSH_DISCONNECT_COMPRESSION_ERROR                       6
      SSH_DISCONNECT_SERVICE_NOT_AVAILABLE                   7
      SSH_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED          8
      SSH_DISCONNECT_HOST_KEY_NOT_VERIFIABLE                 9
      SSH_DISCONNECT_CONNECTION_LOST                        10
      SSH_DISCONNECT_BY_APPLICATION                         11
      SSH_DISCONNECT_TOO_MANY_CONNECTIONS                   12
      SSH_DISCONNECT_AUTH_CANCELLED_BY_USER                 13
      SSH_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE         14
      SSH_DISCONNECT_ILLEGAL_USER_NAME                      15
```

'설명' 문자열이 표시되면 \[SSH-ARCH\]에서 설명한 제어 문자 필터링을 사용하여 터미널 제어 문자를 전송하여 공격을 방지해야 합니다.

0x00000010 \~ 0xFDFFFFFF 범위의 새로운 연결 해제 메시지 '이유 코드' 값\(및 관련 '설명' 텍스트\) 할당 요청은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다. 0xFE000000\~0xFFFFFFFF 범위의 연결 끊김 메시지 '이유 코드' 값은 개인용으로 예약되어 있습니다. 언급한 대로 IANA에 대한 실제 지침은 \[SSH-NUMBERS\]에 있습니다.\(MUST\)

---
### **11.2.  Ignored Data Message**

```text
      byte      SSH_MSG_IGNORE
      string    data
```

모든 구현은 언제든지\(식별 문자열을 수신한 후\) 이 메시지를 이해하고 무시해야 합니다. 전송하기 위해 구현이 필요하지 않습니다. 이 메시지는 고급 트래픽 분석 기술에 대한 추가 보호 조치로 사용될 수 있습니다.\(MUST\)

---
### **11.3.  Debug Message**

```text
      byte      SSH_MSG_DEBUG
      boolean   always_display
      string    message in ISO-10646 UTF-8 encoding [RFC3629]
      string    language tag [RFC3066]
```

모든 구현은 이 메시지를 이해해야 하지만 이를 무시할 수 있습니다. 이 메시지는 디버깅에 도움이 될 수 있는 정보를 전송하는 데 사용됩니다. 'always\_display'가 TRUE이면 메시지가 표시되어야 합니다. 그렇지 않으면 사용자가 디버깅 정보를 명시적으로 요청하지 않는 한 표시되어서는 안 됩니다.\(MUST, SHOULD, SHOULD NOT\)

'메시지'에는 개행 문자가 포함될 필요가 없습니다. 그러나 CRLF\(캐리지 리턴 - 줄 바꿈\) 쌍으로 구분된 여러 줄로 구성될 수 있습니다.

'message' 문자열이 표시되면 \[SSH-ARCH\]에서 설명한 터미널 제어 문자 필터링을 사용하여 터미널 제어 문자를 전송하여 공격을 방지해야 합니다.

---
### **11.4.  Reserved Messages**

구현은 메시지가 수신된 순서대로 SSH\_MSG\_UNIMPLEMENTED 메시지를 사용하여 인식되지 않은 모든 메시지에 응답해야 합니다\(MUST\). 그러한 메시지는 무시되어야 합니다. 최신 프로토콜 버전에서는 이러한 메시지 유형에 대해 다른 의미를 정의할 수 있습니다.\(MUST, MUST\)

```text
      byte      SSH_MSG_UNIMPLEMENTED
      uint32    packet sequence number of rejected message
```

---
## **12.  Summary of Message Numbers**

다음은 메시지 요약 및 관련 메시지 번호입니다.

```text
         SSH_MSG_DISCONNECT             1
         SSH_MSG_IGNORE                 2
         SSH_MSG_UNIMPLEMENTED          3
         SSH_MSG_DEBUG                  4
         SSH_MSG_SERVICE_REQUEST        5
         SSH_MSG_SERVICE_ACCEPT         6
         SSH_MSG_KEXINIT                20
         SSH_MSG_NEWKEYS                21
```

kex 패킷에는 숫자 30-49가 사용됩니다. 다양한 kex 방법은 이 범위의 메시지 번호를 재사용할 수 있습니다.

---
## **13.  IANA Considerations**

이 문서는 세트의 일부입니다. \[SSH-ARCH\], \[SSH-USERAUTH\], \[SSH-CONNECT\] 및 이 문서에 정의된 SSH 프로토콜에 대한 IANA 고려 사항은 \[SSH-NUMBERS\]에 자세히 설명되어 있습니다.

---
## **14.  Security Considerations**

이 프로토콜은 안전하지 않은 네트워크를 통해 안전하게 암호화된 채널을 제공합니다. 서버 호스트 인증, 키 교환, 암호화 및 무결성 보호를 수행합니다. 또한 더 높은 수준의 프로토콜에서 사용할 수 있는 고유한 세션 ID를 파생합니다.

이 프로토콜에 대한 전체 보안 고려 사항은 \[SSH-ARCH\]에 제공됩니다.

---
## **15.  References**
---
### **15.1.  Normative References**

\[SSH-ARCH\] Ylonen, T. 및 C. Lonvick, Ed., "SSH\(Secure Shell\) 프로토콜 아키텍처", RFC 4251, 2006년 1월.

\[SSH-사용자 인증\] Ylonen, T. 및 C. Lonvick, Ed., "SSH\(Secure Shell\) 인증 프로토콜", RFC 4252, 2006년 1월.

\[SSH-CONNECT\] Ylonen, T. 및 C. Lonvick, Ed., "SSH\(Secure Shell\) 연결 프로토콜", RFC 4254, 2006년 1월.

\[SSH-번호\] Lehtinen, S. 및 C. Lonvick, Ed., "SSH\(Secure Shell\) 프로토콜 할당 번호", RFC 4250, 2006년 1월.

```text
   [RFC1321]      Rivest, R., "The MD5 Message-Digest Algorithm ", RFC
                  1321, April 1992.
```

\[RFC1950\] Deutsch, P. 및 J-L. Gailly, "ZLIB 압축 데이터 형식 사양 버전 3.3", RFC 1950, 1996년 5월.

```text
   [RFC1951]      Deutsch, P., "DEFLATE Compressed Data Format
                  Specification version 1.3", RFC 1951, May 1996.
```

\[RFC2104\] Krawczyk, H., Bellare, M. 및 R. Canetti, "HMAC: 메시지 인증을 위한 키 해싱", RFC 2104, 1997년 2월.

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

```text
   [RFC2144]      Adams, C., "The CAST-128 Encryption Algorithm", RFC
                  2144, May 1997.
```

\[RFC2409\] Harkins, D. 및 D. Carrel, "인터넷 키 교환\(IKE\)", RFC 2409, 1998년 11월.

\[RFC2434\] Narten, T. 및 H. Alvestrand, "RFC에서 IANA 고려 사항 섹션 작성 지침", BCP 26, RFC 2434, 1998년 10월.

\[RFC2440\] Callas, J., Donnerhacke, L., Finney, H. 및 R. Thayer, "OpenPGP 메시지 형식", RFC 2440, 1998년 11월.

\[RFC3066\] Alvestrand, H., "언어 식별을 위한 태그", BCP 47, RFC 3066, 2001년 1월.

\[RFC3447\] Jonsson, J. 및 B. Kaliski, "공개 키 암호화 표준\(PKCS\) #1: RSA 암호화 사양 버전 2.1", RFC 3447, 2003년 2월.

\[RFC3526\] Kivinen, T. 및 M. Kojo, "인터넷 키 교환\(IKE\)을 위한 MODP\(More Modular Exponential\) Diffie-Hellman 그룹", RFC 3526, 2003년 5월.

\[RFC3629\] Yergeau, F., "UTF-8, ISO 10646의 변환 형식", STD 63, RFC 3629, 2003년 11월.

\[FIPS-180-2\] 미국 국립 표준 기술 연구소, "SHS\(Secure Hash Standard\)", 연방 정보 처리 표준 간행물 180-2, 2002년 8월.

\[FIPS-186-2\] 미국 국립 표준 기술 연구소, "디지털 서명 표준\(DSS\)", 연방 정보 처리 표준 간행물 186-2, 2000년 1월.

\[FIPS-197\] 미국 국립 표준 기술 연구소, "AES\(고급 암호화 표준\)", 연방 정보 처리 표준 간행물 197, 2001년 11월.

\[FIPS-46-3\] 미국 국립 표준 기술 연구소, "DES\(데이터 암호화 표준\)", 연방 정보 처리 표준 간행물 46-3, 1999년 10월.

\[SCHNEIER\] Schneier, B., "응용 암호화 제2판: C 코드의 프로토콜 알고리즘 및 소스", John Wiley and Sons, New York, NY, 1996.

\[TWOFISH\] Schneier, B., "Twofish 암호화 알고리즘: 128비트 블록 암호, 1판", 1999년 3월.

---
### **15.2.  Informative References**

\[RFC0894\] Hornig, C., "이더넷 네트워크를 통한 IP 데이터그램 전송 표준", STD 41, RFC 894, 1984년 4월.

```text
   [RFC1661]      Simpson, W., "The Point-to-Point Protocol (PPP)", STD
                  51, RFC 1661, July 1994.

   [RFC2412]      Orman, H., "The OAKLEY Key Determination Protocol",
                  RFC 2412, November 1998.
```

\[ssh-1.2.30\] Ylonen, T., "ssh-1.2.30/RFC", 압축된 tarball ftp://ftp.funet.fi/pub/unix/security/login/ssh/ssh-1.2 내의 파일. 30.tar.gz, 1995년 11월.

---
# **Authors' Addresses**

```text
   Tatu Ylonen
   SSH Communications Security Corp
   Valimotie 17
   00380 Helsinki
   Finland

   EMail: ylo@ssh.com

   Chris Lonvick (editor)
   Cisco Systems, Inc.
   12515 Research Blvd.
   Austin  78759
   USA

   EMail: clonvick@cisco.com
```

---
# **Trademark Notice**

"ssh"는 미국 및/또는 기타 국가의 등록 상표입니다.

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(2006\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회 및 인터넷 공학 태스크포스는 모든 명시적 또는 묵시적 보증을 부인합니다. 여기에서 구성은 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않습니다.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 IETF 행정 지원 활동\(IASA\)에서 제공합니다.
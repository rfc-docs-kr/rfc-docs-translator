

```text
Internet Engineering Task Force (IETF)                         L. Eggert
Request for Comments: 8085                                        NetApp
BCP: 145                                                    G. Fairhurst
Obsoletes: 5405                                   University of Aberdeen
Category: Best Current Practice                              G. Shepherd
ISSN: 2070-1721                                            Cisco Systems
                                                              March 2017

                          UDP Usage Guidelines
```

---
# **Abstract**

UDP\(사용자 데이터그램 프로토콜\)는 고유한 정체 제어 메커니즘이 없는 최소한의 메시지 전달 전송을 제공합니다. 이 문서는 UDP를 사용하는 애플리케이션, 터널 및 기타 프로토콜 설계자를 위한 UDP 사용에 대한 지침을 제공합니다. 혼잡 제어 지침이 주요 초점이지만 이 문서는 메시지 크기, 안정성, 체크섬, 미들박스 통과, ECN\(명시적 혼잡 알림\) 사용, DSCP\(차별화된 서비스 코드 포인트\) 및 포트를 포함한 다른 주제에 대한 지침도 제공합니다.

혼잡 제어는 인터넷의 안정적인 작동에 중요하기 때문에 UDP를 인터넷 전송으로 사용하기로 선택한 애플리케이션 및 기타 프로토콜은 혼잡 붕괴를 방지하고 동시 트래픽에 대해 어느 정도 공정성을 확립하는 메커니즘을 사용해야 합니다. UDP를 사용하는 방식에 따라 추가 메커니즘을 구현해야 할 수도 있습니다.

일부 지침은 특히 이러한 프로토콜 자체가 혼잡 제어를 제공하지 않는 경우 다른 프로토콜\(예: IP에 직접 계층화되거나 IP 기반 터널을 통해 계층화된 프로토콜\)의 설계에도 적용됩니다.

이 문서는 RFC 5405를 폐기하고 멀티캐스트 UDP 사용에 대한 지침을 추가합니다.

---
# **Status of This Memo**

이 메모는 Internet Best Current Practice를 문서화합니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. BCP에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc8085에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2017 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................3
   2. Terminology .....................................................5
   3. UDP Usage Guidelines ............................................5
      3.1. Congestion Control Guidelines ..............................6
      3.2. Message Size Guidelines ...................................19
      3.3. Reliability Guidelines ....................................21
      3.4. Checksum Guidelines .......................................22
      3.5. Middlebox Traversal Guidelines ............................25
      3.6. Limited Applicability and Controlled Environments .........27
   4. Multicast UDP Usage Guidelines .................................28
      4.1. Multicast Congestion Control Guidelines ...................30
      4.2. Message Size Guidelines for Multicast .....................32
   5. Programming Guidelines .........................................32
      5.1. Using UDP Ports ...........................................34
      5.2. ICMP Guidelines ...........................................37
   6. Security Considerations ........................................38
   7. Summary ........................................................40
   8. References .....................................................42
      8.1. Normative References ......................................42
      8.2. Informative References ....................................43
   Appendix A. .......................................................53
   Acknowledgments ...................................................55
   Authors' Addresses ................................................55
```

---
## **1.  Introduction**

UDP\(사용자 데이터그램 프로토콜\) \[RFC768\]는 IP를 통해 작동하려는 애플리케이션 및 기타 프로토콜\(예: 터널\)에 최소한의 신뢰할 수 없는 최선의 메시지 전달 전송을 제공합니다. 이 문서의 나머지 부분에서는 둘 다 간단히 "애플리케이션"이라고 부릅니다.

다른 전송 프로토콜과 비교하여 UDP 및 해당 UDP-Lite 변형 \[RFC3828\]은 통신하는 최종 시스템 간에 종단 간 연결을 설정하지 않는다는 점에서 고유합니다. 결과적으로 UDP 통신은 연결 설정 및 해제 오버헤드를 발생시키지 않으며 관련 최종 시스템 상태가 최소화됩니다. 이러한 특성으로 인해 UDP는 일부 응용 프로그램에 매우 효율적인 통신 전송을 제공할 수 있습니다.

UDP의 두 번째 고유한 특징은 고유한 혼잡 제어 메커니즘을 제공하지 않는다는 것입니다. 많은 플랫폼에서 응용 프로그램은 플랫폼 링크 인터페이스의 회선 속도로 UDP 데이터그램을 보낼 수 있습니다. 이는 종종 사용 가능한 종단 간 경로 용량보다 훨씬 크며, 그렇게 하면 경로를 따라 정체가 발생합니다. \[RFC2914\]는 혼잡 제어에 대한 현재의 모범 사례를 설명합니다.

인터넷에는. 이는 인터넷의 안정적인 작동을 위해 혼잡 제어 메커니즘이 중요한 두 가지 주요 이유를 식별합니다.

1. 혼잡 붕괴 방지, 즉 네트워크 부하 증가로 인해 네트워크가 수행하는 유용한 작업이 감소하는 상태.

2. 공정성 확립, 즉 여러 흐름이 합리적으로 공평하게 경로 용량을 공유할 수 있도록 허용합니다.

UDP 자체는 혼잡 제어 메커니즘을 제공하지 않기 때문에 인터넷 통신에 UDP를 사용하여 혼잡 붕괴를 방지하고 공정성을 확립하는 적절한 메커니즘을 사용하는 것은 애플리케이션에 달려 있습니다. \[RFC2309\]는 정체 무응답 흐름의 위험성을 논의하고 "모든 UDP 기반 스트리밍 애플리케이션은 효과적인 정체 회피 메커니즘을 통합해야 한다"고 명시합니다. \[RFC7567\]은 이 진술을 재확인합니다. 이는 스트리밍에 UDP를 사용하지 않는 애플리케이션의 경우에도 중요한 요구 사항입니다. 또한 정체 제어 전송은 자체 유도된 패킷 손실을 줄이고 재전송을 최소화하여 지연을 줄일 수 있으므로 애플리케이션 자체에 이점이 있습니다. 상대적으로 느린 전송 속도에서도 혼잡 제어는 필수적입니다. 예를 들어, 1초에 5개의 1500바이트 UDP 데이터그램을 생성하는 애플리케이션은 이미 56Kb/s 경로의 용량을 초과할 수 있습니다. 잠재적으로 제한되지 않은 더 높은 데이터 속도로 작동할 수 있는 애플리케이션의 경우 혼잡 제어는 혼잡 붕괴를 방지하고 어느 정도의 공정성을 확립하는 데 필수적입니다. 섹션 3에서는 이러한 애플리케이션 설계자를 위한 여러 가지 간단한 지침을 설명합니다.

UDP 데이터그램은 단일 IP 패킷으로 전달되므로 IPv4의 경우 최대 페이로드가 65,507바이트, IPv6의 경우 65,527바이트로 제한됩니다. 대규모 IP 패킷을 전송하려면 일반적으로 IP 조각화가 필요합니다. 조각화는 통신 신뢰성과 효율성을 감소시키므로 피해야 합니다. IPv6에서는 경로의 모든 링크 계층이 이 \[RFC2675\]를 지원할 때 조각화 없이 큰 패킷\("점보그램"\)을 전송할 수 있는 옵션을 허용합니다. 섹션 3의 일부 지침에서는 애플리케이션이 적절한 메시지 크기를 결정하는 방법을 설명합니다. 이 문서의 다른 섹션에서는 안정성, 체크섬, 미들박스 탐색 및 멀티캐스트 사용에 대한 지침을 제공합니다.

이 문서에서는 지침과 권장 사항을 제공합니다. 대부분의 UDP 애플리케이션은 이러한 지침을 따를 것으로 예상되지만 특정 애플리케이션이 주어진 지침을 따르지 않기로 결정하는 타당한 이유가 있습니다. 그러한 경우에는 다음을 수행하는 것이 좋습니다.\(SHOULD\)

응용 프로그램 설계자는 해당 응용 프로그램이나 프로토콜의 기술 사양에서 이 문서의 각 섹션을 인용하고 설계 선택에 대한 근거를 설명합니다.

\[RFC5405\]는 유니캐스트 애플리케이션에 대해서만 지침을 제공하도록 범위가 지정되었지만 이 문서는 IP 애니캐스트, 멀티캐스트, 브로드캐스트를 사용하는 UDP 흐름과 IP 흐름을 지원하기 위해 UDP 터널을 사용하는 애플리케이션에 대한 지침도 제공합니다.

마지막으로, 이 문서에서는 UDP 사용을 구체적으로 언급하고 있지만 일부 지침의 정신은 다른 메시지 전달 응용 프로그램 및 프로토콜\(특히 혼잡 제어, 메시지 크기 및 안정성 주제\)에도 적용됩니다. IANA에 자체 IP 프로토콜 번호를 등록하여 IP를 통해 직접 실행하도록 선택하는 신호, 터널 또는 제어 애플리케이션을 예로 들 수 있습니다. 이 문서는 해당 애플리케이션 및 프로토콜 설계자에게 유용한 배경 지식을 제공할 것으로 예상됩니다.

---
## **2.  Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
## **3.  UDP Usage Guidelines**

인터넷 경로는 전송 지연, 사용 가능한 대역폭, 정체 수준, 재정렬 확률, 지원되는 메시지 크기, 손실률 등 매우 다양한 특성을 가질 수 있습니다. 게다가 동일한 인터넷 경로라도 시간이 지남에 따라 조건이 매우 달라질 수 있습니다. 결과적으로, 인터넷에서 사용될 수 있는 애플리케이션은 특정 경로 특성에 대해 가정을 해서는 안 됩니다. 대신 매우 다른 경로 조건에서 안전하게 작동할 수 있는 메커니즘을 사용해야 합니다. 일반적으로 이를 위해서는 통신하는 인터넷 경로의 현재 상태를 보수적으로 조사하여 유지할 수 있고 경로를 공유하는 다른 트래픽에 합리적으로 공평한 전송 동작을 설정해야 합니다.\(MUST NOT, MUST\)

이러한 메커니즘은 올바르게 구현하기가 어렵습니다. 대부분의 애플리케이션에서는 기존 IETF 전송 프로토콜 중 하나를 사용하는 것이 필요한 메커니즘을 획득하는 가장 간단한 방법입니다. 이렇게 하면 TCP 및 UDP만 지원하는 미들박스가 때때로 존재하는 인터넷을 통해 배포될 때 새로운 IP 프로토콜 번호를 사용하는 프로토콜이 직면하는 문제도 피할 수 있습니다. 결과적으로, 이 섹션의 나머지 부분에서 설명하는 UDP 사용에 대한 권장되는 대안은 TCP와 같은 IETF 전송 프로토콜을 사용하는 것입니다.\(SHOULD\)

\[RFC793\], SCTP\(스트림 제어 전송 프로토콜\) \[RFC4960\] 및 SCTP-PR\(SCTP 부분 신뢰성 확장\) \[RFC3758\] 또는 DCCP\(데이터그램 혼잡 제어 프로토콜\) \[RFC4340\]\(다양한 혼잡 제어 유형 포함\)\[RFC4341\]\[ RFC4342\]\[RFC5622\] 또는 향후 IETF에서 지정하는 전송 프로토콜입니다. \(UDP 캡슐화 SCTP \[RFC6951\] 및 DCCP \[RFC6773\]는 기본 프로토콜이 지원되지 않는 방화벽 및 기타 미들박스 통과에 대한 지원을 제공할 수 있습니다.\)

올바르게 사용하면 이러한 보다 완전한 기능을 갖춘 전송 프로토콜은 자주 주장되는 것처럼 "무거운" 전송 프로토콜이 아닙니다. 예를 들어, TCP 알고리즘은 수십 년 동안 지속적으로 개선되어 사용자 정의 애플리케이션 계층 메커니즘이 쉽게 복제하기 힘든 효율성과 정확성 수준에 도달했습니다. 또한 많은 TCP 구현에서는 애플리케이션이 해당 목적에 맞게 연결을 조정할 수 있습니다. 예를 들어, TCP의 "Nagle" 알고리즘\[RFC1122\]을 비활성화하여 패킷 전송을 더 자주 하지만 여전히 혼잡을 제어하여 통신 대기 시간을 개선할 수 있습니다. 또 다른 예는 많은 플랫폼에서 사용할 수 있는 TCP SYN 쿠키 메커니즘 \[RFC4987\]입니다. SYN 쿠키를 사용하는 TCP에서는 연결이 설정될 때까지 서버가 연결별 상태를 유지할 필요가 없습니다. 또한 TCP는 한 연결 인스턴스의 지연된 세그먼트가 이후 연결 인스턴스를 방해하지 않도록 하는 TIME-WAIT 상태를 유지하기 위해 연결을 닫는 끝이 필요합니다. 이 동작을 인식하고 설계한 애플리케이션은 TCP 연결을 닫는 쪽을 제어하여 TIME-WAIT 상태 유지 관리를 전환하여 리소스를 절약할 수 있습니다\[FABER\]. 마지막으로, TCP의 내장된 용량 검색 및 경로\(PMTU\)에서 지원하는 최대 전송 단위에 대한 인식을 통해 여러 세그먼트를 교환하는 전송의 경우 초기 연결 설정 지연을 신속하게 보상하는 효율적인 데이터 전송이 가능합니다. .

---
### **3.1.  Congestion Control Guidelines**

애플리케이션이나 프로토콜이 혼잡 제어 전송 프로토콜을 사용하지 않기로 선택한 경우 \[RFC2914\]의 요구 사항을 충족하기 위해 UDP 데이터그램을 대상 호스트에 보내는 속도를 제어해야 합니다. 애플리케이션은 이 트래픽을 생성하는 방법과 관계없이 대상으로 보내는 모든 UDP 트래픽에 대해 정체 제어를 수행해야 한다는 점을 강조하는 것이 중요합니다. 예를 들어, 여러 작업자 프로세스를 포크하거나 여러 소켓을 사용하여 UDP 데이터그램을 생성하는 애플리케이션은 집계 트래픽에 대해 혼잡 제어를 수행해야 합니다.\(SHOULD, SHOULD, SHOULD\)

혼잡 제어를 수행하는 몇 가지 접근 방식은 이 섹션의 나머지 부분에서 논의됩니다. 이 섹션에서는 유니캐스트 및 애니캐스트 \[RFC1546\] 사용을 강조하여 일반적인 주제를 설명합니다. 아래에 설명된 모든 접근 방식이 모든 UDP 전송 애플리케이션에 적합한 것은 아닙니다. 섹션 3.1.2에서는 UDP를 통해 대량 전송을 수행하는 애플리케이션에 대한 혼잡 제어 옵션에 대해 설명합니다. 이러한 애플리케이션은 현재 로드에서 경로가 지원할 수 있는 전송 속도를 결정하기 위해 데이터가 교환되는 동안 여러 후속 왕복에 걸쳐 경로를 샘플링하는 방식을 사용할 수 있습니다. 다른 응용 프로그램은 몇 개의 UDP 데이터그램만 대상과 교환합니다. 섹션 3.1.3에서는 "낮은 데이터 볼륨" 애플리케이션에 대한 혼잡 제어 옵션에 대해 설명합니다. 일반적으로 안전한 전송 속도를 결정하기 위해 경로를 반복적으로 샘플링하기에 충분한 데이터를 전송하지 않기 때문에 다양한 종류의 혼잡 제어 메커니즘을 사용해야 합니다. 섹션 3.1.11에서는 UDP가 터널링 프로토콜로 사용될 때 혼잡 제어 고려 사항을 논의합니다. 섹션 4에서는 브로드캐스트 및 멀티캐스트 사용에 대한 추가 권장 사항을 제공합니다.

혼잡 제어를 완성된 애플리케이션에 대한 추가 기능으로 간주해서는 안 된다는 점에 유의하는 것이 중요합니다. 아래 지침에 설명된 많은 메커니즘이 올바르게 작동하려면 애플리케이션 지원이 필요합니다. 애플리케이션 설계자는 설계 프로세스 전반에 걸쳐 보안 측면을 고려하는 방법과 유사하게 애플리케이션 설계 전반에 걸쳐 혼잡 제어를 고려해야 합니다.

과거에 IETF는 또한 두 호스트 간의 트래픽 집계에 작용하는 통합 혼잡 제어 메커니즘, 즉 활성 세션이 독립적인 방식으로 현재 혼잡 정보를 공유할 수 있는 Congestion Manager \[RFC3124\]와 같은 프레임워크를 조사했습니다. 전송 프로토콜의 이러한 메커니즘은 현재 배포를 확인하는 데 실패했지만 UDP 세션에 대한 혼잡 제어 메커니즘의 설계를 단순화하여 \[RFC2914\]의 요구 사항을 충족합니다.

---
#### **3.1.1.  Protocol Timer Guidelines**

통신 엔드포인트 간의 대기 시간을 이해하는 것은 일반적으로 프로토콜과 애플리케이션에 대한 효과적인 혼잡 제어 구현의 중요한 부분입니다. 지연 시간 추정은 혼잡 제어 전송 속도 계산, 재전송 트리거, 패킷 손실 감지 등 다양한 프로토콜 기능에 사용될 수 있습니다. 추가 프로토콜 기능\(예: 경로 검색 간격 결정, 연결 유지 메시지 간의 간격 결정, 경험 품질 측정 간격 결정 또는 원격 끝점이 있는지 확인\)

작업 수행 요청에 응답하는 작업은 일반적으로 혼잡 제어보다 더 긴 시간 동안 작동하므로 이 섹션에서는 다루지 않습니다.

이 문서의 일반적인 권장 사항은 애플리케이션이 기존 혼잡 제어 기술과 여기에 지정된 대기 시간 추정기를 활용해야 한다는 것입니다\(다음 하위 섹션 참조\). 자체 지연 시간 추정 메커니즘을 설계해야 하는 애플리케이션을 위해 다음 지침이 제공됩니다.\(SHOULD\)

일부 상황에서는 네트워크 기반 대기 시간\(예: TFRC\(TCP-Friendly Rate Control\) \[RFC5348\]\)만 특성화해야 하고 다른 경우에는 포함이 필요하기 때문에 지침은 "왕복 시간"이 아닌 "대기 시간"이라는 측면에서 구성됩니다. 원격 엔드포인트가 피드백을 제공하는 데 필요한 시간\(예: 메시지 재전송 시점에 대한 이해 개발\)

엔드포인트 간의 대기 시간은 일반적으로 동적 속성입니다. 따라서 추정치는 분산을 설명하기 위해 최근 여러 측정 샘플의 일종의 평균을 나타내야 합니다. EWMA\(지수가중이동평균\)를 활용하는 것이 이 목적에 유용한 것으로 입증되었습니다\(예: TCP \[RFC6298\] 및 TFRC \[RFC5348\]\).\(SHOULD\)

엔드포인트가 통신하는 각 대상에 대해 독립적인 대기 시간 추정치를 유지해야 합니다\(SHOULD\).\(SHOULD\)

지연 시간 샘플은 모호한 트랜잭션에서 파생되어서는 안 됩니다. 표준적인 예는 데이터를 재전송하지만 이후에 어떤 복사본이 승인되는지 확인할 수 없는 프로토콜에 있습니다. 이러한 모호함으로 인해 대기 시간을 정확하게 계산하는 데 문제가 있습니다. \[RFC6298\]에서 Karn의 알고리즘에 대한 논의를 참조하세요. 이 요구 사항은 발신자가 잘못된 측정에 의존하지 않고 지연 시간을 확실하게 추정할 수 있도록 보장합니다.\(MUST NOT\)

재전송 여부에 관계없이 손실 감지를 제공하는 타이머를 준비하기 위해 대기 시간 추정이 사용되는 경우 타이머 만료는 네트워크의 정체 표시로 해석되어 전송 속도가 안전하고 보수적인 속도로 조정되도록 해야 합니다. \(예를 들어, TCP는 혼잡 창을 하나의 세그먼트로 축소합니다\[RFC5681\]\).\(MUST\)

일부 애플리케이션에서는 엔드포인트 간의 대기 시간을 경험적으로 샘플링하기 전에 초기 대기 시간 추정이 필요합니다. 예를 들어 재전송 타이머를 설정할 때 엔드포인트가 대기 시간을 샘플링하기 전에 전송된 메시지를 보호하기 위해 초기 값이 필요합니다. 이 초기 대기 시간 추정치는 일반적으로 주어진 애플리케이션에 대해 가능한 한 보수적\(대규모\)이어야 합니다. 예를 들어, 경로 대기 시간에 대한 지식이 없는 경우 TCP에서는 초기 RTO\(재전송 시간 초과\)를 1 이상으로 설정해야 합니다.\(SHOULD\)

두 번째 \[RFC6298\]. UDP 애플리케이션은 마찬가지로 1초의 초기 대기 시간 추정치를 사용해야 합니다. 1초보다 짧은 값은 문제가 될 수 있습니다\(\[RFC6298\] 부록의 데이터 분석 참조\).\(SHOULD\)

---
#### **3.1.2.  Bulk-Transfer Applications**

UDP를 통해 피어에 대량 데이터 전송을 수행하는 애플리케이션, 즉 RTT당 몇 개 이상의 UDP 데이터그램을 교환하는 애플리케이션은 TFRC \[RFC5348\], 창 기반 TCP 유사 혼잡 제어를 구현하거나 애플리케이션이 이를 준수하는지 확인해야 합니다. 혼잡제어 원리를 이용하여\(SHOULD\)

TFRC는 IETF의 다른 전송 프로토콜과 호환되는 방식으로 혼잡 제어와 공정성을 모두 제공하도록 설계되었습니다. 애플리케이션이 TFRC를 구현하는 경우 TFRC가 이미 해당 문제를 해결했기 때문에 섹션 3.1.2의 나머지 지침을 따를 필요는 없지만 여전히 섹션 3의 후속 하위 섹션에 있는 나머지 지침을 따라야 합니다.\(SHOULD\)

TFRC 또는 TCP와 유사한 윈도잉을 구현하지 않기로 선택한 대량 전송 애플리케이션은 크기 순서 내에서 TCP와 공정하게 경쟁하는 대역폭\(용량\) 사용을 초래하는 혼잡 제어 체계를 구현해야 합니다.\(SHOULD\)

\[RFC3551\]의 섹션 2에서는 애플리케이션이 패킷 손실률을 모니터링하여 허용 가능한 매개변수 내에 있는지 확인해야 한다고 제안합니다. 동일한 네트워크 조건에서 동일한 네트워크 경로를 통과하는 TCP 흐름이 합리적인 시간 단위로 측정된 평균 처리량을 달성하는 경우 패킷 손실은 허용 가능한 것으로 간주됩니다. 이는 UDP 흐름의 처리량보다 작지 않습니다. TCP와의 비교는 정확하게 지정할 수 없지만 시간 척도와 처리량 측면에서 "크기 순서" 비교를 위한 것입니다. 섹션 3.1.1에 지정된 타이머 관리에 대한 권장 사항도 적용됩니다.\(SHOULD\)

마지막으로 일부 대량 전송 애플리케이션은 혼잡 제어 메커니즘을 구현하지 않고 대신 예약된 경로 용량을 통한 전송에 의존하도록 선택할 수 있습니다\(섹션 3.1.9 참조\). 이는 제한된 네트워킹 환경의 하위 집합에는 허용되는 선택일 수 있지만 더 넓은 인터넷을 통한 작업에는 결코 안전한 방법이 아닙니다. 이러한 애플리케이션의 UDP 트래픽이 프로비저닝되지 않은 인터넷 경로로 누출되면 경로를 공유하는 다른 트래픽의 성능이 크게 저하될 수 있으며 심지어 정체 현상이 발생할 수도 있습니다. 제어되지 않거나 적응되지 않는 전송 동작을 지원하는 애플리케이션은 기본적으로 그렇게 해서는 안 되며, 대신 사용자에게 이 작동 모드를 명시적으로 활성화하도록 요구해야 하며 충분한 경로 용량이 예약되어 있는지 확인해야 합니다.\(SHOULD NOT\)

---
#### **3.1.3.  Low Data-Volume Applications**

언제든지 대상과 소수의 UDP 데이터그램만 교환하는 애플리케이션이 TFRC 또는 섹션 3.1.2의 다른 혼잡 제어 방식 중 하나를 구현하는 경우 네트워크는 거의 이점을 얻지 못합니다. 왜냐하면 이러한 메커니즘은 오직 효과적인 방식으로 혼잡 제어를 수행하기 때문입니다. 더 긴 전송을 위해.

언제든지 대상과 몇 개의 UDP 데이터그램만 교환하는 애플리케이션은 RTT당 평균 1개 이상의 UDP 데이터그램을 대상으로 보내지 않음으로써 전송 동작을 제어해야 합니다. \[RFC1536\]의 권장 사항과 유사하게 애플리케이션은 섹션 3.1.1에 지정된 방법을 사용하여 통신하는 모든 대상에 대한 RTT 추정치를 유지해야 합니다.\(SHOULD, SHOULD\)

일부 애플리케이션은 목적지에 대한 안정적인 RTT 추정치를 유지할 수 없습니다. 이러한 애플리케이션은 RTT\(섹션 3.1.1\)를 측정하기 위해 프로토콜 타이머를 사용할 필요가 없거나 사용할 수 없습니다. 두 가지 사례를 식별할 수 있습니다.

1. 첫 번째 사례는 통계적으로 정확한 RTT 추정치를 설정하기 위해 피어와 너무 적은 UDP 데이터그램을 교환하지만 전송의 신뢰성을 모니터링할 수 있는 애플리케이션의 경우입니다\(섹션 3.3\). 이러한 애플리케이션은 패킷이 손실된 것으로 간주될 때 기하급수적으로 백오프되는 미리 결정된 전송 간격을 사용할 수 있습니다. TCP는 초기값을 1초로 지정하고 있으며\[RFC6298\], 이는 UDP 애플리케이션의 초기값으로도 권장됩니다\(RECOMMENDED\). SIP \[RFC3261\] 및 General Internet Signaling Transport \(GIST\) \[RFC5971\]와 같은 일부 낮은 데이터 볼륨 애플리케이션은 500ms 간격을 사용하며 더 짧은 값은 많은 경우 문제가 될 수 있습니다. 이전 사례와 마찬가지로 초기 시간 초과는 가능한 최대 시간 초과가 아니라는 점에 유의하세요. 섹션 3.1.1을 참조하세요.\(MAY, SHOULD\)

2. 두 번째 애플리케이션 사례는 대상이 반환 트래픽을 보내지 않기 때문에 대상에 대한 RTT 추정치를 유지할 수 없습니다. 이러한 애플리케이션은 3초마다 두 개 이상의 UDP 데이터그램을 전송해서는 안 되며 가능하면 훨씬 덜 공격적인 속도를 사용해야 합니다. 값이 짧을수록 많은 경우 문제가 발생할 수 있습니다. 이 경우 전송 속도는 이전 경우보다 더 보수적이어야 합니다. 반환 트래픽이 부족하여 패킷 손실, 즉 정체를 감지할 수 없고 따라서 애플리케이션이 로드를 줄이기 위해 지수 백오프를 수행할 수 없기 때문입니다.\(SHOULD NOT\)

---
#### **3.1.4.  Applications Supporting Bidirectional Communications**

양방향으로 통신하는 애플리케이션은 양방향 통신에 대해 혼잡 제어를 사용해야 합니다. 예를 들어, 클라이언트-서버, 요청-응답 스타일 애플리케이션의 경우 클라이언트는 서버에 대한 요청 전송을 정체 제어해야 하며, 서버는 클라이언트에 대한 응답을 정체 제어해야 합니다. 순방향과 역방향의 혼잡은 상관 관계가 없으며, 애플리케이션은 양방향의 혼잡을 독립적으로 감지하고 응답하거나 전체 왕복 경로에서 확인된 응답을 기반으로 새로운 요청과 재전송된 요청을 제한해야 합니다.\(SHOULD, SHOULD, SHOULD\)

---
#### **3.1.5.  Implications of RTT and Loss Measurements on Congestion Control**

TCP, SCTP 및 DCCP와 같은 전송은 정체를 적시에 감지하여 정체가 발생할 때 최대 전송 속도를 즉시 감소시킵니다. 이 반응은 일반적으로 손실/혼잡이 발생한 후 1\~2 RTT 후에 완료됩니다. UDP를 사용하는 애플리케이션은 정체를 나타내는 신호에 대한 신속한 반응을 제공하는 정체 제어 체계를 구현해야 합니다\(예: 정체 신호 이후 다음 RTT 내에서 속도를 줄임으로써\).\(SHOULD\)

UDP 혼잡 제어 알고리즘의 작동은 TCP 작동 방식과 매우 다를 수 있습니다. 여기에는 TCP의 "RTT마다 변경률" 모델 내에서 유용하게 작동할 수 없는 애플리케이션에 맞는 시간 척도로 응답하는 정체 제어가 포함됩니다. RTT가 낮거나 변화하는 애플리케이션은 특히 샘플링 오류\(예: 측정 노이즈 또는 타이머 정확도로 인해\)에 취약합니다. 이는 더 긴 간격에 걸쳐 손실/혼잡 및 RTT 측정을 평균화해야 한다는 것을 의미합니다. 그러나 이로 인해 혼잡 감지가 추가로 지연될 수도 있습니다. 일부 애플리케이션은 다음을 포함한 다양한 이유로 전송 속도를 즉시 줄이는 방식으로 반응하지 않을 수 있습니다. RTT 및 손실 측정은 주기적으로만 수행됩니다\(예: RTCP 사용\), 정보를 필터링하는 데 추가 시간이 필요하거나 애플리케이션이 변경만 가능함 미리 결정된 간격으로 전송 속도를 조정합니다\(예: 일부 비디오 코덱\).

따라서 혼잡 제어 알고리즘을 설계할 때 설계자는 피드백 부족이나 혼잡 이벤트로 인해 부하를 줄이는 데 걸리는 총 시간을 고려해야 합니다. 가장 최근의 RTT 측정값이 실제 RTT보다 작거나 측정된 손실률이 현재 속도보다 작은 애플리케이션에서는 사용 가능한 용량을 과대평가할 수 있습니다. 이런 과대평가는

경로 용량을 공유하는 애플리케이션이나 다른 흐름에 정체를 일으키는 전송 속도가 발생하고 정체 붕괴에 기여할 수 있습니다. 이 두 가지 모두를 피해야 합니다.

UDP용으로 설계된 혼잡 제어는 혼잡이 발생할 때 가능한 한 빨리 응답해야 하며, 새로운 속도를 선택할 때 손실률과 응답 시간을 모두 고려해야 합니다. 구현된 혼잡 제어 방식은 공통 병목 현상을 공유하는 다른 흐름을 중단시키지 않도록 TCP와 비슷한 대역폭\(용량\) 사용을 발생시켜야 합니다.\(SHOULD, SHOULD\)

---
#### **3.1.6.  Burst Mitigation and Pacing**

UDP 애플리케이션은 애플리케이션이 네트워크에 전송할 수 있는 전송 버스트를 규제하는 메커니즘을 제공해야 합니다. 많은 TCP 및 SCTP 구현에서는 발신자가 회선 속도로 긴 버스트를 생성하지 못하도록 방지하는 메커니즘을 제공합니다. 이는 공통 네트워크 병목 현상을 공유하는 애플리케이션에 조기 손실을 유발하는 것으로 알려져 있기 때문입니다. TCP \[ALLMAN\]을 통한 페이싱 사용은 TCP 흐름과 다른 흐름의 공존을 향상시키는 것으로도 나타났습니다. 과도한 전송 버스트를 방지해야 할 필요성은 애플리케이션 사양\(예: \[RFC7143\]\)에도 명시되어 있습니다.\(SHOULD\)

데이터 볼륨이 낮은 UDP 흐름도 패킷 페이싱의 이점을 누릴 수 있습니다. 예를 들어 손실에 대한 견고성을 향상하기 위해 패킷의 복사본 3개를 보내는 애플리케이션은 여러 RTT에 걸쳐 해당 세 패킷의 속도를 조절하여 세 패킷이 모두 실패할 확률을 줄이는 것이 좋습니다. 동일한 혼잡 이벤트\(또는 버스트 손상과 같은 기타 이벤트\)로 인해 손실될 수 있습니다.\(SHOULD\)

---
#### **3.1.7.  Explicit Congestion Notification**

인터넷 애플리케이션은 명시적 혼잡 알림\(ECN\) \[RFC3168\]을 사용하여 지원하는 서비스 \[RFC8087\]에 대한 이점을 얻을 수 있습니다.

TCP와 같은 인터넷 전송은 ECN을 활용하는 데 필요한 메커니즘 세트를 제공합니다. ECN은 전송된 패킷의 IP 헤더에 ECN 가능 코드 포인트\(ECT\(0\) 또는 ECT\(1\)\)를 설정하여 작동합니다. 이는 ECN 지원 네트워크 장치\(라우터 및 기타 장치\)가 IP 패킷을 초기 혼잡 신호로 삭제하는 대신 표시\(경험한 혼잡 경험, 혼잡 경험\(CE\) 코드포인트 설정\)할 수 있음을 나타냅니다.

UDP 애플리케이션은 API가 ECN을 지원하고 ECN을 지원하는 데 필요한 프로토콜 메커니즘을 구현하는 경우 ECN을 활성화함으로써 이점을 얻을 수도 있습니다.

애플리케이션이 UDP를 통해 ECN을 사용하는 데 필요한 메커니즘 세트는 다음과 같습니다.

o 발신자는 해당 애플리케이션이 호환 가능한 ECN 방법을 사용하여 ECN 피드백을 제공할 수 있는지 확인\(예: 협상\)하는 방법을 제공해야 합니다.\(MUST\)

o UDP 포트에 대해 ECN 사용을 활성화하는 수신기는 이 포트에서 수신하는 각 UDP 데이터그램에 대해 수신기의 ECN 필드를 확인해야 합니다.\(MUST\)

o 수신 애플리케이션은 전송 애플리케이션에 정체 정보 피드백을 제공해야 합니다. 이는 전송 애플리케이션에 정체 정보를 다시 공급하는 메커니즘을 제공하여 CE 마크와 함께 수신된 데이터그램의 존재를 보고해야 합니다. 피드백은 ECT\(1\) 및 ECT\(0\)/Not-ECT 패킷\[RFC7560\]의 존재도 보고할 수 있습니다. \(\[RFC3168\] 및 \[RFC7560\]은 TCP에 대한 방법을 지정합니다.\)\(MUST, MAY\)

o ECN 가능 데이터그램을 전송하는 애플리케이션은 정체가 발생했음을 나타내는 피드백을 수신할 때 적절한 정체 반응을 제공해야 합니다. 이는 동일한 조건에서 TCP의 반응보다 적지 않은 UDP 혼잡 제어 방법\(섹션 3.1 참조\)에 의해 전송 속도를 감소시키는 결과를 가져옵니다.\(MUST\)

o 발신자는 ECN 필드를 올바르게 지원하지 않는 네트워크 경로를 감지해야 합니다. 감지되면 정체에 보수적으로 대응하거나 ECN\[RFC8087\]을 사용하지 않는 상태로 되돌아가야 합니다. 이 방법은 세션 수명 동안 발생할 수 있는 네트워크 경로 내 변경 사항에 대해 견고해야 합니다.\(SHOULD\)

o 발신자는 CE 표시 패킷\[RFC8087\]을 보고하지 못하는 오작동하는 수신자를 감지하고 적절하게 대응할 수 있는 메커니즘을 제공하는 것이 좋습니다.

\[RFC6679\]는 RTP\(Real-Time Protocol\)를 사용하는 UDP 기반 애플리케이션에 ECN을 사용할 수 있는 방법을 설명하여 이러한 지원에 대한 지침과 예를 제공합니다. 이러한 메커니즘 세트를 제공할 수 없지만 ECN 사용의 이점을 얻으려는 애플리케이션은 이미 ECN\(예: TCP\)을 지원하는 전송 프로토콜을 사용하는 것이 좋습니다.

---
#### **3.1.8.  Differentiated Services Model**

UDP를 사용하는 애플리케이션은 차별화된 서비스\(DiffServ\) QoS\(서비스 품질\) 프레임워크를 사용할 수 있습니다. 차별화된 서비스 처리를 활성화하기 위해 UDP 발신자는

네트워크로 전송되는 패킷의 DSCP\(Differentiated Services Code Point\) 필드 \[RFC2475\]. 일반적으로 UDP 원본/대상 포트 쌍은 흐름에 속하는 모든 패킷에 대해 단일 DSCP 값을 설정하지만 이 섹션의 뒷부분에 설명된 대로 여러 DSCP를 사용할 수 있습니다. DSCP는 작은 고정 값 집합\(클래스 선택기 코드 포인트\), PHB\(홉별 동작\) 사양에 정의된 권장 값 집합 또는 특정 네트워크에 대해 순전히 로컬 의미를 갖는 값에서 선택될 수 있습니다. DiffServ를 지원하는 것입니다. 일반적으로 패킷은 소스와 대상 사이의 여러 네트워크를 통해 전달될 수 있습니다.

기본값이 아닌 DSCP 값을 설정할 때 애플리케이션은 트래픽 소스와 대상 사이에서 DSCP 표시가 변경되거나 제거될 수 있다는 점을 인식해야 합니다. 이는 DSCP를 사용하는 애플리케이션의 디자인에 영향을 미칩니다. 특히 애플리케이션은 특정 네트워크 처리 구현에 의존하지 않도록 설계되어야 합니다. 대신 현재 전송 속도가 네트워크의 혼잡을 유발하는지 확인하기 위해 혼잡 제어 방법을 구현해야 합니다.\(SHOULD\)

\[RFC7657\]은 DSCP 사용의 의미를 설명하고 단일 네트워크 5튜플\(소스 및 대상 주소, 소스 및 대상 포트, 사용되는 전송 프로토콜\(이 경우 UDP 또는 UDP-Lite\)\) 내에서 여러 DSCP 사용에 대한 권장 사항을 제공합니다. , 특히 혼잡 제어 또는 신뢰성 기능\(예: 재전송, 재정렬\)을 통해 전송 프로토콜 상호 작용에 예상되는 영향. 여러 DSCP를 사용하면 보낸 사람이 사용하는 네트워크 전달 리소스 집합이 늘어나 순서가 바뀔 수 있습니다. 또한 리소스 고갈이나 장애에 대한 노출도 높아질 수 있습니다.

---
#### **3.1.9.  QoS, Pre-Provisioned, or Reserved Capacity**

IETF는 일반적으로 Best Effort 일반 인터넷 내에서 사용할 프로토콜을 지정합니다. 때로는 다른 적용 가능성을 가진 프로토콜을 지정하는 것이 관련이 있습니다. UDP를 사용하는 애플리케이션은 통합 서비스 QoS 프레임워크를 사용할 수 있습니다. 이 프레임워크는 일반적으로 통제된 환경\(예: 단일 관리 도메인 또는 도메인 간 쌍방 합의 연결\) 내에서 사용할 수 있습니다. 인터넷용 애플리케이션은 자신이 사용하는 네트워크에서 QoS 메커니즘을 지원한다고 가정해서는 안 되며, 따라서 실제 네트워크 경로가 프로비저닝된 서비스를 제공하지 않는 경우 혼잡 제어, 오류 복구 등을 제공해야 합니다.\(SHOULD NOT\)

일부 UDP 애플리케이션은 사전 프로비저닝된 용량 또는 동적 프로비저닝\(예: RSVP\)을 통해 예약된 용량을 사용하는 네트워크 경로를 통해서만 배포될 것으로 예상됩니다. 멀티캐스트 애플리케이션은 사전 프로비저닝과 함께 사용됩니다.

용량\(예: 액세스 네트워크 내 IPTV 배포\) 이러한 애플리케이션은 혼잡 제어 메커니즘을 구현하지 않고 대신 이러한 용도로 용량이 프로비저닝되고 예약된 경로에서만 전송하는 데 의존할 수 있습니다. 이는 제한된 네트워킹 환경의 하위 집합에는 허용되는 선택일 수 있지만 더 넓은 인터넷을 통한 작업에는 결코 안전한 방법이 아닙니다. 이 옵션을 선택하는 애플리케이션은 원하는 격리를 초래하는 프로비저닝 및 관리 절차를 신중하고 자세하게 설명해야 합니다.\(MAY, SHOULD\)

제어되지 않거나 적응되지 않는 전송 동작을 지원하는 애플리케이션은 기본적으로 그렇게 해서는 안 되며, 대신 사용자가 이 작동 모드를 명시적으로 활성화하도록 요구해야 합니다.\(SHOULD NOT\)

통제된 환경\(섹션 3.6 참조\) 내에서 사용하도록 설계된 애플리케이션은 네트워크 관리 기능을 활용하여 혼잡을 유발하는지 여부를 감지하고 그에 따라 대응할 수 있습니다. 이러한 애플리케이션의 트래픽이 프로비저닝되지 않은 인터넷 경로로 누출되면 경로를 공유하는 다른 트래픽의 성능이 크게 저하되고 정체가 붕괴될 수도 있습니다. 이러한 네트워크용으로 설계된 프로토콜은 프로비저닝되지 않은 인터넷 경로\(예: \[RFC7510\]\)로 트래픽이 누출되는 것을 방지하기 위해 네트워크 가장자리에서 메커니즘을 제공해야 합니다\(SHOULD\). 동일한 경로를 공유하는 다른 애플리케이션을 보호하려면 애플리케이션은 섹션 3.1.10에 설명된 대로 적절한 회로 차단기도 배포해야 합니다.\(SHOULD, SHOULD\)

통제된 환경을 대상으로 하는 IETF 사양은 애플리케이션을 통제된 환경으로 제한하는 적용 가능성 설명을 제공할 것으로 예상됩니다\(섹션 3.6 참조\).

---
#### **3.1.10.  Circuit Breaker Mechanisms**

전송 회로 차단기는 흐름으로 인한 혼잡을 추정하고 과도한 혼잡이 감지되면 흐름을 종료\(또는 속도를 크게 줄이는\)하는 데 사용되는 자동 메커니즘입니다\[RFC8084\]. 이는 이기종 인터넷과 사전 예측이 어려운 트래픽에 필수적인 혼잡 붕괴\(다른 흐름에서 사용할 수 있는 리소스의 고갈\)를 방지하기 위한 안전 조치입니다.

회로 차단기는 최후의 수단으로 사용되는 보호 메커니즘입니다. 정상적인 상황에서는 회로 차단기가 작동되어서는 안 됩니다. 과부하가 심할 때 물건을 보호하도록 설계되었습니다. 목표는 일반적으로 네트워크 경로의 사용 가능한 용량을 반영하는 최대 전송 속도를 제한하는 것입니다. 회로 차단기는 개별 UDP 흐름 또는 트래픽 집계\(예: 네트워크 터널을 사용하여 전송된 트래픽\)에서 작동할 수 있습니다.

\[RFC8084\]는 회로 차단기 사용에 대한 지침과 예를 제공합니다. RTP에서 회로 차단기 사용은 \[RFC8083\]에 지정되어 있습니다.

일반 인터넷에서 사용되는 애플리케이션은 혼잡 제어를 구현하지 않거나 낮은 데이터 볼륨 서비스를 운영하는 경우 전송 회로 차단기를 구현해야 합니다\(섹션 3.6 참조\). 모든 애플리케이션은 전송 회로 차단기\[RFC8084\]를 구현할 수 있으며 네트워크 트래픽에 대한 최후의 수단 보호를 제공하기 위해 최소한 느리게 작동하는 전송 회로 차단기 구현을 고려하는 것이 좋습니다.\(SHOULD, MAY\)

---
#### **3.1.11.  UDP Tunnels**

점점 더 널리 사용되는 UDP 사용 중 하나는 터널링 프로토콜 \[INT-TUNNELS\]입니다. 여기서 터널 끝점은 UDP 데이터그램 내에 다른 프로토콜의 패킷을 캡슐화하고 이를 다른 터널 끝점으로 전송합니다. 페이로드. 이러한 프로토콜의 한 예는 Teredo \[RFC4380\]입니다. 터널은 물리적 인터넷 토폴로지에서 멀리 떨어져 있는 위치를 직접 연결하는 것처럼 보이고 가상\(개인\) 네트워크를 만드는 데 사용할 수 있는 가상 링크를 설정합니다. UDP를 터널링 프로토콜로 사용하는 것은 많은 미들박스가 UDP를 사용한 전송을 지원하기 때문에 경로를 따라 존재할 수 있는 미들박스에서 페이로드 프로토콜을 지원하지 않는 경우 매력적입니다.

잘 구현된 터널은 일반적으로 터널링된 링크를 포함하는 경로를 통해 전송하는 엔드포인트에 보이지 않습니다. 반면, UDP 터널의 경로에 있는 라우터, 즉 두 터널 끝점 사이의 라우터에는 UDP 터널이 생성하는 트래픽이 일반 UDP 흐름이고 캡슐화기와 캡슐화 해제기는 일반 UDP 전송으로 나타납니다. 및 UDP 수신 애플리케이션. 다른 흐름이 하나 이상의 UDP 터널과 경로를 공유할 수 있으므로 정체 제어를 고려해야 합니다.

UDP 터널이 특정 혼잡 제어 메커니즘을 사용해야 하는지 여부를 결정하는 두 가지 요소가 있습니다. 첫째, 페이로드 트래픽이 IP 기반인지 여부입니다. 둘째, 터널링 방식이 터널 내에서 전송되는 페이로드 트래픽의 양에 해당하는 양의 UDP 트래픽을 생성하는지 여부입니다.

IP 기반 유니캐스트 트래픽은 일반적으로 혼잡이 제어되는 것으로 가정됩니다. 즉, 송신자에서 IP 기반 유니캐스트 트래픽을 생성하는 전송 프로토콜이 이미 경로의 혼잡을 해결하기에 충분한 메커니즘을 채택하고 있다고 가정합니다. 결과적으로 IP 기반 유니캐스트 트래픽을 전달하는 터널은

이미 경로를 공유하는 다른 트래픽과 적절하게 상호 작용하므로 터널에 대한 특정 혼잡 제어 메커니즘이 필요하지 않습니다.

그러나 터널의 IP 트래픽이 정체 제어되지 않는 것으로 알려진 경우 터널링된 트래픽이 경로를 공유하는 다른 트래픽에 미치는 영향을 제한하기 위한 추가 조치를 권장합니다. IP 멀티캐스트 트래픽을 전달하는 터널의 구체적인 사례는 섹션 4.1을 참조하세요.\(SHOULD\)

다음 지침에서는 이러한 가능한 사례를 더 자세히 정의합니다.

1. 터널은 페이로드 트래픽의 볼륨에 해당하는 볼륨에서 UDP 트래픽을 생성하며, 페이로드 트래픽은 IP 기반이며 혼잡이 제어됩니다.

- 이것은 틀림없이 인터넷 터널의 가장 일반적인 경우입니다. 이 경우 UDP 터널은 자체 혼잡 제어 메커니즘을 사용해서는 안 됩니다. 왜냐하면 터널링된 트래픽의 혼잡 손실은 이미 터널링된 트래픽의 원래 발신자에서 적절한 혼잡 응답을 트리거하기 때문입니다. 회로 차단기 메커니즘은 집계된 트래픽의 엔벨로프를 제어하여 이점을 제공할 수 있습니다.\(SHOULD NOT\)

- 이 지침은 대부분의 IP 기반 통신이 혼잡 제어된다는 가정을 바탕으로 작성되었습니다. 정체가 제어되지 않는 것으로 알려진 IP 기반 트래픽에 UDP 터널을 사용하는 경우 다음 지침 세트가 적용됩니다.

2. 터널은 페이로드 트래픽의 볼륨에 해당하는 볼륨에서 UDP 트래픽을 생성하며 페이로드 트래픽은 IP 기반으로 알려져 있지 않거나 IP 기반으로 알려져 있지만 혼잡 제어가 되지 않는 것으로 알려져 있습니다.

- 예를 들어 일부 링크 계층 프로토콜이 UDP 내에 캡슐화되는 경우가 이에 해당할 수 있습니다\(그러나 모든 링크 계층 프로토콜은 아니며 일부는 혼잡 제어됨\). 터널링된 비IP 트래픽의 혼잡 손실이 발신자에서 적절한 혼잡 응답을 촉발할 것인지는 알려지지 않았기 때문에 UDP 터널은 전달하는 트래픽에 맞게 설계된 적절한 혼잡 제어 메커니즘이나 회로 차단기 메커니즘을 사용해야 합니다. 터널은 일반적으로 중간 라우터에 관한 한 대량 전송 애플리케이션이므로 섹션 3.1.2의 지침이 적용됩니다.\(SHOULD\)

3. 터널은 그렇지 않은 볼륨에서 UDP 트래픽을 생성합니다.

- 페이로드 트래픽이 IP 기반인지 아니면 혼잡 제어인지 여부에 관계없이 페이로드 트래픽의 볼륨에 해당합니다.

- 이 클래스의 예로는 정방향 오류 수정을 사용할 때 중복성 증가로 인해 손실 시 전송 속도를 높이거나 전송 동작에 제한이 없는 일정한 속도로 전송하는 UDP 터널이 있습니다. 터널링을 위한 UDP의 이러한 특수한 사용은 이 문서에 제공된 일반 지침의 범위를 벗어납니다. 이러한 특수 터널의 구현자는 터널링 메커니즘 설계 시 혼잡 제어를 신중하게 고려해야 하며 회로 차단기 메커니즘의 사용을 고려해야 합니다.\(SHOULD\)

캡슐화된 페이로드 유형은 UDP 포트로 식별될 수 있습니다. 이더넷 유형 또는 IP 프로토콜 번호로 식별됩니다. 터널은 터널이 전달할 수 있는 흐름 유형을 제한하는 메커니즘을 제공해야 합니다\(SHOULD\). 예를 들어, IP를 전달하도록 설계된 UDP 터널은 수신 시 IP가 아닌 트래픽을 필터링해야 합니다. 이는 일반 터널 캡슐화가 사용될 때 특히 중요합니다\(예: EtherType 값을 사용하여 캡슐화하는 것\). 이러한 터널은 특정 배포에 대해 캡슐화되도록 허용된 트래픽 유형을 제한하는 메커니즘을 제공해야 합니다\(\[INT-TUNNELS\] 참조\).\(SHOULD, SHOULD\)

터널링 메커니즘을 설계하려면 다른 많은 UDP 애플리케이션에 필요한 것보다 훨씬 더 많은 전문 지식이 필요합니다. 왜냐하면 터널은 일반적으로 터널을 통해 전송되는 엔드포인트에 투명하도록 설계되어 IP 링크 \[INT-TUNNELS\]의 동작을 올바르게 에뮬레이트해야 하기 때문입니다. 예:

o ECN 코드 포인트 \[RFC6040\]를 사용하여 전달하거나 캡슐화하는 터널에 대한 요구 사항.

o 터널 끝점에 의한 IP DSCP 필드 사용 \[RFC2983\].

o 터널 설계 시 캡슐화 고려 사항 \[ENCAP\].

o ICMP 메시지 사용 \[INT-TUNNELS\].

o 터널의 조각화 및 패킷 크기 처리

- \[내부 터널\].

o ECMP\(등가 다중 경로\) 라우팅을 지원하도록 설계된 터널의 소스 포트 사용\(섹션 5.1.1 참조\).

o 헤더 \[INT-TUNNELS\] 보호 필요성과 IPv6 터널에 대한 체크섬 사용에 대한 지침\(섹션 3.4.1 참조\).

o 운영 및 유지 관리 \[INT-TUNNELS\] 지원.

동시에 터널링된 트래픽은 터널이 전송하는 네트워크의 관점에서 볼 때 다른 트래픽과 마찬가지로 애플리케이션 트래픽입니다. 이 문서에서는 UDP 터널 구현에 대한 혼잡 제어 고려 사항만 다룹니다. 기타 필수 터널링 동작에 대한 논의는 범위를 벗어납니다.

---
### **3.2.  Message Size Guidelines**

IP 단편화는 인터넷 통신의 효율성과 신뢰성을 저하시킵니다. 단일 조각이 손실되면 조각난 패킷 전체가 손실됩니다. 다른 모든 조각이 올바르게 수신되더라도 원본 패킷을 재조립하여 전달할 수 없기 때문입니다. 조각화와 관련된 이러한 근본적인 문제는 IPv4와 IPv6 모두에 존재합니다.

또한 일부 NAT\(네트워크 주소 변환기\) 및 방화벽은 IP 조각을 삭제합니다. NAT에 의해 수행되는 네트워크 주소 변환은 완전한 IP 패킷에서만 작동하며 일부 방화벽 정책에서는 완전한 IP 패킷 검사도 요구합니다. 이러한 경우에도 일부 NAT 및 방화벽은 필요한 재조립 기능을 구현하지 않습니다. 대신 모든 조각을 삭제하도록 선택합니다. 마지막으로 \[RFC4963\]에는 IPv4 단편화와 관련된 기타 문제가 문서화되어 있습니다.

이러한 문제로 인해 애플리케이션은 대상 경로를 따라 최대 전송 단위\(MTU\)를 초과하는 IP 패킷을 생성하는 UDP 데이터그램을 전송해서는 안 됩니다. 결과적으로 애플리케이션은 IP 계층에서 제공하는 경로 MTU 정보를 사용하거나 PMTUD\(경로 MTU 검색\) 자체를 구현하여 대상에 대한 경로가 조각화 없이 원하는 메시지 크기를 지원할지 여부를 결정해야 합니다. .\(SHOULD NOT, SHOULD\)

그러나 경로 MTU 검색을 활성화하는 ICMP 메시지는 미들박스\(방화벽 포함\) \[RFC4890\]에 의해 점점 더 필터링되고 있습니다. 경로에 터널이 포함된 경우 터널 수신 역할을 하는 일부 장치는 터널이 통과하는 네트워크 장치에서 생성된 ICMP 메시지를 삭제하여 이러한 메시지가 UDP 끝점에 도달하지 못하도록 합니다.

패킷화 계층 경로 MTU 검색\(PLPMTUD\) \[RFC4821\]은 ICMP 메시지에 대한 네트워크 지원에 의존하지 않으므로 표준 PMTUD보다 더 강력한 것으로 간주됩니다. ICMP 메시지의 "블랙홀링"에 취약하지 않습니다. PLPMTUD가 작동하려면 프로브 패킷을 전송하고 이러한 프로브의 손실 또는 성공을 설명하기 위해 전송이 사용되는 방식을 변경해야 합니다. 이는 PMTU 알고리즘을 업데이트할 뿐만 아니라 손실 복구, 혼잡 제어 등에 영향을 줍니다. 이러한 업데이트된 메커니즘을 구현할 수 있습니다.

연결 지향 전송\(예: TCP, SCTP, DCCP\) 내에 있지만 UDP의 일부는 아닙니다. 이러한 유형의 피드백은 일반적으로 단방향 애플리케이션에는 존재하지 않습니다.

따라서 PLPMTUD는 이 방법을 사용하려는 UDP 애플리케이션에 추가 설계 요구 사항을 적용합니다. UDP 터널의 경우 특히 그렇습니다. 프로브 패킷 전송의 오버헤드를 고려해야 하고 터널에 혼잡 제어 메커니즘을 추가해야 할 뿐만 아니라\(섹션 3.1.11 참조\) 터널 캡슐화 해제기의 데이터 경로를 복잡하게 만들기 때문입니다.

PMTU/PLPMTUD 검색을 수행하라는 권장 사항을 따르지 않는 애플리케이션은 여전히 ​​경로 MTU를 초과하는 IP 패킷을 발생시키는 UDP 데이터그램 전송을 피해야 합니다. 실제 경로 MTU를 알 수 없기 때문에 이러한 애플리케이션은 기본 유효 MTU\(\[RFC1122\]의 EMTU\_S\)보다 짧은 메시지 전송으로 대체해야 합니다. IPv4의 경우 EMTU\_S는 576바이트와 첫 번째 홉 MTU\[RFC1122\] 중 더 작습니다. IPv6의 경우 EMTU\_S는 1280바이트입니다\[RFC2460\]. 경로에 라우터가 없는 직접 연결된 대상에 대한 유효 PMTU는 구성된 인터페이스 MTU이며, 이는 최대 링크 페이로드 크기보다 작을 수 있습니다. 최소 크기의 UDP 데이터그램 전송은 더 큰 PMTU를 지원하는 경로에서는 비효율적입니다. 이것이 PMTU 검색을 구현하는 두 번째 이유입니다.\(SHOULD, SHOULD\)

적절한 UDP 페이로드 크기를 결정하려면 애플리케이션은 IP 헤더의 크기\(IPv4 선택적 헤더 또는 IPv6 확장 헤더 포함\)와 UDP 헤더의 길이\(8바이트\)를 PMTU 크기에서 빼야 합니다. 최대 세그먼트 크기\(MSS\)로 알려진 이 크기는 TCP/IP 스택\[RFC1122\]에서 얻을 수 있습니다.\(MUST\)

IPv4 또는 IPv6의 유효 PMTU를 초과하는 메시지를 보내지 않는 애플리케이션은 위의 메커니즘을 구현할 필요가 없습니다. 터널이 있으면 유효 PMTU\[INT-TUNNELS\]가 추가로 감소할 수 있으므로 PMTU 검색을 구현하는 것이 도움이 될 수 있습니다.

애플리케이션 계층 메시지를 여러 UDP 데이터그램으로 조각화하는 애플리케이션은 각 데이터그램이 독립적으로 수신될 수 있도록 이 조각화를 수행해야 하며, 애플리케이션이 자체 신뢰성 메커니즘을 구현하는 경우 독립적으로 재전송되어야 합니다.\(SHOULD\)

---
### **3.3.  Reliability Guidelines**

애플리케이션 설계자는 일반적으로 UDP가 신뢰성을 제공하지 않는다는 점\(예: 손실된 패킷을 재전송하지 않음\)을 알고 있습니다. 종종 이는 UDP를 전송 프로토콜로 간주하는 주된 이유입니다. 안정적인 메시지 전달이 필요한 애플리케이션은 적절한 메커니즘을 자체적으로 구현해야 합니다.\(MUST\)

UDP는 또한 데이터그램 중복을 방지하지 않습니다. 즉, 응용 프로그램은 동일한 UDP 데이터그램의 여러 복사본을 수신할 수 있으며 일부 중복은 잠재적으로 첫 번째 것보다 훨씬 늦게 도착할 수 있습니다. 애플리케이션 설계자는 이러한 데이터그램 중복을 적절하게 처리해야 하며 결과적으로 중복을 감지하는 메커니즘을 구현해야 할 수도 있습니다. UDP 데이터그램 수신이 멱등성 작업만 트리거하는 경우에도 응용 프로그램은 로드를 줄이기 위해 중복된 데이터그램을 억제할 수 있습니다.\(SHOULD\)

순서화된 전달이 필요한 애플리케이션은 데이터그램 순서를 스스로 재설정해야 합니다. 인터넷은 일시적인 라우팅, 간헐적인 연결 또는 이동성 등으로 인해 일부 패킷을 다른 패킷에 비해 상당히 지연시킬 수 있습니다. 이로 인해 UDP 데이터그램이 전송 순서와 다른 순서로 수신기에 도착하는 재정렬이 발생할 수 있습니다.\(MUST\)

여러 전송 포트를 사용하는 애플리케이션은 세션 간 재정렬에 강력해야 합니다. ECMP\(Equal Cost Multipath\) 전달과 같은 네트워크 내의 로드 밸런싱 기술로 인해 서로 다른 전송 세션 간, 심지어 동일한 두 네트워크 엔드포인트 간에서도 순서가 부족해질 수 있습니다.

패킷이 다시 정렬되거나 그 이후에도 중복 항목이 도착할 수 있는 시간이 매우 길 수 있다는 점에 유의하는 것이 중요합니다. 더욱 중요한 것은 여기에는 잘 정의된 상한 경계가 없다는 것입니다. \[RFC793\]은 TCP 세그먼트가 경험해야 하는 최대 지연\(MSL\(최대 세그먼트 수명\)\)을 2분으로 정의합니다. 다른 RFC는 다른 전송 프로토콜이나 IP 자체에 대한 MSL을 정의하지 않습니다. TCP에 대해 정의된 MSL 값은 UDP를 포함한 다른 프로토콜에서 사용해야 할 정도로 보수적입니다. 따라서 애플리케이션은 이 2분 간격 내에 수신되는 지연되거나 중복된 패킷의 수신에 강력해야 합니다.\(SHOULD, SHOULD\)

손실된 패킷이나 메시지의 재전송은 일반적인 신뢰성 메커니즘입니다. 이러한 재전송은 정체에 대한 대응으로 네트워크 로드를 증가시켜 정체를 악화시킬 수 있습니다. 재전송을 사용하는 모든 애플리케이션은 재전송\(및 애플리케이션의 원래 트래픽\)의 정체 제어를 담당합니다. 따라서 혼잡 제어 지침이 적용됩니다.

섹션 3.1. 섹션 3.1.1의 적절한 RTT 측정에 대한 지침은 재전송 패킷 손실 감지에 사용되는 타이머에도 적용됩니다.

상대적으로 복잡한 신뢰성 메커니즘을 자체적으로 구현하는 대신 신뢰성 있고 순서화된 메시지 전달이 필요한 애플리케이션은 가능할 때마다 이러한 기능을 제공하는 IETF 표준 전송 프로토콜을 선택해야 합니다.\(SHOULD\)

---
### **3.4.  Checksum Guidelines**

UDP 헤더에는 무결성 검사를 제공하는 선택적 16비트 1의 보수 체크섬이 포함되어 있습니다. 이러한 검사는 코딩 또는 암호화 관점에서 강력하지 않으며 물리 계층 오류 또는 데이터그램의 악의적인 수정을 감지하도록 설계되지 않았습니다\[RFC3819\]. 애플리케이션 개발자는 UDP 서비스를 통해 전송된 전체 개체/파일의 무결성을 확인하기 위해 데이터에 포함된 순환 중복 검사\(CRC\) 또는 키가 있거나 키가 없는 암호화 해시 등을 통해 데이터 무결성이 중요한 추가 검사를 구현해야 합니다.\(SHOULD\)

UDP 체크섬은 페이로드가 전송 중에 손상되지 않았음을 통계적으로 보장합니다. 또한 IP 주소, 포트 번호 및 프로토콜 번호를 포함하므로 수신자가 패킷의 의도된 대상인지 확인할 수 있고, 크기 필드를 포함하므로 패킷이 잘리거나 채워지지 않았는지 확인할 수 있습니다. 따라서 전송된 데이터 대신 또는 전송된 데이터에 추가로 손상된 페이로드 데이터를 수신하지 않도록 애플리케이션을 보호합니다. 체크섬 필드를 사용하여 수행되는 검사 세트에 대한 자세한 설명은 \[RFC6396\]의 섹션 3.1에 제공됩니다.

애플리케이션은 UDP 체크섬\[RFC1122\]을 활성화해야 합니다. IPv4의 경우 \[RFC768\]에서는 체크섬 값을 0으로 설정하여 사용을 비활성화하는 옵션을 허용합니다. 애플리케이션은 선택적으로 체크섬이 0인 UDP 데이터그램을 버릴 수 있습니다\[RFC1122\].\(SHOULD\)

UDP가 IPv6을 통해 사용될 때 UDP 체크섬은 IPv6 및 UDP 헤더 모두를 손상으로부터 보호하기 위해 의존하며\(IPv6에는 체크섬이 없기 때문에\) \[RFC2460\]에 지정된 대로 사용해야 합니다. 특정 조건에서 UDP 애플리케이션은 터널 프로토콜과 함께 제로 UDP 제로 체크섬 모드를 사용할 수 있습니다\(섹션 3.4.1 참조\).\(MUST\)

UDP 체크섬을 비활성화하도록 선택한 애플리케이션은 수신된 데이터의 정확성에 관해 가정해서는 안 되며, 원래 다른 대상으로 전송되었거나 손상된 UDP 데이터그램이 수신될 때 올바르게 동작해야 합니다.\(MUST NOT\)

---
#### **3.4.1.  IPv6 Zero UDP Checksum**

\[RFC6935\]는 \[RFC6936\]의 요구 사항을 충족하는 경우 터널 프로토콜과 함께 제로 UDP 제로 체크섬 모드를 사용할 수 있는 방법을 정의합니다. 이 모드를 활성화할 때 애플리케이션은 메커니즘 및/또는 사용 제한을 구현해야 합니다. 여기에는 사용 범위 정의와 다른 UDP 애플리케이션으로의 트래픽 누출을 방지하기 위한 조치가 포함됩니다\(부록 A 및 섹션 3.6 참조\). IPv4 헤더는 IPv6 패킷에서 보호되지 않는 정보를 검증하므로 제로 IPv6 UDP 체크섬을 사용하기 위한 이러한 추가 설계 요구 사항은 IPv4에는 없습니다. 주요 요구사항은 다음과 같습니다.\(MUST\)

o IPv6에서 UDP 체크섬을 사용하는 것이 기본값이어야 합니다.

- 모든 구현을 위한 구성 \[RFC6935\]. 수신 엔드포인트는 특별히 활성화된 UDP 대상 포트에서 IPv6에 대한 UDP 제로 체크섬 모드의 사용만 허용해야 합니다.\(MUST, MUST\)

o \[RFC2460\]과 다른 체크섬을 지원하는 애플리케이션은 \[RFC6936\]의 섹션 4에 지정된 모든 구현 요구 사항과 \[RFC6936\]의 섹션 5에 지정된 사용 요구 사항을 준수해야 합니다.\(MUST\)

o UDP 애플리케이션은 UDP 제로 체크섬이 있는 모든 패킷에 대해 소스 및 대상 IPv6 주소가 유효한지 확인해야 하며 이 확인이 실패한 모든 패킷을 폐기해야 합니다. 잘못된 전달을 방지하기 위해 새로운 캡슐화 설계에는 최소한 IPv6 헤더, UDP 헤더 및 캡슐화용 심 헤더\(RFC6936\)를 포함하는 전송 계층의 무결성 검사가 포함되어야 합니다.\(MUST, SHOULD\)

o \[RFC6936\]의 요구 사항을 충족하는 데 도움이 되는 한 가지 방법은 섹션 3.6에 설명된 대로 이러한 터널의 사용을 제한하는 것\(예: 운영자 네트워크에 대한 트래픽을 제한하는 것\)일 수 있습니다. UDP \[RFC7510\]의 MPLS에 대해 정의된 캡슐화는 이 접근 방식을 선택합니다.

IPv4에서와 마찬가지로 UDP 체크섬을 비활성화하도록 선택한 IPv6 애플리케이션은 수신된 데이터의 정확성에 관해 가정해서는 안 되며 원래 다른 대상으로 전송되었거나 손상된 UDP 데이터그램이 수신될 때 올바르게 동작해야 합니다.\(MUST NOT\)

UDP 체크섬이 0인 IPv6 데이터그램은 \[RFC2460\]을 기반으로 체크섬을 검증하거나 NAT 또는 방화벽과 같이 UDP 체크섬 필드를 업데이트하는 미들박스에 의해 전달되지 않습니다. 이 동작을 변경하려면 UDP 체크섬이 0인 데이터그램을 올바르게 처리하도록 미들박스를 업데이트해야 합니다. 엔드투엔드 견고성을 보장하려면 일반 인터넷에 배포될 수 있는 애플리케이션은 보안을 사용하여 안전하게 대체할 수 있는 메커니즘을 제공해야 합니다.\(MUST\)

UDP 체크섬이 0인 IPv6 데이터그램을 삭제하는 미들박스가 포함된 경로를 통해 UDP 체크섬 흐름을 0으로 리디렉션하는 경로 변경이 발생할 때 체크섬입니다.

---
#### **3.4.2.  UDP-Lite**

특별한 클래스의 애플리케이션은 오류가 발생하기 쉬운 링크가 포함된 경로를 사용할 때 부분적으로 손상된 페이로드를 폐기하는 대신 전달함으로써 이점을 얻을 수 있습니다. 이러한 애플리케이션은 페이로드 손상을 허용할 수 있으며 기본 UDP 대신 UDP의 변형인 UDP-Lite\(Lightweight User Datagram Protocol\) \[RFC3828\]를 사용하도록 선택할 수 있습니다. UDP 대신 UDP-Lite를 사용하기로 선택한 애플리케이션은 섹션 3에서 UDP 사용에 대해 설명된 혼잡 제어 및 기타 지침을 따라야 합니다.\(MAY\)

UDP-Lite는 UDP "페이로드 길이" 필드의 의미를 "체크섬 적용 범위 길이" 필드의 의미로 변경합니다. 그렇지 않은 경우 UDP-Lite는 의미상 UDP와 동일합니다. UDP-Lite의 인터페이스는 체크섬 적용 범위 길이를 전달하는 단일\(소켓\) 옵션을 추가한다는 점에서 UDP의 인터페이스와 다릅니다. 발신자에서 이는 의도된 체크섬 적용 범위를 지정하며 페이로드의 보호되지 않은 나머지 부분은 " 오류에 민감하지 않은 부분". 기본적으로 UDP-Lite 체크섬 적용 범위는 전체 데이터그램에 걸쳐 확장됩니다. 필요한 경우 애플리케이션은 이 길이 값을 동적으로 수정할 수 있습니다\(예: 일부 메시지에 대한 더 큰 보호 제공\). UDP-Lite는 항상 패킷이 의도한 대상으로 전달되었는지 확인합니다. 즉, 항상 헤더 필드를 확인합니다. 민감하지 않은 부분의 오류로 인해 UDP 데이터그램이 대상에서 삭제되지는 않습니다. 따라서 UDP-Lite를 사용하는 애플리케이션은 UDP-Lite 페이로드의 민감하지 않은 부분에서 수신된 데이터의 정확성에 관해 가정하면 안 됩니다.\(MUST NOT\)

UDP-Lite 발신자는 모든 민감한 페이로드 정보를 포함하도록 최소 체크섬 범위를 선택해야 합니다. 예를 들어 RTP\(Real-Time Protocol\) \[RFC3550\]를 사용하는 애플리케이션은 RTP 헤더가 손상되지 않도록 보호하려고 할 것입니다. 해당하는 경우 애플리케이션은 UDP-Lite 페이로드의 민감하지 않은 부분\(예: 내부 CRC\)에서 전달되는 프로토콜 정보에 대한 적절한 유효성 검사도 도입해야 합니다.\(SHOULD, MUST\)

UDP-Lite 수신기는 수신 패킷에 대해 발신자가 사용하는 최소 범위\[RFC3828\]보다 작지 않은 최소 범위 임계값을 설정해야 합니다. 수신기는 부적절하게 짧은 커버리지 필드가 있는 패킷을 차단할 만큼 충분히 큰 임계값을 선택해야 합니다. 이는 고정된 값일 수도 있고 애플리케이션에 의해 협상될 수도 있습니다. UDP-Lite는 발신자와 수신자 간의 체크섬 적용 범위를 협상하는 메커니즘을 제공하지 않습니다. 따라서 이 작업은 애플리케이션에서 수행되어야 합니다.\(MUST, SHOULD\)

UDP-Lite를 사용할 때 애플리케이션에서는 여전히 패킷 손실이 발생할 수 있습니다. UDP-Lite가 제공하는 향상된 기능은 필요한 부분 적용 범위를 올바르게 식별하기 위해 UDP-Lite 헤더를 가로챌 수 있는 링크에 의존합니다. 터널 및/또는 암호화를 사용하면 UDP-Lite 데이터그램이 UDP 데이터그램과 동일하게 처리되어 패킷이 손실될 수 있습니다. IP 단편화를 사용하면 UDP-Lite 데이터그램에 대한 특별 처리를 방지할 수도 있으며 이는 애플리케이션이 IP 단편화를 피해야 하는 또 다른 이유입니다\(섹션 3.2\).\(SHOULD\)

UDP-Lite는 일부 엔드포인트 프로토콜 스택에서 지원됩니다. UDP-Lite를 사용하는 미들박스 탐색에 대한 현재 지원은 열악합니다. 왜냐하면 UDP-Lite는 UDP에 사용되는 것과 다른 IPv4 프로토콜 번호 또는 IPv6 "다음 헤더" 값을 사용하기 때문입니다. 따라서 현재 UDP-Lite를 해석하고 패킷을 전달할 때 적절한 조치를 취할 수 있는 미들박스는 거의 없습니다. 이로 인해 UDP-Lite가 미들박스에서 더 나은 지원을 얻을 때까지 UDP-Lite는 일반적인 인터넷 지원이 필요한 응용 프로그램에 덜 적합합니다.

---
### **3.5.  Middlebox Traversal Guidelines**

NAT와 방화벽은 종단간 경로를 따라 존재할 수 있는 중간 장치\("미들박스"\)의 예입니다. 미들박스는 일반적으로 흐름별 상태를 유지하는 데 필요한 기능을 수행합니다. TCP와 같은 연결 지향 프로토콜의 경우 미들박스는 연결 관리 정보를 스누핑하고 구문 분석하며 그에 따라 흐름별 상태를 생성하고 삭제합니다. UDP와 같은 비연결 프로토콜의 경우 이 접근 방식은 불가능합니다. 결과적으로 미들박스는 일부 로컬 기준에 따라 새로운 흐름을 나타내는 패킷을 볼 때 흐름별 상태를 생성하고, 동일한 흐름에 속하는 패킷이 도착하지 않은 일정 시간이 지나면 상태를 삭제할 수 있습니다.

미들박스가 수행하는 특정 기능에 따라 이 동작은 미들박스 전체에서 성공할 UDP 트래픽 교환의 종류를 제한하는 시간 종속성을 도입할 수 있습니다. 예를 들어, NAT와 방화벽은 일반적으로 한쪽의 부분 경로를 자신이 서비스하는 도메인 내부로 정의하는 반면, 다른 쪽의 부분 경로는 해당 도메인 외부로 정의합니다. 흐름별 상태는 일반적으로 첫 번째 패킷이 내부에서 외부로 교차할 때 생성되며, 이 상태가 존재하는 동안 NAT 및 방화벽은 반환 트래픽을 전달합니다. 흐름별 상태가 시간 초과된 후 도착하는 반환 트래픽은 외부에서 도착하는 다른 트래픽과 마찬가지로 삭제됩니다.

통신에 UDP를 사용하는 많은 애플리케이션은 추가 메커니즘을 사용할 필요 없이 미들박스에서 작동합니다. 한 가지 예는 일반적으로 몇 초 내에 완료되는 엄격한 요청-응답 통신 패턴을 갖는 DNS\(Domain Name System\)입니다.

애플리케이션이 UDP 트래픽을 교환하지 않는 기간 동안 미들박스가 애플리케이션 세션과 연결된 흐름별 상태를 파괴하면 다른 애플리케이션에서 통신 오류가 발생할 수 있습니다. 애플리케이션은 이러한 통신 실패를 적절하게 처리하고 애플리케이션 계층 세션 및 상태를 재설정하는 메커니즘을 구현할 수 있어야 합니다.\(SHOULD\)

미디어 전송과 같은 일부 애플리케이션의 경우 이러한 재동기화는 사용자가 인식할 수 있는 재생 아티팩트를 유발할 수 있으므로 매우 바람직하지 않습니다. 이러한 특수 애플리케이션은 미들박스 상태를 새로 고치기 위해 주기적으로 연결 유지 메시지를 보낼 수 있습니다\(예: \[RFC7675\]\). 연결 유지 메시지는 일반적인 용도로 권장되지 않는다는 점을 기억하는 것이 중요합니다. 이는 많은 응용 프로그램에 필요하지 않으며 상당한 양의 시스템 및 네트워크 리소스를 소비할 수 있습니다.\(MAY\)

미들박스가 있는 경우 UDP를 통해 유용한 서비스를 전달하기 위해 연결 유지 메시지를 사용해야 하는 애플리케이션은 해당 메시지를 15초마다 한 번 이상 자주 전송해서는 안 되며 가능하면 더 긴 간격을 사용해야 합니다. 임의의 미들박스에 대한 흐름별 UDP 상태에 대해 공통 시간 초과가 지정되지 않았습니다. NAT에는 2분 이상의 상태 제한 시간이 필요합니다\[RFC4787\]. 그러나 경험적 증거에 따르면 현재 배포된 미들박스의 상당 부분이 불행하게도 더 짧은 시간 제한을 사용하고 있는 것으로 나타났습니다. 15초의 시간 제한은 ICE\(Interactive Connectivity Deployment\) 프로토콜 \[RFC5245\]에서 발생합니다. 애플리케이션이 통제된 환경에 배포될 때 배포자는 대상 환경이 애플리케이션이 더 긴 간격을 사용할 수 있도록 허용하는지 또는 포트 제어 프로토콜\(PCP\)을 사용하여 미들박스 상태 제한 시간을 명시적으로 제어하는 ​​메커니즘을 제공하는지 조사해야 합니다. RFC6887\], 미들박스 통신\(MIDCOM\) \[RFC3303\], NSIS\(Next Steps in Signaling\) \[RFC5973\] 또는 UPnP\(Universal Plug and Play\) \[UPnP\]. 서로 다른 호스트의 연결 유지 전송 간의 지속적인 동기화 가능성을 줄이기 위해 응용 프로그램이 연결 유지 전송 타이밍에 약간의 무작위 변화\("지터"\)를 적용하는 것이 좋습니다\[RFC7675\].\(SHOULD NOT, SHOULD, SHOULD\)

연결 유지 메시지를 보내는 것은 끊어진 세션을 복구하는 메커니즘을 구현하는 것을 대체할 수 없습니다. 모든 UDP 데이터그램과 마찬가지로 연결 유지 메시지가 지연되거나 삭제되어 미들박스 상태가 시간 초과될 수 있습니다. 또한 섹션 3.1의 혼잡 제어 지침은 미들박스 연결 유지 메시지의 전송을 포함하여 애플리케이션에 의한 모든 UDP 전송을 다룹니다. 따라서 혼잡 제어로 인해 연결 유지 전송이 지연되거나 일시적으로 중단될 수 있습니다.

연결 유지 메시지는 일반적인 용도로 권장되지 않습니다. 이는 많은 애플리케이션에 필요하지 않으며 상당한 리소스를 소비할 수 있습니다. 예를 들어, 배터리 구동 장치에서 애플리케이션이 트래픽이 거의 없이 장기간 연결을 유지해야 하는 경우 연결 유지 메시지가 전송되는 빈도는 기본 네트워크 기술에 따라 전력 소비를 결정하는 결정 요인이 될 수 있습니다.\(SHOULD NOT\)

많은 미들박스는 UDP에 필요한 것보다 훨씬 낮은 빈도로 TCP 연결에 대해 연결 유지 메시지를 요구하도록 설계되었기 때문에 이러한 배포에서는 UDP보다 TCP를 선호하는 데 이러한 차이만으로도 충분할 수 있습니다. 반면, ICE \[RFC5245\]를 사용하는 등 미들박스를 통한 직접 통신이 UDP보다 TCP에서 덜 성공한다는 일화적인 증거가 있습니다. 특히 미들박스 순회와 관련하여 다양한 전송 프로토콜 간의 장단점은 신중하게 분석할 가치가 있습니다.

인터넷에 배포할 수 있는 UDP 애플리케이션은 미들박스 동작에 다양한 변형이 있다는 점과 UDP가 연결이 없지만 미들박스는 종종 각 UDP 흐름에 대한 상태를 유지한다는 점을 이해하여 설계해야 합니다. 여러 UDP 흐름을 사용하면 사용 가능한 상태 공간이 소모될 수 있으며 미들박스가 후속 패킷을 처리하는 방식이 변경될 수도 있습니다\(내부 리소스를 보호하거나 오용 감지를 방지하기 위해\). 애플리케이션이 여러 UDP 흐름을 병렬로 사용하는 경우 경로 실패 확률이 높아질 수 있습니다\(다중 포트 사용에 대한 권장 사항은 섹션 5.1.2 참조\).

---
### **3.6.  Limited Applicability and Controlled Environments**

UDP를 활용하는 IETF 애플리케이션 사양에 대해 두 가지 다른 유형의 적용 가능성이 확인되었습니다.

일반인터넷. 기본적으로 IETF 사양은 일반 인터넷 배포를 목표로 합니다. 경험에 따르면 하나의 특정 상황이나 특정 응용 프로그램을 위해 개발된 성공적인 프로토콜은 더 넓은 범위의 상황에서 사용되는 경향이 있습니다. 예를 들어, 로컬 영역 내에서 초기 배포되는 프로토콜

- 네트워크는 인터넷을 통과하는 가상 네트워크를 통해 또는 일반적으로 인터넷에서 사용될 수 있습니다. 일반적인 인터넷 사용을 위해 설계된 응용 프로그램은 다양한 네트워크 장치 동작을 경험할 수 있으며, 특히 응용 프로그램이 미들박스를 포함할 수 있는 경로를 통해 작동해야 하는지 여부를 고려해야 합니다.

통제된 환경. 프로토콜/캡슐화/터널은 통제된 환경 내에서만 사용되도록 설계할 수 있습니다. 예를 들어, 네트워크 운영자가 사용하도록 설계된 애플리케이션은 해당 단일 네트워크 운영자의 네트워크 내에서만 배포되거나 인접한 협력 네트워크 운영자 집합의 네트워크에만 배포될 수 있습니다. 그런 다음 일반 인터넷을 통해 작동할 때 필요한 내장 메커니즘에 의존하기보다는 정체를 방지하기 위해 애플리케이션 트래픽을 관리할 수 있습니다. 제한된 적용 가능성 사용 사례를 대상으로 하는 애플리케이션은 특정 하드웨어\(예: 캐리어 등급 장비\) 또는 해당 애플리케이션이 사용되는 하위 네트워크의 기본 프로토콜 기능을 활용할 수 있습니다.

제한된 적용 가능성 사용 사례 또는 통제된 환경을 다루는 사양은 제한된 배포에서 일반 인터넷을 통해 작동하도록 설계된 프로토콜과 동일한 안전 수준이 어떻게 제공되는지 식별해야 합니다\(예: 광범위한 경험을 기반으로 한 설계\). 일반 인터넷 장비에서 기대할 수 없는 기능을 제공하는 특정 방법의 배포와 헤더 손상에 대한 MPLS 설계의 견고성은 둘 다 대체 UDP 무결성 검사 \[RFC7510\]의 사용을 정당화하는 데 도움이 되었습니다.\(SHOULD\)

통제된 환경을 대상으로 하는 IETF 사양은 애플리케이션 트래픽을 통제된 환경으로 제한하는 적용 가능성 설명을 제공할 것으로 예상되며, 손상된 패킷이 환경에서 빠져나가는 것을 막거나 방해하는 방법을 설명할 것으로 예상됩니다\(예: , \[RFC7510\]의 섹션 5\).

---
## **4.  Multicast UDP Usage Guidelines**

이 섹션은 UDP의 멀티캐스트 및 브로드캐스트 사용에 적용할 수 있는 추가 지침을 제공하여 섹션 3을 보완합니다.

멀티캐스트 및 브로드캐스트 전송 \[RFC1112\]은 일반적으로 UDP 전송 프로토콜을 사용하지만 다른 전송 프로토콜\(예: UDP-Lite\)과 함께 사용될 수도 있습니다.

현재 멀티캐스트 전달에는 두 가지 모델, 즉 \[RFC1112\]에 정의된 ASM\(Any-Source Multicast\) 모델과 \[RFC4607\]에 정의된 SSM\(Source-Specific Multicast\) 모델이 있습니다. ASM 그룹 구성원은 모든 소스에서 그룹으로 전송된 모든 데이터를 수신하는 반면, SSM은 배포 트리를 하나의 단일 소스로만 제한합니다.

특수 클래스의 애플리케이션도 IP 멀티캐스트 또는 브로드캐스트 \[RFC919\]에 UDP를 사용합니다. 이러한 특수 애플리케이션을 설계하려면 단순한 유니캐스트 특정 지침을 넘어서는 전문 지식이 필요합니다. 이러한 발신자는 잠재적으로 매우 이질적인 경로를 통해 잠재적으로 매우 많은 수신자에게 동시에 전송할 수 있으므로 혼잡 제어, 흐름 제어 및 신뢰성 메커니즘이 상당히 복잡해지기 때문입니다. .

이 섹션에서는 멀티캐스트 및 브로드캐스트 UDP 사용에 대한 지침을 제공합니다. 애플리케이션의 브로드캐스트 사용은 일반적으로 라우터에 의해 로컬 하위 네트워크로 제한됩니다. 그러나 터널링 기술과 프록시를 사용하면 일부 브로드캐스트 트래픽이 인터넷 경로를 통과할 수 있으며 실제로 발생합니다. 따라서 이러한 지침은 방송 트래픽에도 적용됩니다.

IETF는 \[RFC3738\] 또는 \[RFC4654\]와 같은 멀티캐스트 애플리케이션 설계자를 돕기 위해 신뢰할 수 있는 멀티캐스트 프레임워크 \[RFC3048\]와 여러 빌딩 블록을 정의했습니다.

애니캐스트 대상으로 보내는 발신자는 동일한 애니캐스트 IP 주소로 전송된 연속 메시지가 다른 애니캐스트 노드로 전달될 수 있다는 점, 즉 토폴로지의 다른 위치에 도착할 수 있다는 점을 알아야 합니다.

IP 멀티캐스트 트래픽을 전달하는 대부분의 UDP 터널은 자동 멀티캐스트 터널링\[RFC7450\]과 같은 유니캐스트 대상 주소가 있는 터널 캡슐화를 사용합니다. 이는 유니캐스트 데이터를 전달하는 터널과 동일한 요구 사항을 따라야 합니다\(섹션 3.1.11 참조\). UDP 터널의 외부 헤더에 \[RFC6513\]과 같은 멀티캐스트 대상 주소가 포함된 배포 사례와 솔루션이 있습니다. 이러한 사례는 주로 예약된 용량을 통해 제어된 환경에 배포되며 종종 단일 관리 도메인 내에서 작동하거나 예약된 용량을 사용하여 양측이 합의한 경로를 통해 두 도메인 간에 작동하므로 혼잡 제어는 선택 사항이지만 회로 차단기 기술은 여전히 ​​권장됩니다. 제공된 로드가 예약된 용량을 초과하는 경우\(예: 구성 오류로 인해\) 어느 정도 서비스를 복원합니다.\(MUST, SHOULD\)

---
### **4.1.  Multicast Congestion Control Guidelines**

유니캐스트 혼잡 제어 전송 메커니즘은 양방향 통신이 필요하고 단일 수신기에 대한 네트워크 조건을 수용하도록 전송 속도를 조정하기 때문에 멀티캐스트 배포 서비스에 적용할 수 없거나 대규모 멀티캐스트 트리로 확장되지 않는 경우가 많습니다. 대조적으로, 멀티캐스트 분배 트리는 엄청난 수의 수신기로 확산될 수 있으며, 이로 인해 전송 속도를 제어하기 위한 대역 내 반환 채널의 확장성이 제한되고 멀티캐스트 분배 트리의 일대다 특성으로 인해 속도를 개별 수신기의 요구 사항. 이러한 이유로 기본이든 터널링이든 인터넷 멀티캐스트 데이터에 대한 TCP 호환 집계 흐름 속도를 생성하는 것은 혼잡 제어를 구현하는 응용 프로그램의 책임입니다.

멀티캐스트를 사용하는 애플리케이션은 적절한 혼잡 제어를 제공해야 합니다\(SHOULD\). 멀티캐스트 혼잡 제어는 멀티캐스트 배포 트리와 그룹에 속하는 수신기 모두의 잠재적인 이질성에 대해 견고한 메커니즘을 사용하여 설계되어야 합니다. 이질성은 일부 수신기에서 다른 수신기보다 더 많은 손실, 더 높은 지연 및/또는 네트워크 상태에 대한 응답 능력 저하를 경험하는 경우 나타날 수 있습니다. 혼잡 제어는 멀티캐스트 배포 트리의 전체 또는 일부가 액세스 네트워크\(예: 홈 게이트웨이\)에 걸쳐 있는 모든 멀티캐스트 세션에 특히 중요합니다. RFC 시리즈에는 두 가지 스타일의 혼잡 제어가 정의되어 있습니다.\(SHOULD\)

o 피드백 기반 혼잡 제어. 송신자가 수신자로부터 멀티캐스트 또는 유니캐스트 UDP 메시지를 수신하여 혼잡 수준을 평가한 다음 송신자 속도를 조정할 수 있습니다\(예: \[RFC5740\],\[RFC4654\]\). 멀티캐스트 방법은 유니캐스트보다 더 긴 시간 규모에서 작동할 수 있습니다\(예: 이종 그룹의 그룹 RTT가 더 높기 때문에\). 제어 방법은 단일 수신자로부터 수신된 제어 메시지에 대한 응답으로 전체 멀티캐스트 그룹의 속도를 줄이지 않기로 결정할 수 있습니다\(예: 송신자는 최소 속도를 설정하고 혼잡한 수신자에게 멀티캐스트 그룹을 떠나도록 요청하기로 결정하고 또한 유니캐스트 혼잡 제어를 사용하여 이러한 혼잡한 수신기에 더 낮은 속도로 콘텐츠를 배포하기로 결정합니다.

o 수신기가 혼잡 제어를 위해 명시적인 UDP 제어 메시지를 보내도록 요구하지 않는 수신기 중심 혼잡 제어\(예: \[RFC3738\], \[RFC5775\]\). 대신, 발신자는 여러 IP 멀티캐스트 그룹\(예: {S,G} 채널 집합 사용\)에 데이터를 배포합니다. 각 수신기는 자체 정체 수준을 결정하고 네트워크 제어 평면에서 전송된 멀티캐스트 가입/탈퇴 메시지만을 사용하여 수신 속도를 제어합니다. 이 방법은 임의의 대규모 수신자 그룹으로 확장됩니다.

멀티캐스트 지원 수신기는 모든 그룹에 참여하여 트래픽을 수신하려고 시도할 수 있습니다. 이는 개별 수신기 또는 전체 멀티캐스트 서비스에 대한 속도 제한이 필요함을 의미할 수 있습니다. 전송 계층에서는 조인 메시지가 다음 홉 라우터로 전파되는 것을 방지할 수 있는 방법이 없습니다.

멀티캐스트 응용 프로그램의 일부 클래스는 수신자에서의 사용자 수준 전송 품질을 모니터링할 수 있는 응용 프로그램을 지원합니다. 사용자 품질의 상당한 감소를 감지할 수 있는 애플리케이션은 이를 혼잡 신호로 간주해야 합니다\(예: 계층형 멀티캐스트 인코딩을 사용하여 그룹 탈퇴\). 그렇지 않은 경우 이 신호를 사용하여 멀티캐스트 그룹을 떠나 흐름을 종료하는 회로 차단기를 제공해야 합니다.\(SHOULD\)

---
#### **4.1.1.  Bulk-Transfer Multicast Applications**

멀티캐스트 배포 트리를 통해 데이터의 대량 전송을 수행하는 애플리케이션, 즉 RTT당 몇 개 이상의 UDP 데이터그램을 교환하는 애플리케이션은 혼잡 제어 방법을 구현해야 합니다\(SHOULD\). 현재 권장되는 IETF 방법은 다음과 같습니다: ALC\(Asynchronous Layered Coding\) \[RFC5775\], TFMCC\(TCP-Friendly Multicast Congestion Control\) \[RFC4654\], WEBRC\(Wave and Equation Based Rate Control\) \[RFC3738\], NACK-Oriented Reliable Multicast \(NORM\) 전송 프로토콜 \[RFC5740\], FLUTE\(단방향 전송을 통한 파일 전달\) \[RFC6726\], RTP/RTCP\(실시간 프로토콜/제어 프로토콜\) \[RFC3550\].\(SHOULD, SHOULD\)

애플리케이션은 \[RFC2887\]의 지침을 따르고 \[RFC3048\]의 프레임워크를 활용하여 다른 혼잡 제어 방식을 대안으로 구현할 수 있습니다. \[RFC4654\], \[RFC5775\], \[RFC3738\], \[RFC5740\], \[RFC6726\] 또는 \[RFC3550\]을 구현하지 않기로 선택한 대량 전송 애플리케이션은 내부에서 TCP와 공정하게 경쟁하는 대역폭 사용을 초래하는 혼잡 제어 체계를 구현해야 합니다. 규모의 순서.\(SHOULD\)

\[RFC3551\]의 섹션 2에는 멀티미디어 애플리케이션이 패킷 손실률을 모니터링하여 허용 가능한 매개변수 내에 있는지 확인해야 한다고 명시되어 있습니다. 동일한 네트워크 조건에서 동일한 네트워크 경로를 통과하는 TCP 흐름이 합리적인 시간 단위로 측정된 평균 처리량을 달성하는 경우 패킷 손실은 허용 가능한 것으로 간주됩니다. 이는 UDP 흐름의 처리량보다 작지 않습니다. TCP와의 비교는 정확하게 지정할 수 없지만 시간 척도와 처리량 측면에서 "크기순" 비교를 위한 것입니다.\(SHOULD\)

---
#### **4.1.2.  Low Data-Volume Multicast Applications**

섹션 3.1.3의 모든 권장 사항은 데이터 용량이 적은 멀티캐스트 애플리케이션에도 적용됩니다.

---
### **4.2.  Message Size Guidelines for Multicast**

멀티캐스트 애플리케이션은 \[RFC6807\]의 섹션 3에 설명된 대로 유효 MTU를 초과하는 IP 패킷을 생성하는 UDP 데이터그램을 전송해서는 안 됩니다. 결과적으로 애플리케이션은 "PIM\(Population Count Extensions to Protocol Independent Multicast\)"\[RFC6807\]에서 제공하는 효과적인 MTU 정보를 사용하거나 경로 MTU 검색 자체를 구현해야 합니다\(섹션 3.2 참조\). 각 대상에 대한 경로가 지원할지 여부를 결정해야 합니다. 조각화 없이 원하는 메시지 크기입니다.\(SHOULD NOT, SHOULD\)

---
## **5.  Programming Guidelines**

TCP/IP 애플리케이션을 위한 사실상 표준 애플리케이션 프로그래밍 인터페이스\(API\)는 "소켓" 인터페이스 \[POSIX\]입니다. 일부 플랫폼은 또한 "원시 소켓" 또는 유사한 시설을 통해 IP 패킷을 직접 조립하고 전송할 수 있는 기능을 애플리케이션에 제공합니다. 이는 UDP를 사용하는 두 번째로 더 번거로운 방법입니다. 이 문서의 지침은 애플리케이션이 UDP를 사용할 수 있는 모든 방법을 다룹니다. 소켓 API는 가장 일반적인 방법이므로 이 섹션의 나머지 부분에서는 이에 대해 더 자세히 설명합니다.

소켓 API는 1980년대 초에 UNIX용으로 개발되었지만 UNIX가 아닌 다양한 운영 체제에서도 이를 구현합니다. 소켓 API는 IPv4와 IPv6 \[RFC3493\]을 모두 지원합니다. UDP 소켓 API는 몇 가지 주요 측면에서 TCP의 API와 다릅니다. 애플리케이션 프로그래머는 일반적으로 TCP 소켓 API에 더 익숙하기 때문에 이 섹션에서는 이러한 차이점을 설명합니다. \[STEVENS\]는 UDP 소켓 API의 사용 예를 제공합니다.

UDP 데이터그램은 연결 설정 없이 직접 보내고 받을 수 있습니다. 소켓 API를 사용하면 애플리케이션은 단일 UDP 소켓에 있는 둘 이상의 IP 소스 주소로부터 패킷을 수신할 수 있습니다. 일부 서버는 이를 사용하여 동시에 단일 UDP 소켓을 통해 둘 이상의 원격 호스트와 데이터를 교환합니다. 많은 애플리케이션은 특정 소스 주소로부터 패킷을 수신하는지 확인해야 합니다. 이러한 애플리케이션은 애플리케이션 계층에서 해당 검사를 구현하거나 운영 체제가 수신된 패킷을 필터링하도록 명시적으로 요청해야 합니다.\(MUST\)

많은 운영 체제에서는 UDP 소켓 연결, 즉 UDP 소켓을 특정 주소 및 포트 쌍에 바인딩하는 것도 허용합니다. 이는 해당 TCP 소켓 API 기능과 유사합니다. 그러나 UDP의 경우 이는 로컬 보내기/받기 기능을 단순화하고 지정된 주소 및 포트에 대한 트래픽을 필터링하는 역할을 하는 로컬 작업일 뿐입니다. UDP 소켓을 바인딩해도 연결이 설정되지 않습니다. UDP는 연결이 설정될 때 원격 측에 알리지 않습니다.

로컬 UDP 소켓이 바인딩되었습니다. 소켓을 바인딩하면 UDP 체크섬 또는 IP 타임스탬프 옵션 사용과 같이 UDP 또는 IP 계층에 영향을 미치는 옵션을 구성할 수도 있습니다. 일부 스택에서는 바운드 소켓을 사용하여 전송에 대한 ICMP 오류 메시지가 수신될 때 애플리케이션이 알림을 받을 수도 있습니다\[RFC1122\].

클라이언트/서버 애플리케이션이 둘 이상의 IP 인터페이스가 있는 호스트에서 실행되는 경우 애플리케이션은 요청을 전달한 UDP 데이터그램의 IP 대상 주소와 일치하는 IP 소스 주소로 모든 UDP 응답을 보내야 합니다\(\[RFC1122\], 섹션 참조\). 4.1.3.5\). 많은 미들박스는 섹션 3.5에 설명된 대로 이러한 전송 동작과 다른 IP 주소에서 전송된 응답 삭제를 예상합니다.\(SHOULD\)

UDP 수신자는 길이가 0인 페이로드가 있는 유효한 UDP 데이터그램을 수신할 수 있습니다. 이는 TCP의 경우 연결 종료를 나타내는 read\(\) 소켓 호출의 반환 값 0과 다릅니다.

UDP는 흐름 제어를 제공하지 않습니다. 즉, 특정 시간에 발신자는 수신자가 들어오는 전송을 처리할 수 있는지 여부를 알 수 없습니다. 이는 UDP 기반 애플리케이션이 패킷 손실이 있는 경우에도 견고해야 하는 또 다른 이유입니다. 이러한 손실은 애플리케이션이 아웃바운드 네트워크 인터페이스의 회선 속도보다 빠르게 데이터를 전송할 때 전송 호스트 내에서도 발생할 수 있습니다. 이는 수신 호출이 애플리케이션이 너무 자주 호출할 때\(예: 수신 버퍼 오버플로\) 전송된 모든 데이터를 반환하지 못하는 대상에서도 발생할 수 있습니다. 강력한 흐름 제어 메커니즘은 구현하기 어렵기 때문에 이 기능이 필요한 애플리케이션은 TCP와 같은 모든 기능을 갖춘 전송 프로토콜 사용을 고려해야 합니다.\(SHOULD\)

애플리케이션이 TCP, SCTP 또는 DCCP 소켓을 닫을 때 수신 호스트의 전송 프로토콜은 TIME-WAIT 상태를 유지해야 합니다. 이렇게 하면 닫힌 연결 인스턴스의 지연된 패킷이 동일한 IP 주소 및 포트 쌍을 재사용하는 이후 연결 인스턴스와 실수로 연결되는 것을 방지할 수 있습니다. UDP 프로토콜은 이러한 메커니즘을 구현하지 않습니다. 따라서 UDP 기반 애플리케이션은 재정렬 및 ​​지연에 강력해야 합니다. 한 애플리케이션이 소켓을 닫거나 종료할 수 있으며, 시간이 지나면 다른 애플리케이션이 동일한 포트에서 수신할 수 있습니다. 그러면 이 나중 애플리케이션은 네트워크에서 지연된 첫 번째 애플리케이션용 패킷을 수신할 수 있습니다.

---
### **5.1.  Using UDP Ports**

"서비스 이름 및 전송 프로토콜 포트 번호 레지스트리" 관리에 대한 규칙 및 절차는 \[RFC6335\]에 명시되어 있습니다. UDP 포트 사용에 대한 권장 사항은 \[RFC7605\]에 제공됩니다.

UDP 발신자는 소스 포트 값 0을 사용해서는 안 됩니다. 주소나 페이로드 유형에서 쉽게 확인할 수 없는 소스 포트 번호는 경로를 벗어난 장치에 의한 데이터 주입 공격으로부터 수신기를 보호합니다. UDP 수신기는 포트 0에 바인딩되어서는 안 됩니다.\(SHOULD NOT, SHOULD NOT\)

애플리케이션은 애플리케이션 계층에서 수신자 포트 및 주소 확인을 구현하거나 운영 체제가 수신된 패킷을 필터링하여 임의의 포트로 패킷 수신을 방지하도록 명시적으로 요청해야 합니다\(SHOULD\). 이 조치는 경로를 벗어난 소스\(포트 값을 알 수 없는 곳\)로부터의 데이터 주입 공격으로부터 추가 보호를 제공하도록 설계되었습니다.\(SHOULD\)

애플리케이션은 승인되지 않은 제3자가 생성한 패킷을 애플리케이션이 수신하지 못하도록 방지하여 경로를 벗어난 데이터 주입을 방지하는 검사를 제공해야 합니다. TCP 스택은 일반적으로 이러한 보호 기능을 제공하기 위해 무작위 소스 포트를 사용합니다\[RFC6056\]. UDP 애플리케이션은 동일한 기술을 따라야 합니다. 미들박스와 최종 시스템은 종종 시스템 포트나 사용자 포트에 대해 가정합니다. 따라서 동적 및/또는 개인 포트 범위에서 무작위 포트를 사용하는 것이 좋습니다. 또한 "무작위" 소스 포트를 설정하면 보고된 ICMP 오류가 특정 흐름에서 사용되는 경로의 네트워크 시스템에서 발생한다는 것을 더 확실하게 확인할 수 있습니다. 일부 UDP 응용 프로그램은 소스 포트에 미리 결정된 값을 사용하도록 선택합니다\(일부 멀티캐스트 응용 프로그램 포함\). 따라서 이러한 응용 프로그램은 다른 기술을 사용해야 합니다. 데이터그램 페이로드 내의 다른 프로토콜 필드의 초기 값을 무작위로 지정하고 수신기에서 이 필드의 유효성을 확인함으로써 경로를 벗어난 데이터 공격으로부터 보호할 수도 있습니다\(예: RTP는 무작위 초기 시퀀스 번호와 무작위 미디어 타임스탬프 오프셋을 가집니다. RFC3550\]\).\(SHOULD\)

멀티캐스트를 사용할 때 IP 라우터는 각 멀티캐스트 패킷에 대해 역방향 경로 전달\(RPF\) 검사를 수행합니다. 이는 경로를 벗어난 데이터 삽입을 방지하여 패킷의 소스 주소를 위조할 기회를 제한합니다. 수신자가 멀티캐스트 그룹에 가입하고 소스 주소를 기반으로 필터링하면 필터는 발신자의 IP 주소를 확인합니다. 이는 SSM {S,G} 채널을 사용할 때 항상 그렇습니다.

---
#### **5.1.1.  Usage of UDP for Source Port Entropy and the IPv6 Flow Label**

일부 애플리케이션은 ECMP \[RFC6438\]를 구현하는 네트워크 장치의 엔트로피 소스로 UDP 데이터그램 헤더를 사용합니다. 이 용도를 목표로 하는 UDP 터널 애플리케이션은 UDP를 사용하여 내부 패킷을 캡슐화합니다. 여기서 UDP 소스 포트 값은 ECMP를 사용하는 장치의 네트워크 트래픽 전달 균형을 맞추는 데 사용할 수 있는 엔트로피의 일부를 형성합니다. 송신 터널 끝점은 내부 흐름 정보\(예: 캡슐화된 패킷 헤더\)로부터 계산된 UDP 데이터그램 헤더에서 소스 포트 값을 선택합니다. 충분한 엔트로피를 제공하기 위해 송신 터널 끝점은 캡슐화된 트래픽을 UDP 소스 값 범위 중 하나에 매핑합니다. 값은 임시 포트 범위\(예: 49152\~65535\) 내에 있어야 하며, 여기서 포트의 상위 2비트는 1로 설정됩니다. 14비트\(임시 포트 범위 사용\)의 사용 가능한 소스 포트 엔트로피와 외부 IP 주소는 대부분의 ECMP 애플리케이션\[ENCAP\]에 대한 엔트로피에 충분한 것으로 보입니다.\(SHOULD\)

IP 흐름 내에서 재정렬을 방지하려면 캡슐화된 흐름에 할당된 모든 패킷에 동일한 UDP 소스 포트 값을 사용해야 합니다\(예: 관련 헤더의 해시 사용\). 흐름에 대한 엔트로피 매핑은 캡슐화된 흐름\[ENCAP\]의 수명 동안 변경될 수 있습니다. 예를 들어, 이는 DOS\(서비스 거부\) 완화 또는 ECMP 네트워크를 통한 라우팅에 영향을 미치는 수단으로 변경될 수 있습니다. 그러나 흐름에 대해 선택된 소스 포트는 30초마다 한 번 이상 변경되어서는 안 됩니다\(예: \[RFC8086\]에서와 같이\).\(SHOULD, MAY, SHOULD NOT\)

엔트로피에 소스 포트 필드를 사용하면 다음을 포함하여 고려해야 할 몇 가지 부작용이 있습니다.

o 손상된 패킷이 잘못 전달될 확률이 높아질 수 있으며, 이로 인해 체크섬 계산이나 잘못된 전달 오류로부터 다른 UDP 애플리케이션을 보호하기 위한 동등한 메커니즘의 필요성이 높아집니다. 섹션 3.4.

o 성공적인 미들박스 순회 확률이 감소할 것으로 예상됩니다. 섹션 3.5. 이러한 소스 포트 필드 사용은 일반 인터넷 배포를 목표로 하는 애플리케이션에는 적합하지 않은 경우가 많습니다.

o 경로를 벗어난 공격으로부터 보호하기 위해 필드를 사용할 수 없도록 방지할 수 있습니다\(섹션 5.1에 설명되어 있음\). 따라서 설계자는 동등한 보호를 제공하기 위해 다른 메커니즘을 고려해야 합니다\(예: 통제된 환경으로 사용을 제한 \[RFC7510\] 섹션 3.6\).

UDP 소스 포트 번호 필드도 IPv6에서 엔트로피를 생성하는 데 활용되었습니다. 그러나 IPv6의 경우 "흐름 레이블"\[RFC6437\]을 대신 사용하여 로드 밸런싱\[RFC6438\]을 위한 엔트로피를 제공할 수도 있습니다. 로드 밸런싱을 위한 흐름 레이블의 이러한 사용은 필드 정의와 일치하지만, 필드가 이 목적을 위해 일관되게 사용될 수 있도록 하기 위해서는 더 명확성이 필요했습니다. 따라서 업데이트된 IPv6 흐름 레이블\[RFC6437\] 및 ECMP 라우팅\[RFC6438\] 사용법이 지정되었습니다.

향후 흐름 레이블을 사용할 수 있는 기회를 보장하려면 UDP 애플리케이션은 소스 포트 필드에 엔트로피 값이 설정된 경우에도 흐름 레이블 필드를 설정해야 합니다\(예: IPv6 터널 끝점은 소스 포트 흐름 엔트로피 값을 IPv6에 복사할 수 있음\). 흐름 레이블 필드 \[RFC8086\]\). 라우터 공급업체는 IPv6 흐름 레이블을 흐름 해시의 일부로 사용하여 UDP를 사용하지 않고도 IP 수준 ECMP를 지원할 것을 권장합니다. 로드 밸런싱을 위한 흐름 레이블의 엔드투엔드 사용은 장기적인 솔루션입니다. 흐름 레이블의 사용이 명확해지더라도 상당수의 엔드포인트가 시작된 흐름에 좋은 품질의 흐름 레이블을 할당하기 시작하기 전에 전환 시간이 있을 것입니다. 전송 헤더 필드를 사용한 로드 밸런싱의 사용은 최종적으로 광범위한 배포가 이루어질 때까지 계속될 것입니다.\(SHOULD\)

---
#### **5.1.2.  Applications Using Multiple UDP Ports**

단일 애플리케이션은 여러 유형의 데이터를 교환할 수 있습니다. 경우에 따라 여러 UDP 흐름\(예: 서로 다른 5개 튜플로 식별되는 여러 흐름 집합\)이 필요할 수 있습니다. \[RFC6335\]는 애플리케이션 개발자가 IANA에 잘 알려진 여러 포트\(사용자 또는 시스템\)를 할당하도록 신청하지 않을 것을 권장합니다. 동일한 잘 알려진 포트 또는 동적 포트 쌍\(예: 서비스 이름 또는 신호 프로토콜로 식별\)이 있는 여러 흐름을 사용하는 경우의 의미는 논의하지 않습니다.

여러 흐름을 사용하면 여러 가지 방식으로 네트워크에 영향을 미칠 수 있습니다.

o 일련의 연속 연결을 시작하면 네트워크 경로를 따라 미들박스\(예: NAPT 또는 방화벽\)의 상태 바인딩 수가 늘어날 수 있습니다. UDP 기반 미들박스 순회는 일반적으로 시간 초과를 사용하여 이전 상태를 제거합니다. 미들박스는 애플리케이션에서 특정 흐름의 사용이 중단되는 시점을 인식하지 못하기 때문입니다.

o 동시에 여러 흐름을 사용하면

- 각 흐름마다 다른 네트워크 특성. 둘 다 동일한 경로를 따른다고 가정할 수는 없습니다\(예: ECMP를 사용하는 경우 트래픽은 포트 번호를 기반으로 의도적으로 다른 병렬 경로로 해시됩니다\).

o 여러 흐름을 사용하면 미들박스\(예: NAPT 또는 방화벽\)에서 바인딩 또는 조회 테이블의 점유율이 증가할 수 있으며, 이로 인해 장치가 흐름 상태를 관리하는 방식이 변경될 수 있습니다.

o 또한 과도한 수의 흐름을 사용하면 혼잡 상태가 세션의 모든 흐름 간에 공유되지 않는 한 혼잡 이벤트에 반응하는 유니캐스트 혼잡 제어 기능이 저하될 수 있습니다. 수신기 중심의 멀티캐스트 혼잡 제어에서는 송신 응용 프로그램이 IP 멀티캐스트 그룹 집합을 통해 데이터를 배포해야 하므로 각 수신기는 동시에 활성화된 적당한 수의 UDP 포트에서 데이터를 수신해야 합니다.

따라서 애플리케이션은 여러 UDP 흐름이 사용될 때 미들박스의 일관된 동작을 가정해서는 안 됩니다. 사용되는 포트 수가 증가함에 따라 많은 장치가 다르게 반응합니다. 서로 다른 QoS 요구 사항이 있는 여러 흐름을 사용하려면 애플리케이션에서 각 개별 흐름\(5튜플\)을 사용하여 예상 성능이 달성되는지 확인해야 합니다. 섹션 3.1.9를 참조하세요.\(MUST NOT\)

---
### **5.2.  ICMP Guidelines**

애플리케이션은 UDP 계층이 다양한 목적으로 전달하는 ICMP 오류 메시지에 대한 정보를 활용할 수 있습니다\[RFC1122\]. 애플리케이션은 전송된 트래픽\(즉, 애플리케이션이 실제로 보낸 UDP 데이터그램에 해당하는 보고된 오류 조건\)에 대한 응답으로 ICMP 메시지가 수신되었는지 확인하기 위해 ICMP 메시지의 페이로드를 적절하게 검증해야 합니다. 이를 위해서는 각 대상에 대한 통신 인스턴스에 대한 로컬 상태와 같은 컨텍스트가 필요하며 연결 ​​지향 전송 프로토콜에서는 쉽게 사용할 수 있지만 UDP 기반 애플리케이션에서는 항상 유지되지는 않습니다. 모든 플랫폼에 이 유효성 검사를 지원하는 데 필요한 API가 있는 것은 아니며 일부 플랫폼은 ICMP 정보를 애플리케이션에 전달하기 전에 이미 내부적으로 이 유효성 검사를 수행합니다.\(SHOULD\)

ICMP 오류 메시지에 대한 모든 애플리케이션 응답은 일시적인 라우팅 실패\(때때로 "소프트 오류"라고도 함\)에 강력해야 합니다. 예를 들어 일시적인 ICMP "도달할 수 없음" 메시지는 일반적으로 통신 중단을 유발해서는 안 됩니다.\(SHOULD\)

ICMP 메시지는 점점 더 미들박스에 의해 필터링되고 있습니다. 따라서 UDP 애플리케이션은 올바르고 안전한 작동을 위해 전달에 의존해서는 안 됩니다.\(SHOULD NOT\)

---
## **6.  Security Considerations**

UDP는 통신 보안을 제공하지 않습니다. 도청, 변조 또는 메시지 위조로부터 통신을 보호해야 하는 애플리케이션은 다른 IETF 프로토콜에서 제공하는 종단 간 보안 서비스를 사용해야 합니다.\(SHOULD\)

UDP 애플리케이션은 무작위 소스 포트 또는 이에 상응하는 기술을 사용하여 경로를 벗어난 데이터 주입 공격으로부터 보호해야 합니다\(섹션 5.1 참조\).\(SHOULD\)

잠재적으로 큰 응답으로 짧은 요청에 응답하는 애플리케이션은 증폭 공격의 잠재적 벡터이며 DoS 공격의 일부로 악용될 가능성을 최소화하기 위한 조치를 취해야 합니다. 이는 응답하기 전에 보낸 사람을 인증하는 것을 의미할 수 있습니다. 요청의 소스 IP 주소는 쉽게 스푸핑될 수 있으므로 유용한 인증자가 아니라는 점에 유의하세요. 또는 짧은 인증되지 않은 요청이 큰 응답을 생성하는 경우를 제한하는 것을 의미할 수도 있습니다. 또한 애플리케이션은 소비하는 대역폭을 제한하기 위해 시간 간격으로 응답하는 요청 수를 제한하는 방법을 제공할 수도 있습니다.\(SHOULD, MAY\)

UDP 통신 보안을 위한 한 가지 옵션은 AH\(인증 헤더\) \[RFC4302\]를 통한 IP 패킷 흐름에 대한 인증과 ESP\(보안 페이로드 캡슐화\) \[RFC4303\]를 통한 암호화 및/또는 인증을 제공할 수 있는 IPsec \[RFC4301\]을 사용하는 것입니다. 애플리케이션은 IKE\(인터넷 키 교환\) \[RFC7296\]을 사용하여 해당 세션에 대한 IPsec을 구성합니다. IPsec이 흐름에 대해 구성된 방식에 따라 UDP 헤더와 UDP 페이로드를 인증하거나 암호화할 수 있습니다. 애플리케이션에 인증만 필요한 경우 암호화는 없지만 인증은 포함하는 ESP가 AH보다 더 나은 옵션인 경우가 많습니다. ESP가 미들박스 전체에서 작동할 수 있기 때문입니다. IPsec을 사용하는 응용 프로그램에는 IPsec 프로토콜 제품군을 구현하는 운영 체제의 지원이 필요하며 네트워크 경로는 IKE 및 IPsec 트래픽을 허용해야 합니다. 이는 IPv6 배포 \[RFC6092\]에서 더욱 일반적이 될 수 있습니다.

IPsec을 사용하여 UDP 통신을 보호할 수 있지만 모든 운영 체제가 IPsec을 지원하거나 응용 프로그램이 해당 흐름에 맞게 IPsec을 쉽게 구성할 수 있도록 허용하는 것은 아닙니다. UDP 통신 보안을 위한 두 번째 옵션은 DTLS\(Datagram Transport Layer Security\) \[RFC6347\]\[RFC7525\]를 통한 것입니다. DTLS는 UDP 페이로드를 암호화하여 통신 프라이버시를 제공합니다. UDP 헤더는 보호하지 않습니다. 애플리케이션은 운영 체제의 지원에 의존하지 않고 DTLS를 구현할 수 있습니다.

UDP 페이로드를 인증하거나 암호화하기 위한 다른 많은 옵션이 있습니다. 예를 들어, GSS-API 보안 프레임워크\[RFC2743\] 또는 CMS\(암호화 메시지 구문\)\[RFC5652\]를 사용하여 UDP 페이로드를 보호할 수 있습니다. 특히 키 관리를 수행하기 위해 UDP를 통한 RTP \[RFC3550\]에 대한 여러 가지 보안 옵션이 있습니다. \[RFC7201\]을 참조하세요. 이러한 옵션은 지점 간, 중앙 집중식 그룹 통신 및 멀티캐스트를 포함한 다양한 용도를 포괄합니다. 일부 애플리케이션에서는 개별 UDP 페이로드 대신 파일이나 메시지와 같은 더 큰 독립 실행형 개체를 보호하는 것이 더 나은 솔루션입니다. 이러한 상황에서는 CMS \[RFC5652\], S/MIME \[RFC5751\] 또는 OpenPGP \[RFC4880\]를 사용할 수 있습니다. 또한 이 영역에는 IETF가 아닌 프로토콜이 많이 있습니다.

혼잡 제어 메커니즘과 마찬가지로 보안 메커니즘도 올바르게 설계하고 구현하기가 어렵습니다. 따라서 애플리케이션은 자체적인 보안 메커니즘을 개발하기보다는 DTLS 또는 IPsec과 같은 잘 알려진 표준 보안 메커니즘을 사용하는 것이 좋습니다.\(SHOULD\)

일반화된 TTL 보안 메커니즘\(GTSM\) \[RFC5082\]은 의도된 엔드포인트가 발신자와 동일한 링크에 있을 때 UDP 애플리케이션과 함께 사용될 수 있습니다. 이 경량 메커니즘을 통해 수신기는 원치 않는 패킷을 필터링할 수 있습니다.

혼잡 제어 측면에서 \[RFC2309\] 및 \[RFC2914\]에서는 인터넷으로의 혼잡 무응답 흐름의 위험성에 대해 논의합니다. \[RFC8084\]는 정체 제어가 없거나 정체 제어가 정체 이벤트에 반응하지 못하는 경우 정체 붕괴를 방지하는 데 도움이 될 수 있는 성능 한계를 설정하는 데 사용할 수 있는 방법을 설명합니다. 이 문서는 UDP 기반 애플리케이션 설계자에게 전송 정체 제어에 대한 지침을 제공하며 추가적인 보안 문제를 제기하지 않습니다.

일부 네트워크 운영자는 UDP의 기본 트래픽 속도보다 몇 배나 높은 UDP 공격 트래픽 급증을 경험했습니다. 이는 운영자가 UDP 트래픽의 데이터 속도 또는 패킷 속도를 제한하도록 동기를 부여할 수 있습니다. 이로 인해 애플리케이션이 UDP를 사용하여 달성할 수 있는 처리량이 제한될 수 있으며, 다른 전송 프로토콜을 사용했다면 경험할 수 없었던 UDP 트래픽에 대한 패킷 손실이 더 높아질 수도 있습니다.

발신자와 수신자 사이에 오래 지속되는 연결이 있는 UDP 애플리케이션은 수신자가 여전히 트래픽 수신을 원하는지\("동의"\) 여부를 발신자가 주기적으로 확인하고 명시적인 조치가 없는 경우 중지되도록 설계되어야 합니다. 이 \[RFC7675\]를 확인합니다. 프로토콜 기능을 구현하기 위해 양방향 통신이 필요한 애플리케이션\(예: 신뢰성 또는

혼잡 제어\)은 통신의 양방향을 독립적으로 확인해야 하며 미들박스를 통과하기 위해 연결 유지 메시지를 교환해야 할 수도 있습니다\(섹션 3.5 참조\).

---
## **7.  Summary**

이 섹션에서는 쉽게 참조할 수 있도록 섹션 3\~6의 주요 지침을 표 형식\(표 1\)으로 요약합니다.

```text
   +---------------------------------------------------------+---------+
   | Recommendation                                          | Section |
   +---------------------------------------------------------+---------+
   | MUST tolerate a wide range of Internet path conditions  | 3       |
   | SHOULD use a full-featured transport (e.g., TCP)        |         |
   |                                                         |         |
   | SHOULD control rate of transmission                     | 3.1     |
   | SHOULD perform congestion control over all traffic      |         |
   |                                                         |         |
   | for bulk transfers,                                     | 3.1.2   |
   | SHOULD consider implementing TFRC                       |         |
   | else, SHOULD in other ways use bandwidth similar to TCP |         |
   |                                                         |         |
   | for non-bulk transfers,                                 | 3.1.3   |
   | SHOULD measure RTT and transmit max. 1 datagram/RTT     | 3.1.1   |
   | else, SHOULD send at most 1 datagram every 3 seconds    |         |
   | SHOULD back-off retransmission timers following loss    |         |
   |                                                         |         |
   | SHOULD provide mechanisms to regulate the bursts of     | 3.1.6   |
   | transmission                                            |         |
   |                                                         |         |
   | MAY implement ECN; a specific set of application        | 3.1.7   |
   | mechanisms are REQUIRED if ECN is used.                 |         |
   |                                                         |         |
   | for DiffServ, SHOULD NOT rely on implementation of PHBs | 3.1.8   |
   |                                                         |         |
   | for QoS-enabled paths, MAY choose not to use CC         | 3.1.9   |
   |                                                         |         |
   | SHOULD NOT rely solely on QoS for their capacity        | 3.1.10  |
   | non-CC controlled flows SHOULD implement a transport    |         |
   | circuit breaker                                         |         |
   | MAY implement a circuit breaker for other applications  |         |
   |                                                         |         |
   | for tunnels carrying IP traffic,                        | 3.1.11  |
   | SHOULD NOT perform congestion control                   |         |
   | MUST correctly process the IP ECN field                 |         |
   |                                                         |         |

   | for non-IP tunnels or rate not determined by traffic,   |         |
   | SHOULD perform CC or use circuit breaker                | 3.1.11  |
   | SHOULD restrict types of traffic transported by the     |         |
   | tunnel                                                  |         |
   |                                                         |         |
   | SHOULD NOT send datagrams that exceed the PMTU, i.e.,   | 3.2     |
   | SHOULD discover PMTU or send datagrams < minimum PMTU;  |         |
   | Specific application mechanisms are REQUIRED if PLPMTUD |         |
   | is used.                                                |         |
   |                                                         |         |
   | SHOULD handle datagram loss, duplication, reordering    | 3.3     |
   | SHOULD be robust to delivery delays up to 2 minutes     |         |
   |                                                         |         |
   | SHOULD enable IPv4 UDP checksum                         | 3.4     |
   | SHOULD enable IPv6 UDP checksum; Specific application   | 3.4.1   |
   | mechanisms are REQUIRED if a zero IPv6 UDP checksum is  |         |
   | used.                                                   |         |
   |                                                         |         |
   | SHOULD provide protection from off-path attacks         | 5.1     |
   | else, MAY use UDP-Lite with suitable checksum coverage  | 3.4.2   |
   |                                                         |         |
   | SHOULD NOT always send middlebox keep-alive messages    | 3.5     |
   | MAY use keep-alives when needed (min. interval 15 sec)  |         |
   |                                                         |         |
   | Applications specified for use in limited use (or       | 3.6     |
   | controlled environments) SHOULD identify equivalent     |         |
   | mechanisms and describe their use case.                 |         |
   |                                                         |         |
   | Bulk-multicast apps SHOULD implement congestion control | 4.1.1   |
   |                                                         |         |
   | Low volume multicast apps SHOULD implement congestion   | 4.1.2   |
   | control                                                 |         |
   |                                                         |         |
   | Multicast apps SHOULD use a safe PMTU                   | 4.2     |
   |                                                         |         |
   | SHOULD avoid using multiple ports                       | 5.1.2   |
   | MUST check received IP source address                   |         |
   |                                                         |         |
   | SHOULD validate payload in ICMP messages                | 5.2     |
   |                                                         |         |
   | SHOULD use a randomized source port or equivalent       | 6       |
   | technique, and, for client/server applications, SHOULD  |         |
   | send responses from source address matching request     |         |
   | 5.1                                                     |         |
   | SHOULD use standard IETF security protocols when needed | 6       |
   +---------------------------------------------------------+---------+

                    Table 1: Summary of Recommendations
```

---
## **8.  References**
---
### **8.1.  Normative References**

```text
   [RFC768]   Postel, J., "User Datagram Protocol", STD 6, RFC 768,
              DOI 10.17487/RFC0768, August 1980,
              <http://www.rfc-editor.org/info/rfc768>.

   [RFC793]   Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <http://www.rfc-editor.org/info/rfc793>.

   [RFC1122]  Braden, R., Ed., "Requirements for Internet Hosts -
              Communication Layers", STD 3, RFC 1122,
              DOI 10.17487/RFC1122, October 1989,
              <http://www.rfc-editor.org/info/rfc1122>.

   [RFC1191]  Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,
              DOI 10.17487/RFC1191, November 1990,
              <http://www.rfc-editor.org/info/rfc1191>.

   [RFC1981]  McCann, J., Deering, S., and J. Mogul, "Path MTU Discovery
              for IP version 6", RFC 1981, DOI 10.17487/RFC1981, August
              1996, <http://www.rfc-editor.org/info/rfc1981>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, DOI 10.17487/RFC2460,
              December 1998, <http://www.rfc-editor.org/info/rfc2460>.

   [RFC2914]  Floyd, S., "Congestion Control Principles", BCP 41,
              RFC 2914, DOI 10.17487/RFC2914, September 2000,
              <http://www.rfc-editor.org/info/rfc2914>.

   [RFC3828]  Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., Ed.,
              and G. Fairhurst, Ed., "The Lightweight User Datagram
              Protocol (UDP-Lite)", RFC 3828, DOI 10.17487/RFC3828, July
              2004, <http://www.rfc-editor.org/info/rfc3828>.

   [RFC4787]  Audet, F., Ed. and C. Jennings, "Network Address
              Translation (NAT) Behavioral Requirements for Unicast
              UDP", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January
              2007, <http://www.rfc-editor.org/info/rfc4787>.

   [RFC4821]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, DOI 10.17487/RFC4821, March 2007,
              <http://www.rfc-editor.org/info/rfc4821>.

   [RFC5348]  Floyd, S., Handley, M., Padhye, J., and J. Widmer, "TCP
              Friendly Rate Control (TFRC): Protocol Specification",
              RFC 5348, DOI 10.17487/RFC5348, September 2008,
              <http://www.rfc-editor.org/info/rfc5348>.

   [RFC5405]  Eggert, L. and G. Fairhurst, "Unicast UDP Usage Guidelines
              for Application Designers", BCP 145, RFC 5405,
              DOI 10.17487/RFC5405, November 2008,
              <http://www.rfc-editor.org/info/rfc5405>.

   [RFC6040]  Briscoe, B., "Tunnelling of Explicit Congestion
              Notification", RFC 6040, DOI 10.17487/RFC6040, November
              2010, <http://www.rfc-editor.org/info/rfc6040>.

   [RFC6298]  Paxson, V., Allman, M., Chu, J., and M. Sargent,
              "Computing TCP's Retransmission Timer", RFC 6298,
              DOI 10.17487/RFC6298, June 2011,
              <http://www.rfc-editor.org/info/rfc6298>.

   [RFC8084]  Fairhurst, G., "Network Transport Circuit Breakers",
              BCP 208, RFC 8084, DOI 10.17487/RFC8084, March 2017,
              <http://www.rfc-editor.org/info/rfc8084>.
```

---
### **8.2.  Informative References**

\[ALLMAN\] Allman, M. 및 E. Blanton, "전송 프로토콜의 버스트 완화에 대한 참고 사항", 2005년 3월.

\[BEHAVE-앱\]

- Ford, B., "네트워크 주소 변환기를 통한 순회를 위한 애플리케이션 설계 지침", 진행 중,draft-ford-behave-app-05, 2007년 3월.

\[ENCAP\] Nordmark, E., Ed., Tian, ​​A., Gross, J., Hudson, J., Kreeger, L., Garg, P., Thaler, P. 및 T. Herbert, "캡슐화 고려 사항" , 진행 중인 작업, 초안-ietf-rtgwg-dt-encap-02, 2016년 10월.

\[FABER\] Faber, T., Touch, J. 및 W. Yue, "TCP의 TIME-WAIT 상태와 바쁜 서버에 미치는 영향", Proc. IEEE Infocom, 1999년 3월.

\[내부 터널\]

- Touch, J. 및 W. Townsley, "인터넷 아키텍처의 IP 터널", 진행 중인 작업, 초안-ietf-intarea-tunnels-03, 2016년 7월.

\[POSIX\] IEEE 표준. 1003.1-2001, "정보 기술 표준 - POSIX\(Portable Operating System Interface\)", 개방형 그룹 기술 표준: 기본 사양 발행물 6, ISO/IEC 9945:2002, 2001년 12월.

```text
   [RFC919]   Mogul, J., "Broadcasting Internet Datagrams", STD 5,
              RFC 919, DOI 10.17487/RFC0919, October 1984,
              <http://www.rfc-editor.org/info/rfc919>.

   [RFC1112]  Deering, S., "Host extensions for IP multicasting", STD 5,
              RFC 1112, DOI 10.17487/RFC1112, August 1989,
              <http://www.rfc-editor.org/info/rfc1112>.

   [RFC1536]  Kumar, A., Postel, J., Neuman, C., Danzig, P., and S.
              Miller, "Common DNS Implementation Errors and Suggested
              Fixes", RFC 1536, DOI 10.17487/RFC1536, October 1993,
              <http://www.rfc-editor.org/info/rfc1536>.

   [RFC1546]  Partridge, C., Mendez, T., and W. Milliken, "Host
              Anycasting Service", RFC 1546, DOI 10.17487/RFC1546,
              November 1993, <http://www.rfc-editor.org/info/rfc1546>.

   [RFC2309]  Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering,
              S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G.,
              Partridge, C., Peterson, L., Ramakrishnan, K., Shenker,
              S., Wroclawski, J., and L. Zhang, "Recommendations on
              Queue Management and Congestion Avoidance in the
              Internet", RFC 2309, DOI 10.17487/RFC2309, April 1998,
              <http://www.rfc-editor.org/info/rfc2309>.

   [RFC2475]  Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.,
              and W. Weiss, "An Architecture for Differentiated
              Services", RFC 2475, DOI 10.17487/RFC2475, December 1998,
              <http://www.rfc-editor.org/info/rfc2475>.

   [RFC2675]  Borman, D., Deering, S., and R. Hinden, "IPv6 Jumbograms",
              RFC 2675, DOI 10.17487/RFC2675, August 1999,
              <http://www.rfc-editor.org/info/rfc2675>.

   [RFC2743]  Linn, J., "Generic Security Service Application Program
              Interface Version 2, Update 1", RFC 2743,
              DOI 10.17487/RFC2743, January 2000,
              <http://www.rfc-editor.org/info/rfc2743>.

   [RFC2887]  Handley, M., Floyd, S., Whetten, B., Kermode, R.,
              Vicisano, L., and M. Luby, "The Reliable Multicast Design
              Space for Bulk Data Transfer", RFC 2887,
              DOI 10.17487/RFC2887, August 2000,
              <http://www.rfc-editor.org/info/rfc2887>.

   [RFC2983]  Black, D., "Differentiated Services and Tunnels",
              RFC 2983, DOI 10.17487/RFC2983, October 2000,
              <http://www.rfc-editor.org/info/rfc2983>.

   [RFC3048]  Whetten, B., Vicisano, L., Kermode, R., Handley, M.,
              Floyd, S., and M. Luby, "Reliable Multicast Transport
              Building Blocks for One-to-Many Bulk-Data Transfer",
              RFC 3048, DOI 10.17487/RFC3048, January 2001,
              <http://www.rfc-editor.org/info/rfc3048>.

   [RFC3124]  Balakrishnan, H. and S. Seshan, "The Congestion Manager",
              RFC 3124, DOI 10.17487/RFC3124, June 2001,
              <http://www.rfc-editor.org/info/rfc3124>.

   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              RFC 3168, DOI 10.17487/RFC3168, September 2001,
              <http://www.rfc-editor.org/info/rfc3168>.

   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
              A., Peterson, J., Sparks, R., Handley, M., and E.
              Schooler, "SIP: Session Initiation Protocol", RFC 3261,
              DOI 10.17487/RFC3261, June 2002,
              <http://www.rfc-editor.org/info/rfc3261>.

   [RFC3303]  Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and
              A. Rayhan, "Middlebox communication architecture and
              framework", RFC 3303, DOI 10.17487/RFC3303, August 2002,
              <http://www.rfc-editor.org/info/rfc3303>.

   [RFC3493]  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.
              Stevens, "Basic Socket Interface Extensions for IPv6",
              RFC 3493, DOI 10.17487/RFC3493, February 2003,
              <http://www.rfc-editor.org/info/rfc3493>.

   [RFC3550]  Schulzrinne, H., Casner, S., Frederick, R., and V.
              Jacobson, "RTP: A Transport Protocol for Real-Time
              Applications", STD 64, RFC 3550, DOI 10.17487/RFC3550,
              July 2003, <http://www.rfc-editor.org/info/rfc3550>.

   [RFC3551]  Schulzrinne, H. and S. Casner, "RTP Profile for Audio and
              Video Conferences with Minimal Control", STD 65, RFC 3551,
              DOI 10.17487/RFC3551, July 2003,
              <http://www.rfc-editor.org/info/rfc3551>.

   [RFC3738]  Luby, M. and V. Goyal, "Wave and Equation Based Rate
              Control (WEBRC) Building Block", RFC 3738,
              DOI 10.17487/RFC3738, April 2004,
              <http://www.rfc-editor.org/info/rfc3738>.

   [RFC3758]  Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P.
              Conrad, "Stream Control Transmission Protocol (SCTP)
              Partial Reliability Extension", RFC 3758,
              DOI 10.17487/RFC3758, May 2004,
              <http://www.rfc-editor.org/info/rfc3758>.

   [RFC3819]  Karn, P., Ed., Bormann, C., Fairhurst, G., Grossman, D.,
              Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L.
              Wood, "Advice for Internet Subnetwork Designers", BCP 89,
              RFC 3819, DOI 10.17487/RFC3819, July 2004,
              <http://www.rfc-editor.org/info/rfc3819>.

   [RFC4301]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, DOI 10.17487/RFC4301,
              December 2005, <http://www.rfc-editor.org/info/rfc4301>.

   [RFC4302]  Kent, S., "IP Authentication Header", RFC 4302,
              DOI 10.17487/RFC4302, December 2005,
              <http://www.rfc-editor.org/info/rfc4302>.

   [RFC4303]  Kent, S., "IP Encapsulating Security Payload (ESP)",
              RFC 4303, DOI 10.17487/RFC4303, December 2005,
              <http://www.rfc-editor.org/info/rfc4303>.

   [RFC4340]  Kohler, E., Handley, M., and S. Floyd, "Datagram
              Congestion Control Protocol (DCCP)", RFC 4340,
              DOI 10.17487/RFC4340, March 2006,
              <http://www.rfc-editor.org/info/rfc4340>.

   [RFC4341]  Floyd, S. and E. Kohler, "Profile for Datagram Congestion
              Control Protocol (DCCP) Congestion Control ID 2: TCP-like
              Congestion Control", RFC 4341, DOI 10.17487/RFC4341, March
              2006, <http://www.rfc-editor.org/info/rfc4341>.

   [RFC4342]  Floyd, S., Kohler, E., and J. Padhye, "Profile for
              Datagram Congestion Control Protocol (DCCP) Congestion
              Control ID 3: TCP-Friendly Rate Control (TFRC)", RFC 4342,
              DOI 10.17487/RFC4342, March 2006,
              <http://www.rfc-editor.org/info/rfc4342>.

   [RFC4380]  Huitema, C., "Teredo: Tunneling IPv6 over UDP through
              Network Address Translations (NATs)", RFC 4380,
              DOI 10.17487/RFC4380, February 2006,
              <http://www.rfc-editor.org/info/rfc4380>.

   [RFC4607]  Holbrook, H. and B. Cain, "Source-Specific Multicast for
              IP", RFC 4607, DOI 10.17487/RFC4607, August 2006,
              <http://www.rfc-editor.org/info/rfc4607>.

   [RFC4654]  Widmer, J. and M. Handley, "TCP-Friendly Multicast
              Congestion Control (TFMCC): Protocol Specification",
              RFC 4654, DOI 10.17487/RFC4654, August 2006,
              <http://www.rfc-editor.org/info/rfc4654>.

   [RFC4880]  Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R.
              Thayer, "OpenPGP Message Format", RFC 4880,
              DOI 10.17487/RFC4880, November 2007,
              <http://www.rfc-editor.org/info/rfc4880>.

   [RFC4890]  Davies, E. and J. Mohacsi, "Recommendations for Filtering
              ICMPv6 Messages in Firewalls", RFC 4890,
              DOI 10.17487/RFC4890, May 2007,
              <http://www.rfc-editor.org/info/rfc4890>.

   [RFC4960]  Stewart, R., Ed., "Stream Control Transmission Protocol",
              RFC 4960, DOI 10.17487/RFC4960, September 2007,
              <http://www.rfc-editor.org/info/rfc4960>.

   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler, "IPv4 Reassembly
              Errors at High Data Rates", RFC 4963,
              DOI 10.17487/RFC4963, July 2007,
              <http://www.rfc-editor.org/info/rfc4963>.

   [RFC4987]  Eddy, W., "TCP SYN Flooding Attacks and Common
              Mitigations", RFC 4987, DOI 10.17487/RFC4987, August 2007,
              <http://www.rfc-editor.org/info/rfc4987>.

   [RFC5082]  Gill, V., Heasley, J., Meyer, D., Savola, P., Ed., and C.
              Pignataro, "The Generalized TTL Security Mechanism
              (GTSM)", RFC 5082, DOI 10.17487/RFC5082, October 2007,
              <http://www.rfc-editor.org/info/rfc5082>.

   [RFC5245]  Rosenberg, J., "Interactive Connectivity Establishment
              (ICE): A Protocol for Network Address Translator (NAT)
              Traversal for Offer/Answer Protocols", RFC 5245,
              DOI 10.17487/RFC5245, April 2010,
              <http://www.rfc-editor.org/info/rfc5245>.

   [RFC5622]  Floyd, S. and E. Kohler, "Profile for Datagram Congestion
              Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate
              Control for Small Packets (TFRC-SP)", RFC 5622,
              DOI 10.17487/RFC5622, August 2009,
              <http://www.rfc-editor.org/info/rfc5622>.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, DOI 10.17487/RFC5652, September 2009,
              <http://www.rfc-editor.org/info/rfc5652>.

   [RFC5681]  Allman, M., Paxson, V., and E. Blanton, "TCP Congestion
              Control", RFC 5681, DOI 10.17487/RFC5681, September 2009,
              <http://www.rfc-editor.org/info/rfc5681>.

   [RFC5740]  Adamson, B., Bormann, C., Handley, M., and J. Macker,
              "NACK-Oriented Reliable Multicast (NORM) Transport
              Protocol", RFC 5740, DOI 10.17487/RFC5740, November 2009,
              <http://www.rfc-editor.org/info/rfc5740>.

   [RFC5751]  Ramsdell, B. and S. Turner, "Secure/Multipurpose Internet
              Mail Extensions (S/MIME) Version 3.2 Message
              Specification", RFC 5751, DOI 10.17487/RFC5751, January
              2010, <http://www.rfc-editor.org/info/rfc5751>.

   [RFC5775]  Luby, M., Watson, M., and L. Vicisano, "Asynchronous
              Layered Coding (ALC) Protocol Instantiation", RFC 5775,
              DOI 10.17487/RFC5775, April 2010,
              <http://www.rfc-editor.org/info/rfc5775>.

   [RFC5971]  Schulzrinne, H. and R. Hancock, "GIST: General Internet
              Signalling Transport", RFC 5971, DOI 10.17487/RFC5971,
              October 2010, <http://www.rfc-editor.org/info/rfc5971>.

   [RFC5973]  Stiemerling, M., Tschofenig, H., Aoun, C., and E. Davies,
              "NAT/Firewall NSIS Signaling Layer Protocol (NSLP)",
              RFC 5973, DOI 10.17487/RFC5973, October 2010,
              <http://www.rfc-editor.org/info/rfc5973>.

   [RFC6056]  Larsen, M. and F. Gont, "Recommendations for Transport-
              Protocol Port Randomization", BCP 156, RFC 6056,
              DOI 10.17487/RFC6056, January 2011,
              <http://www.rfc-editor.org/info/rfc6056>.

   [RFC6092]  Woodyatt, J., Ed., "Recommended Simple Security
              Capabilities in Customer Premises Equipment (CPE) for
              Providing Residential IPv6 Internet Service", RFC 6092,
              DOI 10.17487/RFC6092, January 2011,
              <http://www.rfc-editor.org/info/rfc6092>.

   [RFC6335]  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.
              Cheshire, "Internet Assigned Numbers Authority (IANA)
              Procedures for the Management of the Service Name and
              Transport Protocol Port Number Registry", BCP 165,
              RFC 6335, DOI 10.17487/RFC6335, August 2011,
              <http://www.rfc-editor.org/info/rfc6335>.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <http://www.rfc-editor.org/info/rfc6347>.

   [RFC6396]  Blunk, L., Karir, M., and C. Labovitz, "Multi-Threaded
              Routing Toolkit (MRT) Routing Information Export Format",
              RFC 6396, DOI 10.17487/RFC6396, October 2011,
              <http://www.rfc-editor.org/info/rfc6396>.

   [RFC6437]  Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme,
              "IPv6 Flow Label Specification", RFC 6437,
              DOI 10.17487/RFC6437, November 2011,
              <http://www.rfc-editor.org/info/rfc6437>.

   [RFC6438]  Carpenter, B. and S. Amante, "Using the IPv6 Flow Label
              for Equal Cost Multipath Routing and Link Aggregation in
              Tunnels", RFC 6438, DOI 10.17487/RFC6438, November 2011,
              <http://www.rfc-editor.org/info/rfc6438>.

   [RFC6513]  Rosen, E., Ed. and R. Aggarwal, Ed., "Multicast in MPLS/
              BGP IP VPNs", RFC 6513, DOI 10.17487/RFC6513, February
              2012, <http://www.rfc-editor.org/info/rfc6513>.

   [RFC6679]  Westerlund, M., Johansson, I., Perkins, C., O'Hanlon, P.,
              and K. Carlberg, "Explicit Congestion Notification (ECN)
              for RTP over UDP", RFC 6679, DOI 10.17487/RFC6679, August
              2012, <http://www.rfc-editor.org/info/rfc6679>.

   [RFC6726]  Paila, T., Walsh, R., Luby, M., Roca, V., and R. Lehtonen,
              "FLUTE - File Delivery over Unidirectional Transport",
              RFC 6726, DOI 10.17487/RFC6726, November 2012,
              <http://www.rfc-editor.org/info/rfc6726>.

   [RFC6773]  Phelan, T., Fairhurst, G., and C. Perkins, "DCCP-UDP: A
              Datagram Congestion Control Protocol UDP Encapsulation for
              NAT Traversal", RFC 6773, DOI 10.17487/RFC6773, November
              2012, <http://www.rfc-editor.org/info/rfc6773>.

   [RFC6807]  Farinacci, D., Shepherd, G., Venaas, S., and Y. Cai,
              "Population Count Extensions to Protocol Independent
              Multicast (PIM)", RFC 6807, DOI 10.17487/RFC6807, December
              2012, <http://www.rfc-editor.org/info/rfc6807>.

   [RFC6887]  Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and
              P. Selkirk, "Port Control Protocol (PCP)", RFC 6887,
              DOI 10.17487/RFC6887, April 2013,
              <http://www.rfc-editor.org/info/rfc6887>.

   [RFC6935]  Eubanks, M., Chimento, P., and M. Westerlund, "IPv6 and
              UDP Checksums for Tunneled Packets", RFC 6935,
              DOI 10.17487/RFC6935, April 2013,
              <http://www.rfc-editor.org/info/rfc6935>.

   [RFC6936]  Fairhurst, G. and M. Westerlund, "Applicability Statement
              for the Use of IPv6 UDP Datagrams with Zero Checksums",
              RFC 6936, DOI 10.17487/RFC6936, April 2013,
              <http://www.rfc-editor.org/info/rfc6936>.

   [RFC6951]  Tuexen, M. and R. Stewart, "UDP Encapsulation of Stream
              Control Transmission Protocol (SCTP) Packets for End-Host
              to End-Host Communication", RFC 6951,
              DOI 10.17487/RFC6951, May 2013,
              <http://www.rfc-editor.org/info/rfc6951>.

   [RFC7143]  Chadalapaka, M., Satran, J., Meth, K., and D. Black,
              "Internet Small Computer System Interface (iSCSI) Protocol
              (Consolidated)", RFC 7143, DOI 10.17487/RFC7143, April
              2014, <http://www.rfc-editor.org/info/rfc7143>.

   [RFC7201]  Westerlund, M. and C. Perkins, "Options for Securing RTP
              Sessions", RFC 7201, DOI 10.17487/RFC7201, April 2014,
              <http://www.rfc-editor.org/info/rfc7201>.

   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, RFC 7296, DOI 10.17487/RFC7296, October
              2014, <http://www.rfc-editor.org/info/rfc7296>.

   [RFC7450]  Bumgardner, G., "Automatic Multicast Tunneling", RFC 7450,
              DOI 10.17487/RFC7450, February 2015,
              <http://www.rfc-editor.org/info/rfc7450>.

   [RFC7510]  Xu, X., Sheth, N., Yong, L., Callon, R., and D. Black,
              "Encapsulating MPLS in UDP", RFC 7510,
              DOI 10.17487/RFC7510, April 2015,
              <http://www.rfc-editor.org/info/rfc7510>.

   [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May
              2015, <http://www.rfc-editor.org/info/rfc7525>.

   [RFC7560]  Kuehlewind, M., Ed., Scheffenegger, R., and B. Briscoe,
              "Problem Statement and Requirements for Increased Accuracy
              in Explicit Congestion Notification (ECN) Feedback",
              RFC 7560, DOI 10.17487/RFC7560, August 2015,
              <http://www.rfc-editor.org/info/rfc7560>.

   [RFC7567]  Baker, F., Ed. and G. Fairhurst, Ed., "IETF
              Recommendations Regarding Active Queue Management",
              BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015,
              <http://www.rfc-editor.org/info/rfc7567>.

   [RFC7605]  Touch, J., "Recommendations on Using Assigned Transport
              Port Numbers", BCP 165, RFC 7605, DOI 10.17487/RFC7605,
              August 2015, <http://www.rfc-editor.org/info/rfc7605>.

   [RFC7657]  Black, D., Ed. and P. Jones, "Differentiated Services
              (Diffserv) and Real-Time Communication", RFC 7657,
              DOI 10.17487/RFC7657, November 2015,
              <http://www.rfc-editor.org/info/rfc7657>.

   [RFC7675]  Perumal, M., Wing, D., Ravindranath, R., Reddy, T., and M.
              Thomson, "Session Traversal Utilities for NAT (STUN) Usage
              for Consent Freshness", RFC 7675, DOI 10.17487/RFC7675,
              October 2015, <http://www.rfc-editor.org/info/rfc7675>.

   [RFC8083]  Perkins, C. and V. Singh, "Multimedia Congestion Control:
              Circuit Breakers for Unicast RTP Sessions", RFC 8083,
              DOI 10.17487/RFC8083, March 2017,
              <http://www.rfc-editor.org/info/rfc8083>.

   [RFC8086]  Yong, L., Ed., Crabbe, E., Xu, X., and T. Herbert, "GRE-
              in-UDP Encapsulation", RFC 8086, DOI 10.17487/RFC8086,
              March 2017, <http://www.rfc-editor.org/info/rfc8086>.

   [RFC8087]  Fairhurst, G. and M. Welzl, "The Benefits of Using
              Explicit Congestion Notification (ECN)", RFC 8087,
              DOI 10.17487/RFC8087, March 2017,
              <http://www.rfc-editor.org/info/rfc8087>.
```

\[STEVENS\] Stevens, W., Fenner, B. 및 A. Rudoff, "UNIX 네트워크 프로그래밍, 소켓 네트워킹 API", Addison-Wesley, 2004.

```text
   [UPnP]     UPnP Forum, , "Internet Gateway Device (IGD) Standardized
              Device Control Protocol V 1.0", November 2001.
```

---
# **Appendix A.  Case Study of the Use of IPv6 UDP Zero-Checksum Mode**

이 부록에서는 UDP 캡슐화를 정의하는 UDP 터널 캡슐화의 예로 MPLS-in-UDP에 대한 간략한 검토를 제공합니다. 부록의 목적은 IPv6를 통한 MPLS-in-UDP 터널에 UDP 제로 체크섬 모드를 안전하게 사용하기 위해 필요한 메커니즘의 구체적인 예를 제공하는 것입니다. 기본적으로 UDP에는 IPv6과 함께 사용하려면 체크섬이 필요합니다. \[RFC7510\]에 지정된 특정 환경에서 사용될 때 제로 IPv6 UDP 체크섬을 허용하는 옵션이 지정되었으며 이 모드 사용에 대한 일련의 작동 제약 조건을 정의합니다. 이는 아래에 요약되어 있습니다:

IPv6와 함께 제로 체크섬 모드를 사용하는 UDP 터널 또는 캡슐화는 단일 네트워크\(단일 네트워크 운영자 포함\) 또는 트래픽이 정체를 방지하기 위해 관리되는 인접한 협력 네트워크 운영자 집합의 네트워크 내에서만 배포되어야 합니다. 혼잡제어가 필요한 인터넷. MPLS-in-UDP는 단일 관리 제어 하에 있는 네트워크\(예: 단일 운영자의 네트워크 내\)에서 패킷 손상이 예외적으로 발생할 가능성이 없고 운영자가 장비 유형 및 하위 계층 검사에 대한 지식을 통해 알려진 경우에 지정되었습니다. 감지되지 않은 패킷 손상의 위험을 기꺼이 감수합니다.

터널 캡슐화기는 캡슐화 해제기의 IPv6 소스 주소 확인을 강화하기 위해 UDP 제로 체크섬 모드를 사용하는 각 UDP 터널에 대해 서로 다른 IPv6 주소를 사용해야 합니다\(즉, 동일한 IPv6 소스 주소를 더 많은 패킷과 함께 사용해서는 안 됩니다. 대상 주소가 유니캐스트 주소인지 멀티캐스트 주소인지에 관계없이 하나 이상의 IPv6 대상 주소\). MPLS-in-UDP의 사용은 긴밀하게 협력하는 네트워크 관리 집합\(예: 특정 서비스를 공동으로 제공하기 위해 함께 작업하기로 합의한 네트워크 운영자\) 내의 네트워크로 확장될 수 있습니다\[RFC7510\].\(SHOULD NOT\)

MPLS-in-UDP 엔드포인트가 대상 IPv6 주소 외에 소스 IPv6 주소도 확인해야 한다는 요구 사항과 MPLS-in-UDP 터널 간 소스 IPv6 주소 재사용에 대한 강력한 권장 사항은 전체적으로 UDP 체크섬이 없는 경우에 대한 일부 완화를 제공합니다. IPv6 헤더의 적용 범위. 또한 MPLS 데이터 플레인은 유효한 레이블\(예: LSR에 의해 배포된 레이블\)이 있는 패킷만 전달하므로 잘못 전달된 패킷에 다음이 포함되어 있는 경우 MPLS-in-UDP 패킷 잘못 전달을 감지할 수 있는 추가 기회를 제공합니다. 수신 LSR에서의 전달에 유효하지 않은 레이블입니다. MPLS-in-UDP에 대한 IPv6 UDP 제로 체크섬 모드의 예상 결과는 소스 IPv6 및/또는 MPLS 최상위 레이블에 대한 상쇄 손상이 거의 발생하지 않기 때문에 대상 IPv6 주소가 손상되면 일반적으로 패킷 삭제가 발생한다는 것입니다.

IPv6 UDP 제로 체크섬 모드의 사용을 MPLS 패킷 손상이 실제로 문제가 되지 않은 잘 관리되는 네트워크로 제한하는 위 예외의 제한 사항에 의해 추가 보증이 제공됩니다. 따라서 MPLS-in-UDP는 위에서 언급한 예외 사항이 허용되는 잘 관리되는 네트워크의 하위 계층을 통한 전송에 적합하며 이러한 네트워크에서 내부 IP 패킷의 손상 비율은 MPLS 트래픽에 비해 증가할 것으로 예상되지 않습니다. 이는 UDP로 캡슐화되지 않습니다. 이러한 이유로 MPLS-in-UDP는 IPv6에서 UDP zero-checksum 모드를 사용할 때 추가적인 무결성 검사를 제공하지 않으며, 이 설계는 \[RFC6936\]의 5항에 명시된 요구사항 2, 3, 5를 따른다.

MPLS-in-UDP 캡슐화는 UDP 체크섬이 0인 IPv6 데이터그램을 삭제하는 미들박스를 포함하는 경로를 통해 터널을 리디렉션하는 경로 변경이 발생할 때 안전하게 체크섬을 사용하도록 대체하는 메커니즘을 제공하지 않습니다. 이 경우 MPLS-in-UDP 터널은 해당 미들박스에 의해 블랙홀됩니다. IPv6 제로 UDP 체크섬 사용을 지원하기 위해 방화벽, NAT 및 기타 미들박스를 허용하는 권장 변경 사항은 \[RFC6936\]의 섹션 5에 설명되어 있습니다. MPLS는 레이블 스택 손상으로 인해 잘못된 상태를 축적하지 않습니다. MPLS 레이블이 손상되면 MPLS 프로토콜 상태가 누적되지 않고 패킷이 삭제되거나 패킷이 전달\(및 잊어버리게\)됩니다. 오류가 발생하면 운영 및 관리 목적으로 MPLS 프로토콜 외부에 오류 정보가 일부 축적되기 때문에 오류에 대한 MPLS-in-UDP 트래픽의 적극적인 모니터링이 필요합니다. 이 설계는 \[RFC6936\]의 섹션 5에 지정된 요구사항 4를 따릅니다. 또한 UDP 체크섬이 0인 IPv6 트래픽은 네트워크 운영자가 오류가 있는지 적극적으로 모니터링해야 합니다.\(MUST, MUST\)

또한 운영자는 잘못된 구성이나 패킷 오류로 인해 UDP 체크섬이 0인 IPv6 패킷이 네트워크에서 탈출하는 것을 방지하기 위해 패킷 필터를 배포해야 합니다. 또한 UDP 체크섬이 0인 IPv6 트래픽은 네트워크 운영자가 오류가 있는지 적극적으로 모니터링해야 합니다.\(SHOULD, MUST\)

---
# **Acknowledgments**

섹션 3.5의 미들박스 순회 지침은 Bryan Ford, Pyda Srisuresh 및 Dan Kegel의 \[BEHAVE-APP\] 섹션 5의 아이디어를 통합합니다. 섹션 3.1.1의 프로토콜 타이머 지침은 Mark Allman이 크게 기여했습니다.

G. Fairhurst는 보조금 계약 번호 644334\(NEAT\)에 따라 유럽 연합의 Horizon 2020 연구 및 혁신 프로그램 2014-2018로부터 자금을 지원 받았습니다. Lars Eggert는 보조금 계약 번호 644866\(SSICLOPS\)에 따라 유럽 연합의 Horizon 2020 연구 및 혁신 프로그램 2014-2018로부터 자금을 지원 받았습니다. 이 문서는 저자의 견해만을 반영하며 유럽연합 집행위원회는 여기에 포함된 정보의 사용에 대해 책임을 지지 않습니다.

---
# **Authors' Addresses**

```text
   Lars Eggert
   NetApp
   Sonnenallee 1
   Kirchheim  85551
   Germany

   Phone: +49 151 120 55791
   Email: lars@netapp.com
   URI:   https://eggert.org/
```

Godred Fairhurst University of Aberdeen 공학과 Fraser Noble Building Aberdeen AB24 3UE 스코틀랜드

```text
   Email: gorry@erg.abdn.ac.uk
   URI:   http://www.erg.abdn.ac.uk/
```

Greg Shepherd Cisco Systems Tasman Drive 산호세 미국

```text
   Email: gjshep@gmail.com
```
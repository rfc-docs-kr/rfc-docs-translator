

```text
﻿

Internet Engineering Task Force (IETF)                        R. Housley
Request for Comments: 8696                                Vigil Security
Category: Standards Track                                  December 2019
ISSN: 2070-1721
```

CMS\(암호화 메시지 구문\)에서 PSK\(사전 공유 키\) 사용

---
# **Abstract**

대규모 양자 컴퓨터의 발명은 오늘날 널리 배포되는 암호화 알고리즘에 심각한 도전을 제기할 것입니다.  CMS\(암호화 메시지 구문\)는 이러한 양자 컴퓨터의 발명으로 인해 깨질 수 있는 키 전송 및 키 계약 알고리즘을 지원합니다.  현재 CMS로 보호되는 통신을 저장함으로써 미래에 대규모 양자 컴퓨터가 출시되면 누군가 이를 해독할 수 있습니다.  양자 보안 키 관리 알고리즘을 사용할 수 있게 되면 CMS는 기존 구문이 이를 수용하지 못하는 경우 새 알고리즘을 지원하도록 확장됩니다.  이 문서에서는 키 전송 및 키 합의 알고리즘의 출력을 사전 공유 키와 혼합하여 대규모 양자 컴퓨터의 미래 발명으로부터 오늘날의 통신을 보호하는 메커니즘을 설명합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8696에서 확인할 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2019 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서에는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(https://trustee.ietf.org/license-info\)이 적용됩니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
     1.1.  Terminology
     1.2.  ASN.1
     1.3.  Version Numbers
   2.  Overview
   3.  keyTransPSK
   4.  keyAgreePSK
   5.  Key Derivation
   6.  ASN.1 Module
   7.  Security Considerations
   8.  Privacy Considerations
   9.  IANA Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  Key Transport with PSK Example
     A.1.  Originator Processing Example
     A.2.  ContentInfo and AuthEnvelopedData
     A.3.  Recipient Processing Example
   Appendix B.  Key Agreement with PSK Example
     B.1.  Originator Processing Example
     B.2.  ContentInfo and AuthEnvelopedData
     B.3.  Recipient Processing Example
   Acknowledgements
   Author's Address
```

---
## **1.  Introduction**

대규모 양자 컴퓨터의 발명은 오늘날 널리 배포되는 암호화 알고리즘에 심각한 도전을 제기할 것입니다\[S1994\].  대규모 양자 컴퓨터를 구축하는 것이 가능한지, 만약 그렇다면 언제 실현될 수 있는지는 공개된 질문입니다\[NAS2019\].  그러나 그러한 양자 컴퓨터가 발명된다면 이를 사용하는 많은 암호화 알고리즘과 보안 프로토콜이 취약해질 것입니다.

CMS\(암호화 메시지 구문\)\[RFC5652\]\[RFC5083\]는 대규모 양자 컴퓨터\[C2PQ\]의 발명으로 인해 깨질 수 있는 키 전송 및 키 계약 알고리즘을 지원합니다.  이러한 알고리즘에는 RSA \[RFC8017\], Diffie-Hellman \[RFC2631\] 및 Elliptic Curve Diffie-Hellman\(ECDH\) \[RFC5753\]이 포함됩니다.  결과적으로, 현재 CMS로 보호되는 통신을 저장하는 공격자는 향후 대규모 양자 컴퓨터를 사용할 수 있게 되면 이러한 통신을 해독할 수 있습니다.

양자 보안 키 관리 알고리즘을 사용할 수 있게 되면 기존 구문이 새 알고리즘을 아직 수용하지 못하는 경우 이를 지원하도록 CMS가 확장됩니다.

단기적으로 이 문서에서는 기존 키 전송 및 키 합의 알고리즘의 출력을 사전 공유 키\(PSK\)와 혼합하여 미래의 대규모 양자 컴퓨터 발명으로부터 오늘날의 통신을 보호하는 메커니즘을 설명합니다.  강력한 PSK를 RSA \[RFC8017\]와 같은 기존 키 전송 알고리즘이나 Diffie-Hellman \[RFC2631\] 또는 ECDH\(Elliptic Curve Diffie-Hellman\)와 같은 기존 키 합의 알고리즘의 출력과 혼합하여 오늘날 보안 통신을 달성할 수 있습니다. \[RFC5753\].  HMAC 기반 키 유도 함수\(HKDF\)\[RFC5869\]와 같은 양자 저항 키 유도 함수\(KDF\)와 함께 엔트로피가 충분한 PSK를 사용하면 양자 저항성이 있다고 여겨지는 보안 솔루션을 구현할 수 있습니다. 256비트 AES \[AES\]와 같은 양자 저항 암호화 알고리즘.  이러한 방식으로 오늘날의 CMS로 보호되는 통신은 대규모 양자 컴퓨터를 갖춘 공격자에 저항할 수 있습니다.

또한 향후 대규모 양자 컴퓨터 발명에 대한 보호 외에 강력한 PSK를 포함하는 다른 이유가 있을 수 있습니다.  예를 들어, 하나 이상의 기존 공개 키 알고리즘에는 암호화 분석의 획기적인 발전 가능성이 항상 존재하며, Diffie-Hellman 매개변수\[FGHT2016\]에 공개되지 않은 트랩도어에 대한 오랜 우려가 있습니다.  전체 키 관리의 일부로 강력한 PSK를 포함하면 이러한 문제에 대한 추가적인 보호가 제공됩니다.

CMS는 대칭 키 암호화 키와 비밀번호를 기반으로 한 키 관리 기술도 지원하지만 이미 양자 저항성을 갖추고 있으므로 이 문서에서는 논의하지 않습니다.  대칭 키-암호화 키 기술은 적절한 키 크기와 함께 사용될 때 양자 저항성을 갖습니다.  비밀번호 기술은 양자 저항성 키 파생 기능 및 충분히 큰 비밀번호와 함께 사용될 때 양자 저항성을 갖습니다.

---
### **1.1.  Terminology**

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 여기에 표시된 대로 모두 대문자로 표시되는 경우에만 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 해석됩니다.

---
### **1.2.  ASN.1**

CMS 값은 BER\(Basic Encoding Rules\) 및 DER\(Distinguished Encoding Rules\) \[X690\]을 사용하는 ASN.1 \[X680\]을 사용하여 생성됩니다.

---
### **1.3.  Version Numbers**

주요 데이터 구조에는 데이터 구조의 첫 번째 항목으로 버전 번호가 포함됩니다.  버전 번호는 ASN.1 디코드 오류를 방지하기 위한 것입니다.  일부 구현에서는 디코딩을 시도하기 전에 버전 번호를 확인하지 않습니다. 그런 다음 디코드 오류가 발생하면 오류 처리 루틴의 일부로 버전 번호가 확인됩니다. 이는 합리적인 접근 방식입니다. 빠른 경로 외부에 오류 처리를 배치합니다.  이 접근 방식은 보낸 사람이 잘못된 버전 번호를 사용한 경우에도 용서됩니다.

구조가 업데이트될 때마다 더 높은 버전 번호가 할당됩니다.  그러나 최대 상호 운용성을 보장하기 위해 더 높은 버전 번호는 새로운 구문 기능이 사용되는 경우에만 사용됩니다. 즉, 생성된 구문을 지원하는 가장 낮은 버전 번호가 사용됩니다.

---
## **2.  Overview**

CMS 봉투 데이터 콘텐츠 유형\[RFC5652\]과 CMS 인증 봉투 데이터 콘텐츠 유형\[RFC5083\]은 콘텐츠 암호화에 사용되는 키를 설정하기 위해 키 전송 및 키 계약 공개 키 알고리즘을 모두 지원합니다.  키 전송 또는 키 계약 공개 키 알고리즘에는 제한이 적용되지 않습니다. 즉, 향후 지정되는 알고리즘을 포함하여 모든 키 전송 또는 키 계약 알고리즘을 사용할 수 있습니다.  두 경우 모두 보낸 사람이 콘텐츠 암호화 키를 무작위로 생성하면 모든 받는 사람이 해당 키를 얻습니다.  모든 수신자는 암호 해독을 위해 보낸 사람이 생성한 대칭 콘텐츠 암호화 키를 사용합니다.

이 사양은 보낸 사람이 생성한 콘텐츠 암호화 키를 암호화하는 데 사용되는 대칭 키 암호화 키를 설정하는 두 가지 양자 방지 방법을 정의합니다.  두 경우 모두 PSK는 양자 저항 키 암호화 키를 생성하기 위한 키 파생 기능에 대한 입력 중 하나로 사용됩니다.  PSK는 향후 대규모 양자 컴퓨터 발명에 취약하지 않도록 일부 대역 외 수단을 통해 발신자와 모든 수신자에게 배포되어야 하며 식별자가 PSK에 할당되어야 합니다.  각 PSK에 고유 식별자가 있는 것이 가장 좋습니다. 그러나 수신자가 동일한 식별자를 가진 PSK를 두 개 이상 가지고 있는 경우 수신자는 각 PSK를 차례로 시도할 수 있습니다.  PSK는 수명이 몇 주 또는 몇 달인 많은 메시지와 함께 사용될 것으로 예상됩니다.

콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키는 양자 저항성이 있으며 보낸 사람은 다음 단계를 사용하여 이를 설정합니다.

키 전송 알고리즘을 사용하는 경우:

1. "CEK"라고 불리는 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키가 무작위로 생성됩니다.

1. "KDK"라고 불리는 키 파생 키가 무작위로 생성됩니다.

1. 각 수신자에 대해 KDK는 수신자의 공개 키로 암호화된 다음 KDF를 사용하여 PSK와 KDK를 혼합하여 "KEK"라는 키 암호화 키를 생성합니다.

1. KEK는 CEK를 암호화하는 데 사용됩니다.

키 계약 알고리즘을 사용하는 경우:

1. "CEK"라고 불리는 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키가 무작위로 생성됩니다.

1. 각 수신자에 대해 수신자의 공개 키와 발신자의 개인 키를 사용하여 "KEK1"이라는 쌍별 키 암호화 키가 설정됩니다.  KEK1은 키 파생 키로 사용됩니다.

1. 각 수신자에 대해 KDF를 사용하여 PSK와 쌍별 KEK1을 혼합하고 그 결과를 "KEK2"라고 합니다.

1. 각 수신자에 대해 쌍별 KEK2가 CEK를 암호화하는 데 사용됩니다.

\[RFC5652\]의 6.2.5절에 명시된 대로 추가적인 키 관리 기술에 대한 수신자 정보는 OtherRecipientInfo 유형으로 표현된다.  이 문서에는 두 가지 키 관리 기술이 지정되어 있으며 각각 고유한 ASN.1 개체 식별자로 식별됩니다.

"keyTransPSK"\(섹션 3 참조\)라고 하는 첫 번째 키 관리 기술은 키 전송 알고리즘을 사용하여 키 파생 키를 보낸 사람에게서 받는 사람으로 전송한 다음 키 파생 키를 KDF를 사용하여 PSK와 혼합합니다. .  KDF의 출력은 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키의 암호화에 사용되는 키 암호화 키입니다.

"keyAgreePSK"\(섹션 4 참조\)라고 하는 두 번째 키 관리 기술은 키 계약 알고리즘을 사용하여 쌍별 키 암호화 키를 설정합니다.  그런 다음 이 쌍별 키 암호화 키는 KDF를 사용하여 PSK와 혼합되어 두 번째 쌍별 키 암호화 키를 생성하고, 이 키는 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키를 암호화하는 데 사용됩니다.

---
## **3.  keyTransPSK**

keyTransPSK를 사용하는 수신자별 정보는 KeyTransPSKRecipientInfo 유형으로 표현되며, 이는 id-ori-keyTransPSK 개체 식별자로 표시됩니다.  KeyTransPSKRecipientInfo의 각 인스턴스는 동일한 PSK에 액세스할 수 있는 한 명 이상의 수신자에 대해 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키를 설정합니다.

id-ori-keyTransPSK 개체 식별자는 다음과 같습니다.

```text
      id-ori OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
        rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) 13 }

      id-ori-keyTransPSK OBJECT IDENTIFIER ::= { id-ori 1 }
```

KeyTransPSKRecipientInfo 유형은 다음과 같습니다.

- KeyTransPSKRecipientInfo ::= SEQUENCE { 버전 CMSVersion, -- 항상 0으로 설정 pskid PreSharedKeyIdentifier, kdfAlgorithm KeyDerivationAlgorithmIdentifier, keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier, ktris KeyTransRecipientInfos, cryptoKey EncryptedKey }

```text
      PreSharedKeyIdentifier ::= OCTET STRING
```

- KeyTransRecipientInfos ::= KeyTransRecipientInfo의 순서

KeyTransPSKRecipientInfo 유형의 필드는 다음과 같은 의미를 갖습니다.

\* version은 구문 버전 번호입니다.  버전은 0이어야 합니다. CMSVersion 유형은 \[RFC5652\]의 섹션 10.2.5에 설명되어 있습니다.

\* pskid는 발신자가 사용하는 PSK의 식별자입니다.  식별자는 OCTET STRING이며 사람이 읽을 수 있을 필요는 없습니다.

\* kdfAlgorithm은 키 파생 키와 PSK를 혼합하여 키 암호화 키를 생성하기 위해 보낸 사람이 사용하는 키 파생 알고리즘 및 관련 매개 변수를 식별합니다.  KeyDerivationAlgorithmIdentifier는 \[RFC5652\]의 섹션 10.1.6에 설명되어 있습니다.

\* keyEncryptionAlgorithm은 콘텐츠 암호화 키를 암호화하는 데 사용되는 키 암호화 알고리즘을 식별합니다.  KeyEncryptionAlgorithmIdentifier는 \[RFC5652\]의 섹션 10.1.3에 설명되어 있습니다.

\* ktris에는 각 수신자에 대해 하나의 KeyTransRecipientInfo 유형이 포함되어 있습니다. 키 파생 키를 설정하기 위해 키 전송 알고리즘을 사용합니다.  즉, KeyTransRecipientInfo의 암호화된 키 필드에는 콘텐츠 암호화 키 대신 키 파생 키가 포함됩니다.  KeyTransRecipientInfo는 \[RFC5652\]의 섹션 6.2.1에 설명되어 있습니다.

\* cryptoKey는 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키를 키 암호화 키로 암호화한 결과입니다.  EncryptedKey는 OCTET 문자열입니다.

---
## **4.  keyAgreePSK**

keyAgreePSK를 사용하는 수신자별 정보는 KeyAgreePSKRecipientInfo 유형으로 표시되며, 이는 id-ori-keyAgreePSK 개체 식별자로 표시됩니다.  KeyAgreePSKRecipientInfo의 각 인스턴스는 동일한 PSK에 액세스할 수 있는 한 명 이상의 수신자에 대해 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키를 설정합니다.

id-ori-keyAgreePSK 개체 식별자는 다음과 같습니다.

- id-ori-keyAgreePSK 개체 IDENTIFIER ::= { id-ori 2 } KeyAgreePSKRecipientInfo 유형은 다음과 같습니다.

- KeyAgreePSKRecipientInfo ::= SEQUENCE { version CMSVersion, -- 항상 0으로 설정됨 pskid PreSharedKeyIdentifier, Originator \[0\] EXPLICIT OriginatorIdentifierOrKey, ukm \[1\] EXPLICIT UserKeyingMaterial OPTIONAL, kdfAlgorithm KeyDerivationAlgorithmIdentifier, keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier, receiveEncryptedKeys 암호화된 키 }

KeyAgreePSKRecipientInfo 유형의 필드에는 다음과 같은 의미가 있습니다.

\* version은 구문 버전 번호입니다.  버전은 0이어야 합니다. CMSVersion 유형은 \[RFC5652\]의 섹션 10.2.5에 설명되어 있습니다.

\* pskid는 발신자가 사용하는 PSK의 식별자입니다.  식별자는 OCTET STRING이며 사람이 읽을 수 있을 필요는 없습니다.

\* 발신자는 보낸 사람의 키 계약 공개 키를 지정하는 세 가지 대안이 있는 CHOICE입니다.  구현은 발신자의 공개 키를 지정하기 위한 세 가지 대안을 모두 지원해야 합니다. 발신자는 자신의 개인 키와 수신자의 공개 키를 사용하여 쌍별 키 암호화 키를 생성합니다.  KDF는 PSK와 쌍별 키 암호화 키를 혼합하여 두 번째 키 암호화 키를 생성하는 데 사용됩니다.  OriginatorIdentifierOrKey 유형은 \[RFC5652\]의 섹션 6.2.2에 설명되어 있습니다.

\* ukm은 선택사항입니다.  일부 키 계약 알고리즘을 사용하면 발신자는 UKM\(사용자 키 자료\)을 제공하여 동일한 두 당사자가 쌍별 키를 생성할 때마다 다른 키가 생성되도록 합니다.  구현은 ukm 필드를 포함하는 KeyAgreePSKRecipientInfo SEQUENCE를 수락해야 합니다. UKM을 사용하는 주요 계약 알고리즘을 지원하지 않는 구현은 UKM의 존재를 적절하게 처리해야 합니다.  UserKeyingMaterial 유형은 \[RFC5652\]의 섹션 10.2.6에 설명되어 있습니다.

\* kdfAlgorithm은 보낸 사람이 쌍별 키 암호화 키와 PSK를 혼합하여 첫 번째 키와 동일한 길이의 두 번째 키 암호화 키를 생성하는 데 사용하는 키 파생 알고리즘 및 관련 매개 변수를 식별합니다.  KeyDerivationAlgorithmIdentifier는 \[RFC5652\]의 섹션 10.1.6에 설명되어 있습니다.

\* keyEncryptionAlgorithm은 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키를 암호화하는 데 사용되는 키 암호화 알고리즘을 식별합니다.  KeyEncryptionAlgorithmIdentifier 유형은 \[RFC5652\]의 섹션 10.1.3에 설명되어 있습니다.

\* receiveEncryptedKeys에는 수신자 식별자와 한 명 이상의 수신자에 대한 암호화된 키가 포함됩니다.  KeyAgreeRecipientIdentifier는 수신자의 인증서와 수신자의 공개 키를 지정하는 두 가지 대안이 있는 CHOICE입니다. 이는 발신자가 쌍별 키 암호화 키를 생성하는 데 사용했습니다.  암호화된 키는 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키를 두 번째 쌍별 키 암호화 키로 암호화한 결과입니다.  EncryptedKey는 OCTET 문자열입니다.  RecipientEncryptedKeys 유형은 \[RFC5652\]의 섹션 6.2.2에 정의되어 있습니다.

---
## **5.  Key Derivation**

많은 KDF는 내부적으로 단방향 해시 함수를 사용합니다.  이 경우 사용되는 해시 함수는 KeyDerivationAlgorithmIdentifier에 의해 간접적으로 표시됩니다.  HKDF \[RFC5869\]는 해시 함수를 사용하는 KDF의 한 예입니다.

다른 KDF는 내부적으로 암호화 알고리즘을 사용합니다.  이 경우 사용되는 암호화는 KeyDerivationAlgorithmIdentifier에 의해 간접적으로 표시됩니다.  예를 들어, AES-128-CMAC는 \[NIST2018\]에 설명된 대로 KDF의 무작위 추출에 사용될 수 있습니다.

KDF에는 여러 입력 값이 있습니다.  이 섹션에서는 KDF를 사용하여 KeyTransPSKRecipientInfo 및 KeyAgreePSKRecipientInfo에 대한 키 암호화 키를 계산하는 규칙을 설명합니다.  단순화를 위해 HKDF 사양 \[RFC5869\]에 사용된 용어가 여기에서 사용됩니다.

KDF 입력은 다음과 같습니다.

\* IKM은 입력 키 자료입니다. 이는 KDF에 대한 대칭 비밀 입력입니다.  KeyTransPSKRecipientInfo의 경우 이는 키 파생 키입니다.  KeyAgreePSKRecipientInfo의 경우 키 계약 알고리즘에 의해 생성된 쌍별 키 암호화 키입니다.

\* 소금은 선택적이며 비밀이 아닌 임의 값입니다.  많은 KDF에는 솔트가 필요하지 않으며 HKDF \[RFC8619\]에 대한 KeyDerivationAlgorithmIdentifier 할당은 솔트에 대한 매개 변수를 제공하지 않습니다.  특정 KDF에 솔트가 필요한 경우 솔트 값은 KeyDerivationAlgorithmIdentifier의 매개변수로 제공됩니다.

\* L은 옥텟 단위의 출력 키 자료의 길이입니다. 값은 사용될 키 암호화 알고리즘에 따라 달라집니다.  알고리즘은 KeyEncryptionAlgorithmIdentifier로 식별됩니다. 또한 KeyEncryptionAlgorithmIdentifier의 OBJECT IDENTIFIER 부분은 "info"라는 다음 입력 값에 포함됩니다.

\* 정보는 선택적 컨텍스트 및 애플리케이션별 정보입니다. CMSORIforPSKOtherInfo의 DER 인코딩이 info 값으로 사용되며 PSK가 이 구조에 포함됩니다.  EXPLICIT 태그 지정은 이 구조를 정의하는 ASN.1 모듈에서 사용됩니다.  KeyTransPSKRecipientInfo의 경우 ENUMERATED 값 5가 사용됩니다.  KeyAgreePSKRecipientInfo의 경우 ENUMERATED 값 10이 사용됩니다.  CMSORIforPSKOtherInfo는 다음 ASN.1 구조로 정의됩니다.

```text
         CMSORIforPSKOtherInfo ::= SEQUENCE {
           psk                    OCTET STRING,
           keyMgmtAlgType         ENUMERATED {
             keyTrans               (5),
             keyAgree               (10) },
           keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
           pskLength              INTEGER (1..MAX),
           kdkLength              INTEGER (1..MAX) }
```

CMSORIforPSKotherInfo 유형의 필드는 다음과 같은 의미를 갖습니다.

\* psk는 OCTET 문자열입니다. 여기에는 PSK가 포함되어 있습니다.

\* keyMgmtAlgType은 5 또는 10으로 설정됩니다. KeyTransPSKRecipientInfo의 경우 ENUMERATED 값 5가 사용됩니다.  KeyAgreePSKRecipientInfo의 경우 ENUMERATED 값 10이 사용됩니다.

\* keyEncryptionAlgorithm은 알고리즘을 식별하고 알고리즘 매개변수\(있는 경우\)를 제공하는 KeyEncryptionAlgorithmIdentifier입니다.

\* pskLength는 양의 정수입니다. 여기에는 옥텟 단위의 PSK 길이가 포함됩니다.

\* kdkLength는 양의 정수입니다. 여기에는 옥텟 단위의 키 파생 키 길이가 포함됩니다.  KeyTransPSKRecipientInfo의 경우 키 파생 키는 발신자에 의해 생성됩니다.  KeyAgreePSKRecipientInfo의 경우 키 파생 키는 키 계약 알고리즘에 의해 생성된 쌍별 키 암호화 키입니다.

KDF 출력은 다음과 같습니다.

\* OKM은 정확히 L 옥텟인 출력 키 자료입니다.  OKM은 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키를 암호화하는 데 사용되는 키 암호화 키입니다.

허용되는 KDF는 IKM, L 및 정보 입력을 허용해야 합니다. 허용 가능한 KDF는 소금 및 기타 입력도 허용할 수 있습니다.  이러한 모든 입력은 KDF의 출력에 영향을 주어야 합니다.  KDF에 솔트 또는 기타 입력이 필요한 경우 해당 입력은 KeyDerivationAlgorithmIdentifier의 매개변수로 제공되어야 합니다.

---
## **6.  ASN.1 Module**

이 섹션에는 이 문서에 정의된 두 가지 주요 관리 기술에 대한 ASN.1 모듈이 포함되어 있습니다.  이 모듈은 \[RFC5912\] 및 \[RFC6268\]에 정의된 다른 ASN.1 모듈에서 유형을 가져옵니다.

```text
   <CODE BEGINS>
   CMSORIforPSK-2019
     { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9)
       smime(16) modules(0) id-mod-cms-ori-psk-2019(69) }

   DEFINITIONS EXPLICIT TAGS ::=
   BEGIN

   -- EXPORTS All

   IMPORTS
```

AlgorithmIdentifier{}, AlgorithmInformation-2009에서 키 파생 -- \[RFC5912\] { iso\(1\) 식별된 조직\(3\) dod\(6\) 인터넷\(1\) 보안\(5\) 메커니즘\(5\) pkix\(7\) id-mod \(0\) id-mod-algorithmInformation-02\(58\) }

OTHER-RECIPIENT, OtherRecipientInfo, CMSVersion, KeyTransRecipientInfo, OriginatorIdentifierOrKey, UserKeyingMaterial, RecipientEncryptedKeys, EncryptedKey, KeyDerivationAlgorithmIdentifier, KeyEncryptionAlgorithmIdentifier FROM CryptographicMessageSyntax-2010 -- \[RFC6268\] { iso\(1\) member-body\(2\) us\(840\) \(113549\) pkcs \(1\) pkcs-9\(9\) smime\(16\) 모듈\(0\) id-mod-cms-2009\(58\) } ; -- -- OtherRecipientInfo 유형\(ori-\) --

```text
   SupportedOtherRecipInfo OTHER-RECIPIENT ::= {
     ori-keyTransPSK |
     ori-keyAgreePSK,
     ... }
```

-- -- 사전 공유 키를 사용한 키 전송 --

ori-keyTransPSK 기타 수신자 ::= { KeyTransPSKRecipientInfo는 id-ori-keyTransPSK에 의해 식별됨 }

```text
   id-ori OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
     rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) 13 }

   id-ori-keyTransPSK OBJECT IDENTIFIER ::= { id-ori 1 }
```

KeyTransPSKRecipientInfo ::= SEQUENCE { 버전 CMSVersion, -- 항상 0으로 설정 pskid PreSharedKeyIdentifier, kdfAlgorithm KeyDerivationAlgorithmIdentifier, keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier, ktris KeyTransRecipientInfos, cryptoKey EncryptedKey }

```text
   PreSharedKeyIdentifier ::= OCTET STRING
```

KeyTransRecipientInfos ::= KeyTransRecipientInfo의 시퀀스

-- -- 사전 공유 키와의 키 계약 --

ori-keyAgreePSK 기타 수신자 ::= { KeyAgreePSKRecipientInfo는 id-ori-keyAgreePSK에 의해 식별됨 }

id-ori-keyAgreePSK 개체 IDENTIFIER ::= { id-ori 2 } KeyAgreePSKRecipientInfo ::= SEQUENCE { version CMSVersion, -- 항상 0으로 설정 pskid PreSharedKeyIdentifier, Originator \[0\] EXPLICIT OriginatorIdentifierOrKey, ukm \[1\] EXPLICIT UserKeyingMaterial OPTIONAL, kdfAlgorithm KeyDerivationAlgorithmIdentifier, keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier, receiveEncryptedKeys RecipientEncryptedKeys }

-- -- 사전 공유 키를 포함하여 KDF에 '정보' 입력을 제공하는 구조 --

```text
   CMSORIforPSKOtherInfo ::= SEQUENCE {
     psk                    OCTET STRING,
     keyMgmtAlgType         ENUMERATED {
       keyTrans               (5),
       keyAgree               (10) },
     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
     pskLength              INTEGER (1..MAX),
     kdkLength              INTEGER (1..MAX) }

   END
   <CODE ENDS>
```

---
## **7.  Security Considerations**

\[RFC5652\]의 CMS 봉투 데이터 콘텐츠 유형과 관련된 보안 고려 사항과 \[RFC5083\]의 CMS 인증 봉투 데이터 콘텐츠 유형과 관련된 보안 고려 사항이 계속 적용됩니다.

키 파생 함수의 구현은 결과의 일부를 출력하기 전에 전체 결과\(이 사양에서는 키 암호화 키\)를 계산해야 합니다.  결과 키 암호화 키는 보호되어야 합니다.  키 암호화 키가 손상되면 해당 키 자료로 보호되었던 모든 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키가 공개될 수 있습니다. 결과적으로 콘텐츠가 공개될 수 있습니다.  키 계약 알고리즘이 포함된 PSK를 사용하는 경우 두 개의 키 암호화 키가 있으며, 이러한 키 중 하나가 손상되면 비슷한 결과가 발생합니다.

구현에서는 PSK, 키 전송 개인 키, 계약 개인 키 및 키 파생 키를 보호해야 합니다.  PSK가 손상되면 암호화된 콘텐츠가 향후 대규모 양자 컴퓨터 발명에 취약해지게 됩니다.  PSK와 키 전송 개인 키 또는 계약 개인 키가 손상되면 해당 키 자료 조합으로 보호되는 모든 콘텐츠가 공개될 수 있습니다.  PSK와 키 파생 키가 손상되면 해당 키 자료 조합으로 보호되는 모든 콘텐츠가 공개될 수 있습니다.

대규모 양자 컴퓨터는 키 전송 알고리즘이나 키 합의 알고리즘이 제공하는 보안을 본질적으로 무효화합니다. 이는 대규모 양자 컴퓨터를 보유한 공격자가 키 파생 키를 발견할 수 있음을 의미합니다.  또한 대규모 양자 컴퓨터는 대칭키 알고리즘이 제공하는 보안을 효과적으로 절반으로 줄인다.  따라서 PSK는 128비트 보안을 제공하려면 최소 256비트의 엔트로피가 필요합니다.  동일한 수준의 보안을 유지하려면 키 파생 기능이 양자 저항성이 있어야 하며 길이가 최소 256비트인 키 암호화 키를 생성해야 합니다.  마찬가지로 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키의 길이는 256비트 이상이어야 합니다.

키 전송 또는 키 계약 알고리즘과 함께 PSK를 사용하는 경우 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키를 암호화하기 위해 키 암호화 키가 생성됩니다.  키 암호화 알고리즘이 콘텐츠를 보호하는 데 사용되는 알고리즘과 다른 경우 효과적인 보안은 두 알고리즘 중 약한 알고리즘에 따라 결정됩니다.  예를 들어 콘텐츠가 256비트 AES로 암호화되고 키가 128비트 AES로 래핑된 경우 최대 128비트의 보호가 제공됩니다.  구현자는 키 암호화 알고리즘이 콘텐츠 암호화 알고리즘이나 콘텐츠 인증 암호화 알고리즘보다 강력하거나 더 강력한지 확인해야 합니다.

키 파생 기능을 선택하면 결과 키 암호화 키의 강도에 상한이 적용됩니다.  선택한 키 파생 기능의 강도는 선택한 키 암호화 알고리즘만큼 강력해야 합니다.  NIST SP 800-56C 개정 ​​1\[NIST2018\]은 널리 사용되는 여러 키 파생 기능의 보안 강도에 대한 조언을 제공합니다.

구현자는 양자 저항 키 관리 알고리즘과 비양자 저항 대응 알고리즘을 혼합해서는 안 됩니다.  예를 들어 동일한 콘텐츠를 KeyTransRecipientInfo 및 KeyTransPSKRecipientInfo로 보호하면 안 됩니다.  마찬가지로 동일한 콘텐츠를 KeyAgreeRecipientInfo 및 KeyAgreePSKRecipientInfo로 보호해서는 안 됩니다.  그렇게 하면 해당 콘텐츠가 향후 대규모 양자 컴퓨터 발명에 취약해지게 됩니다.

구현자는 콘텐츠 암호화 키가 독립적으로 생성되더라도 동일한 콘텐츠를 양자 저항성 키 관리 알고리즘을 사용하는 메시지와 비양자성 키 관리 알고리즘을 사용하는 메시지로 보내서는 안 됩니다.  그렇게 하면 도청자가 메시지를 연관시킬 수 있어 향후 대규모 양자 컴퓨터 발명에 콘텐츠가 취약해질 수 있습니다.

이 사양에서는 발신자와 수신자만이 PSK를 알 수 있도록 요구하지 않습니다.  PSK는 그룹에 알려질 수 있습니다.  기밀성은 키 전송 또는 키 계약 알고리즘에 따라 달라지므로 다른 당사자가 PSK를 알고 있다고 해서 본질적으로 도청이 가능하지는 않습니다.  그러나 그룹 구성원은 다른 구성원의 트래픽을 기록한 다음 대규모 양자 컴퓨터에 액세스할 수 있게 되면 이를 해독할 수 있습니다.  또한 많은 당사자가 PSK를 알고 있으면 공격자가 PSK를 훔칠 기회가 많습니다. 공격자가 PSK를 확보하면 합법적인 그룹 구성원과 동일한 방식으로 대규모 양자 컴퓨터에 액세스할 수 있는 경우 저장된 트래픽을 해독할 수 있습니다.

건전한 암호화 키 위생은 하나의 목적으로만 키를 사용하는 것입니다.  이 문서에 명시된 전통적인 CMS와 PSK 혼합 변형 모두에 대해 수신자의 공개 키를 사용하는 것은 이 원칙을 위반하는 것입니다. 그러나 공격자가 이 상황을 이용할 수 있는 알려진 방법은 없습니다.  즉, 애플리케이션은 가능할 때마다 분리를 적용해야 합니다.  예를 들어, X.509 확장 키 사용 인증서 확장 \[RFC5280\]에 사용하기 위한 목적 식별자는 공개 키가 PSK와 함께 또는 PSK 없이만 사용되어야 함을 나타내기 위해 나중에 식별될 수 있습니다.

구현에서는 키 파생 키와 콘텐츠 암호화 키 또는 콘텐츠 인증 암호화 키를 무작위로 생성해야 합니다. 또한 키 전송을 위한 공개/개인 키 쌍 생성 및 키 계약 알고리즘은 난수에 의존합니다.  암호화 키를 생성하기 위해 부적절한 PRNG\(의사 난수 생성기\)를 사용하면 보안이 거의 또는 전혀 이루어지지 않을 수 있습니다.  공격자는 전체 키 공간을 무차별 대입 검색하는 것보다 결과적으로 작은 가능성 집합을 검색하여 키를 생성한 PRNG 환경을 재현하는 것이 훨씬 쉽다는 것을 알 수 있습니다. 고품질 난수 생성은 어렵습니다.  \[RFC4086\]은 이 영역에 대한 중요한 지침을 제공합니다.

구현자는 암호화 알고리즘이 시간이 지남에 따라 약해진다는 점을 인식해야 합니다.  새로운 암호 분석 기술이 개발되고 컴퓨팅 성능이 향상됨에 따라 특정 암호화 알고리즘을 깨뜨리는 작업 요소가 줄어들 것입니다.  따라서 암호화 알고리즘 구현은 새로운 알고리즘을 쉽게 삽입할 수 있도록 모듈식이어야 합니다.  즉, 구현자는 지원되는 알고리즘 세트가 시간이 지남에 따라 변경될 수 있도록 준비해야 합니다.

이 문서에 명시된 메커니즘에 의해 제공되는 보안 속성은 공식적인 방법을 사용하여 검증될 수 있습니다.  \[H2019\]의 ProVerif 증명은 Diffie-Hellman 키 합의 알고리즘을 깨뜨릴 수 있는 대규모 양자 컴퓨터를 사용하는 공격자가 수신자에게 콘텐츠 암호화 키를 전달하는 것을 방해할 수 없으며 공격자가 이를 학습할 수 없음을 보여줍니다. 콘텐츠 - 프로토콜 교환의 암호화 키입니다.

---
## **8.  Privacy Considerations**

관찰자는 PSK 키 식별자만 보면 어느 당사자가 각 PSK를 사용하고 있는지 확인할 수 있습니다.  그러나 이러한 키 식별자를 추가한다고 해서 실제로 개인 정보 보호 상황이 약화되는 것은 아닙니다.  키 전송이 사용되는 경우 RecipientIdentifier는 항상 존재하며 관찰자에게 각 수신자를 명확하게 식별합니다.  키 계약이 사용되는 경우 IssuerAndSerialNumber 또는 RecipientKeyIdentifier가 항상 존재하며 이는 각 수신자를 명확하게 식별합니다.

---
## **9.  IANA Considerations**

섹션 6의 ASN.1 모듈에 대한 하나의 객체 식별자가 "S/MIME 모듈 식별자에 대한 SMI 보안\(1.2.840.113549.1.9.16.0\)" 레지스트리 \[IANA\]에 할당되었습니다.

```text
      id-mod-cms-ori-psk-2019 OBJECT IDENTIFIER ::= {
         iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
         pkcs-9(9) smime(16) mod(0) 69 }
```

"S/MIME 메일 보안을 위한 SMI 보안\(1.2.840.113549.1.9.16\)" 레지스트리 \[IANA\]에 새로운 항목이 하나 추가되었습니다.

```text
      id-ori OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
        rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) 13 }
```

"S/MIME 기타 수신자 정보 식별자에 대한 SMI 보안\(1.2.840.113549.1.9.16.13\)"이라는 새 레지스트리가 생성되었습니다.

새 레지스트리에 대한 업데이트는 \[RFC8126\]에 정의된 사양 필수 정책에 따라 수행됩니다.  전문가는 새로운 값이 CMS와 함께 사용할 추가 RecipientInfo 구조를 식별하는지 확인해야 합니다.  다른 목적을 위한 객체 식별자는 이 호에 할당되어서는 안 됩니다.

이 문서를 참조하여 새로운 "S/MIME 기타 수신자 정보 식별자에 대한 SMI 보안\(1.2.840.113549.1.9.16.13\)" 레지스트리\[IANA\]에 두 가지 할당이 이루어졌습니다.

```text
      id-ori-keyTransPSK OBJECT IDENTIFIER ::= {
         iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
         pkcs-9(9) smime(16) id-ori(13) 1 }

      id-ori-keyAgreePSK OBJECT IDENTIFIER ::= {
         iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
         pkcs-9(9) smime(16) id-ori(13) 2 }
```

---
## **10.  References**
---
### **10.1.  Normative References**

```text
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC5083]  Housley, R., "Cryptographic Message Syntax (CMS)
              Authenticated-Enveloped-Data Content Type", RFC 5083,
              DOI 10.17487/RFC5083, November 2007,
              <https://www.rfc-editor.org/info/rfc5083>.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, DOI 10.17487/RFC5652, September 2009,
              <https://www.rfc-editor.org/info/rfc5652>.

   [RFC5912]  Hoffman, P. and J. Schaad, "New ASN.1 Modules for the
              Public Key Infrastructure Using X.509 (PKIX)", RFC 5912,
              DOI 10.17487/RFC5912, June 2010,
              <https://www.rfc-editor.org/info/rfc5912>.

   [RFC6268]  Schaad, J. and S. Turner, "Additional New ASN.1 Modules
              for the Cryptographic Message Syntax (CMS) and the Public
              Key Infrastructure Using X.509 (PKIX)", RFC 6268,
              DOI 10.17487/RFC6268, July 2011,
              <https://www.rfc-editor.org/info/rfc6268>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [X680]     ITU-T, "Information technology -- Abstract Syntax Notation
              One (ASN.1): Specification of basic notation",
              ITU-T Recommendation X.680, August 2015.

   [X690]     ITU-T, "Information technology -- ASN.1 encoding rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ITU-T Recommendation X.690, August 2015.
```

---
### **10.2.  Informative References**

```text
   [AES]      National Institute of Standards and Technology, "Advanced
              Encryption Standard (AES)", DOI 10.6028/NIST.FIPS.197,
              NIST PUB 197, November 2001,
              <https://doi.org/10.6028/NIST.FIPS.197>.

   [C2PQ]     Hoffman, P., "The Transition from Classical to Post-
              Quantum Cryptography", Work in Progress, Internet-Draft,
              draft-hoffman-c2pq-06, 25 November 2019,
              <https://tools.ietf.org/html/draft-hoffman-c2pq-06>.

   [FGHT2016] Fried, J., Gaudry, P., Heninger, N., and E. Thome, "A
              kilobit hidden SNFS discrete logarithm computation",
              Cryptology ePrint Archive Report 2016/961, October 2016,
              <https://eprint.iacr.org/2016/961.pdf>.

   [H2019]    Hammell, J., "Subject: [lamps] WG Last Call for draft-
              ietf-lamps-cms-mix-with-psk"", message to the IETF mailing
              list, May 2019, <https://mailarchive.ietf.org/arch/msg/
              spasm/_6d_4jp3sOprAnbU2fp_yp_-6-k>.

   [IANA]     IANA, "Structure of Management Information (SMI) Numbers
              (MIB Module Registrations)",
              <https://www.iana.org/assignments/smi-numbers>.

   [NAS2019]  National Academies of Sciences, Engineering, and Medicine,
              "Quantum Computing: Progress and Prospects",
              DOI 10.17226/25196, 2019,
              <https://doi.org/10.17226/25196>.

   [NIST2018] Barker, E., Chen, L., and R. Davis, "Recommendation for
              Key-Derivation Methods in Key-Establishment Schemes", NIST
              Special Publication 800-56C Revision 1, April 2018,
              <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/
              NIST.SP.800-56Cr1.pdf>.

   [RFC2631]  Rescorla, E., "Diffie-Hellman Key Agreement Method",
              RFC 2631, DOI 10.17487/RFC2631, June 1999,
              <https://www.rfc-editor.org/info/rfc2631>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <https://www.rfc-editor.org/info/rfc4086>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/info/rfc5280>.

   [RFC5753]  Turner, S. and D. Brown, "Use of Elliptic Curve
              Cryptography (ECC) Algorithms in Cryptographic Message
              Syntax (CMS)", RFC 5753, DOI 10.17487/RFC5753, January
              2010, <https://www.rfc-editor.org/info/rfc5753>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/info/rfc5869>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8619]  Housley, R., "Algorithm Identifiers for the HMAC-based
              Extract-and-Expand Key Derivation Function (HKDF)",
              RFC 8619, DOI 10.17487/RFC8619, June 2019,
              <https://www.rfc-editor.org/info/rfc8619>.

   [S1994]    Shor, P., "Algorithms for Quantum Computation: Discrete
              Logarithms and Factoring", Proceedings of the 35th Annual
              Symposium on Foundations of Computer Science, pp.
              124-134", November 1994.
```

---
# **Appendix A.  Key Transport with PSK Example**

이 예에서는 다음을 사용하여 AES-256 콘텐츠 암호화 키를 설정하는 방법을 보여줍니다.

\* 256비트의 사전 공유 키;

\* 3072비트 키와 RSA PKCS#1 v1.5를 사용한 키 전송;

\* SHA-384와 함께 HKDF를 사용하여 키 파생; 그리고

```text
   *  key wrap using AES-256-KEYWRAP.
```

실제 사용에서 발신자는 자신의 RSA 공개 키와 수신자의 공개 키로 키 파생 키를 암호화합니다.  이는 예제를 단순화하기 위해 생략되었습니다.

---
### **A.1.  Originator Processing Example**

Alice와 Bob에게 알려진 사전 공유 키\(16진수\)는 다음과 같습니다.

```text
      c244cdd11a0d1f39d9b61282770244fb0f6befb91ab7f96cb05213365cf95b15
```

사전 공유 키에 할당된 식별자는 다음과 같습니다.

```text
      ptf-kmc:13614122112

   Alice obtains Bob's public key:

      -----BEGIN PUBLIC KEY-----
      MIIBojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEA3ocW14cxncPJ47fnEjBZ
      AyfC2lqapL3ET4jvV6C7gGeVrRQxWPDwl+cFYBBR2ej3j3/0ecDmu+XuVi2+s5JH
      Keeza+itfuhsz3yifgeEpeK8T+SusHhn20/NBLhYKbh3kiAcCgQ56dpDrDvDcLqq
      vS3jg/VO+OPnZbofoHOOevt8Q/roahJe1PlIyQ4udWB8zZezJ4mLLfbOA9YVaYXx
      2AHHZJevo3nmRnlgJXo6mE00E/6qkhjDHKSMdl2WG6mO9TCDZc9qY3cAJDU6Ir0v
      SH7qUl8/vN13y4UOFkn8hM4kmZ6bJqbZt5NbjHtY4uQ0VMW3RyESzhrO02mrp39a
      uLNnH3EXdXaV1tk75H3qC7zJaeGWMJyQfOE3YfEGRKn8fxubji716D8UecAxAzFy
      FL6m1JiOyV5acAiOpxN14qRYZdHnXOM9DqGIGpoeY1UuD4Mo05osOqOUpBJHA9fS
      whSZG7VNf+vgNWTLNYSYLI04KiMdulnvU6ds+QPz+KKtAgMBAAE=
      -----END PUBLIC KEY-----
```

Bob의 RSA 공개 키에는 다음과 같은 키 식별자가 있습니다.

```text
      9eeb67c9b95a74d44d2f16396680e801b5cba49c
```

Alice는 콘텐츠 암호화 키를 무작위로 생성합니다.

```text
      c8adc30f4a3e20ac420caa76a68f5787c02ab42afea20d19672fd963a5338e83
```

Alice는 키 파생 키를 무작위로 생성합니다.

```text
      df85af9e3cebffde6e9b9d24263db31114d0a8e33a0d50e05eb64578ccde81eb
```

Alice는 Bob의 공개 키에 있는 키 파생 키를 암호화합니다.

```text
      52693f12140c91dea2b44c0b7936f6be46de8a7bfab072bcb6ecfd56b06a9f65
      1bd4669d336aef7b449e5cd9b151893b7c7a3b8e364394840b0a5434cbf10e1b
      5670aefd074faf380665d204fb95153543346f36c2125dba6f4d23d2bc61434b
      5e36ff72b3eafe57c6cf7f74924c309f174b0b8753554b58ed33a8848d707a98
      c0c2b1ddcfd09e31fe213ca0a48dd157bd7d842e85cc76f77710d58efeaa0525
      c651bcd1410fb47534ecabaf5ab7daabed809d4b97220caf6d4929c5fb684f7b
      b8692e6e70332ff9b3f7c11d6cac51d4a35593173d48f80ca843b89789d625e7
      997ad7d674d25a2a7d165a5f39b3cb6358e937bdb02ac8a524ac93113cedd9ad
      c68263025c0bb0997d716e58d4d7b69739bf591f3e71c7678dc0df96f3df9e8a
      a5738f4f9ce21489f300e040891b20b2ab6d9051b3c2e68efa2fa9799a706878
      d5f462018c021d6669ed649f9acdf78476810198bfb8bd41ffedc585eafa957e
      ea1d3625e4bed376e7ae49718aee2f575c401a26a29941d8da5b7ee9aca36471
```

Alice는 SHA-384를 사용하여 HKDF로 256비트 키 암호화 키를 생성합니다. 비밀 값은 키 파생 키입니다. 'info'는 다음 값을 갖는 DER로 인코딩된 CMSORIforPSKOtherInfo 구조입니다.

```text
    0   56: SEQUENCE {
    2   32:   OCTET STRING
          :     C2 44 CD D1 1A 0D 1F 39 D9 B6 12 82 77 02 44 FB
          :     0F 6B EF B9 1A B7 F9 6C B0 52 13 36 5C F9 5B 15
   36    1:   ENUMERATED 5
   39   11:   SEQUENCE {
   41    9:     OBJECT IDENTIFIER aes256-wrap (2 16 840 1 101 3 4 1 45)
          :     }
   52    1:   INTEGER 32
   55    1:   INTEGER 32
          :   }
```

CMSORIforPSKotherInfo의 DER 인코딩은 58옥텟을 생성합니다.

```text
      30380420c244cdd11a0d1f39d9b61282770244fb0f6befb91ab7f96cb0521336
      5cf95b150a0105300b060960864801650304012d020120020120
```

HKDF 출력은 256비트입니다.

```text
     f319e9cebb35f1c6a7a9709b8760b9d0d3e30e16c5b2b69347e9f00ca540a232
```

Alice는 AES-KEY-WRAP을 사용하여 키 암호화 키로 256비트 콘텐츠 암호화 키를 암호화합니다.

```text
      ea0947250fa66cd525595e52a69aaade88efcf1b0f108abe291060391b1cdf59
      07f36b4067e45342
```

Alice는 콘텐츠 암호화 키와 함께 AES-256-GCM을 사용하여 콘텐츠를 암호화합니다.  사용된 12옥텟 nonce는 다음과 같습니다.

```text
      cafebabefacedbaddecaf888
```

콘텐츠 일반 텍스트는 다음과 같습니다.

```text
      48656c6c6f2c20776f726c6421
```

결과 암호문은 다음과 같습니다.

```text
      9af2d16f21547fcefed9b3ef2d
```

결과 12옥텟 인증 태그는 다음과 같습니다.

```text
      a0e5925cc184e0172463c44c
```

---
### **A.2.  ContentInfo and AuthEnvelopedData**

Alice는 AuthEnvelopedData와 ContentInfo를 인코딩하고 결과를 Bob에게 보냅니다.  결과 구조는 다음과 같습니다.

```text
        0  650: SEQUENCE {
        4   11:  OBJECT IDENTIFIER
              :   authEnvelopedData (1 2 840 113549 1 9 16 1 23)
       17  633:  [0] {
       21  629:   SEQUENCE {
       25    1:    INTEGER 0
       28  551:    SET {
       32  547:     [4] {
       36   11:      OBJECT IDENTIFIER
              :       keyTransPSK (1 2 840 113549 1 9 16 13 1)
       49  530:      SEQUENCE {
       53    1:       INTEGER 0
       56   19:       OCTET STRING 'ptf-kmc:13614122112'
       77   13:       SEQUENCE {
       79   11:        OBJECT IDENTIFIER
              :         hkdf-with-sha384 (1 2 840 113549 1 9 16 3 29)
              :         }
       92   11:       SEQUENCE {
       94    9:        OBJECT IDENTIFIER
              :         aes256-wrap (2 16 840 1 101 3 4 1 45)
              :         }
      105  432:       SEQUENCE {
      109  428:        SEQUENCE {
      113    1:         INTEGER 2
      116   20:         [0]
              :          9E EB 67 C9 B9 5A 74 D4 4D 2F 16 39 66 80 E8 01
              :          B5 CB A4 9C
      138   13:         SEQUENCE {
      140    9:          OBJECT IDENTIFIER
              :           rsaEncryption (1 2 840 113549 1 1 1)
      151    0:          NULL
              :          }
      153  384:         OCTET STRING
              :          52 69 3F 12 14 0C 91 DE A2 B4 4C 0B 79 36 F6 BE
              :          46 DE 8A 7B FA B0 72 BC B6 EC FD 56 B0 6A 9F 65
              :          1B D4 66 9D 33 6A EF 7B 44 9E 5C D9 B1 51 89 3B
              :          7C 7A 3B 8E 36 43 94 84 0B 0A 54 34 CB F1 0E 1B
              :          56 70 AE FD 07 4F AF 38 06 65 D2 04 FB 95 15 35
              :          43 34 6F 36 C2 12 5D BA 6F 4D 23 D2 BC 61 43 4B
              :          5E 36 FF 72 B3 EA FE 57 C6 CF 7F 74 92 4C 30 9F
              :          17 4B 0B 87 53 55 4B 58 ED 33 A8 84 8D 70 7A 98
              :          C0 C2 B1 DD CF D0 9E 31 FE 21 3C A0 A4 8D D1 57
              :          BD 7D 84 2E 85 CC 76 F7 77 10 D5 8E FE AA 05 25
              :          C6 51 BC D1 41 0F B4 75 34 EC AB AF 5A B7 DA AB
              :          ED 80 9D 4B 97 22 0C AF 6D 49 29 C5 FB 68 4F 7B
              :          B8 69 2E 6E 70 33 2F F9 B3 F7 C1 1D 6C AC 51 D4
              :          A3 55 93 17 3D 48 F8 0C A8 43 B8 97 89 D6 25 E7
              :          99 7A D7 D6 74 D2 5A 2A 7D 16 5A 5F 39 B3 CB 63
              :          58 E9 37 BD B0 2A C8 A5 24 AC 93 11 3C ED D9 AD
              :          C6 82 63 02 5C 0B B0 99 7D 71 6E 58 D4 D7 B6 97
              :          39 BF 59 1F 3E 71 C7 67 8D C0 DF 96 F3 DF 9E 8A
              :          A5 73 8F 4F 9C E2 14 89 F3 00 E0 40 89 1B 20 B2
              :          AB 6D 90 51 B3 C2 E6 8E FA 2F A9 79 9A 70 68 78
              :          D5 F4 62 01 8C 02 1D 66 69 ED 64 9F 9A CD F7 84
              :          76 81 01 98 BF B8 BD 41 FF ED C5 85 EA FA 95 7E
              :          EA 1D 36 25 E4 BE D3 76 E7 AE 49 71 8A EE 2F 57
              :          5C 40 1A 26 A2 99 41 D8 DA 5B 7E E9 AC A3 64 71
              :          }
              :         }
      541   40:       OCTET STRING
              :        EA 09 47 25 0F A6 6C D5 25 59 5E 52 A6 9A AA DE
              :        88 EF CF 1B 0F 10 8A BE 29 10 60 39 1B 1C DF 59
              :        07 F3 6B 40 67 E4 53 42
              :        }
              :       }
              :      }
      583   55:    SEQUENCE {
      585    9:     OBJECT IDENTIFIER data (1 2 840 113549 1 7 1)
      596   27:     SEQUENCE {
      598    9:      OBJECT IDENTIFIER
              :       aes256-GCM (2 16 840 1 101 3 4 1 46)
      609   14:      SEQUENCE {
      611   12:       OCTET STRING
              :        CA FE BA BE FA CE DB AD DE CA F8 88
              :        }
              :       }
      625   13:     [0]
              :      9A F2 D1 6F 21 54 7F CE FE D9 B3 EF 2D
              :      }
      640   12:    OCTET STRING A0 E5 92 5C C1 84 E0 17 24 63 C4 4C
              :    }
              :   }
              :  }
```

---
### **A.3.  Recipient Processing Example**

```text
   Bob's private key is:

      -----BEGIN RSA PRIVATE KEY-----
      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
      -----END RSA PRIVATE KEY-----
```

Bob은 RSA 개인 키를 사용하여 키 파생 키를 해독합니다.

```text
      df85af9e3cebffde6e9b9d24263db31114d0a8e33a0d50e05eb64578ccde81eb
```

Bob은 SHA-384를 사용하여 HKDF로 256비트 키 암호화 키를 생성합니다. 비밀 값은 키 파생 키입니다. 'info'는 부록 A.1에 표시된 것과 동일한 값을 가진 DER로 인코딩된 CMSORIforPSKOtherInfo 구조입니다.  HKDF 출력은 256비트입니다.

```text
      f319e9cebb35f1c6a7a9709b8760b9d0d3e30e16c5b2b69347e9f00ca540a232
```

Bob은 AES-KEY-WRAP을 사용하여 키 암호화 키로 콘텐츠 암호화 키를 해독합니다. 콘텐츠 암호화 키는 다음과 같습니다.

```text
      c8adc30f4a3e20ac420caa76a68f5787c02ab42afea20d19672fd963a5338e83
```

Bob은 콘텐츠 암호화 키와 함께 AES-256-GCM을 사용하여 콘텐츠를 해독하고 수신된 인증 태그를 확인합니다.  사용된 12옥텟 nonce는 다음과 같습니다.

```text
      cafebabefacedbaddecaf888
```

12옥텟 인증 태그는 다음과 같습니다.

```text
      a0e5925cc184e0172463c44c
```

수신된 암호문 내용은 다음과 같습니다.

```text
      9af2d16f21547fcefed9b3ef2d
```

결과 일반 텍스트 콘텐츠는 다음과 같습니다.

```text
      48656c6c6f2c20776f726c6421
```

---
# **Appendix B.  Key Agreement with PSK Example**

이 예에서는 다음을 사용하여 AES-256 콘텐츠 암호화 키를 설정하는 방법을 보여줍니다.

\* 256비트의 사전 공유 키;

\* SHA-384와 함께 곡선 P-384 및 X9.63 KDF에서 ECDH를 사용하는 주요 합의;

\* SHA-384와 함께 HKDF를 사용하여 키 파생; 그리고

```text
   *  key wrap using AES-256-KEYWRAP.
```

실제 사용에서 발신자는 자신의 정적 공개 키와 이 메시지에 대해 생성된 임시 개인 키를 사용하여 키 계약을 수행하여 자신을 추가 수신자로 처리합니다.  이는 예제를 단순화하기 위해 생략되었습니다.

---
### **B.1.  Originator Processing Example**

Alice와 Bob에게 알려진 사전 공유 키\(16진수\)는 다음과 같습니다.

```text
      4aa53cbf500850dd583a5d9821605c6fa228fb5917f87c1c078660214e2d83e4
```

사전 공유 키에 할당된 식별자는 다음과 같습니다.

```text
      ptf-kmc:216840110121
```

Alice는 콘텐츠 암호화 키를 무작위로 생성합니다.

```text
      937b1219a64d57ad81c05cc86075e86017848c824d4e85800c731c5b7b091033

   Alice obtains Bob's static ECDH public key:

      -----BEGIN PUBLIC KEY-----
      MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEScGPBO9nmUwGrgbGEoFY9HR/bCo0WyeY
      /dePQVrwZmwN2yMJmO2d1kWCvLTz8U7atinxyIRe9CV54yau1KWU/wbkhPDnzuSM
      YkcpxMGo32z3JetEloW5aFOja13vv/W5
      -----END PUBLIC KEY-----
```

다음과 같은 키 식별자가 있습니다.

```text
      e8218b98b8b7d86b5e9ebdc8aeb8c4ecdc05c529
```

Alice는 동일한 곡선에서 임시 ECDH 키 쌍을 생성합니다.

```text
      -----BEGIN EC PRIVATE KEY-----
      MIGkAgEBBDCMiWLG44ik+L8cYVvJrQdLcFA+PwlgRF+Wt1Ab25qUh8OB7OePWjxp
      /b8P6IOuI6GgBwYFK4EEACKhZANiAAQ5G0EmJk/2ks8sXY1kzbuG3Uu3ttWwQRXA
      LFDJICjvYfr+yTpOQVkchm88FAh9MEkw4NKctokKNgpsqXyrT3DtOg76oIYENpPb
      GE5lJdjPx9sBsZQdABwlsU0Zb7P/7i8=
      -----END EC PRIVATE KEY-----
```

Alice는 Bob의 정적 ECDH 공개 키와 임시 ECDH 개인 키를 사용하여 "Z"라는 공유 비밀을 계산합니다. Z는:

```text
      3f015ed0ff4b99523a95157bbe77e9cc0ee52fcffeb7e41eac79d1c11b6cc556
      19cf8807e6d800c2de40240fe0e26adc
```

Alice는 다음 값이 포함된 ECC-CMS-SharedInfo 구조의 X9.63 KDF를 사용하여 Z에서 "KEK1"이라는 쌍별 키 암호화 키를 계산합니다.

```text
    0   21: SEQUENCE {
    2   11:   SEQUENCE {
    4    9:     OBJECT IDENTIFIER aes256-wrap (2 16 840 1 101 3 4 1 45)
          :     }
   15    6:   [2] {
   17    4:     OCTET STRING 00 00 00 20
          :     }
          :   }
```

ECC-CMS-SharedInfo의 DER 인코딩은 23옥텟을 생성합니다.

```text
      3015300b060960864801650304012da206040400000020
```

X9.63 KDF 출력은 256비트 KEK1입니다.

```text
      27dc25ddb0b425f7a968ceada80a8f73c6ccaab115baafcce4a22a45d6b8f3da
```

Alice는 SHA-384를 사용하여 HKDF로 256비트 KEK2를 생성합니다. 비밀 값은 KEK1입니다. 'info'는 다음 값을 갖는 DER로 인코딩된 CMSORIforPSKOtherInfo 구조입니다.

```text
    0   56: SEQUENCE {
    2   32:   OCTET STRING
          :     4A A5 3C BF 50 08 50 DD 58 3A 5D 98 21 60 5C 6F
          :     A2 28 FB 59 17 F8 7C 1C 07 86 60 21 4E 2D 83 E4
   36    1:   ENUMERATED 10
   39   11:   SEQUENCE {
   41    9:     OBJECT IDENTIFIER aes256-wrap (2 16 840 1 101 3 4 1 45)
          :      }
   52    1:   INTEGER 32
   55    1:   INTEGER 32
          :   }
```

CMSORIforPSKotherInfo의 DER 인코딩은 58옥텟을 생성합니다.

```text
      303804204aa53cbf500850dd583a5d9821605c6fa228fb5917f87c1c07866021
      4e2d83e40a010a300b060960864801650304012d020120020120
```

HKDF 출력은 256비트 KEK2입니다.

```text
      7de693ee30ae22b5f8f6cd026c2164103f4e1430f1ab135dc1fb98954f9830bb
```

Alice는 AES-KEY-WRAP을 사용하여 KEK2로 콘텐츠 암호화 키를 암호화합니다. 래핑된 키는 다음과 같습니다.

```text
      229fe0b45e40003e7d8244ec1b7e7ffb2c8dca16c36f5737222553a71263a92b
      de08866a602d63f4
```

Alice는 콘텐츠 암호화 키와 함께 AES-256-GCM을 사용하여 콘텐츠를 암호화합니다.  사용된 12옥텟 nonce는 다음과 같습니다.

```text
      dbaddecaf888cafebabeface
```

일반 텍스트는 다음과 같습니다

```text
      48656c6c6f2c20776f726c6421
```

결과 암호문은 다음과 같습니다.

```text
      fc6d6f823e3ed2d209d0c6ffcf
```

결과 12옥텟 인증 태그는 다음과 같습니다.

```text
      550260c42e5b29719426c1ff
```

---
### **B.2.  ContentInfo and AuthEnvelopedData**

Alice는 AuthEnvelopedData와 ContentInfo를 인코딩하고 결과를 Bob에게 보냅니다.  결과 구조는 다음과 같습니다.

```text
        0  327: SEQUENCE {
        4   11:  OBJECT IDENTIFIER
              :   authEnvelopedData (1 2 840 113549 1 9 16 1 23)
       17  310:  [0] {
       21  306:   SEQUENCE {
       25    1:    INTEGER 0
       28  229:    SET {
       31  226:     [4] {
       34   11:      OBJECT IDENTIFIER
              :       keyAgreePSK (1 2 840 113549 1 9 16 13 2)
       47  210:      SEQUENCE {
       50    1:       INTEGER 0
       53   20:       OCTET STRING 'ptf-kmc:216840110121'
       75   85:       [0] {
       77   83:        [1] {
       79   19:         SEQUENCE {
       81    6:          OBJECT IDENTIFIER
              :           ecdhX963KDF-SHA256 (1 3 132 1 11 1)
       89    9:          OBJECT IDENTIFIER
              :           aes256-wrap (2 16 840 1 101 3 4 1 45)
              :           }
      100   60:         BIT STRING, encapsulates {
      103   57:          OCTET STRING
              :          1B 41 26 26 4F F6 92 CF 2C 5D 8D 64 CD BB 86 DD
              :          4B B7 B6 D5 B0 41 15 C0 2C 50 C9 20 28 EF 61 FA
              :          FE C9 3A 4E 41 59 1C 86 6F 3C 14 08 7D 30 49 30
              :          E0 D2 9C B6 89 0A 36 0A 6C
              :          }
              :         }
              :        }
      162   13:       SEQUENCE {
      164   11:        OBJECT IDENTIFIER
              :         hkdf-with-sha384 (1 2 840 113549 1 9 16 3 29)
              :         }
      177   11:       SEQUENCE {
      179    9:        OBJECT IDENTIFIER
              :         aes256-wrap (2 16 840 1 101 3 4 1 45)
              :         }
      190   68:       SEQUENCE {
      192   66:        SEQUENCE {
      194   22:         [0] {
      196   20:          OCTET STRING
              :          E8 21 8B 98 B8 B7 D8 6B 5E 9E BD C8 AE B8 C4 EC
              :          DC 05 C5 29
              :          }
      218   40:         OCTET STRING
              :         22 9F E0 B4 5E 40 00 3E 7D 82 44 EC 1B 7E 7F FB
              :         2C 8D CA 16 C3 6F 57 37 22 25 53 A7 12 63 A9 2B
              :         DE 08 86 6A 60 2D 63 F4
              :         }
              :        }
              :       }
              :      }
              :     }
      260   55:    SEQUENCE {
      262    9:     OBJECT IDENTIFIER data (1 2 840 113549 1 7 1)
      273   27:     SEQUENCE {
      275    9:      OBJECT IDENTIFIER
              :       aes256-GCM (2 16 840 1 101 3 4 1 46)
      286   14:      SEQUENCE {
      288   12:       OCTET STRING
              :        DB AD DE CA F8 88 CA FE BA BE FA CE
              :        }
              :       }
      302   13:     [0]
              :      FC 6D 6F 82 3E 3E D2 D2 09 D0 C6 FF CF
              :      }
      317   12:    OCTET STRING 55 02 60 C4 2E 5B 29 71 94 26 C1 FF
              :     }
              :    }
              :   }
```

---
### **B.3.  Recipient Processing Example**

Bob은 메시지에서 Alice의 임시 ECDH 공개 키를 얻습니다.

```text
      -----BEGIN PUBLIC KEY-----
      MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEORtBJiZP9pLPLF2NZM27ht1Lt7bVsEEV
      wCxQySAo72H6/sk6TkFZHIZvPBQIfTBJMODSnLaJCjYKbKl8q09w7ToO+qCGBDaT
      2xhOZSXYz8fbAbGUHQAcJbFNGW+z/+4v
      -----END PUBLIC KEY-----

   Bob's static ECDH private key is:

      -----BEGIN EC PRIVATE KEY-----
      MIGkAgEBBDAnJ4hB+tTUN9X03/W0RsrYy+qcptlRSYkhaDIsQYPXfTU0ugjJEmRk
      NTPj4y1IRjegBwYFK4EEACKhZANiAARJwY8E72eZTAauBsYSgVj0dH9sKjRbJ5j9
      149BWvBmbA3bIwmY7Z3WRYK8tPPxTtq2KfHIhF70JXnjJq7UpZT/BuSE8OfO5Ixi
      RynEwajfbPcl60SWhbloU6NrXe+/9bk=
      -----END EC PRIVATE KEY-----
```

Bob은 Alice의 임시 ECDH 공개 키와 정적 ECDH 개인 키를 사용하여 "Z"라는 공유 비밀을 계산합니다. Z는:

```text
      3f015ed0ff4b99523a95157bbe77e9cc0ee52fcffeb7e41eac79d1c11b6cc556
      19cf8807e6d800c2de40240fe0e26adc
```

Bob은 부록 B.1에 표시된 값이 있는 ECC-CMS-SharedInfo 구조와 함께 X9.63 KDF를 사용하여 Z에서 쌍별 키 암호화 키 KEK1을 계산합니다.  X9.63 KDF 출력은 256비트 KEK1입니다.

```text
      27dc25ddb0b425f7a968ceada80a8f73c6ccaab115baafcce4a22a45d6b8f3da
```

Bob은 SHA-384를 사용하여 HKDF로 256비트 KEK2를 생성합니다. 비밀 값은 KEK1입니다. 'info'는 부록 B.1에 표시된 값을 가진 DER로 인코딩된 CMSORIforPSKOtherInfo 구조입니다.  HKDF 출력은 256비트 KEK2입니다.

```text
      7de693ee30ae22b5f8f6cd026c2164103f4e1430f1ab135dc1fb98954f9830bb
```

Bob은 AES-KEY-WRAP을 사용하여 KEK2로 콘텐츠 암호화 키를 해독합니다. 콘텐츠 암호화 키는 다음과 같습니다.

```text
      937b1219a64d57ad81c05cc86075e86017848c824d4e85800c731c5b7b091033
```

Bob은 콘텐츠 암호화 키와 함께 AES-256-GCM을 사용하여 콘텐츠를 해독하고 수신된 인증 태그를 확인합니다.  사용된 12옥텟 nonce는 다음과 같습니다.

```text
      dbaddecaf888cafebabeface
```

12옥텟 인증 태그는 다음과 같습니다.

```text
      550260c42e5b29719426c1ff
```

수신된 암호문 내용은 다음과 같습니다.

```text
      fc6d6f823e3ed2d209d0c6ffcf
```

결과 일반 텍스트 콘텐츠는 다음과 같습니다.

```text
      48656c6c6f2c20776f726c6421
```

---
# **Acknowledgements**

검토와 통찰력 있는 의견을 주신 Roman Danyliw, Ben Kaduk, Burt Kaliski, Panos Kampanakis, Jim Schaad, Robert Sparks, Sean Turner 및 Daniel Van Geest에게 많은 감사를 드립니다.  디자인, 명확성 및 구현 지침이 크게 향상되었습니다.

---
# **Author's Address**

Russ Housley Vigil Security, LLC 516 Dranesville Road Herndon, VA 20170 미국

```text
   Email: housley@vigilsec.com
```
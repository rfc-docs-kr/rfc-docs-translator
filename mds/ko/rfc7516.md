

```text
Internet Engineering Task Force (IETF)                          M. Jones
Request for Comments: 7516                                     Microsoft
Category: Standards Track                                  J. Hildebrand
ISSN: 2070-1721                                                    Cisco
                                                                May 2015

                       JSON Web Encryption (JWE)
```

---
# **Abstract**

JSON 웹 암호화\(JWE\)는 JSON 기반 데이터 구조를 사용하여 암호화된 콘텐츠를 나타냅니다. 이 사양과 함께 사용할 암호화 알고리즘 및 식별자는 별도의 JSON 웹 알고리즘\(JWA\) 사양 및 해당 사양에서 정의한 IANA 레지스트리에 설명되어 있습니다. 관련 디지털 서명 및 메시지 인증 코드\(MAC\) 기능은 별도의 JSON 웹 서명\(JWS\) 사양에 설명되어 있습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 사항 및 이에 대한 피드백을 제공하는 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7516에서 확인할 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2015 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Notational Conventions  . . . . . . . . . . . . . . . . .   4
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   5
   3.  JSON Web Encryption (JWE) Overview  . . . . . . . . . . . . .   8
     3.1.  JWE Compact Serialization Overview  . . . . . . . . . . .   8
     3.2.  JWE JSON Serialization Overview . . . . . . . . . . . . .   9
     3.3.  Example JWE . . . . . . . . . . . . . . . . . . . . . . .  10
   4.  JOSE Header . . . . . . . . . . . . . . . . . . . . . . . . .  11
     4.1.  Registered Header Parameter Names . . . . . . . . . . . .  11
       4.1.1.  "alg" (Algorithm) Header Parameter  . . . . . . . . .  12
       4.1.2.  "enc" (Encryption Algorithm) Header Parameter . . . .  12
       4.1.3.  "zip" (Compression Algorithm) Header Parameter  . . .  12
       4.1.4.  "jku" (JWK Set URL) Header Parameter  . . . . . . . .  13
       4.1.5.  "jwk" (JSON Web Key) Header Parameter . . . . . . . .  13
       4.1.6.  "kid" (Key ID) Header Parameter . . . . . . . . . . .  13
       4.1.7.  "x5u" (X.509 URL) Header Parameter  . . . . . . . . .  13
       4.1.8.  "x5c" (X.509 Certificate Chain) Header Parameter  . .  13
       4.1.9.  "x5t" (X.509 Certificate SHA-1 Thumbprint) Header
               Parameter . . . . . . . . . . . . . . . . . . . . . .  14
       4.1.10. "x5t#S256" (X.509 Certificate SHA-256 Thumbprint)
               Header Parameter  . . . . . . . . . . . . . . . . . .  14
       4.1.11. "typ" (Type) Header Parameter . . . . . . . . . . . .  14
       4.1.12. "cty" (Content Type) Header Parameter . . . . . . . .  14
       4.1.13. "crit" (Critical) Header Parameter  . . . . . . . . .  14
     4.2.  Public Header Parameter Names . . . . . . . . . . . . . .  14
     4.3.  Private Header Parameter Names  . . . . . . . . . . . . .  15
   5.  Producing and Consuming JWEs  . . . . . . . . . . . . . . . .  15
     5.1.  Message Encryption  . . . . . . . . . . . . . . . . . . .  15
     5.2.  Message Decryption  . . . . . . . . . . . . . . . . . . .  17
     5.3.  String Comparison Rules . . . . . . . . . . . . . . . . .  20
   6.  Key Identification  . . . . . . . . . . . . . . . . . . . . .  20
   7.  Serializations  . . . . . . . . . . . . . . . . . . . . . . .  20
     7.1.  JWE Compact Serialization . . . . . . . . . . . . . . . .  20
     7.2.  JWE JSON Serialization  . . . . . . . . . . . . . . . . .  20
       7.2.1.  General JWE JSON Serialization Syntax . . . . . . . .  21
       7.2.2.  Flattened JWE JSON Serialization Syntax . . . . . . .  23
   8.  TLS Requirements  . . . . . . . . . . . . . . . . . . . . . .  24
   9.  Distinguishing between JWS and JWE Objects  . . . . . . . . .  24
   10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  25
     10.1.  JSON Web Signature and Encryption Header Parameters
            Registration . . . . . . . . . . . . . . . . . . . . . .  25
       10.1.1.  Registry Contents  . . . . . . . . . . . . . . . . .  25
   11. Security Considerations . . . . . . . . . . . . . . . . . . .  27
     11.1.  Key Entropy and Random Values  . . . . . . . . . . . . .  27
     11.2.  Key Protection . . . . . . . . . . . . . . . . . . . . .  27
     11.3.  Using Matching Algorithm Strengths . . . . . . . . . . .  28
     11.4.  Adaptive Chosen-Ciphertext Attacks . . . . . . . . . . .  28
     11.5.  Timing Attacks . . . . . . . . . . . . . . . . . . . . .  28
   12. References  . . . . . . . . . . . . . . . . . . . . . . . . .  29
     12.1.  Normative References . . . . . . . . . . . . . . . . . .  29
     12.2.  Informative References . . . . . . . . . . . . . . . . .  30
   Appendix A.  JWE Examples . . . . . . . . . . . . . . . . . . . .  32
     A.1.  Example JWE using RSAES-OAEP and AES GCM  . . . . . . . .  32
       A.1.1.  JOSE Header . . . . . . . . . . . . . . . . . . . . .  32
       A.1.2.  Content Encryption Key (CEK)  . . . . . . . . . . . .  32
       A.1.3.  Key Encryption  . . . . . . . . . . . . . . . . . . .  33
       A.1.4.  Initialization Vector . . . . . . . . . . . . . . . .  34
       A.1.5.  Additional Authenticated Data . . . . . . . . . . . .  35
       A.1.6.  Content Encryption  . . . . . . . . . . . . . . . . .  35
       A.1.7.  Complete Representation . . . . . . . . . . . . . . .  36
       A.1.8.  Validation  . . . . . . . . . . . . . . . . . . . . .  36
     A.2.  Example JWE using RSAES-PKCS1-v1_5 and
           AES_128_CBC_HMAC_SHA_256  . . . . . . . . . . . . . . . .  36
       A.2.1.  JOSE Header . . . . . . . . . . . . . . . . . . . . .  37
       A.2.2.  Content Encryption Key (CEK)  . . . . . . . . . . . .  37
       A.2.3.  Key Encryption  . . . . . . . . . . . . . . . . . . .  38
       A.2.4.  Initialization Vector . . . . . . . . . . . . . . . .  39
       A.2.5.  Additional Authenticated Data . . . . . . . . . . . .  40
       A.2.6.  Content Encryption  . . . . . . . . . . . . . . . . .  40
       A.2.7.  Complete Representation . . . . . . . . . . . . . . .  40
       A.2.8.  Validation  . . . . . . . . . . . . . . . . . . . . .  41
     A.3.  Example JWE Using AES Key Wrap and
           AES_128_CBC_HMAC_SHA_256  . . . . . . . . . . . . . . . .  41
       A.3.1.  JOSE Header . . . . . . . . . . . . . . . . . . . . .  41
       A.3.2.  Content Encryption Key (CEK)  . . . . . . . . . . . .  42
       A.3.3.  Key Encryption  . . . . . . . . . . . . . . . . . . .  42
       A.3.4.  Initialization Vector . . . . . . . . . . . . . . . .  42
       A.3.5.  Additional Authenticated Data . . . . . . . . . . . .  43
       A.3.6.  Content Encryption  . . . . . . . . . . . . . . . . .  43
       A.3.7.  Complete Representation . . . . . . . . . . . . . . .  43
       A.3.8.  Validation  . . . . . . . . . . . . . . . . . . . . .  44
     A.4.  Example JWE Using General JWE JSON Serialization  . . . .  44
       A.4.1.  JWE Per-Recipient Unprotected Headers . . . . . . . .  45
       A.4.2.  JWE Protected Header  . . . . . . . . . . . . . . . .  45
       A.4.3.  JWE Shared Unprotected Header . . . . . . . . . . . .  45
       A.4.4.  Complete JOSE Header Values . . . . . . . . . . . . .  45
       A.4.5.  Additional Authenticated Data . . . . . . . . . . . .  46
       A.4.6.  Content Encryption  . . . . . . . . . . . . . . . . .  46
       A.4.7.  Complete JWE JSON Serialization Representation  . . .  47
     A.5.  Example JWE Using Flattened JWE JSON Serialization  . . .  47
   Appendix B.  Example AES_128_CBC_HMAC_SHA_256 Computation . . . .  48
     B.1.  Extract MAC_KEY and ENC_KEY from Key  . . . . . . . . . .  48
     B.2.  Encrypt Plaintext to Create Ciphertext  . . . . . . . . .  49
     B.3.  64-Bit Big-Endian Representation of AAD Length  . . . . .  49
     B.4.  Initialization Vector Value . . . . . . . . . . . . . . .  49
     B.5.  Create Input to HMAC Computation  . . . . . . . . . . . .  50
     B.6.  Compute HMAC Value  . . . . . . . . . . . . . . . . . . .  50
     B.7.  Truncate HMAC Value to Create Authentication Tag  . . . .  50
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  50
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  51
```

---
## **1.  Introduction**

JSON 웹 암호화\(JWE\)는 JSON 기반 데이터 구조\[RFC7159\]를 사용하여 암호화된 콘텐츠를 나타냅니다. JWE 암호화 메커니즘은 임의의 옥텟 시퀀스를 암호화하고 무결성 보호를 제공합니다.

JWE에 대한 두 가지 밀접하게 관련된 직렬화가 정의됩니다. JWE Compact Serialization은 HTTP Authorization 헤더 및 URI 쿼리 매개변수와 같은 공간 제약이 있는 환경을 위한 컴팩트하고 URL이 안전한 표현입니다. JWE JSON Serialization은 JWE를 JSON 객체로 표현하고 동일한 콘텐츠를 여러 당사자에게 암호화할 수 있도록 합니다. 둘 다 동일한 암호화 기반을 공유합니다.

이 사양과 함께 사용할 암호화 알고리즘 및 식별자는 별도의 JSON 웹 알고리즘\(JWA\) \[JWA\] 사양 및 해당 사양에서 정의한 IANA 레지스트리에 설명되어 있습니다. 관련 디지털 서명 및 MAC 기능은 별도의 JSON 웹 서명\(JWS\) \[JWS\] 사양에 설명되어 있습니다.

이 사양에 정의된 이름은 결과 표현을 간결하게 하는 것이 핵심 목표이기 때문에 짧습니다.

---
### **1.1.  Notational Conventions**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", "OPTIONAL"은 "RFC에서 요구 사항 수준을 나타내는 데 사용되는 핵심 단어"\[RFC2119\]에 설명된 대로 해석해야 합니다. 이 해석은 용어가 모두 대문자로 나타나는 경우에만 적용해야 합니다.

BASE64URL\(OCTETS\)는 \[JWS\]의 섹션 2에 따른 OCTETS의 base64url 인코딩을 나타냅니다.

UTF8\(STRING\)은 STRING의 UTF-8 \[RFC3629\] 표현의 옥텟을 나타냅니다. 여기서 STRING은 0개 이상의 유니코드 \[UNICODE\] 문자 시퀀스입니다.

ASCII\(STRING\)은 STRING의 ASCII \[RFC20\] 표현의 옥텟을 나타냅니다. 여기서 STRING은 0개 이상의 ASCII 문자 시퀀스입니다.

두 값 A와 B의 연결은 A || B로 표시합니다.

---
## **2.  Terminology**

"JSON 웹 서명\(JWS\)", "Base64url 인코딩", "충돌 방지 이름", "헤더 매개변수", "JOSE 헤더" 및 "StringOrURI"라는 용어는 JWS 사양\[JWS\]에 정의되어 있습니다.

"암호문", "디지털 서명", "초기화 벡터\(IV\)", "메시지 인증 코드\(MAC\)" 및 "평문"이라는 용어는 "인터넷 보안 용어집, 버전 2"\[RFC4949\]에 정의되어 있습니다.

이러한 용어는 이 사양에 의해 정의됩니다.

JSON 웹 암호화\(JWE\) - 암호화되고 무결성이 보호된 메시지를 나타내는 데이터 구조입니다.

연관 데이터가 있는 인증된 암호화\(AEAD\) - AEAD 알고리즘은 평문을 암호화하고, 추가 인증된 데이터를 지정할 수 있게 하며, 암호문과 추가 인증된 데이터에 대한 통합된 콘텐츠 무결성 검사를 제공합니다. AEAD 알고리즘은 평문과 추가 인증된 데이터 값의 두 가지 입력을 허용하고 암호문과 인증 태그 값의 두 가지 출력을 생성합니다. AES Galois/Counter Mode\(GCM\)는 그러한 알고리즘 중 하나입니다.

추가 인증 데이터\(AAD\) - 무결성 보호되지만 암호화되지 않은 AEAD 작업에 대한 입력입니다.

인증 태그 - 암호문과 추가 인증 데이터의 무결성을 보장하는 AEAD 작업의 출력입니다. 일부 알고리즘은 인증 태그를 사용하지 않을 수 있으며, 이 경우 이 값은 빈 옥텟 시퀀스입니다.

콘텐츠 암호화 키\(CEK\) - 암호문과 인증 태그를 생성하기 위해 평문을 암호화하는 데 사용되는 AEAD 알고리즘을 위한 대칭 키입니다.

JWE 암호화 키 - 암호화된 콘텐츠 암호화 키 값. 일부 알고리즘의 경우 JWE 암호화 키 값은 빈 옥텟 시퀀스로 지정됩니다.

JWE 초기화 벡터 - 평문을 암호화할 때 사용되는 초기화 벡터 값입니다. 일부 알고리즘은 초기화 벡터를 사용하지 않을 수 있으며, 이 경우 이 값은 빈 옥텟 시퀀스입니다.

JWE AAD - 인증된 암호화 작업으로 무결성이 보호되는 추가 값입니다. 이는 JWE JSON 직렬화를 사용할 때만 존재할 수 있습니다. \(JWE Compact Serialization 또는 JWE JSON 직렬화를 사용할 때도 AAD 값을 무결성 보호 헤더 매개변수 값으로 포함하여 이를 달성할 수 있지만, 값이 이중 base64url로 인코딩된다는 단점이 있습니다.\)

JWE 암호문 - 추가 인증 데이터를 사용하여 평문의 인증된 암호화 결과 생성된 암호문 값입니다.

JWE 인증 태그 - 추가 인증 데이터를 사용하여 평문의 인증된 암호화로부터 생성되는 인증 태그 값입니다.

JWE 보호 헤더 - 인증된 암호화 작업으로 무결성이 보호되는 헤더 매개변수를 포함하는 JSON 객체입니다. 이러한 매개변수는 JWE의 모든 수신자에게 적용됩니다. JWE Compact Serialization의 경우, 이는 전체 JOSE 헤더를 구성합니다. JWE JSON Serialization의 경우, 이는 JOSE 헤더의 한 구성 요소입니다.

JWE 공유 비보호 헤더 - 무결성 보호되지 않은 JWE의 모든 수신자에게 적용되는 헤더 매개변수를 포함하는 JSON 객체입니다. 이는 JWE JSON 직렬화를 사용할 때만 존재할 수 있습니다.

JWE Per-Recipient Unprotected Header - JWE의 단일 수신자에게 적용되는 Header Parameters를 포함하는 JSON 객체입니다. 이러한 Header Parameter 값은 무결성 보호되지 않습니다. 이는 JWE JSON Serialization을 사용할 때만 존재할 수 있습니다.

JWE 컴팩트 직렬화 - JWE를 컴팩트하고 URL에 안전한 문자열로 표현한 것입니다.

JWE JSON 직렬화 - JWE를 JSON 객체로 표현한 것입니다. JWE JSON 직렬화를 사용하면 동일한 콘텐츠를 여러 당사자에게 암호화할 수 있습니다. 이 표현은 압축성이나 URL 안전성에 최적화되지 않았습니다.

키 관리 모드 - 사용할 콘텐츠 암호화 키 값을 결정하는 방법입니다. CEK 값을 결정하는 데 사용되는 각 알고리즘은 특정 키 관리 모드를 사용합니다. 이 사양에서 사용하는 키 관리 모드는 키 암호화, 키 래핑, 직접 키 계약, 키 래핑이 있는 키 계약 및 직접 암호화입니다.

키 암호화 - CEK 값이 비대칭 암호화 알고리즘을 사용하여 의도된 수신자에게 암호화되는 키 관리 모드입니다.

키 래핑 - 대칭 키 래핑 알고리즘을 사용하여 CEK 값을 의도된 수신자에게 암호화하는 키 관리 모드입니다.

직접 키 합의 - 키 합의 알고리즘을 사용하여 CEK 값에 동의하는 키 관리 모드입니다.

키 래핑을 통한 키 계약 - 키 계약 알고리즘을 사용하여 대칭 키 래핑 알고리즘을 통해 의도된 수신자에게 CEK 값을 암호화하는 데 사용되는 대칭 키를 합의하는 키 관리 모드입니다.

직접 암호화 - 당사자 간에 공유되는 비밀 대칭 키 값인 CEK 값을 사용하는 키 관리 모드입니다.

---
## **3.  JSON Web Encryption (JWE) Overview**

JWE는 JSON 데이터 구조와 base64url 인코딩을 사용하여 암호화된 콘텐츠를 나타냅니다. 이러한 JSON 데이터 구조는 RFC 7159 \[RFC7159\]의 섹션 2에 따라 JSON 값이나 구조적 문자 앞이나 뒤에 공백 및/또는 줄 바꿈을 포함할 수 있습니다. JWE는 다음과 같은 논리 값을 나타냅니다\(각각은 섹션 2에서 정의됨\):

```text
   o  JOSE Header
   o  JWE Encrypted Key
   o  JWE Initialization Vector
   o  JWE AAD
   o  JWE Ciphertext
   o  JWE Authentication Tag
```

JWE의 경우 JOSE 헤더 멤버는 다음 값의 멤버의 합집합입니다\(각각은 섹션 2에서 정의됨\):

```text
   o  JWE Protected Header
   o  JWE Shared Unprotected Header
   o  JWE Per-Recipient Unprotected Header
```

JWE는 인증된 암호화를 활용해 평문의 기밀성과 무결성, 그리고 JWE 보호 헤더와 JWE AAD의 무결성을 보장합니다.

이 문서에서는 JWE에 대한 두 가지 직렬화를 정의합니다. JWE Compact Serialization이라는 컴팩트하고 URL에 안전한 직렬화와 JWE JSON Serialization이라는 JSON 직렬화입니다. 두 직렬화 모두에서 JWE Protected Header, JWE Encrypted Key, JWE Initialization Vector, JWE Ciphertext, JWE Authentication Tag는 base64url로 인코딩됩니다. JSON은 임의의 옥텟 시퀀스를 직접 표현할 방법이 없기 때문입니다. JWE AAD가 있는 경우, 이 역시 base64url로 인코딩됩니다.

---
### **3.1.  JWE Compact Serialization Overview**

JWE Compact Serialization에서는 JWE Shared Unprotected Header나 JWE Per-Recipient Unprotected Header가 사용되지 않습니다. 이 경우 JOSE Header와 JWE Protected Header는 동일합니다.

JWE Compact Serialization에서 JWE는 다음과 같은 연결로 표현됩니다.

```text
      BASE64URL(UTF8(JWE Protected Header)) || '.' ||
      BASE64URL(JWE Encrypted Key) || '.' ||
      BASE64URL(JWE Initialization Vector) || '.' ||
      BASE64URL(JWE Ciphertext) || '.' ||
      BASE64URL(JWE Authentication Tag)
```

JWE Compact Serialization에 대한 자세한 내용은 섹션 7.1을 참조하세요.

---
### **3.2.  JWE JSON Serialization Overview**

JWE JSON 직렬화에서 JWE 보호 헤더, JWE 공유 비보호 헤더, JWE 수신자별 비보호 헤더 중 하나 이상이 반드시 있어야 합니다. 이 경우 JOSE 헤더의 멤버는 존재하는 JWE 보호 헤더, JWE 공유 비보호 헤더, JWE 수신자별 비보호 헤더 값의 멤버의 합집합입니다.

JWE JSON 직렬화에서 JWE는 다음 8가지 멤버 중 일부 또는 전부를 포함하는 JSON 객체로 표현됩니다.

- "protected", BASE64URL\(UTF8\(JWE 보호 헤더\)\) 값을 갖는 "unprotected", JWE 공유 비보호 헤더 값을 갖는 "header", JWE 수신자별 비보호 헤더 값을 갖는 "encrypted\_key", BASE64URL\(JWE 암호화 키\) 값을 갖는 "iv", BASE64URL\(JWE 초기화 벡터\) 값을 갖는 "ciphertext", BASE64URL\(JWE 암호문\) 값을 갖는 "tag", BASE64URL\(JWE 인증 태그\) 값을 갖는 "aad", BASE64URL\(JWE AAD\) 값을 갖는

6개의 base64url 인코딩된 결과 문자열과 2개의 보호되지 않은 JSON 객체 값은 JSON 객체 내의 멤버로 표현됩니다. 이러한 값 중 일부를 포함하는 것은 선택 사항입니다. JWE JSON 직렬화는 또한 여러 수신자에게 일반 텍스트를 암호화할 수 있습니다. JWE JSON 직렬화에 대한 자세한 내용은 섹션 7.2를 참조하십시오.

---
### **3.3.  Example JWE**

이 예에서는 "지능의 진정한 표시는 지식이 아니라 상상력이다."라는 평문을 수신자에게 암호화합니다.

다음 예제 JWE 보호 헤더는 다음을 선언합니다.

- 콘텐츠 암호화 키는 RSAES-OAEP \[RFC3447\] 알고리즘을 사용하여 수신자에게 암호화되어 JWE 암호화 키를 생성합니다.

- AES GCM \[AES\] \[NIST.800-38D\] 알고리즘을 사용하여 256비트 키를 사용하여 암호문과 인증 태그를 생성하여 평문에 대한 인증 암호화를 수행합니다.

```text
     {"alg":"RSA-OAEP","enc":"A256GCM"}
```

이 JWE 보호 헤더를 BASE64URL\(UTF8\(JWE 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ
```

이 JWE를 만드는 데 남은 단계는 다음과 같습니다.

- 무작위 콘텐츠 암호화 키\(CEK\)를 생성합니다.

- RSAES-OAEP 알고리즘을 사용하여 수신자의 공개 키로 CEK를 암호화하여 JWE 암호화 키를 생성합니다.

- JWE 암호화 키를 Base64url로 인코딩합니다.

- 무작위 JWE 초기화 벡터를 생성합니다.

- JWE 초기화 벡터를 Base64url로 인코딩합니다.

- 추가 인증 데이터 암호화 매개변수를 ASCII\(BASE64URL\(UTF8\(JWE 보호 헤더\)\)\)로 설정합니다.

- 암호화 키로 CEK, JWE 초기화 벡터 및 추가 인증 데이터 값을 사용하여 AES GCM 알고리즘으로 평문에 대한 인증 암호화를 수행하고 128비트 인증 태그 출력을 요청합니다.

- 암호문을 Base64url로 인코딩합니다.

- 인증 태그를 Base64url로 인코딩합니다.

- 최종 표현을 조립합니다. 이 결과의 컴팩트 직렬화는 문자열 BASE64URL\(UTF8\(JWE 보호 헤더\)\) || '.' || BASE64URL\(JWE 암호화 키\) || '.' || BASE64URL\(JWE 초기화 벡터\) || '.' || BASE64URL\(JWE 암호문\) || '.' || BASE64URL\(JWE 인증 태그\)입니다.

이 예제의 최종 결과\(표시 목적으로만 줄 바꿈 포함\):

```text
     eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.
     OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe
     ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb
     Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
     mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
     1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
     6UklfCpIMfIjf7iGdXKHzg.
     48V1_ALb6US04U3b.
     5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji
     SdiwkIr3ajwQzaBtQD_A.
     XFBoMYUZodetZdvTiFvSkQ
```

이 JWE를 계산하는 전체 세부 사항은 부록 A.1을 참조하십시오. 섹션 A.4 및 A.5에서 JWE JSON 직렬화를 사용하는 예를 포함하여 추가 예는 부록 A를 참조하십시오.

---
## **4.  JOSE Header**

JWE의 경우 JOSE 헤더를 나타내는 JSON 객체의 멤버는 일반 텍스트에 적용된 암호화와 선택적으로 JWE의 추가 속성을 설명합니다. JOSE 헤더 내의 헤더 매개변수 이름은 \[JWS\]의 섹션 4에 설명된 대로 고유해야 합니다. 구현에서 이해하지 못하는 헤더 매개변수를 처리하는 규칙도 동일합니다. 헤더 매개변수 이름의 클래스도 동일합니다.

---
### **4.1.  Registered Header Parameter Names**

JWE에서 사용되는 다음 헤더 매개변수 이름은 \[JWS\]가 설정한 IANA "JSON 웹 서명 및 암호화 헤더 매개변수" 레지스트리에 등록되어 있으며 의미는 아래에 정의되어 있습니다.

공통 레지스트리에서 알 수 있듯이 JWS와 JWE는 공통 헤더 매개변수 공간을 공유합니다. 매개변수가 두 사양에서 모두 사용되는 경우 해당 사양 간에 사용이 호환되어야 합니다.

---
#### **4.1.1.  "alg" (Algorithm) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.1에 정의된 "alg" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 가지고 있습니다. 다만 헤더 매개변수는 CEK의 값을 암호화하거나 결정하는 데 사용된 암호화 알고리즘을 식별합니다. "alg" 값이 지원되는 알고리즘을 나타내지 않거나 수신자에게 해당 알고리즘과 함께 사용할 수 있는 키가 없는 경우 암호화된 콘텐츠를 사용할 수 없습니다.

이 용도에 대해 정의된 "alg" 값 목록은 \[JWA\]가 설정한 IANA "JSON 웹 서명 및 암호화 알고리즘" 레지스트리에서 찾을 수 있습니다. 이 레지스트리의 초기 내용은 \[JWA\]의 섹션 4.1에 정의된 값입니다.

---
#### **4.1.2.  "enc" (Encryption Algorithm) Header Parameter**

"enc"\(암호화 알고리즘\) 헤더 매개변수는 암호문과 인증 태그를 생성하기 위해 일반 텍스트에 인증된 암호화를 수행하는 데 사용되는 콘텐츠 암호화 알고리즘을 식별합니다. 이 알고리즘은 지정된 키 길이를 가진 AEAD 알고리즘이어야 합니다. "enc" 값이 지원되는 알고리즘을 나타내지 않으면 암호화된 콘텐츠를 사용할 수 없습니다. "enc" 값은 \[JWA\]에서 설정한 IANA "JSON 웹 서명 및 암호화 알고리즘" 레지스트리에 등록되거나 충돌 방지 이름이 포함된 값이어야 합니다. "enc" 값은 StringOrURI 값이 포함된 대소문자 구분 ASCII 문자열입니다. 이 헤더 매개변수는 반드시 존재해야 하며 구현에서 이해하고 처리해야 합니다.

이 용도에 대해 정의된 "enc" 값 목록은 \[JWA\]가 설정한 IANA "JSON 웹 서명 및 암호화 알고리즘" 레지스트리에서 찾을 수 있습니다. 이 레지스트리의 초기 내용은 \[JWA\]의 섹션 5.1에 정의된 값입니다.

---
#### **4.1.3.  "zip" (Compression Algorithm) Header Parameter**

암호화 전에 평문에 적용된 "zip"\(압축 알고리즘\)\(있는 경우\). 이 사양에서 정의한 "zip" 값은 다음과 같습니다.

- "DEF" - DEFLATE \[RFC1951\] 알고리즘을 사용한 압축

다른 값을 사용할 수 있습니다. 압축 알고리즘 값은 \[JWA\]에서 설정한 IANA "JSON 웹 암호화 압축 알고리즘" 레지스트리에 등록할 수 있습니다. "zip" 값은 대소문자를 구분하는 문자열입니다. "zip" 매개변수가 없으면 암호화 전에 일반 텍스트에 압축이 적용되지 않습니다. 이 헤더 매개변수를 사용할 경우 무결성 보호가 되어야 하므로 반드시 다음 내에서만 발생해야 합니다.

JWE 보호 헤더. 이 헤더 매개변수의 사용은 선택 사항입니다. 이 헤더 매개변수는 구현에서 이해하고 처리해야 합니다.

---
#### **4.1.4.  "jku" (JWK Set URL) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.2에 정의된 "jku" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 갖고 있습니다. 다만 JWK 세트 리소스에는 JWE가 암호화된 공개 키가 포함되어 있습니다. 이를 사용하여 JWE를 해독하는 데 필요한 개인 키를 결정할 수 있습니다.

---
#### **4.1.5.  "jwk" (JSON Web Key) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.3에 정의된 "jwk" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 갖고 있습니다. 다만 키는 JWE가 암호화된 공개 키입니다. 이를 사용하여 JWE를 암호 해독하는 데 필요한 개인 키를 결정할 수 있습니다.

---
#### **4.1.6.  "kid" (Key ID) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.4에 정의된 "kid" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 가지고 있습니다. 다만 키 힌트는 JWE가 암호화된 공개 키를 참조합니다. 이는 JWE를 암호 해독하는 데 필요한 개인 키를 결정하는 데 사용할 수 있습니다. 이 매개변수를 사용하면 발신자가 JWE 수신자에게 키 변경을 명시적으로 알릴 수 있습니다.

---
#### **4.1.7.  "x5u" (X.509 URL) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.5에 정의된 "x5u" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 갖고 있습니다. 다만 X.509 공개 키 인증서 또는 인증서 체인\[RFC5280\]에는 JWE가 암호화된 공개 키가 포함되어 있습니다. 이를 사용하여 JWE를 암호 해독하는 데 필요한 개인 키를 결정할 수 있습니다.

---
#### **4.1.8.  "x5c" (X.509 Certificate Chain) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.6에 정의된 "x5c" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 갖고 있습니다. 다만 X.509 공개 키 인증서 또는 인증서 체인\[RFC5280\]에는 JWE가 암호화된 공개 키가 포함되어 있습니다. 이를 사용하여 JWE를 해독하는 데 필요한 개인 키를 결정할 수 있습니다.

\[JWS\]의 부록 B에서 "x5c" 값의 예를 참조하세요.

---
#### **4.1.9.  "x5t" (X.509 Certificate SHA-1 Thumbprint) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.7에 정의된 "x5t" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 가지고 있습니다. 다만 지문이 참조하는 인증서에는 JWE가 암호화된 공개 키가 포함되어 있습니다. 이를 사용하여 JWE를 암호 해독하는 데 필요한 개인 키를 결정할 수 있습니다. 인증서 지문은 때때로 인증서 지문이라고도 합니다.

```text
4.1.10.  "x5t#S256" (X.509 Certificate SHA-256 Thumbprint) Header
         Parameter
```

이 매개변수는 \[JWS\]의 섹션 4.1.8에 정의된 "x5t#S256" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 가지고 있습니다. 다만 지문이 참조하는 인증서에는 JWE가 암호화된 공개 키가 포함되어 있습니다. 이를 사용하여 JWE를 해독하는 데 필요한 개인 키를 결정할 수 있습니다. 인증서 지문은 때때로 인증서 지문이라고도 합니다.

---
#### **4.1.11.  "typ" (Type) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.9에 정의된 "typ" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 갖고 있지만 유형은 이 완전한 JWE의 유형입니다.

---
#### **4.1.12.  "cty" (Content Type) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.10에 정의된 "cty" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 가지지만 유형은 보안된 콘텐츠\(일반 텍스트\)의 유형입니다.

---
#### **4.1.13.  "crit" (Critical) Header Parameter**

이 매개변수는 \[JWS\]의 섹션 4.1.11에 정의된 "crit" 헤더 매개변수와 동일한 의미, 구문 및 처리 규칙을 갖습니다. 다만 JWS의 헤더 매개변수가 아니라 JWE의 헤더 매개변수를 참조한다는 점이 다릅니다.

---
### **4.2.  Public Header Parameter Names**

추가 헤더 매개변수 이름은 JWE를 사용하는 사람들이 정의할 수 있습니다. 그러나 충돌을 방지하기 위해 모든 새로운 헤더 매개변수 이름은 \[JWS\]가 설정한 IANA "JSON 웹 서명 및 암호화 헤더 매개변수" 레지스트리에 등록하거나 공개 이름\(충돌 방지 이름이 포함된 값\)이어야 합니다. 각 경우 이름 또는 값의 정의자는 합리적인 조치를 취해야 합니다.

헤더 매개변수 이름을 정의하는 데 사용하는 네임스페이스 부분을 제어하고 있는지 확인하기 위한 예방 조치입니다.

새로운 헤더 매개변수는 상호 운용이 불가능한 JWE를 초래할 수 있으므로 아껴서 도입해야 합니다.

---
### **4.3.  Private Header Parameter Names**

JWE의 생산자와 소비자는 비공개 이름인 헤더 매개변수 이름을 사용하는 데 동의할 수 있습니다. 등록된 헤더 매개변수 이름\(섹션 4.1\)이나 공개 헤더 매개변수 이름\(섹션 4.2\)이 아닌 이름입니다. 공개 헤더 매개변수 이름과 달리 비공개 헤더 매개변수 이름은 충돌할 수 있으므로 주의해서 사용해야 합니다.

---
## **5.  Producing and Consuming JWEs**
---
### **5.1.  Message Encryption**

메시지 암호화 프로세스는 다음과 같습니다. 단계의 입력과 출력 사이에 종속성이 없는 경우 단계의 순서는 중요하지 않습니다.

1. 콘텐츠 암호화 키 값을 결정하는 데 사용된 알고리즘에서 사용하는 키 관리 모드를 결정합니다. \(이것은 결과 JWE의 "alg"\(알고리즘\) 헤더 매개변수에 기록된 알고리즘입니다.\)

1. 키 래핑, 키 암호화 또는 키 래핑을 사용한 키 계약이 사용되는 경우 임의의 CEK 값을 생성합니다. 임의의 값을 생성하는 것에 대한 고려 사항은 RFC 4086 \[RFC4086\]을 참조하십시오. CEK는 콘텐츠 암호화 알고리즘에 필요한 길이와 동일해야 합니다.

1. 직접 키 계약 또는 키 래핑이 있는 키 계약이 사용되는 경우 키 계약 알고리즘을 사용하여 합의된 키의 값을 계산합니다. 직접 키 계약이 사용되는 경우 CEK를 합의된 키로 합니다. 키 래핑이 있는 키 계약이 사용되는 경우 합의된 키를 사용하여 CEK를 래핑합니다.

1. 키 래핑, 키 암호화 또는 키 래핑을 사용한 키 계약이 사용되는 경우 수신자에게 CEK를 암호화하고 그 결과를 JWE 암호화 키로 만듭니다.

1. 직접 키 합의 또는 직접 암호화가 사용되는 경우 JWE 암호화 키는 빈 옥텟 시퀀스가 됩니다.

1. 직접 암호화가 사용되는 경우 CEK를 공유 대칭 키로 지정합니다.

1. 인코딩된 키 값 BASE64URL\(JWE 암호화 키\)을 계산합니다.

1. JWE JSON 직렬화를 사용하는 경우 각 수신자에 대해 이 프로세스\(1\~7단계\)를 반복합니다.

1. 콘텐츠 암호화 알고리즘에 맞는 올바른 크기의 무작위 JWE 초기화 벡터를 생성합니다\(알고리즘에 필요한 경우\). 그렇지 않으면 JWE 초기화 벡터를 빈 옥텟 시퀀스로 둡니다.

1. 인코딩된 초기화 벡터 값 BASE64URL\(JWE 초기화 벡터\)을 계산합니다.

1. "zip" 매개변수가 포함된 경우 지정된 압축 알고리즘을 사용하여 평문을 압축하고 M을 압축된 평문을 나타내는 옥텟 시퀀스로 합니다. 그렇지 않은 경우 M을 평문을 나타내는 옥텟 시퀀스로 합니다.

1. 원하는 헤더 매개변수 집합을 포함하는 JSON 객체를 생성합니다. 이 객체는 JOSE 헤더를 구성합니다. 즉, JWE 보호 헤더, JWE 공유 비보호 헤더, JWE 수신자별 비보호 헤더 중 하나 이상을 포함합니다.

1. 인코딩된 보호 헤더 값 BASE64URL\(UTF8\(JWE 보호 헤더\)\)을 계산합니다. JWE 보호 헤더가 없는 경우\(JWE JSON 직렬화를 사용하고 "보호된" 멤버가 없는 경우에만 발생할 수 있음\) 이 값을 빈 문자열로 둡니다.

1. 추가 인증 데이터 암호화 매개변수를 ASCII\(인코딩된 보호 헤더\)로 설정합니다. 그러나 JWE AAD 값이 있는 경우\(JWE JSON 직렬화를 사용할 때만 해당\) 대신 추가 인증 데이터 암호화 매개변수를 ASCII\(인코딩된 보호 헤더 || '.' || BASE64URL\(JWE AAD\)\)로 설정합니다.

1. 지정된 콘텐츠 암호화 알고리즘을 사용하여 CEK, JWE 초기화 벡터 및 추가 인증 데이터 값을 사용하여 M을 암호화하고 JWE 암호문 값과 JWE 인증 태그\(암호화 작업에서 출력된 인증 태그\)를 생성합니다.

1. 인코딩된 암호문 값 BASE64URL\(JWE 암호문\)을 계산합니다.

1. 인코딩된 인증 태그 값 BASE64URL\(JWE 인증 태그\)을 계산합니다.

1. JWE AAD 값이 있는 경우 인코딩된 AAD 값 BASE64URL\(JWE AAD\)을 계산합니다.

1. 원하는 직렬화된 출력을 만듭니다. 이 결과의 Compact Serialization은 문자열 BASE64URL\(UTF8\(JWE 보호 헤더\)\) || '.' || BASE64URL\(JWE 암호화 키\) || '.' || BASE64URL\(JWE 초기화 벡터\) || '.' || BASE64URL\(JWE 암호문\) || '.' || BASE64URL\(JWE 인증 태그\)입니다. JWE JSON 직렬화는 섹션 7.2에 설명되어 있습니다.

---
### **5.2.  Message Decryption**

메시지 복호화 프로세스는 암호화 프로세스의 역순입니다. 단계의 입력과 출력 사이에 종속성이 없는 경우 단계의 순서는 중요하지 않습니다. 이러한 단계 중 하나라도 실패하면 암호화된 콘텐츠를 검증할 수 없습니다.

수신자가 여러 명인 경우, JWE가 수락되기 위해 수신자의 암호화된 콘텐츠 중 어느 것이 성공적으로 검증되어야 하는지는 애플리케이션에서 결정합니다. 어떤 경우에는 모든 수신자의 암호화된 콘텐츠가 성공적으로 검증되어야 하며 그렇지 않으면 JWE가 무효로 간주됩니다. 다른 경우에는 단일 수신자의 암호화된 콘텐츠만 성공적으로 검증되면 됩니다. 그러나 모든 경우에 최소한 한 명의 수신자의 암호화된 콘텐츠가 성공적으로 검증되어야 하며 그렇지 않으면 JWE가 무효로 간주되어야 합니다.

1. JWE 표현을 구문 분석하여 JWE 구성 요소에 대한 직렬화된 값을 추출합니다. JWE Compact Serialization을 사용할 때 이러한 구성 요소는 JWE 보호 헤더, JWE 암호화 키, JWE 초기화 벡터, JWE 암호문 및 JWE 인증 태그의 base64url 인코딩 표현이며, JWE JSON Serialization을 사용할 때 이러한 구성 요소에는 JWE AAD의 base64url 인코딩 표현과 인코딩되지 않은 JWE 공유 비보호 헤더 및 JWE 수신자별 비보호 헤더 값도 포함됩니다. JWE Compact Serialization을 사용할 때 JWE 보호 헤더, JWE 암호화 키, JWE 초기화 벡터, JWE 암호문, JWE 인증 태그는 base64url로 인코딩된 값으로 순서대로 표현되며, 각 값은 마침표\('.'\) 문자 하나로 구분되어 정확히 4개의 구분 마침표 문자가 사용됩니다. JWE JSON Serialization은 섹션 7.2에서 설명합니다.

1. Base64url은 줄 바꿈, 공백 또는 기타 추가 문자가 사용되지 않았다는 제한 사항에 따라 JWE 보호 헤더, JWE 암호화 키, JWE 초기화 벡터, JWE 암호문, JWE 인증 태그 및 JWE AAD의 인코딩된 표현을 디코딩합니다.

1. 인코딩된 JWE 보호 헤더를 디코딩하여 생성된 옥텟 시퀀스가 RFC 7159 \[RFC7159\]에 따른 완전히 유효한 JSON 개체의 UTF-8 인코딩 표현인지 확인합니다. JWE 보호 헤더를 이 JSON 개체로 지정합니다.

1. JWE Compact Serialization을 사용하는 경우 JOSE 헤더를 JWE 보호 헤더로 설정합니다. 그렇지 않은 경우 JWE JSON Serialization을 사용하는 경우 JOSE 헤더를 JWE 보호 헤더, JWE 공유 비보호 헤더 및 해당 JWE 수신자별 비보호 헤더의 멤버의 합집합으로 설정합니다. 이 모든 멤버는 완전히 유효한 JSON 객체여야 합니다. 이 단계에서 결과 JOSE 헤더에 중복된 헤더 매개변수 이름이 포함되지 않았는지 확인합니다. JWE JSON Serialization을 사용하는 경우 이 제한에는 동일한 헤더 매개변수 이름이 JOSE 헤더를 구성하는 고유한 JSON 객체 값에도 나타나서는 안 된다는 것이 포함됩니다.

1. 구현이 이 사양, 사용 중인 알고리즘 또는 "crit" 헤더 매개변수 값에 의해 요구되는 모든 필드를 이해하고 처리할 수 있는지 확인하고, 해당 매개변수의 값도 이해되고 지원되는지 확인합니다.

1. "alg"\(알고리즘\) 헤더 매개변수에서 지정한 알고리즘이 사용하는 키 관리 모드를 확인합니다.

1. JWE가 수신자에게 알려진 키를 사용하는지 확인합니다.

1. 직접 키 계약 또는 키 래핑이 있는 키 계약이 사용되는 경우 키 계약 알고리즘을 사용하여 합의된 키의 값을 계산합니다. 직접 키 계약이 사용되는 경우 CEK를 합의된 키로 합니다. 키 래핑이 있는 키 계약이 사용되는 경우 합의된 키는 JWE 암호화된 키를 해독하는 데 사용됩니다.

1. 키 래핑, 키 암호화 또는 키 래핑을 사용한 키 계약이 사용되는 경우 JWE 암호화 키를 해독하여 CEK를 생성합니다. CEK는 콘텐츠 암호화 알고리즘에 필요한 길이와 동일해야 합니다. 수신자가 여러 명인 경우 각 수신자는 해당 수신자가 소유한 키로 암호화된 JWE 암호화 키 값만 해독할 수 있습니다. 따라서 정상입니다.

- 수신자당 JWE 암호화 키 값 중 하나를 해독하여 CEK 값을 얻습니다. 또한 타이밍 공격 완화에 대한 보안 고려 사항은 섹션 11.5를 참조하십시오.

1. 직접 키 계약 또는 직접 암호화가 사용되는 경우 JWE 암호화 키 값이 빈 옥텟 시퀀스인지 확인합니다.

1. 직접 암호화가 사용되는 경우 CEK를 공유 대칭 키로 지정합니다.

1. 이 수신자에 대해 CEK를 성공적으로 결정할 수 있는지 여부를 기록합니다.

1. JWE JSON 직렬화를 사용하는 경우 표현에 포함된 각 수신자에 대해 이 프로세스\(4\~12단계\)를 반복합니다.

1. 인코딩된 보호 헤더 값 BASE64URL\(UTF8\(JWE 보호 헤더\)\)을 계산합니다. JWE 보호 헤더가 없는 경우\(JWE JSON 직렬화를 사용하고 "보호된" 멤버가 없는 경우에만 발생할 수 있음\) 이 값을 빈 문자열로 둡니다.

1. 추가 인증 데이터 암호화 매개변수를 ASCII\(인코딩된 보호 헤더\)로 설정합니다. 그러나 JWE AAD 값이 있는 경우\(JWE JSON 직렬화를 사용할 때만 해당\) 대신 추가 인증 데이터 암호화 매개변수를 ASCII\(인코딩된 보호 헤더 || '.' || BASE64URL\(JWE AAD\)\)로 설정합니다.

1. 지정된 콘텐츠 암호화 알고리즘을 사용하여 CEK, JWE 초기화 벡터, 추가 인증 데이터 값 및 JWE 인증 태그\(계산에 대한 인증 태그 입력\)를 사용하여 JWE 암호문을 복호화하고, 복호화된 평문을 반환하고 알고리즘에 지정된 방식으로 JWE 인증 태그를 검증하고, JWE 인증 태그가 올바르지 않으면 복호화된 출력을 내보내지 않고 입력을 거부합니다.

1. "zip" 매개변수가 포함된 경우 지정된 압축 알고리즘을 사용하여 복호화된 평문을 압축 해제합니다.

1. 모든 복호화 단계가 성공한 수신자가 없는 경우 JWE는 무효로 간주되어야 합니다. 그렇지 않은 경우 일반 텍스트를 출력합니다. JWE JSON 직렬화의 경우 복호화가 성공한 수신자와 실패한 수신자를 나타내는 결과를 애플리케이션에 반환합니다.

마지막으로, 주어진 맥락에서 어떤 알고리즘을 사용할지는 애플리케이션의 결정이라는 점에 유의하십시오. JWE를 성공적으로 복호화할 수 있더라도 JWE에서 사용된 알고리즘이 애플리케이션에 수용 가능하지 않으면 JWE를 무효로 간주해야 합니다.

---
### **5.3.  String Comparison Rules**

이 사양에 대한 문자열 비교 규칙은 \[JWS\]의 섹션 5.3에 정의된 규칙과 동일합니다.

---
## **6.  Key Identification**

이 사양에 대한 키 식별 방법은 \[JWS\]의 섹션 6에 정의된 방법과 동일하지만 식별되는 키는 JWE가 암호화된 공개 키입니다.

---
## **7.  Serializations**

JWE는 JWE Compact Serialization 또는 JWE JSON Serialization의 두 가지 직렬화 중 하나를 사용합니다. 이 사양을 사용하는 애플리케이션은 해당 애플리케이션에 사용되는 직렬화 및 직렬화 기능을 지정해야 합니다. 예를 들어, 애플리케이션은 JWE JSON Serialization만 사용하거나, 단일 수신자에 대한 JWE JSON Serialization 지원만 사용하거나, 여러 수신자에 대한 지원을 사용하도록 지정할 수 있습니다. JWE 구현은 지원하도록 설계된 애플리케이션에 필요한 기능만 구현하면 됩니다.

---
### **7.1.  JWE Compact Serialization**

JWE Compact Serialization은 암호화된 콘텐츠를 압축된 URL 안전 문자열로 나타냅니다. 이 문자열은 다음과 같습니다.

```text
      BASE64URL(UTF8(JWE Protected Header)) || '.' ||
      BASE64URL(JWE Encrypted Key) || '.' ||
      BASE64URL(JWE Initialization Vector) || '.' ||
      BASE64URL(JWE Ciphertext) || '.' ||
      BASE64URL(JWE Authentication Tag)
```

JWE 컴팩트 직렬화는 하나의 수신자만 지원하며 JWE 공유 비보호 헤더, JWE 수신자별 비보호 헤더 또는 JWE AAD 값을 나타내는 구문을 제공하지 않습니다.

---
### **7.2.  JWE JSON Serialization**

JWE JSON 직렬화는 암호화된 콘텐츠를 JSON 객체로 표현합니다. 이 표현은 압축성이나 URL 안전성에 최적화되지 않았습니다.

JWE JSON 직렬화에 대해 두 가지 밀접하게 관련된 구문이 정의되어 있습니다. 하나는 완전히 일반적인 구문으로, 콘텐츠를 여러 수신자에게 암호화할 수 있고, 다른 하나는 단일 수신자의 경우에 최적화된 일반화된 구문입니다.

---
#### **7.2.1.  General JWE JSON Serialization Syntax**

다음 멤버는 완전히 일반적인 JWE JSON 직렬화 구문에 사용되는 최상위 JSON 객체에서 사용하도록 정의됩니다.

protected - "protected" 멤버는 반드시 존재해야 하며 JWE Protected Header 값이 비어 있지 않으면 BASE64URL\(UTF8\(JWE Protected Header\)\) 값을 포함해야 합니다. 그렇지 않으면 반드시 없어야 합니다. 이러한 헤더 매개변수 값은 무결성 보호됩니다.

unprotected - "unprotected" 멤버는 반드시 존재해야 하며 JWE Shared Unprotected Header 값이 비어 있지 않으면 JWE Shared Unprotected Header 값을 포함해야 합니다. 그렇지 않으면 반드시 없어야 합니다. 이 값은 문자열이 아니라 인코딩되지 않은 JSON 객체로 표현됩니다. 이러한 헤더 매개변수 값은 무결성 보호되지 않습니다.

iv - JWE 초기화 벡터 값이 비어 있지 않으면 "iv" 멤버가 있어야 하며 BASE64URL\(JWE 초기화 벡터\) 값을 포함해야 합니다. 그렇지 않은 경우에는 없어야 합니다.

aad - "aad" 멤버는 반드시 존재해야 하며 JWE AAD 값이 비어 있지 않으면 BASE64URL\(JWE AAD\)\) 값을 포함해야 합니다. 그렇지 않으면 반드시 없어야 합니다. JWE AAD 값을 포함하면 무결성 보호되지만 암호화되지 않은 base64url 인코딩 값을 제공할 수 있습니다.

ciphertext - "ciphertext" 멤버는 반드시 존재해야 하며 BASE64URL\(JWE Ciphertext\) 값을 포함해야 합니다.

태그 - JWE 인증 태그 값이 비어 있지 않으면 "태그" 멤버가 있어야 하며 BASE64URL\(JWE 인증 태그\) 값을 포함해야 합니다. 그렇지 않은 경우에는 없어야 합니다.

수신자 - "수신자" 멤버 값은 JSON 객체의 배열이어야 합니다. 각 객체에는 단일 수신자에 대한 특정 정보가 포함되어 있습니다. 이 멤버는 반드시 배열 요소 하나와 함께 있어야 합니다.

- 수신자, 배열 요소 값 중 일부 또는 전체가 빈 JSON 객체 "{}"인 경우에도 해당됩니다\(모든 헤더 매개변수 값이 모든 수신자 간에 공유되고 암호화된 키가 사용되지 않는 경우\(예: 직접 암호화 수행 시\) 발생할 수 있음\).

다음 멤버는 "recipients" 배열의 요소인 JSON 객체에서 사용하도록 정의됩니다.

헤더 - "헤더" 멤버는 반드시 존재해야 하며 JWE Per-Recipient Unprotected Header 값이 비어 있지 않으면 JWE Per-Recipient Unprotected Header 값을 포함해야 합니다. 그렇지 않으면 반드시 없어야 합니다. 이 값은 문자열이 아니라 인코딩되지 않은 JSON 객체로 표현됩니다. 이러한 헤더 매개변수 값은 무결성이 보호되지 않습니다.

encrypted\_key - JWE 암호화 키 값이 비어 있지 않으면 "encrypted\_key" 멤버가 있어야 하며 BASE64URL\(JWE 암호화 키\) 값을 포함해야 합니다. 그렇지 않은 경우에는 없어야 합니다.

"alg" 및 "enc" 헤더 매개변수 값이 각 수신자 계산에 전달되도록 하려면 "header", "protected" 및 "unprotected" 멤버 중 하나 이상이 있어야 합니다.

위에 정의된 JSON 객체 둘 다에 추가 멤버가 있을 수 있으며, 이를 발견한 구현에서 이를 이해하지 못하는 경우 반드시 무시해야 합니다.

"alg" 매개변수를 포함한 일부 헤더 매개변수는 모든 수신자 계산에서 공유될 수 있습니다. JWE 보호 헤더 및 JWE 공유 비보호 헤더 값의 헤더 매개변수는 모든 수신자에서 공유됩니다.

수신자별 암호문 및 인증 태그 값을 생성 또는 검증할 때 사용되는 헤더 매개변수 값은 존재할 수 있는 세 가지 헤더 매개변수 값 집합의 합집합입니다. \(1\) "보호된" 멤버에 표현된 JWE 보호 헤더, \(2\) "보호되지 않은" 멤버에 표현된 JWE 공유 비보호 헤더, \(3\) 수신자 배열 요소의 "헤더" 멤버에 표현된 JWE 수신자별 비보호 헤더. 이러한 헤더 매개변수 집합의 합집합은 JOSE 헤더를 구성합니다. 세 위치의 헤더 매개변수 이름은 분리되어야 합니다.

각 JWE 암호화 키 값은 JWE Compact Serialization과 동일한 방식으로 해당 JOSE 헤더 값의 매개변수를 사용하여 계산됩니다. 이는 "수신자" 배열의 각 JWE 암호화 키 값이 다음과 동일하다는 바람직한 속성을 갖습니다.

JWE Compact Serialization에서 동일한 매개변수에 대해 계산되었을 값입니다. 마찬가지로 JWE Ciphertext 및 JWE Authentication Tag 값은 JWE Compact Serialization에 대해 생성된 값과 일치합니다. 단, JWE Protected Header 값\(무결성 보호 헤더 매개변수 값을 나타냄\)이 JWE Compact Serialization에서 사용된 값과 일치해야 합니다.

모든 수신자는 동일한 JWE 보호 헤더, JWE 초기화 벡터, JWE 암호문 및 JWE 인증 태그 값을 사용하며, 메시지가 큰 경우 잠재적으로 상당한 공간 절약이 가능합니다. 따라서 일반 텍스트 값의 처리를 지정하는 모든 헤더 매개변수는 모든 수신자에게 동일해야 합니다. 이는 주로 각 수신자의 JOSE 헤더에 있는 "enc"\(암호화 알고리즘\) 헤더 매개변수 값과 해당 알고리즘의 모든 매개변수가 동일해야 함을 의미합니다.

요약하자면, 일반적인 JWE JSON 직렬화를 사용하는 JWE의 구문은 다음과 같습니다.

```text
     {
      "protected":"<integrity-protected shared header contents>",
      "unprotected":<non-integrity-protected shared header contents>,
      "recipients":[
       {"header":<per-recipient unprotected header 1 contents>,
        "encrypted_key":"<encrypted key 1 contents>"},
       ...
       {"header":<per-recipient unprotected header N contents>,
        "encrypted_key":"<encrypted key N contents>"}],
      "aad":"<additional authenticated data contents>",
      "iv":"<initialization vector contents>",
      "ciphertext":"<ciphertext contents>",
      "tag":"<authentication tag contents>"
     }
```

일반 JWE JSON 직렬화 구문을 사용하는 JWE의 예는 부록 A.4를 참조하세요.

---
#### **7.2.2.  Flattened JWE JSON Serialization Syntax**

평면화된 JWE JSON 직렬화 구문은 일반 구문을 기반으로 하지만, 단일 수신자 케이스에 최적화하여 평면화합니다. "수신자" 멤버를 제거하고 대신 "수신자" 배열에서 사용하도록 정의된 멤버\("헤더" 및 "encrypted\_key" 멤버\)를 최상위 JSON 객체\("암호문" 멤버와 동일한 수준\)에 배치하여 평면화합니다.

이 구문을 사용할 때는 "recipients" 멤버가 있어서는 안 됩니다. 이 구문 차이 외에, flattened 구문을 사용하는 JWE JSON Serialization 객체는 일반 구문을 사용하는 객체와 동일하게 처리됩니다.

요약하자면, 평면화된 JWE JSON 직렬화를 사용하는 JWE의 구문은 다음과 같습니다.

```text
     {
      "protected":"<integrity-protected header contents>",
      "unprotected":<non-integrity-protected header contents>,
      "header":<more non-integrity-protected header contents>,
      "encrypted_key":"<encrypted key contents>",
      "aad":"<additional authenticated data contents>",
      "iv":"<initialization vector contents>",
      "ciphertext":"<ciphertext contents>",
      "tag":"<authentication tag contents>"
     }
```

일반 구문을 사용할 때와 마찬가지로 평면화된 구문을 사용할 때 보호되지 않은 헤더 매개변수 값은 "보호되지 않은" 멤버나 "헤더" 멤버, 또는 둘 다에 있을 수 있습니다.

평면화된 JWE JSON 직렬화 구문을 사용하는 JWE의 예는 부록 A.5를 참조하세요.

---
## **8.  TLS Requirements**

이 사양에 대한 TLS\(전송 계층 보안\) 요구 사항은 \[JWS\]의 섹션 8에 정의된 것과 동일합니다.

---
## **9.  Distinguishing between JWS and JWE Objects**

객체가 JWS인지 JWE인지 구별하는 방법은 여러 가지가 있습니다. 이러한 모든 방법은 모든 합법적인 입력 값에 대해 동일한 결과를 산출하지만, 잘못된 입력에 대해서는 다른 결과를 산출할 수 있습니다.

- 객체가 JWS Compact Serialization 또는 JWE Compact Serialization을 사용하는 경우 마침표\('.'\) 문자로 구분된 base64url 인코딩 세그먼트의 수는 JWS와 JWE에서 다릅니다. JWS에는 두 개의 마침표\('.'\) 문자로 구분된 세 개의 세그먼트가 있습니다. JWE에는 네 개의 마침표\('.'\) 문자로 구분된 다섯 개의 세그먼트가 있습니다.

- 객체가 JWS JSON 직렬화 또는 JWE JSON 직렬화를 사용하는 경우 사용되는 멤버가 다릅니다. JWS에는 "payload" 멤버가 있고 JWE에는 없습니다. JWE에는 "ciphertext" 멤버가 있고 JWS에는 없습니다.

- JWS의 JOSE 헤더는 "alg"\(알고리즘\) 헤더 매개변수 값을 검사하여 JWE의 JOSE 헤더와 구별할 수 있습니다. 값이 디지털 서명 또는 MAC 알고리즘을 나타내거나 값이 "none"이면 JWS를 위한 것입니다. 키 암호화, 키 래핑, 직접 키 계약, 키 래핑이 있는 키 계약 또는 직접 암호화 알고리즘을 나타내면 JWE를 위한 것입니다. \(JWS Compact Serialization 또는 JWE Compact Serialization을 사용하면 검사할 "alg" 값을 추출하는 것이 간단하지만 JWS JSON Serialization 또는 JWE JSON Serialization을 사용하면 더 어려울 수 있습니다.\)

- JWS의 JOSE 헤더는 "enc"\(암호화 알고리즘\) 멤버가 있는지 여부를 확인하여 JWE의 JOSE 헤더와 구별할 수도 있습니다. "enc" 멤버가 있으면 JWE이고, 그렇지 않으면 JWS입니다.

---
## **10.  IANA Considerations**
---
### **10.1.  JSON Web Signature and Encryption Header Parameters Registration**

이 섹션은 \[JWS\]가 설정한 IANA "JSON 웹 서명 및 암호화 헤더 매개변수" 레지스트리의 섹션 4.1에 정의된 헤더 매개변수 이름을 등록합니다.

---
#### **10.1.1.  Registry Contents**

- 헤더 매개변수 이름: "alg"
- 헤더 매개변수 설명: 알고리즘
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.1

- 헤더 매개변수 이름: "enc"
- 헤더 매개변수 설명: 암호화 알고리즘
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.2

- 헤더 매개변수 이름: "zip"
- 헤더 매개변수 설명: 압축 알고리즘
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.3

- 헤더 매개변수 이름: "jku"
- 헤더 매개변수 설명: JWK Set URL
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.4

```text
   o  Header Parameter Name: "jwk"
   o  Header Parameter Description: JSON Web Key
   o  Header Parameter Usage Location(s): JWE
```

- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.5

- 헤더 매개변수 이름: "kid"
- 헤더 매개변수 설명: 키 ID
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.6

- 헤더 매개변수 이름: "x5u"
- 헤더 매개변수 설명: X.509 URL
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.7

- 헤더 매개변수 이름: "x5c"
- 헤더 매개변수 설명: X.509 인증서 체인
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.8

- 헤더 매개변수 이름: "x5t"
- 헤더 매개변수 설명: X.509 인증서 SHA-1 지문
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.9

- 헤더 매개변수 이름: "x5t#S256"
- 헤더 매개변수 설명: X.509 인증서 SHA-256 지문
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.10

- 헤더 매개변수 이름: "typ"
- 헤더 매개변수 설명: 유형
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.11

- 헤더 매개변수 이름: "cty"
- 헤더 매개변수 설명: 콘텐츠 유형
- 헤더 매개변수 사용 위치: JWE
- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.12

```text
   o  Header Parameter Name: "crit"
   o  Header Parameter Description: Critical
   o  Header Parameter Usage Location(s): JWE
```

- 변경 컨트롤러: IESG
- 사양 문서: RFC 7516의 섹션 4.1.13

---
## **11.  Security Considerations**

모든 암호화 애플리케이션과 관련된 모든 보안 문제는 JWS/JWE/JWK 에이전트가 해결해야 합니다. 이러한 문제 중에는 사용자의 비대칭 개인 키와 대칭 비밀 키를 보호하고 다양한 공격에 대한 대책을 채택하는 것이 있습니다.

JWS 사양의 모든 보안 고려 사항은 이 사양에도 적용됩니다. 마찬가지로 XML 암호화 1.1 \[W3C.REC-xmlenc-core1-20130411\]의 모든 보안 고려 사항도 XML에 특정한 것 외에는 적용됩니다.

---
### **11.1.  Key Entropy and Random Values**

키 엔트로피 및 임의 값에 대한 보안 고려 사항은 \[JWS\]의 섹션 10.1을 참조하십시오. 거기에 나열된 임의 값의 사용 외에도 암호화를 수행할 때 임의 값이 CEK\(콘텐츠 암호화 키\) 및 IV\(초기화 벡터\)에도 사용된다는 점에 유의하십시오.

---
### **11.2.  Key Protection**

키 보호에 대한 보안 고려 사항은 \[JWS\]의 섹션 10.2를 참조하십시오. 보호해야 하는 키 외에도 암호화를 수행하는 구현은 키 암호화 키와 콘텐츠 암호화 키를 보호해야 합니다. 키 암호화 키가 손상되면 해당 키로 보호된 모든 콘텐츠가 공개될 수 있습니다. 마찬가지로 콘텐츠 암호화 키가 손상되면 연관된 암호화된 콘텐츠가 공개될 수 있습니다.

---
### **11.3.  Using Matching Algorithm Strengths**

가능한 한 일치 강도의 알고리즘을 함께 사용해야 합니다. 예를 들어, AES Key Wrap을 주어진 키 크기와 함께 사용하는 경우 AES GCM도 사용하는 경우 동일한 키 크기를 사용하는 것이 좋습니다. 키 암호화 및 콘텐츠 암호화 알고리즘이 다른 경우 효과적인 보안은 두 알고리즘 중 더 약한 알고리즘에 따라 결정됩니다.

또한 대칭 키 교환에 사용되는 공개 키의 강도를 결정하는 방법에 대한 정보는 RFC 3766\[RFC3766\]을 참조하세요.

---
### **11.4.  Adaptive Chosen-Ciphertext Attacks**

복호화할 때 JWE 수신자가 메시지 복호화를 위한 오라클로 사용되지 않도록 특별히 주의해야 합니다. RSAES-PKCS1-v1\_5에 대한 공격에 대한 구체적인 대책은 RFC 3218 \[RFC3218\]을 참조해야 합니다. 공격자는 "alg" 헤더 매개변수의 내용을 "RSA-OAEP"에서 "RSA1\_5"로 수정하여 RSAES-OAEP가 CEK를 암호화하는 데 사용되었더라도 감지하여 CEK를 복구하는 데 사용할 수 있는 포맷 오류를 생성할 수 있습니다. 따라서 암호화된 내용이 거부될 때 모든 포맷 오류를 CEK, 추가 인증 데이터 또는 암호문에 단일 오류로 보고하는 것이 특히 중요합니다.

또한, 이러한 유형의 공격은 키 사용을 제한된 알고리즘 집합\(보통 하나\)으로 제한함으로써 방지할 수 있습니다. 예를 들어, 키가 "RSA-OAEP" 전용으로 표시된 경우 해당 키로 "RSA1\_5" 알고리즘을 사용하여 메시지를 해독하려는 모든 시도는 키의 잘못된 사용으로 인해 즉시 실패해야 합니다.

---
### **11.5.  Timing Attacks**

RFC 3218 \[RFC3218\]에 설명된 공격을 완화하기 위해 수신자는 암호화된 키의 형식, 패딩 및 길이 오류를 구별해서는 안 됩니다. 부적절하게 형식화된 키를 수신한 경우 수신자는 임의로 생성된 CEK를 대체하고 다음 단계로 진행하여 타이밍 공격을 완화하는 것이 좋습니다.

---
## **12.  References**
---
### **12.1.  Normative References**

```text
   [JWA]      Jones, M., "JSON Web Algorithms (JWA)", RFC 7518,
              DOI 10.17487/RFC7518, May 2015,
              <http://www.rfc-editor.org/info/rfc7518>.

   [JWK]      Jones, M., "JSON Web Key (JWK)", RFC 7517,
              DOI 10.17487/RFC7517, May 2015,
              <http://www.rfc-editor.org/info/rfc7517>.

   [JWS]      Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", RFC 7515, DOI 10.17487/RFC7515, May
              2015, <http://www.rfc-editor.org/info/rfc7515>.

   [RFC1951]  Deutsch, P., "DEFLATE Compressed Data Format Specification
              version 1.3", RFC 1951, DOI 10.17487/RFC1951, May 1996,
              <http://www.rfc-editor.org/info/rfc1951>.

   [RFC20]    Cerf, V., "ASCII format for Network Interchange", STD 80,
              RFC 20, DOI 10.17487/RFC0020, October 1969,
              <http://www.rfc-editor.org/info/rfc20>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <http://www.rfc-editor.org/info/rfc3629>.

   [RFC4949]  Shirey, R., "Internet Security Glossary, Version 2",
              FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007,
              <http://www.rfc-editor.org/info/rfc4949>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <http://www.rfc-editor.org/info/rfc5280>.

   [RFC7159]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, DOI 10.17487/RFC7159, March
              2014, <http://www.rfc-editor.org/info/rfc7159>.

   [UNICODE]  The Unicode Consortium, "The Unicode Standard",
              <http://www.unicode.org/versions/latest/>.
```

---
### **12.2.  Informative References**

```text
   [AES]      National Institute of Standards and Technology (NIST),
              "Advanced Encryption Standard (AES)", FIPS PUB 197,
              November 2001, <http://csrc.nist.gov/publications/
              fips/fips197/fips-197.pdf>.

   [JSE]      Bradley, J. and N. Sakimura (editor), "JSON Simple
              Encryption", September 2010,
              <http://jsonenc.info/enc/1.0/>.

   [JSMS]     Rescorla, E. and J. Hildebrand, "JavaScript Message
              Security Format", Work in Progress,
              draft-rescorla-jsms-00, March 2011.

   [NIST.800-38D]
              National Institute of Standards and Technology (NIST),
              "Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC", NIST PUB 800-38D,
              November 2007, <http://csrc.nist.gov/publications/
              nistpubs/800-38D/SP-800-38D.pdf>.

   [RFC3218]  Rescorla, E., "Preventing the Million Message Attack on
              Cryptographic Message Syntax", RFC 3218,
              DOI 10.17487/RFC3218, January 2002,
              <http://www.rfc-editor.org/info/rfc3218>.

   [RFC3447]  Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", RFC 3447, DOI 10.17487/RFC3447, February
              2003, <http://www.rfc-editor.org/info/rfc3447>.

   [RFC3766]  Orman, H. and P. Hoffman, "Determining Strengths For
              Public Keys Used For Exchanging Symmetric Keys", BCP 86,
              RFC 3766, DOI 10.17487/RFC3766, April 2004,
              <http://www.rfc-editor.org/info/rfc3766>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <http://www.rfc-editor.org/info/rfc4086>.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, DOI 10.17487/RFC5652, September 2009,
              <http://www.rfc-editor.org/info/rfc5652>.

   [W3C.REC-xmlenc-core1-20130411]
              Eastlake, D., Reagle, J., Hirsch, F., and T. Roessler,
              "XML Encryption Syntax and Processing Version 1.1", World
              Wide Web Consortium Recommendation
              REC-xmlenc-core1-20130411, April 2013,
              <http://www.w3.org/TR/2013/REC-xmlenc-core1-20130411/>.
```

---
# **Appendix A.  JWE Examples**

이 섹션에서는 JWE 계산의 예를 제공합니다.

---
### **A.1.  Example JWE using RSAES-OAEP and AES GCM**

이 예에서는 RSAES-OAEP를 키 암호화에 사용하고 AES GCM을 콘텐츠 암호화에 사용하여 수신자에게 일반 텍스트 "지능의 진정한 신호는 지식이 아니라 상상력입니다."를 암호화합니다. 이 일반 텍스트의 표현\(JSON 배열 표기법 사용\)은 다음과 같습니다.

```text
   [84, 104, 101, 32, 116, 114, 117, 101, 32, 115, 105, 103, 110, 32,
   111, 102, 32, 105, 110, 116, 101, 108, 108, 105, 103, 101, 110, 99,
   101, 32, 105, 115, 32, 110, 111, 116, 32, 107, 110, 111, 119, 108,
   101, 100, 103, 101, 32, 98, 117, 116, 32, 105, 109, 97, 103, 105,
   110, 97, 116, 105, 111, 110, 46]
```

---
#### **A.1.1.  JOSE Header**

다음 예제 JWE 보호 헤더는 다음을 선언합니다.

- 콘텐츠 암호화 키는 RSAES-OAEP 알고리즘을 사용하여 수신자에게 암호화되어 JWE 암호화 키를 생성합니다.
- 인증된 암호화는 256비트 키를 사용하여 AES GCM 알고리즘을 사용하여 평문에서 수행되어 암호문과 인증 태그를 생성합니다.

```text
     {"alg":"RSA-OAEP","enc":"A256GCM"}
```

이 JWE 보호 헤더를 BASE64URL\(UTF8\(JWE 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ
```

---
#### **A.1.2.  Content Encryption Key (CEK)**

256비트 랜덤 CEK를 생성합니다. 이 예에서 값\(JSON 배열 표기법 사용\)은 다음과 같습니다.

```text
   [177, 161, 244, 128, 84, 143, 225, 115, 63, 180, 3, 255, 107, 154,
   212, 246, 138, 7, 110, 91, 112, 46, 34, 105, 47, 130, 203, 46, 122,
   234, 64, 252]
```

---
#### **A.1.3.  Key Encryption**

RSAES-OAEP 알고리즘을 사용하여 수신자의 공개 키로 CEK를 암호화하여 JWE 암호화 키를 생성합니다. 이 예에서는 아래의 JSON 웹 키 \[JWK\] 형식으로 표현된 RSA 키를 사용합니다\(표시 목적으로만 값 내에 줄 바꿈이 있음\):

```text
     {"kty":"RSA",
      "n":"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW
           cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S
           psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a
           sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS
           tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj
           YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw",
      "e":"AQAB",
      "d":"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N
           WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9
           3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk
           qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl
           t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd
           VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ",
      "p":"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-
           SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lf
           fNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0",
      "q":"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBm
           UDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aX
           IWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc",
      "dp":"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KL
           hMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827
           rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE",
      "dq":"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCj
           ywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDB
           UfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis",
      "qi":"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7
           AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3
           eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY"
     }
```

결과적으로 생성된 JWE 암호화 키 값은 다음과 같습니다.

```text
   [56, 163, 154, 192, 58, 53, 222, 4, 105, 218, 136, 218, 29, 94, 203,
   22, 150, 92, 129, 94, 211, 232, 53, 89, 41, 60, 138, 56, 196, 216,
   82, 98, 168, 76, 37, 73, 70, 7, 36, 8, 191, 100, 136, 196, 244, 220,
   145, 158, 138, 155, 4, 117, 141, 230, 199, 247, 173, 45, 182, 214,
   74, 177, 107, 211, 153, 11, 205, 196, 171, 226, 162, 128, 171, 182,
   13, 237, 239, 99, 193, 4, 91, 219, 121, 223, 107, 167, 61, 119, 228,
   173, 156, 137, 134, 200, 80, 219, 74, 253, 56, 185, 91, 177, 34, 158,
   89, 154, 205, 96, 55, 18, 138, 43, 96, 218, 215, 128, 124, 75, 138,
   243, 85, 25, 109, 117, 140, 26, 155, 249, 67, 167, 149, 231, 100, 6,
   41, 65, 214, 251, 232, 87, 72, 40, 182, 149, 154, 168, 31, 193, 126,
   215, 89, 28, 111, 219, 125, 182, 139, 235, 195, 197, 23, 234, 55, 58,
   63, 180, 68, 202, 206, 149, 75, 205, 248, 176, 67, 39, 178, 60, 98,
   193, 32, 238, 122, 96, 158, 222, 57, 183, 111, 210, 55, 188, 215,
   206, 180, 166, 150, 166, 106, 250, 55, 229, 72, 40, 69, 214, 216,
   104, 23, 40, 135, 212, 28, 127, 41, 80, 175, 174, 168, 115, 171, 197,
   89, 116, 92, 103, 246, 83, 216, 182, 176, 84, 37, 147, 35, 45, 219,
   172, 99, 226, 233, 73, 37, 124, 42, 72, 49, 242, 35, 127, 184, 134,
   117, 114, 135, 206]
```

이 JWE 암호화 키를 BASE64URL\(JWE 암호화 키\)로 인코딩하면 다음 값이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe
     ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb
     Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
     mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
     1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
     6UklfCpIMfIjf7iGdXKHzg
```

---
#### **A.1.4.  Initialization Vector**

랜덤 96비트 JWE 초기화 벡터를 생성합니다. 이 예에서 값은 다음과 같습니다.

```text
   [227, 197, 117, 252, 2, 219, 233, 68, 180, 225, 77, 219]
```

이 JWE 초기화 벡터를 BASE64URL\(JWE 초기화 벡터\)로 인코딩하면 다음 값이 생성됩니다.

```text
     48V1_ALb6US04U3b
```

---
#### **A.1.5.  Additional Authenticated Data**

추가 인증 데이터 암호화 매개변수를 ASCII\(BASE64URL\(UTF8\(JWE 보호 헤더\)\)\)로 설정합니다. 이 값은 다음과 같습니다.

```text
   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69,
   116, 84, 48, 70, 70, 85, 67, 73, 115, 73, 109, 86, 117, 89, 121, 73,
   54, 73, 107, 69, 121, 78, 84, 90, 72, 81, 48, 48, 105, 102, 81]
```

---
#### **A.1.6.  Content Encryption**

CEK를 암호화 키로, JWE 초기화 벡터, 위의 추가 인증 데이터 값을 사용하여 AES GCM 알고리즘으로 일반 텍스트에 인증된 암호화를 수행하고 128비트 인증 태그 출력을 요청합니다. 결과 암호문은 다음과 같습니다.

```text
   [229, 236, 166, 241, 53, 191, 115, 196, 174, 43, 73, 109, 39, 122,
   233, 96, 140, 206, 120, 52, 51, 237, 48, 11, 190, 219, 186, 80, 111,
   104, 50, 142, 47, 167, 59, 61, 181, 127, 196, 21, 40, 82, 242, 32,
   123, 143, 168, 226, 73, 216, 176, 144, 138, 247, 106, 60, 16, 205,
   160, 109, 64, 63, 192]
```

결과 인증 태그 값은 다음과 같습니다.

```text
   [92, 80, 104, 49, 133, 25, 161, 215, 173, 101, 219, 211, 136, 91,
   210, 145]
```

이 JWE 암호문을 BASE64URL\(JWE 암호문\)로 인코딩하면 다음 값이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\):

```text
     5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji
     SdiwkIr3ajwQzaBtQD_A
```

이 JWE 인증 태그를 BASE64URL\(JWE 인증 태그\)로 인코딩하면 다음 값이 생성됩니다.

```text
     XFBoMYUZodetZdvTiFvSkQ
```

---
#### **A.1.7.  Complete Representation**

최종 표현을 조립합니다. 이 결과의 컴팩트 직렬화는 문자열 BASE64URL\(UTF8\(JWE 보호 헤더\)\) || '.' || BASE64URL\(JWE 암호화 키\) || '.' || BASE64URL\(JWE 초기화 벡터\) || '.' || BASE64URL\(JWE 암호문\) || '.' || BASE64URL\(JWE 인증 태그\)입니다.

이 예제의 최종 결과\(표시 목적으로만 줄 바꿈 포함\):

```text
     eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.
     OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe
     ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb
     Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
     mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
     1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
     6UklfCpIMfIjf7iGdXKHzg.
     48V1_ALb6US04U3b.
     5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji
     SdiwkIr3ajwQzaBtQD_A.
     XFBoMYUZodetZdvTiFvSkQ
```

---
#### **A.1.8.  Validation**

이 예에서는 키 암호화를 위한 RSAES-OAEP와 콘텐츠 암호화를 위한 AES GCM을 사용하여 JWE를 만드는 과정을 보여줍니다. 이러한 결과는 이러한 알고리즘에 대한 JWE 복호화 구현을 검증하는 데 사용할 수 있습니다. RSAES-OAEP 계산에는 난수 값이 포함되므로 위의 암호화 결과는 완전히 재현할 수 없습니다. 그러나 AES GCM 계산은 결정적이므로 JWE 암호화된 암호문 값은 이러한 입력을 사용하여 수행된 모든 암호화에 대해 동일합니다.

---
### **A.2.  Example JWE using RSAES-PKCS1-v1_5 and AES_128_CBC_HMAC_SHA_256**

이 예에서는 RSAES-PKCS1-v1\_5\(키 암호화\) 및 AES\_128\_CBC\_HMAC\_SHA\_256\(콘텐츠 암호화\)을 사용하여 수신자에게 일반 텍스트 "Live long and prosper."를 암호화합니다. 이 일반 텍스트의 표현\(JSON 배열 표기법 사용\)은 다음과 같습니다.

```text
   [76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,
   112, 114, 111, 115, 112, 101, 114, 46]
```

---
#### **A.2.1.  JOSE Header**

다음 예제 JWE 보호 헤더는 다음을 선언합니다.

- 콘텐츠 암호화 키는 RSAES-PKCS1-v1\_5 알고리즘을 사용하여 수신자에게 암호화되어 JWE 암호화 키를 생성합니다.
- 인증된 암호화는 AES\_128\_CBC\_HMAC\_SHA\_256 알고리즘을 사용하여 평문에서 수행되어 암호문과 인증 태그를 생성합니다.

```text
     {"alg":"RSA1_5","enc":"A128CBC-HS256"}
```

이 JWE 보호 헤더를 BASE64URL\(UTF8\(JWE 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0
```

---
#### **A.2.2.  Content Encryption Key (CEK)**

256비트 랜덤 CEK를 생성합니다. 이 예에서 키 값은 다음과 같습니다.

```text
   [4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106,
   206, 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156,
   44, 207]
```

---
#### **A.2.3.  Key Encryption**

RSAES-PKCS1-v1\_5 알고리즘을 사용하여 수신자의 공개 키로 CEK를 암호화하여 JWE 암호화 키를 생성합니다. 이 예에서는 아래 JSON 웹 키 \[JWK\] 형식으로 표현된 RSA 키를 사용합니다\(표시 목적으로만 값 내에 줄 바꿈 포함\):

```text
     {"kty":"RSA",
      "n":"sXchDaQebHnPiGvyDOAT4saGEUetSyo9MKLOoWFsueri23bOdgWp4Dy1Wl
           UzewbgBHod5pcM9H95GQRV3JDXboIRROSBigeC5yjU1hGzHHyXss8UDpre
           cbAYxknTcQkhslANGRUZmdTOQ5qTRsLAt6BTYuyvVRdhS8exSZEy_c4gs_
           7svlJJQ4H9_NxsiIoLwAEk7-Q3UXERGYw_75IDrGA84-lA_-Ct4eTlXHBI
           Y2EaV7t7LjJaynVJCpkv4LKjTTAumiGUIuQhrNhZLuF_RJLqHpM2kgWFLU
           7-VTdL1VbC2tejvcI2BlMkEpk1BzBZI0KQB0GaDWFLN-aEAw3vRw",
      "e":"AQAB",
      "d":"VFCWOqXr8nvZNyaaJLXdnNPXZKRaWCjkU5Q2egQQpTBMwhprMzWzpR8Sxq
           1OPThh_J6MUD8Z35wky9b8eEO0pwNS8xlh1lOFRRBoNqDIKVOku0aZb-ry
           nq8cxjDTLZQ6Fz7jSjR1Klop-YKaUHc9GsEofQqYruPhzSA-QgajZGPbE_
           0ZaVDJHfyd7UUBUKunFMScbflYAAOYJqVIVwaYR5zWEEceUjNnTNo_CVSj
           -VvXLO5VZfCUAVLgW4dpf1SrtZjSt34YLsRarSb127reG_DUwg9Ch-Kyvj
           T1SkHgUWRVGcyly7uvVGRSDwsXypdrNinPA4jlhoNdizK2zF2CWQ",
      "p":"9gY2w6I6S6L0juEKsbeDAwpd9WMfgqFoeA9vEyEUuk4kLwBKcoe1x4HG68
           ik918hdDSE9vDQSccA3xXHOAFOPJ8R9EeIAbTi1VwBYnbTp87X-xcPWlEP
           krdoUKW60tgs1aNd_Nnc9LEVVPMS390zbFxt8TN_biaBgelNgbC95sM",
      "q":"uKlCKvKv_ZJMVcdIs5vVSU_6cPtYI1ljWytExV_skstvRSNi9r66jdd9-y
           BhVfuG4shsp2j7rGnIio901RBeHo6TPKWVVykPu1iYhQXw1jIABfw-MVsN
           -3bQ76WLdt2SDxsHs7q7zPyUyHXmps7ycZ5c72wGkUwNOjYelmkiNS0",
      "dp":"w0kZbV63cVRvVX6yk3C8cMxo2qCM4Y8nsq1lmMSYhG4EcL6FWbX5h9yuv
           ngs4iLEFk6eALoUS4vIWEwcL4txw9LsWH_zKI-hwoReoP77cOdSL4AVcra
           Hawlkpyd2TWjE5evgbhWtOxnZee3cXJBkAi64Ik6jZxbvk-RR3pEhnCs",
      "dq":"o_8V14SezckO6CNLKs_btPdFiO9_kC1DsuUTd2LAfIIVeMZ7jn1Gus_Ff
           7B7IVx3p5KuBGOVF8L-qifLb6nQnLysgHDh132NDioZkhH7mI7hPG-PYE_
           odApKdnqECHWw0J-F0JWnUd6D2B_1TvF9mXA2Qx-iGYn8OVV1Bsmp6qU",
      "qi":"eNho5yRBEBxhGBtQRww9QirZsB66TrfFReG_CcteI1aCneT0ELGhYlRlC
           tUkTRclIfuEPmNsNDPbLoLqqCVznFbvdB7x-Tl-m0l_eFTj2KiqwGqE9PZ
           B9nNTwMVvH3VRRSLWACvPnSiwP8N5Usy-WRXS-V7TbpxIhvepTfE0NNo"
     }
```

결과적으로 생성된 JWE 암호화 키 값은 다음과 같습니다.

```text
   [80, 104, 72, 58, 11, 130, 236, 139, 132, 189, 255, 205, 61, 86, 151,
   176, 99, 40, 44, 233, 176, 189, 205, 70, 202, 169, 72, 40, 226, 181,
   156, 223, 120, 156, 115, 232, 150, 209, 145, 133, 104, 112, 237, 156,
   116, 250, 65, 102, 212, 210, 103, 240, 177, 61, 93, 40, 71, 231, 223,
   226, 240, 157, 15, 31, 150, 89, 200, 215, 198, 203, 108, 70, 117, 66,
   212, 238, 193, 205, 23, 161, 169, 218, 243, 203, 128, 214, 127, 253,
   215, 139, 43, 17, 135, 103, 179, 220, 28, 2, 212, 206, 131, 158, 128,
   66, 62, 240, 78, 186, 141, 125, 132, 227, 60, 137, 43, 31, 152, 199,
   54, 72, 34, 212, 115, 11, 152, 101, 70, 42, 219, 233, 142, 66, 151,
   250, 126, 146, 141, 216, 190, 73, 50, 177, 146, 5, 52, 247, 28, 197,
   21, 59, 170, 247, 181, 89, 131, 241, 169, 182, 246, 99, 15, 36, 102,
   166, 182, 172, 197, 136, 230, 120, 60, 58, 219, 243, 149, 94, 222,
   150, 154, 194, 110, 227, 225, 112, 39, 89, 233, 112, 207, 211, 241,
   124, 174, 69, 221, 179, 107, 196, 225, 127, 167, 112, 226, 12, 242,
   16, 24, 28, 120, 182, 244, 213, 244, 153, 194, 162, 69, 160, 244,
   248, 63, 165, 141, 4, 207, 249, 193, 79, 131, 0, 169, 233, 127, 167,
   101, 151, 125, 56, 112, 111, 248, 29, 232, 90, 29, 147, 110, 169,
   146, 114, 165, 204, 71, 136, 41, 252]
```

이 JWE 암호화 키를 BASE64URL\(JWE 암호화 키\)로 인코딩하면 다음 값이 생성됩니다\(표시 목적으로만 줄 바꿈 포함\).

```text
     UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm
     1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc
     HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF
     NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8
     rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv
     -B3oWh2TbqmScqXMR4gp_A
```

---
#### **A.2.4.  Initialization Vector**

무작위 128비트 JWE 초기화 벡터를 생성합니다. 이 예에서 값은 다음과 같습니다.

```text
   [3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104,
   101]
```

이 JWE 초기화 벡터를 BASE64URL\(JWE 초기화 벡터\)로 인코딩하면 다음 값이 생성됩니다.

```text
     AxY8DCtDaGlsbGljb3RoZQ
```

---
#### **A.2.5.  Additional Authenticated Data**

추가 인증 데이터 암호화 매개변수를 ASCII\(BASE64URL\(UTF8\(JWE 보호 헤더\)\)\)로 설정합니다. 이 값은 다음과 같습니다.

```text
   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69,
   120, 88, 122, 85, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105,
   74, 66, 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85,
   50, 73, 110, 48]
```

---
#### **A.2.6.  Content Encryption**

CEK를 암호화 키로, JWE 초기화 벡터, 위의 추가 인증 데이터 값을 사용하여 AES\_128\_CBC\_HMAC\_SHA\_256 알고리즘으로 일반 텍스트에 인증된 암호화를 수행합니다. 부록 A.3의 값을 사용하여 이를 수행하는 단계는 부록 B에 자세히 나와 있습니다. 결과 암호문은 다음과 같습니다.

```text
   [40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,
   75, 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,
   112, 56, 102]
```

결과 인증 태그 값은 다음과 같습니다.

```text
   [246, 17, 244, 190, 4, 95, 98, 3, 231, 0, 115, 157, 242, 203, 100,
   191]
```

이 JWE 암호문을 BASE64URL\(JWE 암호문\)로 인코딩하면 다음 값이 생성됩니다.

```text
     KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY
```

이 JWE 인증 태그를 BASE64URL\(JWE 인증 태그\)로 인코딩하면 다음 값이 생성됩니다.

```text
     9hH0vgRfYgPnAHOd8stkvw
```

---
#### **A.2.7.  Complete Representation**

최종 표현을 조립합니다. 이 결과의 컴팩트 직렬화는 문자열 BASE64URL\(UTF8\(JWE 보호 헤더\)\) || '.' || BASE64URL\(JWE 암호화 키\) || '.' || BASE64URL\(JWE 초기화 벡터\) || '.' || BASE64URL\(JWE 암호문\) || '.' || BASE64URL\(JWE 인증 태그\)입니다.

이 예제의 최종 결과\(표시 목적으로만 줄 바꿈 포함\):

```text
     eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.
     UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm
     1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc
     HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF
     NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8
     rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv
     -B3oWh2TbqmScqXMR4gp_A.
     AxY8DCtDaGlsbGljb3RoZQ.
     KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.
     9hH0vgRfYgPnAHOd8stkvw
```

---
#### **A.2.8.  Validation**

이 예제는 키 암호화를 위해 RSAES-PKCS1-v1\_5를 사용하고 콘텐츠 암호화를 위해 AES\_CBC\_HMAC\_SHA2를 사용하여 JWE를 만드는 과정을 보여줍니다. 이러한 결과는 이러한 알고리즘에 대한 JWE 복호화 구현을 검증하는 데 사용할 수 있습니다. RSAES-PKCS1-v1\_5 계산에는 난수 값이 포함되므로 위의 암호화 결과는 완전히 재현할 수 없습니다. 그러나 AES-CBC 계산은 결정적이므로 JWE 암호화된 암호문 값은 이러한 입력을 사용하여 수행된 모든 암호화에 대해 동일합니다.

---
### **A.3.  Example JWE Using AES Key Wrap and AES_128_CBC_HMAC_SHA_256**

이 예에서는 AES Key Wrap을 사용하여 키 암호화를 하고 AES\_128\_CBC\_HMAC\_SHA\_256을 사용하여 수신자에게 일반 텍스트 "Live long and prosper."를 암호화합니다. 이 일반 텍스트의 표현\(JSON 배열 표기법 사용\)은 다음과 같습니다.

```text
   [76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,
   112, 114, 111, 115, 112, 101, 114, 46]
```

---
#### **A.3.1.  JOSE Header**

다음 예제 JWE 보호 헤더는 다음을 선언합니다.

- 콘텐츠 암호화 키는 128비트 키로 AES 키 랩 알고리즘을 사용하여 수신자에게 암호화되어 JWE 암호화 키를 생성합니다.
- 인증된 암호화는 AES\_128\_CBC\_HMAC\_SHA\_256 알고리즘을 사용하여 평문에서 수행되어 암호문과 인증 태그를 생성합니다.

```text
     {"alg":"A128KW","enc":"A128CBC-HS256"}
```

이 JWE 보호 헤더를 BASE64URL\(UTF8\(JWE 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0
```

---
#### **A.3.2.  Content Encryption Key (CEK)**

256비트 랜덤 CEK를 생성합니다. 이 예에서 값은 다음과 같습니다.

```text
   [4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106,
   206, 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156,
   44, 207]
```

---
#### **A.3.3.  Key Encryption**

AES 키 랩 알고리즘을 사용하여 공유 대칭 키로 CEK를 암호화하여 JWE 암호화 키를 생성합니다. 이 예에서는 아래 JSON 웹 키\[JWK\] 형식으로 표현된 대칭 키를 사용합니다.

```text
     {"kty":"oct",
      "k":"GawgguFyGrWKav7AX4VKUg"
     }
```

결과적으로 생성된 JWE 암호화 키 값은 다음과 같습니다.

```text
   [232, 160, 123, 211, 183, 76, 245, 132, 200, 128, 123, 75, 190, 216,
   22, 67, 201, 138, 193, 186, 9, 91, 122, 31, 246, 90, 28, 139, 57, 3,
   76, 124, 193, 11, 98, 37, 173, 61, 104, 57]
```

이 JWE 암호화 키를 BASE64URL\(JWE 암호화 키\)로 인코딩하면 다음 값이 생성됩니다.

```text
     6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ
```

---
#### **A.3.4.  Initialization Vector**

무작위 128비트 JWE 초기화 벡터를 생성합니다. 이 예에서 값은 다음과 같습니다.

```text
   [3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104,
   101]
```

이 JWE 초기화 벡터를 BASE64URL\(JWE 초기화 벡터\)로 인코딩하면 다음 값이 생성됩니다.

```text
     AxY8DCtDaGlsbGljb3RoZQ
```

---
#### **A.3.5.  Additional Authenticated Data**

추가 인증 데이터 암호화 매개변수를 ASCII\(BASE64URL\(UTF8\(JWE 보호 헤더\)\)\)로 설정합니다. 이 값은 다음과 같습니다.

```text
   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
   83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
   77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50, 73,
   110, 48]
```

---
#### **A.3.6.  Content Encryption**

CEK를 암호화 키로, JWE 초기화 벡터, 위의 추가 인증 데이터 값을 사용하여 AES\_128\_CBC\_HMAC\_SHA\_256 알고리즘으로 일반 텍스트에 인증된 암호화를 수행합니다. 이 예제의 값을 사용하여 이를 수행하는 단계는 부록 B에 자세히 나와 있습니다. 결과 암호문은 다음과 같습니다.

```text
   [40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,
   75, 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,
   112, 56, 102]
```

결과 인증 태그 값은 다음과 같습니다.

```text
   [83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199, 133, 32, 38,
   194, 85]
```

이 JWE 암호문을 BASE64URL\(JWE 암호문\)로 인코딩하면 다음 값이 생성됩니다.

```text
     KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY
```

이 JWE 인증 태그를 BASE64URL\(JWE 인증 태그\)로 인코딩하면 다음 값이 생성됩니다.

```text
     U0m_YmjN04DJvceFICbCVQ
```

---
#### **A.3.7.  Complete Representation**

최종 표현을 조립합니다. 이 결과의 컴팩트 직렬화는 문자열 BASE64URL\(UTF8\(JWE 보호 헤더\)\) || '.' || BASE64URL\(JWE 암호화 키\) || '.' || BASE64URL\(JWE 초기화 벡터\) || '.' || BASE64URL\(JWE 암호문\) || '.' || BASE64URL\(JWE 인증 태그\)입니다.

이 예제의 최종 결과\(표시 목적으로만 줄 바꿈 포함\):

```text
     eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.
     6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.
     AxY8DCtDaGlsbGljb3RoZQ.
     KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.
     U0m_YmjN04DJvceFICbCVQ
```

---
#### **A.3.8.  Validation**

이 예제는 키 암호화를 위한 AES Key Wrap과 콘텐츠 암호화를 위한 AES GCM을 사용하여 JWE를 만드는 과정을 보여줍니다. 이러한 결과는 이러한 알고리즘에 대한 JWE 복호화 구현을 검증하는 데 사용할 수 있습니다. 또한 AES Key Wrap과 AES GCM 계산은 모두 결정적이므로 결과 JWE 값은 이러한 입력을 사용하여 수행된 모든 암호화에 대해 동일합니다. 계산이 재현 가능하므로 이러한 결과는 이러한 알고리즘에 대한 JWE 암호화 구현을 검증하는 데에도 사용할 수 있습니다.

---
### **A.4.  Example JWE Using General JWE JSON Serialization**

이 섹션에는 일반적인 JWE JSON 직렬화 구문을 사용하는 예가 들어 있습니다. 이 예는 동일한 일반 텍스트를 여러 수신자에게 암호화하는 기능을 보여줍니다.

이 예에서는 두 명의 수신자가 있습니다. 첫 번째 수신자에 사용된 알고리즘과 키는 부록 A.2에서 사용된 것과 동일합니다. 두 번째 수신자에 사용된 알고리즘과 키는 부록 A.3에서 사용된 것과 동일합니다. 따라서 결과 JWE 암호화 키 값은 동일합니다. 이러한 계산은 여기에서 반복되지 않습니다.

평문, CEK, JWE 초기화 벡터, JWE 보호 헤더는 모든 수신자에게 공유됩니다\(암호문과 인증 태그도 공유되므로 이는 당연한 일입니다\).

---
#### **A.4.1.  JWE Per-Recipient Unprotected Headers**

첫 번째 수신자는 RSAES-PKCS1-v1\_5 알고리즘을 사용하여 CEK를 암호화합니다. 두 번째 수신자는 AES Key Wrap을 사용하여 CEK를 암호화합니다. 두 키에 대한 키 ID 값이 제공됩니다. 이러한 알고리즘과 키 ID를 나타내는 데 사용되는 두 개의 JWE Per-Recipient Unprotected Header 값은 다음과 같습니다.

```text
     {"alg":"RSA1_5","kid":"2011-04-29"}

   and

     {"alg":"A128KW","kid":"7"}
```

---
#### **A.4.2.  JWE Protected Header**

인증된 암호화는 AES\_128\_CBC\_HMAC\_SHA\_256 알고리즘을 사용하여 일반 텍스트에서 수행되어 공통 JWE 암호문 및 JWE 인증 태그 값을 생성합니다. 이를 나타내는 JWE 보호 헤더 값은 다음과 같습니다.

```text
     {"enc":"A128CBC-HS256"}
```

이 JWE 보호 헤더를 BASE64URL\(UTF8\(JWE 보호 헤더\)\)로 인코딩하면 다음 값이 생성됩니다.

```text
     eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0
```

---
#### **A.4.3.  JWE Shared Unprotected Header**

이 JWE는 "jku" 헤더 매개변수를 사용하여 JWK 세트를 참조합니다. 이는 다음 JWE 공유 비보호 헤더 값에서 다음과 같이 표현됩니다.

```text
     {"jku":"https://server.example.com/keys.jwks"}
```

---
#### **A.4.4.  Complete JOSE Header Values**

제공된 JWE Per-Recipient Unprotected Header, JWE Protected Header 및 JWE Shared Unprotected Header 값을 결합하면 각각 첫 번째 및 두 번째 수신자에게 사용되는 JOSE Header 값은 다음과 같습니다.

```text
     {"alg":"RSA1_5",
      "kid":"2011-04-29",
      "enc":"A128CBC-HS256",
      "jku":"https://server.example.com/keys.jwks"}

   and

     {"alg":"A128KW",
      "kid":"7",
      "enc":"A128CBC-HS256",
      "jku":"https://server.example.com/keys.jwks"}
```

---
#### **A.4.5.  Additional Authenticated Data**

추가 인증 데이터 암호화 매개변수를 ASCII\(BASE64URL\(UTF8\(JWE 보호 헤더\)\)\)로 설정합니다. 이 값은 다음과 같습니다.

```text
   [101, 121, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66, 77, 84, 73,
   52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50, 73, 110, 48]
```

---
#### **A.4.6.  Content Encryption**

CEK를 암호화 키로, JWE 초기화 벡터, 위의 추가 인증 데이터 값을 사용하여 AES\_128\_CBC\_HMAC\_SHA\_256 알고리즘으로 일반 텍스트에 인증된 암호화를 수행합니다. 부록 A.3의 값을 사용하여 이를 수행하는 단계는 부록 B에 자세히 나와 있습니다. 결과 암호문은 다음과 같습니다.

```text
   [40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,
   75, 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,
   112, 56, 102]
```

결과 인증 태그 값은 다음과 같습니다.

```text
   [51, 63, 149, 60, 252, 148, 225, 25, 92, 185, 139, 245, 35, 2, 47,
   207]
```

이 JWE 암호문을 BASE64URL\(JWE 암호문\)로 인코딩하면 다음 값이 생성됩니다.

```text
     KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY
```

이 JWE 인증 태그를 BASE64URL\(JWE 인증 태그\)로 인코딩하면 다음 값이 생성됩니다.

```text
     Mz-VPPyU4RlcuYv1IwIvzw
```

---
#### **A.4.7.  Complete JWE JSON Serialization Representation**

이러한 값에 대한 전체 JWE JSON 직렬화는 다음과 같습니다\(표시 목적으로만 값 내에 줄 바꿈이 있음\):

```text
     {
      "protected":
       "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
      "unprotected":
       {"jku":"https://server.example.com/keys.jwks"},
      "recipients":[
       {"header":
         {"alg":"RSA1_5","kid":"2011-04-29"},
        "encrypted_key":
         "UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-
          kFm1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKx
          GHZ7PcHALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3
          YvkkysZIFNPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPh
          cCdZ6XDP0_F8rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPg
          wCp6X-nZZd9OHBv-B3oWh2TbqmScqXMR4gp_A"},
       {"header":
         {"alg":"A128KW","kid":"7"},
        "encrypted_key":
         "6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ"}],
      "iv":
       "AxY8DCtDaGlsbGljb3RoZQ",
      "ciphertext":
       "KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY",
      "tag":
       "Mz-VPPyU4RlcuYv1IwIvzw"
     }
```

---
### **A.5.  Example JWE Using Flattened JWE JSON Serialization**

이 섹션에는 평면화된 JWE JSON 직렬화 구문을 사용하는 예가 들어 있습니다. 이 예는 평면화된 JSON 구조에서 단일 수신자에게 평문을 암호화하는 기능을 보여줍니다.

이 예의 값은 부록 A.4의 이전 예에서 두 번째 수신자의 값과 동일합니다.

이러한 값에 대한 전체 JWE JSON 직렬화는 다음과 같습니다\(표시 목적으로만 값 내에 줄 바꿈이 있음\):

```text
     {
      "protected":
       "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
      "unprotected":
       {"jku":"https://server.example.com/keys.jwks"},
      "header":
       {"alg":"A128KW","kid":"7"},
      "encrypted_key":
       "6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ",
      "iv":
       "AxY8DCtDaGlsbGljb3RoZQ",
      "ciphertext":
       "KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY",
      "tag":
       "Mz-VPPyU4RlcuYv1IwIvzw"
     }
```

---
# **Appendix B.  Example AES_128_CBC_HMAC_SHA_256 Computation**

이 예에서는 부록 A.3의 예에서 값을 사용하여 AES\_128\_CBC\_HMAC\_SHA\_256 인증 암호화 계산의 단계를 보여줍니다. 이 알고리즘이 JWA의 섹션 5.2 및 5.2.3에서 정의된 대로, AES\_CBC\_HMAC\_SHA2 알고리즘 패밀리는 암호화를 수행하기 위해 공개 키 암호화 표준\(PKCS\) #7 패딩을 사용하는 CBC\(Cipher Block Chaining\) 모드에서 AES\(Advanced Encryption Standard\)를 사용하여 구현되고, 무결성 계산을 수행하기 위해 HMAC SHA-2 함수\(이 경우 HMAC SHA-256\)를 사용합니다.

---
### **B.1.  Extract MAC_KEY and ENC_KEY from Key**

이 예에서 사용된 256비트 AES\_128\_CBC\_HMAC\_SHA\_256 키 K\(JSON 배열 표기법 사용\)는 다음과 같습니다.

```text
   [4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106,
   206, 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156,
   44, 207]
```

이 키의 처음 128비트를 HMAC SHA-256 키 MAC\_KEY로 사용합니다. 이는 다음과 같습니다.

```text
   [4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106,
   206]
```

이 키의 마지막 128비트를 AES-CBC 키 ENC\_KEY로 사용합니다. 이는 다음과 같습니다.

```text
   [107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44,
   207]
```

입력 키 K에서 MAC 키가 암호화 키보다 앞에 오는 점에 유의하세요. 이것은 식별자 "AES\_128\_CBC\_HMAC\_SHA\_256" 및 "A128CBC-HS256"의 알고리즘 이름과 반대 순서입니다.

---
### **B.2.  Encrypt Plaintext to Create Ciphertext**

위의 ENC\_KEY를 사용하여 PKCS #7 패딩을 사용하여 CBC 모드에서 AES로 평문을 암호화합니다. 이 예의 평문은 다음과 같습니다.

```text
   [76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,
   112, 114, 111, 115, 112, 101, 114, 46]
```

암호화 결과는 다음과 같으며, 이는 암호문 출력입니다.

```text
   [40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,
   75, 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,
   112, 56, 102]
```

---
### **B.3.  64-Bit Big-Endian Representation of AAD Length**

이 예에서 추가 인증 데이터\(AAD\)는 다음과 같습니다.

```text
   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
   83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
   77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50, 73,
   110, 48]
```

이 AAD는 51바이트 길이로 408비트 길이입니다. AAD의 비트 수를 big-endian 64비트 부호 없는 정수로 표현한 옥텟 문자열 AL은 다음과 같습니다.

```text
   [0, 0, 0, 0, 0, 0, 1, 152]
```

---
### **B.4.  Initialization Vector Value**

이 예에서 사용된 초기화 벡터 값은 다음과 같습니다.

```text
   [3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104,
   101]
```

---
### **B.5.  Create Input to HMAC Computation**

AAD, 초기화 벡터, 암호문, AL 값을 연결합니다. 이 연결의 결과는 다음과 같습니다.

```text
   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
   83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
   77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50, 73,
   110, 48, 3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111,
   116, 104, 101, 40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24,
   152, 230, 6, 75, 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215,
   104, 143, 112, 56, 102, 0, 0, 0, 0, 0, 0, 1, 152]
```

---
### **B.6.  Compute HMAC Value**

위의 연결된 값의 HMAC SHA-256을 계산합니다. 이 결과 M은 다음과 같습니다.

```text
   [83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199, 133, 32, 38,
   194, 85, 9, 84, 229, 201, 219, 135, 44, 252, 145, 102, 179, 140, 105,
   86, 229, 116]
```

---
### **B.7.  Truncate HMAC Value to Create Authentication Tag**

HMAC 출력 M의 전반부\(128비트\)를 인증 태그 출력 T로 사용합니다. 이 잘린 값은 다음과 같습니다.

```text
   [83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199, 133, 32, 38,
   194, 85]
```

---
# **Acknowledgements**

JSON 콘텐츠를 암호화하기 위한 솔루션은 또한 "JSON Simple Encryption"\[JSE\] 및 "JavaScript Message Security Format"\[JSMS\]에서 탐구되었으며, 둘 다 이 문서에 상당한 영향을 미쳤습니다. 이 문서는 간단하고 컴팩트한 JSON 기반 데이터 구조를 활용하면서 가능한 한 XML Encryption 1.1\[W3C.REC-xmlenc-core1-20130411\] 및 RFC 5652\[RFC5652\]의 관련 개념을 명시적으로 재사용하려고 시도합니다.

이 사양서의 내용을 알리는 데 도움이 되는 토론에 참여해 주신 John Bradley, Eric Rescorla, Nat Sakimura에게 특별한 감사를 드리고, 이 문서에서 \[JSMS\]의 텍스트를 재사용할 수 있도록 허락해 주신 Eric Rescorla와 Joe Hildebrand에게, 그리고 이 사양서의 여러 초안을 공동으로 작성해 주신 Eric Rescorla에게 특별한 감사를 드리고자 합니다.

이 명세서의 예를 검증해 주신 Axel Nennker, Emmanuel Raviart, Brian Campbell, Edmund Jay에게 감사드립니다.

이 사양은 수십 명의 적극적이고 헌신적인 참여자를 포함하는 JOSE 작업 그룹의 작업입니다. 특히, 다음 개인은 이 사양에 영향을 준 아이디어, 피드백 및 문구를 제공했습니다.

리차드 반스, 존 브래들리, 브라이언 캠벨, 알리사 쿠퍼, 브레노 데 메데이로스, 스티븐 패럴, 딕 하트, 제프 호지스, 러스 하우스리, 에드먼드 제이, 스콧 켈리, 스티븐 켄트, 배리 레이바, 제임스 맨저, 맷 밀러, 캐슬린 모리아티, 토니 나달린, 히데키 나라, 악셀 넨커, 레이 폴크, 에마뉘엘 라비아르, 에릭 레스콜라, 피트 레스닉, 냇 사키무라, 짐 샤드, 하네스 초페닉, 숀 터너.

짐 샤드와 캐런 오도노휴는 JOSE 작업 그룹의 의장을 맡았고, 숀 터너, 스티븐 패럴, 캐슬린 모리아티는 이 사양을 작성하는 동안 보안 영역 책임자를 맡았습니다.

---
# **Authors' Addresses**

```text
   Michael B. Jones
   Microsoft

   EMail: mbj@microsoft.com
   URI:   http://self-issued.info/

   Joe Hildebrand
   Cisco Systems, Inc.

   EMail: jhildebr@cisco.com
```
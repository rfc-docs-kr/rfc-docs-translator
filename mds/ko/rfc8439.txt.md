

```text
Internet Research Task Force (IRTF)                               Y. Nir
Request for Comments: 8439                                      Dell EMC
Obsoletes: 7539                                               A. Langley
Category: Informational                                     Google, Inc.
ISSN: 2070-1721                                                June 2018

                ChaCha20 and Poly1305 for IETF Protocols
```

---
# **Abstract**

이 문서에서는 ChaCha20 스트림 암호와 Poly1305 인증자의 사용을 독립형 알고리즘과 "결합 모드" 또는 AEAD\(Authenticated Encryption with Associated Data\) 알고리즘으로 정의합니다.

이 문서의 전신인 RFC 7539는 안정적인 참조 및 구현 가이드 역할을 하기 위한 것입니다. CFRG\(Crypto Forum Research Group\)의 제품이었습니다. 이 문서는 RFC 7539에 대해 제출된 정오표를 병합하고 보안 고려 사항 섹션에 약간의 텍스트를 추가합니다.

---
# **Status of This Memo**

이 문서는 인터넷 표준 추적 사양이 아닙니다. 정보 제공의 목적으로 게시됩니다.

이 문서는 IRTF\(Internet Research Task Force\)의 제품입니다. IRTF는 인터넷 관련 연구 및 개발 활동의 결과를 발표합니다. 이러한 결과는 배포에 적합하지 않을 수 있습니다. 이 RFC는 IRTF\(Internet Research Task Force\)의 Crypto Forum Research Group의 합의를 나타냅니다. IRSG에서 출판을 승인한 문서는 어떤 수준의 인터넷 표준에도 적합하지 않습니다. RFC 7841의 섹션 2를 참조하십시오.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8439에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2018 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Conventions Used in This Document . . . . . . . . . . . .   5
   2.  The Algorithms  . . . . . . . . . . . . . . . . . . . . . . .   5
     2.1.  The ChaCha Quarter Round  . . . . . . . . . . . . . . . .   5
       2.1.1.  Test Vector for the ChaCha Quarter Round  . . . . . .   6
     2.2.  A Quarter Round on the ChaCha State . . . . . . . . . . .   6
       2.2.1.  Test Vector for the Quarter Round on the ChaCha State   7
     2.3.  The ChaCha20 Block Function . . . . . . . . . . . . . . .   7
       2.3.1.  The ChaCha20 Block Function in Pseudocode . . . . . .   9
       2.3.2.  Test Vector for the ChaCha20 Block Function . . . . .  10
     2.4.  The ChaCha20 Encryption Algorithm . . . . . . . . . . . .  11
       2.4.1.  The ChaCha20 Encryption Algorithm in Pseudocode . . .  12
       2.4.2.  Example and Test Vector for the ChaCha20 Cipher . . .  12
     2.5.  The Poly1305 Algorithm  . . . . . . . . . . . . . . . . .  14
       2.5.1.  The Poly1305 Algorithms in Pseudocode . . . . . . . .  16
       2.5.2.  Poly1305 Example and Test Vector  . . . . . . . . . .  17
     2.6.  Generating the Poly1305 Key Using ChaCha20  . . . . . . .  18
       2.6.1.  Poly1305 Key Generation in Pseudocode . . . . . . . .  19
       2.6.2.  Poly1305 Key Generation Test Vector . . . . . . . . .  19
     2.7.  A Pseudorandom Function for Crypto Suites Based on
           ChaCha/Poly1305 . . . . . . . . . . . . . . . . . . . . .  20
     2.8.  AEAD Construction . . . . . . . . . . . . . . . . . . . .  20
       2.8.1.  Pseudocode for the AEAD Construction  . . . . . . . .  23
       2.8.2.  Example and Test Vector for AEAD_CHACHA20_POLY1305  .  23
   3.  Implementation Advice . . . . . . . . . . . . . . . . . . . .  25
   4.  Security Considerations . . . . . . . . . . . . . . . . . . .  26
   5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  27
   6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  27
     6.1.  Normative References  . . . . . . . . . . . . . . . . . .  27
     6.2.  Informative References  . . . . . . . . . . . . . . . . .  28
   Appendix A.  Additional Test Vectors  . . . . . . . . . . . . . .  30
     A.1.  The ChaCha20 Block Functions  . . . . . . . . . . . . . .  30
     A.2.  ChaCha20 Encryption . . . . . . . . . . . . . . . . . . .  33
     A.3.  Poly1305 Message Authentication Code  . . . . . . . . . .  36
     A.4.  Poly1305 Key Generation Using ChaCha20  . . . . . . . . .  41
     A.5.  ChaCha20-Poly1305 AEAD Decryption . . . . . . . . . . . .  42
   Appendix B.  Performance Measurements of ChaCha20 . . . . . . . .  45
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  46
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  46
```

---
## **1.  Introduction**

고급 암호화 표준\(AES -- \[FIPS-197\]\)은 암호화의 표준이 되었습니다. 효율적인 설계, 광범위한 구현 및 하드웨어 지원을 통해 다양한 영역에서 높은 성능을 발휘할 수 있습니다. 대부분의 최신 플랫폼에서 AES는 이전에 가장 많이 사용된 암호인 Triple Data Encryption Standard\(3DES -- \[SP800-67\]\)보다 4배에서 10배 정도 빠릅니다. 실용적인 선택.

여기에는 몇 가지 문제가 있습니다. 향후 암호 분석의 발전으로 인해 AES의 약점이 드러날 경우 사용자는 불리한 위치에 놓이게 될 것입니다. 널리 지원되는 유일한 암호는 훨씬 느린 3DES이므로 3DES를 사용하도록 배포를 재구성하는 것은 불가능합니다. \[Standby-Cipher\]에서는 이 문제와 대기 암호의 필요성에 대해 더 자세히 설명합니다. 또 다른 문제는 AES가 전용 하드웨어에서는 매우 빠르지만 이러한 하드웨어가 없는 플랫폼에서는 성능이 상당히 낮다는 것입니다. 또 다른 문제는 많은 AES 구현이 캐시 충돌 타이밍 공격\(\[Cache-Collisions\]\)에 취약하다는 것입니다.

이 문서는 세 가지 알고리즘에 대한 정의 및 구현 가이드를 제공합니다.

1. ChaCha20 암호. \[ChaCha\]에서 최초로 기술된 고속암호이다. 소프트웨어 전용 구현에서는 AES보다 상당히 빠르므로 특수 AES 하드웨어가 없는 플랫폼에서는 약 3배 더 빠릅니다. 몇 가지 구체적인 수치는 부록 B를 참조하세요. ChaCha20은 또한 타이밍 공격에 민감하지 않습니다\(섹션 4의 보안 고려 사항 참조\). 이 알고리즘은 섹션 2.4에 설명되어 있습니다.

2. Poly1305 인증자. 고속 메시지 인증 코드입니다. 구현도 간단하고 올바르게 수행하기 쉽습니다. 알고리즘은 섹션 2.5에 설명되어 있습니다.

3. 섹션 2.8에 설명된 CHACHA20-POLY1305 AEAD\(Authenticated Encryption with Associated Data\) 구성.

이 문서와 이전 문서에서는 이러한 새로운 알고리즘을 처음으로 소개하지 않습니다. 이는 D. J. Bernstein \[ChaCha\]\[Poly1305\]의 과학 논문에서 정의되었습니다. 이 문서의 목적은 이러한 알고리즘을 사용하는 IETF 문서에 대한 안정적인 참조 역할을 하는 것입니다.

이러한 알고리즘은 엄격한 분석을 거쳤습니다. 여러 논문에서 Salsa 및 ChaCha의 보안에 대해 논의합니다\(\[LatinDances\], \[LatinDances2\], \[Zhenqing2012\]\).

이 문서는 CFRG\(Crypto Forum Research Group\)의 합의를 나타냅니다. 이는 \[RFC7539\]를 대체합니다.

---
### **1.1.  Conventions Used in This Document**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

ChaCha 알고리즘에 대한 설명에서는 ChaCha 상태를 "벡터" 또는 "행렬"로 지칭하는 경우가 많습니다. 이는 \[ChaCha\]에서 이러한 용어의 사용을 따릅니다. 행렬 표기법은 시각적으로 더 편리하며 일부 라운드를 "열 라운드"라고 부르는 반면 다른 라운드는 "대각선 라운드"라고 부르는 이유에 대해 더 나은 개념을 제공합니다. 다음은 행렬이 벡터와 어떻게 관련되는지 보여주는 다이어그램입니다\(인덱스 원점을 0으로 하는 C 언어 규칙 사용\).

```text
      0   1   2   3
      4   5   6   7
      8   9  10  11
     12  13  14  15
```

이 벡터 또는 행렬의 요소는 32비트 부호 없는 정수입니다.

알고리즘 이름은 "ChaCha"입니다. "ChaCha20"은 20개의 "라운드"\(또는 80개의 쿼터 라운드 - 섹션 2.1 참조\)가 사용되는 특정 인스턴스입니다. 8라운드 또는 12라운드로 다른 변형이 정의되어 있지만 이 문서에서는 20라운드 ChaCha만 설명하므로 "ChaCha"와 "ChaCha20"이라는 이름은 같은 의미로 사용됩니다.

---
## **2.  The Algorithms**

아래 하위 섹션에서는 사용된 알고리즘과 AEAD 구성을 설명합니다.

---
### **2.1.  The ChaCha Quarter Round**

ChaCha 알고리즘의 기본 연산은 1/4 라운드입니다. 이는 a, b, c 및 d로 표시된 4개의 32비트 부호 없는 정수에 대해 작동합니다. 작업은 다음과 같습니다\(C와 유사한 표기법\).

```text
      a += b; d ^= a; d <<<= 16;
      c += d; b ^= c; b <<<= 12;
      a += b; d ^= a; d <<<= 8;
      c += d; b ^= c; b <<<= 7;
```

여기서 "+"는 2^32 모듈로 정수 덧셈을 나타내고, "^"은 비트별 배타적 OR\(XOR\)을 나타내고, "<<< n"은 n비트 왼쪽 롤\(상위 비트 쪽으로\)을 나타냅니다.

예를 들어 샘플 번호가 포함된 네 번째 줄의 추가, XOR 및 롤 작업을 살펴보겠습니다.

a = 0x11111111

- b = 0x01020304 c = 0x77777777 d = 0x01234567 c = c + d = 0x77777777 + 0x01234567 = 0x789abcde b = b ^ c = 0x01020304 ^ 0x789abcde = 0x7998bfda b = b << < 7 = 0x7998bfda <<< 7 = 0xcc5fed3c

---
#### **2.1.1.  Test Vector for the ChaCha Quarter Round**

테스트 벡터의 경우 예제와 동일한 숫자를 사용하여 c에 임의의 것을 추가합니다.

a = 0x11111111

- b = 0x01020304 c = 0x9b8d6f43 d = 0x01234567

이 4개의 숫자에 대해 분기 라운드를 실행한 후 다음을 얻습니다.

a = 0xea2a92f4

- b = 0xcb1cf8ce c = 0x4581472e d = 0x5881c4bb

---
### **2.2.  A Quarter Round on the ChaCha State**

ChaCha 상태에는 4개의 정수가 없습니다. 16개입니다. 따라서 1/4 반올림 연산은 그 중 4개에서만 작동합니다. 따라서 이름이 붙여졌습니다. 각 분기 라운드는 ChaCha 상태에서 미리 결정된 4개의 숫자에 대해 작동됩니다. 벡터로 볼 때 ChaCha 상태의 인덱스 x, y, z 및 w에 있는 숫자에 대한 1/4 반올림 연산을 QUARTERROUND\(x, y, z, w\)로 표시합니다. 예를 들어, QUARTERROUND\(1, 5, 9, 13\)을 상태에 적용하면 별표가 표시된 요소에 대해 1/4 라운드 연산을 실행하고 다른 요소는 그대로 두는 것을 의미합니다.

```text
      0  *a   2   3
      4  *b   6   7
      8  *c  10  11
     12  *d  14  15
```

이 1/4 라운드 실행은 "컬럼 라운드"라고 불리는 것의 일부입니다.

---
#### **2.2.1.  Test Vector for the Quarter Round on the ChaCha State**

테스트 벡터의 경우 무작위로 생성된 ChaCha 상태를 사용합니다.

```text
   Sample ChaCha State

       879531e0  c5ecf37d  516461b1  c9a62f8a
       44c20ef3  3390af7f  d9fc690b  2a5f714c
       53372767  b00a5631  974c541a  359e9963
       5c971061  3d631689  2098d9d6  91dbd320
```

이 상태에 QUARTERROUND\(2, 7, 8, 13\) 연산을 적용하겠습니다. 분명한 이유로 이것은 "대각선 라운드"라고 불리는 것의 일부입니다.

```text
   After applying QUARTERROUND(2, 7, 8, 13)

       879531e0  c5ecf37d *bdb886dc  c9a62f8a
       44c20ef3  3390af7f  d9fc690b *cfacafd2
      *e46bea80  b00a5631  974c541a  359e9963
       5c971061 *ccc07c79  2098d9d6  91dbd320
```

위치 2, 7, 8, 13의 숫자만 변경되었습니다.

---
### **2.3.  The ChaCha20 Block Function**

ChaCha 블록 기능은 여러 분기 라운드를 실행하여 ChaCha 상태를 변환합니다.

ChaCha20에 대한 입력은 다음과 같습니다.

o 8개의 32비트 리틀 엔디안 정수 연결로 처리되는 256비트 키.

o 32비트 리틀 엔디안 정수 3개의 연결로 처리되는 96비트 nonce.

o 32비트 리틀 엔디안 정수로 처리되는 32비트 블록 수 매개변수.

출력은 무작위로 보이는 64바이트입니다.

여기에 설명된 ChaCha 알고리즘은 256비트 키를 사용합니다. 원래 알고리즘은 128비트 키와 8라운드 및 12라운드 변형도 지정했지만 이는 이 문서의 범위를 벗어납니다. 이번 장에서는 ChaCha 블록 기능에 대해 설명합니다.

또한 원본 ChaCha에는 64비트 nonce와 64비트 블록 수가 있었습니다. 우리는 \[RFC5116\] 섹션 3.2의 권장 사항과 더욱 일치하도록 이를 수정했습니다. 이는 단일 \(key,nonce\) 조합의 사용을 2^32 블록 또는 256GB로 제한하지만 대부분의 용도에는 충분합니다. 여러 발신자가 단일 키를 사용하는 경우 동일한 nonce를 사용하지 않는지 확인하는 것이 중요합니다. 처음 32비트는 발신자별로 고유하고 나머지 64비트는 카운터에서 나오도록 nonce 공간을 분할하면 이를 보장할 수 있습니다.

ChaCha20 상태는 다음과 같이 초기화됩니다.

o 처음 4개 단어\(0-3\)는 상수입니다: 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574.

o 다음 8개 단어\(4-11\)는 4바이트 청크의 리틀 엔디안 순서로 바이트를 읽어 256비트 키에서 가져옵니다.

o 워드 12는 블록 카운터입니다. 각 블록은 64바이트이므로 32비트 워드이면 256GB의 데이터에 충분합니다.

o 단어 13-15는 nonce이므로 동일한 키에 대해 반복되어서는 안 됩니다. 13번째 단어는 리틀 엔디안 정수로 간주되는 입력 넌스의 처음 32비트이고, 15번째 단어는 마지막 32비트입니다.\(MUST\)

```text
       cccccccc  cccccccc  cccccccc  cccccccc
       kkkkkkkk  kkkkkkkk  kkkkkkkk  kkkkkkkk
       kkkkkkkk  kkkkkkkk  kkkkkkkk  kkkkkkkk
       bbbbbbbb  nnnnnnnn  nnnnnnnn  nnnnnnnn

   c=constant k=key b=blockcount n=nonce
```

ChaCha20은 "기둥 라운드"와 "대각선 라운드"를 번갈아 가며 20라운드를 실행합니다. 각 라운드는 4개의 쿼터라운드로 구성되며, 다음과 같이 진행됩니다. 쿼터 라운드 1-4는 "열" 라운드의 일부이고, 5-8은 "대각선" 라운드의 일부입니다.

```text
      QUARTERROUND(0, 4, 8, 12)
      QUARTERROUND(1, 5, 9, 13)
      QUARTERROUND(2, 6, 10, 14)
      QUARTERROUND(3, 7, 11, 15)
      QUARTERROUND(0, 5, 10, 15)
      QUARTERROUND(1, 6, 11, 12)
      QUARTERROUND(2, 7, 8, 13)
      QUARTERROUND(3, 4, 9, 14)
```

20회 라운드\(또는 위 목록의 10회 반복\)가 끝나면 원래 입력 단어를 출력 단어에 추가하고 단어를 리틀 엔디안 순서로 하나씩 시퀀싱하여 결과를 직렬화합니다.

참고: 위 단락의 "추가"는 모듈로 2^32로 수행됩니다. 일부 기계어에서는 이를 32비트 단어에 대한 캐리리스 추가라고 합니다.

---
#### **2.3.1.  The ChaCha20 Block Function in Pseudocode**

참고: 이 섹션과 다른 섹션에는 이전 섹션에서 설명한 알고리즘에 대한 의사 코드가 포함되어 있습니다. 의사코드가 이전 섹션에서 설명한 알고리즘을 정확하게 반영하기 위해 모든 노력을 기울였습니다. 충돌이 여전히 존재하는 경우 텍스트 설명과 테스트 벡터가 규범적입니다.

```text
      inner_block (state):
         Qround(state, 0, 4, 8, 12)
         Qround(state, 1, 5, 9, 13)
         Qround(state, 2, 6, 10, 14)
         Qround(state, 3, 7, 11, 15)
         Qround(state, 0, 5, 10, 15)
         Qround(state, 1, 6, 11, 12)
         Qround(state, 2, 7, 8, 13)
         Qround(state, 3, 4, 9, 14)
         end
```

chacha20\_block\(키, 카운터, nonce\):

- 상태 = 상수 | 키 | 카운터 | nonceinitial\_state = i=1에서 최대 10까지의 상태 inner\_block\(state\) end state +=initial\_state return serialize\(state\) end

여기서 파이프 문자\("|"\)는 연결을 나타냅니다.

---
#### **2.3.2.  Test Vector for the ChaCha20 Block Function**

테스트 벡터의 경우 ChaCha20 블록 기능에 다음 입력을 사용합니다.

o 키 = 00:01:02:03:04:05:06:07:08:09:0a:0b:0c:0d:0e:0f:10:11:12:13: 14:15:16:17 :18:19:1a:1b:1c:1d:1e:1f. 키는 ChaCha 상태에 복사하기 전에 특별한 구조가 없는 일련의 옥텟입니다.

```text
   o  Nonce = (00:00:00:09:00:00:00:4a:00:00:00:00)

   o  Block Count = 1.
```

ChaCha 상태를 설정한 후의 모습은 다음과 같습니다.

키 설정이 완료된 차차 상태입니다.

```text
       61707865  3320646e  79622d32  6b206574
       03020100  07060504  0b0a0908  0f0e0d0c
       13121110  17161514  1b1a1918  1f1e1d1c
       00000001  09000000  4a000000  00000000
```

20개의 라운드\(10개의 "대각선 라운드"로 인터리브된 10개의 열 라운드\)를 실행한 후 ChaCha 상태는 다음과 같습니다.

20라운드 후 차차상태

```text
       837778ab  e238d763  a67ae21e  5950bb2f
       c4f2d0c7  fc62bb2f  8fa018fc  3f5ec7b7
       335271c2  f29489f3  eabda8fc  82e46ebd
       d19c12b4  b04e16de  9e83d0cb  4e3c50a2
```

마지막으로 원래 상태를 결과\(단순 벡터 또는 행렬 추가\)에 추가하여 다음을 제공합니다.

ChaCha20 작업 종료 시의 ChaCha 상태

```text
       e4e7f110  15593bd1  1fdd0f50  c47120a3
       c7f4d1c7  0368c033  9aaa2204  4e6cd4c3
       466482d2  09aa9f07  05d7c214  a2028bd9
       d19c12b5  b94e16de  e883d0cb  4e3c50a2
```

상태를 직렬화한 후에는 다음을 얻습니다.

```text
  Serialized Block:
  000  10 f1 e7 e4 d1 3b 59 15 50 0f dd 1f a3 20 71 c4  .....;Y.P.... q.
  016  c7 d1 f4 c7 33 c0 68 03 04 22 aa 9a c3 d4 6c 4e  ....3.h.."....lN
  032  d2 82 64 46 07 9f aa 09 14 c2 d7 05 d9 8b 02 a2  ..dF............
  048  b5 12 9c d1 de 16 4e b9 cb d0 83 e8 a2 50 3c 4e  ......N......P<N
```

---
### **2.4.  The ChaCha20 Encryption Algorithm**

ChaCha20은 D. J. Bernstein이 설계한 스트림 암호입니다. 이는 Salsa20 알고리즘을 개선한 것이며 256비트 키를 사용합니다.

ChaCha20은 동일한 키와 nonce를 사용하고 연속적으로 증가하는 블록 카운터 매개변수를 사용하여 ChaCha20 블록 함수를 연속적으로 호출합니다. 그런 다음 ChaCha20은 리틀 엔디안 순서로 숫자를 작성하여 결과 상태를 직렬화하고 키스트림 블록을 생성합니다. 연속 블록의 키스트림 블록을 연결하면 키스트림이 형성됩니다. 그런 다음 ChaCha20 함수는 이 키스트림을 일반 텍스트와 XOR합니다. 또는 다음 블록 생성을 진행하기 전에 각 키스트림 블록을 일반 텍스트 블록과 XOR하여 일부 메모리를 절약할 수 있습니다. 일반 텍스트가 512비트의 정수배가 되어야 한다는 요구 사항은 없습니다. 마지막 블록에 추가 키스트림이 있으면 폐기됩니다. 특정 프로토콜에서는 일반 텍스트와 암호문의 특정 길이를 요구할 수 있습니다. 이러한 프로토콜은 일반 텍스트가 채워지는 방식과 받는 패딩의 양을 지정해야 합니다.\(MAY\)

ChaCha20에 대한 입력은 다음과 같습니다.

o 256비트 키

o 32비트 초기 카운터. 임의의 숫자로 설정할 수 있지만 일반적으로 0 또는 1입니다. AEAD 알고리즘의 일부로 일회용 인증 키를 생성하는 등 다른 용도로 제로 블록을 사용하는 경우 하나를 사용하는 것이 합리적입니다.

o 96비트 논스. 일부 프로토콜에서는 이를

- 초기화 벡터.

o 임의 길이의 일반 텍스트

출력은 동일한 길이의 암호화된 메시지 또는 "암호문"입니다.

복호화도 같은 방식으로 이루어집니다. ChaCha20 블록 기능은 키를 키스트림으로 확장하는 데 사용되며, 이는 일반 텍스트를 반환하는 암호문과 XOR됩니다.

---
#### **2.4.1.  The ChaCha20 Encryption Algorithm in Pseudocode**

```text
     chacha20_encrypt(key, counter, nonce, plaintext):
        for j = 0 upto floor(len(plaintext)/64)-1
           key_stream = chacha20_block(key, counter+j, nonce)
           block = plaintext[(j*64)..(j*64+63)]
           encrypted_message +=  block ^ key_stream
           end
        if ((len(plaintext) % 64) != 0)
           j = floor(len(plaintext)/64)
           key_stream = chacha20_block(key, counter+j, nonce)
           block = plaintext[(j*64)..len(plaintext)-1]
           encrypted_message += (block^key_stream)[0..len(plaintext)%64]
           end
        return encrypted_message
        end
```

---
#### **2.4.2.  Example and Test Vector for the ChaCha20 Cipher**

테스트 벡터의 경우 ChaCha20 블록 기능에 다음 입력을 사용합니다.

```text
   o  Key = 00:01:02:03:04:05:06:07:08:09:0a:0b:0c:0d:0e:0f:10:11:12:13:
      14:15:16:17:18:19:1a:1b:1c:1d:1e:1f.

   o  Nonce = (00:00:00:00:00:00:00:4a:00:00:00:00).

   o  Initial Counter = 1.
```

일반 텍스트에는 다음을 사용합니다. 두 개 이상의 블록이 필요할 만큼 길지만 이 예제를 번거롭게 만들 만큼 길지는 않도록 선택되었습니다\(따라서 3개 블록 미만\).

일반 텍스트 자외선 차단제: 000 4c 61 64 69 65 73 20 61 6e 64 20 47 65 6e 74 6c Ladies and Gentl 016 65 6d 65 6e 20 6f 66 20 74 68 65 20 63 6c 61 73 emen of the class 03 2 73 20 6f 66 20 27 39 39 3a 20 49 66 20 49 20 99년 63초: 만약 내가 c 048 6f 75 6c 64 20 6f 66 66 65 72 20 79 6f 75 20 6f가 당신에게 064 6e 6c 79 20 6f 6을 제안한다면 전자 65 20 74 69 70 20 66 6f 72 20 080 74 68 65 20 66 75 74 75 72 65 2c 20 73 75 6e 73 미래, 태양에 대한 팁 하나만 096 63 72 65 65 6e 20 77 6f 75 6c 64 2 0 62 65 20 69 크린 나는 112 74 2e t일 것이다.

다음 그림은 4개의 ChaCha 상태 매트릭스를 보여줍니다.

1. 설정된 첫 번째 블록입니다.

2. 설정된 두 번째 블록. 이들 블록은 단지 2비트만 떨어져 있다는 점에 유의하십시오. 즉, 위치 12의 카운터만 다릅니다.

3. 세 번째 블록은 ChaCha20 블록 연산이 적용된 후 첫 번째 블록입니다.

4. 최종 블록은 ChaCha20 블록 다음의 두 번째 블록입니다.

- 연산이 적용되었습니다.

그 후 키스트림을 보여줍니다.

```text
   First block setup:
       61707865  3320646e  79622d32  6b206574
       03020100  07060504  0b0a0908  0f0e0d0c
       13121110  17161514  1b1a1918  1f1e1d1c
       00000001  00000000  4a000000  00000000

   Second block setup:
       61707865  3320646e  79622d32  6b206574
       03020100  07060504  0b0a0908  0f0e0d0c
       13121110  17161514  1b1a1918  1f1e1d1c
       00000002  00000000  4a000000  00000000
```

블록 작업 후 첫 번째 블록:

- f3514f22 e1d91b40 6f27de2f ed1d63b8 821f138c e2062c3d ecca4f7e 78cff39e a30a3b8a 920a6072 cd7479b5 34932bed 40ba4c79 cd343ec6 4c2c21ea b7 417df0

블록 작업 후 두 번째 블록:

- 9f74a669 410f633f 28feca22 7ec44dec 6d34d426 738cb970 3ac5e9f3 45590cc4 da6e8b39 892c831a cdea67c1 2b7e1d90 037463f3 a11a2073 e8bcfb88 edc49139

```text
   Keystream:
   22:4f:51:f3:40:1b:d9:e1:2f:de:27:6f:b8:63:1d:ed:8c:13:1f:82:3d:2c:06
   e2:7e:4f:ca:ec:9e:f3:cf:78:8a:3b:0a:a3:72:60:0a:92:b5:79:74:cd:ed:2b
   93:34:79:4c:ba:40:c6:3e:34:cd:ea:21:2c:4c:f0:7d:41:b7:69:a6:74:9f:3f
   63:0f:41:22:ca:fe:28:ec:4d:c4:7e:26:d4:34:6d:70:b9:8c:73:f3:e9:c5:3a
   c4:0c:59:45:39:8b:6e:da:1a:83:2c:89:c1:67:ea:cd:90:1d:7e:2b:f3:63
```

마지막으로 키스트림을 일반 텍스트와 XOR하여 암호문을 생성합니다.

```text
  Ciphertext Sunscreen:
  000  6e 2e 35 9a 25 68 f9 80 41 ba 07 28 dd 0d 69 81  n.5.%h..A..(..i.
  016  e9 7e 7a ec 1d 43 60 c2 0a 27 af cc fd 9f ae 0b  .~z..C`..'......
  032  f9 1b 65 c5 52 47 33 ab 8f 59 3d ab cd 62 b3 57  ..e.RG3..Y=..b.W
  048  16 39 d6 24 e6 51 52 ab 8f 53 0c 35 9f 08 61 d8  .9.$.QR..S.5..a.
  064  07 ca 0d bf 50 0d 6a 61 56 a3 8e 08 8a 22 b6 5e  ....P.jaV....".^
  080  52 bc 51 4d 16 cc f8 06 81 8c e9 1a b7 79 37 36  R.QM.........y76
  096  5a f9 0b bf 74 a3 5b e6 b4 0b 8e ed f2 78 5e 42  Z...t.[......x^B
  112  87 4d                                            .M
```

---
### **2.5.  The Poly1305 Algorithm**

Poly1305는 D. J. Bernstein이 디자인한 일회성 인증기입니다. Poly1305는 32바이트 일회용 키와 메시지를 가져와 16바이트 태그를 생성합니다. 이 태그는 메시지를 인증하는 데 사용됩니다.

```text
   The original article ([Poly1305]) is titled "The Poly1305-AES
   message-authentication code", and the MAC function there requires a
   128-bit AES key, a 128-bit "additional key", and a 128-bit (non-
   secret) nonce.  AES is used there for encrypting the nonce, so as to
   get a unique (and secret) 128-bit string, but as the paper states,
   "There is nothing special about AES here.  One can replace AES with
   an arbitrary keyed function from an arbitrary set of nonces to
   16-byte strings."
```

키 생성 방법에 관계없이 키는 "r"과 "s"라는 두 부분으로 분할됩니다. \(r,s\) 쌍은 고유해야 하며 각 호출에 대해 예측할 수 없어야 합니다\(이것이 원래 nonce를 암호화하여 얻은 이유입니다\). 반면 "r"은 상수일 수 있지만 사용하기 전에 다음과 같이 수정해야 합니다. : \("r"은 16옥텟 리틀 엔디안 숫자로 처리됩니다\):\(MUST\)

```text
   o  r[3], r[7], r[11], and r[15] are required to have their top four
      bits clear (be smaller than 16)

   o  r[4], r[8], and r[12] are required to have their bottom two bits
      clear (be divisible by 4)
```

다음 샘플 코드에서는 "r"이 적절하도록 고정됩니다.

```text
   /*
   Adapted from poly1305aes_test_clamp.c version 20050207
   D. J. Bernstein
   Public domain.
   */

   #include "poly1305aes_test.h"

   void poly1305aes_test_clamp(unsigned char r[16])
   {
     r[3] &= 15;
     r[7] &= 15;
     r[11] &= 15;
     r[15] &= 15;
     r[4] &= 252;
     r[8] &= 252;
     r[12] &= 252;
   }
```

여기서 "&="는 C 언어 비트 AND 할당 연산자입니다.

"s"는 예측할 수 없어야 하지만 매번 "r"과 "s"를 모두 고유하게 생성하는 것은 완벽하게 허용됩니다. 각각은 128비트이므로 의사 무작위로 생성하는 것\(섹션 2.6 참조\)도 허용됩니다.

Poly1305에 대한 입력은 다음과 같습니다.

o 256비트 일회용 키

o 임의 길이의 메시지

출력은 128비트 태그입니다.

먼저 "r" 값이 고정됩니다.

다음으로, 상수 소수 "P"를 2^130-5로 설정합니다: 3ffffffffffffffffffffffffffffffffb. 또한 변수 "accumulator"를 0으로 설정합니다.

다음으로 메시지를 16바이트 블록으로 나눕니다. 마지막 것은 더 짧을 수 있습니다.

o 블록을 리틀 엔디안 숫자로 읽습니다.

o 옥텟 수보다 1비트 더 추가합니다. 16바이트 블록의 경우 이는 숫자에 2^128을 추가하는 것과 같습니다. 더 짧은 경우

- 블록, 2^120, 2^112 또는 8로 균등하게 나눌 수 있는 2의 거듭제곱\(2^8까지\)이 될 수 있습니다.

o 블록의 길이가 17바이트가 아닌 경우\(마지막 블록\) 0으로 채웁니다. 블록을 숫자로 취급하는 경우 이는 의미가 없습니다.

o 이 숫자를 누산기에 추가합니다.

o "r"을 곱합니다.

o 누산기를 결과 모듈로 p로 설정합니다. 요약하자면: Acc = \(\(Acc+block\)\*r\) % p.

마지막으로 비밀 키 "s"의 값이 누산기에 추가되고 128개의 최하위 비트가 리틀 엔디안 순서로 직렬화되어 태그를 형성합니다.

---
#### **2.5.1.  The Poly1305 Algorithms in Pseudocode**

클램프\(r\): r &= 0x0ffffffc0ffffffc0ffffffc0fffffff

- poly1305\_mac\(msg, key\): r = le\_bytes\_to\_num\(key\[0..15\]\) clips\(r\) s = le\_bytes\_to\_num\(key\[16..31\]\) a = 0 /\* a는 누산기 \*/ p = \( 1<<130\)-5 for i=1 최대 ceil\(msg 길이\(바이트/16\)\) n = le\_bytes\_to\_num\(msg\[\(\(i-1\)\*16\)..\(i\*16\)\] | \[0x01\]\) a += n a = \(r \* a\) % p end a += s return num\_to\_16\_le\_bytes\(a\) end

---
#### **2.5.2.  Poly1305 Example and Test Vector**

이 예에서는 AES를 사용하여 일회용 키를 생성하지 않고 다음과 같은 키 관련 자료를 얻었다고 가정합니다.

```text
   o  Key Material: 85:d6:be:78:57:55:6d:33:7f:44:52:fe:42:d5:06:a8:01:0
      3:80:8a:fb:0d:b2:fd:4a:bf:f6:af:41:49:f5:1b
```

o 옥텟 문자열로:

- 01:03:80:8a:fb:0d:b2:fd:4a:bf:f6:af:41:49:f5:1b

o 128비트 숫자: 1bf54941aff6bf4afdb20dfb8a800301

또는 클램핑 전: 85:d6:be:78:57:55:6d:33:7f:44:52:fe:42:d5:06:a8

o r을 숫자로 고정: 806d5400e52447c036d555408bed685

메시지에는 다음과 같은 짧은 텍스트를 사용합니다.

```text
  Message to be Authenticated:
  000  43 72 79 70 74 6f 67 72 61 70 68 69 63 20 46 6f  Cryptographic Fo
  016  72 75 6d 20 52 65 73 65 61 72 63 68 20 47 72 6f  rum Research Gro
  032  75 70                                            up
```

Poly1305는 16바이트 청크로 작동하므로 34바이트 메시지는 3개의 블록으로 나뉩니다. 다음 계산에서 "Acc"는 누산기를 나타내고 "Block"은 현재 블록을 나타냅니다.

```text
   Block #1
```

Acc = 00 블록 = 6f4620636968706172676f7470797243 0x01 바이트의 블록 = 016f4620636968706172676f7470797243 Acc + 블록 = 016f4620636968706172676f74707972 43 \(Acc+차단\) \* r = b83fe991ca66800489155dcd69e8426ba2779453994ac90ed284034da565ecf Acc = \(\(Acc+차단\)\*r\) % P = 2c88c77849d64ae9147ddeb88e69c83fc

```text
   Block #2
```

Acc = 2c88c77849d64ae9147ddeb88e69c83fc 블록 = 6f7247206863726165736552206d7572 0x01 바이트의 블록 = 016f7247206863726165736552206d7572 Acc + 블록 = 437febe a505c820f2ad5150db0709f96e \(Acc+차단\) \* r = 21dcc992d0c659ba4036f65bb7f88562ae59b32c2b3b8f7efc8b00f78e548a26 Acc = \(\(Acc+차단\)\*r\) % P = 2d8adaf23b0337 fa7cccfb4ea344b30de

```text
   Last Block
```

Acc = 2d8adaf23b0337fa7cccfb4ea344b30de 블록 = 7075 0x01 바이트의 블록 = 017075 Acc + 블록 = 2d8adaf23b0337fa7cccfb4ea344ca153 \(Acc + 블록\) \* r = 16d8e08a0f3fe1de4fe4a15486aca7a27 0a29f1e6c849221e4a6798b8e45321f \(\(Acc + Block\) \* r\) % P = 28d31b7caff946c77c8844335369d03a7

s를 추가하면 이 번호를 얻고 태그를 얻으려면 직렬화합니다.

```text
   Acc + s = 2a927010caf8b2bc2c6365130c11d06a8

   Tag: a8:06:1d:c1:30:51:36:c6:c2:2b:8b:af:0c:01:27:a9
```

---
### **2.6.  Generating the Poly1305 Key Using ChaCha20**

섹션 2.5에서 설명한 대로 일회용 Poly1305 키를 의사 무작위로 생성하는 것이 허용됩니다. 이 섹션에서는 그러한 방법을 정의합니다.

이러한 키 쌍\(r,s\)을 생성하기 위해 섹션 2.3에 설명된 ChaCha20 블록 기능을 사용합니다. 여기서는 MAC\(메시지 인증 코드\) 기능을 위한 256비트 세션 키가 있다고 가정합니다. 일부 프로토콜에 대한 MAC 알고리즘으로 Poly1305 사용을 지정하는 모든 문서에서는 무결성 키에 256비트가 할당되도록 지정해야 합니다. 섹션 2.8에 정의된 AEAD 구성에서는 암호화 및 키 생성에 동일한 키가 사용됩니다.\(MUST\)

방법은 다음 매개변수를 사용하여 블록 함수를 호출하는 것입니다.

o 256비트 세션 무결성 키는 ChaCha20 키로 사용됩니다.

o 블록 카운터는 0으로 설정됩니다.

o 프로토콜은 96비트 또는 64비트 nonce를 지정합니다. 이는 동일한 키를 사용하는 호출마다 고유해야 하므로 무작위로 생성되어서는 안 됩니다. 카운터는 이를 구현하는 좋은 방법이지만 LFSR\(선형 피드백 시프트 레지스터\)과 같은 다른 방법도 허용됩니다. 여기에 지정된 대로 ChaCha20에는 96비트 nonce가 필요합니다. 따라서 제공된 nonce가 64비트인 경우 nonce의 처음 32비트는 상수로 설정됩니다. 이는 일반적으로 0이지만 여러 발신자가 있는 프로토콜의 경우 각 발신자마다 다를 수 있지만 특정 발신자가 동일한 키를 사용하는 모든 함수 호출에 대해 동일해야 합니다.\(MUST NOT, SHOULD\)

블록 기능을 실행하면 512비트 상태가 됩니다. 직렬화된 상태의 처음 256비트를 가져와 이를 일회용 Poly1305 키로 사용합니다. 처음 128비트는 고정되어 "r"을 형성하고 다음 128비트는 "s"가 됩니다. 나머지 256비트는 버려집니다.

많은 프로토콜에는 암호화 알고리즘\(종종 초기화 벡터 또는 IV라고 함\)에 대한 임시 조항이 있지만 일반적으로 MAC 기능에 대한 조항은 없습니다. 이 경우 호출별 nonce는 메시지 카운터와 같은 다른 곳에서 가져와야 합니다.

---
#### **2.6.1.  Poly1305 Key Generation in Pseudocode**

```text
      poly1305_key_gen(key,nonce):
         counter = 0
         block = chacha20_block(key,counter,nonce)
         return block[0..31]
         end
```

---
#### **2.6.2.  Poly1305 Key Generation Test Vector**

이 예에서는 다음을 설정합니다.

```text
  Key:
  000  80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f  ................
  016  90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f  ................

   Nonce:
   000  00 00 00 00 00 01 02 03 04 05 06 07              ............
```

키, nonce 및 블록 카운터 0이 포함된 ChaCha 상태 설정: 61707865 3320646e 79622d32 6b206574 83828180 87868584 8b8a8988 8f8e8d8c 93929190 97969594 9b9a9998 9f9e9d 9c 00000000 00000000 03020100 07060504

20라운드 후의 ChaCha 상태:

- 8ba0d58a cc815f90 27405081 7194b24a 37b633a8 a50dfde3 e2b8db08 46a6d1fd 7da03782 9183a233 148ad271 b46773d1 3cc1875a 8607def1 ca5c3086 7085eb87

```text
  Output bytes:
  000  8a d5 a0 8b 90 5f 81 cc 81 50 40 27 4a b2 94 71  ....._...P@'J..q
  016  a8 33 b6 37 e3 fd 0d a5 08 db b8 e2 fd d1 a6 46  .3.7...........F
```

그리고 해당 출력은 Poly1305에 사용되는 32바이트 일회용 키이기도 합니다.

---
### **2.7.  A Pseudorandom Function for Crypto Suites Based on ChaCha/Poly1305**

IKEv2\(\[RFC7296\]\)와 같은 일부 프로토콜에는 주로 키 파생을 위해 PRF\(의사 무작위 함수\)가 필요합니다. IKEv2 정의에서 PRF는 가변 길이 키와 가변 길이 입력을 허용하고 고정 길이 출력을 반환하는 함수입니다. 가장 일반적으로 해시된 MAC\(HMAC\) 구성이 이 목적으로 사용되며 메시지 인증과 PRF 모두에 동일한 기능이 사용되는 경우가 많습니다.

Poly1305는 PRF에 적합한 선택이 아닙니다. Poly1305는 동일한 키를 두 번 사용하는 것을 금지하는 반면, IKEv2의 PRF는 동일한 키로 여러 번 사용됩니다. 또한 HMAC와 달리 Poly1305는 편향되어 있으므로 키 파생에 이를 사용하면 대칭 암호화의 보안이 저하됩니다.

Chacha20은 임의로 긴 키 스트림을 생성하여 키 파생 함수로 사용될 수 있습니다. 그러나 이는 IKEv2와 같은 프로토콜이 요구하는 것이 아닙니다.

이러한 이유로 이 문서에서는 PRF를 지정하지 않습니다.

---
### **2.8.  AEAD Construction**

AEAD\_CHACHA20\_POLY1305는 추가 데이터 알고리즘을 사용한 인증된 암호화입니다. AEAD\_CHACHA20\_POLY1305에 대한 입력은 다음과 같습니다.

o 256비트 키

o 96비트 nonce - 동일한 키를 사용하여 호출할 때마다 다릅니다.

o 임의 길이의 일반 텍스트

```text
   o  Arbitrary length additional authenticated data (AAD)
```

일부 프로토콜에는 길이가 96비트가 아닌 고유한 호출별 입력이 있을 수 있습니다. 예를 들어 IPsec은 64비트 nonce를 지정할 수 있습니다. 그러한 경우, 예를 들어 상수 값을 연결하여 프로토콜 임시값을 96비트 임시값으로 변환하는 방법을 정의하는 것은 프로토콜 문서에 달려 있습니다.

ChaCha20 및 Poly1305 프리미티브는 다음과 같이 256비트 키와 96비트 nonce를 사용하는 AEAD로 결합됩니다.

o 먼저, 섹션 2.6에 설명된 절차를 사용하여 256비트 키와 nonce에서 Poly1305 일회용 키가 생성됩니다.

o 다음으로 ChaCha20 암호화 함수를 호출하여 동일한 키와 nonce를 사용하고 초기 카운터를 1로 설정하여 일반 텍스트를 암호화합니다.

o 마지막으로 위에서 계산된 Poly1305 키를 사용하여 Poly1305 함수가 호출되고 다음 내용을 연결하여 메시지가 구성됩니다.

- \* AAD

- \* padding1 -- 패딩은 최대 15개의 0바이트이며, 지금까지의 전체 길이는 16의 정수배가 됩니다. AAD의 길이가 이미 16바이트의 정수배인 경우 이 필드는 길이가 0입니다. .

- \* 암호문

- \* padding2 -- 패딩은 최대 15개의 0바이트이며 총 길이는 16의 정수배가 됩니다. 암호문의 길이가 이미 16바이트의 정수배인 경우 이 필드는 길이가 0입니다. .

- \* 옥텟 단위의 추가 데이터 길이입니다\(64비트 리틀 엔디안 정수\).

- \* 옥텟 단위의 암호문 길이입니다\(64비트 리틀 엔디안 정수\).

AEAD의 출력은 다음을 연결한 것입니다.

o 평문과 동일한 길이의 암호문.

o Poly1305 기능의 출력인 128비트 태그.

복호화는 다음과 같은 차이점을 제외하고 유사합니다.

o 암호문과 평문의 역할이 바뀌므로 암호문에 ChaCha20 암호화 기능을 적용하여 평문을 생성한다.

o Poly1305 기능은 일반 텍스트가 아닌 AAD 및 암호문에서 계속 실행됩니다.

o 계산된 태그는 수신된 태그와 비트 단위로 비교됩니다. 태그가 일치하는 경우에만 메시지가 인증됩니다.

이 디자인에 대한 몇 가지 참고 사항:

1. 단일 호출에서 가능한 암호화된 데이터의 양은 ChaCha20 블록 함수의 블록 카운터 필드 크기로 인해 각각 64바이트의 2^32-1 블록입니다. 이는 총 274,877,906,880바이트 또는 거의 256GB를 제공합니다. 이는 IPsec 및 TLS와 같은 트래픽 프로토콜에는 충분하지만 파일 및/또는 디스크 암호화에는 너무 작을 수 있습니다. 이러한 용도로 원래 설계로 돌아가 nonce를 64비트로 줄이고 위치 13의 정수를 64비트 블록 카운터의 상위 32비트로 사용하여 전체 메시지 크기를 백만 페타바이트 이상으로 늘릴 수 있습니다\( 정확히는 1,180,591,620,717,411,303,360바이트\).

2. 이전 항목에도 불구하고 Poly1305가 실행되는 버퍼 구성의 암호문 길이 필드는 암호문\(및 일반 텍스트\) 크기를 2^64바이트, 즉 16,000페타바이트\(정확히는 18,446,744,073,709,551,616바이트\)로 제한합니다.

이 섹션의 AEAD 구성은 ChaCha20과 Poly1305의 새로운 구성입니다. 이 구성에 대한 보안 분석은 \[Procter\]에 나와 있습니다.

다음은 \[RFC5116\]의 섹션 4에 정의된 이 구성에 대한 매개변수 목록입니다.

o K\_LEN\(키 길이\)은 32옥텟입니다.

o P\_MAX\(일반 텍스트의 최대 크기\)는 274,877,906,880바이트 또는 거의 256GB입니다.

o A\_MAX\(연관 데이터의 최대 크기\)는 연관 데이터의 길이 필드에 의해 2^64-1 옥텟으로 설정됩니다.

```text
   o  N_MIN = N_MAX = 12 octets.

   o  C_MAX = P_MAX + tag length = 274,877,906,896 octets.
```

고유한 AAD 입력\(\[RFC5116\]의 섹션 3.3에 설명됨\)은 AEAD\_CHACHA20\_POLY1305에 대한 단일 입력으로 연결되어야 합니다. 필요한 경우 AAD 입력에 구조를 만드는 것은 애플리케이션에 달려 있습니다.

---
#### **2.8.1.  Pseudocode for the AEAD Construction**

패드16\(x\):

- if \(len\(x\) % 16\)==0이면 NULL을 반환하고 그렇지 않으면 복사본\(0, 16-\(len\(x\)%16\)\)을 반환합니다. end

```text
      chacha20_aead_encrypt(aad, key, iv, constant, plaintext):
         nonce = constant | iv
         otk = poly1305_key_gen(key, nonce)
         ciphertext = chacha20_encrypt(key, 1, nonce, plaintext)
         mac_data = aad | pad16(aad)
         mac_data |= ciphertext | pad16(ciphertext)
         mac_data |= num_to_8_le_bytes(aad.length)
         mac_data |= num_to_8_le_bytes(ciphertext.length)
         tag = poly1305_mac(mac_data, otk)
         return (ciphertext, tag)
```

---
#### **2.8.2.  Example and Test Vector for AEAD_CHACHA20_POLY1305**

테스트 벡터의 경우 AEAD\_CHACHA20\_POLY1305 함수에 다음 입력을 사용합니다.

평문: 000 4c 61 64 69 65 73 20 61 6e 64 20 47 65 6e 74 6c Ladies and Gentl 016 65 6d 65 6e 20 6f 66 20 74 68 65 20 63 6c 61 73 emen of the class 032 73 20 6f 66 20 27 39 39 3a 20 49 66 20 49 20 99년 63초: 만약 내가 c 048 6f 75 6c 64 20 6f 66 66 65 72 20 79 6f 75 20 6f가 당신에게 064 6e 6c 79 20 6f 6e 6을 제안한다면 5 20 74 69 70 20 66 6f 72 20 080 74 68 65 20 66 75 74 75 72 65 2c 20 73 75 6e 73 미래, 태양에 대한 팁 하나만 096 63 72 65 65 6e 20 77 6f 75 6c 64 20 6 2 65 20 69 크린 것 나 112 74 2e t야.

```text
   AAD:
   000  50 51 52 53 c0 c1 c2 c3 c4 c5 c6 c7              PQRS........

  Key:
  000  80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f  ................
  016  90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f  ................

   IV:
   000  40 41 42 43 44 45 46 47                          @ABCDEFG

   32-bit fixed-common part:
   000  07 00 00 00                                      ....
```

Poly1305 일회용 키 생성을 위한 설정\(발신자 ID=7\):

- 61707865 3320646e 79622d32 6b206574 83828180 87868584 8b8a8988 8f8e8d8c 93929190 97969594 9b9a9998 9f9e9d9c 00000000 000 00007 43424140 47464544

Poly1305 일회용 키를 생성한 후:

- 252bac7b af47b42d 557ab609 8455e9a4 73d6e10a ebd97510 7875932a ff53d53e decc7ea2 b44ddbad e49c17d1 d8430bc9 8c94b7bc 8b7d4b4b 3927f67d 166 9a432

```text
  Poly1305 Key:
  000  7b ac 2b 25 2d b4 47 af 09 b6 7a 55 a4 e9 55 84  {.+%-.G...zU..U.
  016  0a e1 d6 73 10 75 d9 eb 2a 93 75 78 3e d5 53 ff  ...s.u..*.ux>.S.

  Poly1305 r =  455e9a4057ab6080f47b42c052bac7b
  Poly1305 s = ff53d53e7875932aebd9751073d6e10a

   keystream bytes:
   9f:7b:e9:5d:01:fd:40:ba:15:e2:8f:fb:36:81:0a:ae:
   c1:c0:88:3f:09:01:6e:de:dd:8a:d0:87:55:82:03:a5:
   4e:9e:cb:38:ac:8e:5e:2b:b8:da:b2:0f:fa:db:52:e8:
   75:04:b2:6e:be:69:6d:4f:60:a4:85:cf:11:b8:1b:59:
   fc:b1:c4:5f:42:19:ee:ac:ec:6a:de:c3:4e:66:69:78:
   8e:db:41:c4:9c:a3:01:e1:27:e0:ac:ab:3b:44:b9:cf:
   5c:86:bb:95:e0:6b:0d:f2:90:1a:b6:45:e4:ab:e6:22:
   15:38
```

암호문: 000 d3 1a 8d 34 64 8e 60 db 7b 86 af bc 53 ef 7e c2 ...4d.\`.{...S.\~. 016 a4 광고 51 29 6e 08 fe a9 e2 b5 a7 36 ee 62 d6 ...Q\)n......6.b. 032 3d be a4 5e 8c a9 67 12 82 fa fb 69 da 92 72 8b =..^..g....i..r. 048 1a 71 de 0a 9e 06 0b 29 05 d6 a5 b6 7e cd 3b 36 .q.....\)....\~.;6 064 92 dd bd 7f 2d 77 8b 8c 98 03 ae e3 28 09 1b 58 ....-w......\(..X 080 fa b3 24 e4 fa d6 75 94 55 85 80 8b 48 31 d7 bc ..$...u.U...H1.. 096 3f f4 de f0 8e 4b 7a 9d e5 76 d2 65 86 ce c6 4b ?....Kz..v.e...K 112 61 16 a.

```text
  AEAD Construction for Poly1305:
  000  50 51 52 53 c0 c1 c2 c3 c4 c5 c6 c7 00 00 00 00  PQRS............
  016  d3 1a 8d 34 64 8e 60 db 7b 86 af bc 53 ef 7e c2  ...4d.`.{...S.~.
  032  a4 ad ed 51 29 6e 08 fe a9 e2 b5 a7 36 ee 62 d6  ...Q)n......6.b.
  048  3d be a4 5e 8c a9 67 12 82 fa fb 69 da 92 72 8b  =..^..g....i..r.
  064  1a 71 de 0a 9e 06 0b 29 05 d6 a5 b6 7e cd 3b 36  .q.....)....~.;6
  080  92 dd bd 7f 2d 77 8b 8c 98 03 ae e3 28 09 1b 58  ....-w......(..X
  096  fa b3 24 e4 fa d6 75 94 55 85 80 8b 48 31 d7 bc  ..$...u.U...H1..
  112  3f f4 de f0 8e 4b 7a 9d e5 76 d2 65 86 ce c6 4b  ?....Kz..v.e...K
  128  61 16 00 00 00 00 00 00 00 00 00 00 00 00 00 00  a...............
  144  0c 00 00 00 00 00 00 00 72 00 00 00 00 00 00 00  ........r.......
```

000행에 4개의 0바이트가 있고 128행에 14개의 0바이트가 있습니다.

```text
   Tag:
   1a:e1:0b:59:4f:09:e2:6a:7e:90:2e:cb:d0:60:06:91
```

---
## **3.  Implementation Advice**

ChaCha20의 각 블록에는 상태 로드를 위한 16개의 이동 작업과 1개의 증분 작업, 각 80개의 XOR, 라운드에 대한 추가 및 롤 작업, 16개의 추가 추가 작업 및 일반 텍스트 보호를 위한 16개의 XOR 작업이 포함됩니다. 섹션 2.3에서는 ChaCha 블록 기능을 "원래 입력 단어 추가"로 설명합니다. 이는 ChaCha 상태에서 라운드를 시작하기 전에 이를 따로 복사하고 나중에 추가한다는 것을 의미합니다. 이는 맞습니다. 그러나 대신 상태를 복사하고 복사본에 대한 작업을 수행하면 몇 가지 작업을 저장할 수 있습니다. 이렇게 하면 다음 블록에 대해 상태를 다시 생성할 필요가 없고 블록 카운터만 증가시킬 필요가 있습니다. 이로써 사이클의 약 5.5%가 절약됩니다.

Poly1305의 산술 연산을 위해 OpenSSL과 같은 일반적인 큰 숫자 라이브러리를 사용하는 것은 권장되지 않습니다. 이러한 라이브러리는 동적 할당을 사용하여 모든 크기의 정수를 처리할 수 있지만 이러한 유연성에는 성능과 부채널 보안이 희생됩니다. 일정한 시간에 실행되는 보다 효율적인 구현을 사용할 수 있으며 그 중 하나는 DJ Bernstein의 자체 라이브러리인 NaCl\(\[NaCl\]\)에 있습니다. 상수 시간이지만 최적이 아닌 접근 방식은 288비트 정수에 대한 산술 연산을 순진하게 구현하는 것입니다. 순진한 구현이라도 \(acc+block\)과 r의 곱셈에서 2^288을 초과하지 않기 때문입니다. 효율적인 상수 시간 구현은 공개 도메인 라이브러리 poly1305-donna\(\[Poly1305\_Donna\]\)에서 찾을 수 있습니다.

---
## **4.  Security Considerations**

ChaCha20 암호는 256비트 보안을 제공하도록 설계되었습니다.

Poly1305 인증자는 2^64개의 합법적인 메시지를 보낸 후에도 16n바이트 메시지에 대해 1-\(n/\(2^102\)\)의 확률로 위조된 메시지가 거부되도록 설계되었으므로 SUF-CMA\( 선택한 메시지 공격에 대한 강력한 위조 불가능성\)을 \[AE\]라는 용어로 사용합니다.

이들 중 하나의 보안을 증명하는 것은 이 문서의 범위를 벗어납니다. 이러한 증명은 참조 학술 논문\(\[ChaCha\], \[Poly1305\], \[LatinDances\], \[LatinDances2\] 및 \[Zhenqing2012\]\)에서 확인할 수 있습니다.

이 문서를 구현할 때 가장 중요한 보안 고려 사항은 ChaCha20에서 사용되는 nonce의 고유성입니다. DES와 같은 64비트 블록 크기의 블록 암호를 사용하여 카운터를 암호화하는 것처럼 카운터와 LFSR은 모두 고유 nonce를 생성하는 데 허용되는 방법입니다. 128비트 또는 256비트 블록의 블록 암호로 암호화된 카운터의 절단을 사용하는 것은 허용되지 않습니다. 이러한 절단은 짧은 시간 후에 반복될 수 있기 때문입니다.

Nonce 반복의 결과: Nonce가 반복되면 메시지 간에 일회용 Poly1305 키와 키 스트림이 모두 동일합니다. 이는 일반 텍스트의 XOR이 암호문의 XOR과 동일하기 때문에 일반 텍스트의 XOR을 나타냅니다.

Poly1305 키는 공격자가 예측할 수 없어야 합니다. 키를 무작위로 생성하면 이 요구 사항을 충족할 수 있습니다. 단, Poly1305는 통신 프로토콜에 자주 사용되므로 수신자가 키를 알아야 합니다. 카운터 암호화와 같은 의사 난수 생성이 허용됩니다. 비밀 키와 nonce와 함께 ChaCha를 사용하는 것도 허용됩니다.\(MUST\)

여기에 제시된 알고리즘은 부채널 취약점을 방지하기 위해 일정한 시간에 쉽게 구현할 수 있도록 설계되었습니다. ChaCha20에서 사용되는 연산은 모두 덧셈, XOR, 고정롤입니다. 이 모든 것은 일정한 시간 내에 구현될 수 있고 구현되어야 합니다. ChaCha 상태에 대한 오프셋에 대한 액세스 및 작업 수는 키의 속성에 의존하지 않으므로 캐시 누락 타이밍을 통해 키에 대한 정보가 유출될 가능성이 없습니다.

Poly1305의 경우 연산은 덧셈, 곱셈입니다. 모듈러스는 모두 128비트보다 큰 숫자에 적용됩니다. 이는 상수 시간에 수행될 수 있지만 일반적인 큰 숫자 라이브러리 사용과 같은 순진한 구현은 상수 시간이 아닙니다. 예를 들어, 곱셈이 연산과 별도의 연산으로 수행되는 경우

모듈러스의 경우 결과는 때때로 2^256 미만일 수도 있고 때로는 2^256 이상일 수도 있습니다. 구현자는 이러한 작업의 적절한 구현을 사용하여 Poly1305의 부채널 타이밍에 주의해야 합니다.

메시지의 신뢰성을 검증하려면 계산된 태그와 수신된 태그를 비트 단위로 비교해야 합니다. 대부분의 사용 사례에서 nonce와 AAD 콘텐츠는 유효한 메시지가 수신될 때까지 "사용"되지 않습니다. 이를 통해 공격자는 태그 비교를 통과할 때까지 서로 다른 태그를 사용하여 여러 개의 동일한 메시지를 보낼 수 있습니다. 공격자가 2^128개의 가능한 모든 태그를 하나씩 시도해야 한다면 이는 어렵습니다. 그러나 태그 비교 동작의 타이밍을 통해 계산된 태그와 수신된 태그의 프리픽스가 얼마나 동일한지 알 수 있다면 메시지 수를 크게 줄일 수 있다. 이러한 이유로 온라인 프로토콜의 구현에서는 C 언어의 memcmp\(\)와 같이 최적화되었지만 안전하지 않은 라이브러리 기능에 의존하기보다는 상수 시간 비교 기능을 사용해야 합니다.\(MUST\)

또한 이 알고리즘을 사용하는 모든 프로토콜은 위조 가능성을 최소화하기 위해 완전한 태그를 포함해야 합니다. 태그 잘림은 수행되어서는 안 됩니다.\(MUST, MUST NOT\)

---
## **5.  IANA Considerations**

IANA는 이 문서를 참조로 가리키도록 숫자 ID가 29이고 이름이 "AEAD\_CHACHA20\_POLY1305"인 "AEAD\(Authenticated Encryption with Associated Data\) 매개변수" 레지스트리 항목을 업데이트했습니다.

---
## **6.  References**
---
### **6.1.  Normative References**

```text
   [ChaCha]   Bernstein, D., "ChaCha, a variant of Salsa20", January
              2008, <http://cr.yp.to/chacha/chacha-20080128.pdf>.

   [Poly1305]
              Bernstein, D., "The Poly1305-AES message-authentication
              code", March 2005,
              <http://cr.yp.to/mac/poly1305-20050329.pdf>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.
```

---
### **6.2.  Informative References**

```text
   [AE]       Bellare, M. and C. Namprempre, "Authenticated Encryption:
              Relations among notions and analysis of the generic
              composition paradigm", DOI 10.1007/s00145-008-9026-x,
              September 2008,
              <http://dl.acm.org/citation.cfm?id=1410269>.

   [Cache-Collisions]
              Bonneau, J. and I. Mironov, "Cache-Collision Timing
              Attacks Against AES", 2006,
              <http://research.microsoft.com/pubs/64024/aes-timing.pdf>.

   [FIPS-197]
              National Institute of Standards and Technology, "Advanced
              Encryption Standard (AES)", FIPS PUB 197, November 2001,
              <http://csrc.nist.gov/publications/fips/fips197/
              fips-197.pdf>.

   [LatinDances]
              Aumasson, J., Fischer, S., Khazaei, S., Meier, W., and C.
              Rechberger, "New Features of Latin Dances: Analysis of
              Salsa, ChaCha, and Rumba", December 2007,
              <http://cr.yp.to/rumba20/newfeatures-20071218.pdf>.

   [LatinDances2]
              Ishiguro, T., Kiyomoto, S., and Y. Miyake, "Modified
              version of 'Latin Dances Revisited: New Analytic Results
              of Salsa20 and ChaCha'", February 2012,
              <https://eprint.iacr.org/2012/065.pdf>.

   [NaCl]     Bernstein, D., Lange, T., and P. Schwabe, "NaCl:
              Networking and Cryptography library", July 2012,
              <http://nacl.cr.yp.to>.

   [Poly1305_Donna]
              "poly1305-donna", commit e6ad6e0, March 2016,
              <https://github.com/floodyberry/poly1305-donna>.

   [Procter]  Procter, G., "A Security Analysis of the Composition of
              ChaCha20 and Poly1305", August 2014,
              <http://eprint.iacr.org/2014/613.pdf>.

   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,
              <https://www.rfc-editor.org/info/rfc5116>.

   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, RFC 7296, DOI 10.17487/RFC7296, October
              2014, <https://www.rfc-editor.org/info/rfc7296>.

   [RFC7539]  Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF
              Protocols", RFC 7539, DOI 10.17487/RFC7539, May 2015,
              <https://www.rfc-editor.org/info/rfc7539>.

   [SP800-67]
              National Institute of Standards and Technology,
              "Recommendation for the Triple Data Encryption Algorithm
              (TDEA) Block Cipher", NIST 800-67, Rev. 2, November 2017,
              <https://csrc.nist.gov/publications/detail/sp/800-67/
              rev-2/final>.
```

\[대기-암호화\]

- McGrew, D., Grieco, A. 및 Y. Sheffer, "미래 암호화 표준 선택", 진행 중인 작업, 초안-mcgrew-standby-cipher-00, 2013년 1월.

\[진칭2012\]

- Zhenqing, S., Bin, Z., Dengguo, F. 및 W. Wenling, "축소 라운드 Salsa20 및 ChaCha\*에 대한 키 복구 공격 개선", 2012.

---
# **Appendix A.  Additional Test Vectors**

이 부록의 하위 섹션에는 섹션 2의 하위 섹션에 있는 알고리즘에 대한 더 많은 테스트 벡터가 포함되어 있습니다.

---
### **A.1.  The ChaCha20 Block Functions**

```text
  Test Vector #1:
  ==============

  Key:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 00              ............

  Block Counter = 0

    ChaCha state at the end
        ade0b876  903df1a0  e56a5d40  28bd8653
        b819d2bd  1aed8da0  ccef36a8  c70d778b
        7c5941da  8d485751  3fe02477  374ad8b8
        f4b8436a  1ca11815  69b687c3  8665eeb2

  Keystream:
  000  76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28  v.....=.@]j.S..(
  016  bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7  .........6...w..
  032  da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37  .AY|QWH.w$.?..J7
  048  6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86  jC.........i..e.

  Test Vector #2:
  ==============

  Key:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 00              ............

  Block Counter = 1

    ChaCha state at the end
        bee7079f  7a385155  7c97ba98  0d082d73
        a0290fcb  6965e348  3e53c612  ed7aee32
        7621b729  434ee69c  b03371d5  d539d874
        281fed31  45fb0a51  1f0ae1ac  6f4d794b

  Keystream:
  000  9f 07 e7 be 55 51 38 7a 98 ba 97 7c 73 2d 08 0d  ....UQ8z...|s-..
  016  cb 0f 29 a0 48 e3 65 69 12 c6 53 3e 32 ee 7a ed  ..).H.ei..S>2.z.
  032  29 b7 21 76 9c e6 4e 43 d5 71 33 b0 74 d8 39 d5  ).!v..NC.q3.t.9.
  048  31 ed 1f 28 51 0a fb 45 ac e1 0a 1f 4b 79 4d 6f  1..(Q..E....KyMo

  Test Vector #3:
  ==============

  Key:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01  ................

  Nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 00              ............

  Block Counter = 1

    ChaCha state at the end
        2452eb3a  9249f8ec  8d829d9b  ddd4ceb1
        e8252083  60818b01  f38422b8  5aaa49c9
        bb00ca8e  da3ba7b4  c4b592d1  fdf2732f
        4436274e  2561b3c8  ebdd4aa6  a0136c00

  Keystream:
  000  3a eb 52 24 ec f8 49 92 9b 9d 82 8d b1 ce d4 dd  :.R$..I.........
  016  83 20 25 e8 01 8b 81 60 b8 22 84 f3 c9 49 aa 5a  . %....`."...I.Z
  032  8e ca 00 bb b4 a7 3b da d1 92 b5 c4 2f 73 f2 fd  ......;...../s..
  048  4e 27 36 44 c8 b3 61 25 a6 4a dd eb 00 6c 13 a0  N'6D..a%.J...l..

  Test Vector #4:
  ==============

  Key:
  000  00 ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 00              ............

  Block Counter = 2

    ChaCha state at the end
        fb4dd572  4bc42ef1  df922636  327f1394
        a78dea8f  5e269039  a1bebbc1  caf09aae
        a25ab213  48a6b46c  1b9d9bcb  092c5be6
        546ca624  1bec45d5  87f47473  96f0992e
```

```text
  Keystream:
  000  72 d5 4d fb f1 2e c4 4b 36 26 92 df 94 13 7f 32  r.M....K6&.....2
  016  8f ea 8d a7 39 90 26 5e c1 bb be a1 ae 9a f0 ca  ....9.&^........
  032  13 b2 5a a2 6c b4 a6 48 cb 9b 9d 1b e6 5b 2c 09  ..Z.l..H.....[,.
  048  24 a6 6c 54 d5 45 ec 1b 73 74 f4 87 2e 99 f0 96  $.lT.E..st......
```

```text
  Test Vector #5:
  ==============

  Key:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 02              ............

  Block Counter = 0

    ChaCha state at the end
        374dc6c2  3736d58c  b904e24a  cd3f93ef
        88228b1a  96a4dfb3  5b76ab72  c727ee54
        0e0e978a  f3145c95  1b748ea8  f786c297
        99c28f5f  628314e8  398a19fa  6ded1b53

  Keystream:
  000  c2 c6 4d 37 8c d5 36 37 4a e2 04 b9 ef 93 3f cd  ..M7..67J.....?.
  016  1a 8b 22 88 b3 df a4 96 72 ab 76 5b 54 ee 27 c7  ..".....r.v[T.'.
  032  8a 97 0e 0e 95 5c 14 f3 a8 8e 74 1b 97 c2 86 f7  .....\....t.....
  048  5f 8f c2 99 e8 14 83 62 fa 19 8a 39 53 1b ed 6d  _......b...9S..m
```

---
### **A.2.  ChaCha20 Encryption**

```text
  Test Vector #1:
  ==============

  Key:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 00              ............

  Initial Block Counter = 0

  Plaintext:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  032  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  048  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Ciphertext:
  000  76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28  v.....=.@]j.S..(
  016  bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7  .........6...w..
  032  da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37  .AY|QWH.w$.?..J7
  048  6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86  jC.........i..e.

  Test Vector #2:
  ==============

  Key:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01  ................

  Nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 02              ............

  Initial Block Counter = 1

  Plaintext:
  000  41 6e 79 20 73 75 62 6d 69 73 73 69 6f 6e 20 74  Any submission t
  016  6f 20 74 68 65 20 49 45 54 46 20 69 6e 74 65 6e  o the IETF inten
  032  64 65 64 20 62 79 20 74 68 65 20 43 6f 6e 74 72  ded by the Contr
  048  69 62 75 74 6f 72 20 66 6f 72 20 70 75 62 6c 69  ibutor for publi
  064  63 61 74 69 6f 6e 20 61 73 20 61 6c 6c 20 6f 72  cation as all or
  080  20 70 61 72 74 20 6f 66 20 61 6e 20 49 45 54 46   part of an IETF
  096  20 49 6e 74 65 72 6e 65 74 2d 44 72 61 66 74 20   Internet-Draft
  112  6f 72 20 52 46 43 20 61 6e 64 20 61 6e 79 20 73  or RFC and any s
  128  74 61 74 65 6d 65 6e 74 20 6d 61 64 65 20 77 69  tatement made wi
  144  74 68 69 6e 20 74 68 65 20 63 6f 6e 74 65 78 74  thin the context
  160  20 6f 66 20 61 6e 20 49 45 54 46 20 61 63 74 69   of an IETF acti
  176  76 69 74 79 20 69 73 20 63 6f 6e 73 69 64 65 72  vity is consider
  192  65 64 20 61 6e 20 22 49 45 54 46 20 43 6f 6e 74  ed an "IETF Cont
  208  72 69 62 75 74 69 6f 6e 22 2e 20 53 75 63 68 20  ribution". Such
  224  73 74 61 74 65 6d 65 6e 74 73 20 69 6e 63 6c 75  statements inclu
  240  64 65 20 6f 72 61 6c 20 73 74 61 74 65 6d 65 6e  de oral statemen
  256  74 73 20 69 6e 20 49 45 54 46 20 73 65 73 73 69  ts in IETF sessi
  272  6f 6e 73 2c 20 61 73 20 77 65 6c 6c 20 61 73 20  ons, as well as
  288  77 72 69 74 74 65 6e 20 61 6e 64 20 65 6c 65 63  written and elec
  304  74 72 6f 6e 69 63 20 63 6f 6d 6d 75 6e 69 63 61  tronic communica
  320  74 69 6f 6e 73 20 6d 61 64 65 20 61 74 20 61 6e  tions made at an
  336  79 20 74 69 6d 65 20 6f 72 20 70 6c 61 63 65 2c  y time or place,
  352  20 77 68 69 63 68 20 61 72 65 20 61 64 64 72 65   which are addre
  368  73 73 65 64 20 74 6f                             ssed to

  Ciphertext:
  000  a3 fb f0 7d f3 fa 2f de 4f 37 6c a2 3e 82 73 70  ...}../.O7l.>.sp
  016  41 60 5d 9f 4f 4f 57 bd 8c ff 2c 1d 4b 79 55 ec  A`].OOW...,.KyU.
  032  2a 97 94 8b d3 72 29 15 c8 f3 d3 37 f7 d3 70 05  *....r)....7..p.
  048  0e 9e 96 d6 47 b7 c3 9f 56 e0 31 ca 5e b6 25 0d  ....G...V.1.^.%.
  064  40 42 e0 27 85 ec ec fa 4b 4b b5 e8 ea d0 44 0e  @B.'....KK....D.
  080  20 b6 e8 db 09 d8 81 a7 c6 13 2f 42 0e 52 79 50   ........./B.RyP
  096  42 bd fa 77 73 d8 a9 05 14 47 b3 29 1c e1 41 1c  B..ws....G.)..A.
  112  68 04 65 55 2a a6 c4 05 b7 76 4d 5e 87 be a8 5a  h.eU*....vM^...Z
  128  d0 0f 84 49 ed 8f 72 d0 d6 62 ab 05 26 91 ca 66  ...I..r..b..&..f
  144  42 4b c8 6d 2d f8 0e a4 1f 43 ab f9 37 d3 25 9d  BK.m-....C..7.%.
  160  c4 b2 d0 df b4 8a 6c 91 39 dd d7 f7 69 66 e9 28  ......l.9...if.(
  176  e6 35 55 3b a7 6c 5c 87 9d 7b 35 d4 9e b2 e6 2b  .5U;.l\..{5....+
  192  08 71 cd ac 63 89 39 e2 5e 8a 1e 0e f9 d5 28 0f  .q..c.9.^.....(.
  208  a8 ca 32 8b 35 1c 3c 76 59 89 cb cf 3d aa 8b 6c  ..2.5.<vY...=..l
  224  cc 3a af 9f 39 79 c9 2b 37 20 fc 88 dc 95 ed 84  .:..9y.+7 ......
  240  a1 be 05 9c 64 99 b9 fd a2 36 e7 e8 18 b0 4b 0b  ....d....6....K.
  256  c3 9c 1e 87 6b 19 3b fe 55 69 75 3f 88 12 8c c0  ....k.;.Uiu?....
  272  8a aa 9b 63 d1 a1 6f 80 ef 25 54 d7 18 9c 41 1f  ...c..o..%T...A.
  288  58 69 ca 52 c5 b8 3f a3 6f f2 16 b9 c1 d3 00 62  Xi.R..?.o......b
  304  be bc fd 2d c5 bc e0 91 19 34 fd a7 9a 86 f6 e6  ...-.....4......
  320  98 ce d7 59 c3 ff 9b 64 77 33 8f 3d a4 f9 cd 85  ...Y...dw3.=....
  336  14 ea 99 82 cc af b3 41 b2 38 4d d9 02 f3 d1 ab  .......A.8M.....
  352  7a c6 1d d2 9c 6f 21 ba 5b 86 2f 37 30 e3 7c fd  z....o!.[./70.|.
  368  c4 fd 80 6c 22 f2 21                             ...l".!

  Test Vector #3:
  ==============

  Key:
  000  1c 92 40 a5 eb 55 d3 8a f3 33 88 86 04 f6 b5 f0  ..@..U...3......
  016  47 39 17 c1 40 2b 80 09 9d ca 5c bc 20 70 75 c0  G9..@+....\. pu.

  Nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 02              ............

  Initial Block Counter = 42
```

일반 텍스트: 000 27 54 77 61 73 20 62 72 69 6c 6c 69 67 2c 20 61 'Twas brillig, a 016 6e 64 20 74 68 65 20 73 6c 69 74 68 79 20 74 6f nd the slith y \~ 032 76 65 73 0a 44 69 64 20 67 79 72 65 20 61 6e 64 ves.Did gyre and 048 20 67 69 6d 62 6c 65 20 69 6e 20 74 68 65 20 77 w 064 61 62 65 3a 0 41 6c 6c 20 6d 69 6d 73 79 20 77 abe:.모두 mimsy w 080 65 72 65 20 74 68 65 20 62 6f 72 6f 67 6f 76 65 보로고브 앞에서 096 73 2c 0a 41 6e 64 20 74 68 65 20 6 d 6f 6d 65 20초, .그리고 엄마는 112 72 61 74 68 73 20 6f 75 74 67 72 61 62 65 2e Raths를 비난합니다.

```text
  Ciphertext:
  000  62 e6 34 7f 95 ed 87 a4 5f fa e7 42 6f 27 a1 df  b.4....._..Bo'..
  016  5f b6 91 10 04 4c 0d 73 11 8e ff a9 5b 01 e5 cf  _....L.s....[...
  032  16 6d 3d f2 d7 21 ca f9 b2 1e 5f b1 4c 61 68 71  .m=..!...._.Lahq
  048  fd 84 c5 4f 9d 65 b2 83 19 6c 7f e4 f6 05 53 eb  ...O.e...l....S.
  064  f3 9c 64 02 c4 22 34 e3 2a 35 6b 3e 76 43 12 a6  ..d.."4.*5k>vC..
  080  1a 55 32 05 57 16 ea d6 96 25 68 f8 7d 3f 3f 77  .U2.W....%h.}??w
  096  04 c6 a8 d1 bc d1 bf 4d 50 d6 15 4b 6d a7 31 b1  .......MP..Km.1.
  112  87 b5 8d fd 72 8a fa 36 75 7a 79 7a c1 88 d1     ....r..6uzyz...
```

---
### **A.3.  Poly1305 Message Authentication Code**

테스트 벡터 #2에서 r이 0과 같음을 주목하세요. 누산기에 r을 곱하는 Poly1305 알고리즘 부분은 r이 0인 경우 텍스트 내용에 관계없이 태그가 s와 동일하다는 것을 의미합니다. 다행스럽게도 r을 생성하는 제안된 모든 방법은 이 특정한 취약한 키를 얻을 가능성이 거의 없습니다.

```text
  Test Vector #1:
  ==============

  One-time Poly1305 Key:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Text to MAC:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  032  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  048  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Tag:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Test Vector #2:
  ==============

  One-time Poly1305 Key:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  36 e5 f6 b5 c5 e0 60 70 f0 ef ca 96 22 7a 86 3e  6.....`p...."z.>

  Text to MAC:
  000  41 6e 79 20 73 75 62 6d 69 73 73 69 6f 6e 20 74  Any submission t
  016  6f 20 74 68 65 20 49 45 54 46 20 69 6e 74 65 6e  o the IETF inten
  032  64 65 64 20 62 79 20 74 68 65 20 43 6f 6e 74 72  ded by the Contr
  048  69 62 75 74 6f 72 20 66 6f 72 20 70 75 62 6c 69  ibutor for publi
  064  63 61 74 69 6f 6e 20 61 73 20 61 6c 6c 20 6f 72  cation as all or
  080  20 70 61 72 74 20 6f 66 20 61 6e 20 49 45 54 46   part of an IETF
  096  20 49 6e 74 65 72 6e 65 74 2d 44 72 61 66 74 20   Internet-Draft
  112  6f 72 20 52 46 43 20 61 6e 64 20 61 6e 79 20 73  or RFC and any s
  128  74 61 74 65 6d 65 6e 74 20 6d 61 64 65 20 77 69  tatement made wi
  144  74 68 69 6e 20 74 68 65 20 63 6f 6e 74 65 78 74  thin the context
  160  20 6f 66 20 61 6e 20 49 45 54 46 20 61 63 74 69   of an IETF acti
  176  76 69 74 79 20 69 73 20 63 6f 6e 73 69 64 65 72  vity is consider
  192  65 64 20 61 6e 20 22 49 45 54 46 20 43 6f 6e 74  ed an "IETF Cont
  208  72 69 62 75 74 69 6f 6e 22 2e 20 53 75 63 68 20  ribution". Such
  224  73 74 61 74 65 6d 65 6e 74 73 20 69 6e 63 6c 75  statements inclu
  240  64 65 20 6f 72 61 6c 20 73 74 61 74 65 6d 65 6e  de oral statemen
  256  74 73 20 69 6e 20 49 45 54 46 20 73 65 73 73 69  ts in IETF sessi
  272  6f 6e 73 2c 20 61 73 20 77 65 6c 6c 20 61 73 20  ons, as well as
  288  77 72 69 74 74 65 6e 20 61 6e 64 20 65 6c 65 63  written and elec
  304  74 72 6f 6e 69 63 20 63 6f 6d 6d 75 6e 69 63 61  tronic communica
  320  74 69 6f 6e 73 20 6d 61 64 65 20 61 74 20 61 6e  tions made at an
  336  79 20 74 69 6d 65 20 6f 72 20 70 6c 61 63 65 2c  y time or place,
  352  20 77 68 69 63 68 20 61 72 65 20 61 64 64 72 65   which are addre
  368  73 73 65 64 20 74 6f                             ssed to

  Tag:
  000  36 e5 f6 b5 c5 e0 60 70 f0 ef ca 96 22 7a 86 3e  6.....`p...."z.>

  Test Vector #3:
  ==============

  One-time Poly1305 Key:
  000  36 e5 f6 b5 c5 e0 60 70 f0 ef ca 96 22 7a 86 3e  6.....`p...."z.>
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  Text to MAC:
  000  41 6e 79 20 73 75 62 6d 69 73 73 69 6f 6e 20 74  Any submission t
  016  6f 20 74 68 65 20 49 45 54 46 20 69 6e 74 65 6e  o the IETF inten
  032  64 65 64 20 62 79 20 74 68 65 20 43 6f 6e 74 72  ded by the Contr
  048  69 62 75 74 6f 72 20 66 6f 72 20 70 75 62 6c 69  ibutor for publi
  064  63 61 74 69 6f 6e 20 61 73 20 61 6c 6c 20 6f 72  cation as all or
  080  20 70 61 72 74 20 6f 66 20 61 6e 20 49 45 54 46   part of an IETF
  096  20 49 6e 74 65 72 6e 65 74 2d 44 72 61 66 74 20   Internet-Draft
  112  6f 72 20 52 46 43 20 61 6e 64 20 61 6e 79 20 73  or RFC and any s
  128  74 61 74 65 6d 65 6e 74 20 6d 61 64 65 20 77 69  tatement made wi
  144  74 68 69 6e 20 74 68 65 20 63 6f 6e 74 65 78 74  thin the context
  160  20 6f 66 20 61 6e 20 49 45 54 46 20 61 63 74 69   of an IETF acti
  176  76 69 74 79 20 69 73 20 63 6f 6e 73 69 64 65 72  vity is consider
  192  65 64 20 61 6e 20 22 49 45 54 46 20 43 6f 6e 74  ed an "IETF Cont
  208  72 69 62 75 74 69 6f 6e 22 2e 20 53 75 63 68 20  ribution". Such
  224  73 74 61 74 65 6d 65 6e 74 73 20 69 6e 63 6c 75  statements inclu
  240  64 65 20 6f 72 61 6c 20 73 74 61 74 65 6d 65 6e  de oral statemen
  256  74 73 20 69 6e 20 49 45 54 46 20 73 65 73 73 69  ts in IETF sessi
  272  6f 6e 73 2c 20 61 73 20 77 65 6c 6c 20 61 73 20  ons, as well as
  288  77 72 69 74 74 65 6e 20 61 6e 64 20 65 6c 65 63  written and elec
  304  74 72 6f 6e 69 63 20 63 6f 6d 6d 75 6e 69 63 61  tronic communica
  320  74 69 6f 6e 73 20 6d 61 64 65 20 61 74 20 61 6e  tions made at an
  336  79 20 74 69 6d 65 20 6f 72 20 70 6c 61 63 65 2c  y time or place,
  352  20 77 68 69 63 68 20 61 72 65 20 61 64 64 72 65   which are addre
  368  73 73 65 64 20 74 6f                             ssed to

  Tag:
  000  f3 47 7e 7c d9 54 17 af 89 a6 b8 79 4c 31 0c f0  .G~|.T.....yL1..

  Test Vector #4:
  ==============

  One-time Poly1305 Key:
  000  1c 92 40 a5 eb 55 d3 8a f3 33 88 86 04 f6 b5 f0  ..@..U...3......
  016  47 39 17 c1 40 2b 80 09 9d ca 5c bc 20 70 75 c0  G9..@+....\. pu.
```

MAC에 보내는 텍스트: 000 27 54 77 61 73 20 62 72 69 6c 6c 69 67 2c 20 61 'Twas brillig, a 016 6e 64 20 74 68 65 20 73 6c 69 74 68 79 20 74 6f nd the s 리시에게 032 76 65로 73 0a 44 69 64 20 67 79 72 65 20 61 6e 64 ves.Did gyre and 048 20 67 69 6d 62 6c 65 20 69 6e 20 74 68 65 20 77 w 064 61 62 6 5 3a 0a 41 6c 6c 20 6d 69 6d 73 79 20 77 abe:.모두 mimsy w 080 65 72 65 20 74 68 65 20 62 6f 72 6f 67 6f 76 65 보로고브 앞에서 096 73 2c 0a 41 6e 64 20 74 68 6 5 20 6일 6f 6일 65 20 s,.그리고 엄마는 112 72 61 74 68 73 20 6f 75 74 67 72 61 62 65 2e rats를 비난합니다.

```text
  Tag:
  000  45 41 66 9a 7e aa ee 61 e7 08 dc 7c bc c5 eb 62  EAf.~..a...|...b
```

테스트 벡터 #5: 130비트 부분 축소를 사용하는 경우 부분 축소된 최종 결과가 완전히 축소되지 않는 경우를 코드에서 처리합니까?

```text
   R:
   02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   S:
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   data:
   FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
   tag:
   03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

테스트 벡터 #6: s를 추가하면 모듈로 2^128이 오버플로되면 어떻게 되나요?

```text
   R:
   02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   S:
   FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
   data:
   02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   tag:
   03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

테스트 벡터 #7: 데이터 사지가 모두 1이고 하지에서 캐리가 있는 경우 어떻게 되나요?

```text
   R:
   01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   S:
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   data:
   FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
   F0 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
   11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   tag:
   05 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

테스트 벡터 #8: 다항식 부분의 최종 결과가 정확히 2^130-5이면 어떻게 되나요?

```text
   R:
   01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   S:
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   data:
   FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
   FB FE FE FE FE FE FE FE FE FE FE FE FE FE FE FE
   01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
   tag:
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

테스트 벡터 #9: 다항식 부분의 최종 결과가 정확히 2^130-6이면 어떻게 되나요?

```text
   R:
   02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   S:
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   data:
   FD FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
   tag:
   FA FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
```

테스트 벡터 #10: 5\*H+L 유형 축소로 131비트 중간 결과가 생성되면 어떻게 되나요?

```text
   R:
   01 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00
   S:
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   data:
   E3 35 94 D7 50 5E 43 B9 00 00 00 00 00 00 00 00
   33 94 D7 50 5E 43 79 CD 01 00 00 00 00 00 00 00
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   tag:
   14 00 00 00 00 00 00 00 55 00 00 00 00 00 00 00
```

테스트 벡터 #11: 5\*H+L 유형 축소로 131비트 최종 결과가 생성되면 어떻게 됩니까?

```text
   R:
   01 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00
   S:
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   data:
   E3 35 94 D7 50 5E 43 B9 00 00 00 00 00 00 00 00
   33 94 D7 50 5E 43 79 CD 01 00 00 00 00 00 00 00
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   tag:
   13 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

---
### **A.4.  Poly1305 Key Generation Using ChaCha20**

```text
  Test Vector #1:
  ==============

  The ChaCha20 Key:
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

  The nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 00              ............

  Poly1305 one-time key:
  000  76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28  v.....=.@]j.S..(
  016  bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7  .........6...w..

  Test Vector #2:
  ==============

  The ChaCha20 Key
  000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  016  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01  ................

  The nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 02              ............
```

```text
  Poly1305 one-time key:
  000  ec fa 25 4f 84 5f 64 74 73 d3 cb 14 0d a9 e8 76  ..%O._dts......v
  016  06 cb 33 06 6c 44 7b 87 bc 26 66 dd e3 fb b7 39  ..3.lD{..&f....9
```

```text
  Test Vector #3:
  ==============
```

ChaCha20 키 000 1c 92 40 a5 eb 55 d3 8a f3 33 88 86 04 f6 b5 f0 ..@..U...3...... 016 47 39 17 c1 40 2b 80 09 9d ca 5c bc 20 70 75 c0 G9..@+....\. 푸.

```text
  The nonce:
  000  00 00 00 00 00 00 00 00 00 00 00 02              ............

  Poly1305 one-time key:
  000  96 5e 3b c6 f9 ec 7e d9 56 08 08 f4 d2 29 f9 4b  .^;...~.V....).K
  016  13 7f f2 75 ca 9b 3f cb dd 59 de aa d2 33 10 ae  ...u..?..Y...3..
```

---
### **A.5.  ChaCha20-Poly1305 AEAD Decryption**

아래에서는 메시지를 해독하는 모습을 볼 수 있습니다. 우리는 암호문, nonce, 태그를 받습니다. 우리는 열쇠를 알고 있습니다. 태그를 확인한 다음 \(유효하다고 가정하여\) 암호문을 해독하겠습니다. 이 특정 프로토콜에서는 일반 텍스트에 패딩이 없다고 가정합니다.

ChaCha20 키 000 1c 92 40 a5 eb 55 d3 8a f3 33 88 86 04 f6 b5 f0 ..@..U...3...... 016 47 39 17 c1 40 2b 80 09 9d ca 5c bc 20 70 75 c0 G9..@+....\. 푸.

```text
  Ciphertext:
  000  64 a0 86 15 75 86 1a f4 60 f0 62 c7 9b e6 43 bd  d...u...`.b...C.
  016  5e 80 5c fd 34 5c f3 89 f1 08 67 0a c7 6c 8c b2  ^.\.4\....g..l..
  032  4c 6c fc 18 75 5d 43 ee a0 9e e9 4e 38 2d 26 b0  Ll..u]C....N8-&.
  048  bd b7 b7 3c 32 1b 01 00 d4 f0 3b 7f 35 58 94 cf  ...<2.....;.5X..
  064  33 2f 83 0e 71 0b 97 ce 98 c8 a8 4a bd 0b 94 81  3/..q......J....
  080  14 ad 17 6e 00 8d 33 bd 60 f9 82 b1 ff 37 c8 55  ...n..3.`....7.U
  096  97 97 a0 6e f4 f0 ef 61 c1 86 32 4e 2b 35 06 38  ...n...a..2N+5.8
  112  36 06 90 7b 6a 7c 02 b0 f9 f6 15 7b 53 c8 67 e4  6..{j|.....{S.g.
  128  b9 16 6c 76 7b 80 4d 46 a5 9b 52 16 cd e7 a4 e9  ..lv{.MF..R.....
  144  90 40 c5 a4 04 33 22 5e e2 82 a1 b0 a0 6c 52 3e  .@...3"^.....lR>
  160  af 45 34 d7 f8 3f a1 15 5b 00 47 71 8c bc 54 6a  .E4..?..[.Gq..Tj
  176  0d 07 2b 04 b3 56 4e ea 1b 42 22 73 f5 48 27 1a  ..+..VN..B"s.H'.
  192  0b b2 31 60 53 fa 76 99 19 55 eb d6 31 59 43 4e  ..1`S.v..U..1YCN
  208  ce bb 4e 46 6d ae 5a 10 73 a6 72 76 27 09 7a 10  ..NFm.Z.s.rv'.z.
  224  49 e6 17 d9 1d 36 10 94 fa 68 f0 ff 77 98 71 30  I....6...h..w.q0
  240  30 5b ea ba 2e da 04 df 99 7b 71 4d 6c 6f 2c 29  0[.......{qMlo,)
  256  a6 ad 5c b4 02 2b 02 70 9b                       ..\..+.p.

  The nonce:
  000  00 00 00 00 01 02 03 04 05 06 07 08              ............
```

AAD: 000 f3 33 88 86 00 00 00 00 00 00 4e 91 .3........N.

```text
  Received Tag:
  000  ee ad 9d 67 89 0c bb 22 39 23 36 fe a1 85 1f 38  ...g..."9#6....8
```

먼저 일회용 Poly1305 키를 계산합니다.

```text
    ChaCha state with key setup
        61707865  3320646e  79622d32  6b206574
        a540921c  8ad355eb  868833f3  f0b5f604
        c1173947  09802b40  bc5cca9d  c0757020
        00000000  00000000  04030201  08070605

    ChaCha state after 20 rounds
        a94af0bd  89dee45c  b64bb195  afec8fa1
        508f4726  63f554c0  1ea2c0db  aa721526
        11b1e514  a0bacc0f  828a6015  d7825481
        e8a4a850  d9dcbbd6  4c2de33a  f8ccd912
```

출력 바이트: bd:f0:4a:a9:5c:e4:de:89:95:b1:4b:b6:a1:8f:ec:af: 26:47:8f:50:c0:54:f5:63 :db:c0:a2:1e:26:15:72:aa

```text
  Poly1305 one-time key:
  000  bd f0 4a a9 5c e4 de 89 95 b1 4b b6 a1 8f ec af  ..J.\.....K.....
  016  26 47 8f 50 c0 54 f5 63 db c0 a2 1e 26 15 72 aa  &G.P.T.c....&.r.
```

다음으로 AEAD 버퍼를 구성합니다.

```text
  Poly1305 Input:
  000  f3 33 88 86 00 00 00 00 00 00 4e 91 00 00 00 00  .3........N.....
  016  64 a0 86 15 75 86 1a f4 60 f0 62 c7 9b e6 43 bd  d...u...`.b...C.
  032  5e 80 5c fd 34 5c f3 89 f1 08 67 0a c7 6c 8c b2  ^.\.4\....g..l..
  048  4c 6c fc 18 75 5d 43 ee a0 9e e9 4e 38 2d 26 b0  Ll..u]C....N8-&.
  064  bd b7 b7 3c 32 1b 01 00 d4 f0 3b 7f 35 58 94 cf  ...<2.....;.5X..
  080  33 2f 83 0e 71 0b 97 ce 98 c8 a8 4a bd 0b 94 81  3/..q......J....
  096  14 ad 17 6e 00 8d 33 bd 60 f9 82 b1 ff 37 c8 55  ...n..3.`....7.U
  112  97 97 a0 6e f4 f0 ef 61 c1 86 32 4e 2b 35 06 38  ...n...a..2N+5.8
  128  36 06 90 7b 6a 7c 02 b0 f9 f6 15 7b 53 c8 67 e4  6..{j|.....{S.g.
  144  b9 16 6c 76 7b 80 4d 46 a5 9b 52 16 cd e7 a4 e9  ..lv{.MF..R.....
  160  90 40 c5 a4 04 33 22 5e e2 82 a1 b0 a0 6c 52 3e  .@...3"^.....lR>
  176  af 45 34 d7 f8 3f a1 15 5b 00 47 71 8c bc 54 6a  .E4..?..[.Gq..Tj
  192  0d 07 2b 04 b3 56 4e ea 1b 42 22 73 f5 48 27 1a  ..+..VN..B"s.H'.
  208  0b b2 31 60 53 fa 76 99 19 55 eb d6 31 59 43 4e  ..1`S.v..U..1YCN
  224  ce bb 4e 46 6d ae 5a 10 73 a6 72 76 27 09 7a 10  ..NFm.Z.s.rv'.z.
  240  49 e6 17 d9 1d 36 10 94 fa 68 f0 ff 77 98 71 30  I....6...h..w.q0
  256  30 5b ea ba 2e da 04 df 99 7b 71 4d 6c 6f 2c 29  0[.......{qMlo,)
  272  a6 ad 5c b4 02 2b 02 70 9b 00 00 00 00 00 00 00  ..\..+.p........
  288  0c 00 00 00 00 00 00 00 09 01 00 00 00 00 00 00  ................
```

Poly1305 태그를 계산하여 일치하는지 확인합니다.

```text
  Calculated Tag:
  000  ee ad 9d 67 89 0c bb 22 39 23 36 fe a1 85 1f 38  ...g..."9#6....8
```

마지막으로 암호문을 해독합니다.

```text
  Plaintext::
  000  49 6e 74 65 72 6e 65 74 2d 44 72 61 66 74 73 20  Internet-Drafts
  016  61 72 65 20 64 72 61 66 74 20 64 6f 63 75 6d 65  are draft docume
  032  6e 74 73 20 76 61 6c 69 64 20 66 6f 72 20 61 20  nts valid for a
  048  6d 61 78 69 6d 75 6d 20 6f 66 20 73 69 78 20 6d  maximum of six m
  064  6f 6e 74 68 73 20 61 6e 64 20 6d 61 79 20 62 65  onths and may be
  080  20 75 70 64 61 74 65 64 2c 20 72 65 70 6c 61 63   updated, replac
  096  65 64 2c 20 6f 72 20 6f 62 73 6f 6c 65 74 65 64  ed, or obsoleted
  112  20 62 79 20 6f 74 68 65 72 20 64 6f 63 75 6d 65   by other docume
  128  6e 74 73 20 61 74 20 61 6e 79 20 74 69 6d 65 2e  nts at any time.
  144  20 49 74 20 69 73 20 69 6e 61 70 70 72 6f 70 72   It is inappropr
  160  69 61 74 65 20 74 6f 20 75 73 65 20 49 6e 74 65  iate to use Inte
  176  72 6e 65 74 2d 44 72 61 66 74 73 20 61 73 20 72  rnet-Drafts as r
  192  65 66 65 72 65 6e 63 65 20 6d 61 74 65 72 69 61  eference materia
  208  6c 20 6f 72 20 74 6f 20 63 69 74 65 20 74 68 65  l or to cite the
  224  6d 20 6f 74 68 65 72 20 74 68 61 6e 20 61 73 20  m other than as
  240  2f e2 80 9c 77 6f 72 6b 20 69 6e 20 70 72 6f 67  /...work in prog
  256  72 65 73 73 2e 2f e2 80 9d                       ress./...
```

---
# **Appendix B.  Performance Measurements of ChaCha20**

```text
   The following measurements were made by Adam Langley for a blog post
   published on February 27th, 2014.  The original blog post was
   available at the time of this writing at
   <https://www.imperialviolet.org/2014/02/27/tlssymmetriccrypto.html>.

     +----------------------------+-------------+-------------------+
     | Chip                       | AES-128-GCM | ChaCha20-Poly1305 |
     +----------------------------+-------------+-------------------+
     | OMAP 4460                  |  24.1 MB/s  |     75.3 MB/s     |
     | Snapdragon S4 Pro          |  41.5 MB/s  |     130.9 MB/s    |
     | Sandy Bridge Xeon (AES-NI) |   900 MB/s  |      500 MB/s     |
     +----------------------------+-------------+-------------------+

                         Table 1: Speed Comparison
```

---
# **Acknowledgements**

ChaCha20과 Poly1305는 Daniel J. Bernstein이 발명했습니다. AEAD 구성과 일회용 Poly1305 키를 생성하는 방법은 Adam Langley가 발명했습니다.

유용한 의견과 설명을 해주신 Robert Ransom, Watson Ladd, Stefan Buhler, Dan Harkins 및 Kenny Paterson에게 감사드립니다. 이 문서에서 보다 효율적인 AEAD 구성을 제안한 Niels Moller에게 감사드립니다. 추가 테스트 벡터와 유용한 설명을 제공하고 이 문서에서 구현을 시도한 최초의 Ilari Liusvaara에게 특별히 감사드립니다. 예제와 의사코드에 대한 개선을 제안한 Sean Parkinson에게 감사드립니다. 의사 코드의 버그를 지적한 David Ireland에게 감사하고, 보안 고려 사항에서 누락된 조언을 지적한 Stephen Farrell과 Alyssa Rowan에게 감사드립니다.

\[Procter\]의 구성과 출판에 대한 보안 분석을 수행한 Gordon Procter에게 특별한 감사를 드립니다.

Jim Schaad와 John Mattson은 태그 잘림에 대한 피드백을 제공했으며 Russ Housley, Stanislav Smyshlyaev 및 John Mattson은 각각 이 버전에 대한 리뷰를 제공했습니다.

---
# **Authors' Addresses**

```text
   Yoav Nir
   Dell EMC
   9 Andrei Sakharov St
   Haifa  3190500
   Israel

   Email: ynir.ietf@gmail.com

   Adam Langley
   Google, Inc.

   Email: agl@google.com
```
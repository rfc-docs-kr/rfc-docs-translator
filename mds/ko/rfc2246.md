

```text
Network Working Group                                         T. Dierks
Request for Comments: 2246                                     Certicom
Category: Standards Track                                      C. Allen
                                                               Certicom
                                                           January 1999

                            The TLS Protocol
                              Version 1.0
```

---
# **Status of this Memo**

본 문서는 인터넷 커뮤니티를 위한 인터넷 표준 트랙 프로토콜을 명시하고 개선을 위한 논의와 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "인터넷 공식 프로토콜 표준"\(STD 1\) 최신판을 참조하세요. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(1999\). 판권 소유.

---
# **Abstract**

이 문서에서는 TLS\(Transport Layer Security\) 프로토콜 버전 1.0을 지정합니다. TLS 프로토콜은 인터넷을 통한 통신 개인 정보 보호를 제공합니다. 이 프로토콜을 사용하면 클라이언트/서버 응용 프로그램이 도청, 변조 또는 메시지 위조를 방지하도록 설계된 방식으로 통신할 수 있습니다.

---
# **Table of Contents**

```text
   1.       Introduction                                              3
   2.       Goals                                                     4
   3.       Goals of this document                                    5
   4.       Presentation language                                     5
   4.1.     Basic block size                                          6
   4.2.     Miscellaneous                                             6
   4.3.     Vectors                                                   6
   4.4.     Numbers                                                   7
   4.5.     Enumerateds                                               7
   4.6.     Constructed types                                         8
   4.6.1.   Variants                                                  9
   4.7.     Cryptographic attributes                                 10
   4.8.     Constants                                                11
   5.       HMAC and the pseudorandom function                       11
   6.       The TLS Record Protocol                                  13
   6.1.     Connection states                                        14
```

```text
   6.2.     Record layer                                             16
   6.2.1.   Fragmentation                                            16
   6.2.2.   Record compression and decompression                     17
   6.2.3.   Record payload protection                                18
   6.2.3.1. Null or standard stream cipher                           19
   6.2.3.2. CBC block cipher                                         19
   6.3.     Key calculation                                          21
   6.3.1.   Export key generation example                            22
   7.       The TLS Handshake Protocol                               23
   7.1.     Change cipher spec protocol                              24
   7.2.     Alert protocol                                           24
   7.2.1.   Closure alerts                                           25
   7.2.2.   Error alerts                                             26
   7.3.     Handshake Protocol overview                              29
   7.4.     Handshake protocol                                       32
   7.4.1.   Hello messages                                           33
   7.4.1.1. Hello request                                            33
   7.4.1.2. Client hello                                             34
   7.4.1.3. Server hello                                             36
   7.4.2.   Server certificate                                       37
   7.4.3.   Server key exchange message                              39
   7.4.4.   Certificate request                                      41
   7.4.5.   Server hello done                                        42
   7.4.6.   Client certificate                                       43
   7.4.7.   Client key exchange message                              43
   7.4.7.1. RSA encrypted premaster secret message                   44
   7.4.7.2. Client Diffie-Hellman public value                       45
   7.4.8.   Certificate verify                                       45
   7.4.9.   Finished                                                 46
   8.       Cryptographic computations                               47
   8.1.     Computing the master secret                              47
   8.1.1.   RSA                                                      48
   8.1.2.   Diffie-Hellman                                           48
   9.       Mandatory Cipher Suites                                  48
   10.      Application data protocol                                48
   A.       Protocol constant values                                 49
   A.1.     Record layer                                             49
   A.2.     Change cipher specs message                              50
   A.3.     Alert messages                                           50
   A.4.     Handshake protocol                                       51
   A.4.1.   Hello messages                                           51
   A.4.2.   Server authentication and key exchange messages          52
   A.4.3.   Client authentication and key exchange messages          53
   A.4.4.   Handshake finalization message                           54
   A.5.     The CipherSuite                                          54
   A.6.     The Security Parameters                                  56
   B.       Glossary                                                 57
   C.       CipherSuite definitions                                  61

   D.       Implementation Notes                                     64
   D.1.     Temporary RSA keys                                       64
   D.2.     Random Number Generation and Seeding                     64
   D.3.     Certificates and authentication                          65
   D.4.     CipherSuites                                             65
   E.       Backward Compatibility With SSL                          66
   E.1.     Version 2 client hello                                   67
   E.2.     Avoiding man-in-the-middle version rollback              68
   F.       Security analysis                                        69
   F.1.     Handshake protocol                                       69
   F.1.1.   Authentication and key exchange                          69
   F.1.1.1. Anonymous key exchange                                   69
   F.1.1.2. RSA key exchange and authentication                      70
   F.1.1.3. Diffie-Hellman key exchange with authentication          71
   F.1.2.   Version rollback attacks                                 71
   F.1.3.   Detecting attacks against the handshake protocol         72
   F.1.4.   Resuming sessions                                        72
   F.1.5.   MD5 and SHA                                              72
   F.2.     Protecting application data                              72
   F.3.     Final notes                                              73
   G.       Patent Statement                                         74
            Security Considerations                                  75
            References                                               75
            Credits                                                  77
            Comments                                                 78
            Full Copyright Statement                                 80
```

---
## **1. Introduction**

TLS 프로토콜의 주요 목표는 통신하는 두 응용 프로그램 간에 개인 정보 보호 및 데이터 무결성을 제공하는 것입니다. 프로토콜은 TLS 레코드 프로토콜과 TLS 핸드셰이크 프로토콜의 두 계층으로 구성됩니다. 신뢰할 수 있는 전송 프로토콜\(예: TCP\[TCP\]\) 위에 계층화된 가장 낮은 수준에는 TLS 레코드 프로토콜이 있습니다. TLS 레코드 프로토콜은 두 가지 기본 속성이 있는 연결 보안을 제공합니다.

- 연결은 비공개입니다. 대칭 암호화는 데이터 암호화에 사용됩니다\(예: DES \[DES\], RC4 \[RC4\] 등\). 이 대칭 암호화의 키는 각 연결에 대해 고유하게 생성되며 다른 프로토콜\(예: TLS 핸드셰이크 프로토콜\). Record Protocol은 암호화 없이도 사용할 수 있습니다.

- 연결이 안정적입니다. 메시지 전송에는 키 MAC을 사용한 메시지 무결성 검사가 포함됩니다. MAC 계산에는 보안 해시 함수\(예: SHA, MD5 등\)가 사용됩니다. 레코드 프로토콜은 MAC 없이도 작동할 수 있지만 일반적으로 다음 용도로만 사용됩니다.

- 다른 프로토콜이 보안 매개변수 협상을 위한 전송으로 레코드 프로토콜을 사용하는 동안 이 모드입니다.

TLS 레코드 프로토콜은 다양한 상위 수준 프로토콜을 캡슐화하는 데 사용됩니다. 캡슐화된 프로토콜 중 하나인 TLS 핸드셰이크 프로토콜을 사용하면 애플리케이션 프로토콜이 첫 번째 데이터 바이트를 전송하거나 수신하기 전에 서버와 클라이언트가 서로를 인증하고 암호화 알고리즘과 암호화 키를 협상할 수 있습니다. TLS 핸드셰이크 프로토콜은 세 가지 기본 속성이 있는 연결 보안을 제공합니다.

- 피어의 신원은 비대칭 또는 공개 키, 암호화\(예: RSA \[RSA\], DSS \[DSS\] 등\)를 사용하여 인증될 수 있습니다. 이 인증은 선택 사항으로 설정할 수 있지만 일반적으로 피어 중 하나 이상에 필수입니다.

- 공유 비밀 협상은 안전합니다. 협상된 비밀은 도청자가 사용할 수 없으며 인증된 연결의 경우 연결 중간에 자신을 배치할 수 있는 공격자라도 비밀을 얻을 수 없습니다.

- 협상은 신뢰할 수 있습니다. 공격자는 통신 당사자에 의해 감지되지 않고 협상 통신을 수정할 수 없습니다.

TLS의 한 가지 장점은 애플리케이션 프로토콜에 독립적이라는 것입니다. 더 높은 수준의 프로토콜은 TLS 프로토콜 위에 투명하게 계층화될 수 있습니다. 그러나 TLS 표준은 프로토콜이 TLS를 통해 보안을 추가하는 방법을 지정하지 않습니다. TLS 핸드셰이킹을 시작하는 방법과 교환된 인증 인증서를 해석하는 방법에 대한 결정은 TLS 위에서 실행되는 프로토콜의 설계자와 구현자의 판단에 달려 있습니다.

---
## **2. Goals**

TLS 프로토콜의 목표는 우선순위에 따라 다음과 같습니다.

1. 암호화 보안: 두 당사자 간의 보안 연결을 설정하려면 TLS를 사용해야 합니다.

2. 상호 운용성: 독립적인 프로그래머는 - 서로의 코드에 대한 지식 없이 암호화 매개변수를 성공적으로 교환할 수 있는 TLS를 활용하는 애플리케이션을 개발할 수 있어야 합니다.

3. 확장성: TLS는 필요에 따라 새로운 공개 키 및 대량 암호화 방법을 통합할 수 있는 프레임워크를 제공하려고 합니다. 이는 또한 두 가지 하위 목표를 달성할 것입니다.

- 새로운 프로토콜을 생성하고\(그리고 새로운 약점이 발생할 위험이 있음\) 완전히 새로운 보안 라이브러리를 구현할 필요성을 피해야 합니다.

4. 상대적 효율성: 암호화 작업은 CPU를 많이 사용하는 경향이 있으며, 특히 공개 키 작업이 그렇습니다. 이러한 이유로 TLS 프로토콜은 처음부터 설정해야 하는 연결 수를 줄이기 위해 선택적 세션 캐싱 체계를 통합했습니다. 또한 네트워크 활동을 줄이기 위해 주의를 기울였습니다.

---
## **3. Goals of this document**

이 문서와 TLS 프로토콜 자체는 Netscape에서 게시한 SSL 3.0 프로토콜 사양을 기반으로 합니다. 이 프로토콜과 SSL 3.0의 차이점은 크지 않지만 TLS 1.0과 SSL 3.0이 상호 운용되지 않을 정도로 중요합니다\(TLS 1.0에는 TLS 구현이 SSL 3.0으로 돌아갈 수 있는 메커니즘이 포함되어 있음\). 이 문서는 주로 프로토콜을 구현할 독자와 프로토콜의 암호화 분석을 수행하는 독자를 대상으로 합니다. 사양은 이를 염두에 두고 작성되었으며 두 그룹의 요구 사항을 반영하기 위한 것입니다. 이러한 이유로 알고리즘에 따른 많은 데이터 구조와 규칙은 부록이 아닌 텍스트 본문에 포함되어 있어 이에 대한 접근이 더 쉽습니다.

이 문서는 견고한 보안 유지에 필요한 특정 정책 영역을 다루지만 서비스 정의나 인터페이스 정의에 대한 세부 정보를 제공하기 위한 것이 아닙니다.

---
## **4. Presentation language**

이 문서는 외부 표현의 데이터 형식을 다룹니다. 다음과 같은 매우 기본적이고 다소 캐주얼하게 정의된 프레젠테이션 구문이 사용됩니다. 구문은 구조의 여러 소스에서 가져옵니다. 구문과 의도 모두에서 프로그래밍 언어 "C"와 XDR \[XDR\]과 유사하지만 너무 많은 유사점을 도출하는 것은 위험합니다. 이 프리젠테이션 언어의 목적은 TLS만 문서화하는 것이지 특정 목표를 넘어서는 일반적인 응용 프로그램을 갖는 것이 아닙니다.

---
### **4.1. Basic block size**

모든 데이터 항목의 표현은 명시적으로 지정됩니다. 기본 데이터 블록 크기는 1바이트\(즉, 8비트\)입니다. 다중 바이트 데이터 항목은 왼쪽에서 오른쪽으로, 위에서 아래로 바이트를 연결한 것입니다. 바이트스트림에서 멀티바이트 항목\(예제에서는 숫자\)은 다음과 같이 구성됩니다\(C 표기법 사용\).

```text
       value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
               ... | byte[n-1];
```

다중 바이트 값의 바이트 순서는 일반적인 네트워크 바이트 순서 또는 빅 엔디안 형식입니다.

---
### **4.2. Miscellaneous**

주석은 "/\*"로 시작하고 "\*/"로 끝납니다.

선택적 구성 요소는 "\[\[ \]\]" 이중 괄호로 묶어 표시됩니다.

해석되지 않은 데이터를 포함하는 단일 바이트 엔터티는 불투명 유형입니다.

---
### **4.3. Vectors**

벡터\(1차원 배열\)는 동종 데이터 요소의 스트림입니다. 벡터의 크기는 문서화 시 지정되거나 런타임까지 지정되지 않은 채로 남아 있을 수 있습니다. 두 경우 모두 길이는 벡터의 요소 수가 아닌 바이트 수를 선언합니다. T 유형의 고정 길이 벡터인 새로운 유형 T'를 지정하는 구문은 다음과 같습니다.

```text
       T T'[n];
```

여기서 T'는 데이터 스트림에서 n 바이트를 차지합니다. 여기서 n은 T 크기의 배수입니다. 벡터의 길이는 인코딩된 스트림에 포함되지 않습니다.

다음 예에서 Datum은 프로토콜이 해석하지 않는 3개의 연속 바이트로 정의되는 반면, Data는 3개의 연속 Datum으로 총 9바이트를 사용합니다.

```text
       opaque Datum[3];      /* three uninterpreted bytes */
       Datum Data[9];        /* 3 consecutive 3 byte vectors */
```

가변 길이 벡터는 <floor..ceiling\> 표기법을 사용하여 유효한 길이의 하위 범위를 지정하여 정의됩니다. 인코딩되면 실제 길이는 바이트 스트림에서 벡터의 내용보다 앞에 옵니다. 길이는 벡터의 지정된 최대\(천장\) 길이를 유지하는 데 필요한 만큼의 바이트를 소비하는 숫자 형식입니다. 실제 길이 필드가 0인 가변 길이 벡터를 빈 벡터라고 합니다.

```text
       T T'<floor..ceiling>;
```

다음 예에서 필수는 불투명 유형의 300\~400바이트를 포함해야 하는 벡터입니다. 결코 비워둘 수 없습니다. 실제 길이 필드는 값 400을 나타내는 데 충분한 uint16이라는 2바이트를 사용합니다\(섹션 4.4 참조\). 반면에 Long은 최대 800바이트의 데이터 또는 400개의 uint16 요소를 나타낼 수 있으며 비어 있을 수 있습니다. 해당 인코딩에는 벡터 앞에 추가된 2바이트 실제 길이 필드가 포함됩니다. 인코딩된 벡터의 길이는 단일 요소 길이의 짝수 배수여야 합니다. 예를 들어 uint16의 17바이트 벡터는 불법입니다.

```text
       opaque mandatory<300..400>;
             /* length field is 2 bytes, cannot be empty */
       uint16 longer<0..800>;
             /* zero to 400 16-bit unsigned integers */
```

---
### **4.4. Numbers**

기본 숫자 데이터 유형은 부호 없는 바이트\(uint8\)입니다. 모든 더 큰 숫자 데이터 유형은 섹션 4.1에 설명된 대로 연결된 고정 길이의 일련의 바이트로 구성되며 역시 부호가 없습니다. 다음 숫자 유형이 사전 정의되어 있습니다.

```text
       uint8 uint16[2];
       uint8 uint24[3];
       uint8 uint32[4];
       uint8 uint64[8];
```

사양의 여기와 다른 곳의 모든 값은 "네트워크" 또는 "빅 엔디안" 순서로 저장됩니다. 16진수 바이트 01 02 03 04로 표시되는 uint32는 10진수 값 16909060과 동일합니다.

---
### **4.5. Enumerateds**

enum이라는 추가적인 희소 데이터 유형을 사용할 수 있습니다. enum 유형의 필드는 정의에 선언된 값만 가정할 수 있습니다. 각 정의는 다른 유형입니다. 동일한 유형의 열거형만 할당하거나 비교할 수 있습니다. 열거된 모든 요소는 다음과 같아야 합니다.

다음 예와 같이 값이 할당됩니다. 열거된 요소는 순서가 지정되어 있지 않으므로 순서에 관계없이 고유한 값을 할당할 수 있습니다.

```text
       enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
```

열거된 항목은 정의된 최대 서수 값만큼 바이트 스트림에서 많은 공간을 차지합니다. 다음 정의는 Color 유형의 필드를 전달하는 데 1바이트를 사용하게 합니다.

```text
       enum { red(3), blue(5), white(7) } Color;
```

불필요한 요소를 정의하지 않고 너비 정의를 강제하기 위해 선택적으로 관련 태그 없이 값을 지정할 수 있습니다. 다음 예에서 Taste는 데이터 스트림에서 2바이트를 사용하지만 값 1, 2 또는 4만 가정할 수 있습니다.

```text
       enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
```

열거형 요소의 이름은 정의된 유형 내에서 범위가 지정됩니다. 첫 번째 예에서 열거형의 두 번째 요소에 대한 정규화된 참조는 Color.blue입니다. 과제의 대상이 잘 명시되어 있으면 그러한 자격은 필요하지 않습니다.

```text
       Color color = Color.blue;     /* overspecified, legal */
       Color color = blue;           /* correct, type implicit */
```

외부 표현으로 변환되지 않는 열거형의 경우 숫자 정보가 생략될 수 있습니다.

```text
       enum { low, medium, high } Amount;
```

---
### **4.6. Constructed types**

편의를 위해 구조 유형은 기본 유형에서 구성될 수 있습니다. 각 사양은 새롭고 고유한 유형을 선언합니다. 정의 구문은 C의 구문과 매우 유사합니다.

```text
       struct {
         T1 f1;
         T2 f2;
         ...
         Tn fn;
       } [[T]];
```

구조 내의 필드는 열거에 사용할 수 있는 것과 매우 유사한 구문을 사용하여 유형 이름을 사용하여 한정될 수 있습니다. 예를 들어, T.f2는 이전 선언의 두 번째 필드를 나타냅니다. 구조 정의가 포함될 수 있습니다.

---
#### **4.6.1. Variants**

정의된 구조에는 환경 내에서 사용 가능한 일부 지식을 기반으로 하는 변형이 있을 수 있습니다. 선택기는 구조가 정의하는 가능한 변형을 정의하는 열거형 유형이어야 합니다. 선택 항목에 선언된 열거형의 모든 요소에 대한 케이스 암이 있어야 합니다. 변형 구조의 본문에는 참조용 라벨이 제공될 수 있습니다. 런타임 시 변형이 선택되는 메커니즘은 표시 언어에 의해 규정되지 않습니다.

```text
       struct {
           T1 f1;
           T2 f2;
           ....
           Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               ....
               case en: Ten;
           } [[fv]];
       } [[Tv]];
```

예를 들어:

```text
       enum { apple, orange } VariantTag;
       struct {
           uint16 number;
           opaque string<0..10>; /* variable length */
       } V1;
       struct {
           uint32 number;
           opaque string[10];    /* fixed length */
       } V2;
       struct {
           select (VariantTag) { /* value of selector is implicit */
               case apple: V1;   /* VariantBody, tag = apple */
               case orange: V2;  /* VariantBody, tag = orange */
           } variant_body;       /* optional label on variant */
       } VariantRecord;
```

유형 앞에 선택기 값을 지정하여 변형 구조를 한정\(좁힐\)할 수 있습니다. 예를 들어,

```text
       orange VariantRecord
```

V2 유형의 Variant\_body를 포함하는 VariantRecord의 축소된 유형입니다.

---
### **4.7. Cryptographic attributes**

네 가지 암호화 작업인 디지털 서명, 스트림 암호 암호화, 블록 암호 암호화 및 공개 키 암호화는 각각 디지털 서명, 스트림 암호화, 블록 암호화 및 공개 키 암호화로 지정됩니다. 필드의 암호화 처리는 필드 유형 지정 앞에 적절한 키워드 지정을 추가하여 지정됩니다. 암호화 키는 현재 세션 상태에 의해 암시됩니다\(섹션 6.1 참조\).

디지털 서명에서는 단방향 해시 함수가 서명 알고리즘의 입력으로 사용됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩됩니다. 여기서 길이는 서명 알고리즘과 키에 의해 지정됩니다.

RSA 서명에서는 두 개의 해시\(SHA 하나와 MD5 하나\)로 구성된 36바이트 구조가 서명됩니다\(개인 키로 암호화됨\). \[PKCS1\]에 설명된 대로 PKCS #1 블록 유형 0 또는 유형 1로 인코딩됩니다.

DSS에서는 SHA 해시의 20바이트가 추가 해싱 없이 디지털 서명 알고리즘을 통해 직접 실행됩니다. 그러면 r과 s라는 두 값이 생성됩니다. DSS 서명은 위와 같이 불투명한 벡터이며 그 내용은 다음의 DER 인코딩입니다.

```text
       Dss-Sig-Value  ::=  SEQUENCE  {
            r       INTEGER,
            s       INTEGER
       }
```

스트림 암호 암호화에서 일반 텍스트는 암호화된 보안 키 의사 난수 생성기에서 생성된 동일한 양의 출력과 배타적 OR로 연결됩니다.

블록 암호 암호화에서는 모든 일반 텍스트 블록이 암호 텍스트 블록으로 암호화됩니다. 모든 블록 암호 암호화는 CBC\(Cipher Block Chaining\) 모드로 수행되며, 블록 암호화되는 모든 항목은 암호 블록 길이의 정확한 배수가 됩니다.

공개 키 암호화에서는 공개 키 알고리즘을 사용하여 일치하는 개인 키로만 해독할 수 있는 방식으로 데이터를 암호화합니다. 공개 키로 암호화된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩됩니다. 여기서 길이는 서명 알고리즘과 키에 의해 지정됩니다.

RSA 암호화된 값은 \[PKCS1\]에 설명된 대로 PKCS #1 블록 유형 2로 인코딩됩니다.

다음 예에서는:

```text
       stream-ciphered struct {
           uint8 field1;
           uint8 field2;
           digitally-signed opaque hash[20];
       } UserType;
```

해시의 내용은 서명 알고리즘의 입력으로 사용되며 전체 구조는 스트림 암호로 암호화됩니다. 이 구조의 길이\(바이트\)는 field1 및 field2의 2바이트, 서명 길이의 2바이트, 서명 알고리즘의 출력 길이를 더한 것과 같습니다. 이는 서명에 사용된 알고리즘과 키가 이 구조를 인코딩하거나 디코딩하기 전에 알려져 있다는 사실로 인해 알려져 있습니다.

---
### **4.8. Constants**

유형이 지정된 상수는 원하는 유형의 기호를 선언하고 값을 할당하여 사양 목적으로 정의할 수 있습니다. 과소 지정된 유형\(불투명, 가변 길이 벡터 및 불투명을 포함하는 구조체\)에는 값을 할당할 수 없습니다. 다중 요소 구조 또는 벡터의 필드는 생략될 수 없습니다.

예를 들어,

```text
       struct {
           uint8 f1;
           uint8 f2;
       } Example1;

       Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */
```

---
## **5. HMAC and the pseudorandom function**

TLS 레코드 및 핸드셰이크 계층의 여러 작업에는 키가 있는 MAC이 필요했습니다. 이는 비밀로 보호되는 일부 데이터의 보안 다이제스트입니다. MAC 비밀을 알지 못하면 MAC 위조가 불가능합니다. 이 작업에 사용하는 구성은 \[HMAC\]에 설명된 HMAC로 알려져 있습니다.

HMAC는 다양한 해시 알고리즘과 함께 사용될 수 있습니다. TLS는 이를 HMAC\_MD5\(비밀, 데이터\) 및 HMAC\_SHA\(비밀,

데이터\). 추가 해시 알고리즘은 암호 그룹에 의해 정의될 수 있으며 기록 데이터를 보호하는 데 사용될 수 있지만 MD5 및 SHA-1은 이 버전의 프로토콜에 대한 핸드셰이킹 설명에 하드 코딩되어 있습니다.

또한 키 생성 또는 검증을 위해 비밀을 데이터 블록으로 확장하려면 구성이 필요합니다. 이 의사 난수 함수\(PRF\)는 비밀, 시드 및 식별 레이블을 입력으로 사용하여 임의 길이의 출력을 생성합니다.

PRF를 최대한 안전하게 만들기 위해 두 가지 해시 알고리즘 중 하나가 안전하게 유지되는 경우 보안을 보장하는 방식으로 두 가지 해시 알고리즘을 사용합니다.

먼저, 단일 해시 함수를 사용하여 비밀과 시드를 임의의 양의 출력으로 확장하는 데이터 확장 함수 P\_hash\(secret, data\)를 정의합니다.

```text
       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                              HMAC_hash(secret, A(2) + seed) +
                              HMAC_hash(secret, A(3) + seed) + ...
```

여기서 +는 연결을 나타냅니다.

A\(\)는 다음과 같이 정의됩니다: - A\(0\) = 시드 A\(i\) = HMAC\_hash\(비밀, A\(i-1\)\)

P\_hash는 필요한 양의 데이터를 생성하는 데 필요한 만큼 반복될 수 있습니다. 예를 들어, P\_SHA-1을 사용하여 64바이트의 데이터를 생성하는 경우 A\(4\)를 통해 4번 반복하여 80바이트의 출력 데이터를 생성해야 합니다. 그런 다음 최종 반복의 마지막 16바이트가 삭제되고 64바이트의 출력 데이터가 남습니다.

TLS의 PRF는 비밀을 두 부분으로 분할하고 절반을 사용하여 P\_MD5로 데이터를 생성하고 나머지 절반을 사용하여 P\_SHA-1로 데이터를 생성한 다음 이 두 확장 기능의 출력을 함께 배타적 또는 결합하여 생성됩니다.

S1과 S2는 비밀의 두 부분이며 각각의 길이는 동일합니다. S1은 비밀의 전반부에서 가져오고, S2는 후반부에서 가져옵니다. 그 길이는 전체 비밀의 길이를 2로 나눈 값을 반올림하여 생성됩니다. 따라서 원래 비밀의 길이가 홀수 바이트인 경우 S1의 마지막 바이트는 S2의 첫 번째 바이트와 동일합니다.

```text
       L_S = length in bytes of secret;
       L_S1 = L_S2 = ceil(L_S / 2);
```

비밀은 위에서 설명한 대로 두 부분으로 분할됩니다\(공유 바이트 1개 가능\). S1은 첫 번째 L\_S1 바이트를 취하고 S2는 마지막 L\_S2 바이트를 사용합니다.

그러면 PRF는 두 개의 의사 난수 스트림을 함께 배타적 논리합으로 혼합한 결과로 정의됩니다.

```text
       PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR
                                  P_SHA-1(S2, label + seed);
```

레이블은 ASCII 문자열입니다. 길이 바이트나 후행 널 문자 없이 제공된 정확한 형식으로 포함되어야 합니다. 예를 들어 "slithy toves"라는 라벨은 다음 바이트를 해싱하여 처리됩니다.

```text
       73 6C 69 74 68 79 20 74 6F 76 65 73
```

MD5는 16바이트 출력을 생성하고 SHA-1은 20바이트 출력을 생성하므로 내부 반복의 경계는 정렬되지 않습니다. 80바이트 출력을 생성하려면 P\_MD5가 A\(5\)를 통해 반복되는 반면 P\_SHA-1은 A\(4\)를 통해서만 반복됩니다.

---
## **6. The TLS Record Protocol**

TLS 레코드 프로토콜은 계층화된 프로토콜입니다. 각 계층에서 메시지에는 길이, 설명 및 내용에 대한 필드가 포함될 수 있습니다. 레코드 프로토콜은 전송할 메시지를 취하고, 데이터를 관리 가능한 블록으로 조각화하고, 선택적으로 데이터를 압축하고, MAC를 적용하고, 암호화하고, 결과를 전송합니다. 수신된 데이터는 해독, 확인, 압축 해제 및 재조립된 후 상위 클라이언트에 전달됩니다.

이 문서에서는 네 가지 레코드 프로토콜 클라이언트\(핸드셰이크 프로토콜, 경고 프로토콜, 암호 사양 변경 프로토콜, 애플리케이션 데이터 프로토콜\)에 대해 설명합니다. TLS 프로토콜의 확장을 허용하기 위해 레코드 프로토콜에서 추가 레코드 유형을 지원할 수 있습니다. 모든 새로운 레코드 유형은 여기에 설명된 네 가지 레코드 유형에 대한 ContentType 값을 넘어서는 유형 값을 즉시 할당해야 합니다\(부록 A.2 참조\). TLS 구현이 이해하지 못하는 레코드 유형을 수신하는 경우 이를 무시해야 합니다. TLS를 통해 사용하도록 설계된 모든 프로토콜은 이에 대한 가능한 모든 공격을 처리하도록 신중하게 설계되어야 합니다. 레코드의 유형과 길이는 암호화로 보호되지 않으므로 이러한 값의 트래픽 분석 값을 최소화하도록 주의해야 합니다.

---
### **6.1. Connection states**

TLS 연결 상태는 TLS 레코드 프로토콜의 운영 환경입니다. 압축 알고리즘, 암호화 알고리즘, MAC 알고리즘을 지정합니다. 또한 이러한 알고리즘에 대한 매개변수는 MAC 비밀, 대량 암호화 키, 읽기 및 쓰기 방향 연결에 대한 IV로 알려져 있습니다. 논리적으로 항상 4가지 연결 상태, 즉 현재 읽기 및 쓰기 상태와 보류 중인 읽기 및 쓰기 상태가 있습니다. 모든 레코드는 현재 읽기 및 쓰기 상태에서 처리됩니다. 보류 상태에 대한 보안 매개변수는 TLS 핸드셰이크 프로토콜에 의해 설정될 수 있으며, 핸드셰이크 프로토콜은 보류 상태 중 하나를 선택적으로 현재 상태로 만들 수 있습니다. 이 경우 적절한 현재 상태는 삭제되고 보류 상태로 대체됩니다. 그런 다음 보류 상태는 빈 상태로 다시 초기화됩니다. 보안 매개변수로 초기화되지 않은 상태를 현재 상태로 만드는 것은 불법입니다. 초기 현재 상태에서는 항상 암호화, 압축 또는 MAC가 사용되지 않음을 지정합니다.

TLS 연결 읽기 및 쓰기 상태에 대한 보안 매개변수는 다음 값을 제공하여 설정됩니다.

연결 끝 - 이 엔터티가 이 연결에서 "클라이언트"로 간주되는지 아니면 "서버"로 간주되는지 여부입니다.

대량 암호화 알고리즘 - 대량 암호화에 사용되는 알고리즘입니다. 이 사양에는 이 알고리즘의 키 크기, 해당 키 중 비밀 키의 양, 블록 또는 스트림 암호인지 여부, 암호의 블록 크기\(해당하는 경우\) 및 "내보내기" 암호로 간주되는지 여부가 포함됩니다.

MAC 알고리즘 - 메시지 인증에 사용되는 알고리즘입니다. 이 사양에는 MAC 알고리즘에서 반환되는 해시 크기가 포함됩니다.

압축 알고리즘 - 데이터 압축에 사용되는 알고리즘입니다. 이 사양에는 알고리즘이 압축을 수행하는 데 필요한 모든 정보가 포함되어야 합니다.

마스터 비밀 - 연결에 있는 두 피어 간에 공유되는 48바이트 비밀입니다.

클라이언트 무작위 - 클라이언트가 제공하는 32바이트 값입니다.

서버 랜덤 - 서버에서 제공하는 32바이트 값입니다.

이러한 매개변수는 표시 언어에서 다음과 같이 정의됩니다.

```text
       enum { server, client } ConnectionEnd;

       enum { null, rc4, rc2, des, 3des, des40 } BulkCipherAlgorithm;

       enum { stream, block } CipherType;

       enum { true, false } IsExportable;

       enum { null, md5, sha } MACAlgorithm;

       enum { null(0), (255) } CompressionMethod;

       /* The algorithms specified in CompressionMethod,
          BulkCipherAlgorithm, and MACAlgorithm may be added to. */

       struct {
           ConnectionEnd          entity;
           BulkCipherAlgorithm    bulk_cipher_algorithm;
           CipherType             cipher_type;
           uint8                  key_size;
           uint8                  key_material_length;
           IsExportable           is_exportable;
           MACAlgorithm           mac_algorithm;
           uint8                  hash_size;
           CompressionMethod      compression_algorithm;
           opaque                 master_secret[48];
           opaque                 client_random[32];
           opaque                 server_random[32];
       } SecurityParameters;
```

레코드 레이어는 보안 매개변수를 사용하여 다음 6개 항목을 생성합니다.

```text
       client write MAC secret
       server write MAC secret
       client write key
       server write key
       client write IV (for block ciphers only)
       server write IV (for block ciphers only)
```

클라이언트 쓰기 매개변수는 레코드를 수신하고 처리할 때 서버에서 사용되며 그 반대의 경우도 마찬가지입니다. 보안 매개변수에서 이러한 항목을 생성하는 데 사용되는 알고리즘은 섹션 6.3에 설명되어 있습니다.

보안 매개변수가 설정되고 키가 생성되면 연결 상태를 현재 상태로 만들어 인스턴스화할 수 있습니다. 이러한 현재 상태는 처리된 각 레코드에 대해 업데이트되어야 합니다. 각 연결 상태에는 다음 요소가 포함됩니다.

압축 상태 - 압축 알고리즘의 현재 상태입니다.

암호 상태 - 암호화 알고리즘의 현재 상태입니다. 이는 해당 연결에 대해 예약된 키로 구성됩니다. 또한 CBC 모드\(TLS에 지정된 유일한 모드\)에서 실행되는 블록 암호의 경우 처음에는 해당 연결 상태에 대한 IV를 포함하고 레코드가 처리될 때 암호화되거나 해독된 마지막 블록의 암호 텍스트를 포함하도록 업데이트됩니다. 스트림 암호의 경우 여기에는 스트림이 계속해서 데이터를 암호화하거나 해독할 수 있도록 하는 데 필요한 상태 정보가 모두 포함됩니다.

MAC 비밀 - 위에서 생성된 이 연결의 MAC 비밀입니다.

시퀀스 번호 - 각 연결 상태에는 읽기 및 쓰기 상태에 대해 별도로 유지되는 시퀀스 번호가 포함됩니다. 연결 상태가 활성 상태가 될 때마다 시퀀스 번호는 0으로 설정되어야 합니다. 시퀀스 번호는 uint64 유형이며 2^64-1을 초과할 수 없습니다. 시퀀스 번호는 각 레코드 다음에 증가합니다. 특히 특정 연결 상태에서 전송되는 첫 번째 레코드는 시퀀스 번호 0을 사용해야 합니다.

---
### **6.2. Record layer**

TLS 레코드 레이어는 임의 크기의 비어 있지 않은 블록으로 상위 레이어로부터 해석되지 않은 데이터를 수신합니다.

---
#### **6.2.1. Fragmentation**

레코드 계층은 정보 블록을 2^14바이트 이하의 청크로 데이터를 전달하는 TLSPlaintext 레코드로 조각화합니다. 클라이언트 메시지 경계는 레코드 계층에서 유지되지 않습니다. 즉, 동일한 ContentType의 여러 클라이언트 메시지가 단일 TLSPlaintext 레코드로 통합될 수 있거나 단일 메시지가 여러 레코드에 걸쳐 조각화될 수 있습니다.

```text
       struct {
           uint8 major, minor;
       } ProtocolVersion;

       enum {
           change_cipher_spec(20), alert(21), handshake(22),
           application_data(23), (255)
       } ContentType;

       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           opaque fragment[TLSPlaintext.length];
       } TLSPlaintext;
```

유형 - 포함된 조각을 처리하는 데 사용되는 상위 수준 프로토콜입니다.

버전 - 사용 중인 프로토콜의 버전입니다. 이 문서에서는 버전 { 3, 1 }을 사용하는 TLS 버전 1.0에 대해 설명합니다. 버전 값 3.1은 역사적입니다. TLS 버전 1.0은 버전 값 3.0을 포함하는 SSL 3.0 프로토콜에 대한 사소한 수정입니다. \(부록 A.1 참조\)

길이 - 다음 TLSPlaintext.fragment의 길이\(바이트\)입니다. 길이는 2^14를 초과할 수 없습니다.

조각 - 애플리케이션 데이터입니다. 이 데이터는 투명하며 유형 필드에 지정된 상위 레벨 프로토콜에 의해 처리되는 독립 블록으로 처리됩니다.

참고: 다양한 TLS 레코드 레이어 콘텐츠 유형의 데이터가 인터리브될 수 있습니다. 애플리케이션 데이터는 일반적으로 다른 콘텐츠 유형보다 전송 우선순위가 낮습니다.

---
#### **6.2.2. Record compression and decompression**

모든 레코드는 현재 세션 상태에 정의된 압축 알고리즘을 사용하여 압축됩니다. 항상 활성 압축 알고리즘이 있습니다. 그러나 처음에는 CompressionMethod.null로 정의됩니다. 압축 알고리즘은 TLSPlaintext 구조를 TLSCompressed 구조로 변환합니다. 압축 기능은 연결 상태가 활성화될 때마다 기본 상태 정보로 초기화됩니다.

압축은 무손실이어야 하며 콘텐츠 길이를 1024바이트 이상 늘릴 수 없습니다. 압축 해제 기능이 2^14바이트를 초과하는 길이로 압축을 해제하는 TLSCompressed.fragment를 발견하면 치명적인 압축 해제 실패 오류를 보고해야 합니다.

```text
       struct {
           ContentType type;       /* same as TLSPlaintext.type */
           ProtocolVersion version;/* same as TLSPlaintext.version */
           uint16 length;
           opaque fragment[TLSCompressed.length];
       } TLSCompressed;
```

길이 - 다음 TLSCompressed.fragment의 길이\(바이트\)입니다. 길이는 2^14 + 1024를 초과할 수 없습니다.

조각 - TLSPlaintext.fragment의 압축된 형식입니다.

참고: CompressionMethod.null 작업은 ID 작업입니다. 필드는 변경되지 않습니다.

구현 참고 사항: - 압축 해제 기능은 메시지가 내부 버퍼 오버플로를 일으키지 않도록 하는 역할을 합니다.

---
#### **6.2.3. Record payload protection**

암호화 및 MAC 기능은 TLSCompressed 구조를 TLSCiphertext로 변환합니다. 암호 해독 기능은 프로세스를 반대로 수행합니다. 레코드의 MAC에는 누락된 메시지, 추가 메시지 또는 반복된 메시지를 감지할 수 있도록 시퀀스 번호도 포함되어 있습니다.

```text
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           select (CipherSpec.cipher_type) {
               case stream: GenericStreamCipher;
               case block: GenericBlockCipher;
           } fragment;
       } TLSCiphertext;
```

type - 유형 필드는 TLSCompressed.type과 동일합니다.

version - 버전 필드는 TLSCompressed.version과 동일합니다.

길이 - 다음 TLSCiphertext.fragment의 길이\(바이트\)입니다. 길이는 2^14 + 2048을 초과할 수 없습니다.

조각 - MAC을 사용하는 TLSCompressed.fragment의 암호화된 형식입니다.

---
##### **6.2.3.1. Null or standard stream cipher**

스트림 암호\(BulkCipherAlgorithm.null 포함 - 부록 A.6 참조\)는 TLSCompressed.fragment 구조를 스트림 TLSCiphertext.fragment 구조로 변환합니다.

```text
       stream-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
       } GenericStreamCipher;
```

MAC은 다음과 같이 생성됩니다.

```text
       HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +
                     TLSCompressed.version + TLSCompressed.length +
                     TLSCompressed.fragment));
```

여기서 "+"는 연결을 나타냅니다.

seq\_num - 이 레코드의 시퀀스 번호입니다.

hash - SecurityParameters.mac\_algorithm에 지정된 해싱 알고리즘입니다.

MAC은 암호화 전에 계산됩니다. 스트림 암호는 MAC을 포함한 전체 블록을 암호화합니다. 동기화 벡터\(예: RC4\)를 사용하지 않는 스트림 암호의 경우 한 레코드 끝의 스트림 암호 상태가 후속 패킷에서 단순히 사용됩니다. CipherSuite가 TLS\_NULL\_WITH\_NULL\_NULL인 경우 암호화는 ID 작업으로 구성됩니다\(즉, 데이터가 암호화되지 않고 MAC 크기가 0이므로 MAC가 사용되지 않음을 의미합니다\). TLSCiphertext.length는 TLSCompressed.length에 CipherSpec.hash\_size를 더한 것입니다.

---
##### **6.2.3.2. CBC block cipher**

블록 암호\(예: RC2 또는 DES\)의 경우 암호화 및 MAC 기능은 TLSCompressed.fragment 구조를 블록 TLSCiphertext.fragment 구조로 변환합니다.

```text
       block-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       } GenericBlockCipher;
```

MAC는 섹션 6.2.3.1에 설명된 대로 생성됩니다.

패딩\(padding\) - 일반 텍스트의 길이가 블록 암호 블록 길이의 정수배가 되도록 추가되는 패딩입니다. 패딩은 TLSCiphertext.length가 블록 길이의 정수배가 되는 한 최대 255바이트 길이일 수 있습니다. 교환된 메시지의 길이 분석을 기반으로 프로토콜에 대한 공격을 좌절시키려면 필요한 것보다 긴 길이가 바람직할 수 있습니다. 패딩 데이터 벡터의 각 uint8은 패딩 길이 값으로 채워져야 합니다.

padding\_length - 패딩 길이는 GenericBlockCipher 구조의 전체 크기가 암호 블록 길이의 배수가 되도록 해야 합니다. 유효한 값의 범위는 0부터 255까지입니다. 이 길이는 padding\_length 필드 자체를 제외한 패딩 필드의 길이를 지정합니다.

암호화된 데이터 길이\(TLSCiphertext.length\)는 TLSCompressed.length, CipherSpec.hash\_size, padding\_length의 합보다 1 더 큽니다.

```text
 Example: If the block length is 8 bytes, the content length
          (TLSCompressed.length) is 61 bytes, and the MAC length is 20
          bytes, the length before padding is 82 bytes. Thus, the
          padding length modulo 8 must be equal to 6 in order to make
          the total length an even multiple of 8 bytes (the block
          length). The padding length can be 6, 14, 22, and so on,
          through 254. If the padding length were the minimum necessary,
          6, the padding would be 6 bytes, each containing the value 6.
          Thus, the last 8 octets of the GenericBlockCipher before block
          encryption would be xx 06 06 06 06 06 06 06, where xx is the
          last octet of the MAC.
```

참고: CBC 모드\(암호 블록 체인\)의 블록 암호를 사용하면 보안 매개변수가 설정될 때 첫 번째 레코드에 대한 초기화 벡터\(IV\)가 다른 키 및 비밀과 함께 생성됩니다. 후속 레코드의 IV는 이전 레코드의 마지막 암호문 블록입니다.

---
### **6.3. Key calculation**

레코드 프로토콜에는 핸드셰이크 프로토콜에서 제공하는 보안 매개변수로부터 키, IV 및 MAC 비밀을 생성하는 알고리즘이 필요합니다.

마스터 비밀은 현재 연결 상태에 필요한 MAC 비밀, 키 및 비수출 IV에 할당되는 일련의 보안 바이트로 해시됩니다\(부록 A.6 참조\). CipherSpecs에는 클라이언트 쓰기 MAC 비밀, 서버 쓰기 MAC 비밀, 클라이언트 쓰기 키, 서버 쓰기 키, 클라이언트 쓰기 IV, 서버 쓰기 IV가 필요하며, 이는 마스터 비밀에서 순서대로 생성됩니다. 사용되지 않은 값은 비어 있습니다.

키와 MAC 비밀을 생성할 때 마스터 비밀은 엔트로피 소스로 사용되며, 무작위 값은 암호화되지 않은 솔트 자료와 내보낼 수 있는 암호를 위한 IV를 제공합니다.

키 자료를 생성하려면 다음을 계산하세요.

```text
       key_block = PRF(SecurityParameters.master_secret,
                          "key expansion",
                          SecurityParameters.server_random +
                          SecurityParameters.client_random);
```

충분한 출력이 생성될 때까지. 그런 다음 key\_block은 다음과 같이 분할됩니다.

```text
       client_write_MAC_secret[SecurityParameters.hash_size]
       server_write_MAC_secret[SecurityParameters.hash_size]
       client_write_key[SecurityParameters.key_material_length]
       server_write_key[SecurityParameters.key_material_length]
       client_write_IV[SecurityParameters.IV_size]
       server_write_IV[SecurityParameters.IV_size]
```

client\_write\_IV 및 server\_write\_IV는 비수출 블록 암호에 대해서만 생성됩니다. 내보낼 수 있는 블록 암호의 경우 초기화 벡터는 아래 설명된 대로 나중에 생성됩니다. 추가 key\_block 자료는 모두 삭제됩니다.

구현 참고 사항: - 이 문서에 정의되어 있으며 가장 많은 자료가 필요한 암호 사양은 3DES\_EDE\_CBC\_SHA입니다. 총 104바이트에 대해 2 x 24바이트 키, 2 x 20바이트 MAC 비밀, 2 x 8바이트 IV가 필요합니다. 핵심자료.

내보내기 가능한 암호화 알고리즘\(CipherSpec.is\_exportable이 true임\)은 최종 쓰기 키를 파생하기 위해 다음과 같은 추가 처리가 필요합니다.

```text
       final_client_write_key =
       PRF(SecurityParameters.client_write_key,
                                  "client write key",
                                  SecurityParameters.client_random +
                                  SecurityParameters.server_random);
       final_server_write_key =
       PRF(SecurityParameters.server_write_key,
                                  "server write key",
                                  SecurityParameters.client_random +
                                  SecurityParameters.server_random);
```

내보낼 수 있는 암호화 알고리즘은 hello 메시지의 임의 값에서만 IV를 파생합니다.

```text
       iv_block = PRF("", "IV block", SecurityParameters.client_random +
                      SecurityParameters.server_random);
```

iv\_block은 key\_block이 위와 같이 두 개의 초기화 벡터로 분할됩니다.

```text
       client_write_IV[SecurityParameters.IV_size]
       server_write_IV[SecurityParameters.IV_size]
```

이 경우 PRF는 비밀 없이 사용됩니다. 이는 단지 비밀의 길이가 0바이트이고 PRF의 해싱에 아무 것도 기여하지 않는다는 의미입니다.

---
#### **6.3.1. Export key generation example**

TLS\_RSA\_EXPORT\_WITH\_RC2\_CBC\_40\_MD5에는 2개의 암호화 키 각각에 대해 임의 바이트 5개가 필요하고 MAC 키 각각에 16바이트가 필요하므로 총 42바이트의 키 자료가 필요합니다. PRF 출력은 key\_block에 저장됩니다. key\_block은 분할되어 있으며 쓰기 키는 내보내기 가능한 암호화 알고리즘이기 때문에 솔트 처리되어 있습니다.

```text
       key_block               = PRF(master_secret,
                                     "key expansion",
                                     server_random +
                                     client_random)[0..41]
       client_write_MAC_secret = key_block[0..15]
       server_write_MAC_secret = key_block[16..31]
       client_write_key        = key_block[32..36]
       server_write_key        = key_block[37..41]

       final_client_write_key  = PRF(client_write_key,
                                     "client write key",
                                     client_random +
                                     server_random)[0..15]
       final_server_write_key  = PRF(server_write_key,
                                     "server write key",
                                     client_random +
                                     server_random)[0..15]

       iv_block                = PRF("", "IV block", client_random +
                                     server_random)[0..15]
       client_write_IV = iv_block[0..7]
       server_write_IV = iv_block[8..15]
```

---
## **7. The TLS Handshake Protocol**

TLS 핸드셰이크 프로토콜은 피어가 레코드 계층에 대한 보안 매개변수에 동의하고, 자신을 인증하고, 협상된 보안 매개변수를 인스턴스화하고, 오류 조건을 서로 보고할 수 있도록 하는 세 가지 하위 프로토콜 모음으로 구성됩니다.

핸드셰이크 프로토콜은 다음 항목으로 구성된 세션 협상을 담당합니다.

세션 식별자 - 활성 또는 재개 가능한 세션 상태를 식별하기 위해 서버에서 선택한 임의 바이트 시퀀스입니다.

피어 인증서 - X509v3 \[X509\] 피어의 인증서입니다. 이 상태 요소는 null일 수 있습니다.

압축 방법 - 암호화 전에 데이터를 압축하는 데 사용되는 알고리즘입니다.

암호 사양 - 대량 데이터 암호화 알고리즘\(예: null, DES 등\) 및 MAC 알고리즘\(예: MD5 또는 SHA\)을 지정합니다. 또한 hash\_size와 같은 암호화 속성을 정의합니다. \(공식 정의는 부록 A.6 참조\)

마스터 비밀 - 클라이언트와 서버 간에 공유되는 48바이트 비밀입니다.

재개 가능 - 새 연결을 시작하는 데 세션을 사용할 수 있는지 여부를 나타내는 플래그입니다.

그런 다음 이러한 항목은 애플리케이션 데이터를 보호할 때 레코드 계층에서 사용할 보안 매개변수를 생성하는 데 사용됩니다. TLS 핸드셰이크 프로토콜의 재개 ​​기능을 통해 동일한 세션을 사용하여 많은 연결을 인스턴스화할 수 있습니다.

---
### **7.1. Change cipher spec protocol**

암호화 사양 변경 프로토콜은 암호화 전략의 신호 전환을 위해 존재합니다. 프로토콜은 현재\(보류 중인 것이 아닌\) 연결 상태에서 암호화되고 압축되는 단일 메시지로 구성됩니다. 메시지는 값 1의 단일 바이트로 구성됩니다.

```text
       struct {
           enum { change_cipher_spec(1), (255) } type;
       } ChangeCipherSpec;
```

암호 사양 변경 메시지는 클라이언트와 서버 모두에서 전송되어 후속 레코드가 새로 협상된 CipherSpec 및 키에 따라 보호될 것임을 수신자에게 알립니다. 이 메시지를 수신하면 수신자는 읽기 보류 상태를 읽기 현재 상태로 즉시 복사하도록 레코드 계층에 지시하게 됩니다. 이 메시지를 보낸 후 즉시 발신자는 기록 계층에 쓰기 보류 상태를 쓰기 활성 상태로 만들도록 지시해야 합니다. \(섹션 6.1 참조\) 보안 매개변수가 합의된 후 확인 완료 메시지가 전송되기 전에 핸드셰이크 중에 암호 사양 변경 메시지가 전송됩니다\(섹션 7.4.9 참조\).

---
### **7.2. Alert protocol**

TLS 레코드 계층에서 지원하는 콘텐츠 유형 중 하나는 경고 유형입니다. 경고 메시지는 메시지의 심각도와 경고에 대한 설명을 전달합니다. 치명적인 수준의 경고 메시지는 연결을 즉시 종료합니다. 이 경우 해당 세션에 해당하는 다른 연결은 계속될 수 있지만 세션 식별자를 무효화하여 실패한 세션이 새로운 연결을 설정하는 데 사용되는 것을 방지해야 합니다. 다른 메시지와 마찬가지로 경고 메시지도 현재 연결 상태에 따라 암호화되고 압축됩니다.

```text
       enum { warning(1), fatal(2), (255) } AlertLevel;

       enum {
           close_notify(0),
           unexpected_message(10),
           bad_record_mac(20),
           decryption_failed(21),
           record_overflow(22),

           decompression_failure(30),
           handshake_failure(40),
           bad_certificate(42),
           unsupported_certificate(43),
           certificate_revoked(44),
           certificate_expired(45),
           certificate_unknown(46),
           illegal_parameter(47),
           unknown_ca(48),
           access_denied(49),
           decode_error(50),
           decrypt_error(51),
           export_restriction(60),
           protocol_version(70),
           insufficient_security(71),
           internal_error(80),
           user_canceled(90),
           no_renegotiation(100),
           (255)
       } AlertDescription;

       struct {
           AlertLevel level;
           AlertDescription description;
       } Alert;
```

---
#### **7.2.1. Closure alerts**

클라이언트와 서버는 잘림 공격을 피하기 위해 연결이 종료되고 있다는 정보를 공유해야 합니다. 어느 쪽이든 종료 메시지 교환을 시작할 수 있습니다.

close\_notify - 이 메시지는 발신자가 이 연결에서 더 이상 메시지를 보내지 않을 것임을 수신자에게 알립니다. 경고 수준의 적절한 close\_notify 메시지 없이 연결이 종료되면 세션을 재개할 수 없게 됩니다.

어느 쪽이든 close\_notify 경고를 보내 마감을 시작할 수 있습니다. 폐쇄 경고 이후 수신된 모든 데이터는 무시됩니다.

각 당사자는 연결의 쓰기 측을 닫기 전에 close\_notify 경고를 보내야 합니다. 상대방은 자체적으로 close\_notify 경고로 응답하고 연결을 즉시 종료하여 보류 중인 쓰기를 삭제해야 합니다. 닫기 시작자가 연결의 읽기 측을 닫기 전에 응답하는 close\_notify 경고를 기다릴 필요는 없습니다.

TLS를 사용하는 애플리케이션 프로토콜이 TLS 연결이 닫힌 후 기본 전송을 통해 모든 데이터가 전달될 수 있도록 제공하는 경우 TLS 구현은 TLS 연결이 종료되었음을 애플리케이션 계층에 알리기 전에 응답하는 close\_notify 경고를 수신해야 합니다. 애플리케이션 프로토콜이 추가 ​​데이터를 전송하지 않고 기본 전송 연결만 닫는 경우 구현에서는 close\_notify 응답을 기다리지 않고 전송을 닫도록 선택할 수 있습니다. 이 표준의 어떤 부분도 연결이 열리거나 닫힐 때를 포함하여 TLS용 사용 프로필이 데이터 전송을 관리하는 방식을 지시하는 데 사용되어서는 안 됩니다.

NB: 연결을 닫으면 전송이 중단되기 전에 보류 중인 데이터가 안정적으로 전달된다고 가정합니다.

---
#### **7.2.2. Error alerts**

TLS 핸드셰이크 프로토콜의 오류 처리는 매우 간단합니다. 오류가 감지되면 감지 당사자는 상대방에게 메시지를 보냅니다. 치명적인 경고 메시지를 전송하거나 수신하면 양측은 즉시 연결을 종료합니다. 서버와 클라이언트는 실패한 연결과 관련된 모든 세션 식별자, 키 및 비밀을 잊어야 합니다. 다음 오류 경고가 정의됩니다.

Unexpected\_message - 부적절한 메시지가 수신되었습니다. 이 경고는 항상 치명적이므로 적절한 구현 간의 통신에서 관찰되어서는 안 됩니다.

bad\_record\_mac - 잘못된 MAC로 레코드가 수신되면 이 경고가 반환됩니다. 이 메시지는 항상 치명적입니다.

decryption\_failed - 유효하지 않은 방식으로 해독된 TLSCiphertext: 블록 길이의 짝수가 아니었거나 확인 시 패딩 값이 올바르지 않았습니다. 이 메시지는 항상 치명적입니다.

Record\_overflow - 길이가 2^14+2048바이트를 초과하는 TLSCiphertext 레코드가 수신되었거나 2^14+1024바이트를 초과하는 TLSCompressed 레코드로 암호 해독된 레코드가 수신되었습니다. 이 메시지는 항상 치명적입니다.

decompression\_failure - 압축 해제 함수가 부적절한 입력을 받았습니다\(예: 과도한 길이로 확장되는 데이터\). 이 메시지는 항상 치명적입니다.

handshake\_failure - handshake\_failure 경고 메시지의 수신은 발신자가 사용 가능한 옵션이 있는 경우 허용되는 보안 매개변수 집합을 협상할 수 없음을 나타냅니다. 이는 치명적인 오류입니다.

bad\_certificate - 인증서가 손상되었거나 올바르게 확인되지 않은 서명이 포함되어 있습니다.

unsupported\_certificate - 인증서가 지원되지 않는 유형이었습니다.

Certificate\_revoked - 서명자가 인증서를 취소했습니다.

Certificate\_expired - 인증서가 만료되었거나 현재 유효하지 않습니다.

Certificate\_unknown - 인증서를 처리하는 중에 다른\(지정되지 않은\) 문제가 발생하여 인증서를 사용할 수 없게 되었습니다.

불법\_파라미터 - 핸드셰이크의 필드가 범위를 벗어났거나 다른 필드와 일치하지 않습니다. 이것은 항상 치명적입니다.

알 수 없음\_ca - 유효한 인증서 체인 또는 부분 체인이 수신되었지만 CA 인증서를 찾을 수 없거나 알려진 신뢰할 수 있는 CA와 일치할 수 없기 때문에 인증서가 승인되지 않았습니다. 이 메시지는 항상 치명적입니다.

access\_denied - 유효한 인증서를 받았으나 접근 제어가 적용되었을 때 발신자가 협상을 진행하지 않기로 결정했습니다. 이 메시지는 항상 치명적입니다.

decode\_error - 일부 필드가 지정된 범위를 벗어났거나 메시지 길이가 올바르지 않아 메시지를 디코딩할 수 없습니다. 이 메시지는 항상 치명적입니다.

decrypt\_error - 서명을 올바르게 확인하거나, 키 교환을 해독하거나, 완료된 메시지를 확인할 수 없는 등 핸드셰이크 암호화 작업이 실패했습니다.

수출 제한 - 수출 제한을 준수하지 않는 협상이 감지되었습니다. 예를 들어 RSA\_EXPORT 핸드셰이크 방법에 대한 1024비트 임시 RSA 키 전송을 시도합니다. 이 메시지는 항상 치명적입니다.

프로토콜\_버전 - 클라이언트가 협상을 시도한 프로토콜 버전이 인식되지만 지원되지 않습니다. \(예를 들어, 보안상의 이유로 이전 프로토콜 버전은 사용하지 않을 수 있습니다.\) 이 메시지는 항상 치명적입니다.

불충분한\_보안 - 서버가 클라이언트에서 지원하는 것보다 더 안전한 암호를 요구하기 때문에 특히 협상이 실패한 경우 handshake\_failure 대신 반환됩니다. 이 메시지는 항상 치명적입니다.

Internal\_error - 피어와 관련되지 않은 내부 오류 또는 프로토콜의 정확성으로 인해 계속할 수 없게 됩니다\(예: 메모리 할당 실패\). 이 메시지는 항상 치명적입니다.

user\_canceled - 이 핸드셰이크는 프로토콜 오류와 무관한 어떤 이유로 취소되고 있습니다. 핸드셰이크가 완료된 후 사용자가 작업을 취소하는 경우 close\_notify를 전송하여 연결을 닫는 것이 더 적절합니다. 이 경고 뒤에는 close\_notify가 와야 합니다. 이 메시지는 일반적으로 경고입니다.

no\_renegotiation - hello 요청에 대한 응답으로 클라이언트가 전송하거나 초기 핸드셰이크 이후 클라이언트 hello에 대한 응답으로 서버가 전송합니다. 둘 중 하나는 일반적으로 재협상으로 이어집니다. 그것이 적절하지 않은 경우 수신자는 이 경고로 응답해야 합니다. 이 시점에서 원래 요청자는 연결을 계속할지 여부를 결정할 수 있습니다. 이것이 적절한 경우 중 하나는 서버가 요청을 충족하기 위해 프로세스를 생성한 경우입니다. 프로세스는 시작 시 보안 매개변수\(키 길이, 인증 등\)를 수신할 수 있으며 그 이후에는 이러한 매개변수에 대한 변경 사항을 전달하기 어려울 수 있습니다. 이 메시지는 항상 경고입니다.

경고 수준이 명시적으로 지정되지 않은 모든 오류의 경우 전송 당사자는 재량에 따라 이것이 치명적인 오류인지 여부를 결정할 수 있습니다. 경고 수준의 경보가 수신되면

수신자는 이를 치명적인 오류로 간주할지 여부를 재량에 따라 결정할 수 있습니다. 그러나 치명적 수준으로 전송되는 모든 메시지는 치명적 메시지로 처리되어야 합니다.

---
### **7.3. Handshake Protocol overview**

세션 상태의 암호화 매개변수는 TLS 레코드 레이어 위에서 작동하는 TLS 핸드셰이크 프로토콜에 의해 생성됩니다. TLS 클라이언트와 서버가 처음 통신을 시작하면 프로토콜 버전에 동의하고, 암호화 알고리즘을 선택하고, 선택적으로 서로를 인증하고, 공개 키 암호화 기술을 사용하여 공유 비밀을 생성합니다.

TLS 핸드셰이크 프로토콜에는 다음 단계가 포함됩니다.

- 알고리즘에 동의하고, 임의의 값을 교환하고, 세션 재개를 확인하기 위해 인사 메시지를 교환합니다.

- 클라이언트와 서버가 프리마스터 비밀에 동의할 수 있도록 필요한 암호화 매개변수를 교환합니다.

- 클라이언트와 서버가 스스로 인증할 수 있도록 인증서와 암호화 정보를 교환합니다.

- 프리마스터 시크릿에서 마스터 시크릿을 생성하고 임의의 값을 교환합니다.

- 레코드 레이어에 보안 매개변수를 제공합니다.

- 클라이언트와 서버가 피어가 동일한 보안 매개변수를 계산했는지, 공격자에 의한 변조 없이 핸드셰이크가 발생했는지 확인할 수 있도록 허용합니다.

상위 계층은 항상 두 피어 간의 가능한 가장 강력한 연결을 협상하는 TLS에 지나치게 의존해서는 안 됩니다. 중간 공격자가 두 엔터티가 지원하는 가장 덜 안전한 방법으로 떨어지도록 시도할 수 있는 방법에는 여러 가지가 있습니다. 프로토콜은 이러한 위험을 최소화하도록 설계되었지만 여전히 공격이 가능합니다. 예를 들어 공격자는 보안 서비스가 실행되는 포트에 대한 액세스를 차단하거나 피어가 인증되지 않은 연결을 협상하도록 시도할 수 있습니다. 기본 규칙은 더 높은 수준이 보안 요구 사항을 인식해야 하며 필요한 것보다 덜 안전한 채널을 통해 정보를 전송하지 않는다는 것입니다. TLS 프로토콜은 안전합니다. 모든 암호 제품군은 약속된 보안 수준을 제공합니다. 인증서를 확인한 호스트와 1024비트 RSA 키 교환을 통해 3DES를 협상하면 그만큼 안전할 것으로 기대할 수 있습니다.

그러나 데이터가 해당 암호화를 깨는 데 필요한 노력만큼 가치가 없다고 생각하지 않는 한 40비트 보안으로 암호화된 링크를 통해 데이터를 전송해서는 안 됩니다.

이러한 목표는 다음과 같이 요약될 수 있는 핸드셰이크 프로토콜에 의해 달성됩니다. 클라이언트는 서버가 서버 안녕하세요 메시지로 응답해야 하는 클라이언트 안녕하세요 메시지를 보냅니다. 그렇지 않으면 치명적인 오류가 발생하고 연결이 실패합니다. 클라이언트 hello 및 서버 hello는 클라이언트와 서버 간의 보안 강화 기능을 설정하는 데 사용됩니다. 클라이언트 hello 및 서버 hello는 프로토콜 버전, 세션 ID, 암호 제품군 및 압축 방법과 같은 속성을 설정합니다. 또한 두 개의 임의 값\(ClientHello.random 및 ServerHello.random\)이 생성되고 교환됩니다.

실제 키 교환에서는 서버 인증서, 서버 키 교환, 클라이언트 인증서, 클라이언트 키 교환 등 최대 4개의 메시지를 사용합니다. 이러한 메시지의 형식을 지정하고 클라이언트와 서버가 공유 비밀에 동의할 수 있도록 메시지 사용을 정의하여 새로운 키 교환 방법을 만들 수 있습니다. 이 비밀은 꽤 길어야 합니다. 현재 정의된 키 교환 방법은 길이가 48\~128바이트인 비밀을 교환합니다.

hello 메시지에 이어 서버는 인증을 받아야 하는 경우 인증서를 보냅니다. 또한 필요한 경우\(예: 서버에 인증서가 없거나 해당 인증서가 서명 전용인 경우\) 서버 키 교환 메시지가 전송될 수 있습니다. 서버가 인증되면 선택한 암호 제품군에 적합한 경우 클라이언트로부터 인증서를 요청할 수 있습니다. 이제 서버는 핸드셰이크의 hello-message 단계가 완료되었음을 나타내는 서버 hello done 메시지를 보냅니다. 그러면 서버는 클라이언트 응답을 기다립니다. 서버가 인증서 요청 메시지를 보낸 경우 클라이언트는 인증서 메시지를 보내야 합니다. 이제 클라이언트 키 교환 메시지가 전송되고 해당 메시지의 내용은 클라이언트 hello와 서버 hello 사이에서 선택된 공개 키 알고리즘에 따라 달라집니다. 클라이언트가 서명 기능이 있는 인증서를 보낸 경우 인증서를 명시적으로 확인하기 위해 디지털 서명된 인증서 확인 메시지가 전송됩니다.

이때 클라이언트는 Change cipher Spec 메시지를 전송하고 클라이언트는 보류 중인 Cipher Spec을 현재 Cipher Spec에 복사합니다. 그런 다음 클라이언트는 즉시 새로운 알고리즘, 키 및 비밀에 따라 완성된 메시지를 보냅니다. 이에 대한 응답으로 서버는 자체 암호 사양 변경 메시지를 보내고 보류 중인 암호 사양을 현재 암호 사양으로 전송한 다음 완료된 메시지를 새 암호 사양으로 보냅니다.

암호 사양 이 시점에서 핸드셰이크가 완료되고 클라이언트와 서버는 애플리케이션 계층 데이터 교환을 시작할 수 있습니다. \(아래 흐름도를 참고하세요.\)

```text
      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

             Fig. 1 - Message flow for a full handshake
```

\* 항상 전송되지 않는 선택적 메시지 또는 상황에 따른 메시지를 나타냅니다.

참고: 파이프라인 중단을 방지하기 위해 ChangeCipherSpec은 독립적인 TLS 프로토콜 콘텐츠 유형이며 실제로는 TLS 핸드셰이크 메시지가 아닙니다.

클라이언트와 서버가 이전 세션을 재개하거나 기존 세션을 복제하기로 결정한 경우\(새 보안 매개변수를 협상하는 대신\) 메시지 흐름은 다음과 같습니다.

클라이언트는 재개할 세션의 세션 ID를 사용하여 ClientHello를 보냅니다. 그런 다음 서버는 일치하는 항목이 있는지 세션 캐시를 확인합니다. 일치하는 항목이 발견되고 서버가 지정된 세션 상태에서 연결을 다시 설정하려는 경우 동일한 세션 ID 값을 사용하여 ServerHello를 보냅니다. 이 시점에서 클라이언트와 서버는 모두 암호 사양 변경 메시지를 보내고 완료된 메시지로 직접 진행해야 합니다. 재설정이 완료되면 클라이언트와 서버는 애플리케이션 계층 데이터 교환을 시작할 수 있습니다. \(아래 흐름도를 참조하세요.\) 세션 ID 일치가 발견되지 않으면 서버는 새 세션 ID를 생성하고 TLS 클라이언트와 서버는 전체 핸드셰이크를 수행합니다.

```text
      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
      [ChangeCipherSpec]
      Finished                      -------->
      Application Data              <------->     Application Data

          Fig. 2 - Message flow for an abbreviated handshake
```

각 메시지의 내용과 의미는 다음 섹션에서 자세히 설명됩니다.

---
### **7.4. Handshake protocol**

TLS 핸드셰이크 프로토콜은 TLS 레코드 프로토콜의 정의된 상위 수준 클라이언트 중 하나입니다. 이 프로토콜은 세션의 보안 속성을 협상하는 데 사용됩니다. 핸드셰이크 메시지는 TLS 레코드 레이어에 제공되며, 여기서 메시지는 하나 이상의 TLSPlaintext 구조 내에 캡슐화되어 현재 활성 세션 상태에 지정된 대로 처리 및 전송됩니다.

```text
       enum {
           hello_request(0), client_hello(1), server_hello(2),
           certificate(11), server_key_exchange (12),
           certificate_request(13), server_hello_done(14),
           certificate_verify(15), client_key_exchange(16),
           finished(20), (255)
       } HandshakeType;

       struct {
           HandshakeType msg_type;    /* handshake type */
           uint24 length;             /* bytes in message */
           select (HandshakeType) {
               case hello_request:       HelloRequest;
               case client_hello:        ClientHello;
               case server_hello:        ServerHello;
               case certificate:         Certificate;
               case server_key_exchange: ServerKeyExchange;
               case certificate_request: CertificateRequest;
               case server_hello_done:   ServerHelloDone;
               case certificate_verify:  CertificateVerify;
               case client_key_exchange: ClientKeyExchange;
               case finished:            Finished;
           } body;
       } Handshake;
```

핸드셰이크 프로토콜 메시지는 전송되어야 하는 순서대로 아래에 표시됩니다. 예상치 못한 순서로 핸드셰이크 메시지를 보내면 치명적인 오류가 발생합니다. 그러나 불필요한 핸드셰이크 메시지는 생략할 수 있습니다. 순서에 대한 한 가지 예외에 유의하십시오. 인증서 메시지는 핸드셰이크\(서버에서 클라이언트로, 그 다음 클라이언트에서 서버로\)에서 두 번 사용되지만 첫 번째 위치에서만 설명됩니다. Hello 요청 메시지에서 이러한 순서 규칙에 구속되지 않는 메시지는 언제든지 보낼 수 있지만 핸드셰이크 도중에 도착하면 클라이언트에서 무시해야 합니다.

---
#### **7.4.1. Hello messages**

Hello 단계 메시지는 클라이언트와 서버 간에 보안 강화 기능을 교환하는 데 사용됩니다. 새 세션이 시작되면 레코드 레이어의 연결 상태 암호화, 해시 및 압축 알고리즘이 null로 초기화됩니다. 현재 연결 상태는 재협상 메시지에 사용됩니다.

---
##### **7.4.1.1. Hello request**

이 메시지가 전송되는 시기: - Hello 요청 메시지는 언제든지 서버에서 전송될 수 있습니다.

이 메시지의 의미: - Hello 요청은 편리할 때 클라이언트 Hello 메시지를 보내 클라이언트가 협상 프로세스를 새로 시작해야 한다는 간단한 알림입니다. 클라이언트가 현재 세션을 협상 중인 경우 이 메시지는 클라이언트에서 무시됩니다. 세션 재협상을 원하지 않는 경우 클라이언트는 이 메시지를 무시할 수 있으며, 클라이언트가 원하는 경우 no\_renegotiation 경고로 응답할 수 있습니다. 핸드셰이크 메시지는 애플리케이션 데이터보다 전송 우선순위를 가지도록 되어 있으므로 클라이언트로부터 몇 개의 레코드만 수신되기 전에 협상이 시작될 것으로 예상됩니다. 서버가 hello 요청을 보냈지만 응답으로 클라이언트 hello를 받지 못한 경우 치명적인 경고와 함께 연결이 종료될 수 있습니다.

hello 요청을 보낸 후 서버는 후속 핸드셰이크 협상이 완료될 때까지 요청을 반복해서는 안 됩니다.

이 메시지의 구조: - struct { } HelloRequest;

참고: 이 메시지는 핸드셰이크 전체에서 유지 관리되고 완료된 메시지와 인증서 확인 메시지에 사용되는 메시지 해시에 포함되어서는 안 됩니다.

---
##### **7.4.1.2. Client hello**

이 메시지가 전송되는 시기: - 클라이언트가 처음 서버에 연결할 때 첫 번째 메시지로 클라이언트 hello를 보내야 합니다. 클라이언트는 기존 연결의 보안 매개변수를 재협상하기 위해 hello 요청에 대한 응답으로 또는 자체적으로 클라이언트 hello를 보낼 수도 있습니다.

```text
       Structure of this message:
           The client hello message includes a random structure, which is
           used later in the protocol.

           struct {
              uint32 gmt_unix_time;
              opaque random_bytes[28];
           } Random;
```

- gmt\_unix\_time 보낸 사람의 내부 시계에 따른 표준 UNIX 32비트 형식\(GMT 1970년 1월 1일 자정 이후의 초\)의 현재 시간과 날짜입니다. 기본 TLS 프로토콜에서는 시계를 올바르게 설정할 필요가 없습니다. 더 높은 수준 또는 응용 프로그램 프로토콜은 추가 요구 사항을 정의할 수 있습니다.

random\_bytes - 보안 난수 생성기에 의해 생성된 28바이트입니다.

클라이언트 안녕하세요 메시지에는 가변 길이 세션 식별자가 포함됩니다. 비어 있지 않은 경우 값은 클라이언트가 재사용하려는 보안 매개변수가 있는 동일한 클라이언트와 서버 간의 세션을 식별합니다. 세션 식별자는 이전 연결, 이 연결 또는 현재 활성화된 다른 연결에서 나올 수 있습니다. 두 번째 옵션은 클라이언트가 연결의 무작위 구조와 파생 값만 업데이트하려는 경우에 유용하며, 세 번째 옵션을 사용하면 전체 핸드셰이크 프로토콜을 반복하지 않고도 여러 개의 독립적인 보안 연결을 설정할 수 있습니다. 이러한 독립적인 연결은 순차적으로 또는 동시에 발생할 수 있습니다. SessionID는 협상하는 핸드셰이크가 완료됨 메시지 교환으로 완료되고 노화로 인해 제거되거나 세션과 관련된 연결에서 치명적인 오류가 발생하여 제거될 때까지 지속되면 유효해집니다. SessionID의 실제 내용은 서버에 의해 정의됩니다.

```text
       opaque SessionID<0..32>;
```

경고: - SessionID는 암호화 또는 즉각적인 MAC 보호 없이 전송되므로 서버는 세션 식별자에 기밀 정보를 배치하거나 가짜 세션 식별자의 내용으로 인해 보안 위반이 발생하도록 해서는 안 됩니다. \(SessionID를 포함하여 전체적으로 핸드셰이크의 내용은 핸드셰이크가 끝날 때 교환되는 완료 메시지에 의해 보호됩니다.\)

클라이언트 hello 메시지를 통해 클라이언트에서 서버로 전달되는 CipherSuite 목록에는 클라이언트가 선호하는 순서\(가장 선호하는 항목부터\)에 따라 클라이언트가 지원하는 암호화 알고리즘의 조합이 포함되어 있습니다. 각 CipherSuite는 키 교환 알고리즘, 대량 암호화 알고리즘\(비밀 키 길이 포함\) 및 MAC 알고리즘을 정의합니다. 서버는 암호 제품군을 선택하거나, 허용 가능한 선택 사항이 없으면 핸드셰이크 실패 경고를 반환하고 연결을 닫습니다.

```text
       uint8 CipherSuite[2];    /* Cryptographic suite selector */
```

클라이언트 hello에는 클라이언트가 지원하는 압축 알고리즘 목록이 포함되어 있으며 클라이언트의 기본 설정에 따라 정렬됩니다.

```text
       enum { null(0), (255) } CompressionMethod;

       struct {
           ProtocolVersion client_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suites<2..2^16-1>;
           CompressionMethod compression_methods<1..2^8-1>;
       } ClientHello;
```

client\_version - 클라이언트가 이 세션 동안 통신하기를 원하는 TLS 프로토콜의 버전입니다. 이는 클라이언트가 지원하는 최신\(가장 높은 값\) 버전이어야 합니다. 이 사양 버전의 경우 버전은 3.1입니다\(이전 버전과의 호환성에 대한 자세한 내용은 부록 E 참조\).

무작위 - 클라이언트가 생성한 무작위 구조입니다.

session\_id - 클라이언트가 이 연결에 사용하려는 세션의 ID입니다. session\_id를 사용할 수 없거나 클라이언트가 새 보안 매개변수를 생성하려는 경우 이 필드는 비어 있어야 합니다.

cipher\_suites - 클라이언트가 지원하는 암호화 옵션 목록이며 클라이언트의 첫 번째 기본 설정이 먼저입니다. session\_id 필드가 비어 있지 않은 경우\(세션 재개 요청 암시\) 이 벡터에는 최소한 해당 세션의 cipher\_suite가 포함되어야 합니다. 값은 부록 A.5에 정의되어 있습니다.

압축\_방법 - 클라이언트가 지원하는 압축 방법 목록이며 클라이언트 기본 설정에 따라 정렬됩니다. session\_id 필드가 비어 있지 않은 경우\(세션 재개 요청 암시\) 해당 세션의 압축 방법을 포함해야 합니다. 이 벡터는 CompressionMethod.null을 포함하고 모든 구현에서 지원해야 합니다. 따라서 클라이언트와 서버는 항상 압축 방법에 동의할 수 있습니다.

클라이언트 Hello 메시지를 보낸 후 클라이언트는 서버 Hello 메시지를 기다립니다. Hello 요청을 제외하고 서버에서 반환된 다른 핸드셰이크 메시지는 치명적인 오류로 처리됩니다.

상위 호환성 참고 사항: - 상위 호환성을 위해 클라이언트 안녕하세요 메시지에 압축 방법 이후에 추가 데이터를 포함하는 것이 허용됩니다. 이 데이터는 핸드셰이크 해시에 포함되어야 하지만 그렇지 않으면 무시되어야 합니다. 이것은 이것이 합법적인 유일한 핸드셰이크 메시지입니다. 다른 모든 메시지의 경우 메시지의 데이터 양이 메시지 설명과 정확히 일치해야 합니다.

---
##### **7.4.1.3. Server hello**

이 메시지가 전송되는 시기: - 서버는 허용 가능한 알고리즘 세트를 찾을 수 있을 때 클라이언트 안녕하세요 메시지에 대한 응답으로 이 메시지를 보냅니다. 일치하는 항목을 찾을 수 없으면 핸드셰이크 실패 경고로 응답합니다.

```text
   Structure of this message:
       struct {
           ProtocolVersion server_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suite;
           CompressionMethod compression_method;
       } ServerHello;
```

server\_version - 이 필드에는 클라이언트 hello에서 클라이언트가 제안한 것 중 낮은 값과 서버에서 지원하는 가장 높은 값이 포함됩니다. 이 사양 버전의 경우 버전은 3.1입니다\(이전 버전과의 호환성에 대한 자세한 내용은 부록 E 참조\).

무작위 - 이 구조는 서버에 의해 생성되며 ClientHello.random과 달라야 합니다\(그리고 독립적이어야 합니다\).

session\_id - 이 연결에 해당하는 세션의 ID입니다. ClientHello.session\_id가 비어 있지 않으면 서버는 세션 캐시에서 일치하는 항목을 찾습니다. 일치하는 항목이 발견되고 서버가 지정된 세션 상태를 사용하여 새 연결을 설정하려는 경우 서버는 클라이언트가 제공한 것과 동일한 값으로 응답합니다. 이는 재개된 세션을 나타내며 당사자가 완료된 메시지로 직접 진행해야 함을 나타냅니다. 그렇지 않으면 이 필드에는 새 세션을 식별하는 다른 값이 포함됩니다. 서버는 세션이 캐시되지 않아 재개될 수 없음을 나타내기 위해 빈 session\_id를 반환할 수 있습니다. 세션이 재개되면 원래 협상했던 것과 동일한 암호화 제품군을 사용하여 재개되어야 합니다.

cipher\_suite - ClientHello.cipher\_suites의 목록에서 서버가 선택한 단일 암호 제품군입니다. 재개된 세션의 경우 이 필드는 재개되는 세션 상태의 값입니다.

압축\_방법 - ClientHello.compression\_methods의 목록에서 서버가 선택한 단일 압축 알고리즘입니다. 재개된 세션의 경우 이 필드는 재개된 세션 상태의 값입니다.

---
#### **7.4.2. Server certificate**

이 메시지가 전송되는 시기: - 합의된 키 교환 방법이 익명이 아닐 때마다 서버는 인증서를 보내야 합니다. 이 메시지는 항상 서버 Hello 메시지 바로 뒤에 표시됩니다.

이 메시지의 의미: - 인증서 유형은 선택한 암호화 제품군의 키 교환 알고리즘에 적합해야 하며 일반적으로 X.509v3 인증서입니다. 다음과 같이 키 교환 방법과 일치하는 키를 포함해야 합니다. 달리 명시하지 않는 한 서명은

- 인증서 알고리즘은 인증서 키 알고리즘과 동일해야 합니다. 달리 지정하지 않는 한 공개 키의 길이는 제한되지 않습니다.

```text
       Key Exchange Algorithm  Certificate Key Type

       RSA                     RSA public key; the certificate must
                               allow the key to be used for encryption.

       RSA_EXPORT              RSA public key of length greater than
                               512 bits which can be used for signing,
                               or a key of 512 bits or shorter which
                               can be used for either encryption or
                               signing.

       DHE_DSS                 DSS public key.

       DHE_DSS_EXPORT          DSS public key.

       DHE_RSA                 RSA public key which can be used for
                               signing.

       DHE_RSA_EXPORT          RSA public key which can be used for
                               signing.

       DH_DSS                  Diffie-Hellman key. The algorithm used
                               to sign the certificate should be DSS.

       DH_RSA                  Diffie-Hellman key. The algorithm used
                               to sign the certificate should be RSA.
```

모든 인증서 프로필, 키 및 암호화 형식은 IETF PKIX 작업 그룹 \[PKIX\]에 의해 정의됩니다. 키 사용 확장이 있는 경우 위에 설명된 대로 서명에 적합한 키에 대해 digitalSignature 비트가 설정되어야 하며, 위에 설명된 대로 암호화를 허용하려면 keyEncipherment 비트가 있어야 합니다. keyAgreement 비트는 Diffie-Hellman 인증서에 설정되어야 합니다.

새로운 키 교환 방법을 지정하는 CipherSuites는 TLS 프로토콜에 대해 지정되므로 인증서 형식과 필요한 인코딩된 키 정보를 암시합니다.

이 메시지의 구조: - 불투명 ASN.1Cert<1..2^24-1\>;

```text
       struct {
           ASN.1Cert certificate_list<0..2^24-1>;
       } Certificate;
```

Certificate\_list - X.509v3 인증서의 시퀀스\(체인\)입니다. 보낸 사람의 인증서가 목록에서 가장 먼저 나와야 합니다. 다음 각 인증서는 이전 인증서를 직접 인증해야 합니다. 인증서 유효성 검사에는 루트 키를 독립적으로 배포해야 하기 때문에 루트 인증 기관을 지정하는 자체 서명된 인증서는 선택적으로 체인에서 생략될 수 있습니다. 단, 어떤 경우든 이를 검증하기 위해 원격 측이 이미 인증서를 소유하고 있어야 한다는 가정하에 가능합니다.

인증서 요청 메시지에 대한 클라이언트의 응답에는 동일한 메시지 유형과 구조가 사용됩니다. 서버의 인증 요청에 대한 응답으로 보낼 적절한 인증서가 없는 경우 클라이언트는 인증서를 보내지 않을 수 있습니다.

참고: PKCS #6 \[PKCS6\] 확장 인증서가 사용되지 않기 때문에 PKCS #7 \[PKCS7\]은 인증서 벡터의 형식으로 사용되지 않습니다. 또한 PKCS #7은 SEQUENCE가 아닌 SET을 정의하므로 목록 구문 분석 작업이 더 어려워집니다.

---
#### **7.4.3. Server key exchange message**

이 메시지가 전송되는 시기: - 이 메시지는 서버 인증서 메시지\(또는 익명 협상인 경우 서버 Hello 메시지\) 직후에 전송됩니다.

- 서버 키 교환 메시지는 서버 인증서 메시지\(전송된 경우\)에 클라이언트가 프리마스터 비밀을 교환할 수 있을 만큼 충분한 데이터가 포함되지 않은 경우에만 서버에서 전송됩니다. 이는 다음 키 교환 방법에 해당됩니다.

```text
           RSA_EXPORT (if the public key in the server certificate is
           longer than 512 bits)
           DHE_DSS
           DHE_DSS_EXPORT
           DHE_RSA
           DHE_RSA_EXPORT
           DH_anon
```

- 다음과 같은 키 교환 방법으로 서버 키 교환 메시지를 보내는 것은 불법입니다.

```text
           RSA
           RSA_EXPORT (when the public key in the server certificate is
           less than or equal to 512 bits in length)
           DH_DSS
           DH_RSA
```

이 메시지의 의미: - 이 메시지는 클라이언트가 프리마스터 비밀을 전달할 수 있도록 암호화 정보를 전달합니다. 즉, 프리마스터 비밀을 암호화하기 위한 RSA 공개 키 또는 클라이언트가 키 교환을 완료할 수 있는 Diffie-Hellman 공개 키\( 그 결과가 프리마스터 비밀이 됩니다.\)

새로운 키 교환 알고리즘을 포함하는 TLS에 대해 추가 CipherSuites가 정의되어 있으므로 키 교환 알고리즘과 관련된 인증서 유형이 클라이언트가 프리마스터 비밀을 교환하는 데 충분한 정보를 제공하지 않는 경우에만 서버 키 교환 메시지가 전송됩니다.

참고: 현행 미국 수출법에 따르면 512비트보다 큰 RSA 모듈은 미국에서 수출되는 소프트웨어의 키 교환에 사용할 수 없습니다. 이 메시지를 사용하면 인증서에 인코딩된 더 큰 RSA 키가 RSA\_EXPORT 키 교환 방법에 대한 임시 더 짧은 RSA 키에 서명하는 데 사용될 수 있습니다.

이 메시지의 구조: - enum { rsa, diffie\_hellman } KeyExchangeAlgorithm;

```text
       struct {
           opaque rsa_modulus<1..2^16-1>;
           opaque rsa_exponent<1..2^16-1>;
       } ServerRSAParams;

       rsa_modulus
           The modulus of the server's temporary RSA key.

       rsa_exponent
           The public exponent of the server's temporary RSA key.

       struct {
           opaque dh_p<1..2^16-1>;
           opaque dh_g<1..2^16-1>;
           opaque dh_Ys<1..2^16-1>;
       } ServerDHParams;     /* Ephemeral DH parameters */

       dh_p
           The prime modulus used for the Diffie-Hellman operation.

       dh_g
           The generator used for the Diffie-Hellman operation.

       dh_Ys
           The server's Diffie-Hellman public value (g^X mod p).

       struct {
           select (KeyExchangeAlgorithm) {
               case diffie_hellman:
                   ServerDHParams params;
                   Signature signed_params;
               case rsa:
                   ServerRSAParams params;
                   Signature signed_params;
           };
       } ServerKeyExchange;

       params
           The server's key exchange parameters.

       signed_params
           For non-anonymous key exchanges, a hash of the corresponding
           params value, with the signature appropriate to that hash
           applied.

       md5_hash
           MD5(ClientHello.random + ServerHello.random + ServerParams);

       sha_hash
           SHA(ClientHello.random + ServerHello.random + ServerParams);

       enum { anonymous, rsa, dsa } SignatureAlgorithm;

       select (SignatureAlgorithm)
       {   case anonymous: struct { };
           case rsa:
               digitally-signed struct {
                   opaque md5_hash[16];
                   opaque sha_hash[20];
               };
           case dsa:
               digitally-signed struct {
                   opaque sha_hash[20];
               };
       } Signature;
```

---
#### **7.4.4. Certificate request**

이 메시지가 전송되는 시기: - 선택한 암호화 제품군에 적합한 경우 익명이 아닌 서버는 선택적으로 클라이언트로부터 인증서를 요청할 수 있습니다. 이 메시지가 전송된 경우 서버 키 교환 메시지 바로 뒤에 표시됩니다\(전송된 경우에는 서버 인증서 메시지\).

```text
   Structure of this message:
       enum {
           rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
           (255)
       } ClientCertificateType;

       opaque DistinguishedName<1..2^16-1>;

       struct {
           ClientCertificateType certificate_types<1..2^8-1>;
           DistinguishedName certificate_authorities<3..2^16-1>;
       } CertificateRequest;

       certificate_types
              This field is a list of the types of certificates requested,
              sorted in order of the server's preference.

       certificate_authorities
           A list of the distinguished names of acceptable certificate
           authorities. These distinguished names may specify a desired
           distinguished name for a root CA or for a subordinate CA;
           thus, this message can be used both to describe known roots
           and a desired authorization space.
```

참고: DistinguishedName은 \[X509\]에서 파생됩니다.

참고: 익명 서버가 클라이언트 식별을 요청하는 것은 치명적인 handshake\_failure 경고입니다.

---
#### **7.4.5. Server hello done**

이 메시지가 전송되는 시기: - 서버 안녕하세요 완료 메시지는 서버 안녕하세요 및 관련 메시지의 끝을 나타내기 위해 서버에서 전송됩니다. 이 메시지를 보낸 후 서버는 클라이언트 응답을 기다립니다.

이 메시지의 의미: - 이 메시지는 서버가 키 교환을 지원하기 위한 메시지 전송을 완료했으며 클라이언트가 키 교환 단계를 진행할 수 있음을 의미합니다.

- 서버 안녕하세요 완료 메시지를 수신하면 클라이언트는 필요한 경우 서버가 유효한 인증서를 제공했는지 확인하고 서버 안녕하세요 매개변수가 허용되는지 확인해야 합니다.

이 메시지의 구조: - struct { } ServerHelloDone;

---
#### **7.4.6. Client certificate**

이 메시지가 전송되는 시기: - 클라이언트가 서버 안녕하세요 완료 메시지를 받은 후 보낼 수 있는 첫 번째 메시지입니다. 이 메시지는 서버가 인증서를 요청하는 경우에만 전송됩니다. 적합한 인증서를 사용할 수 없는 경우 클라이언트는 인증서가 포함되지 않은 인증서 메시지를 보내야 합니다. 핸드셰이크를 계속하기 위해 서버에서 클라이언트 인증이 필요한 경우 치명적인 핸드셰이크 실패 경고로 응답할 수 있습니다. 클라이언트 인증서는 섹션 7.4.2에 정의된 인증서 구조를 사용하여 전송됩니다.

참고: 정적 Diffie-Hellman 기반 키 교환 방법\(DH\_DSS 또는 DH\_RSA\)을 사용할 때 클라이언트 인증이 요청되면 클라이언트 인증서에 인코딩된 Diffie-Hellman 그룹 및 생성기는 클라이언트 매개변수가 지정된 경우 서버가 지정한 Diffie-Hellman 매개변수와 일치해야 합니다. 키 교환에 사용됩니다.

---
#### **7.4.7. Client key exchange message**

이 메시지가 전송되는 시기: - 이 메시지는 항상 클라이언트에 의해 전송됩니다. 전송된 경우 클라이언트 인증서 메시지 바로 뒤에 표시됩니다. 그렇지 않으면 클라이언트가 서버 안녕하세요 완료 메시지를 받은 후 보낸 첫 번째 메시지가 됩니다.

이 메시지의 의미: - 이 메시지를 통해 RSA 암호화 비밀을 직접 전송하거나 각 측이 동일한 프리마스터 비밀에 동의할 수 있도록 하는 Diffie-Hellman 매개변수를 전송하여 프리마스터 비밀이 설정됩니다. 키 교환 방법이 DH\_RSA 또는 DH\_DSS인 경우 클라이언트 인증이 요청되었으며 클라이언트는 서버가 인증서에 지정한 매개변수\(그룹 및 생성기\)와 일치하는 Diffie-Hellman 공개 키가 포함된 인증서로 응답할 수 있었습니다. , 이 메시지에는 데이터가 포함되지 않습니다.

이 메시지의 구조: - 메시지 선택은 선택한 키 교환 방법에 따라 다릅니다. KeyExchangeAlgorithm 정의는 섹션 7.4.3을 참조하세요.

```text
       struct {
           select (KeyExchangeAlgorithm) {
               case rsa: EncryptedPreMasterSecret;
               case diffie_hellman: ClientDiffieHellmanPublic;

           } exchange_keys;
       } ClientKeyExchange;
```

---
##### **7.4.7.1. RSA encrypted premaster secret message**

이 메시지의 의미: - RSA가 키 계약 및 인증에 사용되는 경우 클라이언트는 48바이트 프리마스터 비밀을 생성하고 서버 인증서의 공개 키 또는 서버 키 교환 메시지에 제공된 임시 RSA 키를 사용하여 암호화합니다. 그 결과를 암호화된 프리마스터 비밀 메시지로 보냅니다. 이 구조는 메시지 자체가 아닌 클라이언트 키 교환 메시지의 변형입니다.

```text
   Structure of this message:
       struct {
           ProtocolVersion client_version;
           opaque random[46];
       } PreMasterSecret;

       client_version
           The latest (newest) version supported by the client. This is
           used to detect version roll-back attacks. Upon receiving the
           premaster secret, the server should check that this value
           matches the value transmitted by the client in the client
           hello message.

       random
           46 securely-generated random bytes.

       struct {
           public-key-encrypted PreMasterSecret pre_master_secret;
       } EncryptedPreMasterSecret;
```

참고: Daniel Bleichenbacher \[BLEI\]가 발견한 공격은 PKCS#1로 인코딩된 RSA를 사용하는 TLS 서버를 공격하는 데 사용될 수 있습니다. 이 공격은 다양한 방식으로 실패함으로써 TLS 서버가 특정 메시지가 해독될 때 적절한 PKCS#1 형식인지 여부를 공개하도록 강제될 수 있다는 사실을 이용합니다.

- 이 공격에 대한 취약성을 피하는 가장 좋은 방법은 형식이 잘못된 메시지를 올바른 형식의 RSA 블록과 구별할 수 없는 방식으로 처리하는 것입니다. 따라서 잘못된 형식의 RSA 블록을 수신하면 서버는 임의의 48바이트 값을 생성하고 이를 프리마스터 비밀로 사용하여 진행해야 합니다. 따라서 서버는 수신된 RSA 블록이 올바르게 인코딩되었는지 여부에 관계없이 동일하게 작동합니다.

```text
       pre_master_secret
           This random value is generated by the client and is used to
           generate the master secret, as specified in Section 8.1.
```

---
##### **7.4.7.2. Client Diffie-Hellman public value**

이 메시지의 의미: - 이 구조는 클라이언트의 인증서에 아직 포함되지 않은 경우 클라이언트의 Diffie-Hellman 공개 값\(Yc\)을 전달합니다. Yc에 사용되는 인코딩은 열거된 PublicValueEncoding에 의해 결정됩니다. 이 구조는 메시지 자체가 아닌 클라이언트 키 교환 메시지의 변형입니다.

이 메시지의 구조: - enum { 암시적, 명시적 } PublicValueEncoding;

```text
       implicit
           If the client certificate already contains a suitable
           Diffie-Hellman key, then Yc is implicit and does not need to
           be sent again. In this case, the Client Key Exchange message
           will be sent, but will be empty.

       explicit
           Yc needs to be sent.

       struct {
           select (PublicValueEncoding) {
               case implicit: struct { };
               case explicit: opaque dh_Yc<1..2^16-1>;
           } dh_public;
       } ClientDiffieHellmanPublic;

       dh_Yc
           The client's Diffie-Hellman public value (Yc).
```

---
#### **7.4.8. Certificate verify**

이 메시지가 전송되는 시기: - 이 메시지는 클라이언트 인증서의 명시적인 확인을 제공하는 데 사용됩니다. 이 메시지는 서명 기능이 있는 클라이언트 인증서\(즉, 고정된 Diffie-Hellman 매개변수가 포함된 인증서를 제외한 모든 인증서\) 다음에만 전송됩니다. 전송되면 클라이언트 키 교환 메시지 바로 뒤에 표시됩니다.

```text
   Structure of this message:
       struct {
            Signature signature;
       } CertificateVerify;
```

- Signature 유형은 7.4.3에 정의되어 있다.

```text
       CertificateVerify.signature.md5_hash
           MD5(handshake_messages);

       Certificate.signature.sha_hash
           SHA(handshake_messages);
```

여기서 handshake\_messages는 핸드셰이크 메시지의 유형 및 길이 필드를 포함하여 클라이언트 hello에서 시작하여 이 메시지를 포함하지 않고 전송 또는 수신된 모든 핸드셰이크 메시지를 나타냅니다. 이는 지금까지 교환된 7.4에 정의된 모든 Handshake 구조의 연결입니다.

---
#### **7.4.9. Finished**

이 메시지가 전송되는 시기: - 키 교환 및 인증 프로세스가 성공했는지 확인하기 위해 암호 사양 변경 메시지 직후에 완료 메시지가 항상 전송됩니다. 다른 핸드셰이크 메시지와 완료 메시지 사이에 암호 사양 변경 메시지를 수신하는 것이 중요합니다.

이 메시지의 의미: - 완료된 메시지는 방금 협상된 알고리즘, 키 및 비밀을 사용하여 처음으로 보호됩니다. 완료된 메시지의 수신자는 내용이 올바른지 확인해야 합니다. 한쪽에서 Finished 메시지를 보내고 피어로부터 Finished 메시지를 수신하고 확인한 후에는 연결을 통해 애플리케이션 데이터를 보내고 받기 시작할 수 있습니다.

```text
       struct {
           opaque verify_data[12];
       } Finished;

       verify_data
           PRF(master_secret, finished_label, MD5(handshake_messages) +
           SHA-1(handshake_messages)) [0..11];

       finished_label
           For Finished messages sent by the client, the string "client
           finished". For Finished messages sent by the server, the
           string "server finished".

       handshake_messages
           All of the data from all handshake messages up to but not
           including this message. This is only data visible at the
           handshake layer and does not include record layer headers.

           This is the concatenation of all the Handshake structures as
           defined in 7.4 exchanged thus far.
```

완료된 메시지 앞에 핸드셰이크의 적절한 지점에서 암호 사양 변경 메시지가 나오지 않으면 이는 치명적인 오류입니다.

서버에서 보낸 완료된 메시지에 포함된 해시에는 Sender.server가 포함됩니다. 클라이언트가 보낸 메시지에는 Sender.client가 포함되어 있습니다. handshake\_messages 값에는 클라이언트 hello에서 시작하여 이 완료된 메시지까지의 모든 핸드셰이크 메시지가 포함됩니다. 이는 인증서 확인 메시지\(전송된 경우\)를 포함하므로 섹션 7.4.8의 handshake\_messages와 다를 수 있습니다. 또한 클라이언트가 보낸 완료된 메시지의 handshake\_messages는 두 번째로 보낸 메시지에 이전 메시지가 포함되므로 서버가 보낸 완료된 메시지의 handshake\_messages와 다릅니다.

참고: 암호 사양 변경 메시지, 경고 및 기타 레코드 유형은 핸드셰이크 메시지가 아니며 해시 계산에 포함되지 않습니다. 또한 Hello 요청 메시지는 핸드셰이크 해시에서 생략됩니다.

---
## **8. Cryptographic computations**

연결 보호를 시작하려면 TLS 레코드 프로토콜에는 일련의 알고리즘, 마스터 비밀, 클라이언트 및 서버 임의 값의 사양이 필요합니다. 인증, 암호화 및 MAC 알고리즘은 서버가 선택한 cipher\_suite에 의해 결정되며 서버 Hello 메시지에 표시됩니다. 압축 알고리즘은 hello 메시지에서 협상되며, hello 메시지에서는 임의의 값이 교환됩니다. 이제 남은 것은 마스터 시크릿을 계산하는 것뿐입니다.

---
### **8.1. Computing the master secret**

모든 키 교환 방법에 대해 동일한 알고리즘을 사용하여 pre\_master\_secret을 master\_secret으로 변환합니다. pre\_master\_secret은 master\_secret이 계산된 후에 메모리에서 삭제되어야 합니다.

```text
       master_secret = PRF(pre_master_secret, "master secret",
                           ClientHello.random + ServerHello.random)
       [0..47];
```

마스터 시크릿의 길이는 항상 정확히 48바이트입니다. 프리마스터 비밀의 길이는 키 교환 방법에 따라 달라집니다.

---
#### **8.1.1. RSA**

RSA가 서버 인증 및 키 교환에 사용되면 클라이언트에서 48바이트 pre\_master\_secret이 생성되고 서버의 공개 키로 암호화되어 서버로 전송됩니다. 서버는 개인 키를 사용하여 pre\_master\_secret을 해독합니다. 그런 다음 양 당사자는 위에 지정된 대로 pre\_master\_secret을 master\_secret으로 변환합니다.

RSA 디지털 서명은 PKCS #1 \[PKCS1\] 블록 유형 1을 사용하여 수행됩니다. RSA 공개 키 암호화는 PKCS #1 블록 유형 2를 사용하여 수행됩니다.

---
#### **8.1.2. Diffie-Hellman**

일반적인 Diffie-Hellman 계산이 수행됩니다. 협상된 키\(Z\)는 pre\_master\_secret으로 사용되며 위에 지정된 대로 master\_secret으로 변환됩니다.

참고: Diffie-Hellman 매개변수는 서버에 의해 지정되며 일시적이거나 서버 인증서 내에 포함될 수 있습니다.

---
## **9. Mandatory Cipher Suites**

달리 지정하는 애플리케이션 프로필 표준이 없는 경우 TLS 호환 애플리케이션은 암호화 제품군 TLS\_DHE\_DSS\_WITH\_3DES\_EDE\_CBC\_SHA를 구현해야 합니다.

---
## **10. Application data protocol**

애플리케이션 데이터 메시지는 레코드 레이어에 의해 전달되며 현재 연결 상태에 따라 조각화, 압축 및 암호화됩니다. 메시지는 레코드 레이어에 투명한 데이터로 처리됩니다.

---
## **A. Protocol constant values**

이 섹션에서는 프로토콜 유형과 상수에 대해 설명합니다.

---
### **A.1. Record layer**

```text
    struct {
        uint8 major, minor;
    } ProtocolVersion;

    ProtocolVersion version = { 3, 1 };     /* TLS v1.0 */

    enum {
        change_cipher_spec(20), alert(21), handshake(22),
        application_data(23), (255)
    } ContentType;

    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        opaque fragment[TLSPlaintext.length];
    } TLSPlaintext;

    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        opaque fragment[TLSCompressed.length];
    } TLSCompressed;

    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        select (CipherSpec.cipher_type) {
            case stream: GenericStreamCipher;
            case block:  GenericBlockCipher;
        } fragment;
    } TLSCiphertext;

    stream-ciphered struct {
        opaque content[TLSCompressed.length];
        opaque MAC[CipherSpec.hash_size];
    } GenericStreamCipher;

    block-ciphered struct {
        opaque content[TLSCompressed.length];

        opaque MAC[CipherSpec.hash_size];
        uint8 padding[GenericBlockCipher.padding_length];
        uint8 padding_length;
    } GenericBlockCipher;
```

---
### **A.2. Change cipher specs message**

```text
    struct {
        enum { change_cipher_spec(1), (255) } type;
    } ChangeCipherSpec;
```

---
### **A.3. Alert messages**

```text
    enum { warning(1), fatal(2), (255) } AlertLevel;

        enum {
            close_notify(0),
            unexpected_message(10),
            bad_record_mac(20),
            decryption_failed(21),
            record_overflow(22),
            decompression_failure(30),
            handshake_failure(40),
            bad_certificate(42),
            unsupported_certificate(43),
            certificate_revoked(44),
            certificate_expired(45),
            certificate_unknown(46),
            illegal_parameter(47),
            unknown_ca(48),
            access_denied(49),
            decode_error(50),
            decrypt_error(51),
            export_restriction(60),
            protocol_version(70),
            insufficient_security(71),
            internal_error(80),
            user_canceled(90),
            no_renegotiation(100),
            (255)
        } AlertDescription;

    struct {
        AlertLevel level;
        AlertDescription description;
    } Alert;
```

---
### **A.4. Handshake protocol**

```text
    enum {
        hello_request(0), client_hello(1), server_hello(2),
        certificate(11), server_key_exchange (12),
        certificate_request(13), server_hello_done(14),
        certificate_verify(15), client_key_exchange(16),
        finished(20), (255)
    } HandshakeType;

    struct {
        HandshakeType msg_type;
        uint24 length;
        select (HandshakeType) {
            case hello_request:       HelloRequest;
            case client_hello:        ClientHello;
            case server_hello:        ServerHello;
            case certificate:         Certificate;
            case server_key_exchange: ServerKeyExchange;
            case certificate_request: CertificateRequest;
            case server_hello_done:   ServerHelloDone;
            case certificate_verify:  CertificateVerify;
            case client_key_exchange: ClientKeyExchange;
            case finished:            Finished;
        } body;
    } Handshake;
```

---
#### **A.4.1. Hello messages**

```text
    struct { } HelloRequest;

    struct {
        uint32 gmt_unix_time;
        opaque random_bytes[28];
    } Random;

    opaque SessionID<0..32>;

    uint8 CipherSuite[2];

    enum { null(0), (255) } CompressionMethod;

    struct {
        ProtocolVersion client_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suites<2..2^16-1>;
        CompressionMethod compression_methods<1..2^8-1>;

    } ClientHello;

    struct {
        ProtocolVersion server_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suite;
        CompressionMethod compression_method;
    } ServerHello;
```

---
#### **A.4.2. Server authentication and key exchange messages**

```text
    opaque ASN.1Cert<2^24-1>;

    struct {
        ASN.1Cert certificate_list<1..2^24-1>;
    } Certificate;

    enum { rsa, diffie_hellman } KeyExchangeAlgorithm;

    struct {
        opaque RSA_modulus<1..2^16-1>;
        opaque RSA_exponent<1..2^16-1>;
    } ServerRSAParams;

    struct {
        opaque DH_p<1..2^16-1>;
        opaque DH_g<1..2^16-1>;
        opaque DH_Ys<1..2^16-1>;
    } ServerDHParams;

    struct {
        select (KeyExchangeAlgorithm) {
            case diffie_hellman:
                ServerDHParams params;
                Signature signed_params;
            case rsa:
                ServerRSAParams params;
                Signature signed_params;
        };
    } ServerKeyExchange;

    enum { anonymous, rsa, dsa } SignatureAlgorithm;

    select (SignatureAlgorithm)
    {   case anonymous: struct { };
        case rsa:
            digitally-signed struct {

                opaque md5_hash[16];
                opaque sha_hash[20];
            };
        case dsa:
            digitally-signed struct {
                opaque sha_hash[20];
            };
    } Signature;

    enum {
        rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
        (255)
    } ClientCertificateType;

    opaque DistinguishedName<1..2^16-1>;

    struct {
        ClientCertificateType certificate_types<1..2^8-1>;
        DistinguishedName certificate_authorities<3..2^16-1>;
    } CertificateRequest;

    struct { } ServerHelloDone;
```

---
#### **A.4.3. Client authentication and key exchange messages**

```text
    struct {
        select (KeyExchangeAlgorithm) {
            case rsa: EncryptedPreMasterSecret;
            case diffie_hellman: DiffieHellmanClientPublicValue;
        } exchange_keys;
    } ClientKeyExchange;

    struct {
        ProtocolVersion client_version;
        opaque random[46];

    } PreMasterSecret;

    struct {
        public-key-encrypted PreMasterSecret pre_master_secret;
    } EncryptedPreMasterSecret;

    enum { implicit, explicit } PublicValueEncoding;

    struct {
        select (PublicValueEncoding) {
            case implicit: struct {};
            case explicit: opaque DH_Yc<1..2^16-1>;

        } dh_public;
    } ClientDiffieHellmanPublic;

    struct {
        Signature signature;
    } CertificateVerify;
```

---
#### **A.4.4. Handshake finalization message**

```text
    struct {
        opaque verify_data[12];
    } Finished;
```

---
### **A.5. The CipherSuite**

다음 값은 클라이언트 hello 및 서버 hello 메시지에 사용되는 CipherSuite 코드를 정의합니다.

CipherSuite는 TLS 버전 1.0에서 지원되는 암호화 사양을 정의합니다.

TLS\_NULL\_WITH\_NULL\_NULL이 지정되고 해당 채널의 첫 번째 핸드셰이크 중 TLS 연결의 초기 상태이지만 보안되지 않은 연결보다 더 많은 보호를 제공하지 않으므로 협상해서는 안 됩니다.

```text
    CipherSuite TLS_NULL_WITH_NULL_NULL                = { 0x00,0x00 };
```

다음 CipherSuite 정의에서는 서버가 키 교환에 사용할 수 있는 RSA 인증서를 제공해야 합니다. 서버는 인증서 요청 메시지에서 RSA 또는 DSS 서명 가능 인증서를 요청할 수 있습니다.

```text
    CipherSuite TLS_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };
    CipherSuite TLS_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };
    CipherSuite TLS_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };
    CipherSuite TLS_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };
    CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };
    CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };
    CipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };
    CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };
```

다음 CipherSuite 정의는 서버 인증\(및 선택적으로 클라이언트 인증\) Diffie-Hellman에 사용됩니다. DH는 서버 인증서에 인증 기관에서 서명한 Diffie-Hellman 매개변수가 포함된 암호화 제품군을 나타냅니다.

\(캘리포니아\). DHE는 임시 Diffie-Hellman을 나타냅니다. 여기서 Diffie-Hellman 매개변수는 CA에서 서명한 DSS 또는 RSA 인증서로 서명됩니다. 사용되는 서명 알고리즘은 DH 또는 DHE 매개변수 뒤에 지정됩니다. 서버는 클라이언트 인증을 위해 클라이언트로부터 RSA 또는 DSS 서명 가능 인증서를 요청하거나 Diffie-Hellman 인증서를 요청할 수 있습니다. 클라이언트가 제공하는 모든 Diffie-Hellman 인증서는 서버에서 설명하는 매개변수\(그룹 및 생성기\)를 사용해야 합니다.

```text
    CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };
    CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };
    CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };
    CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };
    CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };
    CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };
    CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };
    CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };
    CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };
    CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };
    CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };
    CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };
```

다음 암호 제품군은 어느 쪽도 인증되지 않은 완전한 익명의 Diffie-Hellman 통신에 사용됩니다. 이 모드는 중간자 공격에 취약하므로 더 이상 사용되지 않습니다.

```text
    CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };
    CipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };
    CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };
    CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };
    CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };
```

참고: 첫 번째 바이트가 0xFF인 모든 암호 제품군은 비공개로 간주되며 로컬/실험적 알고리즘을 정의하는 데 사용할 수 있습니다. 이러한 유형의 상호 운용성은 지역적인 문제입니다.

참고: 메시지 인코딩, 프리마스터 비밀 파생, 대칭 암호화 및 MAC 계산, 관련 알고리즘에 대한 적절한 참조 정보 등 필요한 TLS 프로토콜 정보를 포함하여 암호 그룹을 지정하는 RFC를 게시하여 추가 암호 그룹을 등록할 수 있습니다. RFC 편집실은 사양이 기술적 관심이 있고 완전히 지정되었다고 판단하는 경우 재량에 따라 완전히 설명되지 않은 암호 제품군\(예: 분류된 알고리즘\)에 대한 사양을 게시하도록 선택할 수 있습니다.

참고: 암호화 제품군 값 { 0x00, 0x1C } 및 { 0x00, 0x1D }는 SSL 3의 Fortezza 기반 암호화 제품군과의 충돌을 방지하기 위해 예약되어 있습니다.

---
### **A.6. The Security Parameters**

이러한 보안 매개변수는 TLS 핸드셰이크 프로토콜에 의해 결정되며 연결 상태를 초기화하기 위해 TLS 레코드 레이어에 매개변수로 제공됩니다. SecurityParameters에는 다음이 포함됩니다.

```text
       enum { null(0), (255) } CompressionMethod;

       enum { server, client } ConnectionEnd;

       enum { null, rc4, rc2, des, 3des, des40, idea }
       BulkCipherAlgorithm;

       enum { stream, block } CipherType;

       enum { true, false } IsExportable;

       enum { null, md5, sha } MACAlgorithm;

   /* The algorithms specified in CompressionMethod,
   BulkCipherAlgorithm, and MACAlgorithm may be added to. */

       struct {
           ConnectionEnd entity;
           BulkCipherAlgorithm bulk_cipher_algorithm;
           CipherType cipher_type;
           uint8 key_size;
           uint8 key_material_length;
           IsExportable is_exportable;
           MACAlgorithm mac_algorithm;
           uint8 hash_size;
           CompressionMethod compression_algorithm;
           opaque master_secret[48];
           opaque client_random[32];
           opaque server_random[32];
       } SecurityParameters;
```

---
## **B. Glossary**

애플리케이션 프로토콜 - 애플리케이션 프로토콜은 일반적으로 전송 계층\(예: TCP/IP\) 바로 위에 계층을 이루는 프로토콜입니다. 예로는 HTTP, TELNET, FTP 및 SMTP가 있습니다.

```text
   asymmetric cipher
       See public key cryptography.
```

인증 - 인증은 한 엔터티가 다른 엔터티의 신원을 확인하는 기능입니다.

블록 암호 - 블록 암호는 블록이라고 하는 비트 그룹의 일반 텍스트에서 작동하는 알고리즘입니다. 64비트가 일반적인 블록 크기입니다.

대량 암호 - 대량의 데이터를 암호화하는 데 사용되는 대칭 암호화 알고리즘입니다.

CBC\(암호 블록 체인\) - CBC는 블록 암호로 암호화된 모든 일반 텍스트 블록이 먼저 이전 암호 텍스트 블록\(또는 첫 번째 블록의 경우 초기화 벡터\)과 배타적 OR로 연결되는 모드입니다. 해독을 위해 모든 블록은 먼저 해독된 다음 이전 암호문 블록\(또는 IV\)과 배타적 OR로 연결됩니다.

인증서 - X.509 프로토콜\(ISO 인증 프레임워크라고도 함\)의 일부로 인증서는 신뢰할 수 있는 인증 기관에 의해 할당되며 당사자의 ID 또는 기타 속성과 공개 키 간의 강력한 바인딩을 제공합니다.

클라이언트 - 서버에 대한 TLS 연결을 시작하는 애플리케이션 엔터티입니다. 이는 클라이언트가 기본 전송 연결을 시작했음을 의미할 수도 있고 의미하지 않을 수도 있습니다. 서버와 클라이언트의 주요 작동 차이점은 서버는 일반적으로 인증되는 반면 클라이언트는 선택적으로만 인증된다는 것입니다.

클라이언트 쓰기 키 - 클라이언트가 쓴 데이터를 암호화하는 데 사용되는 키입니다.

클라이언트 쓰기 MAC 비밀 - 클라이언트가 작성한 데이터를 인증하는 데 사용되는 비밀 데이터입니다.

연결 - 연결은 적절한 유형의 서비스를 제공하는 전송\(OSI 계층화 모델 정의에서\)입니다. TLS의 경우 이러한 연결은 피어 투 피어 관계입니다. 연결은 일시적입니다. 모든 연결은 하나의 세션과 연결됩니다.

데이터 암호화 표준 - DES는 매우 널리 사용되는 대칭 암호화 알고리즘입니다. DES는 56비트 키와 8바이트 블록 크기를 갖는 블록 암호입니다. TLS에서 키 생성 목적으로 DES는 8바이트 키 길이\(64비트\)를 갖는 것으로 처리되지만 여전히 56비트 보호만 제공합니다. \(각 키 바이트의 낮은 비트는 해당 키 바이트에서 홀수 패리티를 생성하도록 설정되는 것으로 추정됩니다.\) DES는 각 데이터 블록에 대해 3개의 독립 키와 3개의 암호화가 사용되는 모드에서도 작동할 수 있습니다. 이는 168비트 키\(TLS 키 생성 방법에서는 24바이트\)를 사용하며 112비트 보안에 해당합니다. \[DES\], \[3DES\]

디지털 서명 표준\(DSS\) - 미국 국무부에서 1994년 5월 발행한 NIST FIPS PUB 186, "디지털 서명 표준"에 정의된 미국 국립 표준 기술 연구소\(National Institute of Standards and Technology\)에서 승인한 디지털 서명 알고리즘을 포함한 디지털 서명에 대한 표준입니다. .상업. \[DSS\]

디지털 서명 - 디지털 서명은 공개 키 암호화와 단방향 해시 기능을 활용하여 인증할 수 있고 위조하거나 부인하기 어려운 데이터 서명을 생성합니다.

핸드셰이크 - 트랜잭션 매개변수를 설정하는 클라이언트와 서버 간의 초기 협상입니다.

초기화 벡터\(IV\) - 블록 암호가 CBC 모드에서 사용되는 경우 초기화 벡터는 암호화 전에 첫 번째 일반 텍스트 블록과 배타적 OR로 연결됩니다.

IDEA - Xuejia Lai와 James Massey가 설계한 64비트 블록 암호입니다. \[아이디어\]

메시지 인증 코드\(MAC\) - 메시지 인증 코드는 메시지와 일부 비밀 데이터에서 계산된 단방향 해시입니다. 비밀 데이터를 알지 못하면 위조하기가 어렵습니다. 그 목적은 메시지가 변경되었는지 감지하는 것입니다.

마스터 비밀 - 암호화 키, MAC 비밀 및 IV를 생성하는 데 사용되는 보안 비밀 데이터입니다.

MD5 - MD5는 임의로 긴 데이터 스트림을 고정된 크기\(16바이트\)의 다이제스트로 변환하는 보안 해싱 함수입니다. \[MD5\]

공개 키 암호화 - 두 개의 키 암호를 사용하는 암호화 기술의 한 종류입니다. 공개 키로 암호화된 메시지는 연결된 개인 키로만 해독할 수 있습니다. 반대로, 개인 키로 서명된 메시지는 공개 키로 확인할 수 있습니다.

단방향 해시 함수 - 임의의 양의 데이터를 고정 길이 해시로 변환하는 단방향 변환입니다. 변환을 되돌리거나 충돌을 찾는 것은 계산상 어렵습니다. MD5 및 SHA는 단방향 해시 함수의 예입니다.

RC2 - RSA Data Security, Inc.의 Ron Rivest가 개발한 블록 암호입니다. \[RSADSI\]는 \[RC2\]에 설명되어 있습니다.

RC4 - RSA Data Security \[RSADSI\]에 의해 라이센스가 부여된 스트림 암호입니다. 호환되는 암호는 \[RC4\]에 설명되어 있습니다.

RSA - 암호화 또는 디지털 서명에 사용할 수 있는 매우 널리 사용되는 공개 키 알고리즘입니다. \[RSA\]

salt - 내보내기 암호화 키가 사전 계산 공격에 저항하도록 만드는 데 사용되는 비밀이 아닌 무작위 데이터입니다.

서버 - 서버는 클라이언트의 연결 요청에 응답하는 애플리케이션 엔터티입니다. 클라이언트 아래도 참조하세요.

세션 - TLS 세션은 클라이언트와 서버 간의 연결입니다. 세션은 핸드셰이크 프로토콜에 의해 생성됩니다. 세션은 여러 연결에서 공유할 수 있는 암호화 보안 매개변수 세트를 정의합니다. 세션은 각 연결에 대한 새로운 보안 매개변수의 값비싼 협상을 피하기 위해 사용됩니다.

세션 식별자 - 세션 식별자는 특정 세션을 식별하는 서버에서 생성된 값입니다.

서버 쓰기 키 - 서버에서 쓴 데이터를 암호화하는 데 사용되는 키입니다.

서버 쓰기 MAC 비밀 - 서버에서 쓴 데이터를 인증하는 데 사용되는 비밀 데이터입니다.

SHA - 보안 해시 알고리즘은 FIPS PUB 180-1에 정의되어 있습니다. 20바이트 출력을 생성합니다. SHA에 대한 모든 참조는 실제로 수정된 SHA-1 알고리즘을 사용합니다. \[샤\]

SSL - Netscape의 보안 소켓 계층 프로토콜 \[SSL3\]. TLS는 SSL 버전 3.0을 기반으로 합니다.

스트림 암호\(stream cipher\) - 키를 암호화가 강력한 키스트림으로 변환한 다음 일반 텍스트와 배타적 OR로 연결하는 암호화 알고리즘입니다.

```text
   symmetric cipher
       See bulk cipher.
```

TLS\(전송 계층 보안\) - 이 프로토콜은 다음과 같습니다. 또한 IETF\(Internet Engineering Task Force\)의 전송 계층 보안 작업 그룹도 있습니다. 이 문서 끝에 있는 "의견"을 참조하세요.

---
## **C. CipherSuite definitions**

```text
CipherSuite                      Is       Key          Cipher      Hash
                             Exportable Exchange

TLS_NULL_WITH_NULL_NULL               * NULL           NULL        NULL
TLS_RSA_WITH_NULL_MD5                 * RSA            NULL         MD5
TLS_RSA_WITH_NULL_SHA                 * RSA            NULL         SHA
TLS_RSA_EXPORT_WITH_RC4_40_MD5        * RSA_EXPORT     RC4_40       MD5
TLS_RSA_WITH_RC4_128_MD5                RSA            RC4_128      MD5
TLS_RSA_WITH_RC4_128_SHA                RSA            RC4_128      SHA
TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5    * RSA_EXPORT     RC2_CBC_40   MD5
TLS_RSA_WITH_IDEA_CBC_SHA               RSA            IDEA_CBC     SHA
TLS_RSA_EXPORT_WITH_DES40_CBC_SHA     * RSA_EXPORT     DES40_CBC    SHA
TLS_RSA_WITH_DES_CBC_SHA                RSA            DES_CBC      SHA
TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA            3DES_EDE_CBC SHA
TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  * DH_DSS_EXPORT  DES40_CBC    SHA
TLS_DH_DSS_WITH_DES_CBC_SHA             DH_DSS         DES_CBC      SHA
TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS         3DES_EDE_CBC SHA
TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  * DH_RSA_EXPORT  DES40_CBC    SHA
TLS_DH_RSA_WITH_DES_CBC_SHA             DH_RSA         DES_CBC      SHA
TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA         3DES_EDE_CBC SHA
TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC    SHA
TLS_DHE_DSS_WITH_DES_CBC_SHA            DHE_DSS        DES_CBC      SHA
TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS        3DES_EDE_CBC SHA
TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC    SHA
TLS_DHE_RSA_WITH_DES_CBC_SHA            DHE_RSA        DES_CBC      SHA
TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA        3DES_EDE_CBC SHA
TLS_DH_anon_EXPORT_WITH_RC4_40_MD5    * DH_anon_EXPORT RC4_40       MD5
TLS_DH_anon_WITH_RC4_128_MD5            DH_anon        RC4_128      MD5
TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA   DH_anon        DES40_CBC    SHA
TLS_DH_anon_WITH_DES_CBC_SHA            DH_anon        DES_CBC      SHA
TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon        3DES_EDE_CBC SHA
```

\* IsExportable이 True임을 나타냅니다.

```text
      Key
      Exchange
      Algorithm       Description                        Key size limit

      DHE_DSS         Ephemeral DH with DSS signatures   None
      DHE_DSS_EXPORT  Ephemeral DH with DSS signatures   DH = 512 bits
      DHE_RSA         Ephemeral DH with RSA signatures   None
      DHE_RSA_EXPORT  Ephemeral DH with RSA signatures   DH = 512 bits,
                                                         RSA = none
      DH_anon         Anonymous DH, no signatures        None
      DH_anon_EXPORT  Anonymous DH, no signatures        DH = 512 bits

      DH_DSS          DH with DSS-based certificates     None
      DH_DSS_EXPORT   DH with DSS-based certificates     DH = 512 bits
      DH_RSA          DH with RSA-based certificates     None
      DH_RSA_EXPORT   DH with RSA-based certificates     DH = 512 bits,
                                                         RSA = none
      NULL            No key exchange                    N/A
      RSA             RSA key exchange                   None
      RSA_EXPORT      RSA key exchange                   RSA = 512 bits
```

키 크기 제한 - 키 크기 제한은 내보낼 수 있는 암호화 제품군의 암호화에 합법적으로 사용할 수 있는 가장 큰 공개 키의 크기를 제공합니다.

```text
                         Key      Expanded   Effective   IV    Block
    Cipher       Type  Material Key Material  Key Bits  Size   Size

    NULL       * Stream   0          0           0        0     N/A
    IDEA_CBC     Block   16         16         128        8      8
    RC2_CBC_40 * Block    5         16          40        8      8
    RC4_40     * Stream   5         16          40        0     N/A
    RC4_128      Stream  16         16         128        0     N/A
    DES40_CBC  * Block    5          8          40        8      8
    DES_CBC      Block    8          8          56        8      8
    3DES_EDE_CBC Block   24         24         168        8      8
```

\* IsExportable이 true임을 나타냅니다.

유형 - 스트림 암호인지 CBC 모드에서 실행되는 블록 암호인지를 나타냅니다.

키 자료 - 쓰기 키를 생성하는 데 사용되는 key\_block의 바이트 수입니다.

확장된 키 자료 - 암호화 알고리즘에 실제로 입력된 바이트 수

유효 키 비트 - 암호화 루틴에 공급되는 키 자료에 얼마나 많은 엔트로피 자료가 있는지입니다.

IV 크기 - 초기화 벡터에 대해 생성해야 하는 데이터의 양입니다. 스트림 암호의 경우 0입니다. 블록 암호의 블록 크기와 같습니다.

블록 크기 - 블록 암호가 하나의 청크에서 암호화하는 데이터의 양입니다. CBC 모드에서 실행되는 블록 암호는 블록 크기의 짝수배만 암호화할 수 있습니다.

```text
      Hash      Hash      Padding
    function    Size       Size
      NULL       0          0
      MD5        16         48
      SHA        20         40
```

---
## **D. Implementation Notes**

TLS 프로토콜은 흔히 발생하는 많은 보안 실수를 방지할 수 없습니다. 이 섹션에서는 구현자를 지원하기 위한 몇 가지 권장 사항을 제공합니다.

---
### **D.1. Temporary RSA keys**

미국 수출 제한은 암호화에 사용되는 RSA 키를 512비트로 제한하지만 서명 작업에 사용되는 RSA 키의 길이에는 제한을 두지 않습니다. 512비트 RSA 키는 고가치 트랜잭션이나 장기 보안이 필요한 애플리케이션에는 충분히 안전하지 않기 때문에 인증서는 512비트보다 커야 하는 경우가 많습니다. 일부 인증서는 서명 전용으로 지정되어 있으며, 이 경우 키 교환에 사용할 수 없습니다.

인증서의 공개 키를 암호화에 사용할 수 없는 경우 서버는 임시 RSA 키에 서명한 후 교환합니다. 내보낼 수 있는 애플리케이션에서 임시 RSA 키는 허용되는 최대 길이\(예: 512비트\)여야 합니다. 512비트 RSA 키는 상대적으로 안전하지 않으므로 자주 변경해야 합니다. 일반적인 전자 상거래 애플리케이션의 경우 매일 또는 500건의 거래마다 키를 변경하는 것이 좋으며 가능하면 더 자주 변경하는 것이 좋습니다. 여러 트랜잭션에 동일한 임시 키를 사용하는 것이 허용되지만 사용할 때마다 서명해야 합니다.

RSA 키 생성은 시간이 많이 걸리는 프로세스입니다. 많은 경우 우선순위가 낮은 프로세스에 키 생성 작업을 할당할 수 있습니다.

새 키가 완성될 때마다 기존 임시 키를 새 키로 교체할 수 있습니다.

---
### **D.2. Random Number Generation and Seeding**

TLS에는 암호화된 보안 의사 난수 생성기\(PRNG\)가 필요합니다. PRNG를 설계하고 시드할 때는 주의를 기울여야 합니다. MD5 및/또는 SHA와 같은 보안 해시 작업을 기반으로 하는 PRNG는 허용되지만 난수 생성기 상태의 크기보다 더 많은 보안을 제공할 수는 없습니다. \(예를 들어 MD5 기반 PRNG는 일반적으로 128비트 상태를 제공합니다.\)

생산되는 시드 물질의 양을 추정하려면 각 시드 바이트에 예측할 수 없는 정보의 비트 수를 추가하십시오. 예를 들어, PC 호환 18.2Hz 타이머에서 가져온 키스트로크 타이밍 값은 카운터 값의 전체 크기가 16비트 이상이라도 각각 1 또는 2개의 보안 비트를 제공합니다. 128비트 PRNG를 시드하려면 대략 100개의 타이머 값이 필요합니다.

```text
 Warning: The seeding functions in RSAREF and versions of BSAFE prior to
          3.0 are order-independent. For example, if 1000 seed bits are
          supplied, one at a time, in 1000 separate calls to the seed
          function, the PRNG will end up in a state which depends only
          on the number of 0 or 1 seed bits in the seed data (i.e.,
          there are 1001 possible final states). Applications using
          BSAFE or RSAREF must take extra care to ensure proper seeding.
          This may be accomplished by accumulating seed bits into a
          buffer and processing them all at once or by processing an
          incrementing counter with every seed bit; either method will
          reintroduce order dependence into the seeding process.
```

---
### **D.3. Certificates and authentication**

구현에서는 인증서의 무결성을 확인할 책임이 있으며 일반적으로 인증서 해지 메시지를 지원해야 합니다. 인증서는 항상 신뢰할 수 있는 인증 기관\(CA\)의 적절한 서명을 확인해야 합니다. 신뢰할 수 있는 CA를 선택하고 추가하는 작업은 매우 신중하게 수행되어야 합니다. 사용자는 인증서 및 루트 CA에 대한 정보를 볼 수 있어야 합니다.

---
### **D.4. CipherSuites**

TLS는 보안을 제공하지 않거나 최소한의 보안을 제공하는 것을 포함하여 다양한 키 크기와 보안 수준을 지원합니다. 적절한 구현은 아마도 많은 암호화 제품군을 지원하지 않을 것입니다. 예를 들어, 40비트 암호화는 쉽게 깨질 수 있으므로 강력한 보안이 필요한 구현에서는 40비트 키를 허용해서는 안 됩니다. 마찬가지로 익명의 Diffie-Hellman은 중간자 공격을 방지할 수 없으므로 사용하지 않는 것이 좋습니다. 또한 애플리케이션은 최소 및 최대 키 크기를 적용해야 합니다. 예를 들어, 512비트 RSA 키 또는 서명이 포함된 인증서 체인은 보안 수준이 높은 애플리케이션에 적합하지 않습니다.

---
## **E. Backward Compatibility With SSL**

역사적 이유와 예약된 포트 번호의 과도한 사용을 피하기 위해 TLS 1.0, SSL 3.0 및 SSL 2.0으로 보호되는 애플리케이션 프로토콜은 모두 동일한 연결 포트를 공유하는 경우가 많습니다. 예를 들어 https 프로토콜\(SSL로 보호되는 HTTP\) 또는 TLS\)는 사용 중인 보안 프로토콜에 관계없이 포트 443을 사용합니다. 따라서 다양한 프로토콜을 구별하고 협상하려면 일부 메커니즘을 결정해야 합니다.

TLS 버전 1.0과 SSL 3.0은 매우 유사합니다. 따라서 둘 다 지원하는 것은 쉽습니다. SSL 3.0 서버와 협상하려는 TLS 클라이언트는 SSL 3.0 레코드 형식과 클라이언트 Hello 구조를 사용하여 클라이언트 Hello 메시지를 보내야 하며, TLS 1.0을 지원한다는 점을 알리기 위해 버전 필드에 대해 {3, 1}을 보내야 합니다. 서버가 SSL 3.0만 지원하는 경우 SSL 3.0 server hello로 응답합니다. TLS를 지원하는 경우 TLS 서버 안녕하세요. 그런 다음 협상은 협상된 프로토콜에 따라 적절하게 진행됩니다.

마찬가지로 SSL 3.0 클라이언트와 상호 운용하려는 TLS 서버는 SSL 3.0 클라이언트 hello 메시지를 수락하고 버전 필드가 {3, 0}인 SSL 3.0 클라이언트 hello가 수신되면 SSL 3.0 서버 hello로 응답해야 합니다. 이 클라이언트는 TLS를 지원하지 않습니다.

클라이언트가 서버에 알려진 가장 높은 프로토콜을 이미 알고 있을 때마다\(예: 세션을 재개할 때\) 해당 기본 프로토콜에서 연결을 시작해야 합니다.

SSL 버전 2.0 서버를 지원하는 TLS 1.0 클라이언트는 SSL 버전 2.0 클라이언트 안녕하세요 메시지\[SSL2\]를 보내야 합니다. TLS 서버가 동일한 연결 포트에서 SSL 2.0 클라이언트를 지원하려면 클라이언트 hello 형식을 허용해야 합니다. 버전 2.0 사양과의 유일한 차이점은 값이 3인 버전을 지정하는 기능과 CipherSpec에서 더 많은 암호화 유형을 지원한다는 것입니다.

```text
 Warning: The ability to send Version 2.0 client hello messages will be
          phased out with all due haste. Implementors should make every
          effort to move forward as quickly as possible. Version 3.0
          provides better mechanisms for moving to newer versions.
```

다음 암호 사양은 SSL 버전 2.0에서 가져온 것입니다. 이는 키 교환 및 인증에 RSA를 사용하는 것으로 가정됩니다.

```text
       V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };
       V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };
       V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };

       V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5
                                                  = { 0x04,0x00,0x80 };
       V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };
       V2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };
       V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };
```

TLS 고유의 암호화 사양은 아래 구문을 사용하여 버전 2.0 클라이언트 안녕하세요 메시지에 포함될 수 있습니다. 첫 번째 바이트가 0인 모든 V2CipherSpec 요소는 버전 2.0 서버에서 무시됩니다. 위의 V2CipherSpecs 중 하나를 전송하는 클라이언트에는 이에 상응하는 TLS도 포함되어야 합니다\(부록 A.5 참조\).

```text
       V2CipherSpec (see TLS name) = { 0x00, CipherSuite };
```

---
### **E.1. Version 2 client hello**

버전 2.0 클라이언트 안녕하세요 메시지는 이 문서의 표현 모델을 사용하여 아래에 표시됩니다. 실제 정의는 여전히 SSL 버전 2.0 사양으로 간주됩니다.

```text
       uint8 V2CipherSpec[3];

       struct {
           uint8 msg_type;
           Version version;
           uint16 cipher_spec_length;
           uint16 session_id_length;
           uint16 challenge_length;
           V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
           opaque session_id[V2ClientHello.session_id_length];
           Random challenge;
       } V2ClientHello;
```

msg\_type - 이 필드는 버전 필드와 함께 버전 2 클라이언트 안녕하세요 메시지를 식별합니다. 값은 일\(1\)이어야 합니다.

버전 - 클라이언트가 지원하는 프로토콜의 가장 높은 버전입니다\(ProtocolVersion.version과 동일, 부록 A.1 참조\).

cipher\_spec\_length - 이 필드는 cipher\_specs 필드의 전체 길이입니다. 0일 수 없으며 V2CipherSpec 길이\(3\)의 배수여야 합니다.

session\_id\_length - 이 필드의 값은 0 또는 16이어야 합니다. 0이면 클라이언트가 새 세션을 생성하는 것입니다. 16인 경우 session\_id 필드에는 16바이트의 세션 식별이 포함됩니다.

Challenge\_length - 클라이언트가 자신을 인증하기 위해 서버에 요청하는 길이\(바이트\)입니다. 이 값은 32여야 합니다.

cipher\_specs - 클라이언트가 사용할 의향이 있고 사용할 수 있는 모든 CipherSpec의 목록입니다. 서버에 허용되는 CipherSpec이 하나 이상 있어야 합니다.

session\_id - 이 필드의 길이가 0이 아닌 경우 클라이언트가 재개하려는 세션에 대한 ID가 포함됩니다.

챌린지 - 서버가 자신을 식별하기 위한 서버에 대한 클라이언트 챌린지는 \(거의\) 임의 길이의 무작위입니다. TLS 서버는 이 프로토콜 사양에 지정된 대로 챌린지 데이터를 ClientHello.random 데이터\(필요한 경우 앞에 0으로 채워짐\)가 되도록 올바르게 정당화합니다. 챌린지 길이가 32바이트보다 길면 마지막 32바이트만 사용됩니다. V3 서버가 챌린지 데이터가 16바이트 미만인 V2 ClientHello를 거부하는 것은 합법적이지만 필수는 아닙니다.

참고: TLS 세션 재개 요청은 TLS 클라이언트 hello를 사용해야 합니다.

---
### **E.2. Avoiding man-in-the-middle version rollback**

TLS 클라이언트가 버전 2.0 호환 모드로 대체되면 특별한 PKCS #1 블록 형식을 사용해야 합니다. 이는 TLS 서버가 TLS 가능 클라이언트와의 버전 2.0 세션을 거부하도록 하기 위한 것입니다.

TLS 클라이언트가 버전 2.0 호환 모드에 있는 경우 ENCRYPTED-KEY-DATA 필드의 RSA 암호화를 위해 PKCS 패딩의 오른쪽\(최하위\) 8개의 임의 바이트\(패딩의 터미널 null은 포함하지 않음\)를 설정합니다. CLIENT-MASTER-KEY를 0x03으로 변경합니다\(다른 패딩 바이트는 무작위임\). ENCRYPTED-KEY-DATA 필드를 해독한 후 TLS를 지원하는 서버는 이러한 8개의 패딩 바이트가 0x03인 경우 오류를 발행해야 합니다. 이러한 방식으로 패딩된 블록을 수신하는 버전 2.0 서버는 정상적으로 진행됩니다.

---
## **F. Security analysis**

TLS 프로토콜은 안전하지 않은 채널을 통해 통신하는 클라이언트와 서버 간에 보안 연결을 설정하도록 설계되었습니다. 이 문서에서는 공격자가 상당한 컴퓨팅 리소스를 보유하고 있으며 프로토콜 외부 소스로부터 비밀 정보를 얻을 수 없다는 점을 포함하여 몇 가지 전통적인 가정을 하고 있습니다. 공격자는 통신 채널을 통해 전송된 메시지를 캡처, 수정, 삭제, 재생 및 변조할 수 있는 능력을 갖고 있는 것으로 간주됩니다. 이 부록에서는 TLS가 다양한 공격에 저항하도록 어떻게 설계되었는지 간략하게 설명합니다.

---
### **F.1. Handshake protocol**

핸드셰이크 프로토콜은 CipherSpec을 선택하고 보안 세션과 관련된 기본 암호화 매개변수를 함께 구성하는 마스터 비밀을 생성하는 역할을 합니다. 핸드셰이크 프로토콜은 선택적으로 신뢰할 수 있는 인증 기관에서 서명한 인증서를 가진 당사자를 인증할 수도 있습니다.

---
#### **F.1.1. Authentication and key exchange**

TLS는 양 당사자 인증, 인증되지 않은 클라이언트를 사용한 서버 인증, 전체 익명성이라는 세 가지 인증 모드를 지원합니다. 서버가 인증될 때마다 채널은 중간자 공격으로부터 안전하지만 완전히 익명인 세션은 본질적으로 이러한 공격에 취약합니다. 익명 서버는 클라이언트를 인증할 수 없습니다. 서버가 인증되면 해당 인증서 메시지는 허용되는 인증 기관으로 연결되는 유효한 인증서 체인을 제공해야 합니다. 마찬가지로 인증된 클라이언트는 서버에 허용 가능한 인증서를 제공해야 합니다. 각 당사자는 상대방의 인증서가 유효하고 만료되거나 취소되지 않았는지 확인할 책임이 있습니다.

키 교환 프로세스의 일반적인 목표는 공격자가 아닌 통신 당사자에게 알려진 pre\_master\_secret을 생성하는 것입니다. pre\_master\_secret은 master\_secret을 생성하는 데 사용됩니다\(섹션 8.1 참조\). master\_secret은 인증서 확인 및 완료 메시지, 암호화 키 및 MAC 비밀을 생성하는 데 필요합니다\(섹션 7.4.8, 7.4.9 및 6.3 참조\). 올바르게 완료된 메시지를 전송함으로써 당사자는 올바른 pre\_master\_secret을 알고 있음을 증명합니다.

---
##### **F.1.1.1. Anonymous key exchange**

키 교환을 위해 RSA 또는 Diffie-Hellman을 사용하여 완전한 익명 세션을 설정할 수 있습니다. 익명 RSA를 사용하면 클라이언트는 서버의 인증되지 않은 공개 키로 pre\_master\_secret을 암호화합니다.

서버 키 교환 메시지에서 추출되었습니다. 결과는 클라이언트 키 교환 메시지로 전송됩니다. 도청자는 서버의 개인 키를 모르기 때문에 pre\_master\_secret을 해독하는 것은 불가능합니다. \(이 문서에는 익명의 RSA 암호 제품군이 정의되어 있지 않습니다.\)

Diffie-Hellman을 사용하면 서버의 공개 매개변수가 서버 키 교환 메시지에 포함되고 클라이언트의 공개 매개변수는 클라이언트 키 교환 메시지에 전송됩니다. 비공개 값을 모르는 도청자는 Diffie-Hellman 결과\(예: pre\_master\_secret\)를 찾을 수 없어야 합니다.

```text
 Warning: Completely anonymous connections only provide protection
          against passive eavesdropping. Unless an independent tamper-
          proof channel is used to verify that the finished messages
          were not replaced by an attacker, server authentication is
          required in environments where active man-in-the-middle
          attacks are a concern.
```

---
##### **F.1.1.2. RSA key exchange and authentication**

RSA를 사용하면 키 교환과 서버 인증이 결합됩니다. 공개 키는 서버 인증서에 포함되어 있거나 서버 키 교환 메시지에 전송된 임시 RSA 키일 수 있습니다. 임시 RSA 키가 사용되면 서버의 RSA 또는 DSS 인증서로 서명됩니다. 서명에는 현재 ClientHello.random이 포함되어 있으므로 이전 서명과 임시 키를 재생할 수 없습니다. 서버는 여러 협상 세션에 단일 임시 RSA 키를 사용할 수 있습니다.

참고: 임시 RSA 키 옵션은 서버에 대규모 인증서가 필요하지만 키 교환에 사용되는 키에 대해 정부가 부과한 크기 제한을 준수해야 하는 경우 유용합니다.

클라이언트는 서버의 인증서를 확인한 후 서버의 공개 키를 사용하여 pre\_master\_secret을 암호화합니다. pre\_master\_secret을 성공적으로 디코딩하고 올바르게 완료된 메시지를 생성함으로써 서버는 서버 인증서에 해당하는 개인 키를 알고 있음을 보여줍니다.

RSA가 키 교환에 사용될 때 클라이언트는 인증서 확인 메시지를 사용하여 인증됩니다\(섹션 7.4.8 참조\). 클라이언트는 master\_secret 및 이전의 모든 핸드셰이크 메시지에서 파생된 값에 서명합니다. 이러한 핸드셰이크 메시지에는 서명을 서버에 바인딩하는 서버 인증서와 서명을 현재 핸드셰이크 프로세스에 바인딩하는 ServerHello.random이 포함됩니다.

---
##### **F.1.1.3. Diffie-Hellman key exchange with authentication**

Diffie-Hellman 키 교환이 사용되는 경우 서버는 고정된 Diffie-Hellman 매개변수가 포함된 인증서를 제공하거나 서버 키 교환 메시지를 사용하여 DSS 또는 RSA 인증서로 서명된 임시 Diffie-Hellman 매개변수 세트를 보낼 수 있습니다. 공격자가 이전 매개변수를 재생하지 않도록 서명하기 전에 임시 매개변수가 hello.random 값으로 해시됩니다. 두 경우 모두 클라이언트는 인증서나 서명을 확인하여 매개변수가 서버에 속하는지 확인할 수 있습니다.

클라이언트에 고정된 Diffie-Hellman 매개변수가 포함된 인증서가 있는 경우 해당 인증서에는 키 교환을 완료하는 데 필요한 정보가 포함됩니다. 이 경우 클라이언트와 서버는 통신할 때마다 동일한 Diffie-Hellman 결과\(예: pre\_master\_secret\)를 생성합니다. pre\_master\_secret이 필요 이상으로 메모리에 오래 머무르는 것을 방지하려면 최대한 빨리 master\_secret으로 변환해야 합니다. 키 교환이 작동하려면 클라이언트 Diffie-Hellman 매개변수가 서버에서 제공하는 매개변수와 호환되어야 합니다.

클라이언트에 표준 DSS 또는 RSA 인증서가 있거나 인증되지 않은 경우 클라이언트 키 교환 메시지에 포함된 임시 매개변수 세트를 서버에 보낸 다음 선택적으로 인증서 확인 메시지를 사용하여 자신을 인증합니다.

---
#### **F.1.2. Version rollback attacks**

TLS에는 SSL 버전 2.0에 비해 상당한 개선 사항이 포함되어 있으므로 공격자는 TLS 지원 클라이언트와 서버를 버전 2.0으로 대체하려고 시도할 수 있습니다. 이 공격은 두 개의 TLS 가능 당사자가 SSL 2.0 핸드셰이크를 사용하는 경우에만 발생할 수 있습니다.

무작위가 아닌 PKCS #1 블록 유형 2 메시지 패딩을 사용하는 솔루션은 우아하지 않지만 버전 3.0 서버가 공격을 탐지할 수 있는 합리적인 보안 방법을 제공합니다. 이 솔루션은 애플리케이션이 지정한 대기 임계값이 만료되기 전에 키를 무차별 대입하여 동일한 키\(그러나 일반 패딩 포함\)가 포함된 새 ENCRYPTED-KEY-DATA 메시지로 대체할 수 있는 공격자에 대해 안전하지 않습니다. 이 정도 규모의 공격을 우려하는 당사자는 어쨌든 40비트 암호화 키를 사용해서는 안 됩니다. PKCS 패딩 중 최하위 8바이트의 패딩을 변경하는 것은 서명된 해시 크기와 프로토콜에 사용되는 RSA 키 길이에 대한 보안에 영향을 주지 않습니다. 이는 본질적으로 입력 블록 크기를 8바이트 늘리는 것과 동일하기 때문입니다.

---
#### **F.1.3. Detecting attacks against the handshake protocol**

공격자는 당사자가 일반적으로 선택하는 것과 다른 암호화 알고리즘을 선택하도록 핸드셰이크 교환에 영향을 주려고 시도할 수 있습니다. 많은 구현이 40비트 내보내기 가능한 암호화를 지원하고 일부는 널 암호화 또는 MAC 알고리즘을 지원할 수도 있으므로 이 공격은 특히 우려됩니다.

이 공격의 경우 공격자는 하나 이상의 핸드셰이크 메시지를 적극적으로 변경해야 합니다. 이런 일이 발생하면 클라이언트와 서버는 핸드셰이크 메시지 해시에 대해 서로 다른 값을 계산합니다. 결과적으로 당사자들은 서로의 완료된 메시지를 수락하지 않습니다. master\_secret이 없으면 공격자는 완료된 메시지를 복구할 수 없으므로 공격이 발견됩니다.

---
#### **F.1.4. Resuming sessions**

세션을 재개하여 연결이 설정되면 새 ClientHello.random 및 ServerHello.random 값이 세션의 master\_secret으로 해시됩니다. master\_secret이 손상되지 않았고 암호화 키와 MAC 비밀을 생성하는 데 사용된 보안 해시 작업이 안전하다면 연결은 안전해야 하며 이전 연결과 효과적으로 독립적이어야 합니다. 공격자는 알려진 암호화 키나 MAC 비밀을 사용하여 보안 해시 작업\(SHA 및 MD5를 모두 사용\)을 중단하지 않고 master\_secret을 손상시킬 수 없습니다.

클라이언트와 서버가 모두 동의하지 않으면 세션을 재개할 수 없습니다. 세션이 손상되었거나 인증서가 만료 또는 취소되었을 수 있다고 의심되는 경우 당사자는 전체 핸드셰이크를 강제해야 합니다. master\_secret을 획득한 공격자가 해당 세션 ID가 만료될 때까지 손상된 당사자를 가장할 수 있으므로 세션 ID 수명에 대해 24시간의 상한이 제안됩니다. 상대적으로 안전하지 않은 환경에서 실행될 수 있는 애플리케이션은 안정적인 저장소에 세션 ID를 기록해서는 안 됩니다.

---
#### **F.1.5. MD5 and SHA**

TLS는 해시 함수를 매우 보수적으로 사용합니다. 가능한 경우 MD5와 SHA를 함께 사용하여 한 알고리즘의 치명적이지 않은 결함이 전체 프로토콜을 손상시키지 않도록 보장합니다.

---
### **F.2. Protecting application data**

master\_secret은 ClientHello.random 및 ServerHello.random으로 해시되어 각 연결에 대한 고유한 데이터 암호화 키와 MAC 비밀을 생성합니다.

나가는 데이터는 전송 전에 MAC으로 보호됩니다. 메시지 재생 또는 수정 공격을 방지하기 위해 MAC는 MAC 비밀, 시퀀스 번호, 메시지 길이, 메시지 내용 및 두 개의 고정 문자열로부터 계산됩니다. 하나의 TLS Record Layer 클라이언트를 대상으로 하는 메시지가 다른 클라이언트로 리디렉션되지 않도록 하려면 메시지 유형 필드가 필요합니다. 시퀀스 번호는 메시지를 삭제하거나 재정렬하려는 시도가 감지되도록 보장합니다. 시퀀스 번호는 64비트 길이이므로 오버플로되어서는 안 됩니다. 한 당사자의 메시지는 독립적인 MAC 비밀을 사용하므로 다른 당사자의 출력에 삽입될 수 없습니다. 마찬가지로 서버 쓰기 키와 클라이언트 쓰기 키는 독립적이므로 스트림 암호화 키는 한 번만 사용됩니다.

공격자가 암호화 키를 해독하면 해당 키로 암호화된 모든 메시지를 읽을 수 있습니다. 마찬가지로 MAC 키가 손상되면 메시지 수정 공격이 가능해집니다. MAC도 암호화되기 때문에 메시지 변경 공격을 위해서는 일반적으로 MAC뿐만 아니라 암호화 알고리즘도 깨뜨려야 합니다.

참고: MAC 비밀은 암호화 키보다 클 수 있으므로 암호화 키가 손상되더라도 메시지는 변조 방지 상태를 유지할 수 있습니다.

---
### **F.3. Final notes**

TLS가 보안 연결을 제공하려면 클라이언트와 서버 시스템, 키 및 애플리케이션이 모두 안전해야 합니다. 또한 구현에는 보안 오류가 없어야 합니다.

시스템은 가장 약한 키 교환 및 인증 알고리즘이 지원되는 만큼만 강력하며 신뢰할 수 있는 암호화 기능만 사용해야 합니다. 짧은 공개 키, 40비트 대량 암호화 키 및 익명 서버는 매우 주의해서 사용해야 합니다. 구현과 사용자는 어떤 인증서와 인증 기관이 허용되는지 결정할 때 주의해야 합니다. 부정직한 인증 기관은 엄청난 피해를 입힐 수 있습니다.

---
## **G. Patent Statement**

이 프로토콜에 사용하기 위해 제안된 일부 암호화 알고리즘에는 특허권이 있습니다. 또한 Netscape Communications Corporation은 이 표준의 기반이 되는 SSL\(Secure Sockets Layer\) 작업에 대한 특허권을 보유하고 있습니다. RFC 2026에 정의된 인터넷 표준 프로세스에서는 라이센스가 합리적인 조건에 따라 신청자에게 제공될 것임을 나타내는 진술서를 특허 보유자로부터 입수할 것을 요청합니다.

MIT\(Massachusetts Institute of Technology\)는 RSA Data Security, Inc.에 미국에서 발행된 다음 특허에 대한 독점 하위 라이센스 권한을 부여했습니다.

```text
       Cryptographic Communications System and Method ("RSA"), No.
       4,405,829
```

Netscape Communications Corporation은 미국에서 다음 특허를 취득했습니다.

```text
       Secure Socket Layer Application Program Apparatus And Method
       ("SSL"), No. 5,657,390
```

Netscape Communications는 다음과 같은 성명을 발표했습니다.

```text
       Intellectual Property Rights

       Secure Sockets Layer
```

- 미국 특허상표청\("PTO"\)은 최근 Secure Sockets Layers\("SSL"\)로 기술된 발명에 대해 Netscape에 미국 특허 번호 5,657,390\("SSL 특허"\)을 발행했습니다. IETF는 현재 보안 기능을 갖춘 전송 프로토콜로 SSL 채택을 고려하고 있습니다. Netscape는 다음 이용 약관에 따라 로열티 없는 SSL 프로토콜 채택 및 사용을 권장합니다.

```text
         * If you already have a valid SSL Ref license today which
           includes source code from Netscape, an additional patent
           license under the SSL patent is not required.

         * If you don't have an SSL Ref license, you may have a royalty
           free license to build implementations covered by the SSL
           Patent Claims or the IETF TLS specification provided that you
           do not to assert any patent rights against Netscape or other
           companies for the implementation of SSL or the IETF TLS
           recommendation.
```

- "특허 청구"란 무엇입니까?

- 특허 청구는 다음과 같은 발행된 외국 또는 국내 특허에 대한 청구입니다.

```text
        1) must be infringed in order to implement methods or build
           products according to the IETF TLS specification;  or

        2) patent claims which require the elements of the SSL patent
           claims and/or their equivalents to be infringed.
```

Internet Society, Internet Architecture Board, Internet Engineering Steering Group 및 Corporation for National Research Initiatives는 특허 및 특허 출원의 유효성이나 범위, 보증 조건의 적절성에 대해 어떠한 입장도 취하지 않습니다. 위에 언급된 Internet Society 및 기타 그룹은 이 표준의 실행에 적용될 수 있는 기타 지적 재산권에 대해 어떠한 결정도 내리지 않았습니다. 이러한 문제에 대한 추가 고려는 사용자 자신의 책임입니다.

---
# **Security Considerations**

보안 문제는 이 메모 전체에서 논의됩니다.

---
# **References**

```text
   [3DES]   W. Tuchman, "Hellman Presents No Shortcut Solutions To DES,"
            IEEE Spectrum, v. 16, n. 7, July 1979, pp40-41.

   [BLEI]   Bleichenbacher D., "Chosen Ciphertext Attacks against
            Protocols Based on RSA Encryption Standard PKCS #1" in
            Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462, pages:
            1--12, 1998.

   [DES]    ANSI X3.106, "American National Standard for Information
            Systems-Data Link Encryption," American National Standards
            Institute, 1983.

   [DH1]    W. Diffie and M. E. Hellman, "New Directions in
            Cryptography," IEEE Transactions on Information Theory, V.
            IT-22, n. 6, Jun 1977, pp. 74-84.

   [DSS]    NIST FIPS PUB 186, "Digital Signature Standard," National
            Institute of Standards and Technology, U.S. Department of
            Commerce, May 18, 1994.

   [FTP]    Postel J., and J. Reynolds, "File Transfer Protocol", STD 9,
            RFC 959, October 1985.

   [HTTP]   Berners-Lee, T., Fielding, R., and H. Frystyk, "Hypertext
            Transfer Protocol -- HTTP/1.0", RFC 1945, May 1996.

   [HMAC]   Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:  Keyed-
            Hashing for Message Authentication," RFC 2104, February
            1997.

   [IDEA]   X. Lai, "On the Design and Security of Block Ciphers," ETH
            Series in Information Processing, v. 1, Konstanz: Hartung-
            Gorre Verlag, 1992.

   [MD2]    Kaliski, B., "The MD2 Message Digest Algorithm", RFC 1319,
            April 1992.

   [MD5]    Rivest, R., "The MD5 Message Digest Algorithm", RFC 1321,
            April 1992.

   [PKCS1]  RSA Laboratories, "PKCS #1: RSA Encryption Standard,"
            version 1.5, November 1993.

   [PKCS6]  RSA Laboratories, "PKCS #6: RSA Extended Certificate Syntax
            Standard," version 1.5, November 1993.

   [PKCS7]  RSA Laboratories, "PKCS #7: RSA Cryptographic Message Syntax
            Standard," version 1.5, November 1993.

   [PKIX]   Housley, R., Ford, W., Polk, W. and D. Solo, "Internet
            Public Key Infrastructure: Part I: X.509 Certificate and CRL
            Profile", RFC 2459, January 1999.

   [RC2]    Rivest, R., "A Description of the RC2(r) Encryption
            Algorithm", RFC 2268, January 1998.

   [RC4]    Thayer, R. and K. Kaukonen, A Stream Cipher Encryption
            Algorithm, Work in Progress.

   [RSA]    R. Rivest, A. Shamir, and L. M. Adleman, "A Method for
            Obtaining Digital Signatures and Public-Key Cryptosystems,"
            Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120-
            126.

   [RSADSI] Contact RSA Data Security, Inc., Tel: 415-595-8782

   [SCH]    B. Schneier. Applied Cryptography: Protocols, Algorithms,
            and Source Code in C, Published by John Wiley & Sons, Inc.
            1994.

   [SHA]    NIST FIPS PUB 180-1, "Secure Hash Standard," National
            Institute of Standards and Technology, U.S. Department of
            Commerce, Work in Progress, May 31, 1994.

   [SSL2]   Hickman, Kipp, "The SSL Protocol", Netscape Communications
            Corp., Feb 9, 1995.

   [SSL3]   A. Frier, P. Karlton, and P. Kocher, "The SSL 3.0 Protocol",
            Netscape Communications Corp., Nov 18, 1996.

   [TCP]    Postel, J., "Transmission Control Protocol," STD 7, RFC 793,
            September 1981.

   [TEL]    Postel J., and J. Reynolds, "Telnet Protocol
            Specifications", STD 8, RFC 854, May 1993.

   [TEL]    Postel J., and J. Reynolds, "Telnet Option Specifications",
            STD 8, RFC 855, May 1993.

   [X509]   CCITT. Recommendation X.509: "The Directory - Authentication
            Framework". 1988.

   [XDR]    R. Srinivansan, Sun Microsystems, RFC-1832: XDR: External
            Data Representation Standard, August 1995.
```

---
# **Credits**

```text
   Win Treese
   Open Market

   EMail: treese@openmarket.com

   Editors

   Christopher Allen                  Tim Dierks
   Certicom                           Certicom

   EMail: callen@certicom.com         EMail: tdierks@certicom.com

   Authors' Addresses

   Tim Dierks                         Philip L. Karlton
   Certicom                           Netscape Communications

   EMail: tdierks@certicom.com

   Alan O. Freier                     Paul C. Kocher
   Netscape Communications            Independent Consultant

   EMail: freier@netscape.com         EMail: pck@netcom.com

   Other contributors

   Martin Abadi                       Robert Relyea
   Digital Equipment Corporation      Netscape Communications

   EMail: ma@pa.dec.com               EMail: relyea@netscape.com

   Ran Canetti                        Jim Roskind
   IBM Watson Research Center         Netscape Communications

   EMail: canetti@watson.ibm.com      EMail: jar@netscape.com

   Taher Elgamal                      Micheal J. Sabin, Ph. D.
   Securify                           Consulting Engineer

   EMail: elgamal@securify.com        EMail: msabin@netcom.com

   Anil R. Gangolli                   Dan Simon
   Structured Arts Computing Corp.    Microsoft

   EMail: gangolli@structuredarts.com EMail:  dansimon@microsoft.com

   Kipp E.B. Hickman                  Tom Weinstein
   Netscape Communications            Netscape Communications

   EMail: kipp@netscape.com           EMail: tomw@netscape.com

   Hugo Krawczyk
   IBM Watson Research Center

   EMail: hugo@watson.ibm.com
```

---
# **Comments**

IETF TLS 작업 그룹의 토론 목록은 이메일 주소 <ietf-tls@lists.consensus.com\>에 있습니다. 그룹에 대한 정보와 목록 구독 방법에 대한 정보는 <http://lists.consensus.com/\>에서 확인할 수 있습니다.

목록의 아카이브는 다음에서 찾을 수 있습니다: - <http://www.imc.org/ietf-tls/mail-archive/\>

---
# **Full Copyright Statement**

저작권\(C\)인터넷학회\(1999\). 판권 소유.

본 문서와 그 번역본은 다른 사람에게 복사 및 제공될 수 있으며, 본 문서에 대해 논평하거나 설명하거나 구현을 지원하는 파생 저작물은 어떤 종류의 제한 없이 전체 또는 일부를 준비, 복사, 출판 및 배포할 수 있습니다. 단, 위의 저작권 표시와 이 단락은 모든 사본과 파생물에 포함되어 있어야 합니다. 그러나 이 문서 자체는 저작권 표시를 제거하거나 인터넷 협회 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떠한 방식으로도 수정할 수 없습니다. 단, 인터넷 표준을 개발할 목적으로 필요한 경우는 제외됩니다. 이 경우 저작권에 대한 절차는 인터넷 표준 프로세스를 따라야 하거나 영어 이외의 언어로 번역하려면 필요한 대로 따라야 합니다.

위에 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회와 인터넷 엔지니어링 태스크 포스는 여기에 있는 정보의 사용으로 인해 발생하지 않는 모든 보증을 포함하되 이에 국한되지 않고 명시적이든 묵시적이든 모든 보증을 부인합니다. 특정 목적에 대한 상품성이나 적합성에 대한 권리나 묵시적인 보증을 침해하는 행위.
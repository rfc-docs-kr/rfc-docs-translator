

```text
Network Working Group                                         C. Lonvick
Request for Comments: 3164                                 Cisco Systems
Category: Informational                                      August 2001
```

- BSD syslog 프로토콜

---
# **Status of this Memo**

이 메모는 인터넷 커뮤니티에 대한 정보를 제공합니다. 어떤 종류의 인터넷 표준도 지정하지 않습니다. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(2001\). 판권 소유.

---
# **Abstract**

이 문서에서는 syslog 프로토콜의 관찰된 동작을 설명합니다. 이 프로토콜은 수년 동안 네트워크를 통해 이벤트 알림 메시지를 전송하는 데 사용되었습니다. 이 프로토콜은 원래 University of California Berkeley Software Distribution\(BSD\) TCP/IP 시스템 구현에서 개발되었지만 운영 및 관리에 대한 가치로 인해 다른 많은 운영 체제로 이식될 뿐만 아니라 다른 많은 네트워크 장치에 내장되었습니다. .

---
# **Table of Contents**

```text
   1. Introduction....................................................2
   1.1 Events and Generated Messages..................................3
   1.2 Operations of the Message Receivers............................5
   2. Transport Layer Protocol........................................5
   3. Definitions and Architecture....................................5
   4. Packet Format and Contents......................................7
   4.1 syslog Message Parts...........................................8
   4.1.1 PRI Part.....................................................8
   4.1.2 HEADER Part of a syslog Packet..............................10
   4.1.3 MSG Part of a syslog Packet.................................11
   4.2 Original syslog Packets Generated by a Device.................12
   4.3 Relayed syslog Packets........................................12
   4.3.1 Valid PRI and TIMESTAMP.....................................13
   4.3.2 Valid PRI but no TIMESTAMP or invalid TIMESTAMP.............13
   4.3.3 No PRI or Unidentifiable PRI................................14
   5. Conventions....................................................14
   5.1 Dates and Times...............................................15
   5.2 Domain Name and Address.......................................15
   5.3 Originating Process Information...............................15
   5.4 Examples......................................................16
   6. Security Considerations........................................18
   6.1 Packet Parameters.............................................19
   6.2 Message Authenticity..........................................19
   6.2.1 Authentication Problems.....................................19
   6.2.2 Message Forgery.............................................20
   6.3 Sequenced Delivery............................................20
   6.3.1 Single Source to a Destination..............................20
   6.3.2 Multiple Sources to a Destination...........................21
   6.3.3 Multiple Sources to Multiple Destinations...................21
   6.3.4 Replaying...................................................22
   6.4 Reliable Delivery.............................................22
   6.5 Message Integrity.............................................22
   6.6 Message Observation...........................................22
   6.7 Message Prioritization and Differentiation....................23
   6.8 Misconfiguration..............................................24
   6.9 Forwarding Loop...............................................24
   6.10 Load Considerations..........................................25
   7. IANA Considerations............................................25
   8. Conclusion and Other Efforts...................................25
   Acknowledgements..................................................26
   References........................................................27
   Author's Address..................................................28
   Full Copyright Statement..........................................29
```

---
## **1. Introduction**

태초부터 삶은 메시지 전달에 의존해 왔습니다. 자기 인식 유기체의 경우 이러한 메시지는 다양한 내용을 전달할 수 있습니다. 메시지는 위험, 음식이나 기타 생활 필수품의 존재 및 기타 여러 가지 신호를 나타낼 수 있습니다. 대부분의 경우 이러한 메시지는 다른 장치에 정보를 제공하므로 확인이 필요하지 않습니다. 사람들이 상호 작용하고 프로세스를 만들면서 이와 동일한 원칙이 사회적 커뮤니케이션에도 적용되었습니다. 예를 들어, 악천후 경고는 사이렌 소리, 텔레비전 및 라디오 방송국을 통한 경고 전달, 심지어 선박의 깃발 사용 등 다양한 채널을 통해 전달될 수 있습니다. 이러한 경고를 듣거나 보는 사람들은 그 중요성을 깨닫고 적절한 조치를 취할 것으로 기대됩니다. 대부분의 경우 경고 수신에 대한 응답 확인이 필요하지 않거나 바람직하지 않습니다. 이와 동일한 방식으로 운영 체제, 프로세스 및 응용 프로그램은 자체 상태 메시지 또는 특정 이벤트가 발생했음을 나타내는 메시지를 보내기 위해 작성되었습니다. 이러한 이벤트 메시지는 일반적으로 기계 운영자에게 지역적으로 중요한 의미를 갖습니다. 운영 체제, 프로세스 및 애플리케이션이 더욱 복잡해짐에 따라 이러한 다양한 메시지를 분류 및 기록하고 운영 직원이 보다 신속하게 작업을 수행할 수 있도록 시스템이 고안되었습니다.

문제 알림을 단순한 상태 메시지와 구별합니다. syslog 프로세스는 많은 운영 체제에서 널리 채택되는 시스템 중 하나였습니다. 이 프로세스에는 유연성이 설계되어 운영 직원이 장치에서 실행 중인 프로세스에서 전송된 메시지의 대상을 구성할 수 있습니다. 한 차원에서는 syslog 프로세스에서 수신한 이벤트를 다른 파일에 기록하고 장치 콘솔에도 표시할 수 있습니다. 다른 차원에서는 네트워크를 통해 메시지를 다른 시스템의 syslog 프로세스로 전달하도록 syslog 프로세스를 구성할 수 있습니다. syslog 프로세스는 어느 정도의 확장성을 위해 네트워크를 인식하도록 구축되어야 했습니다. 여러 시스템의 운영자가 각 시스템에 기록된 메시지를 검토하기 위해 각 시스템에 액세스할 시간이 없다는 것이 알려졌기 때문입니다. 따라서 원격 장치에서 실행되는 syslog 프로세스는 메시지를 파일에 추가하거나 나중에 다른 시스템으로 전달하도록 구성될 수 있습니다.

가장 단순한 용어로 말하면, syslog 프로토콜은 시스템이 IP 네트워크를 통해 syslog 서버라고도 하는 이벤트 메시지 수집기에 이벤트 알림 메시지를 보낼 수 있도록 하는 전송을 제공합니다. 각 프로세스, 애플리케이션 및 운영 체제는 어느 정도 독립적으로 작성되었으므로 syslog 메시지 내용의 일관성이 거의 없습니다. 이러한 이유로 메시지의 형식이나 내용에 대한 가정은 이루어지지 않습니다. 프로토콜은 단순히 이러한 이벤트 메시지를 전송하도록 설계되었습니다. 모든 경우에 메시지를 생성하는 장치는 하나입니다. 해당 머신의 syslog 프로세스는 메시지를 수집기로 보낼 수 있습니다. 접수확인이 되지 않습니다.

syslog 프로토콜 및 프로세스의 기본 원칙 중 하나는 단순성입니다. 송신기와 수신기 사이에는 엄격한 조정이 필요하지 않습니다. 실제로 syslog 메시지 전송은 수신기를 구성하지 않거나 실제로 물리적으로 존재하지 않는 장치에서 시작될 수 있습니다. 반대로, 대부분의 장치는 명시적인 구성이나 정의 없이 메시지를 수신할 수 있습니다. 이러한 단순성은 syslog의 수용과 배포에 큰 도움이 되었습니다.

---
## **1.1 Events and Generated Messages**

운영 체제, 프로세스 및 애플리케이션 작성자는 메시지를 생성하는 상황을 완전히 제어할 수 있습니다. 어떤 경우에는 상태를 제공하기 위해 메시지가 생성됩니다. 이는 특정 기간에 있을 수도 있고 프로그램 호출이나 종료와 같은 다른 간격에 있을 수도 있습니다. 다른 경우에는 일련의 조건이 충족되어 메시지가 생성될 수 있습니다. 이러한 경우 상태 메시지나 특정 유형의 경보가 포함된 메시지가 생성될 수 있습니다. 작가들은 다음과 같은 것으로 간주되었습니다.

운영 체제, 프로세스 및 애플리케이션은 메시지를 여러 가지 광범위한 범주 중 하나로 수량화합니다. 이러한 광범위한 범주는 일반적으로 메시지의 심각도 표시와 함께 이를 생성한 기능으로 구성됩니다. 이는 운영 직원이 메시지를 선택적으로 필터링하고 더 중요하고 시간에 민감한 알림을 신속하게 제공하는 동시에 나중에 읽을 수 있도록 상태 또는 정보 메시지를 파일에 배치할 수 있도록 하기 위함이었습니다. 메시지를 표시하거나 저장하는 다른 옵션도 존재하는 것으로 나타났습니다.

장치는 이벤트 메시지 표시 및/또는 전달을 위한 규칙으로 구성되어야 합니다. 지금까지 살펴본 규칙은 일반적으로 매우 유연합니다. 관리자는 모든 메시지를 로컬에 저장하고 심각도가 높은 모든 메시지를 다른 장치로 전달하기를 원할 수 있습니다. 특정 시설의 메시지를 장치 사용자 중 일부 또는 전체에게 전송하고 시스템 콘솔에 표시하는 것이 적절하다고 생각할 수도 있습니다. 그러나 관리자는 이벤트 메시지의 처리를 구성하기로 결정하고 이벤트 메시지를 syslog 수집기로 보내는 프로세스는 일반적으로 어떤 시설 메시지와 어떤 심각도 수준을 전달할지 결정한 다음 원격 수신기를 정의하는 것으로 구성됩니다. 예를 들어, 관리자는 메일 기능에 의해 생성된 모든 메시지가 하나의 특정 이벤트 메시지 수집기로 전달되기를 원할 수 있습니다. 그런 다음 관리자는 커널에서 생성된 모든 메시지를 다른 syslog 수신기로 전송하는 동시에 커널의 매우 심각한 메시지도 세 번째 수신기로 전송하도록 할 수 있습니다. 해당 메시지를 시스템 콘솔에 표시하고 적절한 사람에게 메일로 보내는 동시에 장치의 로컬 디스크에 있는 파일로 보내는 것도 적절할 수 있습니다. 반대로, 로컬로 정의된 프로세스의 메시지가 콘솔에만 표시되고 장치에서 저장되거나 전달되지 않도록 하는 것이 적절할 수 있습니다. 어떤 경우에도 이에 대한 규칙은 장치에서 생성되어야 합니다. 그러면 관리자는 수집기에서 어떤 유형의 메시지가 수신될지 알게 되므로 해당 syslog 서버에서도 적절한 규칙을 만들어야 합니다.\(MUST\)

메시지의 내용은 작성자의 재량에 따라 결정됩니다. 메시지를 읽는 사람에게 유익할 수 있도록 메시지를 작성하는 것이 좋은 형식으로 간주되었습니다. 또한 메시지에 타임스탬프와 전송 장치 및 해당 장치를 생성한 프로세스에 대한 일부 표시를 포함하는 것도 좋은 방법으로 간주되었습니다. 그러나 이들 중 어느 것도 엄격하게 요구되지는 않습니다.

모든 장치의 모든 프로세스가 이벤트 메시지를 생성할 수 있다고 가정해야 합니다. 여기에는 프린터, 라우터, 허브, 스위치 등 로컬 저장소가 없는 컴퓨터의 프로세스가 포함될 수 있습니다.

디스크가 없는 워크스테이션. 이 경우 이벤트 메시지를 수집기로 전송하여 운영자가 기록하고 볼 수 있도록 하는 것이 필수적일 수 있습니다.

---
## **1.2 Operations of the Message Receivers**

이벤트 메시지를 수신할 때 처리하는 방법을 지정하는 것은 이 문서의 범위를 벗어납니다. 섹션 1.1에 설명된 작업과 마찬가지로 일반적으로 적절한 사람에게 표시되거나, 디스크에 저장되거나, 추가로 전달되거나, 이들의 조합이 가능합니다. 수신된 메시지의 처리를 결정하는 규칙은 로컬로 생성된 메시지의 처리를 결정하는 규칙과 동일한 것으로 나타났습니다.

매우 일반적인 규칙에 따르면 일반적으로 상대적으로 적은 수의 수집기에게 메시지를 보내는 장치가 많습니다. 이 팬인\(fan-in\) 프로세스를 통해 관리자는 상대적으로 적은 수의 저장소에 메시지를 집계할 수 있습니다.

---
## **2. Transport Layer Protocol**

syslog는 UDP\(사용자 데이터그램 프로토콜\)\[1\]를 기본 전송 계층 메커니즘으로 사용합니다. syslog에 할당된 UDP 포트는 514입니다. 메시지가 보낸 사람의 syslog 프로세스에서 왔음을 나타내기 위해 소스 포트도 514인 것이 권장되지만 유효한 syslog 메시지가 514에서 온 경우도 있습니다. 발신자가 514 이외의 소스 포트를 사용하는 경우 발신자가 514 이외의 소스 포트를 사용하는 경우 권장되며 후속 메시지가 일관된 단일 포트에서 오는 것이 좋은 형식으로 간주되었습니다.\(SHOULD, SHOULD\)

---
## **3. Definitions and Architecture**

이 문서에서는 다음 정의가 사용됩니다.

메시지를 생성할 수 있는 기계를

-     "장치".

- 메시지를 수신하여 다른 기계로 전달할 수 있는 기계를 "릴레이"라고 합니다.

- 메시지를 수신하고 이를 다른 기계에 전달하지 않는 기계를 "수집기"라고 합니다. 이는 일반적으로 "syslog 서버"로 알려져 있습니다.

- 메시지를 보낼 때 모든 장치나 릴레이는 "발신자"로 알려집니다.

- 모든 릴레이 또는 수집기는 메시지를 수신할 때 "수신기"로 알려집니다.

장치의 아키텍처는 다음과 같이 요약될 수 있습니다.

- 발신자는 수집기인지 릴레이인지 알지 못한 채 릴레이 또는 수집기에게 메시지를 보냅니다.

- 발신자는 동일한 메시지를 여러 수신자에게 보내도록 구성할 수 있습니다.

- 릴레이는 수신한 메시지의 전부 또는 일부를 후속 릴레이 또는 수집기로 보낼 수 있습니다. 메시지를 모두 전달하지 않는 경우 수집기 역할과 릴레이 역할을 모두 수행합니다. 다음 다이어그램에서는 이러한 장치가 릴레이로 지정됩니다.

- 릴레이는 자체 메시지를 생성하여 후속 릴레이 또는 수집자에게 보낼 수도 있습니다. 이 경우 장치 역할을 합니다. 이러한 장치는 다음 다이어그램에서도 릴레이로 지정됩니다.

다이어그램 1에 표시된 다음 아키텍처는 유효하지만 첫 번째 아키텍처가 가장 널리 사용되는 것으로 알려져 있습니다. 이러한 예의 다른 배열도 허용됩니다. 위에서 설명한 대로 다음 다이어그램에서 릴레이는 내부에서 생성한 메시지와 함께 수신한 메시지 전체 또는 일부를 전달할 수 있습니다.

```text
         +------+         +---------+
         |Device|---->----|Collector|
         +------+         +---------+

         +------+         +-----+         +---------+
         |Device|---->----|Relay|---->----|Collector|
         +------+         +-----+         +---------+

         +------+     +-----+            +-----+     +---------+
         |Device|-->--|Relay|-->--..-->--|Relay|-->--|Collector|
         +------+     +-----+            +-----+     +---------+

         +------+         +-----+         +---------+
         |Device|---->----|Relay|---->----|Collector|
         |      |-\       +-----+         +---------+
         +------+  \
                    \      +-----+         +---------+
                     \-->--|Relay|---->----|Collector|
                           +-----+         +---------+

         +------+         +---------+
         |Device|---->----|Collector|
         |      |-\       +---------+
         +------+  \
                    \      +-----+         +---------+
                     \-->--|Relay|---->----|Collector|
                           +-----+         +---------+

         +------+         +-----+            +---------+
         |Device|---->----|Relay|---->-------|Collector|
         |      |-\       +-----+         /--|         |
         +------+  \                     /   +---------+
                    \      +-----+      /
                     \-->--|Relay|-->--/
                           +-----+

           Diagram 1.  Some Possible syslog Architectures
```

---
## **4. Packet Format and Contents**

UDP 대상 포트가 514인 모든 IP 패킷의 페이로드는 syslog 메시지로 처리되어야 합니다. 원래 전송된 syslog 메시지의 형식과 릴레이된 메시지의 형식 간에는 차이가 있을 수 있습니다. 본질적으로 이 문서에 지정된 형식으로 syslog 메시지를 전송하는 것이 권장되지만 필수는 아닙니다. 릴레이가 해당 형식을 준수하는 메시지를 인식할 수 있으면 메시지를 변경하지 않고 메시지를 다시 전송해야 합니다. 그러나 릴레이가 수신하는 경우\(MUST, MAY, SHOULD, MUST\)

메시지가 형식의 적절한 구현을 식별할 수 없으면 메시지를 재전송하기 전에 해당 형식을 따르도록 메시지를 수정해야 합니다. 섹션 4.1에서는 syslog 메시지의 권장 형식을 설명합니다. 섹션 4.2에서는 원래 전송된 메시지에 대한 요구 사항을 설명하고 섹션 4.3에서는 중계된 메시지에 대한 요구 사항을 설명합니다.\(MUST, SHOULD\)

---
## **4.1 syslog Message Parts**

통신 중에 표시되는 syslog 메시지의 전체 형식은 식별 가능한 세 부분으로 구성됩니다. 첫 번째 부분은 PRI, 두 번째 부분은 HEADER, 세 번째 부분은 MSG라고 합니다. 패킷의 총 길이는 1024바이트 이하여야 합니다. 내용이 없는 syslog 패킷을 보내는 것은 가치가 없고 전송되어서는 안 되지만 syslog 메시지의 최소 길이는 없습니다.\(MUST, SHOULD NOT\)

---
### **4.1.1 PRI Part**

PRI 부분은 3자, 4자 또는 5자여야 하며 첫 번째와 마지막 문자로 꺾쇠 괄호로 묶입니다. PRI 부분은 "<"\('보다 작음' 문자\)로 시작하고 그 뒤에 숫자가 오고 그 뒤에 "\>"\('보다 큼' 문자\)가 옵니다. 이 부분에 사용된 코드 세트는 RFC 2234\[2\]에 설명된 대로 8비트 필드의 7비트 ASCII여야 합니다. 이는 "정보 교환을 위한 미국 표준 코드"\[3\]에 정의된 ASCII 코드입니다. 여기서 "<" 문자는 ABNF\(Augmented Backus-Naur Form\) %d60으로 정의되며, "\>" 문자는 ABNF 값 %d62를 갖습니다. 이러한 꺾쇠 괄호 안에 포함된 숫자는 우선 순위 값이라고 하며 아래 설명된 대로 시설과 심각도를 모두 나타냅니다. 우선 순위 값은 %d48\("0"의 경우\)부터 %d57\("9"의 경우\) 값을 사용하여 1, 2 또는 3개의 십진수\(ABNF DIGITS\)로 구성됩니다.\(MUST, MUST\)

메시지의 기능 및 심각도는 십진수 값으로 숫자로 코딩됩니다. 일부 운영 체제 데몬 및 프로세스에는 기능 값이 할당되었습니다. 시설에 명시적으로 할당되지 않은 프로세스 및 데몬은 "로컬 사용" 기능을 사용하거나 "사용자 수준" 기능을 사용할 수 있습니다. 지정된 시설은 숫자 코드 값과 함께 다음 표에 표시됩니다.

```text
       Numerical             Facility
          Code

           0             kernel messages
           1             user-level messages
           2             mail system
           3             system daemons
           4             security/authorization messages (note 1)

           5             messages generated internally by syslogd
           6             line printer subsystem
           7             network news subsystem
           8             UUCP subsystem
           9             clock daemon (note 2)
          10             security/authorization messages (note 1)
          11             FTP daemon
          12             NTP subsystem
          13             log audit (note 1)
          14             log alert (note 1)
          15             clock daemon (note 2)
          16             local use 0  (local0)
          17             local use 1  (local1)
          18             local use 2  (local2)
          19             local use 3  (local3)
          20             local use 4  (local4)
          21             local use 5  (local5)
          22             local use 6  (local6)
          23             local use 7  (local7)

           Table 1.  syslog Message Facilities
```

- 참고 1 - 유사해 보이는 보안/인증, 감사 및 경고 메시지를 위해 시설 4, 10, 13 및 14를 활용하는 다양한 운영 체제가 발견되었습니다. 참고 2 - 시계\(cron/at\) 메시지에 대해 시설 9와 15를 모두 활용하는 다양한 운영 체제가 발견되었습니다.

각 메시지 우선 순위에는 십진수 심각도 수준 표시기도 있습니다. 이는 수치 값과 함께 다음 표에 설명되어 있습니다.

```text
        Numerical         Severity
          Code

           0       Emergency: system is unusable
           1       Alert: action must be taken immediately
           2       Critical: critical conditions
           3       Error: error conditions
           4       Warning: warning conditions
           5       Notice: normal but significant condition
           6       Informational: informational messages
           7       Debug: debug-level messages

           Table 2. syslog Message Severities
```

우선순위 값은 먼저 시설 번호에 8을 곱한 다음 심각도 수치를 더하여 계산됩니다. 예를 들어 긴급 심각도\(Severity=0\)가 있는 커널 메시지\(Facility=0\)의 우선순위 값은 0입니다. 또한 알림 심각도\(Severity=0\)가 있는 "local use 4" 메시지\(Facility=20\)는 =5\)의 우선 순위 값은 165입니다. syslog 메시지의 PRI 부분에서 이 값은 각각 <0\>과 <165\>로 꺾쇠 괄호 사이에 배치됩니다. "0" 값이 "<" 뒤에 오는 유일한 경우는 우선 순위 값 "0"에 대한 것입니다. 그렇지 않으면 앞에 "0"을 사용해서는 안 됩니다.\(MUST NOT\)

---
### **4.1.2 HEADER Part of a syslog Packet**

HEADER 부분에는 타임스탬프와 장치의 호스트 이름 또는 IP 주소 표시가 포함됩니다. syslog 패킷의 HEADER 부분에는 표시되는\(인쇄\) 문자가 포함되어야 합니다. 사용된 코드 세트는 PRI 부분에 사용된 것과 같은 8비트 필드의 7비트 ASCII여야 합니다. 이 코드 세트에서 허용되는 문자는 ABNF VCHAR 값\(%d33-126\)과 공백\(SP 값 %d32\)뿐입니다.\(MUST, MUST\)

HEADER에는 TIMESTAMP와 HOSTNAME이라는 두 개의 필드가 포함되어 있습니다. TIMESTAMP는 PRI 부분의 후행 "\>" 바로 뒤에 오고 단일 공백 ​​문자는 각 TIMESTAMP 및 HOSTNAME 필드 뒤에 와야 합니다. HOSTNAME에는 자체적으로 알려진 호스트 이름이 포함됩니다. 호스트 이름이 없으면 자체 IP 주소가 포함됩니다. 장치에 여러 개의 IP 주소가 있는 경우 일반적으로 메시지가 전송되는 IP 주소를 사용하는 것으로 나타났습니다. 이 동작에 대한 대안도 나타났습니다. 이 경우 메시지가 전송되는 인터페이스에 관계없이 단일 소스 IP 주소를 사용하여 모든 메시지를 전송하도록 장치를 구성할 수 있습니다. 이는 장치에서 전송된 모든 메시지에 대해 일관된 단일 HOSTNAME을 제공합니다.\(MUST\)

TIMESTAMP 필드는 현지 시간이며 "Mmm dd hh:mm:ss"\(따옴표 제외\) 형식입니다. 여기서:

- Mmm은 해당 연도의 월을 나타내는 영어 약어이며 첫 글자는 대문자, 나머지 두 글자는 소문자입니다. 허용되는 유일한 값은 다음과 같습니다.

```text
         Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
```

- dd는 해당 월의 날짜입니다. 해당 월의 날짜가 10보다 작으면 공백과 숫자로 표시되어야 합니다. 예를 들어, 8월 7일은 "g"와 "7" 사이에 두 개의 공백을 포함하여 "Aug 7"로 표시됩니다.\(MUST\)

- hh:mm:ss는 현지 시간입니다. 시간\(hh\)은 24시간 형식으로 표시됩니다. 유효한 항목은 00에서 23 사이입니다. 분\(mm\) 및 초\(ss\) 항목은 00에서 59 사이입니다.

단일 공백 ​​문자는 TIMESTAMP 필드 뒤에 와야 합니다.\(MUST\)

HOSTNAME 필드에는 메시지 발신자의 호스트 이름, IPv4 주소 또는 IPv6 주소만 포함됩니다. 선호되는 값은 호스트 이름입니다. 호스트 이름이 사용되는 경우 HOSTNAME 필드에는 STD 13 \[4\]에 지정된 장치의 호스트 이름이 포함되어야 합니다. 여기에는 공백이 포함되어서는 안 된다는 점에 유의해야 합니다. 도메인 이름은 HOSTNAME 필드에 포함되어서는 안 됩니다. IPv4 주소가 사용되는 경우 STD 13\[5\]에서 사용되는 것처럼 점으로 구분된 십진수 표기법으로 표시되어야 합니다. IPv6 주소가 사용되는 경우 RFC 2373 \[6\]에 사용된 유효한 표현을 사용할 수 있습니다. 단일 공백 ​​문자도 HOSTNAME 필드 뒤에 와야 합니다.\(MUST, MUST NOT, MUST NOT, MUST, MAY, MUST\)

---
### **4.1.3 MSG Part of a syslog Packet**

MSG 부분은 syslog 패킷의 나머지 부분을 채웁니다. 여기에는 일반적으로 메시지를 생성한 프로세스에 대한 일부 추가 정보와 메시지 텍스트가 포함됩니다. 이 부분에는 종료 구분 기호가 없습니다. syslog 패킷의 MSG 부분에는 표시되는\(인쇄\) 문자가 포함되어야 합니다. 전통적으로 가장 자주 사용되는 코드 세트는 PRI 및 HEADER 부분에서 사용되는 것과 같은 8비트 필드의 7비트 ASCII였습니다. 이 코드 세트에서 허용되는 문자는 ABNF VCHAR 값\(%d33-126\)과 공백\(SP 값 %d32\)뿐입니다. 그러나 MSG 내에서 사용되는 코드 세트에 대한 표시는 필요하지 않으며 예상되지도 않습니다. MSG에 사용된 문자가 위에 설명된 것과 유사한 독점적으로 표시되는 문자 및 공백인 한 다른 코드 세트를 사용할 수 있습니다. MSG 부분에 사용되는 코드 세트의 선택은 의도된 수신자를 고려하여 이루어져야 합니다. 수신자가 보거나 이해할 수 없는 코드 세트의 문자가 포함된 메시지는 이를 보는 운영자나 관리자에게 가치 있는 정보를 제공하지 않습니다.\(MUST, MAY, SHOULD\)

MSG 부분에는 TAG 필드와 CONTENT 필드라는 두 개의 필드가 있습니다. 태그 필드의 값은 메시지를 생성한 프로그램 또는 프로세스의 이름이 됩니다. CONTENT에는 메시지의 세부정보가 포함되어 있습니다. 이는 전통적으로 이벤트에 대한 자세한 정보를 제공하는 자유 형식 메시지였습니다. TAG는 32자를 초과할 수 없는 ABNF 영숫자 문자열입니다. 영숫자가 아닌 문자는 TAG 필드를 종료하고 CONTENT 필드의 시작 문자로 간주됩니다. 가장 일반적으로 CONTENT 필드의 첫 번째 문자는\(MUST NOT\)

TAG 필드의 결론은 왼쪽 대괄호 문자\("\["\), 콜론 문자\(":"\) 또는 공백 문자로 표시됩니다. 이에 대해서는 섹션 5.3에서 자세히 설명합니다.

---
## **4.2 Original syslog Packets Generated by a Device**

syslog 패킷은 원래 장치에서 전송되므로 내용에 대해 설정된 요구 사항이 없습니다. UDP 포트 514로 향하는 모든 IP 패킷의 페이로드는 유효한 syslog 메시지로 간주되어야 한다는 점을 여기서 반복해야 합니다. 그러나 syslog 패킷에는 섹션 4.1\(PRI, HEADER 및 MSG\)에 설명된 모든 부분이 포함되어 있는 것이 좋습니다. 이렇게 하면 수신자의 가독성이 향상되고 메시지를 수정하기 위한 릴레이가 필요하지 않기 때문입니다.\(MUST, SHOULD\)

RECOMMENDED 형식으로 syslog 메시지를 구성하기로 선택한 구현자를 위해 다음 지침이 제공됩니다.\(SHOULD\)

- 원래 형성된 메시지의 HEADER 부분에 TIMESTAMP가 있는 경우 해당 시간대 내 장치의 현지 시간이어야 합니다.\(SHOULD\)

- 원래 형성된 메시지에 HOSTNAME 필드가 있는 경우 자체적으로 알고 있는 호스트 이름이 포함됩니다. 호스트 이름이 없으면 자체 IP 주소가 포함됩니다.

- 원래 형성된 메시지에 TAG 값이 있는 경우 해당 값은 메시지를 생성한 프로그램 또는 프로세스의 이름이 됩니다.

---
## **4.3 Relayed syslog Packets**

릴레이가 패킷을 수신하면 유효한 PRI를 확인합니다. 첫 번째 문자가 보다 작음 기호가 아닌 경우 릴레이는 패킷에 유효한 PRI가 포함되어 있지 않다고 가정해야 합니다. 세 번째, 네 번째 또는 다섯 번째 문자가 오른쪽 꺾쇠 괄호 문자가 아닌 경우 릴레이는 다시 PRI가 원본 메시지에 포함되지 않았다고 가정해야 합니다. 릴레이가 유효한 PRI 부분을 찾으면 HEADER 부분에서 유효한 TIMESTAMP를 확인해야 합니다. 이러한 규칙에 따라 수신된 메시지에는 세 가지 일반적인 경우가 있습니다. 표 3은 이러한 사례의 일반적인 특징을 제공하고 해당 사례의 처리를 설명하는 이 문서의 후속 섹션을 나열합니다.\(MUST, MUST\)

```text
              Case                                         Section
         Valid PRI and TIMESTAMP                            4.3.1
         Valid PRI but no TIMESTAMP or invalid TIMESTAMP    4.3.2
         No PRI or unidentifiable PRI                       4.3.3

              Table 3. Cases of Received syslog Messages
```

---
### **4.3.1 Valid PRI and TIMESTAMP**

릴레이가 유효한 PRI와 유효한 TIMESTAMP를 찾으면 내부 구성을 확인합니다. 릴레이는 우선순위 값에 따라 syslog 패킷을 전달하도록 구성되어야 합니다. 릴레이가 수신된 패킷을 전달하도록 구성되어 있음을 발견하면 패킷을 변경하지 않고 전달해야 합니다. 이 점을 다시 한 번 강조하기 위해 원래 전송된 syslog 메시지가 섹션 4.1에 설명된 형식을 따르는 것이 권장되는 이유입니다.\(MUST, MUST, SHOULD\)

여기서는 메시지 수신자가 TIMESTAMP 필드의 시간을 확인할 필요가 없다는 점에 유의해야 합니다. 날짜가 올바르게 설정되지 않은 장치는 여전히 유효한 syslog 메시지를 보낼 수 있다고 가정할 수 있습니다. 또한 릴레이는 HOSTNAME 필드의 값이 메시지를 보내는 장치의 호스트 이름이나 IP 주소와 일치하는지 확인할 필요가 없습니다. 이 동작의 이유는 섹션 4.1.2에서 찾을 수 있습니다.

---
### **4.3.2 Valid PRI but no TIMESTAMP or invalid TIMESTAMP**

릴레이가 수신된 syslog 패킷에서 유효한 TIMESTAMP를 찾지 못한 경우 PRI 부분의 닫는 꺾쇠 괄호 바로 뒤에 TIMESTAMP와 공백 문자를 추가해야 합니다. TIMESTAMP 뒤에 HOSTNAME과 공백 문자를 추가로 추가해야 합니다\(SHOULD\). 이러한 필드는 여기에 설명되어 있으며 섹션 4.1.2에 자세히 설명되어 있습니다. 수신된 패킷의 나머지 부분은 MSG의 CONTENT 필드로 처리되어 추가되어야 합니다. 릴레이는 메시지를 보낸 장치에서 원래 프로세스를 확인할 방법이 없으므로 TAG 값을 확인할 수 없으며 포함되지 않습니다.\(MUST, SHOULD, MUST\)

TIMESTAMP는 릴레이의 현재 현지 시간입니다.

HOSTNAME은 릴레이에 의해 알려진 장치의 이름이 됩니다. 이름을 확인할 수 없는 경우 장치의 IP 주소가 사용됩니다.

릴레이가 PRI 부분 뒤에 TIMESTAMP 또는 TIMESTAMP 및 HOSTNAME을 추가하는 경우 패킷의 총 길이가 여전히 1024바이트 이하인지 확인해야 합니다. 패킷이 1024바이트를 초과하여 확장된 경우 릴레이는 패킷을 1024바이트로 잘라야 합니다. 이로 인해 원본 패킷 끝의 중요한 정보가 손실될 수 있습니다. 이러한 이유로 원래 생성된 syslog 패킷의 PRI 및 HEADER 부분에 섹션 4.1에 설명된 값과 필드가 포함되는 것이 권장됩니다.\(MUST, MUST, SHOULD\)

---
### **4.3.3 No PRI or Unidentifiable PRI**

릴레이가 PRI 없이 또는 식별할 수 없는 PRI가 있는 syslog 메시지를 수신하는 경우 섹션 4.3.2에 설명된 대로 우선 순위 값이 13인 PRI와 TIMESTAMP를 삽입해야 합니다. 릴레이는 섹션 4.3.2에 설명된 대로 HOSTNAME도 삽입해야 합니다. 수신된 패킷의 전체 내용은 중계된 MSG의 내용으로 처리되어 추가됩니다.\(MUST, SHOULD\)

식별할 수 없는 PRI의 예는 큰따옴표가 없는 "<00\>"입니다. 이는 메시지의 처음 4자일 수 있습니다. 이 예를 계속하려면 릴레이가 "<00\>"의 처음 4개 문자가 포함된 syslog 메시지를 수신하면 해당 구성을 참조합니다. 우선 순위 값이 13인 syslog 메시지를 다른 릴레이 또는 수집기로 전달하도록 구성된 경우 위에서 설명한 대로 패킷을 수정해야 합니다. 권장되는 HOSTNAME 삽입을 포함하여 이 작업에 대한 구체적인 내용은 아래에 나와 있습니다.\(MUST, SHOULD\)

```text
   Originally received message
     <00>...
   Relayed message
     <13>TIMESTAMP HOSTNAME <00>...
```

릴레이가 PRI 부분 뒤에 TIMESTAMP 또는 TIMESTAMP 및 HOSTNAME을 추가하는 경우 패킷의 총 길이가 여전히 1024바이트 이하인지 확인해야 합니다. 패킷이 1024바이트를 초과하여 확장된 경우 릴레이는 패킷을 1024바이트로 잘라야 합니다. 이로 인해 원본 패킷 끝의 중요한 정보가 손실될 수 있습니다. 이러한 이유로 원래 생성된 syslog 패킷의 PRI 및 HEADER 부분에 섹션 4.1에 설명된 값과 필드가 포함되는 것이 권장됩니다.\(MUST, MUST, SHOULD\)

---
## **5. Conventions**

이 문서의 섹션 4에서는 syslog 프로토콜 형식 및 내용에 대한 모든 요구 사항을 지정하지만 시간이 지남에 따라 syslog 메시지 내에 추가 정보를 포함하기 위한 특정 규칙이 생겨났습니다. 이러한 항목은 의무 사항은 아니지만 구현자가 완전성을 고려하고 수신자에게 해당 항목의 출처와 특성에 대한 추가 단서를 제공할 수 있다는 점을 분명히 명시해야 합니다.

---
## **5.1 Dates and Times**

일부 네트워크 관리자는 장기간에 걸쳐 syslog 메시지를 보관하기를 좋아하는 것으로 나타났습니다. 일부 원본 syslog 메시지에는 TIMESTAMP를 종료하는 공백 바로 뒤에 2자 또는 4자 연도 필드가 오는 보다 명확한 타임스탬프가 포함되어 있는 것으로 나타났습니다. 이는 필드 순서 및 형식의 원래 의도와 일치하지 않습니다. 구현자가 전송된 메시지 내에 보다 구체적인 날짜 및 시간 스탬프를 포함하려는 경우 CONTENT 필드 내에 있어야 합니다. 구현자는 보다 명확한 날짜 및 시간 정보를 포함하려는 경우 ISO 8601 \[7\] 날짜 및 시간 형식을 활용하기를 원할 수 있습니다.

장기 보관에 대한 이러한 욕구를 해결하기 위한 추가 방법이 제안되었으며 일부는 성공적으로 구현되었습니다. 그러한 방법 중 하나는 네트워크 관리자가 수집기에 저장된 메시지를 수정하도록 선택할 수 있다는 것입니다. 간단한 스크립트를 실행하여 저장된 각 기록에 연도 및 기타 정보를 추가할 수 있습니다. 또는 스크립트는 저장된 시간을 네트워크 관리자의 요구에 더 적합한 형식으로 바꿀 수 있습니다. 또 다른 대안은 현재 연도가 포함된 파일에 레코드를 삽입하는 것입니다. 그렇다면 해당 정보 기록에 가까운 다른 모든 기록은 같은 해에 수신되어야 합니다. 그러나 이들 중 어느 것도 각 레코드에 올바른 시간대를 연결하는 문제를 다루지 않습니다.

---
## **5.2 Domain Name and Address**

메시지를 보낸 장치를 쉽게 식별하려면 FQDN\(정규화된 도메인 이름\)과 IP 주소를 CONTENT 필드에 포함하는 것이 좋습니다. 그러나 전통적으로 HOSTNAME 필드에는 호스트 이름만 포함되었습니다.

---
## **5.3 Originating Process Information**

또한 메시지를 생성한 장치의 프로세스에 대한 일부 정보를 포함하는 것도 좋은 방법으로 간주됩니다\(해당 개념이 있는 경우\). 이는 일반적으로 강력한 운영 체제의 프로세스 이름과 프로세스 ID\(종종 "pid"라고도 함\)입니다. 프로세스 이름은 일반적으로 TAG 필드에 표시됩니다. CONTENT 필드의 시작 부분에 추가 정보가 포함되는 경우가 많습니다. "TAG\[pid\]:" 형식\(따옴표 제외\)이 일반적입니다. 이 경우 왼쪽 대괄호는 TAG 필드를 종료하는 데 사용되며 CONTENT 필드의 첫 번째 문자입니다. 프로세스 ID가 중요하지 않으면 생략될 수 있습니다.

이 경우 일반적으로 TAG 뒤에 콜론과 공백 문자가 표시됩니다. 따옴표 없이 "TAG: "로 표시됩니다. 이 경우 콜론은 CONTENT 필드의 첫 번째 문자입니다.

---
## **5.4 Examples**

예를 들어, 이는 두 장치 사이의 회선에서 관찰될 수 있으므로 유효한 메시지입니다. 다음 예에서는 각 메시지를 들여쓰기했으며 가독성을 위해 줄바꿈을 삽입했습니다.

```text
        Example 1
```

- <34\>Oct 11 22:14:15 mymachine su: /dev/pts/8의 lonvick에 대해 'su root'가 실패했습니다.

이 예에서는 추가 권한을 얻으려는 시도에서 인증 오류가 발생하는 것을 보여줍니다. 또한 시도된 명령과 이를 시도하는 사용자도 표시됩니다. 이는 mymachine이라는 장치에서 원본 메시지로 녹음되었습니다. 이를 수신하는 릴레이는 HEADER 부분에 올바른 형식의 PRI 부분과 TIMESTAMP 필드가 포함되어 있으므로 이를 보내기 전에 아무런 변경도 하지 않습니다. 이 예에서 TAG 값은 프로세스 "su"입니다. 콜론은 TAG 필드를 종료하며 CONTENT 필드의 첫 번째 문자입니다. 이 경우 프로세스 ID\(pid\)는 일시적인 것으로 간주되며 이 syslog 메시지를 보는 사람은 pid를 알더라도 유용한 정보를 얻을 수 없습니다. 포함되지 않았으므로 CONTENT 필드의 처음 두 문자는 콜론과 공백 문자입니다.

```text
        Example 2

        Use the BFG!
```

이는 유효한 메시지이지만 유용한 정보가 거의 없습니다. 이 메시지에는 식별 가능한 PRI 부분이 없습니다. 여기에는 타임스탬프나 메시지 소스 표시가 포함되어 있지 않습니다. 이 메시지가 종이나 디스크에 저장되어 있으면 이후에 메시지를 검토해도 아무런 가치가 없습니다.

이 예는 분명히 장치의 원본 메시지입니다. 릴레이는 메시지를 전달하기 전에 섹션 4.3에 설명된 대로 메시지를 변경해야 합니다. 결과적으로 릴레이된 메시지는 아래와 같습니다.\(MUST\)

```text
        <13>Feb  5 17:32:18 10.0.0.99 Use the BFG!
```

이 중계된 메시지에서는 전체 메시지가 MSG 부분의 CONTENT 부분으로 처리되었습니다. 먼저 기본 우선순위 값인 13을 사용하여 유효한 PRI 부분을 추가했습니다. 다음으로 HEADER 부분에 HOSTNAME과 함께 TIMESTAMP를 추가했습니다. 후속 릴레이에서는 이 메시지를 더 이상 변경하지 않습니다. 이 예에서는 해당 월의 날짜가 10보다 작다는 점에 유의해야 합니다. TIMESTAMP 형식에서는 날짜의 한 자리 숫자\(이 경우 5\) 앞에 공백이 있으므로 TIMESTAMP에서는 월 뒤에 두 개의 공백이 있습니다. 해당 월의 전날. 또한 릴레이는 메시지를 보내는 장치의 호스트 이름을 알지 못하는 것으로 나타나 장치의 IPv4 주소를 HOSTNAME 필드에 삽입했습니다.

```text
        Example 3

         <165>Aug 24 05:34:00 CST 1987 mymachine myproc[10]: %% It's
         time to make the do-nuts.  %%  Ingredients: Mix=OK, Jelly=OK #
         Devices: Mixer=OK, Jelly_Injector=OK, Frier=OK # Transport:
         Conveyer1=OK, Conveyer2=OK # %%
```

이 메시지에는 심각도가 알림인 로컬로 정의된 시설\(local4\)에서 왔음을 나타내는 우선 순위 값이 있는 유효한 PRI 부분이 있습니다. HEADER 부분에는 메시지에 적절한 TIMESTAMP 필드가 있습니다. 릴레이는 이 메시지를 보내기 전에 수정하지 않습니다. 그러나 HOSTNAME 및 TAG 필드는 섹션 4의 정의와 일치하지 않습니다. HOSTNAME 필드는 "CST"로 해석되고 MSG 부분의 시작은 "1987"입니다.

이 예의 CONTENT에 포함된 정보는 원격 측정 데이터도 아니고 감독 제어 또는 데이터 수집 정보도 아니라는 점에 유의해야 합니다. 이 문서의 섹션 6에 나열된 보안 문제로 인해 해당 성격의 정보는 이 프로토콜을 통해 전달되어서는 안 됩니다.

```text
        Example 4

         <0>1990 Oct 22 10:52:01 TZ-6 scapegoat.dmz.example.org 10.1.2.3
         sched[0]: That's All Folks!
```

이 예에는 전체적으로 관련 없는 정보가 많이 포함되어 있습니다. 인간 또는 충분히 적응할 수 있는 자동 파서는 날짜 및 시간 정보뿐만 아니라 FQDN\(정규화된 도메인 이름\) \[4\] 및 IP 주소를 확인할 수 있습니다. 그러나 이벤트 성격에 대한 정보는 제한적입니다. 표시된 이벤트의 심각도로 인해 프로세스에서 더 많은 정보를 수집하거나 보내지 못했을 수 있습니다. 이 메시지를 생성하고 보낸 것은 운이 좋았을 수도 있습니다.

이 예는 분명히 장치의 원본 메시지입니다. HEADER 부분의 첫 번째 필드는 4.1.2절에서 정의한 형식의 TIMESTAMP가 아니므로 릴레이에 의해 수정되어야 합니다. 릴레이는 다음과 같이 TIMESTAMP를 추가하고 HOSTNAME을 추가해야 하며 원래 패킷의 PRI 부분 이후에 수신된 전체 패킷을 새 패킷의 CONTENT 필드로 처리합니다. HOSTNAME 필드에 사용되는 값은 릴레이에서 알려진 도메인 이름 없이 호스트 이름만 사용됩니다. 릴레이된 패킷에는 TAG 값이 추가되지 않습니다. 원본 메시지에 도메인 이름과 IPv4 주소를 포함시키는 것은 고귀한 노력이지만 섹션 4.1.2에 설명된 필드 사용과 일치하지 않습니다.\(MUST, SHOULD\)

```text
         <0>Oct 22 10:52:12 scapegoat 1990 Oct 22 10:52:01 TZ-6
         scapegoat.dmz.example.org 10.1.2.3 sched[0]: That's All Folks!
```

---
## **6. Security Considerations**

냄새는 확인이 필요하지 않은 메시지로 간주될 수 있습니다. 사람들은 나쁜 냄새를 피하는 경향이 있지만 좋은 음식과 관련된 냄새에 끌립니다. 냄새나 향기를 받았다는 사실을 인정할 필요는 없으며 실제로 일부 냄새를 완전히 무시하는 것은 최고의 재량권일 수 있습니다. 반면에, 부엌에서 풍기는 분위기만으로도 요리사의 솜씨를 인정하는 것이 일반적으로 좋은 예의로 간주됩니다. 마찬가지로, 다양한 종들이 짝을 유인하기 위해 냄새를 이용하는 것으로 밝혀졌습니다. 나방의 한 종은 이 냄새를 이용해 서로를 찾습니다. 그러나 볼라스거미는 이 종의 암컷 나방의 냄새를 흉내낼 수 있는 것으로 밝혀졌습니다. 그러면 이 향기는 수컷 나방을 유인할 것이고, 수컷 나방은 짝을 찾을 것이라는 기대를 가지고 따라갈 것입니다. 대신 냄새의 근원지에 도착하면 먹히게 ​​된다\[8\]. 악의적인 의도로 허위 메시지를 발송한 경우입니다.

로컬 사용 시 syslog 프로세스는 이벤트 알림 메시지를 해당 시스템의 파일에 배치합니다. 이는 메시지 보호를 위해 시스템의 무결성에 의존합니다. syslog 프로토콜을 사용하여 메시지를 원격 수집기로 전송하는 syslog 프로세스의 후속 구성은 이벤트 알림 메시지 전달의 확장이었으며 동일한 네트워크 신뢰를 나타냅니다. syslog의 근본적인 단순성으로 인해 여러 보안 결과가 발생하며 강력한 전달이 필요한 상황에서 이 프로토콜의 적용 가능성에 대한 몇 가지 우려가 있습니다. 비유하자면, 컴퓨터 이벤트 메시지는 우연히, 잘못, 심지어는 악의적으로 전송될 수도 있습니다. 그러나 이 글을 쓰는 시점에는 네트워크로 연결된 장치가 다른 장치를 소비한다는 보고는 없습니다.

---
## **6.1 Packet Parameters**

위에서 설명한 대로 메시지 길이는 1024바이트를 초과해서는 안 됩니다. 메시지 길이가 1024바이트를 초과하는 수신자에게 syslog 메시지가 전송되는 경우 공격이 발생했습니다. 일부 이전 버전의 syslog에서는 1024바이트보다 큰 메시지가 포함된 syslog 패킷을 수신하면 문제가 발생했습니다. syslog 메시지 수신기는 메시지 길이가 1024바이트보다 큰 패킷을 수신해도 오작동하지 않아야 합니다. 1024바이트보다 큰 메시지를 수신하는 수신기에서는 다양한 동작이 관찰되었습니다. 일부는 메시지의 전체 내용을 기록하는 반면 다른 일부는 메시지의 일부만 기록하는 것으로 나타났습니다. 또 다른 사람들은 메시지를 완전히 폐기하는 것으로 알려져 있습니다. 장치는 수신된 길이가 1024바이트를 초과하는 메시지를 재전송해서는 안 됩니다.\(MUST NOT, MUST NOT\)

마찬가지로 수신자는 메시지 본문의 정확성을 엄격하게 적용해야 합니다. 수신된 메시지에 유효한 우선 순위 값 주위에 보다 작거나 큰 문자가 없는 경우 syslog 수집기가 오작동해서는 안 됩니다. 메시지를 전달하는 경우 섹션 4.3.3에 설명된 대로 이러한 메시지를 형식화되지 않은 콘텐츠로 처리해야 합니다.\(MUST\)

또한 수신된 메시지에는 섹션 4 전체에 설명된 대로 메시지에 인쇄 가능한 텍스트가 포함되어 있어야 합니다. 위에 설명된 문자 이외의 문자가 포함된 메시지를 수신하는 경우 장치가 오작동해서는 안 됩니다.

---
## **6.2 Message Authenticity**

syslog 전달 메커니즘은 메시지를 메시지 보낸 사람과 강력하게 연결하지 않습니다. 해당 패킷의 수신자는 메시지가 실제로 보고된 발신자로부터 전송되었는지 또는 패킷이 다른 장치에서 전송되었는지 확인할 수 없습니다. 메시지 수신자는 HEADER 부분의 HOSTNAME이 IP 패킷의 소스 주소 필드에 포함된 IP 주소 이름과 일치하는지 확인할 필요가 없습니다.

---
### **6.2.1 Authentication Problems**

이 동작으로 인해 발생할 수 있는 한 가지 결과는 잘못 구성된 시스템이 자신을 다른 시스템으로 나타내는 수집기에 syslog 메시지를 보낼 수 있다는 것입니다. 관리 직원은 메시지 발신자로 추정되는 사람의 상태가 수신된 메시지에 정확하게 반영되지 않을 수 있다는 사실에 혼란스러워할 수 있습니다. 관리자는 자신을 동일한 시스템으로 나타내는 두 개 이상의 시스템이 있다는 사실을 쉽게 식별하지 못할 수도 있습니다.

또한 HEADER 부분의 HOSTNAME 필드를 채우는 경우에는 지역적인 의미만 가질 수 있으며 일시적일 수도 있다는 점에 유의해야 합니다. 장치가 DHCP 풀에서 IP 주소를 얻은 경우 식별자와 실제 소스 간의 연결이 항상 유지되는 것은 아닙니다. CONTENT에 정규화된 도메인 이름을 포함하면 메시지가 항상 IP 주소와 연결될 수 있거나 항상 고유한 시스템과 연결될 수 있는 경우 관리자가 각 메시지의 소스를 식별할 수 있는 가장 좋은 기회를 얻을 수 있습니다.

---
### **6.2.2 Message Forgery**

이 동작에 대한 악의적인 악용도 지적되었습니다. 공격자는 syslog 메시지\(메시지가 전송된 것으로 알려진 시스템 또는 다른 시스템에서\)를 수집기로 전송할 수 있습니다. 어떤 경우에는 공격자가 다른 많은 메시지 속에 공격의 실제 성격을 숨길 수도 있습니다. 예를 들어, 공격자는 일부 시스템의 문제를 나타내는 위조된 메시지를 생성하기 시작할 수 있습니다. 이는 의심되는 문제를 조사하는 데 시간을 할애할 시스템 관리자의 관심을 끌 수 있습니다. 이 시간 동안 공격자는 다른 시스템이나 동일한 시스템의 다른 프로세스를 손상시킬 수 있습니다. 또한 공격자는 상태나 이벤트에 대한 허위 표시를 제공하기 위해 거짓 syslog 메시지를 생성할 수 있습니다. 예를 들어, 공격자는 시스템에서 중요한 프로세스를 중지하여 종료 알림을 생성할 수 있습니다. 이후 공격자는 프로세스가 다시 시작되었다는 위조된 알림을 생성할 수 있습니다. 시스템 관리자는 잘못된 정보를 받아들이고 프로세스가 실제로 다시 시작되었는지 확인하지 않을 수 있습니다.

---
## **6.3 Sequenced Delivery**

일반적으로 네트워크 이상 현상에 대한 포렌식은 일련의 사건을 재구성하는 데 의존합니다. 완벽한 세상에서 메시지는 다른 장치에서 생성된 순서대로 syslog 수집기에 수신되며 이 기록을 보는 사람은 누구나 이벤트 순서에 대한 정확한 그림을 갖게 됩니다. 불행하게도 syslog 프로세스와 프로토콜은 순서화된 전달을 보장하지 않습니다. 이 섹션에서는 이로 인해 발생할 수 있는 몇 가지 문제에 대해 자세히 설명합니다.

---
### **6.3.1 Single Source to a Destination**

syslog 레코드는 일반적으로 수신된 순서대로 표시됩니다\(파일에 배치, 콘솔에 표시 등\). 이는 생성된 순서와 항상 일치하는 것은 아닙니다. IP 네트워크를 통해 전송되므로 일부 잘못된 수신이 예상됩니다. 이로 인해 약간의 혼란이 발생할 수 있습니다.

프로세스가 시작되기 전에 중지되었음을 나타내는 메시지가 수신될 수 있습니다. 전송 전에 원본 프로세스가 각 메시지에 타임스탬프를 지정하거나 번호를 매긴 경우 이는 다소 수정될 수 있습니다. 이 경우 송신 장치는 신뢰할 수 있는 시간 소스를 활용해야 합니다. 그러나 모든 장치가 시간 업데이트를 수신할 수 있는 것은 아니며 모든 장치가 메시지에 타임스탬프를 표시할 수 있는 것은 아니라는 점을 기억해야 합니다.

---
### **6.3.2 Multiple Sources to a Destination**

syslog에는 통합 이벤트 번호 지정 개념이 없습니다. 단일 장치는 CONTENT 내에 시퀀스 번호를 자유롭게 포함할 수 있지만 여러 장치 간에는 조정할 수 없습니다. 이러한 경우 여러 장치에서 각 장치가 첫 번째 메시지를 보내고 있다고 보고할 수 있습니다. 다시 말하지만, 전송 장치가 메시지에서 신뢰할 수 있는 소스의 타임스탬프를 활용하는 경우 이 문제가 다소 수정될 수 있습니다. 그러나 언급한 바와 같이 단일 장치에서 단일 수집기로 보내는 메시지도 순서 없이 수신될 수 있습니다. 단일 수집기에 syslog 메시지를 보내도록 구성된 여러 장치가 있는 경우 이러한 상황은 더욱 복잡해집니다. 첫 번째 장치의 메시지가 두 번째 장치의 메시지보다 먼저 생성되었더라도 한 장치의 메시지가 지연될 수 있으므로 수집기가 다른 장치의 메시지를 먼저 수신하게 됩니다. 타임스탬프나 조정된 시퀀스 번호가 없는 경우 메시지는 수신된 순서대로 표시될 수 있으며 이로 인해 실제 이벤트 시퀀스가 ​​부정확하게 표시될 수 있습니다.

---
### **6.3.3 Multiple Sources to Multiple Destinations**

네트워크 관리자가 사용할 수 있는 수많은 구성 옵션으로 인해 이벤트 순서에 대한 인식이 더욱 왜곡될 수 있습니다. 상태 메시지 또는 기타 정보 메시지를 하나의 수집기에 보내고 상대적으로 더 중요한 메시지를 다른 수집기에 보내도록 장치 그룹을 구성할 수 있습니다. 또한 메시지는 동일한 수집기의 다른 파일로 전송될 수 있습니다. 메시지에 소스의 타임스탬프가 포함되어 있지 않은 경우 메시지가 다른 위치에 보관되면 메시지 순서를 지정하기 어려울 수 있습니다. 관리자는 한 파일의 레코드가 다른 파일의 레코드 이전 또는 이후에 발생했는지 확인하지 못할 수 있습니다. 모든 대상 파일에 타임스탬프가 있는 표시 메시지를 배치하면 이 문제가 다소 완화될 수 있습니다. 여기에 조정된 타임스탬프가 있는 경우 개별 메시지 수신 시간이 표시됩니다.

---
### **6.3.4 Replaying**

순서 표시나 타임스탬프가 없으면 나중에 메시지를 녹음하고 재생할 수 있습니다. 공격자는 시스템의 정상적인 활동을 나타내는 일련의 메시지를 녹음할 수 있습니다. 나중에 해당 공격자는 네트워크에서 해당 시스템을 제거하고 syslog 메시지를 수집기에 재생할 수 있습니다. HEADER 부분에 TIMESTAMP 필드가 있어도 공격자는 패킷을 기록하고 재전송하기 전에 현재 시간을 반영하도록 간단히 수정할 수 있습니다. 관리자는 수신된 메시지에서 이상한 점을 발견할 수 없으며 수신된 메시지는 시스템의 정상적인 활동을 잘못 표시할 수 있습니다.

---
## **6.4 Reliable Delivery**

syslog 프로세스나 프로토콜 내에 전달을 보장하는 메커니즘이 없고 기본 전송이 UDP이므로 일부 메시지가 손실될 수 있습니다. 네트워크 정체로 인해 삭제되거나 악의적으로 가로채서 폐기될 수 있습니다. 하나 이상의 syslog 메시지 삭제 결과를 확인할 수 없습니다. 메시지가 단순한 상태 업데이트인 경우, 미수신이 인지되지 않거나 시스템 운영자에게 불편을 줄 수 있습니다. 반면에 메시지가 더 중요한 경우 관리자는 발전 중이거나 잠재적으로 심각한 문제를 인식하지 못할 수도 있습니다. 무단 활동을 숨기기 위한 방법으로 공격자가 메시지를 가로채서 삭제할 수도 있습니다.

---
## **6.5 Message Integrity**

syslog 메시지는 삭제되는 것 외에도 전송 중에 손상되거나 공격자가 악의적으로 수정할 수도 있습니다. syslog 메시지가 포함된 패킷이 손상된 경우 링크 계층뿐만 아니라 IP\[9\] 및 UDP 프로토콜에도 손상을 감지할 수 있는 다양한 메커니즘이 내장되어 있습니다. 중간 라우터는 손상된 IP 패킷을 폐기할 수 있다\[10\]. UDP 패킷의 손상은 수신 UDP 모듈에 의해 감지될 수 있으며, 이를 자동으로 폐기할 수 있습니다. 어떠한 경우에도 메시지의 원본 내용은 수집자에게 전달되지 않습니다. 또한 공격자가 syslog 메시지의 발신자와 수집자 사이에 위치하는 경우 전송 중인 메시지를 가로채서 수정하여 승인되지 않은 활동을 숨길 수 있습니다.

---
## **6.6 Message Observation**

이벤트 메시지 형식과 관련된 엄격한 지침은 없지만 대부분의 syslog 메시지는 유능한 관리자가 다음 작업을 수행할 수 있어야 한다는 가정 하에 사람이 읽을 수 있는 형식으로 생성됩니다.

그것을 읽고 그 의미를 이해하십시오. syslog 프로토콜이나 syslog 애플리케이션에는 전송 중인 메시지의 기밀성을 제공하는 메커니즘이 없습니다. 대부분의 경우 일반 텍스트 메시지를 전달하는 것은 운영 직원이 회선에서 패킷을 스니핑하는 경우 이점이 됩니다. 운영 직원은 메시지를 읽고 이를 회선을 통과하는 다른 패킷에서 보이는 다른 이벤트와 연관시켜 문제를 추적하고 수정할 수 있습니다. 불행하게도 공격자는 사람이 읽을 수 있는 syslog 메시지의 내용을 관찰할 수도 있습니다. 그런 다음 공격자는 해당 메시지에서 얻은 지식을 사용하여 시스템을 손상시키거나 다른 피해를 입힐 수 있습니다.

---
## **6.7 Message Prioritization and Differentiation**

메시지를 생성하는 프로세스는 메시지 우선 순위 값을 사용하여 이벤트의 중요성을 나타낼 수 있지만 이 값과 패킷 전달의 중요성 사이에는 뚜렷한 연관성이 없습니다. 이에 대한 예로 두 개의 이벤트 메시지를 생성하는 애플리케이션을 생각해 보십시오. 첫 번째는 정상적인 상태 메시지이지만 두 번째는 프로세스 문제를 나타내는 중요한 메시지일 수 있습니다. 이 두 번째 메시지는 해당 이벤트의 중요성과 관련하여 적절하게 더 높은 심각도 값을 갖습니다. 운영자가 이 두 메시지가 모두 syslog 수집기로 전송되도록 구성한 경우 해당 메시지는 전송을 위해 UDP로 전달됩니다. 정상적인 조건에서는 이들 간에 구별이 이루어지지 않으며 순서대로 전송됩니다.

다시 말하지만, 일반적인 상황에서 수신자는 syslog 메시지를 수신하는 대로 받아들입니다. 많은 장치가 일반 상태 메시지를 전송하고 있지만 그 중 하나가 중요한 이벤트 메시지를 전송하는 경우 syslog 프로토콜에는 다른 메시지보다 중요한 메시지의 우선순위를 정하는 고유한 메커니즘이 없습니다.

경우에 따라 장치 운영자는 다양한 수준을 서비스 품질 식별자와 연관시키는 방법을 찾을 수 있습니다. 예를 들어, 운영자는 IPv4 우선순위 필드\[9\], IPv6 트래픽 클래스 옥텟\[11\] 또는 차별화된 서비스에서 사용되는 특정 값과 특정 우선순위 값을 갖는 syslog 메시지 간의 일부 연결을 정의하도록 선택할 수 있습니다. 필드 \[12\]. 위의 예에서, 운영자는 네트워크를 통과할 때 문제를 나타내는 메시지를 높은 신뢰성, 낮은 대기 시간 대기열과 연관시키면서 상태 메시지를 정상적인 전달과 연관시킬 수 있는 능력을 가질 수 있습니다. 이는 일반 상태 메시지보다 필수 메시지의 우선 순위를 정하는 영향을 미칩니다. 이러한 홉별 우선순위 지정을 사용하더라도 이 큐잉 메커니즘은 여전히 ​​전송 장치의 헤드 오브 라인 차단과 수신 장치의 버퍼 부족으로 이어질 수 있습니다.

거의 동시에 전송되거나 수신되는 메시지가 많은 경우 장치. 이 동작은 syslog에만 국한된 것이 아니지만 메시지를 직렬로 전송하는 모든 작업에 고유합니다.

이 동작에는 보안 문제가 있습니다. 중요한 이벤트 메시지의 전송을 라인 책임자가 차단하면 중요한 메시지의 전달이 덜 중요한 메시지 뒤로 밀려날 수 있습니다. 대기열이 적절하게 지워지면 중요한 메시지 전송에 몇 초만 추가될 수 있습니다. 반면, 큐가 지워지지 않으면 중요한 메시지가 전송되지 않을 수 있습니다. 또한 수신 측에서도 많은 수의 메시지가 거의 동시에 수신되어 syslog 수신기가 버퍼 부족 문제를 겪고 있는 경우 중요한 메시지가 다른 메시지와 함께 무분별하게 삭제될 수 있습니다. 이는 장치 및 해당 용량에 문제가 있는 반면, 프로토콜 보안 문제는 덜 중요한 메시지보다 상대적으로 더 중요한 메시지에 우선 순위를 두지 않는다는 것입니다.

---
## **6.8 Misconfiguration**

메시지나 구성에 대해 배포된 제어 정보가 없으므로 메시지가 실제로 의도한 수신자에게 전달되는지 확인하는 것은 전적으로 네트워크 관리자의 책임입니다. 잘못된 수신자에게 syslog 메시지를 보내도록 장치를 실수로 구성한 사례가 보고되었습니다. 많은 경우, 부주의한 수신자는 syslog 메시지를 수신하도록 구성되지 않았을 수 있으며 아마도 해당 메시지를 삭제할 것입니다. 다른 특정 경우에는 syslog 메시지 수신이 의도하지 않은 수신자에게 문제를 일으키는 것으로 알려져 있습니다\[13\]. 메시지가 의도한 수신자에게 전달되지 않으면 검토하거나 처리할 수 없습니다.

---
## **6.9 Forwarding Loop**

그림 1에 표시된 것처럼 시스템은 수집기에 도달하기 전에 syslog 메시지를 후속 릴레이로 릴레이하도록 구성할 수 있습니다. 특별한 경우에 관리자는 특정 우선 순위 값을 가진 메시지를 서로 전달하도록 두 개의 릴레이를 실수로 구성했음을 발견했습니다. 이들 머신 중 하나가 해당 유형의 메시지를 수신하거나 생성하면 이를 다른 릴레이로 전달합니다. 그러면 해당 릴레이가 다시 전달됩니다. 이 주기는 두 장치의 처리 가용성뿐만 아니라 중간 네트워크의 성능 저하를 초래했습니다. 네트워크 관리자는 이러한 죽음의 소용돌이를 일으키지 않도록 주의해야 합니다.

---
## **6.10 Load Considerations**

네트워크 관리자는 syslog 수신기의 적절한 크기를 추정하는 데 시간을 투자해야 합니다. 공격자는 수집기의 디스크를 거짓 메시지로 채워 서비스 거부 공격을 수행할 수 있습니다. 기록을 순환 파일에 보관하면 이 문제가 완화될 수 있지만 이는 관리자가 나중에 기록을 검토할 수 있는지 보장하지 못하는 결과를 낳습니다. 이 과정에서 수신자나 수집자는 전송된 모든 메시지를 수신할 수 있는 네트워크 인터페이스를 가지고 있어야 합니다.

관리자와 네트워크 계획자는 장치, 릴레이 및 수집기 간의 네트워크 경로도 비판적으로 검토해야 합니다. 생성된 syslog 메시지는 네트워크 링크를 압도해서는 안 됩니다.

---
## **7. IANA Considerations**

syslog 프로토콜에는 UDP 포트 514가 할당되었습니다. 이 포트 할당은 이 프로토콜에 대해서만 IANA에 의해 유지됩니다.

syslog 프로토콜은 섹션 4에 설명된 대로 각 메시지의 심각도와 메시지를 생성한 시설을 나타내는 명명된 속성의 정의를 제공합니다. 이러한 속성에 대한 네임스페이스 식별자는 숫자로 정의됩니다. 프로토콜은 이러한 숫자에 대한 이름 공간의 특정 할당을 정의하지 않습니다. 애플리케이션 개발자 또는 시스템 공급업체는 속성, 해당 의미 및 관련 번호를 정의할 수 있습니다. 시스템은 이기종 장치 간에도 유사한 것으로 간주되는 이벤트를 설명하기 위해 동일한 속성, 의미 및 관련 번호를 사용할 것으로 예상되므로 이 이름 공간은 충돌을 방지하기 위해 제어되지 않습니다.

---
## **8. Conclusion and Other Efforts**

syslog 프로토콜은 네트워크를 통해 이벤트 알림 메시지를 전송하는 데 효과적으로 사용될 수 있습니다. 모든 경우에 syslog 메시지 수신자가 "받아들이는 것에 자유로워야 한다"는 원칙을 구현하는 것이 중요합니다. 이를 사용하기로 선택한 네트워크 운영자는 프로토콜의 특성과 보안에 미치는 영향을 이해하는 것이 좋습니다.

과거에도 syslog 메시지 형식을 표준화하려는 시도가 있었습니다. 가장 주목할 만한 시도는 1997년 제40차 인터넷 엔지니어링 태스크 포스 회의의 BOF에서 최고조에 달했습니다. 이는 ulp\(Universal Logging Protocol\) BOF였으며 회의록은 IETF Proceedings 웹 사이트\[14\]에 온라인으로 나와 있습니다.

많은 좋은 생각이 그 노력에서 나왔고 관심 있는 구현자는 그 노력으로 생산된 메모나 문서 중 일부를 찾고 싶어할 수도 있습니다.

이 글을 쓰는 시점에는 전통적으로 텍스트 전용으로 간주되어 왔던 응용 프로그램에서 국제 문자 집합의 사용을 허용하려는 노력이 진행 중입니다. 위에서 설명한 HOSTNAME 및 TIMESTAMP 필드가 이를 대표합니다. 또한 전체 CONTENT 필드는 전통적으로 US-ASCII라는 코드 세트로 문자와 공백을 인쇄해 왔습니다. 이러한 국제화 노력을 지지하는 사람들은 방해 없이 syslog 메시지 내에서 국제 문자 집합을 사용할 수 있는 적절한 방법을 찾을 수 있기를 바랍니다. 또한 구현자가 향후 추가 코드 세트를 수용하고 적절한 계획을 세울 수 있기를 바랍니다. 다시 한 번 말씀드리지만, 기존 시스템의 단순성은 이를 수용하는 데 엄청난 가치가 있다는 점을 주의해야 합니다. 단순성을 감소시키는 것은 그 가치를 감소시킬 수 있습니다.

---
# **Acknowledgements**

이 문서를 작성하는 동안 다음 사람들이 콘텐츠 피드백을 제공했습니다.

```text
         Jon Knight <J.P.Knight@lboro.ac.uk>
         Magosanyi Arpad <mag@bunuel.tii.matav.hu>
         Balazs Scheidler <bazsi@balabit.hu>
         Jon Callas <jon@counterpane.com>
         Eliot Lear <lear@cisco.com>
         Petter Reinholdtsen <pere@hungry.com>
         Darren Reed <darrenr@reed.wattle.id.au>
         Alfonso De Gregorio <dira@speedcom.it>
         Eric Allman <eric@sendmail.com>
         Andrew Ross <andrew@kiwi-enterprises.com>
         George Maslyar <george.maslyar@primark.com>
         Albert Mietus <albert@ons-huis.net>
         Russ Allbery <rra@stanford.edu>
         Titus D. Winters <titus@cs.hmc.edu>
         Edwin P. Boon <Edwin.Boon@consul.com>
         Jeroen M. Mostert <Jeroen.Mostert@consul.com>
```

Eric Allman은 syslog 데몬과 프로토콜의 최초 발명자이자 작성자입니다. 이 메모의 작성자와 커뮤니티 전체는 이 작업과 이 작업이 수년 동안 제공한 유용성에 대해 감사를 표하고 싶습니다.

이 사실상의 표준 운영 체제 기능에 대한 많은 양의 추가 정보는 일반적으로 syslog.conf 파일과 많은 Unix 및 Unix의 syslog.conf, syslog, syslogd 및 logger에 대한 매뉴얼 페이지에서 찾을 수 있습니다. 장치처럼요.

---
# **References**

```text
   1  Postel, J., "User Datagram Protocol", STD 6, RFC 768, August 1980.
```

2 Crocker, D. 및 P. Overell, "구문을 위한 증강된 BNF

- 사양: ABNF", RFC 2234, 1997년 11월.

3 정보 교환을 위한 미국 표준 코드, USASI X3.4-1968

4 Mockapetris, P., "도메인 이름 - 개념 및 시설", STD 13, RFC 1034, 1987년 11월.

5 Mockapetris, P., "도메인 이름 - 구현 및

- 사양", STD 13, RFC 1035, 1987년 11월.

6 Hinden, R. 및 S. Deering, "IP 버전 6 주소 지정 아키텍처", RFC 2373, 1998년 7월.

7 데이터 요소 및 교환 형식 - 정보 교환 - 날짜 및 시간 표시, 국제 표준화 기구, 참조 번호 ISO 8601: 1988 \(E\), 1988

8 Stowe, M. 등, "화학적 모방: 볼라스 거미는 나방 먹이 종의 성 페로몬 성분을 방출합니다", Science, 1987

```text
   9  Postel, J., "Internet Protocol", STD 5, RFC 791, September 1981.
```

10 Baker, F., "IP 버전 4 라우터에 대한 요구 사항", RFC 1812, 1995년 6월.

11 Deering, S. 및 R. Hinden, "인터넷 프로토콜, 버전 6\(IPv6\) 사양", RFC 2460, 1998년 12월.

12 Nichols, K., Blake, S., Baker, F. 및 D. Black, "IPv4 및 IPv6 헤더의 차별화된 서비스 필드\(DS 필드\) 정의", RFC 2474, 1998년 12월.

```text
   13 Cisco Systems Product Security Incident Response Team (PSIRT),
      "Field Notice: Cisco IOS(r) Syslog Crash", January 11, 1999
      http://www.cisco.com/warp/public/707/advisory.html
```

14 Walker, D., IETF 사무국, "40차 인터넷 엔지니어링 태스크 포스 회보, 미국 워싱턴 DC, 1997년 12월 8\~12일 http://www.ietf.org/proceedings/97dec/index.html

---
# **Author's Address**

```text
   Chris Lonvick
   Cisco Systems
   12515 Research Blvd.
   Austin, TX, USA

   Phone:  +1.512.378.1182
   EMail:  clonvick@cisco.com
```

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(2001\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에서 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
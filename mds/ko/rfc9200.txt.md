

```text
﻿

Internet Engineering Task Force (IETF)                          L. Seitz
Request for Comments: 9200                                     Combitech
Category: Standards Track                                    G. Selander
ISSN: 2070-1721                                                 Ericsson
                                                           E. Wahlstroem
                                                                        
                                                              S. Erdtman
                                                              Spotify AB
                                                           H. Tschofenig
                                                                Arm Ltd.
                                                             August 2022

Authentication and Authorization for Constrained Environments Using the
                    OAuth 2.0 Framework (ACE-OAuth)
```

---
# **Abstract**

이 사양은 ACE-OAuth라는 IoT\(사물 인터넷\) 환경의 인증 및 권한 부여를 위한 프레임워크를 정의합니다. 프레임워크는 OAuth 2.0 및 CoAP\(Constrained Application Protocol\)를 포함한 일련의 빌딩 블록을 기반으로 하여 잘 알려지고 널리 사용되는 인증 솔루션을 IoT 장치에 적합한 형태로 변환합니다. 가능한 경우 기존 사양이 사용되지만 IoT 사용 사례에 더 나은 서비스를 제공하기 위해 확장이 추가되고 프로필이 정의됩니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9200에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2022 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
   2.  Terminology
   3.  Overview
     3.1.  OAuth 2.0
     3.2.  CoAP
   4.  Protocol Interactions
   5.  Framework
     5.1.  Discovering Authorization Servers
     5.2.  Unauthorized Resource Request Message
     5.3.  AS Request Creation Hints
       5.3.1.  The Client-Nonce Parameter
     5.4.  Authorization Grants
     5.5.  Client Credentials
     5.6.  AS Authentication
     5.7.  The Authorization Endpoint
     5.8.  The Token Endpoint
       5.8.1.  Client-to-AS Request
       5.8.2.  AS-to-Client Response
       5.8.3.  Error Response
       5.8.4.  Request and Response Parameters
         5.8.4.1.  Grant Type
         5.8.4.2.  Token Type
         5.8.4.3.  Profile
         5.8.4.4.  Client-Nonce
       5.8.5.  Mapping Parameters to CBOR
     5.9.  The Introspection Endpoint
       5.9.1.  Introspection Request
       5.9.2.  Introspection Response
       5.9.3.  Error Response
       5.9.4.  Mapping Introspection Parameters to CBOR
     5.10. The Access Token
       5.10.1.  The Authorization Information Endpoint
         5.10.1.1.  Verifying an Access Token
         5.10.1.2.  Protecting the Authorization Information Endpoint
       5.10.2.  Client Requests to the RS
       5.10.3.  Token Expiration
       5.10.4.  Key Expiration
   6.  Security Considerations
     6.1.  Protecting Tokens
     6.2.  Communication Security
     6.3.  Long-Term Credentials
     6.4.  Unprotected AS Request Creation Hints
     6.5.  Minimal Security Requirements for Communication
     6.6.  Token Freshness and Expiration
     6.7.  Combining Profiles
     6.8.  Unprotected Information
     6.9.  Identifying Audiences
     6.10. Denial of Service Against or with Introspection
   7.  Privacy Considerations
   8.  IANA Considerations
     8.1.  ACE Authorization Server Request Creation Hints
     8.2.  CoRE Resource Types
     8.3.  OAuth Extensions Errors
     8.4.  OAuth Error Code CBOR Mappings
     8.5.  OAuth Grant Type CBOR Mappings
     8.6.  OAuth Access Token Types
     8.7.  OAuth Access Token Type CBOR Mappings
       8.7.1.  Initial Registry Contents
     8.8.  ACE Profiles
     8.9.  OAuth Parameters
     8.10. OAuth Parameters CBOR Mappings
     8.11. OAuth Introspection Response Parameters
     8.12. OAuth Token Introspection Response CBOR Mappings
     8.13. JSON Web Token Claims
     8.14. CBOR Web Token Claims
     8.15. Media Type Registration
     8.16. CoAP Content-Formats
     8.17. Expert Review Instructions
   9.  References
     9.1.  Normative References
     9.2.  Informative References
   Appendix A.  Design Justification
   Appendix B.  Roles and Responsibilities
   Appendix C.  Requirements on Profiles
   Appendix D.  Assumptions on AS Knowledge about the C and RS
   Appendix E.  Differences to OAuth 2.0
   Appendix F.  Deployment Examples
     F.1.  Local Token Validation
     F.2.  Introspection Aided Token Validation
   Acknowledgments
   Authors' Addresses
```

---
## **1.  Introduction**

권한 부여는 일반 리소스 \[RFC4949\]에 액세스하기 위해 엔터티에 승인을 부여하는 프로세스입니다. 권한 부여 작업 자체는 장치에서 호스팅되는 리소스, 즉 리소스 서버\(RS\)에 대해 요청 클라이언트에 액세스 권한을 부여하는 것으로 가장 잘 설명될 수 있습니다. 이 교환은 하나 이상의 인증 서버\(AS\)에 의해 중재됩니다. 다수의 장치 및 사용자에 대한 인증을 관리하는 것은 복잡한 작업일 수 있습니다.

웹 및 모바일 환경을 위한 인증 솔루션에 대한 사전 작업은 사물인터넷\(IoT\) 환경에도 적용되지만, 많은 IoT 장치는 처리 능력, 사용 가능한 메모리 등의 측면에서 제약을 받습니다. 이러한 장치의 경우, CoAP\(Constrained Application Protocol\) \[RFC7252\]는 이 사양의 통신 흐름을 구현하기 위해 HTTP 대신 사용될 때 일부 리소스 문제를 완화할 수 있습니다.

부록 A는 이 설계에서 고려된 제약 조건에 대한 개요를 제공하며 제약 조건에 대한 보다 자세한 처리는 \[RFC7228\]에서 확인할 수 있습니다. 이 설계는 다양한 IoT 배포와 지속적인 장치 및 네트워크 기능을 수용하는 것을 목표로 합니다. 에너지 소비를 예로 들면, 한쪽 끝에는 전력 예산이 빠듯한 에너지 수확 장치 또는 배터리 구동 장치가 있습니다. 다른 쪽 끝에는 주전원 장치가 있습니다. 모든 레벨은 그 사이에 존재합니다.

따라서 IoT 장치는 사용 가능한 처리 및 메시지 교환 기능 측면에서 매우 다를 수 있으며 다양한 인증 사용 사례\[RFC7744\]를 지원해야 합니다.

이 사양은 OAuth 2.0 \[RFC6749\]의 재사용을 기반으로 구축된 제한된 환경에 대한 인증 및 권한 부여\(ACE\)를 위한 프레임워크를 설명하므로 인증을 사물 인터넷 장치로 확장합니다. 이 사양에는 OAuth 2.0을 IoT 환경에 맞게 조정하는 데 필요한 구성 요소가 포함되어 있습니다.

이 프레임워크의 프로필은 \[RFC9202\] 또는 \[RFC9203\]과 같은 별도의 사양으로 제공됩니다. 이러한 프로필은 상호 운용성을 향상시키기 위해 특정 보안 프로토콜에 대한 프레임워크의 사용과 특정 배포 환경에서 사용할 기본 전송을 지정할 수 있습니다. 구현은 특정 프로필과의 적합성을 주장할 수 있으며, 이에 따라 동일한 프로필을 활용하는 구현은 상호 운용되지만, 다른 프로필의 구현은 상호 운용이 가능할 것으로 예상되지 않습니다. 휴대폰 및 태블릿과 같은 보다 강력한 장치는 여러 프로필을 구현할 수 있으므로 더 광범위하고 제한된 장치와 상호 작용할 수 있습니다. 프로필에 대한 요구 사항은 이 사양 전반에 걸쳐 상황에 맞게 적절한 위치에 설명되어 있으며 부록 C에도 요약되어 있습니다.

---
## **2.  Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

"인증", "권한 부여", "기밀성", "\(데이터\) 무결성", "메시지 인증 코드" 및 "확인"과 같은 특정 보안 관련 용어는 \[RFC4949\]에서 가져왔습니다.

이 사양의 교환은 RESTful 프로토콜 상호 작용으로 설명되므로 HTTP \[RFC9110\]은 유용한 용어를 제공합니다. \("RESTful"은 REST\(Representational State Transfer\) 아키텍처를 나타냅니다.\)

아키텍처의 엔터티에 대한 용어는 클라이언트\(C\), 리소스 서버\(RS\) 및 권한 부여 서버\(AS\)와 같은 OAuth 2.0 \[RFC6749\]에 정의되어 있습니다.

여기서 "엔드포인트"라는 용어는 AS의 토큰 및 내부 검사와 RS의 authz-info와 같은 리소스를 나타내는 OAuth 정의 다음에 사용됩니다\(authz-info의 정의는 섹션 5.10.1 참조\). 끝점\). 본 명세서에서는 "CoAP 프로토콜에 참여하는 \[a\]n 엔터티"\[RFC7252\]인 CoAP 정의를 사용하지 않는다.

이 문서의 사양은 "프레임워크" 또는 "ACE 프레임워크"라고 합니다. "이 프레임워크의 프로필"을 언급할 때 이는 구체적인 전송 및 통신 보안 프로토콜\(예: DTLS를 통한 CoAP\)과 함께 이 사양의 사용을 정의하는 추가 사양을 의미합니다.

"액세스 정보"라는 용어는 액세스 토큰 이외의 매개변수에 사용되며 AS가 RS에 액세스할 수 있도록 클라이언트에 제공합니다\(예: RS의 공개 키 또는 RS가 지원하는 프로필\).

"인증 정보"라는 용어는 관련 액세스 토큰의 청구를 포함하여 RS가 액세스 요청을 승인해야 하는지 여부를 결정하는 데 사용하는 모든 정보를 나타내는 데 사용됩니다.

이 문서 전체에서 CBOR 데이터 항목의 예는 달리 명시되지 않는 한 \[RFC8949\]의 섹션 8 및 \[RFC8610\]의 부록 G에 정의된 대로 CBOR 확장 진단 표기법\("진단 표기법"\)으로 표현됩니다. 우리는 종종 진단 표기법 주석을 사용하여 숫자 매개변수 이름과 값의 텍스트 표현을 제공합니다.

---
## **3.  Overview**

이 사양은 사물 인터넷 환경에서 인증을 위한 ACE 프레임워크를 정의합니다. 이는 빌딩 블록 세트로 구성됩니다.

기본 블록은 널리 배포되는 OAuth 2.0 \[RFC6749\] 프레임워크입니다. 많은 IoT 장치는 추가 확장 없이 OAuth 2.0을 지원할 수 있지만 특정 제한된 설정의 경우 추가 프로파일링이 필요합니다.

또 다른 빌딩 블록은 HTTP가 적합하지 않은 통신 환경을 위한 경량 웹 전송 프로토콜 CoAP \[RFC7252\]입니다. CoAP는 일반적으로 UDP 위에서 실행되므로 오버헤드와 메시지 교환이 더욱 줄어듭니다. 이 사양은 CoAP를 통한 OAuth 사용에 대한 확장을 정의하지만 HTTP/2 \[RFC9113\], MQTT\(Message Queuing Telemetry Transport\) \[MQTT5.0\], Bluetooth Low와 같은 다른 기본 프로토콜은 향후 지원되는 것이 금지되지 않습니다. 에너지\(BLE\) \[BLE\] 및 QUIC \[RFC9000\]. 이 문서에서는 GET 및 POST와 같은 RESTful 동사 측면에서 프로토콜 교환을 지정합니다. 이러한 동사를 지원하지 않는 프로토콜을 사용하는 향후 프로필은 대신 해당 프로토콜 메시지가 전송되는 방법을 지정해야 합니다.\(MUST\)

세 번째 빌딩 블록은 JSON \[RFC8259\]이 충분히 컴팩트하지 않은 인코딩을 위한 CBOR\(Concise Binary Object Representation\) \[RFC8949\]입니다. CBOR은 작은 코드와 메시지 크기를 위해 설계된 이진 인코딩입니다. CoAP가 사용될 때 자체 포함 토큰 및 프로토콜 메시지 페이로드는 CBOR로 인코딩됩니다. CoAP를 사용하지 않는 경우 CBOR 사용을 권장합니다.\(SHOULD\)

네 번째 빌딩 블록은 전송 계층 보안\(DTLS \[RFC6347\] \[RFC9147\] 또는 TLS \[RFC8446\]\)에 대한 대안 또는 보완으로 개체 수준 계층 보안을 활성화하는 COSE\(CBOR 개체 서명 및 암호화\) \[RFC8152\]입니다. COSE는 OAuth 전달자 토큰의 확장인 소유 증명\(PoP\) 토큰과 같은 독립형 토큰을 보호하는 데 사용됩니다. 기본 토큰 형식은 CBOR 웹 토큰\(CWT\) \[RFC8392\]에 정의되어 있습니다. COSE를 사용하는 CoAP에 대한 애플리케이션 계층 보안은 OSCORE\(Object Security for Constrained RESTful Environments\) \[RFC8613\]를 통해 제공될 수 있습니다.

위에 나열된 빌딩 블록을 통해 다양한 IoT 장치 및 네트워크 제약을 충족하는 솔루션이 가능합니다. 제약 조건 목록은 \[RFC7228\]에 자세히 설명되어 있으며 위에서 언급한 구성 요소가 다양한 제약 조건과 어떻게 관련되는지에 대한 설명은 부록 A에서 확인할 수 있습니다.

다행히도 모든 IoT 장치가 모든 제약을 겪는 것은 아닙니다. 그럼에도 불구하고 ACE 프레임워크는 이러한 모든 측면을 고려하고 모든 경우에 적용되는 단일 솔루션을 요구하는 대신 여러 가지 배포 변형이 공존할 수 있도록 허용합니다. 보안 관점에서 볼 때 가능한 다양한 상호연동 사용 사례와 다양한 요구 사항을 포괄하는 것이 중요합니다. IoT 배포가 성숙해지면 널리 사용되는 배포 변형이 ACE 프로필 형식으로 문서화됩니다.

---
### **3.1.  OAuth 2.0**

OAuth 2.0 권한 부여 프레임워크를 사용하면 클라이언트는 리소스 소유자의 권한으로 리소스에 대한 범위가 지정된 액세스를 얻을 수 있습니다. 인증 정보 또는 이에 대한 참조는 액세스 토큰을 사용하여 노드 간에 전달됩니다. 이러한 액세스 토큰은 리소스 소유자의 승인을 받아 인증 서버에 의해 클라이언트에 발급됩니다. 클라이언트는 액세스 토큰을 사용하여 리소스 서버에서 호스팅하는 보호된 리소스에 액세스합니다.

이 사양에서는 다양한 OAuth 2.0 용어가 사용됩니다.

액세스 토큰:

- 액세스 토큰은 보호된 리소스에 액세스하는 데 필요한 자격 증명입니다. 액세스 토큰은 AS가 클라이언트에게 발급한 인증 권한을 나타내는 데이터 구조입니다. 액세스 토큰은 AS에 의해 생성되고 RS에 의해 소비됩니다. 액세스 토큰 내용은 클라이언트에게 불투명합니다.

- 액세스 토큰은 해당 배포의 보안 요구 사항에 따라 다양한 형식과 다양한 활용 방법\(예: 암호화 속성\)을 가질 수 있습니다.

내성:

- 내부 검사는 리소스 서버 또는 잠재적으로 클라이언트가 수신된 액세스 토큰의 활성 상태 및 콘텐츠에 대해 권한 부여 서버에 쿼리하는 방법입니다. 이는 인증 결정이 매우 동적인 경우 및/또는 수신된 액세스 토큰 자체가 자체 포함된 토큰이 아닌 불투명한 참조인 경우에 특히 유용합니다. OAuth 2.0의 자체 검사에 대한 자세한 내용은 \[RFC7662\]에서 확인할 수 있습니다.

갱신 토큰:

- 새로 고침 토큰은 액세스 토큰을 얻는 데 사용되는 자격 증명입니다. 새로 고침 토큰은 권한 부여 서버에 의해 클라이언트에 발급되며 현재 액세스 토큰이 만료될 때 새 액세스 토큰을 얻거나 동일하거나 더 좁은 범위의 추가 액세스 토큰을 얻는 데 사용됩니다\(이러한 액세스 토큰은 수명이 짧고 권한이 더 적을 수 있음\). 리소스 소유자의 승인을 받은 경우\) 새로 고침 토큰 발행은 인증 서버의 재량에 따라 선택 사항입니다. Authorization Server가 Refresh Token을 발급하면 Access Token 발급 시 포함됩니다\(예: 그림 1의 \(B\)단계\).

OAuth 2.0의 새로 고침 토큰은

- 리소스 소유자가 클라이언트에 부여한 권한입니다. 문자열은 일반적으로 클라이언트에게 불투명합니다. 토큰은 인증 정보를 검색하는 데 사용되는 식별자를 나타냅니다. 액세스 토큰과 달리 새로 고침 토큰은 인증 서버에서만 사용하도록 고안되었으며 리소스 서버로 전송되지 않습니다. 이 프레임워크에서 새로 고침 토큰은 사용되는 경우 문자열 대신 바이너리로 인코딩됩니다.

소유 증명 토큰:

- 토큰은 암호화 키에 바인딩될 수 있으며, 이는 토큰에 의해 승인된 요청에 토큰을 바인딩하는 데 사용됩니다. 이러한 토큰을 소유 증명 토큰\(또는 PoP 토큰\)이라고 합니다.

- 여기에 사용된 소유 증명 보안 개념은 AS가 키를 토큰에 바인딩하는 신뢰할 수 있는 제3자 역할을 한다고 가정합니다. 액세스 토큰의 경우 이러한 소위 PoP 키는 클라이언트가 리소스에 액세스할 때 RS에 대한 비밀 소유를 보여주기 위해 사용됩니다. RS는 액세스 토큰을 수신할 때 클라이언트가 사용하는 키가 액세스 토큰에 바인딩된 키와 일치하는지 확인해야 합니다. 본 사양에서 "액세스 토큰"이라는 용어를 사용하는 경우, 별도로 명시하지 않는 한 PoP 액세스 토큰으로 간주됩니다.

- 토큰에 바인딩된 키\(PoP 키\)는 대칭 또는 비대칭 암호화를 사용할 수 있습니다. 암호화 종류의 적절한 선택은 IoT 장치의 제약 조건과 사용 사례의 보안 요구 사항에 따라 달라집니다.

대칭 PoP 키:

- AS는 무작위 대칭 PoP 키를 생성합니다. 키는 자체 검사 호출 시 반환되도록 저장되거나 토큰에 포함됩니다. 후자의 경우 전체 토큰 또는 키만 암호화해야 합니다. PoP 키는 보안 채널로 보호되는 토큰과 함께 클라이언트에 반환됩니다.\(MUST\)

비대칭 PoP 키:

- 비대칭 키 쌍이 클라이언트에 의해 생성되고 공개 키가 AS로 전송됩니다\(클라이언트의 공개 키에 대한 지식이 아직 없는 경우\). 이 경우 PoP 키인 공개 키에 대한 정보는 인트로스펙션 호출 시 반환되도록 저장되거나 토큰 내에 포함되어 클라이언트로 다시 전송됩니다. 토큰을 소비하는 리소스 서버는 토큰의 정보에서 공개 키를 식별할 수 있으며, 이를 통해 클라이언트는 소유 증명에 해당 개인 키를 사용할 수 있습니다.

- 토큰은 암호화 래퍼\(예: COSE \[RFC8152\]\)에 의해 보호되는 간단한 참조 또는 구조화된 정보 개체\(예: CWT \[RFC8392\]\)입니다. PoP 키 선택이 반드시 토큰의 무결성 보호를 위한 특정 자격 증명 유형을 의미하는 것은 아닙니다.

범위 및 권한:

- OAuth 2.0에서 클라이언트는 액세스 토큰 요청에서 \(scope 매개변수를 통해\) 얻으려는 권한 유형을 지정합니다. 그러면 AS는 범위 응답 매개변수를 사용하여 클라이언트에게 발행된 액세스 토큰의 범위를 알릴 수 있습니다. 클라이언트도 제한된 장치일 수 있으므로 이 사양에서는 그러한 요청 및 응답에 대해 CBOR 인코딩\(섹션 5 참조\)의 사용을 정의합니다.

- OAuth 2.0의 범위 매개변수 값은 AS 및 RS에 잘 알려진 의미를 사용하여 공백으로 구분되고 대소문자를 구분하는 문자열 목록으로 표현됩니다. 범위 개념에 대한 자세한 내용은 \[RFC6749\]의 섹션 3.3을 참조하세요.

주장:

- 액세스 토큰에 포함되어 있거나 자체 조사에서 반환된 정보\(클레임\)는 이름-값 쌍의 형태입니다. 예를 들어, 액세스 토큰에는 토큰을 발행한 AS를 식별하는 클레임\(iss 클레임을 통해\)과 액세스 토큰이 어떤 대상을 대상으로 하는지\(aud 클레임을 통해\)가 포함될 수 있습니다. 액세스 토큰의 대상은 특정 리소스, 하나의 리소스 또는 여러 리소스 서버일 수 있습니다. 리소스 소유자 정책은 인증 서버가 액세스 토큰에 입력하는 클레임에 영향을 미칩니다.

- 액세스 토큰의 구조와 인코딩은 배포 전반에 걸쳐 다양하지만 JWT\(JSON 웹 토큰\) \[RFC7519\]를 사용하여 표준화된 형식이 정의되었습니다. 여기서 클레임은 JSON 개체로 인코딩됩니다. \[RFC8392\]에서는 CBOR 웹 토큰\(CWT\)이 CBOR 인코딩을 사용하여 동등한 형식으로 정의되었습니다.

토큰 및 자체 검사 끝점:

- AS는 클라이언트가 액세스 토큰을 요청할 수 있도록 하는 토큰 엔드포인트를 호스팅합니다. 클라이언트는 AS의 토큰 엔드포인트에 POST 요청을 하고 응답으로 액세스 토큰을 받습니다\(요청이 성공한 경우\).

- 일부 배포에서는 수신된 액세스 토큰에 관한 추가 정보를 요청해야 하는 경우 RS와 잠재적으로 클라이언트가 사용할 수 있는 토큰 내부 검사 끝점이 AS에 의해 제공됩니다. 요청 엔터티는 AS의 내부 검사 끝점에 POST 요청을 만들고 응답으로 액세스 토큰에 대한 정보를 받습니다. \(위의 "자기 성찰"을 참조하십시오.\)

---
### **3.2.  CoAP**

CoAP는 HTTP와 유사하지만 제한된 환경을 위해 특별히 설계된 애플리케이션 계층 프로토콜입니다. CoAP는 일반적으로 패킷 재정렬 및 ​​손실이 발생할 수 있는 UDP와 같은 데이터그램 중심 전송을 사용합니다. 보안 솔루션은 후자의 측면을 고려해야 합니다.

```text
   While HTTP uses headers and query strings to convey additional
   information about a request, CoAP encodes such information into
   header parameters called 'options'.
```

CoAP는 블록 단위 전송\[RFC7959\]을 통해 CoAP 페이로드의 애플리케이션 계층 조각화를 지원합니다. 그러나 블록 단위 전송은 CoAP 옵션의 크기 제한을 늘리지 않습니다. 따라서 옵션에 인코딩된 데이터는 작게 유지되어야 합니다.

CoAP에 대한 전송 계층 보안은 DTLS 또는 TLS \[RFC6347\] \[RFC8446\] \[RFC9147\]에 의해 제공될 수 있습니다. CoAP는 전송 계층 보안이 프록시에서 종료되어야 하는 여러 프록시 작업을 정의합니다. 프록시를 통해 엔드투엔드 CoAP 통신을 보호하고 균일한 방식으로 다른 전송을 통한 CoAP 보안을 지원하는 한 가지 접근 방식은 COSE와 같은 객체 기반 보안 메커니즘을 사용하여 애플리케이션 계층에서 보안을 제공하는 것입니다. RFC8152\].

COSE의 애플리케이션 중 하나는 OSCORE \[RFC8613\]로, 이는 엔드투엔드 기밀성, 무결성 및 재생 보호, CoAP 요청과 응답 메시지 간의 보안 바인딩을 제공합니다. OSCORE에서는 CoAP 메시지가 COSE 개체에 래핑되어 CoAP를 사용하여 전송됩니다.

이 프레임워크에서는 제한된 환경에서 HTTP를 대체하여 CoAP를 사용하는 것이 권장됩니다. 통신 보안을 위해 이 프레임워크는 특정 애플리케이션의 요구 사항에 따라 선택이 달라지므로 명시적인 프로토콜 권장 사항을 제시하지 않습니다. DTLS \[RFC6347\] \[RFC9147\] 및 OSCORE \[RFC8613\]이 예로 언급됩니다. 섹션 6.5의 요구 사항을 충족하는 다른 프로토콜도 적용 가능합니다.\(SHOULD\)

---
## **4.  Protocol Interactions**

ACE 프레임워크는 토큰 엔드포인트와 선택적으로 내부 검사 엔드포인트를 사용하는 OAuth 2.0 프로토콜 상호 작용을 기반으로 합니다. 클라이언트는 토큰 엔드포인트를 사용하여 AS로부터 액세스 토큰과 선택적으로 새로 고침 토큰을 얻은 후 RS에 액세스 토큰을 제공하여 보호된 리소스에 대한 액세스 권한을 얻습니다. 대부분의 배포에서 RS는 액세스 토큰을 로컬로 처리할 수 있습니다. 그러나 어떤 경우에는 RS가 새로운 정보를 얻기 위해 내부 검사 엔드포인트를 통해 AS에 이를 제시할 수도 있습니다. 이러한 상호 작용은 그림 1에 나와 있습니다. 다양한 OAuth 개념에 대한 개요가 섹션 3.1에 나와 있습니다.

```text
   +--------+                               +---------------+
   |        |---(A)-- Token Request ------->|               |
   |        |                               | Authorization |
   |        |<--(B)-- Access Token ---------|    Server     |
   |        |    + Access Information       |               |
   |        |    + Refresh Token (optional) +---------------+
   |        |                                      ^ |
   |        |            Introspection Request  (D)| |
   | Client |                         Response     | |(E)
   |        |            (optional exchange)       | |
   |        |                                      | v
   |        |                               +--------------+
   |        |---(C)-- Token + Request ----->|              |
   |        |                               |   Resource   |
   |        |<--(F)-- Protected Resource ---|    Server    |
   |        |                               |              |
   +--------+                               +--------------+

                       Figure 1: Basic Protocol Flow
```

액세스 토큰 요청\(A\):

- 클라이언트는 AS의 토큰 끝점에 액세스 토큰을 요청합니다. 이 프레임워크는 AS가 키를 액세스 토큰에 바인딩하는 PoP 액세스 토큰\(간단한 설명은 섹션 3.1 참조\)의 사용을 가정합니다. 클라이언트는 액세스 토큰의 소유 증명\(예: 대칭/비대칭 암호화 또는 특정 키에 대한 참조\)을 위해 사용하려는 자격 증명에 대한 정보와 획득하려는 권한을 포함할 수 있습니다.

액세스 토큰 응답\(B\):

- 클라이언트의 요청이 성공적으로 확인, 인증 및 권한 부여되면 AS는 액세스 토큰과 선택적으로 새로 고침 토큰을 반환합니다. 특정 부여 유형만 새로 고침 토큰을 지원합니다. AS는 "액세스 정보"라고 하는 추가 매개변수를 반환할 수도 있습니다. OAuth 2.0 및 PoP 액세스 토큰 확장에 의해 정의된 응답 매개변수 외에도 이 프레임워크는 클라이언트에게 RS의 기능\(예: RS가 지원하는 프로필\)을 알리는 데 사용할 수 있는 매개변수를 정의합니다. 이러한 매개변수에 대한 자세한 내용은 섹션 5.8.4에서 확인할 수 있습니다.

자원 요청 \(C\):

- 클라이언트는 RS와 상호 작용하여 보호된 자원에 대한 액세스를 요청하고 액세스 토큰을 제공합니다. 클라이언트와 RS 간에 사용하는 프로토콜은 CoAP에만 국한되지 않습니다. HTTP, HTTP/2 \[RFC9113\], QUIC \[RFC9000\], MQTT \[MQTT5.0\], Bluetooth Low Energy \[BLE\] 등도 실행 가능한 후보입니다.

- 장치 제한 사항 및 선택한 프로토콜에 따라 이 교환은 두 부분으로 분할될 수 있습니다.

- \(1\) 클라이언트는 클라이언트의 후속 자원 요청에 사용될 RS에 인증 정보를 포함하거나 참조하는 액세스 토큰을 보냅니다.

- \(2\) 클라이언트는 AS로부터 얻은 통신 보안 프로토콜과 기타 접근 정보를 이용하여 자원 접근을 요청한다.

- 클라이언트와 RS는 프로파일에 지정된 보안 프로토콜\(\(B\) 단계 참조\)과 액세스 토큰 또는 액세스 정보에서 얻은 키를 사용하여 상호 인증합니다. RS는 토큰이 무결성으로 보호되고 AS에서 생성되었는지 확인합니다. 그런 다음 액세스 토큰에 포함된 클레임을 리소스 요청과 비교합니다. RS가 온라인인 경우 HTTP 또는 CoAP를 통해 토큰 내부 검사\(메시지 \(D\) 및 \(E\) 참조\)를 사용하여 유효성 검사를 AS로 전달할 수 있습니다.

토큰 자체 검사 요청\(D\):

- 리소스 서버는 해당 AS의 내부 검사 엔드포인트에 대한 요청에 액세스 토큰을 포함시켜 이를 내부 검사하도록 구성될 수 있습니다. CoAP에 대한 토큰 내부 검사는 섹션 5.9에 정의되어 있으며 HTTP에 대해서는 \[RFC7662\]에 정의되어 있습니다.

- 토큰 자체 검사는 선택적 단계이며 토큰이 자체 포함되어 있고 리소스 서버가 자체적으로 토큰 유효성 검사를 수행할 준비가 되어 있는 경우 생략할 수 있습니다.

토큰 자체 검사 응답\(E\):

- AS는 토큰의 유효성을 검사하고 이와 관련된 범위, 대상, 유효성 등과 같은 최신 매개변수를 RS로 다시 반환합니다. 그런 다음 RS는 수신된 매개변수를 사용하여 요청을 수락하거나 거부하는 요청을 처리합니다.

보호된 리소스\(F\):

- 클라이언트의 요청이 승인되면 RS는 요청을 이행하고 적절한 응답 코드와 함께 응답을 반환합니다. RS는 사용된 통신 보안 프로토콜에 따라 응답을 보호하기 위해 동적으로 설정된 키를 사용합니다.

OAuth 2.0 프레임워크는 OAuth 2.0에 대한 확장\(예: \[RFC7521\] 및 \[RFC8628\]\)을 통해 더욱 확장된 승인 유형을 통해 여러 "프로토콜 흐름"을 정의합니다. 가장 효과적인 부여 유형은 사용 시나리오에 따라 다릅니다. \[RFC7744\]는 다양한 IoT 사용 사례를 설명하지만 이러한 시나리오의 대부분을 다루는 두 가지 부여 유형, 즉 인증 코드 부여\(\[RFC6749\]의 섹션 4.1에 설명됨\)와 클라이언트 자격 증명 부여\(\[RFC6749\]의 섹션 4.4에 설명됨\)가 있습니다. \[RFC6749\]\). 인증 코드 부여는 스마트 홈 환경의 일반적인 시나리오인 IoT 장치에 대한 액세스를 요청하는 스마트폰 및 태블릿에서 실행되는 앱에 사용하기에 적합합니다. 설정 단계\). \[RFC8252\]에 설명된 기본 앱 지침이 이 사용 사례에 적용 가능합니다. 클라이언트 자격 증명 부여는 OAuth 클라이언트 자체가 제한된 IoT 장치에 사용하기에 적합합니다. 이러한 경우 리소스 소유자는 승인 서버를 통해 클라이언트에 대한 액세스 권한을 사전에 설정했으며 이는 종종 커미셔닝 도구를 사용하여 수행됩니다.

클라이언트에게 보호된 리소스에 대한 액세스 권한을 부여하기 위한 리소스 소유자의 동의는 기존 OAuth 흐름에서와 같이 동적으로 제공될 수 있거나 리소스 소유자가 AS에서 권한 부여 정책으로 사전 구성할 수 있습니다. 토큰 요청이 도착합니다. 리소스 소유자와 요청 당사자\(예: 클라이언트 소유자\)는 그림 1에 표시되지 않습니다.

이 프레임워크는 클라이언트, AS 및 RS와 같은 ACE 엔터티 간의 다양한 통신 보안 메커니즘을 지원합니다. 클라이언트가 이 문서 범위 외부에서 정의된 메커니즘을 사용하여 AS에 등록\(등록 또는 온보딩이라고도 함\)되었다고 가정합니다. 실제로 공장 기반 프로비저닝이나 커미셔닝 도구 사용 등 온보딩을 위한 다양한 기술이 사용되었습니다. 온보딩 기술에 관계없이 이 프로비저닝 절차는 클라이언트와 AS가 자격 증명과 구성 매개변수를 교환한다는 것을 의미합니다. 이러한 자격 증명은 서로를 상호 인증하고 클라이언트와 AS 간에 교환되는 메시지를 보호하는 데 사용됩니다.

또한 클라이언트가 AS에 등록된 것과 잠재적으로 유사한 방식으로 RS가 AS에 등록되었다고 가정합니다. AS와 RS 사이에 설정된 키 자료를 통해 AS는 액세스 토큰에 암호화 보호를 적용하여 콘텐츠를 수정할 수 없도록 하고 필요한 경우 콘텐츠의 기밀성을 보호할 수 있습니다. 통신 보안 프로토콜을 통한 기밀 보호 외에 액세스 토큰 콘텐츠의 기밀 보호가 제공됩니다.

C와 RS 간의 통신 보안을 설정하는 데 필요한 키 자료는 이 문서에 설명된 프로토콜의 일부로 동적으로 설정됩니다.

프로토콜 시작 부분에는 클라이언트가 리소스 서버와 이 서버가 호스팅하는 리소스를 검색하는 선택적 검색 단계가 있습니다. 이 단계에서 클라이언트는 보호된 리소스에 액세스하는 데 필요한 권한을 결정할 수도 있습니다. 일반적인 절차는 섹션 5.1에 설명되어 있습니다. 프로필은 검색을 위한 다른 절차를 정의할 수 있습니다.\(MAY\)

예를 들어 Bluetooth Low Energy에서는 기본 서비스에 대한 정보를 포함하여 주변 장치에서 광고를 방송합니다. CoAP에서는 두 번째 예로 \[RFC6690\]에 설명된 대로 클라이언트가 "/.well-known/core"에 요청하여 사용 가능한 리소스에 대한 정보를 표준화된 형식으로 반환받을 수 있습니다.

---
## **5.  Framework**

다음 섹션에서는 ACE 프레임워크를 구성하는 제한된 환경을 위한 OAuth 2.0의 프로파일링 및 확장에 대해 자세히 설명합니다.

자격 증명 프로비저닝

- 제한된 환경에서는 클라이언트와 RS가 공통 키 인프라의 일부라고 가정할 수 없습니다. 따라서 AS는 클라이언트와 RS 간의 상호 인증을 허용하기 위해 자격 증명 및 관련 정보를 제공합니다. 그러면 클라이언트와 RS 사이의 결과 보안 연결을 사용하여 이러한 자격 증명을 클라이언트가 사용하는 액세스 토큰에 바인딩할 수도 있습니다.

소유 증명

- ACE 프레임워크는 기본적으로 액세스 토큰에 대한 소유 증명을 구현합니다. 즉, 토큰 소유자가 토큰에 바인딩된 키의 소유자임을 증명할 수 있습니다. 바인딩은 소유 증명에 사용되는 키를 나타내는 cnf\(확인\) 클레임 \[RFC8747\]에 의해 제공됩니다. 클라이언트가 추가 액세스 권한을 얻기 위해 새 액세스 토큰을 제출해야 하는 경우 AS가 이 토큰을 이전 토큰과 동일한 키에 바인딩하도록 요청할 수 있습니다.

에이스 프로필

- 클라이언트 또는 RS는 지원하는 인코딩이나 프로토콜이 제한될 수 있습니다. 다양한 배포 설정을 지원하기 위해 클라이언트와 RS 간의 특정 상호 작용이 ACE 프로필에 정의됩니다. ACE 프레임워크에서 AS는 클라이언트와 RS 간의 호환 가능한 프로필 선택 일치를 관리해야 합니다. AS는 토큰 응답의 ace\_profile 매개변수를 사용하여 선택한 프로필을 클라이언트에 알립니다.

OAuth 2.0에서는 리소스에 액세스할 때 클라이언트와 RS 간, 내부 검사가 사용되는 경우 AS와 RS 간에 액세스 토큰을 요청할 때 AS와 클라이언트 간 통신을 보호하기 위해 TLS를 사용해야 합니다. 제한된 설정에서는 TLS가 항상 가능하거나 바람직하지 않습니다. 그럼에도 불구하고 위에 명명된 통신은 암호화되고 무결성이 보호되며 메시지 재생으로부터 보호되어야 합니다. 또한 통신하는 엔드포인트가 상호 인증을 수행하는 것도 필수입니다. 또한 응답 수신자가 응답이 실제로 특정 요청에 속한다는 것을 확신할 수 있다는 점에서 응답이 요청에 바인딩되어 있음을 보장해야 합니다\(MUST\). 이러한 보안 통신을 설정하려면 보호되지 않은 일부 메시지를 먼저 교환해야 할 수도 있습니다\(예: 클라이언트에서 RS로 토큰 전송\).\(MUST, MUST, MUST\)

프로필은 위에 필요한 기능을 제공하는 클라이언트와 RS 간의 통신 보안 프로토콜을 지정해야 합니다. 프로필은 위에 필요한 기능을 제공하는 클라이언트와 AS 간에 사용하도록 권장되는 통신 보안 프로토콜을 지정해야 합니다. 프로파일은 자체 조사를 위해 위에 필요한 기능을 제공하는 RS와 AS 간에 사용하도록 권장되는 통신 보안 프로토콜을 지정해야 합니다. 이러한 권장 사항은 C와 AS 간 또는 RS와 AS 간 통신이 위의 보안 요구 사항을 준수하는 다른 보안 프로토콜로 보호되는 경우 새 프로필을 정의할 필요 없이 다양한 구현 간의 상호 운용성을 가능하게 합니다.\(MUST, MUST, MUST\)

OAuth 2.0에서는 AS의 토큰 및 내부 검사 끝점과의 통신은 HTTP를 통해 이루어지는 것으로 가정되며 Uri 쿼리 매개 변수를 사용할 수 있습니다. 이 프레임워크의 프로필이 CoAP를 대신 사용하는 경우 Uri 쿼리 매개변수 대신 다음 대안을 사용해야 합니다. 발신자\(클라이언트 또는 RS\)는 요청 매개변수를 CBOR 맵으로 인코딩하고 해당 맵을 페이로드로 제출합니다. POST 요청. 다양한 OAuth 2.0 매개변수에 대한 CBOR 인코딩이 이 문서에 지정되어 있습니다. 프로필이 CoAP와 함께 다른 OAuth 2.0 매개변수를 사용해야 하는 경우 해당 CBOR 인코딩을 지정해야 합니다.\(MUST, MUST\)

가장 바깥쪽 인코딩 계층에서 프로토콜 메시지 매개변수의 CBOR 인코딩을 사용하는 프로필은 Content-Format "application/ace+cbor"를 사용해야 합니다. CoAP가 통신에 사용되는 경우 Content-Format은 ID: 19로 축약되어야 합니다\(섹션 8.16 참조\).\(MUST, MUST\)

OAuth 2.0 AS는 클라이언트와 RS에 대한 응답 페이로드에 JSON 구조를 사용합니다. CoAP를 사용하는 경우 JSON 대신 CBOR \[RFC8949\]를 사용해야 합니다. 프로필에 따라 CBOR 페이로드는 CBOR이 아닌 암호화 래퍼에 포함될 수 있습니다.\(MUST, MAY\)

---
### **5.1.  Discovering Authorization Servers**

C는 액세스 토큰을 요청할 위치를 결정하기 위해 RS를 담당하는 AS를 검색해야 합니다. 그렇게 하기 위해, C는 1\) 토큰 요청 메시지가 전송되어야 하는 AS URI를 찾아야 하고, 2\) 이 URI를 가진 AS가 이 RS에 대한 액세스 토큰을 제공할 권한이 있는지 검증해야 합니다.\(MUST\)

```text
   In order to determine the AS URI, the C MAY send an initial
   Unauthorized Resource Request message to the RS.  The RS then denies
   the request and sends the address of its AS back to the C (see
   Section 5.2).  How the C validates the AS authorization is not in
   scope for this document.  The C may, for example, ask its owner if
   this AS is authorized for this RS.  The C may also use a mechanism
   that addresses both problems at once (e.g., by querying a dedicated
   secure service provided by the client owner) .
```

---
### **5.2.  Unauthorized Resource Request Message**

무단 자원 요청\(Unauthorized Resource Request\) 메시지는 클라이언트에게 승인이 부여되지 않은 RS가 호스팅하는 자원에 대한 요청입니다. RS는 다음 중 하나라도 해당되는 경우 보호된 리소스에 대한 모든 요청을 승인되지 않은 리소스 요청 메시지로 처리해야 합니다.\(MUST\)

\* 보안되지 않은 채널에서 요청이 수신되었습니다.

\* RS에는 해당 리소스에 대해 요청된 작업과 관련하여 요청 발신자에 대한 유효한 액세스 토큰이 없습니다.

\* RS에는 요청 발신자에 대한 유효한 액세스 토큰이 있지만 해당 토큰은 요청된 리소스에 대한 요청된 작업을 승인하지 않습니다.

참고: 이러한 조건은 액세스가 허용되고 C와 RS 사이에 보안 채널이 설정된 후 RS가 요청을 자동으로 처리할 수 있도록 보장합니다. 보호되는 리소스에 대한 권한을 부여하는 프로세스의 일부인 authz-info 엔드포인트는 그 자체로 보호되는 리소스가 아니므로 위에 지정된 대로 보호되어서는 안 됩니다\(섹션 5.10.1 참조\).\(MUST NOT\)

무단 리소스 요청 메시지는 "unauthorized\_client" 오류 응답으로 거부되어야 합니다. 이 응답에서 리소스 서버는 섹션 5.3에 설명된 대로 클라이언트가 RS의 AS로부터 액세스 토큰을 요청할 수 있도록 적절한 AS 요청 생성 힌트를 제공해야 합니다.\(MUST, SHOULD\)

RS에 의한 모든 클라이언트 요청\(승인되지 않은 요청 포함\) 처리는 섹션 5.10.2에 설명되어 있습니다.

---
### **5.3.  AS Request Creation Hints**

AS 요청 생성 힌트는 무단 자원 요청 메시지\(섹션 5.2 참조\)에 대한 응답으로 RS에 의해 전송되어 무단 자원 요청 메시지의 발신자가 유효한 액세스 토큰을 획득하도록 돕습니다. AS 요청 생성 힌트는 RS에 대한 적절한 AS를 식별하는 절대 URI\(\[RFC3986\]의 섹션 4.3 참조\)를 지정하는 OPTIONAL 요소 AS가 있는 CBOR 또는 JSON 맵입니다.\(MAY\)

메시지에는 다음과 같은 선택적 매개변수도 포함될 수 있습니다.\(MAY\)

\* 청중 요소에는 RS가 제안한 대로 클라이언트가 AS에서 요청해야 하는 식별자가 포함되어 있습니다. 이 매개변수를 사용하면 AS에 대한 액세스 토큰 요청에 포함될 때 AS는 액세스 토큰의 사용을 특정 RS로 제한할 수 있습니다. 이 매개변수에 대한 설명은 섹션 6.9를 참조하세요.

\* Kid\(키 식별자\) 요소에는 클라이언트와 RS 간의 기존 보안 연결에 사용되는 키의 키 식별자가 포함됩니다. RS는 보안 연결을 다시 설정하지 않아도 되도록 클라이언트가 이 키에 바인딩된 액세스 토큰을 요청할 것으로 예상합니다.

\* connonce 요소에는 client-nonce가 포함됩니다. 섹션 5.3.1을 참조하십시오.

\* 범위 요소에는 클라이언트가 AS를 향해 요청해야 하는 제안된 범위가 포함됩니다.

표 1은 AS 요청 생성 힌트의 일부일 수 있는 매개변수를 요약합니다.

```text
               +==========+==========+=====================+
               | Name     | CBOR Key | Value Type          |
               +==========+==========+=====================+
               | AS       | 1        | text string         |
               +----------+----------+---------------------+
               | kid      | 2        | byte string         |
               +----------+----------+---------------------+
               | audience | 5        | text string         |
               +----------+----------+---------------------+
               | scope    | 9        | text or byte string |
               +----------+----------+---------------------+
               | cnonce   | 39       | byte string         |
               +----------+----------+---------------------+
```

- 표 1: AS 요청 생성 힌트

AS 매개변수의 스키마 부분은 클라이언트와 AS 간에 사용되는 보안 프로토콜에 맞게 조정되어야 할 수도 있습니다. 따라서 예제 AS 값 "coap://as.example.com/token"을 "coaps://as.example.com/token"으로 변환해야 할 수도 있습니다. 클라이언트는 AS와 통신하는 방식에 따라 자체적으로 올바른 스키마 부분을 결정할 수 있다고 가정합니다.

그림 2는 진단 표기법을 사용한 AS 요청 생성 힌트 페이로드의 예를 보여줍니다.

```text
       4.01 Unauthorized
       Content-Format: application/ace+cbor
       Payload :
       {
        / AS / 1 : "coaps://as.example.com/token",
        / audience / 5 : "coaps://rs.example.com",
        / scope / 9 : "rTempC",
        / cnonce / 39 : h'e0a156bb3f'
       }
```

- 그림 2: AS 요청 생성 힌트 페이로드 예

위의 예에서 응답 매개변수 AS는 이 메시지의 수신자를 URI "coaps://as.example.com/token"으로 지정하여 액세스 토큰을 요청합니다. 이 응답을 보내는 RS는 AS의 클록과 동기화되지 않은 내부 클록을 사용합니다. 따라서 수신한 액세스 토큰의 만료 시간을 안정적으로 확인할 수 없습니다. 그럼에도 불구하고 특정 수준의 액세스 토큰 최신성을 보장하기 위해 RS는 응답에 connonce 매개변수\(섹션 5.3.1 참조\)를 포함했습니다. \(이 예에서는 connonce 매개변수의 16진수 시퀀스가 ​​CBOR 기반 표기법으로 인코딩됩니다.\)

그림 3은 그림 2에 표시된 메시지 페이로드의 바이너리 인코딩의 필수 사용을 보여줍니다.

```text
   a4                                   # map(4)
      01                                # unsigned(1) (=AS)
      78 1c                             # text(28)
         636f6170733a2f2f61732e657861
         6d706c652e636f6d2f746f6b656e   # "coaps://as.example.com/token"
      05                                # unsigned(5) (=audience)
      76                                # text(22)
         636f6170733a2f2f72732e657861
         6d706c652e636f6d               # "coaps://rs.example.com"
      09                                # unsigned(9) (=scope)
      66                                # text(6)
         7254656d7043                   # "rTempC"
      18 27                             # unsigned(39) (=cnonce)
      45                                # bytes(5)
         e0a156bb3f                     #

        Figure 3: AS Request Creation Hints Example Encoded in CBOR
```

---
#### **5.3.1.  The Client-Nonce Parameter**

RS가 시계를 AS와 동기화하지 않으면 만료되었거나 손상된 오래된 액세스 토큰을 수락하도록 속일 수 있습니다. 이 경우 일정 수준의 토큰 최신성을 보장하기 위해 RS는 cnonce\(client-nonce\) 매개변수를 사용할 수 있습니다. 이 매개변수에 대한 처리 요구 사항은 다음과 같습니다.

\* AS 요청 생성 힌트 메시지에서 connonce 매개변수를 전송하는 RS는 주어진 connonce가 최신인지 확인하기 위한 정보를 저장해야 합니다. 이것이 내부적으로 구현되는 방법은 이 사양의 범위를 벗어납니다. client-nonce의 만료는 클라이언트가 AS 요청 생성 힌트를 받은 후 액세스 토큰을 얻는 데 걸리는 대략적인 시간을 기반으로 해야 하며 예상치 못한 지연을 어느 정도 허용해야 합니다.\(MUST\)

\* AS 요청 생성 힌트 메시지에서 connonce 매개변수를 수신하는 클라이언트는 섹션 5.8.4.4의 connonce 매개변수를 사용하여 AS에서 액세스 토큰을 요청할 때 매개변수에 이를 포함해야 합니다.\(MUST\)

\* AS가 connonce 매개변수가 포함된 액세스 토큰 요청을 승인하는 경우 섹션 5.10에 지정된 connonce 청구를 사용하여 액세스 토큰에 이 값을 포함해야 합니다.\(MUST\)

\* client-nonce 메커니즘을 사용하고 액세스 토큰을 수신하는 RS는 위의 첫 번째 단계에서 저장된 정보에 따라 새로운 client-nonce 값을 사용하여 이 토큰에 connonce 클레임이 포함되어 있는지 확인해야 합니다. Cnonce 청구가 존재하지 않거나 Cnonce 청구 값이 신선하지 않은 경우 RS는 액세스 토큰을 폐기해야 합니다. 이것이 authz-info 끝점과의 상호 작용인 경우 RS는 CoAP 코드 4.01\(Unauthorized\)에 해당하는 응답 코드를 사용하여 오류 메시지로 응답해야 합니다.\(MUST, MUST, MUST\)

---
### **5.4.  Authorization Grants**

액세스 토큰을 요청하기 위해 클라이언트는 리소스 소유자로부터 권한을 얻거나 해당 클라이언트 자격 증명을 권한 부여로 사용합니다. 승인은 승인 부여의 형태로 표현됩니다.

OAuth 프레임워크 \[RFC6749\]는 네 가지 부여 유형을 정의합니다. 부여 유형은 리소스 소유자를 대신하여 부여된 그룹\(비밀번호, 인증 코드, 암시적\)과 클라이언트에 대한 그룹\(클라이언트 자격 증명\)의 두 그룹으로 나눌 수 있습니다. \[RFC7521\]에 정의된 주장 기반 권한 부여와 같은 추가 부여 유형이 나중에 추가되었습니다.

부여 유형은 사용 사례에 따라 선택됩니다. 클라이언트가 리소스 소유자를 대신하여 작업하는 경우 인증 코드 부여가 권장됩니다. 클라이언트가 리소스 소유자를 대신하여 작동하지만 디스플레이가 없거나 상호 작용 가능성이 매우 제한적인 경우 \[RFC8628\]에 정의된 장치 코드 부여를 사용하는 것이 좋습니다. 클라이언트가 자율적으로 작동하는 경우 클라이언트 자격 증명 부여가 권장됩니다.

다양한 부여 유형에 대한 자세한 내용은 \[RFC6749\]의 섹션 1.3을 참조하세요. OAuth 2.0 프레임워크는 추가 승인 유형을 정의하기 위한 확장 메커니즘을 제공하므로 이 프레임워크의 프로필은 필요한 경우 추가 승인 유형을 정의할 수 있습니다.\(MAY\)

---
### **5.5.  Client Credentials**

토큰 엔드포인트에서 액세스 토큰을 요청할 때 권한 부여 유형과 관계없이 클라이언트 인증이 필수입니다. 클라이언트 자격 증명 부여 유형의 경우 인증과 부여가 일치합니다.

클라이언트 등록 및 클라이언트 자격 증명을 클라이언트에 프로비저닝하는 것은 이 사양의 범위를 벗어납니다.

OAuth 프레임워크는 client\_id 및 client\_secret 값을 구성하는 \[RFC6749\]의 섹션 2.3.1에서 하나의 클라이언트 자격 증명 유형을 정의합니다. \[OAUTH-RPCC\]는 원시 공개 키와 사전 공유 키를 클라이언트 자격 증명 유형에 추가합니다. 이 프레임워크의 프로필은 클라이언트 인증서를 사용하여 추가 클라이언트 자격 증명 유형으로 이를 확장할 수 있습니다.\(MAY\)

---
### **5.6.  AS Authentication**

클라이언트 자격 증명 부여는 기본적으로 클라이언트가 연결하는 AS를 인증하지 않습니다. 클래식 OAuth에서는 AS가 TLS 서버 인증서로 인증됩니다.

이 프레임워크의 프로필은 클라이언트가 AS를 인증하는 방법과 통신 보안이 구현되는 방법을 지정해야 합니다. 기본적으로 OAuth 2.0에 정의된 대로 서버 측 TLS 인증서가 필요합니다.\(MUST\)

---
### **5.7.  The Authorization Endpoint**

OAuth 2.0 권한 부여 끝점은 리소스 소유자와 상호 작용하고 특정 권한 부여 흐름에서 권한 부여를 얻는 데 사용됩니다. ACE-OAuth 프레임워크의 기본 사용 사례는 인증 흐름에 리소스 소유자가 관여하지 않는 기계 간 상호 작용을 위한 것입니다. 따라서 이 끝점은 여기서 범위를 벗어납니다. 향후 프로필은 이 끝점에 대한 제한된 적응 메커니즘도 정의할 수 있습니다. 제한된 리소스 서버와 상호 작용하는 비제약 클라이언트는 \[RFC6749\] 섹션 3.1의 사양과 \[RFC6819\] 섹션 4.2에 제안된 공격 대책을 사용할 수 있습니다.

---
### **5.8.  The Token Endpoint**

표준 OAuth 2.0에서 AS는 액세스 토큰 요청을 제출하기 위한 토큰 엔드포인트를 제공합니다. 이 프레임워크는 토큰 끝점의 기능을 확장하여 AS에 클라이언트와 RS가 공유 키를 설정하거나 공개 키를 교환하는 데 도움을 줄 수 있는 가능성을 제공합니다. 또한 이 프레임워크는 JSON 대신 CBOR을 사용하여 인코딩을 정의합니다.

엔드포인트는 기존 OAuth 또는 기타 전송과 마찬가지로 HTTPS를 통해 노출될 수도 있습니다. 프로필은 아래에 설명된 필드와 이러한 전송 간의 매핑 세부 정보를 정의해야 합니다. JSON이 포함된 HTTPS를 사용하는 경우 OAuth 2.0 사양 \[RFC6749\]의 섹션 4.1.3 및 4.1.4의 의미를 따라야 합니다\(아래 설명된 추가 사항 포함\). CBOR이 페이로드 형식으로 사용되는 경우 이 섹션에 설명된 의미를 따라야 합니다.\(MUST, MUST, MUST\)

AS가 토큰을 발행할 수 있으려면 클라이언트가 인증되어야 하고 요청된 범위에 대해 유효한 승인을 제시해야 합니다. 이 프레임워크의 프로필은 AS가 클라이언트를 인증하는 방법과 클라이언트와 AS 간의 통신이 보호되는 방법을 지정하여 섹션 5에 지정된 요구 사항을 충족해야 합니다.\(MUST, MUST\)

URL 경로에 있는 이 끝점의 기본 이름은 '/token'이어야 합니다. 그러나 구현에서는 이 이름을 사용할 필요가 없으며 대신 자체 이름을 정의할 수 있습니다.\(SHOULD\)

---
#### **5.8.1.  Client-to-AS Request**

클라이언트는 AS의 토큰 끝점에 POST 요청을 보냅니다. 프로필은 통신이 보호되는 방법을 지정해야 합니다. 요청 내용은 승인 유형에 따라 OAuth 2.0 사양 \[RFC6749\] 섹션 4의 관련 하위 섹션에 지정된 매개변수로 구성되며 다음과 같은 예외 및 추가 사항이 있습니다.\(MUST\)

\* grant\_type 매개변수는 이 프레임워크의 맥락에서 선택사항입니다\(\[RFC6749\]의 필수와 반대\). 해당 매개변수가 누락된 경우 기본값 "client\_credentials"가 암시됩니다.\(MUST\)

\* \[RFC8693\]의 대상 매개변수는 특정 대상에 바인딩된 액세스 토큰을 요청하는 선택 사항입니다.\(MAY\)

\* RS가 AS 요청 생성 힌트 메시지\(섹션 5.3\)에서 client-nonce를 제공한 경우 섹션 5.8.4.4에 정의된 connonce 매개변수가 필수입니다.\(MUST\)

\* 범위 매개변수는 \[RFC6749\]의 섹션 3.3에 지정된 문자열 인코딩 대신 또는 복잡한 범위의 압축 인코딩을 허용하기 위해 바이트 문자열로 인코딩될 수 있습니다. 이러한 이진 인코딩의 구문은 여기에서 명시적으로 지정되지 않으며 프로필이나 응용 프로그램에 맡겨집니다. 특히 바이너리로 인코딩된 범위는 범위 토큰을 구분하기 위해 공백 문자 '0x20'을 반드시 사용할 필요는 없습니다.\(MAY\)

\* 클라이언트는 빈\(널 값\) ace\_profile 매개변수를 보내 AS가 응답에 ace\_profile 매개변수를 포함하길 원함을 나타낼 수 있습니다. 섹션 5.8.4.3을 참조하십시오.

\* 클라이언트는 토큰 엔드포인트에 대한 액세스 토큰 요청에서 \[RFC9201\]의 매개변수를 사용할 수 있어야 하며, AS는 이러한 추가 매개변수를 처리할 수 있어야 합니다.\(MUST\)

기본 동작은 AS가 클라이언트에 대한 대칭 소유 증명 키를 생성하는 것입니다. 비대칭 키 쌍을 사용하거나 RS로 이전에 설정된 키를 재사용하려면 클라이언트가 \[RFC9201\]의 req\_cnf 매개변수를 사용해야 합니다.

CoAP가 사용되는 경우 이러한 매개변수는 CBOR 맵에 제공되어야 합니다\(표 5 참조\).\(MUST\)

HTTP가 전송으로 사용되면 클라이언트는 토큰 끝점에 요청을 보냅니다. 매개변수는 \[RFC6749\]의 부록 B에 정의된 대로 인코딩되어야 합니다.\(MUST\)

다음 예에서는 소유 증명 토큰에 대한 다양한 유형의 요청을 보여줍니다.

그림 4는 진단 표기법을 사용하여 대칭 소유 증명 키가 있는 토큰에 대한 요청을 보여줍니다.

```text
   Header: POST (Code=0.02)
   Uri-Host: "as.example.com"
   Uri-Path: "token"
   Content-Format: application/ace+cbor
   Payload:
   {
     / client_id / 24 : "myclient",
     / audience /  5  : "tempSensor4711"
   }

          Figure 4: Example Request for an Access Token Bound to a
                               Symmetric Key
```

그림 5는 비대칭 소유 증명 키가 있는 토큰에 대한 요청을 보여줍니다. 이 예에서는 OSCORE \[RFC8613\]이 객체 보안을 제공하는 데 사용되었습니다. 따라서 Content-Format은 "application/ace+cbor" 유형 콘텐츠를 래핑하는 "application/oscore"입니다. OSCORE 옵션에는 독자의 편의를 위해 괄호 안에 디코딩된 해석이 추가되어 있습니다. 또한 이 예에서 청중은 클라이언트와 AS 모두에 의해 암시적으로 알려집니다. 또한 이 예제에서는 \[RFC9201\]의 req\_cnf 매개변수를 사용합니다.

헤더: POST\(코드=0.02\) Uri-호스트: "as.example.com" Uri-경로: "token" OSCORE: 0x09, 0x05, 0x44, 0x6C \(h=0, k=1, n=001, 부분 IV= 0x05, kid=\[0x44, 0x6C\]\) Content-Format: application/oscore 페이로드: 0x44025d1/ ... \(간결함을 위해 전체 페이로드 생략\) ... /68b3825e

```text
   Decrypted payload:
   {
     / client_id / 24 : "myclient",
     / req_cnf / 4 : {
       / COSE_Key / 1 : {
         / kty /  1 : 2 / EC2 /,
         / kid /  2 : h'11',
         / crv / -1 : 1 / P-256 /,
         / x /   -2 : b64'usWxHK2PmfnHKwXPS54m0kTcGJ90UiglWiGahtagnv8',
         / y /   -3 : b64'IBOL+C3BttVivg+lSreASjpkttcsz+1rb7btKLv8EX4'
       }
     }
   }
```

- 그림 5: 비대칭 키에 바인딩된 토큰 요청 예시

그림 6은 이전에 전달된 소유 증명 키가 \[RFC9201\]의 req\_cnf 매개변수를 사용해서만 참조되는 토큰에 대한 요청을 보여줍니다.

```text
   Header: POST (Code=0.02)
   Uri-Host: "as.example.com"
   Uri-Path: "token"
   Content-Format: application/ace+cbor
   Payload:
   {
     / client_id / 24 : "myclient",
     / audience /   5 : "valve424",
     / scope /      9 : "read",
     / req_cnf /    4 : {
        / kid /        3 : b64'6kg0dXJM13U'
     }
   }

        Figure 6: Example Request for an Access Token Bound to a Key
                                 Reference
```

새로 고침 토큰은 일반적으로 요청 클라이언트의 소유 증명 키만큼 안전하게 저장되지 않습니다. 소유 증명 기반 새로 고침 토큰 요청은 토큰 요청에서 다른 소유 증명 키나 다른 대상을 요청해서는 안 됩니다. 새로 고침 토큰 요청은 초기 토큰 요청에서 발급된 액세스 토큰과 동일한 소유 증명 키 및 동일한 대상에 바인딩된 액세스 토큰을 요청하는 데에만 사용할 수 있습니다.\(MUST NOT\)

---
#### **5.8.2.  AS-to-Client Response**

AS에 의해 액세스 토큰 요청이 성공적으로 확인되었고 클라이언트가 액세스 토큰 요청에 해당하는 액세스 토큰을 얻을 수 있는 권한이 부여된 경우 AS는 CoAP 응답 코드 2.01\(생성됨\)에 해당하는 응답 코드가 포함된 응답을 보냅니다. 클라이언트 요청이 유효하지 않거나 승인되지 않은 경우 AS는 섹션 5.8.3에 설명된 대로 오류 응답을 반환합니다.

AS는 성공적인 응답을 발행할 때 사용할 토큰 유형과 프로필을 결정합니다. AS는 클라이언트와 RS의 기능에 대한 사전 지식을 가지고 있다고 가정합니다\(부록 D 참조\). 예를 들어 이러한 사전 지식은 동적 클라이언트 등록 프로토콜 교환 \[RFC7591\]을 사용하여 설정될 수 있습니다. 클라이언트가 \[RFC9201\]의 req\_cnf 매개변수를 사용하여 특정 소유 증명 키를 요청한 경우 클라이언트가 요청한 키 유형의 사용을 지원해야 하므로 AS가 선택하는 프로필에도 영향을 미칠 수 있습니다.

성공적인 응답의 내용은 액세스 정보입니다. CoAP를 사용할 때 페이로드는 CBOR 맵으로 인코딩되어야 합니다. HTTP를 사용할 때 인코딩은 \[RFC6749\]의 섹션 5.1에 지정된 대로 JSON 맵입니다. 두 경우 모두 \[RFC6749\]의 섹션 5.1에 지정된 매개변수가 다음 추가 및 변경 사항과 함께 사용됩니다.\(MUST\)

ace\_profile:

- 요청에 빈 ace\_profile 매개변수가 포함되지 않은 경우 이 매개변수는 선택사항이며, 이 경우 필수입니다. 이는 클라이언트가 RS를 향해 사용해야 하는 프로필을 나타냅니다. 이 매개변수의 형식에 대해서는 섹션 5.8.4.3을 참조하십시오. 이 매개변수가 없으면 AS는 클라이언트가 RS에 사용할 프로필을 암시적으로 알고 있다고 가정합니다.\(MAY, MUST\)

토큰 유형:

- 이 매개변수는 \[RFC6749\]의 필수\(REQUIRED\)와 달리 선택사항\(OPTIONAL\)입니다. 기본적으로 이 프레임워크의 구현은 token\_type이 "PoP"라고 가정해야 합니다\(SHOULD\). 특정 사용 사례에서 다른 token\_type\(예: "Bearer"\)을 사용해야 하는 경우 이 매개변수가 필수입니다.\(MUST, SHOULD, MUST\)

또한 \[RFC9201\]은 AS가 토큰 끝점에 대한 요청에 응답할 때 사용할 수 있어야 하는 추가 매개변수를 정의합니다.\(MUST\)

표 2에는 현재 액세스 정보의 일부가 될 수 있는 매개변수가 요약되어 있습니다. 향후 확장에서는 추가 매개변수를 정의할 수 있습니다.

```text
                   +===================+==============+
                   | Parameter name    | Specified in |
                   +===================+==============+
                   | access_token      | [RFC6749]    |
                   +-------------------+--------------+
                   | token_type        | [RFC6749]    |
                   +-------------------+--------------+
                   | expires_in        | [RFC6749]    |
                   +-------------------+--------------+
                   | refresh_token     | [RFC6749]    |
                   +-------------------+--------------+
                   | scope             | [RFC6749]    |
                   +-------------------+--------------+
                   | state             | [RFC6749]    |
                   +-------------------+--------------+
                   | error             | [RFC6749]    |
                   +-------------------+--------------+
                   | error_description | [RFC6749]    |
                   +-------------------+--------------+
                   | error_uri         | [RFC6749]    |
                   +-------------------+--------------+
                   | ace_profile       | RFC 9200     |
                   +-------------------+--------------+
                   | cnf               | [RFC9201]    |
                   +-------------------+--------------+
                   | rs_cnf            | [RFC9201]    |
                   +-------------------+--------------+

                       Table 2: Access Information
                                Parameters
```

그림 7은 \[RFC9201\]에 정의된 대칭 소유 증명 키와 함께 토큰 및 cnf 매개변수가 포함된 응답을 보여줍니다. 키 식별자 kid는 키 인덱싱 및 검색을 단순화하는 데에만 사용되며 클라이언트나 RS의 도메인에서 고유하다고 가정해서는 안 됩니다.

```text
   Header: Created (Code=2.01)
   Content-Format: application/ace+cbor
   Payload:
   {
     / access_token / 1 : b64'SlAV32hk'/ ...
      (remainder of CWT omitted for brevity;
      CWT contains COSE_Key in the cnf claim)/,
     / ace_profile / 38 : "coap_dtls",
     / expires_in /   2 : 3600,
     / cnf / 8 : {
       / COSE_Key / 1 : {
         / kty / 1 : 4 / Symmetric /,
         / kid / 2 : b64'39Gqlw',
         / k /  -1 : b64'hJtXhkV8FJG+Onbc6mxC'
       }
     }
   }

       Figure 7: Example AS Response with an Access Token Bound to a
                               Symmetric Key
```

---
#### **5.8.3.  Error Response**

AS와의 상호 작용에 대한 오류 응답은 일반적으로 다음 예외를 제외하고 \[RFC6749\]의 섹션 5.2에 정의된 것과 동일합니다.

\* CoAP를 사용하는 경우 페이로드는 Content-Format "application/ace+cbor"를 사용하여 CBOR 맵으로 인코딩되어야 합니다. HTTP를 사용할 때 페이로드는 \[RFC6749\]의 섹션 5.2에 지정된 대로 JSON으로 인코딩됩니다.\(MUST\)

\* Invalid\_client를 제외하고 모든 오류 응답에는 CoAP 코드 4.00\(Bad Request\)에 해당하는 응답 코드를 사용해야 합니다. 여기서 CoAP 코드 4.01\(Unauthorized\)에 해당하는 응답 코드는 섹션에 지정된 것과 동일한 조건에서 사용할 수 있습니다. \[RFC6749\]의 5.2.\(MUST\)

\* CBOR 인코딩이 사용되는 경우 매개변수 error, error\_description 및 error\_uri는 표 5에 지정된 코드를 사용하여 축약되어야 합니다.\(MUST\)

\* CBOR 인코딩이 사용되는 경우 오류 코드\(즉, 오류 매개변수의 값\)는 표 3에 지정된 대로 축약되어야 합니다.\(MUST\)

```text
   +===========================+=============+========================+
   | Name                      | CBOR Values | Original Specification |
   +===========================+=============+========================+
   | invalid_request           | 1           | Section 5.2 of         |
   |                           |             | [RFC6749]              |
   +---------------------------+-------------+------------------------+
   | invalid_client            | 2           | Section 5.2 of         |
   |                           |             | [RFC6749]              |
   +---------------------------+-------------+------------------------+
   | invalid_grant             | 3           | Section 5.2 of         |
   |                           |             | [RFC6749]              |
   +---------------------------+-------------+------------------------+
   | unauthorized_client       | 4           | Section 5.2 of         |
   |                           |             | [RFC6749]              |
   +---------------------------+-------------+------------------------+
   | unsupported_grant_type    | 5           | Section 5.2 of         |
   |                           |             | [RFC6749]              |
   +---------------------------+-------------+------------------------+
   | invalid_scope             | 6           | Section 5.2 of         |
   |                           |             | [RFC6749]              |
   +---------------------------+-------------+------------------------+
   | unsupported_pop_key       | 7           | RFC 9200               |
   +---------------------------+-------------+------------------------+
   | incompatible_ace_profiles | 8           | RFC 9200               |
   +---------------------------+-------------+------------------------+
```

- 표 3: 일반적인 오류 코드에 대한 CBOR 약어

OAuth 2.0에 정의된 오류 응답 외에도 AS는 다음 동작을 구현해야 합니다.\(MUST\)

\* 클라이언트가 RS가 처리할 수 없는 토큰 요청에 비대칭 키를 제출하는 경우 AS는 표 3에 지정된 오류 코드 "unsupported\_pop\_key"를 포함하여 CoAP 코드 4.00\(Bad Request\)에 해당하는 응답 코드로 해당 요청을 거부해야 합니다. .\(MUST\)

\* 클라이언트와 클라이언트가 액세스 토큰을 요청한 RS가 공통 프로파일을 공유하지 않는 경우 AS는 지정된 오류 코드 "in Compatible\_ace\_profiles"를 포함하여 CoAP 코드 4.00\(Bad Request\)에 해당하는 응답 코드로 해당 요청을 거부해야 합니다. 표 3에서.\(MUST\)

---
#### **5.8.4.  Request and Response Parameters**

이 섹션에서는 액세스 토큰 요청 및 응답에 사용할 수 있는 새 매개변수에 대한 자세한 내용과 기존 매개변수 및 공통 매개변수 값의 보다 간결한 인코딩을 위한 약어를 제공합니다.

---
##### **5.8.4.1.  Grant Type**

CBOR 페이로드가 사용되는 경우 섹션 8.5에 정의된 레지스트리에 지정된 약어는 \[RFC6749\]에 정의된 문자열 값 대신 CBOR 인코딩에 사용해야 합니다.\(MUST\)

```text
     +====================+============+============================+
     | Name               | CBOR Value | Original Specification     |
     +====================+============+============================+
     | password           | 0          | Section 4.3.2 of [RFC6749] |
     +--------------------+------------+----------------------------+
     | authorization_code | 1          | Section 4.1.3 of [RFC6749] |
     +--------------------+------------+----------------------------+
     | client_credentials | 2          | Section 4.4.2 of [RFC6749] |
     +--------------------+------------+----------------------------+
     | refresh_token      | 3          | Section 6 of [RFC6749]     |
     +--------------------+------------+----------------------------+
```

- 표 4: 일반적인 보조금 유형에 대한 CBOR 약어

---
##### **5.8.4.2.  Token Type**

\[RFC6749\]의 5.1절에 정의된 token\_type 매개변수를 통해 AS는 클라이언트에게 수신 중인 액세스 토큰 유형\(예: 베어러 토큰\)을 나타낼 수 있습니다.

이 문서는 소유 증명 토큰을 지정하여 "OAuth 액세스 토큰 유형" 레지스트리에 대한 새 값 "PoP"를 등록합니다. 클라이언트가 RS에 대한 소유 증명을 수행하는 방법은 프로필에 의해 지정되어야 합니다.\(MUST\)

token\_type 매개변수의 값은 CBOR 인코딩이 사용되는 경우 섹션 8.7에 지정된 레지스트리에 정의된 CBOR 약어를 사용해야 합니다.\(MUST\)

이 프레임워크에서는 token\_type 매개변수의 "pop" 값이 기본값입니다. 그러나 AS는 \[IANA.OAuthAccessTokenTypes\]에 등록된 값과 다른 값을 제공할 수 있습니다.

---
##### **5.8.4.3.  Profile**

이 프레임워크의 프로파일은 클라이언트와 RS 간의 통신 프로토콜과 통신 보안 프로토콜을 정의해야 합니다. 보안 프로토콜은 암호화, 무결성 및 재생 보호를 제공해야 합니다. 또한 요청과 응답 간의 바인딩을 제공해야 합니다. 또한 프로필은 소유 증명 토큰을 지원하는 경우 허용되는 소유 증명 방법 목록을 정의해야 합니다.\(MUST, MUST, MUST, MUST\)

프로필은 ace\_profile 매개변수에서 자신을 고유하게 식별하는 데 사용해야 하는 식별자를 지정해야 합니다. 프로필 식별자의 텍스트 표현은 사람이 쉽게 읽을 수 있도록 하고 JSON 기반 상호 작용을 위해 만들어졌습니다. CBOR 기반 상호 작용에는 사용하면 안 됩니다. 프로필은 섹션 8.8에 정의된 레지스트리에 식별자를 등록해야 합니다.\(MUST, MUST NOT, MUST\)

프로필은 프로필별 매개변수의 협상이나 신호 전달을 지원하기 위해 토큰 요청과 액세스 토큰 응답의 액세스 정보 모두에 대한 추가 매개변수를 정의할 수 있습니다.\(MAY\)

AS가 액세스 토큰 응답에서 ace\_profile 매개변수를 제공하기를 원하는 클라이언트는 액세스 토큰 요청에서 CBOR 기반 상호작용의 경우 null 값 또는 CBOR이 사용되지 않는 경우 빈 문자열과 함께 ace\_profile 매개변수를 전송하여 이를 나타낼 수 있습니다. .

---
##### **5.8.4.4.  Client-Nonce**

이전에 AS 요청 생성 힌트\(섹션 5.3\)에서 connonce 매개변수를 수신한 경우 이 매개변수는 클라이언트에서 AS로 전송되어야 합니다. 매개변수는 CBOR 기반 상호작용의 경우 바이트 문자열로 인코딩되고, CBOR이 사용되지 않는 경우에는 문자열\(패딩 인코딩 바이너리가 없는 base64url \[RFC4648\]\)로 인코딩됩니다. AS 요청 생성 힌트의 connonce 매개변수 값을 복사해야 합니다.\(MUST, MUST\)

---
#### **5.8.5.  Mapping Parameters to CBOR**

CBOR 인코딩이 사용되는 경우 액세스 토큰 요청 및 응답의 모든 OAuth 매개변수는 맵 키에 대해 주어진 정수 약어를 사용하여 섹션 8.10에 정의된 레지스트리에 지정된 대로 CBOR 유형에 매핑되어야 합니다.\(MUST\)

청구에 해당하는 약어를 \[RFC8392\]에 정의된 약어와 정렬했습니다.

또한 -24에서 23까지의 약어는 CBOR에서 1바이트 인코딩 크기를 갖습니다. 따라서 우리는 제한된 시나리오에서 가장 자주 사용될 것으로 예상되는 매개변수에 해당 범위의 약어를 할당하기로 결정했습니다.

```text
      +===================+==========+=============+===============+
      | Name              | CBOR Key | Value Type  | Original      |
      |                   |          |             | Specification |
      +===================+==========+=============+===============+
      | access_token      | 1        | byte string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | expires_in        | 2        | unsigned    | [RFC6749]     |
      |                   |          | integer     |               |
      +-------------------+----------+-------------+---------------+
      | audience          | 5        | text string | [RFC8693]     |
      +-------------------+----------+-------------+---------------+
      | scope             | 9        | text or     | [RFC6749]     |
      |                   |          | byte string |               |
      +-------------------+----------+-------------+---------------+
      | client_id         | 24       | text string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | client_secret     | 25       | byte string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | response_type     | 26       | text string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | redirect_uri      | 27       | text string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | state             | 28       | text string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | code              | 29       | byte string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | error             | 30       | integer     | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | error_description | 31       | text string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | error_uri         | 32       | text string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | grant_type        | 33       | unsigned    | [RFC6749]     |
      |                   |          | integer     |               |
      +-------------------+----------+-------------+---------------+
      | token_type        | 34       | integer     | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | username          | 35       | text string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | password          | 36       | text string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | refresh_token     | 37       | byte string | [RFC6749]     |
      +-------------------+----------+-------------+---------------+
      | ace_profile       | 38       | integer     | RFC 9200      |
      +-------------------+----------+-------------+---------------+
      | cnonce            | 39       | byte string | RFC 9200      |
      +-------------------+----------+-------------+---------------+

       Table 5: CBOR Mappings Used in Token Requests and Responses
```

---
### **5.9.  The Introspection Endpoint**

토큰 내부 검사 \[RFC7662\]는 AS와 RS에 의해 구현될 수 있습니다. 구현되면 RS에서 사용하고 AS에 특정 토큰에 대한 메타데이터\(예: 유효성 또는 범위\)를 쿼리하는 데 사용할 수 있습니다. HTTP 및 JSON에 대해 \[RFC7662\]에 정의된 프로토콜과 유사하게, 이 섹션에서는 CBOR을 사용하고 애플리케이션 프로토콜 선택을 프로필에 맡기고 보다 제한된 환경에 대한 적응을 정의합니다. 클라이언트는 또한 RS와 유사하게 자체 검사를 구현하고 사용하여 주어진 토큰에 대한 정보를 얻을 수 있습니다.\(MAY, MAY, MAY\)

요청 엔터티와 AS의 내부 검사 끝점 간의 통신은 무결성을 보호하고 암호화해야 합니다. 통신 보안 프로토콜은 요청과 응답 간의 바인딩도 제공해야 합니다. 또한 두 상호 작용 당사자는 상호 인증을 수행해야 합니다. 마지막으로 AS는 요청 엔터티가 제공된 토큰에 대한 자체 검사 정보에 ​​액세스할 수 있는 권한이 있는지 확인해야 합니다. 내부 검사를 지원하는 이 프레임워크의 프로필은 요청 엔터티와 AS 간의 인증 및 통신 보안이 구현되는 방법을 지정해야 합니다.\(MUST, MUST, MUST, SHOULD, MUST\)

URL 경로에서 이 끝점의 기본 이름은 '/introspect'여야 합니다. 그러나 구현에서는 이 이름을 사용할 필요가 없으며 대신 자체 이름을 정의할 수 있습니다.\(SHOULD\)

---
#### **5.9.1.  Introspection Request**

요청 엔터티는 AS의 내부 검사 끝점에 POST 요청을 보냅니다. 프로필은 통신이 보호되는 방법을 지정해야 합니다. CoAP가 사용되는 경우 페이로드는 액세스 토큰이 포함된 토큰 항목이 있는 CBOR 맵으로 인코딩되어야 합니다. 응답에서 AS를 돕기 위해 요청 엔터티에 의해 알려진 추가 컨텍스트를 나타내는 추가 선택적 매개 변수가 포함될 수 있습니다.\(MUST, MUST, MAY\)

CoAP 기반 상호작용의 경우 모든 메시지는 "application/ace+cbor" 콘텐츠 유형을 사용해야 합니다. HTTP의 경우 \[RFC7662\]의 섹션 2.1에 정의된 인코딩이 사용됩니다.\(MUST\)

\[RFC7662\]의 섹션 2.1과 동일한 매개변수가 필수이고 선택 사항입니다.

예를 들어, 그림 8은 OAuth 2.0 소유 증명 토큰에 대해 쿼리하기 위해 AS에서 토큰 내부 검사 엔드포인트를 호출하는 RS를 보여줍니다. 이 예에서는 OSCORE \[RFC8613\] 기반 객체 보안을 가정합니다. 따라서 Content-Format은 "application/oscore"입니다. 그림 9는 디코딩된 페이로드를 보여줍니다.

```text
   Header: POST (Code=0.02)
   Uri-Host: "as.example.com"
   Uri-Path: "introspect"
   OSCORE: 0x09, 0x05, 0x25
   Content-Format: application/oscore
   Payload:
   ... COSE content ...

                  Figure 8: Example Introspection Request

   {
     / token / 11  : b64'7gj0dXJQ43U',
     / token_type_hint / 33 : 2 / PoP /
   }

                         Figure 9: Decoded Payload
```

---
#### **5.9.2.  Introspection Response**

인트로스펙션 요청이 승인되어 성공적으로 처리되면 AS는 CoAP 코드 2.01\(생성됨\)에 해당하는 응답 코드가 포함된 응답을 보냅니다. 자체 검사 요청이 유효하지 않거나 승인되지 않았거나 처리할 수 없는 경우 AS는 섹션 5.9.3에 설명된 대로 오류 응답을 반환합니다.

성공적인 응답에서 AS는 맵에 응답 매개변수를 인코딩합니다. CoAP가 사용되는 경우 이는 CBOR 맵으로 인코딩되어야 합니다. HTTP가 사용되는 경우 \[RFC7662\]의 섹션 2.2에 지정된 JSON 인코딩이 사용됩니다. 응답 페이로드를 포함하는 맵에는 \[RFC7662\]의 섹션 2.2와 동일한 필수 및 선택적 매개변수가 포함되어 있으며 다음과 같은 추가 사항이 있습니다.\(MUST\)

에이스\_프로필

- 이 매개변수는 선택사항입니다. 이는 RS가 클라이언트와 함께 사용해야 하는 프로필을 나타냅니다. 이 매개변수의 형식화에 대한 자세한 내용은 섹션 5.8.4.3을 참조하십시오. 이 매개변수가 없으면 AS는 RS가 클라이언트에 대해 사용할 프로필을 암시적으로 알고 있다고 가정합니다.\(MAY, MUST\)

알아듣다

- 이 매개변수는 선택사항입니다. 이는 클라이언트가 AS에 제공한 client-nonce입니다. RS는 이것이 AS 요청 생성 힌트에서 이전에 클라이언트에 제공된 client-nonce에 해당하는지 확인해야 합니다. 섹션 5.3 및 5.8.4.4를 참조하십시오. 해당 값은 CBOR로 인코딩된 경우 바이트 문자열이고, JSON \[RFC4648\]으로 인코딩된 경우 패딩 없이 이 바이트 문자열을 base64url로 인코딩한 것입니다.\(MAY, MUST\)

CTI

- 이 매개변수는 선택사항입니다. 이는 이 액세스 토큰과 연결된 cti 클레임입니다. 이 매개변수는 해당 값이 CBOR로 인코딩될 때 바이트 문자열이고 JSON으로 인코딩될 때 패딩 없이 이 바이트 문자열의 base64url 인코딩이라는 점을 제외하면 \[RFC7662\]의 섹션 3.1.2에 정의된 jti 매개변수와 동일한 의미 및 처리 규칙을 갖습니다. \[RFC4648\].\(MAY\)

엑시

- 이 매개변수는 선택사항입니다. 이는 이 액세스 토큰과 연결된 만료\_in 클레임입니다. 섹션 5.10.3을 참조하십시오.\(MAY\)

또한 \[RFC9201\]은 AS가 내부 검사 끝점에 대한 요청에 응답할 때 사용할 수 있어야 하는 더 많은 매개 변수를 정의합니다.\(MUST\)

예를 들어, 그림 10은 그림 8의 내부 검사 요청에 대한 AS 응답을 보여줍니다. 이 예에는 \[RFC9201\]에 정의된 cnf 매개 변수가 포함되어 있습니다.

```text
   Header: Created (Code=2.01)
   Content-Format: application/ace+cbor
   Payload:
   {
     / active /      10 : true,
     / scope /        9 : "read",
     / ace_profile / 38 : 1 / coap_dtls /,
     / cnf /          8 : {
       / COSE_Key / 1 : {
         / kty / 1 : 4 / Symmetric /,
         / kid / 2 : b64'39Gqlw',
         / k /  -1 : b64'hJtXhkV8FJG+Onbc6mxC'
       }
     }
   }

                 Figure 10: Example Introspection Response
```

---
#### **5.9.3.  Error Response**

AS와의 CoAP 기반 상호 작용에 대한 오류 응답은 \[RFC7662\]의 섹션 2.3에 정의된 대로 HTTP 기반 상호 작용에 대한 오류 응답과 동일하지만 다음과 같은 차이점이 있습니다.

\* 콘텐츠가 전송되고 CoAP가 사용되는 경우 페이로드는 CBOR 맵으로 인코딩되어야 하며 Content-Format "application/ace+cbor"를 사용해야 합니다. HTTP의 경우 \[RFC6749\]의 섹션 2.3에 정의된 인코딩이 사용됩니다.\(MUST\)

\* 요청 엔터티\(일반적으로 RS\)가 사용하는 자격 증명이 유효하지 않은 경우 AS는 CoAP 코드 4.01\(Unauthorized\)에 해당하는 응답 코드로 응답해야 하며 \[RFC7662\] 섹션 2.3의 필수 및 선택적 매개 변수를 사용해야 합니다.\(MUST\)

\* 요청 엔터티가 이 내부 검사 요청을 수행할 권한이 없는 경우 AS는 CoAP 코드 4.03\(금지됨\)과 동일한 응답 코드로 응답해야 합니다. 이 경우 페이로드가 반환되지 않습니다.\(MUST\)

\* 매개변수 error, error\_description 및 error\_uri는 표 5에 지정된 코드를 사용하여 축약되어야 합니다.\(MUST\)

\* 오류 코드는 섹션 8.4에 정의된 레지스트리에 지정된 코드를 사용하여 축약되어야 합니다.\(MUST\)

비활성 토큰이나 유효하지 않은 토큰에 대해 적절하게 형식화되고 인증된 쿼리는 이 사양에 따른 오류 응답을 보증하지 않습니다. 이러한 경우 인증 서버는 대신 활성 필드가 "false"로 설정된 자체 검사 응답으로 응답해야 합니다.\(MUST\)

---
#### **5.9.4.  Mapping Introspection Parameters to CBOR**

CBOR이 사용되는 경우 내부 검사 요청 및 응답 매개변수는 맵 키에 대해 주어진 정수 약어를 사용하여 섹션 8.12에 정의된 레지스트리에 지정된 대로 CBOR 유형에 매핑되어야 합니다.\(MUST\)

\[RFC8392\]에 정의된 약어와 섹션 5.8.5의 동일한 이름을 가진 매개변수의 약어를 사용하여 청구에 해당하는 약어를 정렬했습니다.

```text
    +===================+======+======================+===============+
    | Parameter name    | CBOR | Value Type           | Original      |
    |                   | Key  |                      | Specification |
    +===================+======+======================+===============+
    | iss               | 1    | text string          | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | sub               | 2    | text string          | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | aud               | 3    | text string          | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | exp               | 4    | integer or floating- | [RFC7662]     |
    |                   |      | point number         |               |
    +-------------------+------+----------------------+---------------+
    | nbf               | 5    | integer or floating- | [RFC7662]     |
    |                   |      | point number         |               |
    +-------------------+------+----------------------+---------------+
    | iat               | 6    | integer or floating- | [RFC7662]     |
    |                   |      | point number         |               |
    +-------------------+------+----------------------+---------------+
    | cti               | 7    | byte string          | RFC 9200      |
    +-------------------+------+----------------------+---------------+
    | scope             | 9    | text or byte string  | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | active            | 10   | True or False        | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | token             | 11   | byte string          | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | client_id         | 24   | text string          | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | error             | 30   | integer              | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | error_description | 31   | text string          | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | error_uri         | 32   | text string          | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | token_type_hint   | 33   | text string          | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | token_type        | 34   | integer              | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | username          | 35   | text string          | [RFC7662]     |
    +-------------------+------+----------------------+---------------+
    | ace_profile       | 38   | integer              | RFC 9200      |
    +-------------------+------+----------------------+---------------+
    | cnonce            | 39   | byte string          | RFC 9200      |
    +-------------------+------+----------------------+---------------+
    | exi               | 40   | unsigned integer     | RFC 9200      |
    +-------------------+------+----------------------+---------------+
```

- 표 6: 토큰 내부 검사 매개변수에 대한 CBOR 매핑

---
### **5.10.  The Access Token**

이 프레임워크에서는 \[RFC8392\]에 지정된 대로 CBOR 웹 토큰\(CWT\)을 사용하는 것이 권장됩니다.\(SHOULD\)

액세스 토큰의 오프라인 처리를 용이하게 하기 위해 이 문서에서는 JWT 및 CWT 인코딩 토큰에 대해 \[RFC8747\]의 cnf 클레임과 \[RFC8693\]의 범위 클레임을 사용합니다. 범위 주장에 지정된 문자열 인코딩 외에도 이진 인코딩을 사용할 수 있습니다. 이러한 인코딩의 구문은 여기에서 명시적으로 지정되지 않으며 프로필이나 응용 프로그램에 맡겨집니다. 특히 이진 인코딩 범위는 범위 토큰을 구분하기 위해 공백 문자 '0x20'을 반드시 사용할 필요는 없습니다.\(MAY\)

AS가 클라이언트와 통신하기 위해 사용해야 하는 프로필에 대한 힌트를 RS에 전달해야 하는 경우 AS는 섹션 5.8.4.3에 정의된 것과 동일한 구문 및 의미를 사용하여 액세스 토큰에 ace\_profile 클레임을 포함할 수 있습니다.\(MAY\)

클라이언트가 액세스 토큰 요청\(섹션 5.8.4.4\)에서 connonce 매개변수를 제출한 경우 AS는 여기에 지정된 connonce 청구에 이 매개변수의 값을 포함해야 합니다. connonce 클레임은 이진 인코딩을 사용합니다.\(MUST\)

---
#### **5.10.1.  The Authorization Information Endpoint**

인증 정보와 클라이언트가 사용하는 소유 증명 방법에 대한 정보가 포함된 액세스 토큰은 RS가 클라이언트 요청을 인증하고 권한을 부여할 수 있도록 RS로 전송되어야 합니다.

이 섹션에서는 CoAP와 같은 RESTful 프로토콜을 사용하여 액세스 토큰을 RS로 전송하는 방법을 정의합니다. 이 프레임워크의 프로필은 토큰 전송을 위한 다른 방법을 정의할 수 있습니다.\(MAY\)

이 방법은 RS에 의해 구현된 authz-info 끝점으로 구성됩니다. 이 방법을 사용하는 클라이언트는 페이로드의 액세스 토큰을 사용하여 RS의 authz-info 엔드포인트에 POST 요청을 해야 합니다. CoAP 콘텐츠 형식 또는 HTTP 미디어 유형은 CBOR 웹 토큰의 경우 토큰 형식\(예: "application/cwt"\)을 반영해야 합니다. 토큰 형식에 대해 콘텐츠 형식이나 미디어 유형이 정의되지 않은 경우 "application/octet-stream"을 사용해야 합니다.\(MUST, MUST\)

토큰을 수신한 RS는 토큰의 유효성을 확인해야 합니다. 토큰이 유효한 경우 RS는 CoAP 코드 2.01\(생성됨\)과 동일한 응답 코드로 POST 요청에 응답해야 합니다. 섹션 5.10.1.1은 RS가 액세스 토큰의 유효성을 검증하기 위해 어떻게 진행해야 하는지를 간략하게 설명합니다.\(MUST, MUST, MUST\)

RS는 향후 사용을 위해 최소한 하나의 액세스 토큰을 저장할 준비를 해야 합니다. 이는 OAuth 2.0에서 액세스 토큰이 처리되는 방식에 대한 차이점입니다. 여기서 액세스 토큰은 일반적으로 각 요청과 함께 전송되므로 RS에 저장되지 않습니다.\(MUST\)

이 프레임워크를 사용할 때 RS는 소유 증명 키당 하나의 토큰만 저장하는 것이 권장됩니다. 이는 동일한 키에 연결된 추가 토큰이 해당 인증 정보를 대체하여 RS의 기존 토큰을 대체한다는 것을 의미합니다. 그 이유는 필요한 저장 공간 및 적용 가능한 토큰에 대한 요청 해결과 관련하여 구현이 크게 단순화\(제약됨\)되기 때문입니다. 단일 클라이언트에 대해 여러 액세스 토큰을 사용하면 모든 액세스 토큰을 고려하고 클라이언트의 실제 권한을 계산해야 하므로 리소스 서버에 대한 부담이 증가합니다. 또한 토큰이 서로 모순될 수 있으며, 이로 인해 서버가 잘못된 권한을 시행할 수 있습니다. 액세스 토큰 중 하나가 다른 토큰보다 일찍 만료되면 결과 권한으로 인해 보호가 충분하지 않을 수 있습니다.\(SHOULD\)

authz-info 엔드포인트로 전송된 페이로드가 토큰으로 구문 분석되지 않는 경우 RS는 CoAP 코드 4.00\(Bad Request\)에 해당하는 응답 코드로 응답해야 합니다.\(MUST\)

RS는 authz-info 끝점에 대한 POST 요청에 응답하기 전에 토큰을 검증하기 위해 자체 검사 요청을 할 수 있습니다\(예: 토큰이 불투명 참조인 경우\). 일부 전송 프로토콜은 RS가 사용 중이고 클라이언트가 일정 간격 후에 다시 시도해야 함을 나타내는 방법을 제공할 수 있습니다. 이러한 유형의 상태 업데이트는 RS가 자체 검사 응답을 기다리는 동안 적합합니다.\(MAY\)

프로필은 이 끝점의 오류 응답이 보호되는지 여부를 포함하여 authz-info 끝점이 보호되는지 여부를 지정해야 합니다. 토큰에는 클라이언트와 RS가 처음에 보안 컨텍스트를 설정할 수 있도록 하는 정보가 포함되어 있으므로 이 시점에서는 상호 인증이 불가능할 수 있습니다.\(MUST\)

URL 경로에서 이 끝점의 기본 이름은 '/authz-info'입니다. 그러나 구현에서는 이 이름을 사용할 필요가 없으며 대신 자체 이름을 정의할 수 있습니다.

---
##### **5.10.1.1.  Verifying an Access Token**

RS가 액세스 토큰을 수신하면 저장하기 전에 이를 확인해야 합니다. 토큰 확인의 세부 사항은 토큰 인코딩, 토큰 유형, 토큰에 적용되는 보안 보호, 클레임을 비롯한 다양한 측면에 따라 달라집니다. 토큰 인코딩마다 보안 보호가 다르기 때문에 토큰 인코딩이 중요합니다. 예를 들어 CWT 토큰은 COSE를 사용하고, JWT 토큰은 JOSE\(JSON Object Signing and Encryption\)를 사용합니다. 토큰 유형은 토큰이 자체 포함되어 RS에서 로컬로 발생할 수 있으므로 확인 절차에도 영향을 미칩니다. 토큰 참조와 관련된 클레임을 얻습니다. 자체 포함된 토큰은 최소한 무결성을 보호해야 하지만 암호화될 수도 있습니다.\(MUST, MUST\)

자체 포함 토큰의 경우 RS는 해당 토큰 형식에 지정된 대로 먼저 토큰의 보안 보호를 처리해야 합니다. CWT의 경우 설명은 \[RFC8392\]에서 찾을 수 있습니다. JWT의 경우 관련 사양은 \[RFC7519\]입니다. 여기에는 이 RS에 대한 액세스 토큰을 발행할 권한이 있는 AS에 의해 보안 보호\(및 토큰\)가 생성되었다는 확인이 포함되어야 합니다.\(MUST, MUST\)

토큰이 참조로 전달되는 경우 RS는 먼저 클레임을 얻어야 합니다. RS가 토큰 내부 검사를 사용하는 경우 관련 사양은 5.9절에 지정된 CoAP 전송이 포함된 \[RFC7662\]입니다.

이 초기 처리 단계에서 오류가 발생할 수 있습니다.

\* 보안 래퍼 확인이 실패하거나 수신 RS에 대한 토큰을 발행할 권한이 없는 AS에 의해 토큰이 발행된 경우 RS는 반드시 토큰을 폐기해야 하며, 이것이 authz-info와의 상호 작용인 경우, CoAP 코드 4.01\(승인되지 않음\)에 해당하는 응답 코드와 함께 오류 메시지를 반환합니다.\(MUST\)

\* 청구를 얻을 수 없는 경우 RS는 토큰을 폐기해야 하며 authz-info 끝점을 통한 상호 작용의 경우 CoAP 코드 4.00\(잘못된 요청\)에 해당하는 응답 코드가 포함된 오류 메시지를 반환해야 합니다.\(MUST\)

다음으로 RS는 액세스 토큰에 포함된 클레임\(있는 경우\)을 확인해야 합니다. 클레임 확인이 실패하면 다음 목록의 우선순위에 따라 오류가 반환됩니다.\(MUST\)

iss

- iss 클레임\(있는 경우\)은 액세스 토큰에 대한 보안 보호를 생성한 AS를 식별해야 합니다. 그렇지 않은 경우 RS는 토큰을 폐기해야 합니다. 이것이 authz-info와의 상호작용인 경우 RS는 CoAP 코드 4.01\(Unauthorized\)에 해당하는 응답 코드로 응답해야 합니다.\(MUST, MUST\)

특급

- 만료일은 미래 날짜여야 합니다. 그렇지 않은 경우 RS는 토큰을 폐기해야 합니다. 이것이 authz-info와의 상호작용인 경우 RS는 CoAP 코드 4.01\(Unauthorized\)에 해당하는 응답 코드로 응답해야 합니다. RS는 토큰이 만료되는 시점에 보호된 자원에 대한 접근 권한을 종료해야 한다는 점에 유의하십시오.\(MUST, MUST\)

오드

- aud 클레임은 RS가 식별하는 대상을 참조해야 합니다. 그렇지 않은 경우 RS는 토큰을 폐기해야 합니다. 이것이 authz-info와의 상호작용인 경우 RS는 CoAP 코드 4.03\(금지됨\)과 동일한 응답 코드로 응답해야 합니다.\(MUST, MUST\)

범위

- RS는 범위 주장의 값을 인식해야 합니다. 그렇지 않은 경우 RS는 토큰을 폐기해야 합니다. 이것이 authz-info와의 상호 작용인 경우 RS는 CoAP 코드 4.00\(Bad Request\)과 동일한 응답 코드로 응답해야 합니다. RS는 무엇이 잘못되었는지 명확히 하기 위해 오류 응답에 추가 정보를 제공할 수 있습니다.\(MUST, MUST, MAY\)

프로필이나 기본 애플리케이션과 관련된 방식으로 다른 청구에 대해서는 추가 처리가 필요할 수 있습니다.

클라이언트가 아직 인증되지 않았을 수 있으므로 토큰이 RS에 제출될 때 sub\(주체\) 클레임을 항상 확인할 수는 없습니다. 또한 RS가 이 토큰을 처음 확인할 때 exi\(만료 후\) 청구에 대한 카운터가 초기화되어야 한다는 점에 유의하세요.\(MUST\)

또한 이 프레임워크의 프로필은 오류 응답을 허용하지 않는 액세스 토큰 전송 메커니즘을 정의할 수 있습니다. 따라서 여기에 지정된 오류 메시지는 토큰이 authz-info 엔드포인트로 전송된 경우에만 적용됩니다.

오류 응답을 보낼 때 RS는 \[RFC6750\] 섹션 3.1의 오류 코드를 사용하여 클라이언트에 추가 세부 정보를 제공할 수 있습니다.\(MAY\)

---
##### **5.10.1.2.  Protecting the Authorization Information Endpoint**

이 프레임워크는 RESTful 환경에서 사용될 수 있으므로 공격자가 액세스 토큰을 제출하는 것 외에 authz-info 엔드포인트에서 무단 요청을 수행할 수 없도록 하는 것이 중요합니다.

특히, authz-info 엔드포인트에서 GET, DELETE 또는 PUT을 수행하는 것은 불가능해야 합니다.\(SHOULD NOT\)

RS는 토큰을 반복적으로 제출하여 RS의 처리 용량을 과부하시키려는 공격을 완화하기 위해 속도 제한 조치를 구현해야 합니다. CoAP 기반 통신의 경우 RS는 \[RFC8516\]의 메커니즘을 사용하여 과부하되었음을 나타낼 수 있습니다.\(SHOULD\)

---
#### **5.10.2.  Client Requests to the RS**

RS에 요청을 보내기 전에 클라이언트는 이 통신을 보호하는 데 사용된 키가 여전히 유효한지 확인해야 합니다. 클라이언트가 사용된 키의 유효성을 결정하는 방법에 대한 자세한 내용은 섹션 5.10.4를 참조하세요.\(MUST\)

RS가 클라이언트로부터 요청을 수신하고 대상 리소스에 승인이 필요한 경우 RS는 먼저 이 요청을 승인하는 액세스 토큰이 있는지, 클라이언트가 해당 토큰에 대한 소유 증명 바인딩을 요청에 수행했는지 확인해야 합니다. .\(MUST\)

클라이언트가 소유 증명을 수행하지 않았거나 RS에 클라이언트에 대한 유효한 액세스 토큰이 없는 경우 응답 코드는 4.01\(인증되지 않음\)이어야 합니다. RS가 클라이언트에 대한 액세스 토큰을 가지고 있지만 토큰이 요청된 리소스에 대한 액세스를 승인하지 않는 경우 RS는 4.03\(금지됨\)으로 요청을 거부해야 합니다. RS가 클라이언트에 대한 액세스 토큰을 가지고 있지만 리소스에 대해 요청된 작업을 포함하지 않는 경우 RS는 4.05\(허용되지 않는 방법\)로 요청을 거부해야 합니다.\(MUST, MUST, MUST\)

참고: 응답 코드 4.03 및 4.05를 사용하는 것은 클라이언트가 AS에서 받은 액세스 토큰을 사용하여 요청된 리소스에 낙관적으로 액세스하려고 시도하는 무한 루프를 방지하기 위한 것입니다. 악의적인 클라이언트는 C를 가장하여 C의 권한을 결정할 수 있으므로 이러한 세부 응답 코드는 특정 수준의 보안이 이미 사용 가능한 경우에만 사용해야 하며, 이는 클라이언트가 인증된 경우에만 달성할 수 있습니다.

참고: RS는 요청이 제시될 때 액세스 토큰을 적시에 검증하기 위해 자체 검사를 사용할 수 있습니다.\(MAY\)

참고: 액세스 토큰\(예: 범위\)의 클레임을 특정 요청과 일치시키는 것은 애플리케이션마다 다릅니다.

요청이 유효한 토큰과 일치하고 클라이언트가 해당 토큰에 대한 소유 증명을 수행한 경우 RS는 기본 애플리케이션에서 지정한 대로 요청을 계속 처리합니다.

---
#### **5.10.3.  Token Expiration**

RS의 기능에 따라 수신된 액세스 토큰의 만료를 확인할 수 있는 다양한 방법이 있습니다. 다음은 RS에 필요한 기능을 포함한 가능성 목록입니다.

\* 토큰은 CWT이며 exp 청구와 nbf 청구를 포함할 수 있습니다. RS는 \[RFC7519\]에 정의된 대로 내부 클럭의 값과 비교하여 이를 확인합니다. 이 경우 RS의 내부 시계는 현재 날짜 및 시간을 반영하거나 최소한 AS의 시계와 동기화되어야 합니다. 이 클럭 동기화가 수행되는 방법은 이 사양의 범위를 벗어납니다.

\* RS는 섹션 5.9에 지정된 대로 자체 검사 요청을 수행하여 토큰의 유효성을 확인합니다. 이를 위해서는 RS가 AS에 대한 안정적인 네트워크 연결을 갖고 두 개의 보안 세션을 병렬로\(C에서 RS로, RS에서 AS로\) 처리할 수 있어야 합니다.

\* 내부 시계를 동기화하는 신뢰할 수 있는 방법이 없는 장치에 대한 토큰 만료를 지원하기 위해 이 사양에서는 다음 접근 방식을 정의합니다. 클레임 exi\(만료 후\)를 사용하여 RS에 토큰 수명을 초 단위로 제공할 수 있습니다. RS가 처음으로 토큰을 수신한 시간입니다. 이 메커니즘은 자체 포함 토큰\(예: CWT 및 JWT\)에만 작동합니다. CWT의 경우 이 매개변수는 부호 없는 정수로 인코딩되는 반면, JWT는 이를 JSON 숫자로 인코딩합니다.

\* 이 청구를 처리하려면 RS가 다음을 수행해야 합니다.

- - RS가 exi 클레임을 포함하여 수신하는 각 토큰에 대해 해당 토큰을 수신한 시간을 추적하고 해당 목록을 정기적으로 다시 방문하여 만료된 토큰을 삭제합니다.

- - 만료된 exi 클레임을 포함하는 토큰의 식별자를 추적합니다\(다시 수락하는 것을 방지하기 위해\). 무제한적인 메모리 사용량 증가를 방지하려면 exi 클레임을 사용할 때 다음과 같은 방식으로 구현해야 합니다.\(MUST\)

- o 토큰을 생성할 때 AS는 액세스 토큰에 cti 클레임\(또는 JWT의 경우 jti\)을 추가해야 합니다. 이 클레임의 값은 RS에 대해 이 AS에서 발행한 exi 클레임을 포함하는 토큰을 계산하는 시퀀스 번호와 RS의 식별자를 연결한 이진 표현으로 생성되어야 합니다.\(MUST, MUST\)

- o RS는 반드시 확인된 exi 클레임을 포함하는 만료된 토큰의 가장 높은 시퀀스 번호를 저장하고 더 낮은 시퀀스 번호를 가진 토큰을 만료된 것으로 처리해야 합니다. AS가 동일한 RS에 대해 서로 다른 유효 시간의 토큰을 발행하는 경우 이로 인해 시퀀스 번호가 낮은 유효한 토큰이 폐기될 수 있습니다. 일반적으로 이러한 시나리오의 토큰은 모두 동일한 유효 시간을 갖는다고 가정합니다.\(MUST\)

CoAP Observe \[RFC7641\]와 같이 장기 실행 요청을 승인하는 토큰이 만료되면 RS는 CoAP 코드 4.01\(Unauthorized\)에 해당하는 응답 코드가 포함된 오류 응답을 클라이언트에 보낸 후 처리를 종료해야 합니다. 장기 실행 요청.\(MUST\)

---
#### **5.10.4.  Key Expiration**

AS는 RS가 사용하는 키 자료를 클라이언트에게 제공합니다. 이는 일반적인 대칭 PoP 키이거나 RS가 클라이언트를 인증하는 데 사용하는 비대칭 키일 수 있습니다. 현재 해당 키와 연결된 만료 메타데이터가 없으므로 클라이언트는 이러한 키가 여전히 유효한지 알 수 없습니다. 이로 인해 클라이언트가 만료되어 공격자의 손에 있을 수 있는 키를 사용하여 중요한 정보가 포함된 요청을 RS에 보내거나 클라이언트가 적절하게 보호되지 않고 위조되었을 수 있는 RS로부터 응답을 수락하는 상황이 발생할 수 있습니다. 공격자에 의해.

이를 방지하기 위해 클라이언트는 해당 키가 관련 액세스 토큰이 있는 동안에만 유효하다고 가정해야 합니다. 액세스 토큰은 클라이언트에게 불투명하므로 클라이언트에게 액세스 토큰의 유효성을 알리려면 다음 방법 중 하나를 사용해야 합니다.\(MUST\)

\* 클라이언트는 사용 중인 모든 토큰의 기본 유효 시간\(즉, 토큰이 발급된 후 얼마나 오랫동안 유효한지\)을 알고 있습니다. 이 정보는 AS에 등록되거나 클라이언트가 쿼리할 수 있는 방식으로 AS에 의해 게시될 때 클라이언트에 제공될 수 있습니다.

\* AS는 액세스 정보의expires\_in 매개변수를 사용하여 클라이언트에게 토큰 유효성을 알립니다.

토큰 만료에 대한 정보를 얻을 수 없는 클라이언트는 이 토큰을 사용해서는 안 됩니다.\(MUST NOT\)

---
## **6.  Security Considerations**

OAuth 2.0 \[RFC6749\]에서 제공되는 RESTful 환경의 인증 및 권한 부여에 적용되는 보안 고려 사항이 이 작업에 적용됩니다. 또한 \[RFC6819\]는 IoT 배포에도 적용되는 OAuth에 대한 추가 보안 고려 사항을 제공합니다. 내부 검사 끝점을 사용하는 경우 \[RFC7662\]의 보안 고려 사항도 적용됩니다.

다음 하위 섹션에서는 이 문서와 제한된 환경에서의 사용과 관련된 문제를 다룹니다.

---
### **6.1.  Protecting Tokens**

디지털 서명이나 키 메시지 다이제스트\(예: MAC\(메시지 인증 코드\) 또는 AEAD\(인증된 데이터 암호화\) 알고리즘을 사용하여 액세스 토큰의 콘텐츠를 보호함으로써 광범위한 위협을 완화할 수 있습니다. 결과적으로 토큰이 수정되는 것을 방지하기 위해 토큰 무결성 보호를 적용해야 합니다. 특히 토큰에는 소유 증명에 사용되는 대칭 키 또는 비대칭 키에 대한 참조가 포함되어 있기 때문입니다. 액세스 토큰에 대칭 키가 포함되어 있는 경우 이 대칭 키는 리소스 서버만 해독할 수 있도록 인증 서버에 의해 암호화되어야 합니다. 토큰을 공개적으로 읽을 수 있어야 하는 경우가 아니면 AEAD 알고리즘을 사용하는 것이 MAC을 사용하는 것보다 더 좋습니다.\(MUST, MUST\)

토큰이 여러 수신자\(예: 그룹인 대상\)를 대상으로 하는 경우 AS와 수신자 간에 공유되는 대칭 키를 사용한 토큰의 무결성 보호는 수신자 중 누구라도 토큰을 수정할 수 있으므로 충분하지 않습니다. 다른 수신자는 감지하지 못합니다. 따라서 다중 수신 대상이 있는 토큰은 비대칭 서명으로 보호되어야 합니다.\(MUST\)

권한 부여 서버는 일반적으로 단일 리소스 서버\(또는 리소스 서버 목록\)인 의도된 수신자\(대상\)의 ID를 토큰에 포함하는 것이 중요합니다. 동일한 공유 비밀은 여러 리소스 서버에서 소유 증명 키로 사용되어서는 안 됩니다. 왜냐하면 소유 증명 개념을 사용함으로써 얻을 수 있는 이점이 크게 줄어들기 때문입니다.\(MUST NOT\)

클라이언트가 그렇게 할 수 있는 경우 AS가 토큰의 수명을 짧게 유지할 수 있도록 새로운 액세스 토큰을 자주 요청해야 합니다. 이를 통해 AS는 더 짧은 소유 증명 키 크기를 사용할 수 있으며 이는 클라이언트와 리소스 서버에 성능상의 이점을 제공합니다. 키가 짧을수록 메시지도 짧아집니다\(특히 비대칭 키 자료의 경우\).

인증 서버가 대칭 키를 액세스 토큰에 바인딩할 때 이러한 액세스 토큰의 범위를 특정 권한으로 지정해야 합니다.\(SHOULD\)

특정 상황에서는 아직 유효한 액세스 토큰을 취소해야 할 수도 있습니다. 클라이언트 시작 취소는 OAuth 2.0의 \[RFC7009\]에 지정되어 있습니다. OAuth의 기본 가정은 액세스 토큰이 상대적으로 짧은 수명으로 발급된다는 것이므로 다른 취소 메커니즘은 현재 지정되지 않습니다. 이는 상대적으로 수명이 긴 액세스 토큰이 필요한 연결이 끊어지고 제한된 장치의 경우 해당되지 않을 수 있으므로 이 문서의 범위를 벗어나는 추가 표준화 작업이 필요합니다.

---
### **6.2.  Communication Security**

인증 서버와의 통신은 기밀 보호를 사용해야 합니다. 클라이언트나 RS가 특정 액세스 토큰과 함께 사용하기 위해 인증 서버로부터 소유 증명 키를 얻을 수 있으므로 이 단계는 매우 중요합니다. 기밀 보호를 사용하지 않으면 이 비밀\(및 액세스 토큰\)이 도청자에게 노출되어 소유 증명 보안이 완전히 무효화됩니다. 프로필의 통신 보안 요구 사항은 섹션 5에 명시되어 있습니다.\(MUST\)

액세스 토큰에 대한 추가 보호는 이를 암호화하여 적용할 수 있습니다. 예를 들어 CWT 암호화는 \[RFC8392\]의 섹션 7.1에 지정되어 있습니다. 토큰이 나중에 안전하지 않은 연결을 통해 전송되는 경우\(예: authz-info 엔드포인트로 전송되는 경우\) 이러한 추가 보호가 필요할 수 있습니다.

개발자는 PoP 자격 증명\(예: 개인 키 또는 대칭 키\)의 유출을 방지하기 위해 주의를 기울여야 합니다. 액세스 토큰에 바인딩된 PoP 자격 증명을 소유한 공격자는 클라이언트를 가장할 수 있습니다. 공격자가 장치에 물리적으로 액세스할 수 있으므로 물리적 추출 기술을 사용하여 메모리 콘텐츠에 액세스할 수 있으므로 이는 제한된 환경이 많을 때 실제 위험이 됩니다. 이러한 위험은 키를 자주 새로 고치고, 소프트웨어 격리 기술을 사용하고, 하드웨어 보안을 사용하면 어느 정도 완화될 수 있습니다.

---
### **6.3.  Long-Term Credentials**

클라이언트와 RS 모두 통신을 보호하고 AS를 인증하는 데 사용되는 장기 자격 증명을 가지고 있습니다. 이러한 자격 증명은 무단 액세스로부터 보호되어야 합니다. 공개적으로 접근 가능한 장소에 배포된 제한된 장치에서는 특수 하드웨어\(예: 보안 키 저장 메모리\) 없이는 이러한 보호를 달성하기 어려울 수 있습니다.

자격 증명이 손실되거나 손상된 경우 영향을 받는 장치의 운영자는 이러한 자격 증명이 제공하는 모든 액세스를 무효화하는 절차를 갖고 해당 자격 증명에 연결된 토큰을 취소해야 합니다. 특정 장치에 연결된 자격 증명의 손실이 해당 장치에 연결되지 않은 다른 자격 증명의 손상으로 이어져서는 안 됩니다. 따라서 인증에 사용되는 비밀 키는 둘 이상의 당사자 간에 공유되어서는 안 됩니다.\(MUST NOT\)

클라이언트 또는 RS의 운영자는 손상되었거나 손실된 것으로 의심되는 자격 증명을 교체하기 위한 절차를 마련해야 합니다.\(SHOULD\)

또한 운영자는 폐기되는 장치에서 자격 증명 및 기타 보안에 중요한 자료를 안전하게 삭제하는 것을 포함하는 장치 폐기 절차를 갖추어야 합니다.\(SHOULD\)

---
### **6.4.  Unprotected AS Request Creation Hints**

처음에는 C와 RS 간의 통신을 보호하는 보안 채널이 존재하지 않습니다. 따라서 C는 승인되지 않은 요청\(섹션 5.3 참조\)에 대한 RS의 보호되지 않은 응답에 포함된 AS 요청 생성 힌트가 진짜인지 여부를 결정할 수 없습니다. 따라서 C는 AS가 특정 RS에 대한 액세스 토큰을 제공하도록 승인되었는지 확인해야 합니다. 이 결정을 구현하는 방법은 이 문서의 범위를 벗어나며 응용 프로그램에 맡깁니다.\(MUST\)

---
### **6.5.  Minimal Security Requirements for Communication**

이 섹션에서는 다양한 프로토콜 상호 작용의 통신 보안에 대한 최소 요구 사항을 요약합니다.

C-AS

- 클라이언트와 인증 서버 간의 모든 통신은 암호화되어야 하며 무결성과 재생이 보호되어야 합니다. 또한 공격자가 의도한 응답을 이전 요청에 유효한 이전 응답으로 바꾸는 공격을 피하기 위해 AS에서 클라이언트로의 응답은 클라이언트의 요청에 바인딩되어야 합니다. 이를 위해서는 보안 통신을 협상하기 위해 클라이언트와 인증 서버가 이전에 공유 비밀 또는 공개 키를 교환한 적이 있어야 합니다. 또한 클라이언트는 AS가 특정 RS에 대한 액세스 토큰을 발급할 권한이 있는지 여부를 확인할 수 있어야 합니다. 예를 들어 이는 사전 구성된 목록을 통해 수행되거나 보안이 요구되는 온라인 조회 메커니즘을 통해 수행될 수 있습니다.\(MUST, MUST, MUST\)

RS-AS

- 내부 검사 끝점을 통한 리소스 서버와 권한 부여 서버 간의 통신은 암호화되어야 하며 무결성 및 재생이 보호되어야 합니다. 또한 AS에서 RS로의 응답은 RS의 요청에 바인딩되어야 합니다. 이를 위해서는 보안 통신을 협상하기 위해 RS와 인증 서버가 이전에 공유 비밀 또는 공개 키를 교환한 적이 있어야 합니다. 또한 RS는 AS가 액세스 토큰 자체를 발행할 권한이 있는지 여부를 확인할 수 있어야 합니다. 이는 일반적으로 대역 외로 구성되지만 동일한 방식으로 보안이 유지되는 경우 온라인 조회 메커니즘을 통해 수행할 수도 있습니다.\(MUST, MUST, MUST\)

C-RS

- 클라이언트와 리소스 서버 간의 초기 통신은 일반적으로 RS가 필요한 매개변수를 전달하는 해당 클라이언트에 대한 액세스 토큰을 소유하고 있지 않기 때문에 보안이 유지될 수 없습니다. 양쪽 당사자가 클라이언트 인증 없이 DTLS를 지원하는 경우 초기 통신을 보호하기 위해 이 메커니즘을 사용하는 것이 좋습니다. 클라이언트가 RS에 액세스 토큰을 성공적으로 전송한 후에는 실제 자원 요청을 위해 클라이언트와 RS 사이에 보안 통신 프로토콜이 설정되어야 합니다. 이 프로토콜은 요청과 응답 간의 바인딩뿐만 아니라 기밀성, 무결성, 재생 보호를 제공해야 합니다. 이를 위해서는 클라이언트가 RS의 공개 키를 학습했거나 AS로부터 액세스 토큰에 바인딩된 대칭 소유 증명 키를 수신해야 합니다. RS는 클라이언트의 공개 키, 토큰의 클레임에서 공유된 대칭 키 또는 자체 검사 요청을 학습해야 합니다. ACE는 C와 RS 간의 프로필 협상을 제공하지 않기 때문에 클라이언트는 RS가 어떤 프로필을 지원하는지\(예: AS 또는 사전 구성된 프로필에서\) 학습하고 이에 따라 통신을 시작해야 합니다.\(SHOULD, MUST, MUST, MUST\)

---
### **6.6.  Token Freshness and Expiration**

오프라인 상태의 RS는 클럭 드리프트 문제에 직면합니다. 시계를 AS와 동기화할 수 없기 때문에 더 이상 유효하지 않거나 손상된 오래된 액세스 토큰을 수락하도록 속일 수 있습니다. 이를 방지하기 위해 RS는 섹션 5.3에 정의된 nonce 기반 메커니즘\(cnonce\)을 사용하여 이후에 이 RS에 제공되는 액세스 토큰의 최신성을 보장할 수 있습니다.

시계 드리프트의 또 다른 문제는 표준 토큰 만료 클레임 exp를 평가하면 예측할 수 없는 결과가 나올 수 있다는 것입니다.

허용되는 클럭 드리프트 범위는 구체적인 애플리케이션에 따라 크게 달라집니다. 중요한 요소는 액세스 토큰이 유효한 기간과 액세스 토큰의 적시 만료가 얼마나 중요한지입니다.

RS가 토큰을 처음 본 시점을 기반으로 exi 클레임으로 구현된 만료 메커니즘은 보다 예측 가능한 대안을 제공하기 위해 정의되었습니다. Exi 접근 방식에는 고려해야 할 몇 가지 단점이 있습니다.

\* 악의적인 클라이언트는 수명을 연장하기 위해 exi 클레임으로 토큰을 보류할 수 있습니다.

\* RS가 상태를 잃는 경우\(예: 예정되지 않은 재부팅으로 인해\) 저장 중인 토큰의 exi 클레임을 추적하는 카운터의 현재 값을 잃을 수 있습니다.

첫 번째 단점은 배포 시나리오와 Exi 솔루션에 내재되어 있습니다. 따라서 때때로 RS가 온라인 상태가 되도록 요구하지 않으면 완화될 수 없습니다. 두 번째 단점은 exi 카운터의 값을 영구 메모리에 정기적으로 저장하여 완화할 수 있습니다.

---
### **6.7.  Combining Profiles**

다양한 상호 작용에 대해 다양한 전송 및 보안 프로토콜이 허용되는 사용 사례가 있을 수 있으며, 기존 프로필에서 명시적으로 다루지 않는 경우 프로필을 새 프로필로 결합하는 것에 해당합니다. 예를 들어, 새 프로필은 이전에 정의된 MQTT-TLS 프로필이 클라이언트와 AS 간의 상호 작용을 위해 이전에 정의된 CoAP-DTLS 프로필과 함께 클라이언트와 RS 간에 사용되도록 지정할 수 있습니다. 기존 프로필을 결합한 새 프로필은 기존 프로필의 보안 요구 사항이 충족되는 방식을 지정해야 합니다. 따라서 모든 프로필은 보안 요구 사항을 명확하게 지정해야 하며 보안이 다양한 프로토콜 상호 작용의 조합에 따라 달라지는 경우 문서화해야 합니다.\(MUST, MUST\)

---
### **6.8.  Unprotected Information**

authz-info 엔드포인트와의 통신 및 이 프레임워크에 정의된 다양한 오류 응답에는 잠재적으로 보호되지 않은 채널을 통한 정보 전송이 포함될 수 있습니다. 이러한 메시지는 적에게 정보를 유출할 수도 있고 적극적인 공격자가 조작하여 잘못된 동작을 유도할 수도 있습니다. 예를 들어 인증 정보 엔드포인트에 대한 요청에 대한 오류 응답은 이 토큰을 가로채는 공격자에게 불투명한 액세스 토큰에 대한 정보를 공개할 수 있습니다.

오류 메시지와 관련하여 이 프레임워크는 일반적으로 자세한 오류 메시지의 이점이 정보 유출로 인한 위험보다 크다는 가정하에 작성되었습니다. 이 평가가 적용되지 않는 특정 사용 사례의 경우 자세한 오류 메시지가 보다 일반적인 오류 메시지로 대체될 수 있습니다.

일부 시나리오에서는 authz-info 끝점과의 통신을 보호하는 것이 가능할 수 있습니다\(예: 서버 측 인증만 사용하는 DTLS를 통해\). 이것이 가능하지 않은 경우에는 불투명한 참조이고 RS의 자체 검사를 받아야 하는 암호화된 CWT 또는 토큰을 사용하는 것이 좋습니다.\(SHOULD\)

초기 무단 리소스 요청 메시지\(섹션 5.2 참조\)가 사용되는 경우 클라이언트는 이 요청에서 민감한 콘텐츠를 전송하지 않는지 확인해야 합니다. GET 및 DELETE 요청은 리소스의 대상 URI만 표시하는 반면, POST 및 PUT 요청은 의도한 작업의 전체 페이로드를 표시합니다.\(MUST\)

클라이언트가 authz-info 엔드포인트에 액세스 토큰을 제출하는 시점에 인증되지 않았기 때문에 공격자는 클라이언트인 척하고 RS를 속여 취약한 보안 메커니즘을 지정하는 오래된 프로필을 사용하도록 시도할 수 있습니다. authz-info 엔드포인트를 통해. 이러한 공격에는 상기 사용되지 않는 프로필의 사용을 요청하는 ace\_profile 클레임을 포함하는 유효한 액세스 토큰이 필요합니다. 리소스 소유자는 이러한 오래된 프로필을 사용하지 못하도록 RS 구성을 업데이트해야 합니다.

---
### **6.9.  Identifying Audiences**

\[RFC7519\]에 정의된 aud 클레임과 \[RFC8693\]의 동등한 대상 매개변수는 대상 값을 특정 RS에 일치시키는 방법에 대해 의도적으로 모호합니다. 이는 애플리케이션별 의미 체계를 사용할 수 있도록 하기 위한 것입니다. 이 섹션에서는 제한된 환경에서 청중 사용에 대한 몇 가지 일반적인 지침을 제공하려고 합니다.

URL은 네트워크를 전환하여 새 URL과 연결할 수 있는 모바일 장치를 식별하는 좋은 방법이 아닙니다. 청중이 단일 RS를 나타내고 비대칭 키가 사용되는 경우 RS는 공개 키의 해시로 고유하게 식별될 수 있습니다. 이 접근 방식을 사용하는 경우 \[RFC6920\] 섹션 3의 절차를 적용하는 것이 좋습니다.\(SHOULD\)

청중이 리소스 서버 그룹을 다루는 경우, 그룹 식별자를 개별 RS로 매핑하는 것은 그룹 청중을 사용하기 전에 각 RS에 제공되어야 합니다. 그룹의 멤버십이 변경될 때 RS에 항상 연결할 수 없는 경우 동적 그룹 관리가 문제가 될 수 있습니다. 더욱이, 그룹 대상에 적용되는 대칭 소유 증명 키에 바인딩된 액세스 토큰을 발행하는 것은 문제가 됩니다. 액세스 토큰을 소유하고 있는 RS가 그룹의 일부인 다른 RS에 대해 클라이언트를 가장할 수 있기 때문입니다. 따라서 그룹 대상 및 대칭형 소유 증명 키에 바인딩된 액세스 토큰을 발급하는 것은 권장되지 않습니다.\(SHOULD NOT\)

클라이언트도 의도한 RS에 대한 토큰을 얻으려면 청중 매개변수에 넣을 올바른 값을 결정할 수 있어야 합니다. 이 프로세스의 오류로 인해 클라이언트가 실수로 잘못된 RS에 대한 토큰을 얻을 수 있습니다. 대상에 대한 올바른 값은 구성의 일부로 클라이언트에 제공되거나 클라이언트가 일부 디렉터리에서 동적으로 조회할 수 있습니다. 후자의 경우 디렉터리 데이터의 무결성과 정확성이 보장되어야 합니다. AS 요청 생성 힌트\(섹션 5.3\)의 일부로 RS에서 제공하는 대상 힌트는 일반적으로 소스가 인증되지 않고 무결성이 보호되지 않으므로 신뢰할 수 있는 값으로 취급되어서는 안 됩니다.

---
### **6.10.  Denial of Service Against or with Introspection**

OAuth에서 제공되고 ACE 프레임워크에서 지원되는 선택적 내부 검사 메커니즘은 구현자가 고려해야 하는 두 가지 유형의 공격을 허용합니다.

첫째, 공격자는 액세스 토큰의 유효성 검사를 방지하기 위해 AS의 내부 검사 끝점에 대해 서비스 거부 공격을 수행할 수 있습니다. 시스템의 보안을 유지하기 위해 내부 검사를 사용하도록 구성된 RS는 내부 검사 끝점에 도달할 수 없는 토큰을 기반으로 하는 액세스를 허용해서는 안 됩니다.\(MUST NOT\)

둘째, 공격자는 RS가 내부 검사를 수행한다는 사실을 이용하여 내부 검사 호출이 필요한 authz-info 끝점에 토큰을 반복적으로 전송하여 해당 RS에 대한 서비스 거부 공격을 수행할 수 있습니다. RS는 /authz-info에 토큰을 제출하는 특정 클라이언트 IP 주소에 대해 지정된 시간 간격으로 수행하는 내부 검사 요청 수에 대한 속도 제한을 구현하여 이러한 공격을 완화할 수 있습니다. 해당 제한에 도달하면 해당 주소에서 들어오는 요청이 일정 시간 동안 거부됩니다. 분산 공격을 완화하려면 자체 검사 요청에 대한 일반적인 속도 제한도 고려해야 합니다.

---
## **7.  Privacy Considerations**

구현자와 사용자는 이 프레임워크의 다양한 배포가 개인 정보 보호에 미치는 영향을 알고 있어야 합니다.

AS는 매우 중심적인 위치에 있으며 액세스 토큰을 요청하는 클라이언트에 대한 민감한 정보를 잠재적으로 학습할 수 있습니다. 클라이언트 자격 증명 부여가 사용되는 경우 AS는 클라이언트가 수행하려는 액세스 종류를 추적할 수 있습니다. 다른 부여를 사용하면 리소스 소유자가 이를 방지할 수 있습니다. 이를 위해 리소스 소유자는 AS가 다른 권한을 연결하여 동일한 클라이언트에 의한 다른 액세스 토큰 요청을 허용하지 않는 익명의 임시 자격 증명에 발급한 권한을 바인딩해야 합니다.

토큰에 포함된 클레임은 클라이언트 및 RS에 대한 개인 정보에 민감한 정보를 이에 액세스하는 모든 당사자에게 공개할 수 있습니다\(자체 포함된 토큰의 콘텐츠 처리 또는 내부 조사를 통해\). AS는 발행된 토큰에 공개된 클라이언트 및 RS에 대한 정보를 최소화하도록 구성되어야 합니다.\(SHOULD\)

토큰이 무결성만 보호되고 암호화되지 않은 경우 유선으로 듣고 있는 공격자에게 정보가 공개되거나 다른 방법으로 액세스 토큰을 얻을 수 있습니다. CWT의 경우 토큰은 예를 들어 클라이언트가 사용하는 청중, 범위 및 확인 방법을 공개할 수 있습니다. 후자는 클라이언트를 실행하는 장치나 애플리케이션의 신원을 드러낼 수 있습니다. 이는 클라이언트를 사용하는 사람의 신원과 연결될 수 있습니다\(사람이 있고 기계 간 상호 작용이 없는 경우\).

소유 증명을 위해 비대칭 키를 사용하는 클라이언트는 다른 RS에 대한 소유 증명을 위해 동일한 키 쌍을 사용하는 결과를 알고 있어야 합니다. 공모하는 RS 세트 또는 액세스 토큰을 얻을 수 있는 공격자는 요청을 연결하거나 클라이언트의 신원을 확인할 수도 있습니다.

승인되지 않은 요청\(섹션 5.3 참조\)에 대한 보호되지 않은 응답은 RS 및/또는 C와의 기존 관계에 대한 정보를 공개할 수 있습니다. 암호화되지 않은 응답에는 가능한 한 적은 정보를 포함하는 것이 좋습니다. AS의 절대 URI도 RS가 제공하는 서비스에 대한 민감한 정보를 드러낼 수 있습니다. 개발자는 RS가 AS 요청 생성 힌트에서 이해관계자의 개인정보 보호에 영향을 미치는 정보를 공개하지 않도록 해야 합니다. 필요한 경우 AS 검색을 위해 다른 메커니즘을 사용하도록 선택할 수 있습니다. C와 RS 사이의 통신을 암호화하는 수단이 이미 존재하는 경우, 특정 오류에 대응할 수 있는 충분한 정보를 C에 제공하기 위해 오류 응답에 더 자세한 정보가 포함될 수 있습니다.

---
## **8.  IANA Considerations**

이 문서는 Expert Review 등록 정책을 사용하여 여러 레지스트리를 생성합니다. 전문가에게 제공되는 지침은 섹션 8.17에 나와 있습니다.

---
### **8.1.  ACE Authorization Server Request Creation Hints**

이 사양은 IANA "ACE 인증 서버 요청 생성 힌트" 레지스트리를 설정합니다.

레지스트리 열은 다음과 같습니다.

이름: 매개변수의 이름입니다.

CBOR 키: 매개변수에 대한 CBOR 맵 키입니다. 다양한 값 범위는 다양한 등록 정책 \[RFC8126\]을 사용합니다. -256부터 255까지의 정수 값이 표준 조치로 지정됩니다. -65536에서 -257, 256에서 65535 사이의 정수 값이 필수 사양으로 지정됩니다. 65535보다 큰 정수 값은 전문가 검토로 지정됩니다. -65536보다 작은 정수 값은 개인 사용으로 표시됩니다.

값 유형: 이 매개변수의 값에 허용되는 CBOR 데이터 유형입니다.

참조: 여기에는 Request Creation Hint 약어\(존재하는 경우\)의 공개 사양에 대한 포인터가 포함되어 있습니다.

이 레지스트리는 처음에 표 1의 값으로 채워졌습니다. 이러한 모든 항목에 대한 참조 열은 이 문서입니다.

---
### **8.2.  CoRE Resource Types**

IANA는 "CoRE\(Constrained RESTful Environments\) 매개변수" \[IANA.CoreParameters\] 레지스트리 아래의 "리소스 유형\(rt=\) 링크 대상 속성 값" 하위 레지스트리에 새로운 리소스 유형\(rt=\) 링크 대상 속성을 등록했습니다.

```text
   Value:  ace.ai
   Description:  ACE-OAuth authz-info endpoint resource.
   Reference:  RFC 9200
```

특정 ACE-OAuth 프로필은 프로필별 검색 프로세스를 정의하기 위해 이 공통 리소스 유형을 사용할 수 있습니다.

---
### **8.3.  OAuth Extensions Errors**

이 사양은 "OAuth Extensions Error Registry" \[IANA.OAuthExtensionsErrorRegistry\]에 다음 오류 값을 등록합니다.

이름: unsupported\_pop\_key 사용법 위치: 토큰 오류 응답 프로토콜 확장: RFC 9200 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.8.3

이름: in Compatible\_ace\_profiles 사용 위치: 토큰 오류 응답 프로토콜 확장: RFC 9200 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.8.3

---
### **8.4.  OAuth Error Code CBOR Mappings**

이 사양은 IANA "OAuth 오류 코드 CBOR 매핑" 레지스트리를 설정합니다.

레지스트리 열은 다음과 같습니다.

이름: OAuth 오류 코드 이름은 \[RFC6749\]의 섹션 5.2에 있는 이름을 나타냅니다\(예: "invalid\_request"\).

CBOR 값: 이 오류 코드의 CBOR 약어입니다. -65536보다 작은 정수 값은 개인 사용으로 표시됩니다. 다른 모든 값은 등록 정책 전문가 검토 \[RFC8126\]를 사용합니다.

참조: 여기에는 오류 코드 약어의 공개 사양에 대한 포인터가 포함되어 있습니다.

원래 사양: 여기에는 오류 코드의 공개 사양\(있는 경우\)에 대한 포인터가 포함됩니다.

이 레지스트리는 처음에 표 3의 값으로 채워졌습니다. 이러한 모든 항목에 대한 참조 열은 이 문서입니다.

---
### **8.5.  OAuth Grant Type CBOR Mappings**

이 사양은 IANA "OAuth 부여 유형 CBOR 매핑" 레지스트리를 설정합니다.

이 레지스트리의 열은 다음과 같습니다.

이름: \[RFC6749\]의 섹션 1.3에 지정된 승인 유형의 이름입니다.

CBOR 값: 이 보조금 유형의 CBOR 약어입니다. -65536보다 작은 정수 값은 개인 사용으로 표시됩니다. 다른 모든 값은 등록 정책 전문가 검토 \[RFC8126\]를 사용합니다.

참조: 여기에는 부여 유형 약어의 공개 사양\(있는 경우\)에 대한 포인터가 포함됩니다.

원본 사양: 여기에는 부여 유형의 공개 사양\(있는 경우\)에 대한 포인터가 포함됩니다.

이 레지스트리는 처음에 표 4의 값으로 채워졌습니다. 이러한 모든 항목에 대한 참조 열은 이 문서입니다.

---
### **8.6.  OAuth Access Token Types**

이 섹션에서는 "OAuth 액세스 토큰 유형" 레지스트리 \[IANA.OAuthAccessTokenTypes\]에 다음과 같은 새로운 토큰 유형을 등록합니다.

이름: PoP 추가 토큰 엔드포인트 응답 매개변수: cnf, rs\_cnf\(\[RFC8747\]의 섹션 3.1 및 \[RFC9201\]의 섹션 3.2 참조\) HTTP 인증 체계: 해당 없음 컨트롤러 변경: IETF 참조: RFC 9200

---
### **8.7.  OAuth Access Token Type CBOR Mappings**

이 사양은 IANA "OAuth 액세스 토큰 유형 CBOR 매핑" 레지스트리를 설정합니다.

이 레지스트리의 열은 다음과 같습니다.

이름: "OAuth 액세스 토큰 유형" 레지스트리에 등록된 토큰 유형의 이름입니다\(예: "Bearer"\).

CBOR 값: 이 토큰 유형의 CBOR 약어입니다. -65536보다 작은 정수 값은 개인 사용으로 표시됩니다. 다른 모든 값은 등록 정책 전문가 검토 \[RFC8126\]를 사용합니다.

참조: 여기에는 OAuth 토큰 유형 약어의 공개 사양\(있는 경우\)에 대한 포인터가 포함됩니다.

원본 사양: 여기에는 OAuth 토큰 유형의 공개 사양\(있는 경우\)에 대한 포인터가 포함됩니다.

---
#### **8.7.1.  Initial Registry Contents**

```text
   Name:  Bearer
   CBOR Value:  1
   Reference:  RFC 9200
   Original Specification:  [RFC6749]

   Name:  PoP
   CBOR Value:  2
   Reference:  RFC 9200
   Original Specification:  RFC 9200
```

---
### **8.8.  ACE Profiles**

이 사양은 IANA "ACE 프로필" 레지스트리를 설정합니다.

이 레지스트리의 열은 다음과 같습니다.

이름: 프로필 속성의 값으로 사용될 프로필의 이름입니다.

설명: 프로필의 개요와 프로필이 개발된 컨텍스트를 제공하는 텍스트입니다.

CBOR 값: 이 프로필 이름의 CBOR 약어입니다. 다양한 값 범위는 다양한 등록 정책 \[RFC8126\]을 사용합니다. -256부터 255까지의 정수 값이 표준 조치로 지정됩니다. -65536에서 -257, 256에서 65535 사이의 정수 값이 필수 사양으로 지정됩니다. 65535보다 큰 정수 값은 전문가 검토로 지정됩니다. -65536보다 작은 정수 값은 개인 사용으로 표시됩니다.

참조: 여기에는 프로필 약어의 공개 사양\(있는 경우\)에 대한 포인터가 포함됩니다.

---
### **8.9.  OAuth Parameters**

이 사양은 "OAuth 매개변수" 레지스트리 \[IANA.OAuthParameters\]에 다음 매개변수를 등록합니다.

이름: ace\_profile 매개변수 사용법 위치: 토큰 응답 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.8.2 및 5.8.4.3

---
### **8.10.  OAuth Parameters CBOR Mappings**

이 사양은 IANA "OAuth 매개변수 CBOR 매핑" 레지스트리를 설정합니다.

이 레지스트리의 열은 다음과 같습니다.

이름: OAuth 매개변수 이름은 OAuth 매개변수 레지스트리의 이름\(예: client\_id\)을 나타냅니다.

CBOR 키: 이 매개변수에 대한 CBOR 맵 키입니다. -65536보다 작은 정수 값은 개인 사용으로 표시됩니다. 다른 모든 값은 등록 정책 전문가 검토 \[RFC8126\]를 사용합니다.

값 유형: 이 매개변수의 값에 허용되는 CBOR 데이터 유형입니다.

참조: 여기에는 OAuth 매개변수 약어\(존재하는 경우\)의 공개 사양에 대한 포인터가 포함됩니다.

원본 사양 여기에는 OAuth 매개변수의 공개 사양\(있는 경우\)에 대한 포인터가 포함됩니다.

이 레지스트리는 처음에 표 5의 값으로 채워졌습니다. 이러한 모든 항목에 대한 참조 열은 이 문서입니다.

---
### **8.11.  OAuth Introspection Response Parameters**

이 사양은 "OAuth Token Introspection Response" 레지스트리 \[IANA.TokenIntrospectionResponse\]에 다음 매개변수를 등록합니다.

이름: ace\_profile 설명: 클라이언트와 RS 간에 사용되는 ACE 프로필입니다. 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.9.2

이름: cnonce 설명: "client-nonce". RS가 클라이언트를 통해 이전에 AS에 제공한 nonce입니다. RS가 시계를 AS와 동기화할 수 없을 때 토큰 최신성을 확인하는 데 사용됩니다. 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.9.2

이름 cti 설명 "CWT ID". \[RFC8392\]에 정의된 CWT의 식별자입니다. RFC 9200의 컨트롤러 IETF 참조 섹션 5.9.2 변경

이름: exi 설명: "만료 날짜". RS가 토큰을 처음 본 시점부터 토큰의 수명\(초\)입니다. 내부 시계를 동기화할 수 없는 장치에 대해 더 약한 형태의 토큰 만료를 구현하는 데 사용됩니다. 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.9.2

---
### **8.12.  OAuth Token Introspection Response CBOR Mappings**

이 사양은 IANA "OAuth 토큰 내부 검사 응답 CBOR 매핑" 레지스트리를 설정합니다.

이 레지스트리의 열은 다음과 같습니다.

이름: OAuth 매개변수 이름은 OAuth 매개변수 레지스트리의 이름\(예: client\_id\)을 나타냅니다.

CBOR 키: 이 매개변수에 대한 CBOR 맵 키입니다. -65536보다 작은 정수 값은 개인 사용으로 표시됩니다. 다른 모든 값은 등록 정책 전문가 검토 \[RFC8126\]를 사용합니다.

값 유형: 이 매개변수의 값에 허용되는 CBOR 데이터 유형입니다.

참조: 여기에는 자체 검사 응답 매개변수 약어\(있는 경우\)의 공개 사양에 대한 포인터가 포함됩니다.

원본 사양 여기에는 OAuth 토큰 자체 검사 매개변수\(존재하는 경우\)의 공개 사양에 대한 포인터가 포함됩니다.

이 레지스트리는 처음에 표 6의 값으로 채워졌습니다. 이러한 모든 항목에 대한 참조 열은 이 문서입니다.

클레임 이름에 해당하는 매개 변수 매핑은 \[RFC8392\]의 CWT 클레임 이름 매핑과 의도적으로 일치합니다.

---
### **8.13.  JSON Web Token Claims**

이 사양은 "JSON Web Token \(JWT\)" 레지스트리 \[IANA.JsonWebTokenClaims\] 아래의 "JSON Web Token Claims" 하위 레지스트리에 다음과 같은 새로운 클레임을 등록합니다.

클레임 이름: ace\_profile 클레임 설명: 토큰과 함께 사용되는 ACE 프로필입니다. 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.10

클레임 이름: cnonce 클레임 설명: "client-nonce". RS가 클라이언트를 통해 이전에 AS에 제공한 nonce입니다. RS가 시계를 AS와 동기화할 수 없을 때 토큰 최신성을 확인하는 데 사용됩니다. 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.10

클레임 이름: exi 클레임 설명: "만료 날짜". RS가 토큰을 처음 본 시점부터 토큰의 수명\(초\)입니다. 내부 시계를 동기화할 수 없는 장치에 대해 더 약한 형태의 토큰 만료를 구현하는 데 사용됩니다. 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.10.3

---
### **8.14.  CBOR Web Token Claims**

이 사양은 "CBOR 웹 토큰\(CWT\) 클레임" 레지스트리 \[IANA.CborWebTokenClaims\]에 다음과 같은 새로운 클레임을 등록합니다.

클레임 이름: ace\_profile 클레임 설명: 토큰과 함께 사용되는 ACE 프로필입니다. JWT 클레임 이름: ace\_profile 클레임 키: 38 클레임 값 유형: 정수 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.10

클레임 이름: cnonce 클레임 설명: 클라이언트를 통해 RS에 의해 AS로 전송된 client-nonce입니다. JWT 클레임 이름: cnonce 클레임 키: 39 클레임 값 유형: 바이트 문자열 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.10

클레임 이름: ex 클레임 설명: RS에서 수신된 시점부터 측정된 토큰의 만료 시간\(초\)입니다. JWT 클레임 이름: exi 클레임 키: 40 클레임 값 유형: 부호 없는 정수 변경 컨트롤러: IETF 참조: RFC 9200의 섹션 5.10.3

클레임 이름: 범위 클레임 설명: \[RFC6749\]에 정의된 액세스 토큰의 범위입니다. JWT 청구 이름: 범위 청구 키: 9 청구 값 유형: 바이트 문자열 또는 텍스트 문자열 변경 컨트롤러: IETF 참조: \[RFC8693\]의 섹션 4.2

---
### **8.15.  Media Type Registration**

이 사양은 CBOR로 인코딩된 매개변수를 전달하는 이 문서에 정의된 프로토콜의 메시지에 대해 "application/ace+cbor" 미디어 유형을 등록합니다. 이 등록은 \[RFC6838\]에 지정된 절차를 따릅니다.

```text
   Type name:  application

   Subtype name:  ace+cbor

   Required parameters:  N/A

   Optional parameters:  N/A
```

인코딩 고려사항: RFC 9200에 정의된 프로토콜 매개변수를 포함하는 CBOR 맵으로 인코딩되어야 합니다.

보안 고려 사항: RFC 9200의 섹션 6을 참조하세요.

```text
   Interoperability considerations:  N/A

   Published specification:  RFC 9200
```

이 미디어 유형을 사용하는 애플리케이션: 유형은 다음에서 사용됩니다.

- RFC 9200에 지정된 대로 CBOR 인코딩을 사용하여 ACE 프레임워크를 지원하는 인증 서버, 클라이언트 및 리소스 서버.

```text
   Fragment identifier considerations:  N/A

   Additional information:  N/A
```

자세한 내용을 문의할 사람 및 이메일 주소:

- IESG <iesg@ietf.org\>

```text
   Intended usage:  COMMON
```

이용제한 : 없음

```text
   Author:  Ludwig Seitz <ludwig.seitz@combitech.se>

   Change controller:  IETF
```

---
### **8.16.  CoAP Content-Formats**

"CoAP Content-Formats" 레지스트리에 다음 항목이 등록되었습니다.

```text
   Media Type:  application/ace+cbor
   Encoding:  -
   ID:  19
   Reference:  RFC 9200
```

---
### **8.17.  Expert Review Instructions**

본 문서에 확립된 모든 IANA 레지스트리는 Expert Review의 등록 정책을 사용하도록 정의됩니다. 이 섹션에서는 전문가가 찾아야 할 사항에 대한 몇 가지 일반적인 지침을 제공하지만, 전문가로 지정되는 데에는 어떤 이유가 있으므로 상당한 권한이 부여되어야 합니다.

전문 검토자는 다음 사항을 고려해야 합니다.

\* 포인트 스쿼트는 지양되어야 합니다. 검토자는 사용이 이미 등록된 것과 중복되지 않고 포인트가 배포에 사용될 가능성이 있는지 확인하기 위해 등록 요청에 대한 충분한 정보를 얻는 것이 좋습니다. 개인 사용으로 태그가 지정된 영역은 테스트 목적 및 폐쇄된 환경을 위한 것입니다. 다른 범위의 코드 포인트는 테스트용으로 할당하면 안 됩니다.

\* 상호 운용 가능한 방식으로 폐쇄된 환경 외부에서 사용될 것으로 예상되는 경우 선착순 범위에 대한 사양이 필요합니다. 사양이 제공되지 않은 경우 제공된 설명에는 포인트가 사용되는 용도를 식별할 수 있는 충분한 정보가 있어야 합니다.

\* 전문가는 포인트 할당을 승인할 때 예상되는 필드 사용을 고려해야 합니다. 표준 트랙 문서에 범위가 있다는 사실이 표준 트랙 문서에 해당 범위 외부에 포인트가 할당될 수 없다는 의미는 아닙니다. 인코딩된 값의 길이는 해당 길이의 남은 코드 포인트 수, 즉 사용될 장치의 크기에 따라 결정됩니다.

\* 이들 사이에는 높은 수준의 중복이 예상되므로

- 레지스트리 및 OAuth 매개변수 \[IANA.OAuthParameters\] 레지스트리의 내용, 전문가는 유사한 기능을 가진 OAuth 매개변수와의 정렬을 유지하기 위해 새로운 등록을 요구해야 합니다. 이 정렬에서 벗어나는 것은 사용 사례에 의해 동기가 부여되고 유사한 OAuth 매개변수로 쉽거나 효율적으로 처리될 수 없는 기능적 차이가 있는 경우에만 허용되어야 합니다.

---
## **9.  References**
---
### **9.1.  Normative References**

```text
   [IANA.CborWebTokenClaims]
              IANA, "CBOR Web Token (CWT) Claims",
              <https://www.iana.org/assignments/cwt>.

   [IANA.CoreParameters]
              IANA, "Constrained RESTful Environments (CoRE)
              Parameters",
              <https://www.iana.org/assignments/core-parameters>.

   [IANA.JsonWebTokenClaims]
              IANA, "JSON Web Token Claims",
              <https://www.iana.org/assignments/jwt>.

   [IANA.OAuthAccessTokenTypes]
              IANA, "OAuth Access Token Types",
              <https://www.iana.org/assignments/oauth-parameters>.

   [IANA.OAuthExtensionsErrorRegistry]
              IANA, "OAuth Extensions Error Registry",
              <https://www.iana.org/assignments/oauth-parameters>.

   [IANA.OAuthParameters]
              IANA, "OAuth Parameters",
              <https://www.iana.org/assignments/oauth-parameters>.

   [IANA.TokenIntrospectionResponse]
              IANA, "OAuth Token Introspection Response",
              <https://www.iana.org/assignments/oauth-parameters>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <https://www.rfc-editor.org/info/rfc4648>.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <https://www.rfc-editor.org/info/rfc6347>.

   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              <https://www.rfc-editor.org/info/rfc6749>.

   [RFC6750]  Jones, M. and D. Hardt, "The OAuth 2.0 Authorization
              Framework: Bearer Token Usage", RFC 6750,
              DOI 10.17487/RFC6750, October 2012,
              <https://www.rfc-editor.org/info/rfc6750>.

   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, "Media Type
              Specifications and Registration Procedures", BCP 13,
              RFC 6838, DOI 10.17487/RFC6838, January 2013,
              <https://www.rfc-editor.org/info/rfc6838>.

   [RFC6920]  Farrell, S., Kutscher, D., Dannewitz, C., Ohlman, B.,
              Keranen, A., and P. Hallam-Baker, "Naming Things with
              Hashes", RFC 6920, DOI 10.17487/RFC6920, April 2013,
              <https://www.rfc-editor.org/info/rfc6920>.

   [RFC7252]  Shelby, Z., Hartke, K., and C. Bormann, "The Constrained
              Application Protocol (CoAP)", RFC 7252,
              DOI 10.17487/RFC7252, June 2014,
              <https://www.rfc-editor.org/info/rfc7252>.

   [RFC7519]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web Token
              (JWT)", RFC 7519, DOI 10.17487/RFC7519, May 2015,
              <https://www.rfc-editor.org/info/rfc7519>.

   [RFC7662]  Richer, J., Ed., "OAuth 2.0 Token Introspection",
              RFC 7662, DOI 10.17487/RFC7662, October 2015,
              <https://www.rfc-editor.org/info/rfc7662>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8152]  Schaad, J., "CBOR Object Signing and Encryption (COSE)",
              RFC 8152, DOI 10.17487/RFC8152, July 2017,
              <https://www.rfc-editor.org/info/rfc8152>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8392]  Jones, M., Wahlstroem, E., Erdtman, S., and H. Tschofenig,
              "CBOR Web Token (CWT)", RFC 8392, DOI 10.17487/RFC8392,
              May 2018, <https://www.rfc-editor.org/info/rfc8392>.

   [RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, "Concise Data
              Definition Language (CDDL): A Notational Convention to
              Express Concise Binary Object Representation (CBOR) and
              JSON Data Structures", RFC 8610, DOI 10.17487/RFC8610,
              June 2019, <https://www.rfc-editor.org/info/rfc8610>.

   [RFC8693]  Jones, M., Nadalin, A., Campbell, B., Ed., Bradley, J.,
              and C. Mortimore, "OAuth 2.0 Token Exchange", RFC 8693,
              DOI 10.17487/RFC8693, January 2020,
              <https://www.rfc-editor.org/info/rfc8693>.

   [RFC8747]  Jones, M., Seitz, L., Selander, G., Erdtman, S., and H.
              Tschofenig, "Proof-of-Possession Key Semantics for CBOR
              Web Tokens (CWTs)", RFC 8747, DOI 10.17487/RFC8747, March
              2020, <https://www.rfc-editor.org/info/rfc8747>.

   [RFC8949]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", STD 94, RFC 8949,
              DOI 10.17487/RFC8949, December 2020,
              <https://www.rfc-editor.org/info/rfc8949>.

   [RFC9201]  Seitz, L., "Additional OAuth Parameters for Authentication
              and Authorization in Constrained Environments (ACE)",
              RFC 9201, DOI 10.17487/RFC9201, August 2022,
              <https://www.rfc-editor.org/info/rfc9201>.
```

---
### **9.2.  Informative References**

```text
   [BLE]      Bluetooth Special Interest Group, "Core Specification
              5.3", Section 4.4, July 2021,
              <https://www.bluetooth.com/specifications/bluetooth-core-
              specification/>.

   [DCAF]     Gerdes, S., Bergmann, O., and C. Bormann, "Delegated CoAP
              Authentication and Authorization Framework (DCAF)", Work
              in Progress, Internet-Draft, draft-gerdes-ace-dcaf-
              authorize-04, 19 October 2015,
              <https://datatracker.ietf.org/doc/html/draft-gerdes-ace-
              dcaf-authorize-04>.

   [Margi10impact]
              Margi, C., de Oliveira, B., de Sousa, G., Simplicio Jr,
              M., Barreto, P., Carvalho, T., Naeslund, M., and R. Gold,
              "Impact of Operating Systems on Wireless Sensor Networks
              (Security) Applications and Testbeds", Proceedings of the
              19th International Conference on Computer Communications
              and Networks, DOI 10.1109/ICCCN.2010.5560028, August 2010,
              <https://doi.org/10.1109/ICCCN.2010.5560028>.

   [MQTT5.0]  Banks, A., Briggs, E., Borgendale, K., and R. Gupta, "MQTT
              Version 5.0", OASIS Standard, March 2019,
              <https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-
              v5.0.html>.

   [OAUTH-RPCC]
              Seitz, L., Erdtman, S., and M. Tiloca, "Raw-Public-Key and
              Pre-Shared-Key as OAuth client credentials", Work in
              Progress, Internet-Draft, draft-erdtman-oauth-rpcc-00, 21
              November 2017, <https://datatracker.ietf.org/doc/html/
              draft-erdtman-oauth-rpcc-00>.

   [POP-KEY-DIST]
              Bradley, J., Hunt, P., Jones, M., Tschofenig, H., and M.
              Meszaros, "OAuth 2.0 Proof-of-Possession: Authorization
              Server to Client Key Distribution", Work in Progress,
              Internet-Draft, draft-ietf-oauth-pop-key-distribution-07,
              27 March 2019, <https://datatracker.ietf.org/doc/html/
              draft-ietf-oauth-pop-key-distribution-07>.

   [RFC4949]  Shirey, R., "Internet Security Glossary, Version 2",
              FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007,
              <https://www.rfc-editor.org/info/rfc4949>.

   [RFC6690]  Shelby, Z., "Constrained RESTful Environments (CoRE) Link
              Format", RFC 6690, DOI 10.17487/RFC6690, August 2012,
              <https://www.rfc-editor.org/info/rfc6690>.

   [RFC6819]  Lodderstedt, T., Ed., McGloin, M., and P. Hunt, "OAuth 2.0
              Threat Model and Security Considerations", RFC 6819,
              DOI 10.17487/RFC6819, January 2013,
              <https://www.rfc-editor.org/info/rfc6819>.

   [RFC7009]  Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, "OAuth
              2.0 Token Revocation", RFC 7009, DOI 10.17487/RFC7009,
              August 2013, <https://www.rfc-editor.org/info/rfc7009>.

   [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, "Terminology for
              Constrained-Node Networks", RFC 7228,
              DOI 10.17487/RFC7228, May 2014,
              <https://www.rfc-editor.org/info/rfc7228>.

   [RFC7521]  Campbell, B., Mortimore, C., Jones, M., and Y. Goland,
              "Assertion Framework for OAuth 2.0 Client Authentication
              and Authorization Grants", RFC 7521, DOI 10.17487/RFC7521,
              May 2015, <https://www.rfc-editor.org/info/rfc7521>.

   [RFC7591]  Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and
              P. Hunt, "OAuth 2.0 Dynamic Client Registration Protocol",
              RFC 7591, DOI 10.17487/RFC7591, July 2015,
              <https://www.rfc-editor.org/info/rfc7591>.

   [RFC7641]  Hartke, K., "Observing Resources in the Constrained
              Application Protocol (CoAP)", RFC 7641,
              DOI 10.17487/RFC7641, September 2015,
              <https://www.rfc-editor.org/info/rfc7641>.

   [RFC7744]  Seitz, L., Ed., Gerdes, S., Ed., Selander, G., Mani, M.,
              and S. Kumar, "Use Cases for Authentication and
              Authorization in Constrained Environments", RFC 7744,
              DOI 10.17487/RFC7744, January 2016,
              <https://www.rfc-editor.org/info/rfc7744>.

   [RFC7959]  Bormann, C. and Z. Shelby, Ed., "Block-Wise Transfers in
              the Constrained Application Protocol (CoAP)", RFC 7959,
              DOI 10.17487/RFC7959, August 2016,
              <https://www.rfc-editor.org/info/rfc7959>.

   [RFC8252]  Denniss, W. and J. Bradley, "OAuth 2.0 for Native Apps",
              BCP 212, RFC 8252, DOI 10.17487/RFC8252, October 2017,
              <https://www.rfc-editor.org/info/rfc8252>.

   [RFC8259]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, RFC 8259,
              DOI 10.17487/RFC8259, December 2017,
              <https://www.rfc-editor.org/info/rfc8259>.

   [RFC8414]  Jones, M., Sakimura, N., and J. Bradley, "OAuth 2.0
              Authorization Server Metadata", RFC 8414,
              DOI 10.17487/RFC8414, June 2018,
              <https://www.rfc-editor.org/info/rfc8414>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [RFC8516]  Keranen, A., ""Too Many Requests" Response Code for the
              Constrained Application Protocol", RFC 8516,
              DOI 10.17487/RFC8516, January 2019,
              <https://www.rfc-editor.org/info/rfc8516>.

   [RFC8613]  Selander, G., Mattsson, J., Palombini, F., and L. Seitz,
              "Object Security for Constrained RESTful Environments
              (OSCORE)", RFC 8613, DOI 10.17487/RFC8613, July 2019,
              <https://www.rfc-editor.org/info/rfc8613>.

   [RFC8628]  Denniss, W., Bradley, J., Jones, M., and H. Tschofenig,
              "OAuth 2.0 Device Authorization Grant", RFC 8628,
              DOI 10.17487/RFC8628, August 2019,
              <https://www.rfc-editor.org/info/rfc8628>.

   [RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [RFC9110]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/info/rfc9110>.

   [RFC9113]  Thomson, M., Ed. and C. Benfield, Ed., "HTTP/2", RFC 9113,
              DOI 10.17487/RFC9113, June 2022,
              <https://www.rfc-editor.org/info/rfc9113>.

   [RFC9147]  Rescorla, E., Tschofenig, H., and N. Modadugu, "The
              Datagram Transport Layer Security (DTLS) Protocol Version
              1.3", RFC 9147, DOI 10.17487/RFC9147, April 2022,
              <https://www.rfc-editor.org/info/rfc9147>.

   [RFC9202]  Gerdes, S., Bergmann, O., Bormann, C., Selander, G., and
              L. Seitz, "Datagram Transport Layer Security (DTLS)
              Profile for Authentication and Authorization for
              Constrained Environments (ACE)", RFC 9202,
              DOI 10.17487/RFC9202, August 2022,
              <https://www.rfc-editor.org/info/rfc9202>.

   [RFC9203]  Palombini, F., Seitz, L., Selander, G., and M. Gunnarsson,
              "The Object Security for Constrained RESTful Environments
              (OSCORE) Profile of the Authentication and Authorization
              for Constrained Environments (ACE) Framework", RFC 9203,
              DOI 10.17487/RFC9203, August 2022,
              <https://www.rfc-editor.org/info/rfc9203>.
```

---
# **Appendix A.  Design Justification**

이 섹션에서는 이 문서에 설명된 솔루션의 설계 결정에 대한 추가 정보를 제공합니다. 섹션 3에는 여러 구성 요소가 나열되어 있으며 그 중요성이 간략하게 요약되어 있습니다. OAuth 2.0을 그대로 사용하는 대신 이러한 구성 요소 중 일부를 제공하는 이유는 다음과 같습니다.

```text
   Common IoT constraints are:
```

저전력 라디오:

- 많은 IoT 장치에는 장시간 지속되어야 하는 작은 배터리가 장착되어 있습니다. 제한된 많은 무선 장치의 경우 가장 높은 에너지 비용은 메시지 전송 또는 수신과 관련됩니다\(AES에 비해 대략 10배\)\[Margi10impact\]. 따라서 전송 및 수신되는 메시지의 수와 크기를 최소화하는 등 전체 통신 오버헤드를 낮게 유지하는 것이 중요합니다. 이는 메시지 형식과 프로토콜 선택에 영향을 미칩니다. UDP 및 CBOR 인코딩 메시지를 통한 CoAP를 사용하면 이러한 측면 중 일부가 해결됩니다. 보안 프로토콜은 통신 오버헤드의 원인이 되며 경우에 따라 최적화될 수 있습니다. 예를 들어 인증 및 키 설정은 보안 요구 사항이 허용하는 경우 전송 또는 애플리케이션 계층 보안을 사용하여 신뢰할 수 있는 제3자가 보안 컨텍스트를 제공하는 것으로 대체될 수 있습니다.

낮은 CPU 속도:

- 일부 IoT 장치에는 인터넷에 있는 대부분의 최신 장치보다 훨씬 느린 프로세서가 장착되어 있습니다. 이는 일반적으로 장치가 적시에 수행할 수 있는 암호화 작업에 영향을 미치며, 이는 프로토콜 대기 시간 등에 영향을 미칩니다. 보안 요구 사항이 허용하는 경우 계산 비용이 더 많이 드는 공개 키 암호화 대신 대칭 키 암호화를 사용할 수 있지만 이를 위해서는 전송 계층 또는 애플리케이션 계층 보안을 사용하여 신뢰할 수 있는 제3자 지원 비밀 키 설정에 대한 지원이 필요할 수도 있습니다.

적은 양의 메모리:

- IoT 장치에 내장된 마이크로 컨트롤러에는 소량의 RAM과 플래시 메모리만 장착되어 있는 경우가 많으며, 이로 인해 수행할 수 있는 처리 종류와 해당 장치에 넣을 수 있는 코드의 양이 제한됩니다. 코드 크기를 줄이기 위해 해당 장치의 펌웨어에 더 적은 수의 프로토콜 구현을 적용할 수 있습니다. 이 경우 HTTP 대신 CoAP를, 공개키 암호화 대신 대칭키 암호화를, JSON 대신 CBOR을 사용할 수 있다. 인증 및 키 설정 프로토콜\(예: DTLS 핸드셰이크\)은 보조 키 설정과 비교하여 메모리 및 코드 공간에도 영향을 미칩니다.

사용자 인터페이스 제한:

- 리소스에 대한 액세스를 보호하는 것은 중요한 보안 기능이자 개인 정보 보호 기능입니다. 최종 사용자와 기업 고객은 IoT 장치에서 수집한 데이터나 IoT 장치가 제3자에게 제공할 수 있는 기능에 대한 액세스 권한을 부여하고 싶어하지 않을 수 있습니다. 풍부한 사용자 인터페이스를 통해 최종 사용자에게 권한을 요청하는 고전적인 접근 방식은 많은 IoT 배포 시나리오에서 작동하지 않기 때문에 이러한 기능은 스마트폰 및 태블릿과 같은 작업에 더 적합한 사용자 제어 장치에 위임되어야 합니다.

통신 제약:

- 특정 제한된 설정에서는 IoT 장치가 항상 특정 장치와 통신하지 못할 수도 있습니다. 해당 지역의 일반적인 연결 부족, 비용 문제 또는 보안상의 이유로\(예: 서비스 거부 공격의 진입점을 피하기 위해\) 장치가 절전 모드이거나 인터넷 연결이 끊어질 수 있습니다.

- 이 프레임워크의 기반이 되는 통신 상호 작용\(그림 1에 그래픽으로 표시됨\)은 다양한 프로토콜을 사용하여 수행될 수 있으며 통신 제약으로 인해 메시지 흐름의 모든 부분이 모든 애플리케이션에서 사용되는 것은 아닙니다. CoAP를 활용한 배포가 예상되지만 이 프레임워크는 이에 국한되지 않습니다. IP를 반드시 사용하지 않는 HTTP 또는 Bluetooth Smart 통신과 같은 다른 프로토콜도 사용할 수 있습니다. 후자는 다양한 인터페이스에 대한 애플리케이션 계층 보안의 필요성을 제기합니다.

이러한 제약 조건을 고려하여 우리는 다음과 같은 설계 결정을 내렸습니다.

CBOR, 코스, CWT:

- 이 프레임워크를 사용할 때 데이터 형식으로 CBOR \[RFC8949\]을 사용하는 것이 좋습니다. CBOR 데이터를 보호해야 하는 경우 COSE \[RFC8152\]를 사용하는 것이 좋습니다. 또한 자체 포함 토큰이 필요한 경우 CWT \[RFC8392\]를 사용하는 것이 좋습니다. 이러한 조치는 유선으로 전송되는 메시지 크기, 메모리에 보관해야 하는 데이터 개체의 RAM 크기, 장치가 지원해야 하는 라이브러리 크기를 줄이는 것을 목표로 합니다.\(SHOULD, SHOULD, SHOULD\)

CoAP:

- 본 프레임워크 사용 시 HTTP 대신 CoAP \[RFC7252\]를 사용하는 것을 권장합니다. 이는 Bluetooth 저에너지\(섹션 3.2 참조\)와 같이 제한된 장치를 특별히 겨냥한 다른 프로토콜의 사용을 배제하지 않습니다. 이는 다시 유선을 통해 전송되는 메시지 크기, 메모리에 보관해야 하는 데이터 개체의 RAM 크기, 장치가 지원해야 하는 라이브러리 크기를 줄이는 것을 목표로 합니다.\(SHOULD\)

접근 정보:

- 이 프레임워크는 AS가 액세스 토큰 응답에서 클라이언트에 반환하는 RS 관련 데이터에 대해 "액세스 정보"라는 이름을 정의합니다\(섹션 5.8.2 참조\). 이는 여러 프로필을 지원하는 강력한 클라이언트가 지원되는 프로필과 원시 공개 키를 모르는 RS와 상호 작용해야 하는 시나리오를 활성화하는 것을 목표로 합니다.

소유 증명:

- 이 프레임워크는 cnf 클레임 \[RFC8747\]을 사용하여 소유 증명 토큰을 사용합니다. cnf 클레임과 의미상 및 구문적으로 동일한 값 공간을 갖는 요청 매개변수 cnf 및 응답 매개변수 cnf는 확인 키를 요청하고 명시할 수 있도록 토큰 엔드포인트에 대해 정의됩니다. 이는 토큰 도난을 더 어렵게 만드는 것을 목표로 합니다. 토큰 도난은 특히 제한된 사용 사례와 관련이 있습니다. 통신은 종종 미들박스를 통해 전달되므로 전달자 토큰을 훔치고 이를 사용하여 무단 액세스를 얻을 수 있습니다.

인증 정보 끝점:

- 이 프레임워크는 액세스 토큰이 게시될 수 있는 authz-info 엔드포인트를 노출하여 RS에 액세스 토큰을 제공하는 새로운 방법을 도입합니다. 이는 요청 메시지의 크기와 RS의 코드 복잡성을 줄이는 것을 목표로 합니다. 많은 제한된 프로토콜이 물리 계층에서 심각한 메시지 크기 제한\(예: 100바이트 정도\)을 갖고 있기 때문에 요청 메시지의 크기는 문제가 됩니다. 이는 더 큰 패킷이 조각화되어 높은 패킷 손실률과 하나의 패킷이 손실될 경우 전체 메시지를 재전송해야 하는 필요성과 결합된다는 것을 의미합니다. 따라서 요청 전송과 액세스 토큰 전송을 분리하면 조각화를 줄이는 데 도움이 됩니다.

클라이언트 자격 증명 부여:

- 이 프레임워크에서는 부여 토큰을 생성하기 위해 리소스 소유자의 수동 개입이 불가능한 기계 간 통신 사용 사례에 클라이언트 자격 증명 부여를 사용하는 것이 권장됩니다. 그 의도는 자원 소유자가 대신 클라이언트 자신의 자격 증명을 기반으로 AS를 사용하여 권한 부여를 미리 준비하는 것입니다. 그러면 클라이언트는 \(수동 개입 없이\) AS로부터 액세스 토큰을 얻을 수 있습니다.\(SHOULD\)

내성:

- 이 프레임워크에서는 클라이언트가 새 액세스 토큰을 쉽게 얻을 수 없는 방식으로 제한되는 경우\(즉, AS와의 통신을 방해하는 연결 문제가 있는 경우\) 액세스 토큰 자체 검사를 사용하는 것이 권장됩니다. 이 경우 단순 참조가 될 수 있는 장기 토큰을 사용하는 것이 좋습니다. RS는 AS와 통신할 수 있다고 가정하므로 토큰 참조와 관련된 클레임을 학습하기 위해 자체 검사를 수행할 수 있습니다. 이러한 접근 방식의 장점은 리소스 소유자가 클라이언트와 접촉할 필요 없이 토큰 참조와 관련된 클레임을 변경하여 액세스 권한을 부여하거나 취소할 수 있다는 것입니다.\(SHOULD, SHOULD\)

---
# **Appendix B.  Roles and Responsibilities**

자원 소유자

- \* RS가 AS에 등록되어 있는지 확인하세요. 여기에는 RS가 지원하는 프로파일, token\_type, 범위 및 키 유형\(대칭/비대칭\)을 AS에 알리는 것이 포함됩니다. 또한 RS가 자신을 식별하는 대상이 누구인지 AS에 알립니다.

- \* 클라이언트가 RS를 담당하는 AS를 찾을 수 있는지 확인하십시오.

- \* 클라이언트 자격 증명 부여가 사용되는 경우 AS에 RS에 필요한 최신 액세스 제어 정책이 있는지 확인하십시오.

요청 당사자

- \* AS에 인증하는 데 필요한 자격 증명이 클라이언트에 제공되었는지 확인하십시오.

- \* 요청을 발행할 때 클라이언트가 요청 당사자의 보안 요구 사항\(예: 최소 통신 보안 요구 사항 또는 트러스트 앵커\)을 따르도록 구성되어 있는지 확인하십시오.

- \* 고객을 AS에 등록합니다. 여기에는 클라이언트에 대한 프로파일, token\_types 및 키 유형\(대칭/비대칭\)을 AS에 알리는 것이 포함됩니다.

인증 서버

- \* RS를 등록하고 해당 보안 컨텍스트를 관리합니다.

- \* 클라이언트 및 인증 자격 증명을 등록합니다.

- \* 리소스 소유자가 등록된 RS와 관련된 액세스 제어 정책을 구성하고 업데이트할 수 있도록 허용합니다.

- \* 클라이언트가 토큰을 요청할 수 있도록 토큰 끝점을 노출합니다.

- \* 토큰을 요청하려는 클라이언트를 인증합니다.

- \* RS에 구성된 인증 정책을 사용하여 토큰 요청을 처리합니다.

- \* 선택적으로 RS가 토큰 내부 검사 요청을 제출할 수 있도록 하는 내부 검사 끝점을 노출합니다.

- \* 내부 검사 엔드포인트를 제공하는 경우 내부 검사 응답을 원하는 RS를 인증합니다.

\* 내부 검사 엔드포인트를 제공하는 경우 프로세스 토큰

- 성찰 요청.

```text
      *  Optionally, handle token revocation.

      *  Optionally, provide discovery metadata.  See [RFC8414].

      *  Optionally, handle refresh tokens.
```

고객

- \* 요청 대상이 되는 RS를 담당하는 AS를 검색합니다.

- \* 토큰 요청을 제출합니다\(그림 1의 \(A\) 단계 참조\).

- - AS를 인증합니다.

- - 선택적으로\(미리 구성되지 않은 경우\) 요청의 대상이 될 RS, 리소스 및 작업을 지정합니다.

- - 원시 공개 키\(RPK\) 또는 인증서를 사용하는 경우 AS에 이 클라이언트에 대한 올바른 RPK 또는 인증서가 있는지 확인하십시오.

- \* 액세스 토큰 및 액세스 정보를 처리합니다\(그림 1의 \(B\) 단계 참조\).

- - 액세스 정보가 필요한 보안 매개변수\(예: PoP 키 또는 RS에서 지원하는 통신 보안 프로토콜에 대한 정보\)를 제공하는지 확인합니다.

- - 소유증명키를 안전하게 보관하세요.

- - AS에서 제공한 경우 새로 고침 토큰을 안전하게 저장합니다.

\* 토큰을 전송하고 RS에 요청\(단계 \(C\) 참조\)

- 그림 1\).

- - RS에 대해 인증합니다\(소유 증명 프로세스와 동시에 수행될 수 있음\).

- - AS에서 지정한 대로 토큰을 전송합니다\(기본값은 authz-info 끝점이며 대체 옵션은 프로필에서 지정됨\).

- - 사용 중인 프로필에 지정된 대로 소유 증명 절차를 수행합니다\(이미 인증 절차를 통해 처리되었을 수도 있음\).

- \* RS의 RS 응답\(그림 1의 단계 \(F\) 참조\)을 처리합니다.

리소스 서버

- \* 액세스 토큰을 제출하는 방법을 공개합니다. 기본적으로 이는 authz-info 엔드포인트입니다.

- \* 액세스 토큰을 처리합니다.

- - 토큰이 인식된 AS에서 나온 것인지 확인합니다.

- - 토큰의 무결성을 확인하세요.

- - 토큰이 이 RS에 적용되는지 확인합니다.

- - 토큰이 만료되지 않았는지 확인합니다\(토큰이 만료 정보를 제공하는 경우\).

- - 일치하는 요청의 컨텍스트에서 검색할 수 있도록 토큰을 저장합니다.

- 참고: 여기에 제안된 순서는 표준이 아닙니다. 동등한 결과에 도달하는 모든 프로세스를 사용할 수 있습니다. 주목할 만한 고려 사항은 비용이 많이 드는 암호화 작업\(예: 서명을 확인하기 전에 만료 확인 수행\)을 수행하기 전에 적용할 수 없거나 유효하지 않은 토큰을 신속하게 폐기하기 위해 초기에 저렴한 작업을 사용할 수 있는지 여부입니다.

- \* 요청을 처리합니다.

- - 클라이언트와의 통신 보안을 설정합니다.

- - 클라이언트를 인증합니다.

- - 클라이언트를 기존 토큰과 일치시킵니다.

- - 클라이언트에 속한 토큰이 실제로 요청된 작업을 승인하는지 확인하세요.

- - 선택적으로 자체 검사를 사용하여 일치하는 토큰이 여전히 유효한지 확인합니다\(가능한 경우\).

- \* 합의된 통신 보안 메커니즘에 따라 응답을 보냅니다.

\* 원시 공개 키와 같은 자격 증명을 안전하게 저장합니다.

- 액세스 토큰에 연결된 인증 또는 소유 증명 키.

---
# **Appendix C.  Requirements on Profiles**

이 섹션에는 프로파일 설계자의 편의를 위해 이 프레임워크의 프로파일에 대한 요구 사항이 나열되어 있습니다.

\* 선택적으로 클라이언트가 섹션 5.1 및 4에서 제안한 것과 다른 리소스에 액세스하기 위해 필요한 권한과 AS를 검색할 수 있는 새로운 방법을 정의합니다.

```text
   *  Optionally, specify new grant types (Section 5.4).
```

\* 선택적으로 클라이언트 인증서 사용을 클라이언트 자격 증명 유형으로 정의합니다\(섹션 5.5\).

\* 클라이언트와 RS가 사용해야 하는 통신 프로토콜\(예: CoAP\)을 지정합니다\(섹션 5 및 5.8.4.3\).

\* 클라이언트와 RS가 통신을 보호하기 위해 사용해야 하는 보안 프로토콜\(예: OSCORE 또는 DTLS\)을 지정합니다. 이는 암호화, 무결성 및 재생 보호를 제공해야 합니다\(섹션 5.8.4.3\).

\* 클라이언트와 RS가 상호 인증하는 방법을 지정합니다.

- \(섹션 4\).

\* 소유 증명 프로토콜을 지정하고 여러 개가 있는 경우 하나를 선택하는 방법을 지정합니다. 또한 특정 소유 증명 프로토콜\(섹션 5.8.4.2\)에서 지원하는 키 유형\(예: 대칭/비대칭\)을 지정합니다.

\* 고유한 ace\_profile 식별자를 지정합니다\(섹션 5.8.4.3\).

\* 내부 검사가 지원되는 경우 내부 검사를 위한 통신 및 보안 프로토콜을 지정합니다\(Section 5.9\).

\* 클라이언트와 AS 간의 상호작용을 위한 통신 및 보안 프로토콜을 지정합니다. 이는 암호화, 무결성 보호, 재생 보호 및 요청과 응답 간의 바인딩을 제공해야 합니다\(섹션 5 및 5.8\).

\* 오류 응답이 보호되는 방법을 포함하여 authz-info 엔드포인트가 보호되는 방법/여부를 지정합니다\(섹션 5.10.1\).

\* 선택적으로 authz-info 끝점\(섹션 5.10.1\) 이외의 다른 토큰 전송 방법을 정의합니다.

---
# **Appendix D.  Assumptions on AS Knowledge about the C and RS**

이 섹션에는 토큰 및 내부 검사 끝점에 대한 요청에 응답할 수 있도록 AS가 클라이언트 및 RS에 대해 알아야 하는 사항에 대한 가정이 나열되어 있습니다. 이 정보가 어떻게 확립되는지는 이 문서의 범위를 벗어납니다.

\* 클라이언트 또는 RS의 식별자입니다.

\* 클라이언트 또는 RS가 지원하는 프로필입니다.

\* RS가 지원하는 범위.

\* RS가 식별하는 청중.

\* 클라이언트 또는 RS가 지원하는 키 유형\(예: 사전 공유 대칭 키, 원시 공개 키, 키 길이 및 기타 키 매개변수\).

\* RS가 지원하는 액세스 토큰 유형\(예: CWT\).

\* RS가 CWT를 지원하는 경우 RS가 지원하는 암호화 래퍼\(예: 알고리즘, 키 랩 알고리즘 및 키 길이\)에 대한 COSE 매개변수입니다.

\* 이 RS에 발행된 액세스 토큰의 만료 시간입니다\(RS가 AS가 선택한 기본 시간을 수락하지 않는 한\).

\* 클라이언트와 AS\(있는 경우\) 간에 공유되는 대칭 키입니다.

\* RS와 AS\(있는 경우\) 간에 공유되는 대칭 키입니다.

\* 클라이언트 또는 RS\(있는 경우\)의 원시 공개 키입니다.

\* RS가 시간을 동기화했는지\(따라서 exp 청구를 사용할 수 있는지\) 여부.

---
# **Appendix E.  Differences to OAuth 2.0**

이 문서는 제한된 환경에 적합하도록 OAuth 2.0을 조정합니다. 이 섹션에는 OAuth 2.0의 규범적 요구 사항과의 주요 차이점이 나열되어 있습니다.

TLS 사용

- OAuth 2.0에서는 액세스 토큰을 요청할 때 AS와 클라이언트 간, 리소스에 액세스할 때 클라이언트와 RS 간, 내부 검사가 사용되는 경우 AS와 RS 간 통신을 보호하기 위해 TLS를 사용해야 합니다. 이 프레임워크에는 유사한 보안 속성이 필요하지만 TLS로 이를 실현할 필요는 없습니다. 섹션 5를 참조하세요.

grant\_type 매개변수의 카디널리티

- OAuth 2.0을 사용하는 클라이언트-AS 요청에서는 grant\_type 매개변수가 필요합니다\(\[RFC6749\]에 따라\). 이 프레임워크에서 이 매개변수는 선택사항입니다. 섹션 5.8.1을 참조하십시오.

범위 매개변수의 인코딩

- OAuth 2.0을 사용하는 클라이언트-AS 요청에서 범위 매개변수는 문자열로 인코딩됩니다\(\[RFC6749\]에 따라\). 이 프레임워크에서 이 매개변수는 바이트 문자열로 인코딩될 수도 있습니다. 섹션 5.8.1을 참조하십시오.

token\_type 매개변수의 카디널리티

- OAuth 2.0을 사용하는 AS-클라이언트 응답에서는 token\_type 매개변수가 필요합니다\(\[RFC6749\]에 따라\). 이 프레임워크에서 이 매개변수는 선택사항입니다. 섹션 5.8.2를 참조하십시오.

액세스 토큰 보관

- OAuth 2.0에서는 RS에 대한 모든 요청과 함께 액세스 토큰이 전송될 수 있습니다. 액세스 토큰의 정확한 사용은 애플리케이션의 의미와 애플리케이션에서 사용하는 세션 관리 개념에 따라 다릅니다. 이 프레임워크에서 RS는 나중에 사용할 수 있도록 이러한 토큰을 저장할 수 있어야 합니다. 섹션 5.10.1을 참조하십시오.

---
# **Appendix F.  Deployment Examples**

부록 A에 표시된 것처럼 매우 다양한 IoT 배포가 있으며, 이 섹션에서는 몇 가지 일반적인 변형을 중점적으로 설명합니다. 이 섹션은 규범적인 것은 아니지만 프레임워크를 적용할 수 있는 방법을 보여줍니다.

각 배포 변형에 대해 클라이언트, 리소스 서버 및 인증 서버 간에 가능한 보안 설정이 많이 있습니다. 다음 하위 섹션의 주요 초점은 RS가 호스팅하는 리소스에 대한 클라이언트 요청 인증이 수행되는 방법에 있습니다. 이를 위해서는 클라이언트와 RS 간의 요청 및 응답 보안을 고려해야 합니다.

참고: 요청 및 응답의 예에는 CBOR 진단 표기법이 사용됩니다.

---
### **F.1.  Local Token Validation**

본 시나리오에서는 리소스 서버가 오프라인인 경우, 즉 접근 요청 시 AS에 연결되어 있지 않은 경우를 고려한다. 이 액세스 절차에는 그림 1의 \(A\), \(B\), \(C\) 및 \(F\) 단계가 포함됩니다.

리소스 서버는 로컬에서 액세스 토큰을 확인할 수 있어야 하므로 자체 포함 액세스 토큰을 사용해야 합니다.

이 예에서는 클라이언트, 인증 서버, 리소스 서버 역할을 하는 온도 센서 간의 상호 작용을 보여줍니다. 메시지 교환 A와 B는 그림 11에 나와 있습니다.

A: 클라이언트는 먼저 RS와의 통신 보안에 사용되는 공개-개인 키 쌍을 생성합니다.

- 클라이언트는 AS의 토큰 엔드포인트에 CoAP POST 요청을 보냅니다. 이 요청의 보안은 전송 또는 애플리케이션 계층일 수 있습니다. 정의할 것은 통신 보안 프로필에 달려 있습니다. 이 예에서는 클라이언트와 AS 모두 DTLS 등을 통해 상호 인증을 수행했다고 가정합니다. 요청에는 클라이언트의 공개 키와 온도 센서가 자신을 식별하는 값인 "tempSensorInLivingRoom"으로 설정된 대상 매개변수가 포함되어 있습니다. AS는 요청을 평가하고 클라이언트가 리소스에 액세스할 수 있는 권한을 부여합니다.

B: AS는 액세스 토큰을 포함한 액세스 정보가 포함된 2.05\(콘텐츠\) 응답으로 응답합니다. PoP 액세스 토큰에는 클라이언트의 공개 키가 포함되고, 액세스 정보에는 RS의 공개 키가 포함됩니다. 통신 보안을 위해 이 예에서는 클라이언트와 RS 간에 DTLS RawPublicKey를 사용합니다. 발급된 토큰은 도난당한 클라이언트 자격 증명을 사용하는 공격을 완화하기 위해 짧은 유효 시간, 즉 iat에 가까운 만료 시간을 갖습니다. 토큰에는 온도 장치 소유자가 누릴 수 있는 인증된 액세스 권한과 같은 범위 등의 클레임이 포함됩니다. 이 예에서 AS가 발행한 범위 클레임은 키 소유를 증명할 수 있는 토큰 소유자가 /temper 리소스에 대한 GET 요청과 /firmware 리소스에 대한 POST 요청을 만들 수 있는 권한이 있음을 RS에 알립니다. 범위 청구의 구문과 의미는 애플리케이션마다 다릅니다.

- 참고: 이 예에서는 클라이언트가 액세스하려는 리소스를 알고 있으므로 액세스 토큰에 대한 특정 대상 및 범위 클레임을 요청할 수 있다고 가정합니다.

```text
            Authorization
     Client    Server
       |         |
       |<=======>| DTLS Connection Establishment
       |         |   and mutual authentication
       |         |
   A:  +-------->| Header: POST (Code=0.02)
       |  POST   | Uri-Path:"token"
       |         | Content-Format: application/ace+cbor
       |         | Payload: <Request-Payload>
       |         |
   B:  |<--------+ Header: 2.05 Content
       |  2.05   | Content-Format: application/ace+cbor
       |         | Payload: <Response-Payload>
       |         |

       Figure 11: Token Request and Response Using Client Credentials
```

Request-Payload와 Response-Payload에 포함된 정보는 그림 12에 나와 있습니다. \[RFC9201\]의 매개변수 rs\_cnf는 리소스 서버의 공개 키에 대해 클라이언트에 알리는 데 사용됩니다.

```text
   Request-Payload :
   {
     / audience / 5 : "tempSensorInLivingRoom",
     / client_id / 24 : "myclient",
     / req_cnf / 4 : {
     / COSE_Key / 1 : {
         / kid / 2 : b64'1Bg8vub9tLe1gHMzV76e',
         / kty / 1 : 2 / EC2 /,
         / crv / -1 : 1 / P-256 /,
         / x / -2 : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
         / y / -3 : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
       }
     }
   }

   Response-Payload :
   {
     / access_token / 1 : b64'0INDoQEKoQVNKkXfb7xaWqMT'/ .../,
     / rs_cnf / 41 : {
       / COSE_Key / 1 : {
         / kid / 2 : b64'c29tZSBwdWJsaWMga2V5IGlk',
         / kty / 1 : 2 / EC2 /,
         / crv / -1 : 1 / P-256 /,
         / x / -2   : b64'MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4',
         / y / -3   : b64'4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM'
       }
     }
   }

              Figure 12: Request and Response Payload Details
```

액세스 토큰의 내용은 그림 13에 나와 있습니다.

```text
   {
     / aud / 3 : "tempSensorInLivingRoom",
     / iat / 6 : 1563451500,
     / exp / 4 : 1563453000,
     / scope / 9 :  "temperature_g firmware_p",
     / cnf / 8 : {
       / COSE_Key / 1 : {
         / kid / 2 : b64'1Bg8vub9tLe1gHMzV76e',
         / kty / 1 : 2 / EC2 /,
         / crv / -1 : 1 / P-256 /,
         / x / -2 : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
         / y / -3 : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
       }
     }
   }
```

- 그림 13: 클라이언트의 공개 키를 포함하는 액세스 토큰

메시지 C와 F는 그림 14와 15에 나와 있습니다.

C: 그런 다음 클라이언트는 PoP 액세스 토큰을 RS의 authz-info 엔드포인트로 보냅니다. 이는 일반 CoAP POST 요청입니다. 즉, AS와 RS 간에 토큰이 무결성으로 보호되므로 클라이언트와 RS 간에 전송 또는 애플리케이션 계층 보안이 사용되지 않습니다. RS는 PoP 액세스 토큰이 알려지고 신뢰할 수 있는 AS에 의해 생성되었으며 이 RS에 적용되고 유효한지 확인합니다. RS는 PoP 액세스 토큰에 포함된 이 클라이언트에 대한 인증 정보와 함께 보안 컨텍스트를 캐시합니다.

```text
              Resource
    Client     Server
       |         |
   C:  +-------->| Header: POST (Code=0.02)
       |  POST   | Uri-Path:"authz-info"
       |         | Payload: 0INDoQEKoQVN ...
       |         |
       |<--------+ Header: 2.04 Changed
       |  2.04   |
       |         |
```

- 그림 14: RS에 대한 액세스 토큰 프로비저닝

클라이언트와 RS는 B 및 C 단계에서 설정된 원시 공개 키를 사용하여 DTLS 핸드셰이크를 실행합니다.

클라이언트는 DTLS를 통해 RS의 /온도에 CoAP GET 요청을 보냅니다. RS는 이전에 설정된 보안 컨텍스트를 기반으로 요청이 승인되었는지 확인합니다.

F: RS는 리소스 표현을 페이로드로 포함하는 CoAP 2.05 콘텐츠 응답으로 동일한 DTLS 채널을 통해 응답합니다.

```text
              Resource
    Client     Server
       |         |
       |<=======>| DTLS Connection Establishment
       |         |   using Raw Public Keys
       |         |
       +-------->| Header: GET (Code=0.01)
       | GET     | Uri-Path: "temperature"
       |         |
       |         |
       |         |
   F:  |<--------+ Header: 2.05 Content
       | 2.05    | Payload: <sensor value>
       |         |
```

- 그림 15: DTLS로 보호되는 리소스 요청 및 응답

---
### **F.2.  Introspection Aided Token Validation**

본 배포 시나리오에서는 접속 요청 시점에 클라이언트가 AS에 접속할 수 없는 반면, RS는 백엔드 인프라에 연결되어 있다고 가정한다. 따라서 RS는 토큰 자체 검사를 활용할 수 있습니다. 이 액세스 절차에는 그림 1의 \(A\)-\(F\) 단계가 포함되지만 클라이언트가 AS에 연결되어 있는 단계 동안 \(A\) 및 \(B\) 단계가 수행되었다고 가정합니다.

클라이언트는 적어도 일정 기간 동안 오프라인 상태라고 가정하므로 사전 프로비저닝된 액세스 토큰은 오랫동안 유지되어야 합니다. 클라이언트가 제한되어 있으므로 토큰은 자체 포함되지 않고\(즉, CWT가 아님\) 참조일 뿐입니다. 리소스 서버는 자체 연결을 사용하여 아래 예에 표시된 자체 검사를 통해 액세스 토큰과 관련된 클레임에 대해 알아봅니다.

이 예에서는 오프라인 클라이언트\(열쇠\), RS\(온라인 잠금\) 및 AS 간의 상호 작용이 표시됩니다. 클라이언트가 AS에 액세스할 수 있는 프로비저닝 단계가 있다고 가정합니다. 이는 그림 16에 표시된 메시지 교환 A와 B에 해당합니다.

리소스 소유자의 승인 동의는 사전 구성될 수 있지만 리소스 소유자와의 대화형 흐름을 통해 제공될 수도 있습니다. 전자열쇠 사례에 대한 이에 대한 예로는 리소스 소유자가 연결된 자동차를 가지고 있고 자동차에 사용할 일반 키를 구입하는 경우가 있습니다. 전자열쇠를 승인하기 위해 소유자는 이를 장치에 대한 UI를 제공하는 컴퓨터에 연결합니다. 그 후 OAuth 2.0 암시적 흐름을 사용하여 자동차 제조업체의 AS에서 자동차 키를 인증할 수 있습니다.

참고: 이 예에서 클라이언트는 액세스 시 토큰 요청이 전송되지 않으므로 액세스하는 데 사용될 정확한 문을 알지 못합니다. 따라서 범위와 대상 매개 변수는 처음부터 상당히 넓게 설정되는 반면, 액세스되는 특정 RS에 대한 클레임을 좁히는 맞춤형 값은 자체 검사 단계에서 해당 RS에 제공될 수 있습니다.

A: 클라이언트는 AS의 토큰 엔드포인트에 CoAP POST 요청을 보냅니다. 요청에는 개별 도어가 연결된 물리적 액세스 제어 시스템을 식별하는 값인 "PACS1337"\(PACS\)로 설정된 대상 매개변수가 포함되어 있습니다. AS는 특정 클라이언트 및 대상 고객과 일치시킬 수 있는 불투명 문자열로 액세스 토큰을 생성합니다. 또한 대칭 소유 증명 키를 생성합니다. 클라이언트와 AS 간의 통신 보안 및 인증은 사전 공유된 보안 컨텍스트\(사전 공유 키\(PSK\), RPK 또는 인증서\)를 사용하여 전송 계층에서\(예: DTLS를 통해\) 제공되는 것으로 가정됩니다.

B: AS는 액세스 토큰 및 대칭 소유 증명 키를 포함한 액세스 정보를 페이로드로 포함하는 CoAP 2.05 콘텐츠 응답으로 응답합니다. C와 RS 간의 통신 보안은 DTLS와 PreSharedKey입니다. PoP 키는 PreSharedKey로 사용됩니다.

참고: 이 예에서는 다중 RS 대상에 대해 대칭 키를 사용하고 있는데 이는 일반적으로 권장되지 않습니다\(섹션 6.9 참조\). 그러나 이 경우 모든 문이 동일한 물리적 접근 통제 시스템의 일부이기 때문에 위험은 허용 가능한 것으로 간주됩니다. 따라서 악의적인 RS가 다른 RS를 향해 클라이언트를 가장할 위험은 낮습니다.

```text
            Authorization
    Client     Server
       |         |
       |<=======>| DTLS Connection Establishment
       |         |   and mutual authentication
       |         |
   A:  +-------->| Header: POST (Code=0.02)
       |  POST   | Uri-Path:"token"
       |         | Content-Format: application/ace+cbor
       |         | Payload: <Request-Payload>
       |         |
   B:  |<--------+ Header: 2.05 Content
       |         | Content-Format: application/ace+cbor
       |  2.05   | Payload: <Response-Payload>
       |         |

       Figure 16: Token Request and Response Using Client Credentials
```

Request-Payload와 Response-Payload에 포함된 정보는 그림 17과 같습니다.

```text
   Request-Payload:
   {
     / client_id / 24 : "keyfob",
     / audience / 5   : "PACS1337"
   }

   Response-Payload:
   {
     / access_token / 1 : b64'VGVzdCB0b2tlbg',
     / cnf / 8 : {
       / COSE_Key / 1 : {
         / kid / 2 : b64'c29tZSBwdWJsaWMga2V5IGlk',
         / kty / 1 : 4 / Symmetric /,
         / k / -1  : b64'ZoRSOrFzN_FzUA5XKMYoVHyzff5oRJxl-IXRtztJ6uE'
       }
     }
   }
```

- 그림 17: C 오프라인에 대한 요청 및 응답 페이로드

이 경우 액세스 토큰은 AS의 인증 정보를 참조하는 불투명 바이트 문자열입니다.

C: 다음으로 클라이언트는 RS의 authz-info 엔드포인트에 액세스 토큰을 게시합니다. 이는 일반 CoAP 요청입니다. 즉, 클라이언트와 RS 사이에 DTLS가 없습니다. 토큰은 불투명한 문자열이므로 RS는 자체적으로 이를 확인할 수 없으므로 E 단계 이후까지 상태 코드로 클라이언트에 응답하는 것을 연기합니다.

D: RS는 CoAP POST 요청을 사용하여 AS의 내부 검사 엔드포인트로 토큰을 보냅니다. 이 예에서는 RS와 AS가 DTLS 클라이언트 역할을 하는 RS와 미리 공유된 보안 컨텍스트\(PSK, RPK 또는 인증서\)를 사용하여 상호 인증을 수행했다고 가정합니다.

E: AS는 토큰에 대한 매개변수가 포함된 자체 검사 응답\(2.05 콘텐츠\)을 제공합니다. 여기에는 RS가 단계 F에서 클라이언트의 소유 증명을 확인할 수 있도록 하는 확인 키\(cnf\) 매개변수가 포함됩니다. 그림 19의 예에서는 사전 설정된 키\(예: 이전 토큰에 대해 클라이언트와 RS가 사용하는 키\)를 가정합니다. \)는 이제 키 식별자 kid로만 참조됩니다.

- RS는 메시지 E를 수신한 후 C 단계에서 클라이언트의 POST에 CoAP 응답 코드 2.01\(Created\)로 응답합니다.

```text
              Resource
     Client    Server
       |         |
   C:  +-------->| Header: POST (T=CON, Code=0.02)
       |  POST   | Uri-Path:"authz-info"
       |         | Payload: b64'VGVzdCB0b2tlbg'
       |         |
       |         |     Authorization
       |         |       Server
       |         |          |
       |      D: +--------->| Header: POST (Code=0.02)
       |         |  POST    | Uri-Path: "introspect"
       |         |          | Content-Format: application/ace+cbor
       |         |          | Payload: <Request-Payload>
       |         |          |
       |      E: |<---------+ Header: 2.05 Content
       |         |  2.05    | Content-Format: application/ace+cbor
       |         |          | Payload: <Response-Payload>
       |         |          |
       |         |
       |<--------+ Header: 2.01 Created
       |  2.01   |
       |         |

              Figure 18: Token Introspection for the C Offline
```

Request-Payload와 Response-Payload에 포함된 정보는 그림 19에 나와 있습니다.

```text
   Request-Payload:
   {
     / token /     11 : b64'VGVzdCB0b2tlbg',
     / client_id / 24 : "FrontDoor"
   }

   Response-Payload:
   {
     / active / 10 : true,
     / aud /     3 : "lockOfDoor4711",
     / scope /   9 : "open close",
     / iat /     6 : 1563454000,
     / cnf /     8 : {
            / kid / 3 : b64'c29tZSBwdWJsaWMga2V5IGlk'
     }
   }
```

- 그림 19: 자체 검사를 위한 요청 및 응답 페이로드

클라이언트는 대칭 PoP 키를 사용하여 RS에 대한 DTLS PreSharedKey 보안 연결을 설정합니다. CoAP 요청 PUT는 RS의 uri-path /state로 전송되어 도어 상태를 잠김으로 변경합니다.

F: RS는 보안 DTLS 채널을 통해 적절한 응답으로 응답합니다.

```text
              Resource
     Client    Server
       |         |
       |<=======>| DTLS Connection Establishment
       |         |   using Pre Shared Key
       |         |
       +-------->| Header: PUT (Code=0.03)
       | PUT     | Uri-Path: "state"
       |         | Payload: <new state for the lock>
       |         |
   F:  |<--------+ Header: 2.04 Changed
       | 2.04    | Payload: <new state for the lock>
       |         |

        Figure 20: Resource Request and Response Protected by OSCORE
```

---
# **Acknowledgments**

이 문서는 IETF ACE Working Group의 산물입니다.

IoT 시나리오에서 OAuth 2.0 및 UMA\(Unlicensed Mobile Access\) 사용에 기여한 Eve Maler, 토론 입력에 대해 Robert Taylor, 이 제안의 이전 제안에 대한 입력에 대해 Mališa Vučinić에게 감사드립니다.

"\[POP-KEY-DIST\]OAuth 2.0 소유 증명: 인증 서버에서 클라이언트 키 배포까지" \[POP-KEY-DIST\]의 작성자에게 감사드립니다. 여기에서 보안 고려 사항의 일부를 복사했습니다.

"위임된 CoAP 인증 및 권한 부여 프레임워크\(DCAF\)" \[DCAF\]\(섹션 5.1 참조\)의 AS 검색 및 다중 액세스 토큰에 대한 고려 사항에 대한 작업을 기여한 Stefanie Gerdes, Olaf Bergmann 및 Carsten Bormann에게 감사드립니다.

포괄적인 검토를 해주신 Jim Schaad와 Mike Jones에게 감사드립니다.

이 작업과 관련된 다양한 질문에 대한 의견을 주신 Benjamin Kaduk에게 감사드립니다.

매우 유용한 리뷰 의견을 주신 Cigdem Sengul에게 감사드립니다.

CoRE 리소스 유형 레지스트리에 텍스트를 제공한 Carsten Bormann에게 감사드립니다.

부록 E\(내용 포함\)를 제안한 Roman Danyliw에게 감사드립니다.

Ludwig Seitz와 Göran Selander는 Vinnova의 자금 지원을 받아 CelticPlus 프로젝트 CyberWI의 일부로 이 문서를 작업했습니다. Ludwig Seitz는 또한 CelticNext 프로젝트 CRITISEC의 맥락에서 Vinnova로부터 이 작업에 대한 추가 자금을 받았습니다.

---
# **Authors' Addresses**

```text
   Ludwig Seitz
   Combitech
   Djäknegatan 31
   SE-211 35 Malmö
   Sweden
   Email: ludwig.seitz@combitech.com

   Göran Selander
   Ericsson
   SE-164 80 Kista
   Sweden
   Email: goran.selander@ericsson.com

   Erik Wahlstroem
   Sweden
   Email: erik@wahlstromstekniska.se

   Samuel Erdtman
   Spotify AB
   Birger Jarlsgatan 61, 4tr
   SE-113 56 Stockholm
   Sweden
   Email: erdtman@spotify.com

   Hannes Tschofenig
   Arm Ltd.
   6067 Absam
   Austria
   Email: Hannes.Tschofenig@arm.com
```
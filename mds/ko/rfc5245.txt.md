

```text
Internet Engineering Task Force (IETF)                      J. Rosenberg
Request for Comments: 5245                                   jdrosen.net
Obsoletes: 4091, 4092                                         April 2010
Category: Standards Track
ISSN: 2070-1721

             Interactive Connectivity Establishment (ICE):
     A Protocol for Network Address Translator (NAT) Traversal for
                         Offer/Answer Protocols
```

---
# **Abstract**

이 문서에서는 제안/응답 모델을 사용하여 설정된 UDP 기반 멀티미디어 세션에 대한 NAT\(Network Address Translator\) 통과를 위한 프로토콜을 설명합니다. 이 프로토콜을 ICE\(대화형 연결 설정\)라고 합니다. ICE는 STUN\(Session Traversal Utilities for NAT\) 프로토콜과 그 확장인 Traversal Using Relay NAT\(TURN\)을 사용합니다. ICE는 SIP\(Session Initiation Protocol\)와 같은 제안/응답 모델을 활용하는 모든 프로토콜에서 사용할 수 있습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc5245에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2010 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   6
   2.  Overview of ICE . . . . . . . . . . . . . . . . . . . . . . .   7
     2.1.  Gathering Candidate Addresses . . . . . . . . . . . . . .   9
     2.2.  Connectivity Checks . . . . . . . . . . . . . . . . . . .  11
     2.3.  Sorting Candidates  . . . . . . . . . . . . . . . . . . .  12
     2.4.  Frozen Candidates . . . . . . . . . . . . . . . . . . . .  13
     2.5.  Security for Checks . . . . . . . . . . . . . . . . . . .  14
     2.6.  Concluding ICE  . . . . . . . . . . . . . . . . . . . . .  14
     2.7.  Lite Implementations  . . . . . . . . . . . . . . . . . .  16
   3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  16
   4.  Sending the Initial Offer . . . . . . . . . . . . . . . . . .  19
     4.1.  Full Implementation Requirements  . . . . . . . . . . . .  19
       4.1.1.  Gathering Candidates  . . . . . . . . . . . . . . . .  19
         4.1.1.1.  Host Candidates . . . . . . . . . . . . . . . . .  20
         4.1.1.2.  Server Reflexive and Relayed Candidates . . . . .  20
         4.1.1.3.  Computing Foundations . . . . . . . . . . . . . .  22
         4.1.1.4.  Keeping Candidates Alive  . . . . . . . . . . . .  22
       4.1.2.  Prioritizing Candidates . . . . . . . . . . . . . . .  22
         4.1.2.1.  Recommended Formula . . . . . . . . . . . . . . .  23
         4.1.2.2.  Guidelines for Choosing Type and Local
                   Preferences . . . . . . . . . . . . . . . . . . .  23
       4.1.3.  Eliminating Redundant Candidates  . . . . . . . . . .  25
       4.1.4.  Choosing Default Candidates . . . . . . . . . . . . .  25
     4.2.  Lite Implementation Requirements  . . . . . . . . . . . .  25
     4.3.  Encoding the SDP  . . . . . . . . . . . . . . . . . . . .  26
   5.  Receiving the Initial Offer . . . . . . . . . . . . . . . . .  28
     5.1.  Verifying ICE Support . . . . . . . . . . . . . . . . . .  28
     5.2.  Determining Role  . . . . . . . . . . . . . . . . . . . .  29
     5.3.  Gathering Candidates  . . . . . . . . . . . . . . . . . .  30
     5.4.  Prioritizing Candidates . . . . . . . . . . . . . . . . .  30
     5.5.  Choosing Default Candidates . . . . . . . . . . . . . . .  31
     5.6.  Encoding the SDP  . . . . . . . . . . . . . . . . . . . .  31
     5.7.  Forming the Check Lists . . . . . . . . . . . . . . . . .  31
       5.7.1.  Forming Candidate Pairs . . . . . . . . . . . . . . .  31
       5.7.2.  Computing Pair Priority and Ordering Pairs  . . . . .  34
       5.7.3.  Pruning the Pairs . . . . . . . . . . . . . . . . . .  34
       5.7.4.  Computing States  . . . . . . . . . . . . . . . . . .  34
     5.8.  Scheduling Checks . . . . . . . . . . . . . . . . . . . .  37
   6.  Receipt of the Initial Answer . . . . . . . . . . . . . . . .  39
     6.1.  Verifying ICE Support . . . . . . . . . . . . . . . . . .  39
     6.2.  Determining Role  . . . . . . . . . . . . . . . . . . . .  39
     6.3.  Forming the Check List  . . . . . . . . . . . . . . . . .  40
     6.4.  Performing Ordinary Checks  . . . . . . . . . . . . . . .  40
   7.  Performing Connectivity Checks  . . . . . . . . . . . . . . .  40
     7.1.  STUN Client Procedures  . . . . . . . . . . . . . . . . .  40
       7.1.1.  Creating Permissions for Relayed Candidates . . . . .  40
       7.1.2.  Sending the Request . . . . . . . . . . . . . . . . .  40
         7.1.2.1.  PRIORITY and USE-CANDIDATE  . . . . . . . . . . .  41
         7.1.2.2.  ICE-CONTROLLED and ICE-CONTROLLING  . . . . . . .  41
         7.1.2.3.  Forming Credentials . . . . . . . . . . . . . . .  41
         7.1.2.4.  DiffServ Treatment  . . . . . . . . . . . . . . .  42
       7.1.3.  Processing the Response . . . . . . . . . . . . . . .  42
         7.1.3.1.  Failure Cases . . . . . . . . . . . . . . . . . .  42
         7.1.3.2.  Success Cases . . . . . . . . . . . . . . . . . .  43
           7.1.3.2.1.  Discovering Peer Reflexive Candidates . . . .  43
           7.1.3.2.2.  Constructing a Valid Pair . . . . . . . . . .  44
           7.1.3.2.3.  Updating Pair States  . . . . . . . . . . . .  45
           7.1.3.2.4.  Updating the Nominated Flag . . . . . . . . .  46
         7.1.3.3.  Check List and Timer State Updates  . . . . . . .  46
     7.2.  STUN Server Procedures  . . . . . . . . . . . . . . . . .  46
       7.2.1.  Additional Procedures for Full Implementations  . . .  47
         7.2.1.1.  Detecting and Repairing Role Conflicts  . . . . .  47
         7.2.1.2.  Computing Mapped Address  . . . . . . . . . . . .  48
         7.2.1.3.  Learning Peer Reflexive Candidates  . . . . . . .  49
         7.2.1.4.  Triggered Checks  . . . . . . . . . . . . . . . .  49
         7.2.1.5.  Updating the Nominated Flag . . . . . . . . . . .  50
       7.2.2.  Additional Procedures for Lite Implementations  . . .  51
   8.  Concluding ICE Processing . . . . . . . . . . . . . . . . . .  51
     8.1.  Procedures for Full Implementations . . . . . . . . . . .  51
       8.1.1.  Nominating Pairs  . . . . . . . . . . . . . . . . . .  51
         8.1.1.1.  Regular Nomination  . . . . . . . . . . . . . . .  52
         8.1.1.2.  Aggressive Nomination . . . . . . . . . . . . . .  52
       8.1.2.  Updating States . . . . . . . . . . . . . . . . . . .  53
     8.2.  Procedures for Lite Implementations . . . . . . . . . . .  54
       8.2.1.  Peer Is Full  . . . . . . . . . . . . . . . . . . . .  54
       8.2.2.  Peer Is Lite  . . . . . . . . . . . . . . . . . . . .  55
     8.3.  Freeing Candidates  . . . . . . . . . . . . . . . . . . .  56
       8.3.1.  Full Implementation Procedures  . . . . . . . . . . .  56
       8.3.2.  Lite Implementation Procedures  . . . . . . . . . . .  56
   9.  Subsequent Offer/Answer Exchanges . . . . . . . . . . . . . .  56
     9.1.  Generating the Offer  . . . . . . . . . . . . . . . . . .  57
       9.1.1.  Procedures for All Implementations  . . . . . . . . .  57
         9.1.1.1.  ICE Restarts  . . . . . . . . . . . . . . . . . .  57
         9.1.1.2.  Removing a Media Stream . . . . . . . . . . . . .  58
         9.1.1.3.  Adding a Media Stream . . . . . . . . . . . . . .  58
       9.1.2.  Procedures for Full Implementations . . . . . . . . .  58
         9.1.2.1.  Existing Media Streams with ICE Running . . . . .  58
         9.1.2.2.  Existing Media Streams with ICE Completed . . . .  59
       9.1.3.  Procedures for Lite Implementations . . . . . . . . .  59
         9.1.3.1.  Existing Media Streams with ICE Running . . . . .  59
         9.1.3.2.  Existing Media Streams with ICE Completed . . . .  60
     9.2.  Receiving the Offer and Generating an Answer  . . . . . .  60
       9.2.1.  Procedures for All Implementations  . . . . . . . . .  60
         9.2.1.1.  Detecting ICE Restart . . . . . . . . . . . . . .  60
         9.2.1.2.  New Media Stream  . . . . . . . . . . . . . . . .  61
         9.2.1.3.  Removed Media Stream  . . . . . . . . . . . . . .  61
       9.2.2.  Procedures for Full Implementations . . . . . . . . .  61
         9.2.2.1.  Existing Media Streams with ICE Running and no
                   remote-candidates . . . . . . . . . . . . . . . .  61
         9.2.2.2.  Existing Media Streams with ICE Completed and
                   no remote-candidates  . . . . . . . . . . . . . .  61
         9.2.2.3.  Existing Media Streams and remote-candidates  . .  61
       9.2.3.  Procedures for Lite Implementations . . . . . . . . .  62
     9.3.  Updating the Check and Valid Lists  . . . . . . . . . . .  63
       9.3.1.  Procedures for Full Implementations . . . . . . . . .  63
         9.3.1.1.  ICE Restarts  . . . . . . . . . . . . . . . . . .  63
         9.3.1.2.  New Media Stream  . . . . . . . . . . . . . . . .  63
         9.3.1.3.  Removed Media Stream  . . . . . . . . . . . . . .  64
         9.3.1.4.  ICE Continuing for Existing Media Stream  . . . .  64
       9.3.2.  Procedures for Lite Implementations . . . . . . . . .  64
   10. Keepalives  . . . . . . . . . . . . . . . . . . . . . . . . .  65
   11. Media Handling  . . . . . . . . . . . . . . . . . . . . . . .  66
     11.1. Sending Media . . . . . . . . . . . . . . . . . . . . . .  66
       11.1.1. Procedures for Full Implementations . . . . . . . . .  66
       11.1.2. Procedures for Lite Implementations . . . . . . . . .  67
       11.1.3. Procedures for All Implementations  . . . . . . . . .  67
     11.2. Receiving Media . . . . . . . . . . . . . . . . . . . . .  67
   12. Usage with SIP  . . . . . . . . . . . . . . . . . . . . . . .  68
     12.1. Latency Guidelines  . . . . . . . . . . . . . . . . . . .  68
       12.1.1. Offer in INVITE . . . . . . . . . . . . . . . . . . .  68
       12.1.2. Offer in Response . . . . . . . . . . . . . . . . . .  70
     12.2. SIP Option Tags and Media Feature Tags  . . . . . . . . .  70
     12.3. Interactions with Forking . . . . . . . . . . . . . . . .  70
     12.4. Interactions with Preconditions . . . . . . . . . . . . .  70
     12.5. Interactions with Third Party Call Control  . . . . . . .  71
   13. Relationship with ANAT  . . . . . . . . . . . . . . . . . . .  71
   14. Extensibility Considerations  . . . . . . . . . . . . . . . .  72
   15. Grammar . . . . . . . . . . . . . . . . . . . . . . . . . . .  73
     15.1. "candidate" Attribute . . . . . . . . . . . . . . . . . .  73
     15.2. "remote-candidates" Attribute . . . . . . . . . . . . . .  75
     15.3. "ice-lite" and "ice-mismatch" Attributes  . . . . . . . .  75
     15.4. "ice-ufrag" and "ice-pwd" Attributes  . . . . . . . . . .  76
     15.5. "ice-options" Attribute . . . . . . . . . . . . . . . . .  76
   16. Setting Ta and RTO  . . . . . . . . . . . . . . . . . . . . .  76
     16.1. RTP Media Streams . . . . . . . . . . . . . . . . . . . .  77
     16.2. Non-RTP Sessions  . . . . . . . . . . . . . . . . . . . .  78
   17. Example . . . . . . . . . . . . . . . . . . . . . . . . . . .  79
   18. Security Considerations . . . . . . . . . . . . . . . . . . .  85
     18.1. Attacks on Connectivity Checks  . . . . . . . . . . . . .  86
     18.2. Attacks on Server Reflexive Address Gathering . . . . . .  88
     18.3. Attacks on Relayed Candidate Gathering  . . . . . . . . .  89
     18.4. Attacks on the Offer/Answer Exchanges . . . . . . . . . .  89
     18.5. Insider Attacks . . . . . . . . . . . . . . . . . . . . .  90
       18.5.1. The Voice Hammer Attack . . . . . . . . . . . . . . .  90
       18.5.2. STUN Amplification Attack . . . . . . . . . . . . . .  90
     18.6. Interactions with Application Layer Gateways and SIP  . .  91
   19. STUN Extensions . . . . . . . . . . . . . . . . . . . . . . .  92
     19.1. New Attributes  . . . . . . . . . . . . . . . . . . . . .  92
     19.2. New Error Response Codes  . . . . . . . . . . . . . . . .  93
   20. Operational Considerations  . . . . . . . . . . . . . . . . .  93
     20.1. NAT and Firewall Types  . . . . . . . . . . . . . . . . .  93
     20.2. Bandwidth Requirements  . . . . . . . . . . . . . . . . .  93
       20.2.1. STUN and TURN Server Capacity Planning  . . . . . . .  93
       20.2.2. Gathering and Connectivity Checks . . . . . . . . . .  94
       20.2.3. Keepalives  . . . . . . . . . . . . . . . . . . . . .  94
     20.3. ICE and ICE-lite  . . . . . . . . . . . . . . . . . . . .  95
     20.4. Troubleshooting and Performance Management  . . . . . . .  95
     20.5. Endpoint Configuration  . . . . . . . . . . . . . . . . .  95
   21. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  96
     21.1. SDP Attributes  . . . . . . . . . . . . . . . . . . . . .  96
       21.1.1. candidate Attribute . . . . . . . . . . . . . . . . .  96
       21.1.2. remote-candidates Attribute . . . . . . . . . . . . .  96
       21.1.3. ice-lite Attribute  . . . . . . . . . . . . . . . . .  97
       21.1.4. ice-mismatch Attribute  . . . . . . . . . . . . . . .  97
       21.1.5. ice-pwd Attribute . . . . . . . . . . . . . . . . . .  98
       21.1.6. ice-ufrag Attribute . . . . . . . . . . . . . . . . .  98
       21.1.7. ice-options Attribute . . . . . . . . . . . . . . . .  98
     21.2. STUN Attributes . . . . . . . . . . . . . . . . . . . . .  99
     21.3. STUN Error Responses  . . . . . . . . . . . . . . . . . .  99
   22. IAB Considerations  . . . . . . . . . . . . . . . . . . . . .  99
     22.1. Problem Definition  . . . . . . . . . . . . . . . . . . . 100
     22.2. Exit Strategy . . . . . . . . . . . . . . . . . . . . . . 100
     22.3. Brittleness Introduced by ICE . . . . . . . . . . . . . . 101
     22.4. Requirements for a Long-Term Solution . . . . . . . . . . 102
     22.5. Issues with Existing NAPT Boxes . . . . . . . . . . . . . 102
   23. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . 102
   24. References  . . . . . . . . . . . . . . . . . . . . . . . . . 103
     24.1. Normative References  . . . . . . . . . . . . . . . . . . 103
     24.2. Informative References  . . . . . . . . . . . . . . . . . 104
   Appendix A.  Lite and Full Implementations  . . . . . . . . . . . 107
   Appendix B.  Design Motivations . . . . . . . . . . . . . . . . . 108
     B.1.  Pacing of STUN Transactions . . . . . . . . . . . . . . . 108
     B.2.  Candidates with Multiple Bases  . . . . . . . . . . . . . 109
     B.3.  Purpose of the <rel-addr> and <rel-port> Attributes . . . 111
     B.4.  Importance of the STUN Username . . . . . . . . . . . . . 111
     B.5.  The Candidate Pair Priority Formula . . . . . . . . . . . 113
     B.6.  The remote-candidates Attribute . . . . . . . . . . . . . 113
     B.7.  Why Are Keepalives Needed?  . . . . . . . . . . . . . . . 114
     B.8.  Why Prefer Peer Reflexive Candidates? . . . . . . . . . . 115
     B.9.  Why Send an Updated Offer?  . . . . . . . . . . . . . . . 115
     B.10. Why Are Binding Indications Used for Keepalives?  . . . . 115
     B.11. Why Is the Conflict Resolution Mechanism Needed?  . . . . 116
```

---
## **1.  Introduction**

RFC 3264 \[RFC3264\]는 멀티미디어 세션 설정을 위해 SDP\(Session Description Protocol\) 메시지 \[RFC4566\]의 2단계 교환을 정의합니다. 이 제공/응답 메커니즘은 SIP\(Session Initiation Protocol\) \[RFC3261\]과 같은 프로토콜에서 사용됩니다.

제안/응답을 사용하는 프로토콜은 NAT\(Network Address Translator\)를 통해 작동하기 어렵습니다. 그들의 목적은 미디어 패킷의 흐름을 설정하는 것이기 때문에 메시지 내에 미디어 소스 및 싱크의 IP 주소와 포트를 전달하는 경향이 있는데, 이는 NAT \[RFC3235\]를 통해 문제가 있는 것으로 알려져 있습니다. 또한 프로토콜은 참가자 간에 직접 미디어 흐름을 생성하여 참가자 사이에 애플리케이션 계층 중개자가 없도록 노력합니다. 이는 미디어 대기 시간을 줄이고, 패킷 손실을 줄이며, 애플리케이션 배포에 따른 운영 비용을 줄이기 위해 수행됩니다. 그러나 NAT를 통해서는 이를 달성하기가 어렵습니다. 이에 대한 이유를 완전히 다루는 것은 이 사양의 범위를 벗어납니다.

이러한 프로토콜이 NAT를 통해 작동할 수 있도록 다양한 솔루션이 정의되었습니다. 여기에는 애플리케이션 계층 게이트웨이\(ALG\), 미들박스 제어 프로토콜 \[RFC3303\], 원래 STUN\(Simple Traversal of UDP Through NAT\) \[RFC3489\] 사양, 영역별 IP \[RFC3102\] \[RFC3103\] 및 필요한 세션 설명 확장이 포함됩니다. 실시간 제어 프로토콜\(RTCP\) \[RFC3605\]에 대한 세션 설명 프로토콜\(SDP\) \[RFC4566\] 속성과 같이 작동하도록 만듭니다. 불행하게도 이러한 기술은 모두 장단점이 있어 일부 네트워크 토폴로지에서는 각 기술을 최적으로 만들지만 다른 기술에서는 좋지 않은 선택입니다. 그 결과 관리자와

구현자는 솔루션이 배포될 네트워크의 토폴로지에 대해 가정을 하고 있습니다. 이로 인해 시스템이 복잡해지고 취약해집니다. 필요한 것은 모든 상황에서 잘 작동할 수 있을 만큼 유연한 단일 솔루션입니다.

이 사양에서는 ICE\(대화형 연결 설정\)를 제안/응답 모델에 의해 설정된 UDP 기반 미디어 스트림에 대한 NAT 통과 기술로 정의합니다\(ICE는 TCP \[ICE-TCP\]와 같은 다른 전송 프로토콜을 처리하도록 확장될 수 있음\). ICE는 제안/응답 모델의 확장이며, SDP 제안 및 답변에 다양한 IP 주소와 포트를 포함시켜 작동하며, P2P 연결 확인을 통해 연결성을 테스트합니다. SDP에 포함된 IP 주소와 포트 및 연결 확인은 개정된 STUN 사양 \[RFC5389\]을 사용하여 수행되며, 이제 이름이 NAT용 세션 탐색 유틸리티로 변경되었습니다. 새 이름과 새 사양은 원래 STUN 사양처럼 독립형 NAT 통과 솔루션이 아닌 다른 NAT 통과 기술\(즉, ICE\)과 함께 사용되는 도구로서의 새로운 역할을 반영합니다. ICE는 또한 STUN의 확장인 Traversal Using Relays around NAT\(TURN\) \[RFC5766\]을 사용합니다. ICE는 각 미디어 스트림에 대해 다수의 IP 주소와 포트를 교환하기 때문에 멀티홈 및 듀얼 스택 호스트에 대한 주소 선택도 허용하며 이러한 이유로 RFC 4091 \[RFC4091\] 및 \[RFC4092\]를 더 이상 사용하지 않습니다.

---
## **2.  Overview of ICE**

일반적인 ICE 배포에는 통신을 원하는 두 개의 엔드포인트\(RFC 3264 용어로 AGENTS라고 함\)가 있습니다. 그들은 SDP \[RFC3264\] 메시지의 제안/응답 교환을 수행할 수 있는 일부 신호 프로토콜\(예: SIP\)을 통해 간접적으로 통신할 수 있습니다. ICE는 다른 메커니즘\[RFC5626\]을 통해 제공되는 것으로 가정되는 SIP용 NAT 통과를 위한 것이 아닙니다. ICE 프로세스가 시작될 때 에이전트는 자신의 토폴로지를 알지 못합니다. 특히 NAT\(또는 NAT의 여러 계층\) 뒤에 있을 수도 있고 그렇지 않을 수도 있습니다. ICE를 사용하면 에이전트는 토폴로지에 대한 충분한 정보를 검색하여 잠재적으로 통신할 수 있는 하나 이상의 경로를 찾을 수 있습니다.

그림 1은 ICE 배포를 위한 일반적인 환경을 보여줍니다. 두 끝점에는 L과 R이라는 레이블이 지정되어 있습니다\(왼쪽과 오른쪽에 대해 통화 흐름을 시각화하는 데 도움이 됨\). L과 R은 모두 자신의 NAT 뒤에 있지만 이를 인식하지 못할 수도 있습니다. NAT 유형과 해당 속성도 알려져 있지 않습니다. 에이전트 L과 R은 L과 R 사이에 미디어 세션을 설정하는 것이 목적인 SDP 메시지를 교환할 수 있는 제안/응답 교환에 참여할 수 있습니다. 일반적으로 이 교환은 SIP 서버를 통해 발생합니다.

에이전트, SIP 서버 및 NAT 외에도 ICE는 일반적으로 네트워크의 STUN 또는 TURN 서버와 함께 사용됩니다. 각 에이전트는 자체 STUN 또는 TURN 서버를 가질 수도 있고 동일할 수도 있습니다.

```text
                              +-------+
                              | SIP   |
           +-------+          | Srvr  |          +-------+
           | STUN  |          |       |          | STUN  |
           | Srvr  |          +-------+          | Srvr  |
           |       |         /         \         |       |
           +-------+        /           \        +-------+
                           /             \
                          /               \
                         /                 \
                        /                   \
                       /  <-  Signaling  ->  \
                      /                       \
                     /                         \
               +--------+                   +--------+
               |  NAT   |                   |  NAT   |
               +--------+                   +--------+
                 /                                \
                /                                  \
               /                                    \
           +-------+                             +-------+
           | Agent |                             | Agent |
           |   L   |                             |   R   |
           |       |                             |       |
           +-------+                             +-------+

                     Figure 1: ICE Deployment Scenario
```

ICE의 기본 아이디어는 다음과 같습니다. 각 에이전트에는 다른 에이전트와 통신하는 데 사용할 수 있는 다양한 후보 전송 주소\(특정 전송 프로토콜에 대한 IP 주소와 포트의 조합, 이 사양에서는 항상 UDP임\)가 있습니다. 여기에는 다음이 포함될 수 있습니다.

o 직접 연결된 네트워크 인터페이스의 전송 주소

```text
   o  A translated transport address on the public side of a NAT (a
      "server reflexive" address)
```

o TURN 서버에서 할당된 전송 주소\("중계 주소"\).

잠재적으로 L의 후보 전송 주소 중 하나를 사용하여 R의 후보 전송 주소와 통신할 수 있습니다. \~ 안에

그러나 연습을 하면 많은 조합이 작동하지 않습니다. 예를 들어, L과 R이 모두 NAT 뒤에 있는 경우 직접 연결된 인터페이스 주소는 직접 통신할 수 없을 것입니다\(결국 ICE가 필요한 이유입니다!\). ICE의 목적은 어떤 주소 쌍이 작동하는지 알아내는 것입니다. ICE가 이를 수행하는 방식은 작동하는 하나 이상의 쌍을 찾을 때까지 가능한 모든 쌍을 체계적으로\(신중하게 정렬된 순서로\) 시도하는 것입니다.

---
### **2.1.  Gathering Candidate Addresses**

ICE를 실행하려면 에이전트는 모든 주소 후보를 식별해야 합니다. CANDIDATE는 전송 주소, 즉 특정 전송 프로토콜에 대한 IP 주소와 포트의 조합입니다\(여기서는 UDP만 지정됨\). 이 문서는 세 가지 유형의 후보를 정의합니다. 일부는 물리적 또는 논리적 네트워크 인터페이스에서 파생되고 다른 일부는 STUN 및 TURN을 통해 검색 가능합니다. 당연히 실행 가능한 후보 중 하나는 로컬 인터페이스에서 직접 얻은 전송 주소입니다. 이러한 후보자를 HOST CANDIDATE라고 합니다. 로컬 인터페이스는 이더넷이나 WiFi일 수도 있고 VPN\(가상 사설망\) 또는 MIP\(모바일 IP\)와 같은 터널 메커니즘을 통해 얻은 인터페이스일 수도 있습니다. 모든 경우에 이러한 네트워크 인터페이스는 포트\(및 후보\)를 할당할 수 있는 로컬 인터페이스로 에이전트에 나타납니다.

에이전트가 멀티홈인 경우 각 IP 주소에서 후보를 얻습니다. 에이전트를 기준으로 IP 네트워크에서 PEER\(세션의 다른 에이전트\)의 위치에 따라 해당 IP 주소 중 하나 이상을 통해 피어가 에이전트에 연결할 수 있습니다. 예를 들어, 사설망 10 네트워크\(I1\)에 로컬 IP 주소가 있고 두 번째 IP 주소가 공용 인터넷\(I2\)에 연결된 에이전트를 생각해 보십시오. I1의 후보는 동일한 사설망 10 네트워크의 피어와 통신할 때 직접 연결할 수 있는 반면, I2의 후보는 공용 인터넷의 피어와 통신할 때 직접 연결할 수 있습니다. 제안을 보내기 전에 어떤 IP 주소가 작동할지 추측하는 대신 제안 에이전트는 제안에 두 후보를 모두 포함합니다.

다음으로 에이전트는 추가 후보를 얻기 위해 STUN 또는 TURN을 사용합니다. 이는 NAT의 공개 측에서 변환된 주소\(SERVER REFLEXIVE CANDIDATES\)와 TURN 서버의 주소\(RELAYED CANDIDATES\)의 두 가지 형태로 제공됩니다. TURN 서버를 활용하는 경우 두 유형의 후보 모두 TURN 서버에서 가져옵니다. STUN 서버만 활용하는 경우 해당 서버에서 서버 반사 후보만 얻습니다. 이러한 후보와 호스트 후보의 관계는 그림 2에 나와 있습니다. 이 그림에서는 두 유형의 후보가 모두 TURN을 사용하여 검색됩니다. 그림에서 X:x 표기는 IP 주소 X와 UDP 포트 x를 의미합니다.

```text
                 To Internet

                     |
                     |
                     |  /------------  Relayed
                 Y:y | /               Address
                 +--------+
                 |        |
                 |  TURN  |
                 | Server |
                 |        |
                 +--------+
                     |
                     |
                     | /------------  Server
              X1':x1'|/               Reflexive
               +------------+         Address
               |    NAT     |
               +------------+
                     |
                     | /------------  Local
                 X:x |/               Address
                 +--------+
                 |        |
                 | Agent  |
                 |        |
                 +--------+

                     Figure 2: Candidate Relationships
```

에이전트가 IP 주소 및 포트 X:x에서 TURN Allocate 요청을 보내면 NAT\(있는 것으로 가정\)는 바인딩 X1':x1'을 생성하여 이 서버 반사 후보를 호스트 후보 X:x에 매핑합니다. 호스트 후보에서 전송된 나가는 패킷은 NAT에 의해 서버 재귀 후보로 변환됩니다. 서버 반사 후보로 전송된 수신 패킷은 NAT에 의해 호스트 후보로 변환되어 에이전트로 전달됩니다. 우리는 주어진 서버 반사 후보와 연관된 호스트 후보를 BASE라고 부릅니다.

- 참고: "기본"은 에이전트가 특정 후보자를 위해 보내는 주소를 나타냅니다. 따라서 퇴화 사례로서 호스트 후보도 기반을 갖고 있지만 호스트 후보와 동일합니다.

에이전트와 TURN 서버 사이에 여러 NAT가 있는 경우 TURN 요청은 각 NAT에 바인딩을 생성하지만 가장 바깥쪽 서버 재귀 후보\(TURN에 가장 가까운 후보\)만 생성합니다.

서버\)는 에이전트에 의해 검색됩니다. 에이전트가 NAT 뒤에 있지 않은 경우 기본 후보는 서버 재귀 후보와 동일하며 서버 재귀 후보는 중복되어 제거됩니다.

그러면 할당 요청이 TURN 서버에 도착합니다. TURN 서버는 로컬 IP 주소 Y에서 포트 y를 할당하고 Allocate 응답을 생성하여 이 릴레이된 후보를 에이전트에 알립니다. 또한 TURN 서버는 할당 요청의 소스 전송 주소를 할당 응답에 복사하여 서버 반사 후보 X1':x1'의 에이전트에 알립니다. TURN 서버는 L과 R 사이에 트래픽을 전달하는 패킷 중계 역할을 합니다. L로 트래픽을 보내기 위해 R은 Y:y에서 TURN 서버로 트래픽을 보내고 TURN 서버는 이를 X1':x1'로 전달합니다. NAT를 통과하여 X:x로 매핑되어 L로 전달됩니다.

STUN 서버만 활용되는 경우 에이전트는 STUN 서버에 STUN 바인딩 요청 \[RFC5389\]을 보냅니다. STUN 서버는 바인딩 요청의 소스 전송 주소를 바인딩 응답에 복사하여 서버 반사 후보 X1':x1'의 에이전트에 알립니다.

---
### **2.2.  Connectivity Checks**

L이 모든 후보를 수집하면 가장 높은 우선순위에서 가장 낮은 우선순위로 순서를 지정하고 신호 채널을 통해 R로 보냅니다. 후보자는 SDP 제안의 속성으로 전달됩니다. R은 제안을 받으면 동일한 수집 프로세스를 수행하고 자체 후보자 목록으로 응답합니다. 이 프로세스가 끝나면 각 에이전트는 후보와 피어 후보의 전체 목록을 갖게 됩니다. 이를 쌍으로 연결하여 후보 쌍을 만듭니다. 어떤 쌍이 작동하는지 확인하기 위해 각 에이전트는 일련의 확인을 예약합니다. 각 검사는 클라이언트가 로컬 후보에서 원격 후보로 STUN 요청을 전송하여 특정 후보 쌍에 대해 수행하는 STUN 요청/응답 트랜잭션입니다.

연결 확인의 기본 원칙은 간단합니다.

1. 후보 쌍을 우선순위에 따라 정렬합니다.

2. 우선순위에 따라 각 후보 쌍에 대한 수표를 보냅니다.

3. 상대 상담원으로부터 받은 확인 내용을 확인합니다.

두 에이전트가 후보 쌍에 대해 검사를 수행하면 결과는 4방향 핸드셰이크입니다.

```text
   L                        R
   -                        -
   STUN request ->             \  L's
             <- STUN response  /  check

              <- STUN request  \  R's
   STUN response ->            /  check

                    Figure 3: Basic Connectivity Check
```

STUN 요청은 미디어\(예: RTP 및 RTCP\)에 사용될 정확히 동일한 IP 주소 및 포트로 전송된다는 점에 유의하는 것이 중요합니다. 결과적으로 에이전트는 패킷이 수신된 포트가 아닌 패킷 내용을 사용하여 STUN 및 RTP/RTCP를 역다중화합니다. 다행히도 이 역다중화는 특히 RTP와 RTCP의 경우 쉽게 수행할 수 있습니다.

STUN 바인딩 요청은 연결 확인에 사용되므로 STUN 바인딩 응답에는 에이전트와 해당 피어 간의 모든 NAT의 공개 측에 있는 에이전트의 변환된 전송 주소가 포함됩니다. 이 전송 주소가 에이전트가 이미 배운 다른 후보와 다른 경우 이는 PEER REFLEXIVE CANDIDATE라는 새로운 후보를 나타내며 다른 후보와 마찬가지로 ICE에 의해 테스트됩니다.

최적화로서 R은 L의 확인 메시지를 받자마자 동일한 후보 쌍에서 L로 전송되도록 연결 확인 메시지를 예약합니다. 이를 통해 유효한 후보자를 찾는 프로세스가 가속화되며 이를 트리거드 체크\(TRIGGERED CHECK\)라고 합니다.

이 핸드셰이크가 끝나면 L과 R은 모두 양 방향으로 종단 간 메시지를 보내고 받을 수 있다는 것을 알게 됩니다.

---
### **2.3.  Sorting Candidates**

위의 알고리즘은 모든 후보 쌍을 검색하기 때문에 작업 쌍이 존재하면 후보를 시도하는 순서에 관계없이 결국 이를 찾습니다. 더 빠르고 더 나은 결과를 생성하기 위해 후보는 지정된 순서로 정렬됩니다. 정렬된 후보 쌍의 결과 목록을 CHECK LIST라고 합니다. 알고리즘은 섹션 4.1.2에 설명되어 있지만 두 가지 일반 원칙을 따릅니다.

o 각 에이전트는 후보자에게 숫자 우선순위를 부여하며 이는 후보자와 함께 피어에게 전송됩니다.

o 각 에이전트가 후보 쌍에 대해 동일한 순서를 갖도록 로컬 및 원격 우선순위가 결합됩니다.

두 번째 속성은 L과 R 앞에 NAT가 있을 때 ICE가 작동하도록 하는 데 중요합니다. NAT 뒤에 있는 에이전트가 해당 호스트를 향해 패킷을 보낼 때까지 NAT는 호스트에서 들어오는 패킷을 허용하지 않는 경우가 많습니다. 결과적으로 각 방향의 ICE 확인은 양측이 해당 NAT를 통해 확인을 보낼 때까지 성공하지 못합니다.

에이전트는 주기적으로 목록의 다음 후보 쌍에 대한 STUN 요청을 보내 이 체크리스트를 통해 작업합니다. 이것을 일반 수표라고 합니다.

일반적으로 우선순위 알고리즘은 유사한 유형의 후보가 유사한 우선순위를 갖도록 설계되어 더 많은 직접 경로\(즉, 더 적은 수의 미디어 릴레이 및 더 적은 NAT를 통해\)가 간접 경로\(더 많은 미디어 릴레이 및 더 많은 NAT가 있는 경로\)보다 선호됩니다. \). 그러나 해당 지침 내에서 상담원은 알고리즘을 조정하는 방법에 대해 상당한 재량권을 갖습니다.

---
### **2.4.  Frozen Candidates**

이전 설명은 에이전트가 하나의 구성 요소\(단일 전송 주소가 필요한 미디어 스트림의 일부\)를 사용하여 미디어 세션을 설정하려는 경우에만 다룹니다. 미디어 스트림에는 여러 구성 요소가 필요할 수 있으며 각 구성 요소는 미디어 스트림에 대해 작동해야 합니다. 전체적으로 일할 것입니다\). 일반적으로\(예: RTP 및 RTCP 사용\) 에이전트는 실제로 둘 이상의 흐름에 대한 연결을 설정해야 합니다.

네트워크 속성은 각 구성 요소에 대해 매우 유사할 가능성이 높습니다\(특히 RTP와 RTCP가 동일한 IP 주소에서 전송되고 수신되기 때문에\). 일반적으로 한 미디어 구성요소의 정보를 활용하여 다른 구성요소에 가장 적합한 후보를 결정하는 것이 가능합니다. ICE는 "동결 후보"라는 메커니즘을 사용하여 이를 수행합니다.

각 후보는 FOUNDATION이라는 속성과 연결되어 있습니다. 두 후보가 "유사"할 때 동일한 기반을 갖습니다. 즉, 동일한 유형이고 동일한 프로토콜을 사용하는 동일한 호스트 후보 및 STUN 서버에서 얻은 것입니다. 그렇지 않으면 기초가 다릅니다. 후보 쌍에도 기초가 있는데, 이는 단지 두 후보의 기초를 연결한 것입니다. 처음에는 고유한 기반을 가진 후보 쌍만 테스트됩니다. 다른 후보 쌍은 "동결"로 표시됩니다. 후보 쌍에 대한 연결 확인이 성공하면 다른 후보 쌍은

동일한 기초가 동결 해제되었습니다. 이렇게 하면 표면적으로는 더 매력적이지만 실제로는 실패할 가능성이 있는 구성 요소를 반복적으로 검사하는 것을 방지할 수 있습니다.

여기서는 설명 목적을 위한 별도의 메커니즘으로 "동결"을 설명했지만 실제로 이는 ICE의 필수 부분이며 ICE 우선 순위 지정 알고리즘은 올바른 후보가 고정 해제되고 올바른 순서로 확인되도록 자동으로 보장합니다.

---
### **2.5.  Security for Checks**

ICE는 두 에이전트 간에 미디어를 보내는 데 사용할 수 있는 주소를 검색하는 데 사용되므로 프로세스가 하이재킹되어 미디어를 잘못된 위치로 보낼 수 없도록 하는 것이 중요합니다. 각 STUN 연결 확인은 신호 채널에서 교환된 키를 사용하여 계산된 MAC\(메시지 인증 코드\)로 처리됩니다. 이 MAC는 메시지 무결성과 데이터 원본 인증을 제공하므로 공격자가 연결 확인 메시지를 위조하거나 수정하는 것을 방지합니다. 또한 SIP \[RFC3261\] 호출자가 ICE와 호출 분기를 사용하는 경우 ICE 교환은 분기된 각 수신자와 독립적으로 발생합니다. 이러한 경우 신호에서 교환된 키는 각 ICE 교환을 분기된 각 수신자와 연결하는 데 도움이 됩니다.

---
### **2.6.  Concluding ICE**

ICE 검사는 특정 순서로 수행되므로 우선순위가 높은 후보 쌍을 먼저 검사한 다음 우선순위가 낮은 후보 쌍을 검사합니다. ICE를 결론 짓는 한 가지 방법은 각 미디어 스트림의 각 구성 요소에 대한 확인이 성공적으로 완료되자마자 승리를 선언하는 것입니다. 실제로 이는 합리적인 알고리즘이며 이에 대한 자세한 내용은 아래에 제공됩니다. 그러나 패킷 손실로 인해 우선 순위가 높은 검사를 완료하는 데 시간이 더 오래 걸릴 수 있습니다. 이 경우 ICE를 조금 더 오래 실행하면 더 나은 결과를 얻을 수 있습니다. 그러나 보다 근본적으로 이 사양에 정의된 우선순위는 "최적" 결과를 산출하지 못할 수도 있습니다. 예를 들어, 지연 시간이 짧은 미디어 경로를 선택하는 것이 목표인 경우 릴레이 사용은 지연 시간이 더 높을 수 있다는 힌트일 뿐 힌트에 지나지 않습니다. 실제 왕복 시간\(RTT\) 측정이 이루어질 수 있으며, 이는 우선 순위가 낮은 쌍이 우선 순위가 높은 쌍보다 실제로 더 낫다는 것을 보여줄 수 있습니다.

결과적으로 ICE는 대리인 중 한 명을 통제 대리인 역할로 배정하고, 다른 한 명은 통제 대리인 역할을 맡게 합니다. 제어 에이전트는 유효한 것 중에서 미디어에 사용될 후보 쌍을 지정합니다. REGULAR NOMINATION 또는 AGGRESSIVE NOMINATION을 사용하는 두 가지 방법 중 하나로 이를 수행할 수 있습니다.

정기적인 지정을 통해 제어 에이전트는 각 미디어 스트림에 대해 하나 이상의 유효한 후보 쌍이 발견될 때까지 검사를 계속합니다. 그런 다음 유효한 항목 중에서 선택하고 NOMINATED 후보 쌍에 대해 두 번째 STUN 요청을 보냅니다. 단, 이번에는 이 쌍이 사용하도록 지정되었음을 피어에게 알리기 위한 플래그가 설정되어 있습니다. 이는 그림 4에 나와 있습니다.

```text
   L                        R
   -                        -
   STUN request ->             \  L's
             <- STUN response  /  check

              <- STUN request  \  R's
   STUN response ->            /  check

   STUN request + flag ->      \  L's
             <- STUN response  /  check

                       Figure 4: Regular Nomination
```

플래그가 포함된 STUN 트랜잭션이 완료되면 양측은 해당 미디어 스트림에 대한 향후 확인을 취소합니다. 이제 ICE는 이 쌍을 사용하여 미디어를 보냅니다. ICE 에이전트가 미디어에 사용하는 쌍을 SELECTED PAIR라고 합니다.

공격적인 지명에서는 제어 에이전트가 보내는 모든 STUN 요청에 플래그를 넣습니다. 이렇게 하면 첫 번째 확인이 성공하면 해당 미디어 스트림에 대한 ICE 처리가 완료되고 제어 에이전트는 두 번째 STUN 요청을 보낼 필요가 없습니다. 선택한 쌍은 확인에 성공한 가장 높은 우선순위의 유효한 쌍이 됩니다. 공격적 지명은 일반 지명보다 빠르지만 유연성이 떨어집니다. 공격적인 지명은 그림 5에 나와 있습니다.

```text
   L                        R
   -                        -
   STUN request + flag ->      \  L's
             <- STUN response  /  check

              <- STUN request  \  R's
   STUN response ->            /  check

                      Figure 5: Aggressive Nomination
```

모든 미디어 스트림이 완료되면 제어 엔드포인트는 미디어 스트림에 대한 m 및 c 라인의 후보\(기본 후보라고 함\)가 ICE의 SELECTED CANDIDATES와 일치하지 않는 경우 업데이트된 제안을 보냅니다.

ICE가 종료되면 에이전트 중 하나 또는 모든 미디어 스트림에 대해 언제든지 다시 시작할 수 있습니다. 이는 재시작을 나타내는 업데이트된 제안을 전송하여 수행됩니다.

---
### **2.7.  Lite Implementations**

통화에서 ICE를 사용하려면 두 상담원 모두 이를 지원해야 합니다. 그러나 특정 에이전트는 항상 공용 인터넷에 연결되어 있으며 모든 통신원으로부터 패킷을 수신할 수 있는 공용 IP 주소를 갖습니다. 이러한 장치가 ICE를 더 쉽게 지원할 수 있도록 ICE는 LITE\(일반적인 FULL 구현과 대조\)라는 특수한 유형의 구현을 정의합니다. 간단한 구현은 후보자를 수집하지 않습니다. 여기에는 모든 미디어 스트림에 대한 호스트 후보만 포함됩니다. Lite 에이전트는 연결 확인에 응답할 수 있어야 하지만 연결 확인을 생성하거나 상태 시스템을 실행하지 않습니다. 라이트 구현이 전체 구현과 연결되면 전체 에이전트가 제어 에이전트의 역할을 맡고 라이트 에이전트가 제어된 역할을 맡습니다. 두 개의 라이트 구현이 연결되면 검사가 전송되지 않습니다.

라이트 구현이 적절한 시기에 대한 지침은 부록 A의 설명을 참조하세요.

전체 구현에 대한 디딤돌을 제공하기 위해 이 사양에 라이트 구현이 추가되었다는 점에 유의하는 것이 중요합니다. 공용 인터넷에 항상 연결되어 있는 장치의 경우에도 가능하다면 전체 구현을 수행하는 것이 좋습니다.

---
## **3.  Terminology**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. RFC 2119\[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

독자는 제안/응답 모델 \[RFC3264\], STUN \[RFC5389\] 및 UDP에 대한 NAT 동작 요구 사항 \[RFC4787\]에 정의된 용어를 잘 알고 있어야 합니다.

이 사양에서는 다음과 같은 추가 용어를 사용합니다.

에이전트: RFC 3264에 정의된 대로 에이전트는 프로토콜입니다.

- 제안/답변 교환에 관련된 구현. 제안/답변 교환에는 두 명의 에이전트가 참여합니다.

피어: 세션에 있는 에이전트 중 하나의 관점에서 볼 때 해당 피어는 다른 에이전트입니다. 특히 제안자의 관점에서 볼 때 피어는 응답자입니다. 응답자의 관점에서 볼 때 피어는 제안자입니다.

전송 주소: IP 주소와 전송 프로토콜\(예: UDP 또는 TCP\) 포트의 조합입니다.

후보: 미디어 수신을 위한 잠재적인 연락 지점이 되는 전송 주소입니다. 후보자에는 유형\(서버 반사, 릴레이 또는 호스트\), 우선 순위, 기반 및 기반과 ​​같은 속성도 있습니다.

구성 요소: 구성 요소는 단일 전송 주소가 필요한 미디어 스트림의 일부입니다. 미디어 스트림에는 여러 구성 요소가 필요할 수 있으며, 각 구성 요소는 미디어 스트림 전체가 작동하도록 작동해야 합니다. RTP 기반 미디어 스트림의 경우 미디어 스트림당 두 개의 구성 요소\(RTP용 하나, RTCP용 하나\)가 있습니다.

호스트 후보\(Host Candidate\): 호스트의 IP 주소에서 특정 포트에 바인딩하여 얻은 후보입니다. 여기에는 VPN\(가상 사설망\) 및 RSIP\(영역 특정 IP\) \[RFC3102\]\(운영 체제 수준에 있음\)를 통해 얻은 것과 같은 물리적 인터페이스 및 논리적 인터페이스의 IP 주소가 포함됩니다.

서버 재귀 후보\(Server Reflexive Candidate\): IP 주소와 포트가 NAT를 통해 서버로 패킷을 보낼 때 에이전트에 대해 NAT가 할당한 바인딩인 후보입니다. 서버 재귀 후보는 바인딩 요청을 사용하는 STUN 서버 또는 중계된 후보와 서버 재귀 후보를 모두 제공하는 TURN 서버에서 학습할 수 있습니다.

피어 재귀 후보\(Peer Reflexive Candidate\): 에이전트가 NAT를 통해 STUN 바인딩 요청을 피어에게 보낼 때 에이전트에 대해 NAT가 할당한 바인딩인 IP 주소와 포트를 가진 후보입니다.

릴레이된 후보\(Relayed Candidate\): 호스트 후보로부터 TURN 서버로 TURN 할당 요청을 전송하여 얻은 후보입니다. 중계된 후보는 TURN 서버에 상주하며, TURN 서버는 에이전트를 향해 패킷을 다시 중계합니다.

기본: 서버 반사 후보의 기본은 파생된 호스트 후보입니다. 호스트 후보자는 또한 해당 후보자 자체와 동일한 기반을 가지고 있다고 합니다. 마찬가지로, 릴레이된 후보의 기반은 해당 후보 자체입니다.

Foundation: 유형, 기본 IP 주소, 프로토콜\(UDP, TCP 등\) 및 STUN 또는 TURN 서버가 동일한 두 후보에 대해 동일한 임의 문자열입니다. 이 중 하나라도 다르면 기초가 달라집니다. 동일한 기반 쌍을 가진 두 후보 쌍은 유사한 네트워크 특성을 가질 가능성이 높습니다. 기초는 고정 알고리즘에 사용됩니다.

로컬 후보자: 에이전트가 획득하여 보낸 제안이나 답변에 포함된 후보자입니다.

원격 후보: 에이전트가 동료로부터 제안이나 답변을 받은 후보입니다.

기본 대상/후보: 미디어 스트림 구성 요소의 기본 대상은 ICE를 인식하지 않는 에이전트가 사용하는 전송 주소입니다. RTP 구성 요소의 경우 기본 IP 주소는 SDP의 c 라인에 있고 포트는 m 라인에 있습니다. RTCP 구성 요소의 경우 존재하는 경우 rtcp 속성에 있고 존재하지 않는 경우 IP 주소는 c 라인에 있고 1 + 포트는 m 라인에 있습니다. 구성 요소의 기본 후보는 전송 주소가 해당 구성 요소의 기본 대상과 일치하는 것입니다.

후보 쌍: 로컬 후보와 원격 후보를 포함하는 쌍입니다.

확인, 연결 확인, STUN 확인: 연결 확인을 위한 STUN 바인딩 요청 트랜잭션입니다. 로컬 후보에서 후보 쌍의 원격 후보로 검사가 전송됩니다.

체크리스트: 에이전트가 체크를 생성하는 데 사용할 정렬된 후보 쌍 세트입니다.

일반 확인: 주기적으로 실행되는 타이머의 결과로 에이전트가 생성한 연결 확인으로 확인을 보내도록 지시합니다.

트리거된 확인: 피어로부터 연결 확인을 받은 결과로 생성된 연결 확인입니다.

유효한 목록: 성공적인 STUN 트랜잭션에 의해 검증된 미디어 스트림에 대한 후보 쌍의 정렬된 집합입니다.

전체: 이 사양에 정의된 전체 기능 세트를 수행하는 ICE 구현입니다.

Lite: 특정 기능을 생략한 ICE 구현,

- ICE의 이점을 충분히 얻을 수 있는 피어 구현에 필요한 만큼만 구현합니다. Lite 구현은 상태 머신을 유지하지 않으며 연결 확인을 생성하지 않습니다.

제어 에이전트\(Controlling Agent\): 후보 쌍의 최종 선택을 선택하고 필요한 경우 STUN 및 업데이트된 제안을 통해 신호를 보내는 역할을 담당하는 ICE 에이전트입니다. 어떤 세션에서든 항상 한 명의 에이전트가 제어합니다. 다른 하나는 통제된 에이전트입니다.

제어 에이전트\(Controlled Agent\): 제어 에이전트가 후보 쌍의 최종 선택을 선택하기를 기다리는 ICE 에이전트입니다.

정규 지명: 하나의 STUN 요청으로 쌍을 검증하여 미디어 트래픽에 대한 유효한 후보 쌍을 선택한 다음 지명을 나타내는 플래그와 함께 두 번째 STUN 요청을 보내 이를 선택하는 프로세스입니다.

공격적 지명: 유효한 후보 쌍을 생성하는 첫 번째 항목이 미디어에 사용되도록 모든 STUN 요청에 플래그를 포함하여 미디어 트래픽에 대한 유효한 후보 쌍을 선택하는 프로세스입니다.

지명됨: 유효한 후보 쌍에 지명된 플래그 세트가 있는 경우 이는 미디어 전송 및 수신을 위해 ICE가 이를 선택할 수 있음을 의미합니다.

선택된 쌍, 선택된 후보: ICE가 미디어 전송 및 수신을 위해 선택한 후보 쌍을 선택된 쌍이라고 하며, 각 후보를 선택된 후보라고 합니다.

---
## **4.  Sending the Initial Offer**

제안/응답 교환에서 초기 제안을 보내려면 에이전트는 \(1\) 후보를 수집하고, \(2\) 우선 순위를 지정하고, \(3\) 중복 후보를 제거하고, \(4\) 기본 후보를 선택한 다음 \(5\) 공식화하고 SDP 제안을 보내세요. 전체 구현과 라이트 구현에서는 이 5가지 단계 중 마지막 단계를 제외한 모든 단계가 다릅니다.

---
### **4.1.  Full Implementation Requirements**
---
#### **4.1.1.  Gathering Candidates**

에이전트는 통신이 임박했다고 판단되면 후보자를 모읍니다. 제공자는 사용자 인터페이스 단서 또는 세션 시작에 대한 명시적인 요청을 기반으로 이를 수행할 수 있습니다. 모든 후보자

운송 주소입니다. 유형과 베이스도 있습니다. 이 사양에서는 호스트 후보, 서버 반사 후보, 피어 반사 후보 및 릴레이된 후보의 네 가지 유형을 정의하고 수집합니다. 서버 반사 후보는 STUN 또는 TURN을 통해 수집되고, 릴레이된 후보는 TURN을 통해 획득됩니다. 피어 반사 후보는 연결 확인의 결과로 ICE의 후반 단계에서 획득됩니다. Candidate의 기본은 Agent가 해당 Candidate를 사용할 때 반드시 보내야 하는 Candidate입니다.

---
##### **4.1.1.1.  Host Candidates**

첫 번째 단계는 호스트 후보를 모으는 것입니다. 호스트 후보는 호스트의 인터페이스\(VPN 인터페이스를 포함한 물리적 또는 가상\)에 연결된 IP 주소의 포트\(일반적으로 임시\)에 바인딩하여 얻습니다.

에이전트가 사용하려는 각 UDP 미디어 스트림에 대해 에이전트는 호스트가 가지고 있는 각 IP 주소에서 미디어 스트림의 각 구성 요소에 대한 후보를 얻어야 합니다. 특정 IP 주소의 UDP 포트에 바인딩하여 각 후보를 얻습니다. 호스트 후보\(및 실제로 모든 후보\)는 항상 후보인 특정 구성 요소와 연결됩니다. 각 구성 요소에는 구성 요소 ID라고 하는 ID가 할당되어 있습니다. RTP 기반 미디어 스트림의 경우 RTP 자체의 구성 요소 ID는 1이고 RTCP의 구성 요소 ID는 2입니다. 에이전트가 RTCP를 사용하는 경우 이에 대한 후보를 가져와야 합니다. 에이전트가 RTP와 RTCP를 모두 사용하는 경우 에이전트에 K IP 주소가 있으면 2\*K 호스트 후보가 됩니다.\(SHOULD, MUST\)

각 호스트 후보의 기본은 후보 자체로 설정됩니다.

---
##### **4.1.1.2.  Server Reflexive and Relayed Candidates**

에이전트는 릴레이된 후보를 획득해야 하며\(SHOULD\) 서버 반사 후보를 획득해야 합니다\(SHOULD\). 이러한 요구 사항은 제공업체의 변화를 허용하기 위해 강력해야 합니다. 에이전트가 공용 인터넷이나 폐쇄 네트워크 외부의 엔드포인트에 연결되지 않는 폐쇄 네트워크에서는 STUN 및 TURN 서버의 사용이 불필요할 수 있습니다. 이러한 경우 이중 스택 또는 멀티홈 에이전트에 대해 전체 구현을 사용하여 호스트 후보를 선택합니다. TURN 서버를 사용하면 비용이 많이 들고 ICE를 사용하는 경우 두 엔드포인트가 모두 주소 및 포트 종속 매핑을 수행하는 NAT 뒤에 있는 경우에만 활용됩니다. 결과적으로 일부 배포에서는 이 사용 사례를 미미한 것으로 간주하고 TURN 서버를 사용하지 않기로 선택할 수 있습니다. 에이전트가 서버 반사 또는 릴레이 후보를 수집하지 않는 경우 해당 기능을 구현하고 구성을 통해 비활성화하여 나중에 조건이 변경되면 구성을 통해 다시 활성화할 수 있도록 권장합니다.\(SHOULD, SHOULD, SHOULD\)

에이전트가 릴레이된 후보와 서버 반사 후보를 모두 수집하는 경우 TURN 서버를 사용합니다. 서버 반사 후보만 수집하는 경우 STUN 서버를 사용합니다.

다음으로 에이전트는 각 호스트 후보를 구성되었거나 어떤 방법으로 검색한 STUN 또는 TURN 서버와 쌍을 이룹니다. STUN 또는 TURN 서버가 구성된 경우 도메인 이름을 구성하고 \[RFC5389\]의 DNS 절차\("stun" 서비스와 함께 SRV 레코드 사용\)를 사용하여 STUN 서버를 검색하는 것이 좋습니다. \[RFC5766\]에서\("turn" 서비스와 함께 SRV 레코드 사용\) TURN 서버를 검색하는 데 사용됩니다.\(SHOULD\)

이 사양은 단일 STUN 또는 TURN 서버의 사용만을 고려합니다. 해당 단일 STUN 또는 TURN 서버에 대해 여러 선택 사항이 있는 경우\(예를 들어 DNS 레코드를 통해 학습되고 여러 결과가 반환되는 경우\) 에이전트는 모든 항목에 대해 단일 STUN 또는 TURN 서버\(IP 주소 기반\)를 사용해야 합니다. 특정 세션의 후보자. 이는 ICE의 성능을 향상시킵니다. 결과는 STUN 또는 TURN 서버가 있는 호스트 후보 쌍 세트입니다. 그런 다음 에이전트는 한 쌍을 선택하고 해당 호스트 후보에서 서버로 바인딩 또는 할당 요청을 보냅니다. STUN 서버에 대한 바인딩 요청은 인증되지 않으며 응답의 모든 ALTERNATE-SERVER 속성은 무시됩니다. 에이전트는 \[RFC5389\]에 정의된 바인딩 요청에 대한 이전 버전과의 호환성 모드를 지원해야 합니다. 할당 요청은 클라이언트가 다른 수단을 통해 획득한 장기 자격 증명을 사용하여 인증되어야 합니다.\(SHOULD, MUST, SHOULD\)

이후 매 Ta 밀리초마다 에이전트는 또 다른 새로운 STUN 또는 TURN 트랜잭션을 생성할 수 있습니다. 이 트랜잭션은 복구 가능한 오류\(예: 인증 실패\)로 인해 실패한 이전 트랜잭션의 재시도이거나 새 호스트 후보 및 STUN 또는 TURN 서버 쌍에 대한 트랜잭션일 수 있습니다. 에이전트는 Ta 밀리초마다 1회보다 더 자주 트랜잭션을 생성해서는 안 됩니다. Ta 및 STUN 재전송 타이머 RTO를 설정하는 방법에 대한 지침은 섹션 16을 참조하십시오.\(SHOULD NOT\)

에이전트는 바인딩 또는 할당 응답을 받습니다. 성공적인 할당 응답은 서버 재귀 후보\(매핑된 주소에서 획득\)와 XOR-RELAYED-ADDRESS 속성의 릴레이 후보를 에이전트에 제공합니다. 서버에 할당 요청을 이행할 리소스가 부족하여 할당 요청이 거부된 경우 에이전트는 대신 서버 재귀 후보를 얻기 위해 바인딩 요청을 보내야 합니다. 바인딩 응답은 서버 재귀 후보\(매핑된 주소에서도 가져옴\)만 에이전트에 제공합니다. 서버 반사 후보의 기본은 할당 또는 바인딩 요청이 전송된 호스트 후보입니다. 릴레이된 후보자의 기반은 해당 후보자 자체입니다. 중계후보인 경우\(SHOULD\)

호스트 후보와 동일하면\(드물게 발생할 수 있음\) 중계된 후보를 폐기해야 합니다.\(MUST\)

---
##### **4.1.1.3.  Computing Foundations**

마지막으로 에이전트는 각 후보자에게 기초를 할당합니다. 기초는 세션 내에서 범위가 지정된 식별자입니다. 다음 사항이 모두 참인 경우 두 후보자는 동일한 재단 ID를 가져야 합니다.\(MUST\)

o 동일한 유형\(호스트, 릴레이, 서버 재귀 또는 피어 재귀\)입니다.

o 해당 베이스의 IP 주소는 동일합니다\(포트는 다를 수 있음\).

o 반사 및 릴레이 후보의 경우 해당 후보를 얻는 데 사용되는 STUN 또는 TURN 서버는 동일한 IP 주소를 갖습니다.

o 동일한 전송 프로토콜\(TCP, UDP 등\)을 사용하여 얻은 것입니다.

마찬가지로, 두 후보의 유형이 다르거나, 베이스의 IP 주소가 다르거나, 후보를 얻는 데 사용되는 STUN 또는 TURN 서버의 IP 주소가 다르거나, 전송 프로토콜이 다른 경우 두 후보는 서로 다른 기반을 가져야 합니다.\(MUST\)

---
##### **4.1.1.4.  Keeping Candidates Alive**

서버 반사 및 릴레이 후보가 할당되면 섹션 8.3에 설명된 대로 ICE 처리가 완료될 때까지 활성 상태로 유지되어야 합니다. 바인딩 요청을 통해 학습된 서버 반사 후보의 경우 서버에 대한 추가 바인딩 요청을 통해 바인딩이 활성 상태로 유지되어야 합니다. 할당에 대한 새로 고침은 \[RFC5766\]에 설명된 대로 새로 고침 트랜잭션을 사용하여 수행됩니다. 새로 고침 요청은 서버 반사 후보도 새로 고칩니다.\(MUST, MUST\)

---
#### **4.1.2.  Prioritizing Candidates**

우선순위 지정 프로세스를 통해 각 후보자에게 우선순위가 지정됩니다. 미디어 스트림의 각 후보는 1과 \(2\*\*31 - 1\) 사이의 양의 정수여야 하는 고유한 우선순위를 가져야 합니다. 이 우선순위는 ICE에서 연결 확인 순서와 후보자의 상대적 선호도를 결정하는 데 사용됩니다.\(MUST\)

에이전트는 섹션 4.1.2.1의 공식을 사용하여 이 우선순위를 계산해야 하며 섹션 4.1.2.2의 지침을 사용하여 해당 매개변수를 선택해야 합니다. 에이전트가 다른 공식을 사용하기로 선택한 경우 두 에이전트가 수표에서 조정되지 않으므로 ICE가 수렴하는 데 더 오랜 시간이 걸립니다.\(SHOULD\)

---
##### **4.1.2.1.  Recommended Formula**

공식을 사용할 때 에이전트는 각 후보 유형\(서버 반사, 피어 반사, 릴레이 및 호스트\)에 대한 기본 설정을 결정하고 에이전트가 멀티홈인 경우 해당 IP 주소에 대한 기본 설정을 선택하여 우선 순위를 계산합니다. 그런 다음 이 두 가지 선호도를 결합하여 후보자의 우선순위를 계산합니다. 해당 우선순위는 다음 공식을 사용하여 계산됩니다.

```text
   priority = (2^24)*(type preference) +
              (2^8)*(local preference) +
              (2^0)*(256 - component ID)
```

유형 선호도는 0부터 126까지의 정수여야 하며 후보 유형에 대한 선호도를 나타냅니다\(유형은 로컬, 서버 반사, 피어 반사 및 릴레이\). 126은 가장 높은 선호도이고 0은 가장 낮은 선호도입니다. 값을 0으로 설정하면 이 유형의 후보가 최후의 수단으로만 사용된다는 의미입니다. 유형 선호도는 동일한 유형의 모든 후보자에 대해 동일해야 하며\(MUST\) 다른 유형의 후보자에 대해서는 달라야 합니다\(MUST\). 동료 반사 후보자의 유형 선호도는 서버 반사 후보자의 유형 선호도보다 높아야 합니다. 섹션 4.1.1의 절차에 따라 모인 후보자는 동료 성찰 후보자가 될 수 없습니다. 이러한 유형의 후보는 ICE가 수행하는 연결 확인을 통해 학습됩니다.\(MUST, MUST, MUST\)

로컬 기본 설정은 0부터 65535까지의 정수여야 합니다. 에이전트가 멀티홈인 경우 후보를 얻은 특정 IP 주소에 대한 기본 설정을 나타냅니다. 65535는 가장 높은 선호도를 나타내고 0은 가장 낮은 선호도를 나타냅니다. IP 주소가 하나만 있는 경우 이 값은 65535로 설정되어야 합니다. 보다 일반적으로 동일한 유형을 가진 특정 미디어 스트림에 대한 특정 구성 요소에 대한 후보가 여러 개 있는 경우 로컬 기본 설정은 각 항목에 대해 고유해야 합니다. 이 사양에서는 이는 멀티홈 호스트에 대해서만 발생합니다. 호스트가 이중 스택이기 때문에 멀티홈인 경우 로컬 기본 설정은 RFC 3484 \[RFC3484\]에 설명된 IP 주소의 우선 순위 값과 동일하게 설정되어야 합니다.\(MUST, SHOULD, MUST, SHOULD\)

구성 요소 ID는 후보의 구성 요소 ID이며 1에서 256 사이여야 합니다.\(MUST\)

---
##### **4.1.2.2.  Guidelines for Choosing Type and Local Preferences**

유형 및 로컬 기본 설정 값을 선택하는 기준 중 하나는 TURN 서버, VPN 서버 또는 NAT와 같은 미디어 중개자를 사용하는 것입니다. 미디어 중개자를 통해 미디어가 해당 미디어로 전송되는 경우

후보인 경우, 수신되기 전에 먼저 미디어 중개자를 통과하게 됩니다. 릴레이된 후보자는 미디어 중개자를 포함하는 후보자 유형 중 하나입니다. 다른 하나는 VPN 인터페이스에서 얻은 호스트 후보입니다. 미디어가 미디어 중개자를 통해 전송되면 전송과 수신 사이의 대기 시간이 늘어날 수 있습니다. 추가 라우터 홉이 필요할 수 있으므로 패킷 손실이 증가할 수 있습니다. 미디어는 공급자가 운영하는 미디어 중개자를 통해 바로 들어오고 나가기 때문에 서비스 제공 비용이 증가할 수 있습니다. 이러한 문제가 중요하다면 릴레이된 후보에 대한 유형 선호도는 호스트 후보보다 낮아야 합니다. RECOMMENDED 값은 호스트 후보의 경우 126, 서버 반사 후보의 경우 100, 피어 반사 후보의 경우 110, 릴레이된 후보의 경우 0입니다. 또한 에이전트가 멀티홈이고 여러 IP 주소를 갖는 경우 VPN 인터페이스의 호스트 후보에 대한 로컬 기본 설정의 우선 순위는 0이어야 합니다.\(SHOULD, SHOULD, SHOULD\)

기본 설정 선택의 또 다른 기준은 IP 주소 계열입니다. ICE는 IPv4 및 IPv6 모두에서 작동합니다. 따라서 듀얼 스택 호스트가 IPv6보다 연결을 선호하지만 v6 네트워크의 연결이 끊어지는 경우\(예: 6to4 릴레이 오류로 인해\) IPv4로 대체할 수 있는 전환 메커니즘을 제공합니다\[RFC3056\]. 또한 기본 IPv6 주소와 6to4 주소가 모두 있는 호스트에도 도움이 될 수 있습니다. 이러한 경우 v6 주소, 6to4 주소, v4 주소 순으로 더 높은 로컬 기본 설정이 할당될 수 있습니다. 이를 통해 사이트는 즉시 기본 v6 주소를 얻고 사용을 시작할 수 있지만 아직 기본 v6 연결이 없는 다른 사이트의 에이전트와 통신할 때는 6to4 주소로 대체할 수 있습니다.

기본 설정을 선택하는 또 다른 기준은 보안입니다. 사용자가 재택근무자이므로 기업 네트워크 및 로컬 홈 네트워크에 연결되어 있는 경우, 사용자는 기업 내에서 통신할 때 음성 트래픽을 기업 네트워크에 유지하기 위해 VPN을 통해 라우팅하는 것을 선호할 수 있습니다. 기업 외부 사용자와 통신할 때 로컬 네트워크. 이러한 경우 VPN 주소는 다른 주소보다 로컬 선호도가 더 높습니다.

기본 설정을 선택하는 또 다른 기준은 위상적 인식입니다. 이는 중개자를 활용하는 후보자에게 가장 유용합니다. 이러한 경우 에이전트가 중개자의 위상적 근접성에 대한 지식을 미리 구성하거나 동적으로 발견한 경우 이를 사용하여 더 가까운 중개자로부터 얻은 후보에 더 높은 로컬 선호도를 할당할 수 있습니다.

---
#### **4.1.3.  Eliminating Redundant Candidates**

다음으로 에이전트는 중복된 후보를 제거합니다. 전송 주소가 다른 후보와 같고 해당 베이스가 다른 후보의 베이스와 같을 경우 후보는 중복됩니다. 두 후보가 동일한 전송 주소를 가질 수 있지만 기반이 다를 수 있으며 이는 중복된 것으로 간주되지 않습니다. 에이전트가 NAT 뒤에 있지 않으면 서버 반사 후보와 호스트 후보가 중복되는 경우가 많습니다. 에이전트는 우선순위가 낮은 중복 후보를 제거해야 합니다\(SHOULD\).\(SHOULD\)

---
#### **4.1.4.  Choosing Default Candidates**

ICE가 아닌 동료의 미디어 대상이 될 경우 해당 후보는 기본값이라고 합니다. 해당 대상을 DEFAULT DESTINATION이라고 합니다. ICE 인식 피어와 통신할 때 ICE 알고리즘에 의해 기본 후보가 선택되지 않은 경우 미디어의 기본 대상이 미디어의 기본 대상과 일치하도록 SDP를 "수정"하려면 ICE 처리가 완료된 후 업데이트된 제안/응답이 필요합니다. ICE가 선정한 후보자. ICE가 기본 후보자를 선택하는 경우 업데이트된 제안/답변이 필요하지 않습니다.

에이전트는 각 사용 중인 미디어 스트림의 각 구성 요소에 대해 하나씩 후보 집합을 기본값으로 선택해야 합니다. 포트 0\(미디어 스트림을 거부하기 위해 RFC 3264에서 사용됨\)이 없는 경우 미디어 스트림은 사용 중입니다. 결과적으로 미디어 스트림은 a=inactive \[RFC4566\]로 표시되거나 대역폭 값이 0인 경우에도 사용 중입니다.\(MUST\)

해당 후보자가 연락 중인 피어와 함께 작업할 가능성을 기반으로 기본 후보자를 선택하는 것이 좋습니다. 기본 후보는 릴레이된 후보\(릴레이된 후보가 사용 가능한 경우\), 서버 반사 후보\(서버 반사 후보가 사용 가능한 경우\) 및 마지막으로 호스트 후보인 것이 좋습니다.\(SHOULD, SHOULD\)

---
### **4.2.  Lite Implementation Requirements**

라이트 구현에서는 호스트 후보만 활용합니다. 라이트 구현은 각 미디어 스트림의 각 구성 요소에 대해 IPv4 후보를 0개 또는 1개 할당해야 합니다. 0개 이상의 IPv6 후보를 할당할 수 있지만 호스트가 사용하는 각 IPv6 주소당 하나만 할당할 수 있습니다. 각 미디어 스트림의 구성 요소당 IPv4 후보는 하나만 있을 수 있으므로 에이전트가 여러 개의 IPv4 주소를 갖고 있는 경우 후보 할당을 위해 하나를 선택해야 합니다. 호스트가 듀얼 스택인 경우 하나의 IPv4 후보와 하나의 전역 IPv6 주소를 할당하는 것이 좋습니다. 라이트 구현에서는 ICE를 사용하여 후보 중에서 동적으로 선택할 수 없습니다. 따라서 특정 범위에서 둘 이상의 후보자를 포함\(MUST, MAY, MUST, SHOULD\)

연결 확인을 통해서만 하나의 주소를 사용할지 다른 주소를 사용할지 실제로 결정할 수 있으므로 권장되지 않습니다.\(SHOULD NOT\)

각 구성 요소에는 구성 요소 ID라고 하는 ID가 할당되어 있습니다. RTP 기반 미디어 스트림의 경우 RTP 자체의 구성 요소 ID는 1이고 RTCP의 구성 요소 ID는 2입니다. 에이전트가 RTCP를 사용하는 경우 이에 대한 후보를 가져와야 합니다.\(MUST\)

각 후보자에게는 재단이 지정됩니다. 기반은 서로 다른 IP 주소에서 할당된 두 후보에 대해 달라야 하며, 그렇지 않으면 동일해야 합니다. 각 IP 주소에 대해 증가하는 간단한 정수이면 충분합니다. 또한 각 후보에는 동일한 미디어 스트림에 대한 모든 후보 중에서 고유한 우선순위가 할당되어야 합니다. 이 우선순위는 다음과 같아야 합니다.\(MUST, MUST, SHOULD\)

```text
   priority = (2^24)*(126) +
              (2^8)*(IP precedence) +
              (2^0)*(256 - component ID)
```

호스트가 v4 전용인 경우 IP 우선 순위를 65535로 설정해야 합니다. 호스트가 v6 또는 이중 스택인 경우 IP 우선 순위는 RFC 3484 \[RFC3484\]에 설명된 IP 주소의 우선 순위 값이어야 합니다.\(SHOULD, SHOULD\)

다음으로 에이전트는 각 미디어 스트림의 각 구성 요소에 대한 기본 후보를 선택합니다. 호스트가 IPv4 전용인 경우 각 미디어 스트림의 각 구성 요소에 대해 하나의 후보만 있으므로 해당 후보가 기본값입니다. 호스트가 IPv6 또는 이중 스택인 경우 기본값 선택은 로컬 정책의 문제입니다. 이 기본값은 동료와 함께 사용될 가능성이 가장 높은 후보가 되도록 선택해야 합니다. IPv6 전용 호스트의 경우 이는 일반적으로 전역적으로 범위가 지정된 IPv6 주소입니다. 듀얼 스택 호스트의 경우 IPv4 주소를 권장합니다.\(SHOULD, SHOULD\)

---
### **4.3.  Encoding the SDP**

SDP 인코딩 프로세스는 전체 구현과 라이트 구현에서 동일합니다.

에이전트는 사용하려는 각 미디어 스트림에 대해 m 행을 포함합니다. SDP의 미디어 스트림 순서는 ICE와 관련이 있습니다. ICE는 먼저 첫 번째 m 라인에 대한 연결 검사를 수행하고 결과적으로 미디어는 해당 스트림에 대해 먼저 흐를 수 있습니다. 에이전트는 가장 중요한 미디어 스트림이 있는 경우 SDP에 가장 먼저 배치해야 합니다.\(SHOULD\)

특정 미디어 스트림의 각 후보에 대한 후보 속성이 있습니다. 섹션 15에서는 이 속성을 구성하기 위한 자세한 규칙을 제공합니다. 속성은 IP 주소를 전달합니다.

ICE가 작동하기 위해 피어에게 신호를 보내야 하는 속성\(우선 순위, 기반 및 구성 요소 ID\) 외에도 후보에 대한 포트 및 전송 프로토콜이 있습니다. Candidate 속성은 진단 및 기타 기능에 유용한 후보자에 대한 정보\(해당 유형 및 관련 전송 주소\)도 전달합니다.

에이전트 간 STUN 연결 확인은 STUN \[RFC5389\]에 정의된 단기 자격 증명 메커니즘을 사용하여 인증됩니다. 이 메커니즘은 클라이언트와 서버 간에 프로토콜을 통해 교환되는 사용자 이름과 비밀번호에 의존합니다. ICE에서는 제안/답변 교환을 통해 이를 교환합니다. 이 자격 증명의 사용자 이름 부분은 콜론으로 구분된 각 에이전트의 사용자 이름 조각을 연결하여 구성됩니다. 각 에이전트는 수신한 요청에 대한 메시지 무결성을 계산하는 데 사용되는 암호도 제공합니다. 사용자 이름 조각과 비밀번호는 각각 ice-ufrag 및 ice-pwd 속성에서 교환됩니다. 보안을 제공하는 것 외에도 사용자 이름은 미디어 스트림에 대한 검사의 명확성과 상관 관계를 제공합니다. 동기 부여는 부록 B.4를 참조하세요.

에이전트가 라이트 구현인 경우 SDP에 "a=ice-lite" 세션 수준 속성을 포함해야 합니다. 에이전트가 전체 구현인 경우 이 속성을 포함하면 안 됩니다.\(MUST, MUST NOT\)

기본 후보는 미디어의 기본 대상으로 SDP에 추가됩니다. RTP 기반 스트림의 경우 RTP 후보의 IP 주소와 포트를 각각 c 및 m 라인에 배치하여 수행됩니다. 에이전트가 RTCP를 활용하는 경우 RFC 3605 \[RFC3605\]에 정의된 대로 a=rtcp 속성을 사용하여 RTCP 후보를 인코딩해야 합니다. RTCP가 사용되지 않는 경우 에이전트는 RFC 3556 \[RFC3556\]에 정의된 대로 b=RS:0 및 b=RR:0을 사용한다는 신호를 보내야 합니다.\(MUST, MUST\)

ICE가 아닌 피어와 통신할 때 미디어의 기본 대상이 될 전송 주소도 하나 이상의 a=candidate 라인에 후보로 존재해야 합니다.\(MUST\)

ICE는 해당 에이전트가 사용하는 ICE 확장을 식별하는 일련의 토큰을 포함하는 제안 또는 답변을 허용하여 확장성을 제공합니다. 에이전트가 ICE 확장을 지원하는 경우 ice-options 속성에 해당 확장에 대해 정의된 토큰을 포함해야 합니다.\(MUST\)

다음은 ICE 속성\(가독성을 위해 줄이 접혀 있음\)을 포함하는 SDP 메시지의 예입니다.

```text
       v=0
       o=jdoe 2890844526 2890842807 IN IP4 10.0.1.1
       s=
       c=IN IP4 192.0.2.3
       t=0 0
       a=ice-pwd:asd88fgpdd777uzjYhagZg
       a=ice-ufrag:8hhY
       m=audio 45664 RTP/AVP 0
       b=RS:0
       b=RR:0
       a=rtpmap:0 PCMU/8000
       a=candidate:1 1 UDP 2130706431 10.0.1.1 8998 typ host
       a=candidate:2 1 UDP 1694498815 192.0.2.3 45664 typ srflx raddr
   10.0.1.1 rport 8998
```

에이전트가 제안이나 답변을 전송하면 해당 에이전트는 각 후보에 대해 STUN과 미디어 패킷을 모두 수신할 준비를 해야 합니다. 섹션 11.1에서 설명한 것처럼 미디어 패킷은 제안이나 응답에서 미디어의 기본 대상으로 나타나기 전에 후보자에게 전송될 수 있습니다.\(MUST\)

---
## **5.  Receiving the Initial Offer**

에이전트가 초기 제안을 받으면 제안자가 ICE를 지원하는지 확인하고, 자체 역할을 결정하고, 후보를 수집하고, 우선 순위를 지정하고, 기본 후보를 선택하고, 답변을 인코딩 및 전송하고, 전체 구현의 경우 체크리스트를 구성하고 연결을 시작합니다. 체크 무늬.

---
### **5.1.  Verifying ICE Support**

에이전트는 수신한 SDP의 각 미디어 스트림에 대해 해당 미디어 스트림의 각 구성 요소에 대한 기본 대상이 후보 속성에 나타나는 경우 이 사양에 정의된 ICE 절차를 진행합니다. 예를 들어 RTP의 경우 c줄과 m줄의 IP 주소와 포트가 각각 Candidate 속성에 나타나고 rtcp 속성의 값이 Candidate 속성에 나타납니다.

이 조건이 충족되지 않으면 에이전트는 다음 예외를 제외하고 이 사양의 나머지 부분에 설명된 ICE 메커니즘을 사용하지 않고 일반 RFC 3264 절차를 기반으로 SDP를 처리해야 합니다.\(MUST\)

1. 에이전트는 모든 에이전트에 대한 연결 유지 절차를 설명하는 섹션 10의 규칙을 따라야 합니다.\(MUST\)

2. a=candidate 속성이 있지만 미디어 스트림의 기본 대상과 일치하는 속성이 없기 때문에 에이전트가 ICE를 진행하지 않는 경우 에이전트는 응답에 a=ice-mismatch 속성을 포함해야 합니다.\(MUST\)

3. 기본 후보가 TURN 서버를 통해 학습된 릴레이된 후보인 경우 에이전트는 방금 수신한 SDP의 피어로부터 학습된 IP 주소에 대해 TURN 서버에서 권한을 생성해야 합니다. 그렇지 않으면 피어의 미디어 스트림에 있는 초기 패킷이 손실될 수 있습니다.\(MUST\)

---
### **5.2.  Determining Role**

각 세션마다 각 상담원이 역할을 맡습니다. 통제와 통제라는 두 가지 역할이 있습니다. 제어 에이전트는 통신에 사용되는 최종 후보 쌍의 선택을 담당합니다. 전체 에이전트의 경우 이는 각 미디어 스트림에 대해 ICE에서 사용할 수 있는 후보 쌍을 지정하고 필요할 때 ICE의 선택을 기반으로 업데이트된 제안을 생성하는 것을 의미합니다. 간단한 구현의 경우 제어 에이전트가 된다는 것은 제안 및 답변\(IPv4의 경우 한 쌍만 있음\)에 있는 후보 쌍을 기반으로 후보 쌍을 선택한 다음 필요할 때 해당 선택을 반영하는 업데이트된 제안을 생성하는 것을 의미합니다\( IPv4 전용 호스트에는 필요하지 않습니다\). 제어된 에이전트는 각 미디어 스트림에 사용할 후보 쌍을 알려주고 이 정보를 알리기 위해 업데이트된 제안을 생성하지 않습니다. 아래 섹션에서는 노드 제어 및 제어에 따른 실제 절차를 자세히 설명합니다.

역할과 행동에 미치는 영향을 결정하는 규칙은 다음과 같습니다.

두 에이전트 모두 꽉 찼습니다. ICE 처리를 시작한 제안을 생성한 에이전트는 제어 역할을 맡아야 하며, 다른 에이전트는 제어 역할을 맡아야 합니다. 두 에이전트 모두 체크리스트를 작성하고, ICE 상태 시스템을 실행하고, 연결 확인을 생성합니다. 제어 에이전트는 섹션 8.1의 논리를 실행하여 ICE에 의해 선택될 쌍을 지정하고 섹션 8.1.2에 설명된 대로 두 에이전트 모두 ICE를 종료합니다. 부록 B.11에 설명된 특이한 경우에는 두 대리인 모두 자신이 통제되거나 통제되고 있다고 잘못 믿을 수 있습니다. 이 문제를 해결하려면 각 에이전트는 0과 \(2\*\*64\) - 1\(즉, 64비트 양의 정수\) 사이에 균일하게 분포된 타이 브레이커라고 하는 난수를 선택해야 합니다. 이 번호는 섹션 7.1.2.2에 설명된 대로 이 사례를 감지하고 복구하기 위해 연결 확인에 사용됩니다.\(MUST, MUST\)

전체 에이전트 1개, 라이트 1개: 전체 에이전트는 제어 역할을 맡아야 하고, 라이트 에이전트는 제어 역할을 맡아야 합니다. 전체 에이전트는 체크리스트를 작성하고, ICE 상태 시스템을 실행하고, 연결 확인을 생성합니다. 해당 에이전트는 섹션 8.1의 논리를 실행하여 ICE가 선택할 쌍을 지정하고 섹션 8.1.2의 논리를 사용하여 ICE를 종료합니다. 간단한 구현은 연결 확인을 수신하고 이를 수신하고 응답한 다음 섹션 8.2에 설명된 대로 ICE를 종료합니다. 라이트 구현의 경우 각 미디어 스트림에 대한 ICE 처리 상태는 실행 중으로 간주되며 전체 ICE 상태는 실행 중입니다.\(MUST\)

둘 다 라이트: ICE 처리를 시작한 제안을 생성한 에이전트는 제어 역할을 맡아야 하며, 다른 에이전트는 제어된 역할을 맡아야 합니다. 이 경우 연결 확인이 전송되지 않습니다. 오히려 제안/응답 교환이 완료되면 각 에이전트는 연결 확인 없이 섹션 8에 설명된 처리를 수행합니다. 두 에이전트 모두 자신이 통제되거나 통제되고 있다고 믿을 가능성이 있습니다. 후자의 경우 제안/응답 교환을 전달하는 신호 프로토콜의 눈부심 감지 기능을 통해 충돌이 해결됩니다. 각 미디어 스트림에 대한 ICE 처리 상태는 실행 중으로 간주되며 전체 ICE 상태는 실행 중입니다.\(MUST\)

세션에 대해 역할이 결정되면 ICE가 다시 시작되지 않는 한 지속됩니다. ICE를 다시 시작하면\(섹션 9.1\) 역할과 순위 결정자가 새로 선택됩니다.

---
### **5.3.  Gathering Candidates**

응답자에게 후보자를 모으는 프로세스는 전체 구현의 경우 섹션 4.1.1, 라이트 구현의 경우 섹션 4.2에 설명된 제안자 프로세스와 동일합니다. 이 프로세스는 사용자에게 알리기 전에 제안을 받은 즉시 시작하는 것이 좋습니다. 이러한 수집은 에이전트가 시작될 때 시작될 수 있습니다.\(SHOULD, MAY\)

---
### **5.4.  Prioritizing Candidates**

응답자에서 후보자의 우선 순위를 지정하는 프로세스는 전체 구현의 경우 섹션 4.1.2, 라이트 구현의 경우 섹션 4.2에 설명된 대로 제안자가 따르는 프로세스와 동일합니다.

---
### **5.5.  Choosing Default Candidates**

응답자에서 기본 후보를 선택하는 프로세스는 전체 구현의 경우 섹션 4.1.4, 라이트 구현의 경우 섹션 4.2에 설명된 대로 제안자가 따르는 프로세스와 동일합니다.

---
### **5.6.  Encoding the SDP**

응답자에서 SDP를 인코딩하는 프로세스는 섹션 4.3에 설명된 대로 전체 및 라이트 구현 모두에 대해 제공자가 따르는 프로세스와 동일합니다.

---
### **5.7.  Forming the Check Lists**

체크리스트 작성은 전체 구현에 의해서만 수행됩니다. 라이트 구현은 이 섹션에 정의된 단계를 건너뛰어야 합니다.\(MUST\)

제안/응답 교환으로 인해 사용 중인 미디어 스트림당 하나의 체크리스트가 있습니다. 미디어 스트림에 대한 체크리스트를 구성하기 위해 에이전트는 후보 쌍을 형성하고, 후보 쌍 우선순위를 계산하고, 우선순위에 따라 쌍을 정렬하고, 정리하고, 상태를 설정합니다. 이 섹션에서는 이러한 단계를 설명합니다.

---
#### **5.7.1.  Forming Candidate Pairs**

먼저 에이전트는 미디어 스트림에 대한 각 후보\(LOCAL CANDIDATES라고 함\)를 가져와 해당 미디어 스트림에 대해 피어\(REMOTE CANDIDATES라고 함\)로부터 받은 후보와 쌍을 이룹니다. 섹션 18.5.2에 설명된 공격을 방지하기 위해 에이전트는 제안이나 답변에서 수락할 후보의 수를 제한할 수 있습니다. 로컬 후보는 두 후보가 동일한 구성 요소 ID를 갖고 동일한 IP 주소 버전을 갖는 경우에만 원격 후보와 쌍을 이룹니다. 일부 로컬 후보자가 원격 후보자와 짝을 이루지 못하고 일부 원격 후보자가 로컬 후보자와 짝을 이루지 못할 가능성이 있습니다. 이는 하나의 에이전트가 미디어 스트림의 모든 구성 요소에 대한 후보를 포함하지 않는 경우 발생할 수 있습니다. 이런 일이 발생하면 해당 미디어 스트림의 구성 요소 수가 효과적으로 줄어들고 미디어 스트림의 모든 구성 요소에서 각 에이전트가 제공하는 최대 구성 요소 ID의 두 에이전트에서 최소값과 동일한 것으로 간주됩니다.\(MAY\)

RTP의 경우 한 에이전트가 RTCP 후보를 제공하고 다른 에이전트는 제공하지 않을 때 이런 일이 발생합니다. 또 다른 예로, 제공자는 동일한 포트에서 RTP와 RTCP를 다중화할 수 있으며 SDP 속성\[RFC5761\]을 통해 SDP에서 이를 수행할 수 있음을 알립니다. 그러나 제안자는 응답자가 수행할 수 있는지 알 수 없기 때문에

이러한 멀티플렉싱을 통해 제공자는 별도의 포트에 RTP 및 RTCP 후보를 포함하므로 제안에는 미디어 스트림당 두 개의 구성 요소가 있습니다. 응답자가 이러한 멀티플렉싱을 수행할 수 있는 경우 결합된 RTP/RTCP 다중화에 대해 각 후보에 대해 단일 구성 요소만 포함됩니다. ICE는 결국 이 후보에 대해 단 하나의 구성 요소만 있는 것처럼 작동하게 됩니다.

로컬 및 원격 후보가 모두 특정 구성 요소에 대한 기본 후보인 후보 쌍을 해당 구성 요소에 대한 기본 후보 쌍이라고 합니다. 이는 두 에이전트가 모두 ICE를 인식하지 못한 경우 미디어를 전송하는 데 사용되는 쌍입니다.

이해를 돕기 위해 그림 6은 후보와 후보 쌍의 주요 속성을 나타내는 것 외에도 전송 주소, 후보, 후보 쌍 및 체크리스트 등 여러 주요 개념 간의 관계를 보여줍니다.

```text
       +------------------------------------------+
       |                                          |
       | +---------------------+                  |
       | |+----+ +----+ +----+ |   +Type          |
       | || IP | |Port| |Tran| |   +Priority      |
       | ||Addr| |    | |    | |   +Foundation    |
       | |+----+ +----+ +----+ |   +ComponentiD   |
       | |      Transport      |   +RelatedAddr   |
       | |        Addr         |                  |
       | +---------------------+   +Base          |
       |             Candidate                    |
       +------------------------------------------+
       *                                         *
       *    *************************************
       *    *
     +-------------------------------+
    .|                               |
     | Local     Remote              |
     | +----+    +----+   +default?  |
     | |Cand|    |Cand|   +valid?    |
     | +----+    +----+   +nominated?|
     |                    +State     |
     |                               |
     |                               |
     |          Candidate Pair       |
     +-------------------------------+
     *                              *
     *                  ************
     *                  *
     +------------------+
     |  Candidate Pair  |
     +------------------+
     +------------------+
     |  Candidate Pair  |
     +------------------+
     +------------------+
     |  Candidate Pair  |
     +------------------+

            Check
            List
```

- 그림 6: 체크리스트의 개념도

---
#### **5.7.2.  Computing Pair Priority and Ordering Pairs**

쌍이 형성되면 후보 쌍 우선순위가 계산됩니다. G를 제어 에이전트가 제공한 후보의 우선순위로 설정합니다. D를 제어 에이전트가 제공하는 후보의 우선순위로 설정합니다. 쌍의 우선순위는 다음과 같이 계산됩니다.

```text
      pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)
```

여기서 G\>D?1:0은 G가 D보다 크면 값이 1이고 그렇지 않으면 0인 표현식입니다. 우선순위가 할당되면 에이전트는 우선순위가 감소하는 순서로 후보 쌍을 정렬합니다. 두 쌍의 우선순위가 동일한 경우 쌍 사이의 순서는 임의적입니다.

---
#### **5.7.3.  Pruning the Pairs**

이렇게 정렬된 후보 쌍 목록은 수행될 연결 확인 순서를 결정하는 데 사용됩니다. 각 확인에는 로컬 후보의 요청을 원격 후보로 보내는 작업이 포함됩니다. 에이전트는 재귀적 후보로부터 직접 요청을 보낼 수 없고 해당 기반에서만 요청을 보낼 수 있으므로 에이전트는 다음으로 정렬된 후보 쌍 목록을 살펴봅니다. 로컬 후보가 서버 반사인 각 쌍에 대해 서버 반사 후보는 해당 베이스로 대체되어야 합니다. 이 작업이 완료되면 에이전트는 목록을 정리해야 합니다. 이는 로컬 및 원격 후보가 우선순위 목록에서 더 높은 쌍의 로컬 및 원격 후보와 동일한 경우 쌍을 제거하여 수행됩니다. 결과는 해당 미디어 스트림에 대한 체크리스트라고 하는 순서가 지정된 후보 쌍의 시퀀스입니다.\(MUST, MUST\)

또한 섹션 18.5.2에 설명된 공격을 제한하기 위해 에이전트는 에이전트가 모든 체크리스트에서 수행하는 연결 검사의 총 횟수를 특정 값으로 제한해야 하며 이 값은 구성 가능해야 합니다. 기본값은 100입니다. 권장됩니다. 이 제한은 100개 미만이 될 때까지 우선순위가 낮은 후보 쌍을 삭제하여 적용됩니다. 가능하면 더 낮은 값을 사용하고 실제 배포 구성에서 볼 수 있는 타당한 검사의 최대 수로 설정하는 것이 좋습니다. 구성 요구 사항은 배포 후 문제가 있는 것으로 확인되는 경우 현장에서 이 값을 수정하기 위한 도구를 제공하기 위한 것입니다.\(MUST, SHOULD, SHOULD\)

---
#### **5.7.4.  Computing States**

체크리스트의 각 후보 쌍에는 기초와 상태가 있습니다. 기초는 쌍의 로컬 및 원격 후보자의 기초를 결합한 것입니다. 각 미디어 스트림에 대한 체크리스트가 계산되면 상태가 할당됩니다. 상태가 가질 수 있는 5가지 잠재적 가치는 다음과 같습니다.

대기 중: 이 쌍에 대해서는 검사가 수행되지 않았으며 검사 목록에서 우선순위가 가장 높은 대기 쌍이 되면 바로 수행할 수 있습니다.

진행 중: 이 쌍에 대한 수표가 전송되었지만

- 거래가 진행 중입니다.

성공: 이 쌍에 대한 검사가 이미 완료되어 성공적인 결과를 얻었습니다.

실패: 이 쌍에 대한 검사가 이미 완료되어 실패했습니다. 응답이 생성되지 않거나 복구할 수 없는 오류 응답이 생성됩니다.

고정: 이 쌍에 대한 검사가 수행되지 않았으며 다른 검사가 성공할 때까지 아직 수행할 수 없습니다. 따라서 이 쌍이 고정 해제되고 대기 상태로 전환됩니다.

ICE가 실행되면 그림 7과 같이 쌍이 상태 간에 이동합니다.

```text
      +-----------+
      |           |
      |           |
      |  Frozen   |
      |           |
      |           |
      +-----------+
            |
            |unfreeze
            |
            V
      +-----------+         +-----------+
      |           |         |           |
      |           | perform |           |
      |  Waiting  |-------->|In-Progress|
      |           |         |           |
      |           |         |           |
      +-----------+         +-----------+
                                  / |
                                //  |
                              //    |
                            //      |
                           /        |
                         //         |
               failure //           |success
                     //             |
                    /               |
                  //                |
                //                  |
              //                    |
             V                      V
      +-----------+         +-----------+
      |           |         |           |
      |           |         |           |
      |   Failed  |         | Succeeded |
      |           |         |           |
      |           |         |           |
      +-----------+         +-----------+

                         Figure 7: Pair State FSM
```

체크리스트의 각 쌍에 대한 초기 상태는 다음과 같은 일련의 단계를 수행하여 계산됩니다.

1. 에이전트는 각 체크리스트의 모든 쌍을 Frozen 상태로 설정합니다.

2. 에이전트는 첫 번째 미디어 스트림에 대한 체크리스트를 검사합니다\(미디어 스트림은 SDP 제안 및 응답의 첫 번째 m 라인으로 설명될 때 첫 번째 미디어 스트림입니다\). 해당 미디어 스트림의 경우:

- \* 동일한 기반을 가진 모든 쌍에 대해 가장 낮은 구성 요소 ID를 가진 쌍의 상태를 대기 중으로 설정합니다. 그러한 쌍이 두 개 이상 있는 경우 우선 순위가 가장 높은 쌍이 사용됩니다.

체크리스트 중 하나에는 대기 상태의 일부 쌍이 있고 다른 체크리스트에는 모든 쌍이 Frozen 상태에 있습니다. 최소한 한 쌍이 대기 중인 체크리스트를 활성 체크리스트라고 하며, 모든 쌍이 동결된 체크리스트를 동결 체크리스트라고 합니다.

체크리스트 자체는 해당 미디어 스트림에 대한 ICE 검사 상태를 캡처하는 상태와 연결됩니다. 세 가지 상태가 있습니다.

실행 중: 이 상태에서는 이 미디어 스트림에 대한 ICE 검사가 계속 진행 중입니다.

완료됨: 이 상태에서는 ICE 검사가 미디어 스트림의 각 구성 요소에 대해 지정된 쌍을 생성했습니다. 결과적으로 ICE가 성공했으며 미디어를 보낼 수 있습니다.

실패: 이 상태에서는 ICE 확인이 완료되지 않았습니다.

- 이 미디어 스트림에 성공했습니다.

제안/답변 교환의 결과로 체크리스트가 처음 구성되면 실행 중 상태가 됩니다.

모든 미디어 스트림에 걸친 ICE 처리에도 이와 관련된 상태가 있습니다. 이 상태는 ICE 처리가 진행 중인 동안 실행 중과 같습니다. ICE 처리가 완료되면 상태는 완료\(Completed\)이고, 성공하지 못한 채 실패하면 실패\(Failed\)입니다. 상태 간 전환 규칙은 아래에 설명되어 있습니다.

---
### **5.8.  Scheduling Checks**

검사는 전체 구현에 의해서만 생성됩니다. 라이트 구현은 이 섹션에 설명된 단계를 건너뛰어야 합니다.\(MUST\)

에이전트는 일반 검사와 트리거된 검사를 수행합니다. 두 검사의 생성은 각 미디어 스트림에 대해 주기적으로 실행되는 타이머에 의해 제어됩니다. 에이전트는 트리거된 확인 대기열이라고 하는 FIFO 대기열을 유지 관리합니다. 이 대기열에는 다음 사용 가능한 시간에 확인이 전송될 후보 쌍이 포함되어 있습니다.

기회. 타이머가 실행되면 에이전트는 트리거된 확인 대기열에서 최상위 쌍을 제거하고 해당 쌍에 대한 연결 확인을 수행하며 후보 쌍의 상태를 진행 중으로 설정합니다. 트리거된 검사 대기열에 쌍이 없으면 일반 검사가 전송됩니다.

에이전트가 섹션 5.7에 설명된 대로 체크리스트를 계산한 후에는 각 활성 체크리스트에 대한 타이머를 설정합니다. 타이머는 Ta\*N 초마다 실행됩니다. 여기서 N은 활성 체크리스트의 수입니다\(초기에는 활성 체크리스트가 하나만 있습니다\). 구현에서는 타이머가 이보다 덜 자주 실행되도록 설정할 수 있습니다. 구현에서는 각 미디어 스트림에 대해 동시에 실행되지 않도록 이러한 타이머를 분산시켜야 합니다. Ta와 재전송 타이머 RTO는 섹션 16에 설명된 대로 계산됩니다. N을 곱하면 이 집계 검사 처리량을 모든 활성 검사 목록 간에 분할할 수 있습니다. 첫 번째 타이머가 즉시 실행되므로 에이전트는 제안/응답 교환이 완료된 순간 연결 확인을 수행하고 몇 초 후에 다음 확인이 수행됩니다\(활성 확인 목록이 하나만 있기 때문에\).\(MAY, SHOULD\)

타이머가 작동하고 전송될 트리거된 확인이 없는 경우 에이전트는 다음과 같이 일반 확인을 선택해야 합니다.\(MUST\)

o 대기 상태에 있는 체크리스트에서 우선순위가 가장 높은 쌍을 찾으십시오.

o 그러한 쌍이 있는 경우:

- \* 해당 쌍의 로컬 후보에서 해당 쌍의 원격 후보로 STUN 검사를 보냅니다. 이 목적을 위한 STUN 요청을 구성하는 절차는 섹션 7.1.2에 설명되어 있습니다.

- \* 후보 쌍의 상태를 진행 중으로 설정합니다.

o 그러한 쌍이 없는 경우:

- \* 해당 체크리스트에서 Frozen 상태에 있는 가장 우선순위가 높은 쌍을 찾으세요.

- \* 그러한 쌍이 있는 경우:

- + 쌍을 고정 해제합니다.

+ 해당 쌍에 대한 검사를 수행하여 상태를 다음과 같이 만듭니다.

- 진행 중으로 전환됩니다.

- \* 해당 쌍이 없는 경우:

- + 해당 체크리스트에 대한 타이머를 종료합니다.

확인을 위해 메시지 무결성을 계산하기 위해 에이전트는 피어의 SDP에서 배운 원격 사용자 이름 조각과 비밀번호를 사용합니다. 로컬 사용자 이름 조각은 에이전트가 자체 후보에 대해 직접 알 수 있습니다.

---
## **6.  Receipt of the Initial Answer**

이 섹션에서는 에이전트가 피어로부터 응답을 받을 때 따르는 절차를 설명합니다. 피어가 ICE를 지원하는지 확인하고 역할을 결정하며 전체 구현을 위해 체크리스트를 구성하고 일반적인 검사를 수행하기 시작합니다.

ICE를 SIP와 함께 사용하면 분기로 인해 단일 제안이 다양한 답변을 생성할 수 있습니다. 이 경우 ICE는 각 답변에 대해 완전히 병렬적이고 독립적으로 진행하며 제안과 각 답변의 조합을 자체 쌍 세트, 체크리스트, 상태 등을 사용하여 독립적인 제안/답변 교환으로 처리합니다. 한 쌍의 처리가 다른 쌍에 영향을 미치는 유일한 경우는 후보를 해제하는 것입니다. 이에 대해서는 아래 섹션 8.3에서 설명합니다.

---
### **6.1.  Verifying ICE Support**

제안자의 논리는 제안자가 SDP에서 a=ice-mismatch 속성을 생성하지 않는다는 점을 제외하면 섹션 5.1에 설명된 응답자의 논리와 동일합니다.

어떤 경우에는 답변에서 미디어 스트림에 대한 a=candidate 속성을 생략하고 대신 SDP의 하나 이상의 미디어 스트림에 대한 a=ice-mismatch 속성을 포함할 수 있습니다. 이는 응답자가 ICE를 지원하지만 신호 중개자가 해당 후보 속성을 수정하지 않고 미디어 구성 요소의 기본 대상을 수정했기 때문에 ICE 처리가 세션에 사용되지 않았음을 제공자에게 알립니다. 이러한 일이 발생할 수 있는 경우에 대한 논의는 섹션 18을 참조하십시오. 이 사양은 이러한 실패 사례에서 에이전트가 어떻게 진행해야 하는지에 대한 지침을 제공하지 않습니다.

---
### **6.2.  Determining Role**

제안자는 섹션 5.2에서 응답자에 대해 설명된 것과 동일한 절차를 따릅니다.

---
### **6.3.  Forming the Check List**

체크리스트의 구성은 전체 구현에 의해서만 수행됩니다. 제안자는 섹션 5.7에서 응답자에 대해 설명된 것과 동일한 절차를 따릅니다.

---
### **6.4.  Performing Ordinary Checks**

일반적인 검사는 전체 구현에 의해서만 수행됩니다. 제안자는 섹션 5.8에서 응답자에 대해 설명된 것과 동일한 절차를 따릅니다.

---
## **7.  Performing Connectivity Checks**

이 섹션에서는 연결 확인이 수행되는 방법을 설명합니다. 모든 ICE 구현은 이전 \[RFC3489\]와 달리 \[RFC5389\]를 준수해야 합니다. 그러나 전체 구현은 검사를 생성\(STUN 클라이언트 역할\)하고 수신\(STUN 서버 역할\)하는 반면, 라이트 구현은 검사만 수신하므로 STUN 서버 역할만 수행합니다.

---
### **7.1.  STUN Client Procedures**

이러한 절차는 일반 확인인지 트리거된 확인인지에 관계없이 에이전트가 연결 확인을 보내는 방법을 정의합니다. 이러한 절차는 전체 구현에만 적용됩니다.

---
#### **7.1.1.  Creating Permissions for Relayed Candidates**

연결 확인이 중계된 로컬 후보를 사용하여 전송되는 경우 클라이언트는 이전에 권한을 아직 생성하지 않은 경우 먼저 권한을 생성해야 합니다. 원격 후보의 IP 주소를 향해 지정된 중계 후보에 대한 권한을 생성하도록 TURN 서버에 지시했다면 이전에 하나를 생성했을 것입니다. 권한을 생성하기 위해 에이전트는 \[RFC5766\]에 정의된 절차를 따릅니다. 권한은 원격 후보의 IP 주소에 대해 생성되어야 합니다. ICE가 완료될 때까지 에이전트가 TURN 채널 생성을 연기하는 것이 좋습니다. 이 경우 연결 확인을 위한 권한은 일반적으로 CreatePermission 요청을 사용하여 생성됩니다. 일단 설정되면 에이전트는 ICE가 종료될 때까지 권한을 활성 상태로 유지해야 합니다.\(MUST, MUST, SHOULD, MUST\)

---
#### **7.1.2.  Sending the Request**

검사는 로컬 후보에서 원격 후보로 바인딩 요청을 보내 생성됩니다. \[RFC5389\]에서는 바인딩 요청이 구성되고 생성되는 방법을 설명합니다. 연결 확인은 필수입니다.\(MUST\)

STUN 단기 자격 증명 메커니즘을 활용합니다. RFC 3489와의 하위 호환성 지원은 연결 검사와 함께 사용하거나 가정해서는 안 됩니다. 연결 확인에는 FINGERPRINT 메커니즘을 사용해야 합니다.\(MUST NOT, MUST\)

ICE는 PRIORITY, USE-CANDIDATE, ICE-ControlLED 및 ICE-ControlLING을 포함한 몇 가지 새로운 속성을 정의하여 STUN을 확장합니다. 이러한 새로운 속성은 섹션 19.1에 공식적으로 정의되어 있으며 해당 사용법은 아래 하위 섹션에 설명되어 있습니다. 이러한 STUN 확장은 ICE에 사용되는 연결 확인에만 적용됩니다.

---
##### **7.1.2.1.  PRIORITY and USE-CANDIDATE**

에이전트는 바인딩 요청에 PRIORITY 속성을 포함해야 합니다. 속성은 섹션 4.1.2의 알고리즘을 기반으로 동료 성찰 후보에게 할당되는 우선순위와 동일하게 설정되어야 하며, 이 검사의 결과로 학습해야 합니다\(방법은 섹션 7.1.3.2.1 참조\). 동료 반사 후보자가 학습됩니다\). 이 우선순위 값은 유형 선호도가 동료 반사 후보 유형의 값으로 설정된다는 점을 제외하면 쌍의 로컬 후보에 대한 우선순위가 계산된 방법과 동일하게 계산됩니다.\(MUST, MUST\)

제어 에이전트는 바인딩 요청에 USE-CANDIDATE 속성을 포함할 수 있습니다. 제어 에이전트는 이를 바인딩 요청에 포함해서는 안 됩니다. 이 속성은 제어 에이전트가 이 구성 요소에 대한 검사를 중단하고 이 구성 요소에 대한 검사 결과로 얻은 후보 쌍을 사용하기를 원한다는 것을 나타냅니다. 섹션 8.1.1에서는 언제 포함할지 결정하는 지침을 제공합니다.\(MAY, MUST NOT\)

---
##### **7.1.2.2.  ICE-CONTROLLED and ICE-CONTROLLING**

에이전트는 제어 역할에 있는 경우 요청에 ICE-CONTROLLED 속성을 포함해야 하며, 제어 역할에 있는 경우 요청에 ICE-CONTROLLING 속성을 포함해야 합니다. 두 속성 중 하나의 내용은 섹션 5.2에서 결정된 순위 결정 항목이어야 합니다. 이러한 속성은 섹션 19.1에 완전히 정의되어 있습니다.\(MUST, MUST\)

---
##### **7.1.2.3.  Forming Credentials**

연결 확인 역할을 하는 바인딩 요청은 STUN 단기 자격 증명 메커니즘을 활용해야 합니다. 자격 증명의 사용자 이름은 피어가 제공한 사용자 이름 조각과 요청을 보내는 에이전트의 사용자 이름 조각을 콜론\(":"\)으로 구분하여 연결하여 구성됩니다. 비밀번호는 피어가 제공한 비밀번호와 동일합니다. 예를 들어, 에이전트 L이 제안자이고 에이전트 R이 응답자인 경우를 생각해 보십시오. L 요원\(MUST\)

후보자에 대한 LFRAG의 사용자 이름 조각과 LPASS의 비밀번호가 포함되었습니다. 에이전트 R은 RFRAG의 사용자 이름 부분과 RPASS의 비밀번호를 제공했습니다. L에서 R로의 연결 확인은 사용자 이름 RFRAG:LFRAG와 비밀번호 RPASS를 사용합니다. R에서 L로의 연결 확인은 사용자 이름 LFRAG:RFRAG와 비밀번호 LPASS를 사용합니다. 응답은 요청과 동일한 사용자 이름과 비밀번호를 사용합니다\(USERNAME 속성은 응답에 존재하지 않습니다\).

---
##### **7.1.2.4.  DiffServ Treatment**

에이전트가 미디어 패킷에서 Diffserv 코드 포인트 표시 \[RFC2475\]를 사용하는 경우 연결 확인에 동일한 표시를 적용해야 합니다.\(SHOULD\)

---
#### **7.1.3.  Processing the Response**

바인딩 응답이 수신되면 \[RFC5389\]에 정의된 대로 트랜잭션 ID를 사용하여 바인딩 요청과 상관된 다음 이를 바인딩 요청이 전송된 후보 쌍에 연결합니다. 이 섹션에서는 STUN 사용과 관련된 바인딩 응답을 처리하기 위한 추가 절차를 정의합니다.

---
##### **7.1.3.1.  Failure Cases**

STUN 트랜잭션이 487\(역할 충돌\) 오류 응답을 생성하는 경우 에이전트는 바인딩 요청에 ICE-CONTROLLED 또는 ICE-ControlLING 속성이 포함되어 있는지 확인합니다. 요청에 ICE-CONTROLLED 속성이 포함된 경우 에이전트는 아직 제어 역할을 전환하지 않았다면 반드시 제어 역할로 전환해야 합니다. 요청에 ICE-CONTROLLING 속성이 포함된 경우 에이전트는 아직 전환하지 않았다면 제어된 역할로 전환해야 합니다. 일단 전환되면 에이전트는 487을 생성한 검사의 후보 쌍을 트리거된 검사 대기열에 넣어야 합니다. 해당 쌍의 상태는 대기 중으로 설정됩니다. 트리거된 검사가 전송되면 새 역할을 반영하는 ICE- CONTROLLING 또는 ICE-ControlLED 속성이 포함됩니다. 그러나 타이 브레이커 값은 다시 선택되어서는 안 된다는 점에 유의하십시오.\(MUST, MUST, MUST, MUST NOT\)

역할이 변경되면 에이전트는 쌍 우선순위\(섹션 5.7.2\)를 다시 계산해야 합니다. 왜냐하면 이러한 우선순위는 제어 및 제어된 역할의 기능이기 때문입니다. 역할 변경은 대리인이 지정된 쌍을 선택하고 ICE 종료 시 업데이트된 제안을 생성할 책임이 있는지 여부에도 영향을 미칩니다.

에이전트는 연결 확인을 위해 ICMP 오류 수신을 지원할 수 있습니다. STUN 트랜잭션이 ICMP 오류를 생성하는 경우 에이전트는 쌍의 상태를 실패로 설정합니다. STUN 트랜잭션이 생성되는 경우\(MAY\)

복구할 수 없거나\(\[RFC5389\]에 정의된 대로\) 시간 초과된 STUN 오류 응답이 발생하면 에이전트는 쌍의 상태를 실패로 설정합니다.

에이전트는 응답의 소스 IP 주소 및 포트가 바인딩 요청이 전송된 대상 IP 주소 및 포트와 동일한지, 응답의 대상 IP 주소 및 포트가 바인딩 요청의 소스 IP 주소 및 포트와 일치하는지 확인해야 합니다. 바인딩 요청이 전송되었습니다. 즉, 요청과 응답의 소스 및 대상 전송 주소가 대칭입니다. 대칭이 아닌 경우 에이전트는 쌍의 상태를 실패로 설정합니다.\(MUST\)

---
##### **7.1.3.2.  Success Cases**

다음 사항이 모두 충족되면 검사가 성공한 것으로 간주됩니다.

o STUN 트랜잭션이 성공 응답을 생성했습니다.

o 응답의 소스 IP 주소와 포트는

- 바인딩 요청이 전송된 대상 IP 주소 및 포트.

o 응답의 대상 IP 주소 및 포트는 바인딩 요청이 전송된 소스 IP 주소 및 포트와 일치합니다.

---
###### **7.1.3.2.1.  Discovering Peer Reflexive Candidates**

에이전트는 STUN 응답에서 매핑된 주소를 확인합니다. 전송 주소가 에이전트가 알고 있는 로컬 후보와 일치하지 않는 경우 매핑된 주소는 새 후보, 즉 피어 반사 후보를 나타냅니다. 다른 후보자들과 마찬가지로 유형, 기반, 우선순위, 기반이 있습니다. 이는 다음과 같이 계산됩니다.

o 그 유형은 동료 반사와 동일합니다.

o 그 베이스는 STUN 검사가 전송된 후보 쌍의 로컬 후보와 동일하게 설정됩니다.

o 우선순위는 바인딩 요청의 PRIORITY 속성 값과 동일하게 설정됩니다.

o 그 기초는 섹션 4.1.1.3에 설명된 대로 선택됩니다.

그러면 이 동료 반사 후보가 미디어 스트림의 로컬 후보 목록에 추가됩니다. 사용자 이름 조각과 비밀번호는 해당 미디어 스트림의 다른 모든 로컬 후보와 동일합니다.

그러나 동료 반사 후보자는 다른 원격 후보자와 짝을 이루지 않습니다. 이것은 필요하지 않습니다. 섹션 7.1.3.2.2의 절차에 따라 유효한 쌍이 일시적으로 생성됩니다. 에이전트가 피어 반사 후보를 생성될 유효한 쌍의 후보 외에 다른 원격 후보와 페어링하려는 경우 에이전트는 피어 반사 후보를 포함하는 업데이트된 제안을 생성할 수 있습니다. 이렇게 하면 다른 모든 원격 후보와 쌍을 이루게 됩니다.\(MAY\)

---
###### **7.1.3.2.2.  Constructing a Valid Pair**

에이전트는 로컬 후보가 응답의 매핑된 주소와 같고 원격 후보가 요청이 전송된 대상 주소와 동일한 후보 쌍을 구성합니다. 이는 STUN 연결 확인을 통해 검증되었으므로 유효한 쌍이라고 합니다. 유효한 쌍은 검사를 생성한 쌍과 같을 수도 있고, 검사 목록에 있는 다른 쌍과 같을 수도 있고, 현재 어떤 검사 목록에도 없는 쌍일 수도 있습니다. 쌍이 검사를 생성한 쌍과 같거나 현재 검사 목록에 있는 경우 각 미디어 스트림에 대해 에이전트가 유지 관리하는 VALID LIST에도 추가됩니다. 이 목록은 ICE 처리 시작 시 비어 있으며 검사가 수행되면서 채워져 유효한 후보 쌍이 생성됩니다.

해당 쌍이 어떤 체크리스트에도 포함되지 않는 것이 매우 일반적입니다. 체크리스트에는 로컬 후보가 결코 서버 반사적이지 않은 쌍이 있다는 점을 기억하십시오. 해당 쌍은 로컬 후보를 서버 반사 후보의 기본으로 변환한 다음 중복되는 경우 제거했습니다. STUN 검사에 대한 응답이 도착하면 둘 사이에 NAT가 있는 경우 매핑된 주소가 반사됩니다. 이 경우 유효한 쌍에는 체크리스트의 어떤 쌍과도 일치하지 않는 로컬 후보가 있습니다.

쌍이 체크리스트에 없는 경우 에이전트는 섹션 5.7의 알고리즘을 사용하여 각 후보의 우선순위를 기반으로 쌍의 우선순위를 계산합니다. 지역 후보의 우선순위는 유형에 따라 다릅니다. 동료 반사적이지 않은 경우 SDP에서 해당 후보자에 대해 신호된 우선순위와 동일합니다. 피어 반사적이라면 에이전트가 방금 완료된 바인딩 요청에 배치한 PRIORITY 속성과 동일합니다. 원격 후보의 우선순위는 피어의 SDP에서 가져옵니다. 후보자가 거기에 나타나지 않는다면, 그 점검은 새로운 원격 후보자에 대한 트리거된 점검이었을 것입니다. 이 경우 방금 완료된 확인을 트리거한 바인딩 요청의 PRIORITY 속성 값으로 우선순위가 적용됩니다. 그런 다음 해당 쌍이 VALID LIST에 추가됩니다.

---
###### **7.1.3.2.3.  Updating Pair States**

에이전트는 검사를 \*생성\*한 쌍의 상태를 성공으로 설정합니다. 검사를 \*생성\*한 쌍은 응답의 결과로 섹션 7.1.3.2.2에서 구성된 유효한 쌍과 다를 수 있습니다. 이 검사가 성공하면 다른 검사의 상태도 변경될 수 있습니다. 에이전트는 다음 두 단계를 수행해야 합니다.\(MUST\)

1. 에이전트는 동일한 미디어 스트림 및 동일한 기반에 대한 다른 모든 Frozen 쌍의 상태를 대기 중으로 변경합니다. 항상 그런 것은 아니지만 일반적으로 이러한 다른 쌍은 서로 다른 구성 요소 ID를 갖습니다.

2. 이 미디어 스트림의 모든 구성 요소에 대해 유효한 목록에 쌍이 있는 경우\(SDP에서 신호를 받은 구성 요소 수가 제공자마다 다른 경우 사용되는 실제 구성 요소 수\) 성공 이 검사로 인해 다른 미디어 스트림에 대한 검사가 동결 해제될 수 있습니다. 이 단계는 고려 중인 유효한 목록에 모든 구성 요소에 대한 쌍이 처음으로 있을 때뿐만 아니라 이후 검사가 성공하고 해당 유효한 목록에 또 다른 쌍이 추가될 때마다 수행됩니다. 에이전트는 차례로 각 미디어 스트림에 대한 체크리스트를 검사합니다.

- \* 체크리스트가 활성화된 경우 에이전트는 고려 중인 유효한 목록의 쌍과 기초가 일치하는 해당 체크리스트의 모든 Frozen 쌍의 상태를 대기 중으로 변경합니다.

- \* 체크리스트가 고정되어 있고 그 기초가 고려 중인 유효한 목록의 쌍과 일치하는 체크리스트에 최소한 하나의 쌍이 있는 경우, 기초가 유효한 목록의 쌍과 일치하는 체크리스트의 모든 쌍의 상태 고려 중은 대기로 설정됩니다. 이렇게 하면 체크리스트가 활성화되고 섹션 5.8에 설명된 대로 일반 체크가 시작됩니다.

- \* 체크리스트가 고정되어 있고 고려 중인 유효한 목록의 쌍과 기초가 일치하는 체크리스트의 쌍이 없는 경우 에이전트는

- + 동일한 기초를 가진 모든 쌍을 함께 그룹화하고

- + 각 그룹에 대해 구성 요소 ID가 가장 낮은 쌍의 상태를 대기 중으로 설정합니다. 그러한 쌍이 두 개 이상 있는 경우 우선 순위가 가장 높은 쌍이 사용됩니다.

---
###### **7.1.3.2.4.  Updating the Nominated Flag**

에이전트가 제어 에이전트이고 바인딩 요청에 USE-CANDIDATE 속성이 포함된 경우 해당 검사에서 생성된 유효한 쌍에는 지정된 플래그가 true로 설정됩니다. 이 플래그는 지정된 플래그가 설정된 것 중에서 우선순위가 가장 높은 경우 이 유효한 쌍이 미디어에 사용되어야 함을 나타냅니다. 이로써 이 미디어 스트림 또는 모든 미디어 스트림에 대한 ICE 처리가 종료될 수 있습니다. 섹션 8을 참조하세요.

에이전트가 제어 에이전트인 경우 응답은 자체적으로 USE-CANDIDATE 속성이 있는 요청에 대한 응답으로 전송된 트리거된 확인의 결과일 수 있습니다. 이 경우는 섹션 7.2.1.5에 설명되어 있으며 이제 원래 요청에서 학습된 쌍에 대해 지정된 플래그를 설정하게 될 수 있습니다.

---
##### **7.1.3.3.  Check List and Timer State Updates**

확인의 성공 여부에 관계없이 트랜잭션을 완료하려면 체크 목록과 타이머 상태를 업데이트해야 할 수 있습니다.

체크리스트의 모든 쌍이 현재 Failed 또는 Succeeded 상태인 경우:

o 미디어 스트림의 각 구성 요소에 대한 유효한 목록에 쌍이 없는 경우 확인 목록의 상태는 실패로 설정됩니다.

o 고정된 체크리스트 각각에 대해 상담원은

- \* 동일한 기초를 가진 모든 쌍을 함께 그룹화하고

- \* 각 그룹에 대해 구성 요소 ID가 가장 낮은 쌍의 상태를 대기 중으로 설정합니다. 그러한 쌍이 두 개 이상 있는 경우 우선 순위가 가장 높은 쌍이 사용됩니다.

체크리스트의 쌍 중 대기 또는 동결 상태에 있는 쌍이 없으면 체크리스트는 더 이상 활성 상태로 간주되지 않으며 섹션 5.8에 설명된 대로 일반 점검에 대한 타이머 계산에서 N 값에 포함되지 않습니다.

---
### **7.2.  STUN Server Procedures**

에이전트는 가장 최근 제안이나 답변에 포함된 각 후보를 기반으로 바인딩 요청을 수신할 준비를 해야 합니다. 이 요구 사항은 피어가 간단한 구현인 경우에도 적용됩니다.\(MUST\)

에이전트는 요청을 인증하고 메시지 무결성 검사를 수행하기 위해 단기 자격 증명을 사용해야 합니다. 에이전트는 사용자 이름이 콜론으로 구분된 두 개의 값으로 구성된 경우 유효한 것으로 간주해야 합니다. 여기서 첫 번째 값은 진행 중인 세션에 대한 제안 또는 응답에서 에이전트가 생성한 사용자 이름 조각과 동일합니다. 제안자가 피어로부터 응답을 받기 전에 바인딩 요청을 받는 것이 가능합니다\(실제로 매우 가능성이 높습니다\). 이런 일이 발생하면 에이전트는 즉시 응답을 생성해야 합니다\(섹션 7.2.1.2에 설명된 대로 매핑된 주소 계산 포함\). 에이전트는 이 시점에서 응답을 생성하기에 충분한 정보를 가지고 있습니다. 피어의 비밀번호는 필요하지 않습니다. 답변을 받으면 전체 구현을 위해 필요한 나머지 단계, 즉 7.2.1.3, 7.2.1.4 및 7.2.1.5를 진행해야 합니다. 응답 전에 여러 STUN 요청이 수신되는 경우 이로 인해 트리거된 확인 대기열에 여러 쌍이 대기할 수 있습니다.\(MUST, MUST, MUST, MUST\)

에이전트는 ALTERNATE-SERVER 메커니즘을 활용해서는 안 되며, RFC 3489에 대한 이전 버전과의 호환성 메커니즘을 지원해서는 안 됩니다. FINGERPRINT 메커니즘을 활용해야 합니다.\(MUST NOT, MUST\)

에이전트가 미디어 패킷에서 Diffserv 코드 포인트 표시 \[RFC2475\]를 사용하는 경우 바인딩 요청에 대한 응답에 동일한 표시를 적용해야 합니다. 엔드포인트가 미디어 패킷에 적용할 수 있는 모든 레이어 2 표시에도 동일하게 적용됩니다.\(SHOULD\)

---
#### **7.2.1.  Additional Procedures for Full Implementations**

이 하위 섹션에서는 전체 구현에 적용할 수 있는 추가 서버 절차를 정의합니다.

---
##### **7.2.1.1.  Detecting and Repairing Role Conflicts**

일반적으로 섹션 5.2의 역할 선택 규칙에 따라 각 에이전트는 서로 다른 역할\(하나는 제어 및 제어\)을 선택하게 됩니다. 그러나 일반적으로 제3자 통화 제어를 활용하는 비정상적인 통화 흐름에서는 두 상담원이 동일한 역할을 선택할 수 있습니다. 이 섹션에서는 이 사례를 확인하고 복구하는 절차를 설명합니다.

에이전트는 ICE-ControlLING 또는 ICE-ControlLED 속성에 대한 바인딩 요청을 검사해야 합니다. 반드시 다음 절차를 따라야 합니다.\(MUST, MUST\)

o 요청에 ICE-ControlLING이나 ICE-ControlLED가 모두 없으면 피어 에이전트가 이 사양의 이전 버전을 구현했을 수 있습니다. 충돌이 있을 수 있지만 감지할 수는 없습니다.

o 에이전트가 제어 역할에 있고 ICE-CONTROLLING 속성이 요청에 있는 경우:

- \* 에이전트의 타이 브레이커가 ICE-ControlLING 속성의 내용보다 크거나 같은 경우 에이전트는 바인딩 오류 응답을 생성하고 값이 487\(역할 충돌\)인 ERROR-CODE 속성을 포함하지만 역할은 유지합니다. .

- \* 에이전트의 순위결정이 ICE-ControlLING 속성의 내용보다 작으면 에이전트는 제어된 역할로 전환됩니다.

o 상담원이 제어된 역할에 있고 요청에 ICE-CONTROLLED 속성이 있는 경우:

- \* 에이전트의 순위결정값이 ICE-CONTROLLED 속성의 내용보다 크거나 같을 경우 에이전트는 제어 역할로 전환됩니다.

- \* 에이전트의 타이 브레이커가 ICE-ControlLED 속성의 내용보다 작은 경우 에이전트는 바인딩 오류 응답을 생성하고 값이 487\(역할 충돌\)인 ERROR-CODE 속성을 포함하지만 해당 역할은 유지합니다.

o 에이전트가 제어 역할에 있고 ICE-ControlLING 속성이 요청에 있거나, 에이전트가 제어 역할에 있고 ICE-CONTROLLED 속성이 요청에 있는 경우 충돌이 없습니다.

역할이 변경되면 에이전트는 쌍 우선순위\(섹션 5.7.2\)를 다시 계산해야 합니다. 왜냐하면 이러한 우선순위는 제어 및 제어된 역할의 기능이기 때문입니다. 역할 변경은 대리인이 지명된 쌍을 선택하고 ICE 종료 시 업데이트된 제안을 생성할 책임이 있는지 여부에도 영향을 미칩니다.

에이전트가 역할을 변경한 경우에도 서버가 바인딩 요청에 대한 성공적인 응답을 생성한 경우 섹션 7.2.1의 나머지 섹션을 따릅니다.

---
##### **7.2.1.2.  Computing Mapped Address**

중계된 후보에서 수신되는 요청의 경우 STUN 처리\(즉, XOR-MAPPED-ADDRESS 속성 생성\)에 사용되는 소스 전송 주소는 TURN 서버에서 확인되는 전송 주소입니다. 바인딩 요청이 데이터 표시를 통해 전달된 경우 해당 소스 전송 주소는 데이터 표시 메시지의 XOR-PEER-ADDRESS 속성에 표시됩니다. 만약

바인딩 요청은 ChannelData 메시지를 통해 전달되었으며 소스 전송 주소는 채널에 바인딩된 주소입니다.

---
##### **7.2.1.3.  Learning Peer Reflexive Candidates**

요청의 소스 전송 주소가 기존 원격 후보와 일치하지 않는 경우 새 피어 재귀 원격 후보를 나타냅니다. 이 후보는 다음과 같이 구성됩니다.

o 후보자의 우선순위는 요청의 PRIORITY 속성으로 설정됩니다.

o 후보자 유형은 동료 반사로 설정됩니다.

o 후보자의 기초는 다른 모든 원격 후보자의 기초와 다른 임의의 값으로 설정됩니다. 후속 제안/답변 교환에 SDP에 이 동료 성찰 후보자가 포함되어 있으면 후보자의 실제 기반을 알립니다.

o 이 후보의 구성 요소 ID는 요청이 전송된 로컬 후보의 구성 요소 ID로 설정됩니다.

이 후보자는 원격 후보자 목록에 추가됩니다. 그러나 에이전트는 이 후보자를 로컬 후보자와 페어링하지 않습니다.

---
##### **7.2.1.4.  Triggered Checks**

다음으로 에이전트는 STUN 요청이 수신된 전송 주소와 동일한 로컬 후보와 요청이 발생한 소스 전송 주소와 동일한 원격 후보\(이는 STUN 요청이 수신된 피어 반사 원격 후보일 수 있음\)로 구성된 쌍을 구성합니다. 방금 배웠습니다\). 로컬 후보는 호스트 후보\(요청이 릴레이를 통해 수신되지 않은 경우\) 또는 릴레이된 후보\(릴레이를 통해 요청이 수신된 경우\)가 됩니다. 로컬 후보는 서버 반사 후보가 될 수 없습니다. 두 후보 모두 에이전트에 알려져 있으므로 우선 순위를 얻고 후보 쌍 우선 순위를 계산할 수 있습니다. 그러면 이 쌍이 체크리스트에서 조회됩니다. 다음과 같은 여러 결과 중 하나가 있을 수 있습니다.

o 해당 쌍이 이미 체크리스트에 있는 경우:

- \* 해당 쌍의 상태가 대기 중 또는 동결인 경우 해당 쌍에 대한 검사가 아직 없으면 트리거된 검사 대기열에 포함됩니다.

- \* 해당 쌍의 상태가 In-Progress인 경우 에이전트는 진행 중인 트랜잭션을 취소합니다. 취소는 에이전트가 요청을 재전송하지 않고 응답 부족을 실패로 처리하지 않고 응답을 위해 트랜잭션 시간 초과 기간 동안 기다리는 것을 의미합니다. 또한 에이전트는 트리거된 확인 대기열에 쌍을 추가하여 해당 쌍\(새로운 STUN 바인딩 요청 트랜잭션을 나타냄\)에 대한 새로운 연결 확인을 생성해야 합니다. 그러면 쌍의 상태가 대기 중으로 변경됩니다.\(MUST\)

- \* 쌍의 상태가 실패인 경우 대기로 변경되고 에이전트는 트리거된 확인 대기열에 해당 쌍을 대기열에 추가하여 해당 쌍에 대한 새로운 연결 확인\(새로운 STUN 바인딩 요청 트랜잭션을 나타냄\)을 생성해야 합니다.\(MUST\)

- \* 해당 쌍의 상태가 성공이면 더 이상 수행되지 않습니다.

- 이러한 단계는 두 에이전트가 모두 NAT 뒤에 있을 때 ICE의 신속한 완료를 촉진하기 위해 수행됩니다.

o 해당 쌍이 아직 확인 목록에 없는 경우:

- \* 쌍은 우선순위에 따라 체크리스트에 삽입됩니다.

- \* 상태가 대기로 설정되어 있습니다.

- \* 쌍이 트리거된 검사 대기열에 포함됩니다.

트리거된 검사가 전송될 때 섹션 7.1.2에 설명된 대로 구성되고 처리됩니다. 이러한 절차에서는 에이전트가 피어의 전송 주소, 사용자 이름 조각 및 비밀번호를 알아야 합니다. 원격 후보의 사용자 이름 조각은 방금 수신된 바인딩 요청에서 USERNAME 콜론 뒤의 부분과 동일합니다. 해당 사용자 이름 조각을 사용하여 에이전트는 피어로부터 수신된 SDP 메시지\(포크의 경우 둘 이상이 있을 수 있음\)를 확인하고 이 사용자 이름 조각을 찾을 수 있습니다. 그러면 해당 비밀번호가 선택됩니다.

---
##### **7.2.1.5.  Updating the Nominated Flag**

에이전트가 수신한 바인딩 요청에 USE-CANDIDATE 속성이 설정되어 있고 에이전트가 제어된 역할에 있는 경우 에이전트는 섹션 7.2.1.4에서 계산된 쌍의 상태를 확인합니다.

o 이 쌍의 상태가 성공인 경우 이는 이 쌍에 의해 생성된 검사가 성공적인 응답을 생성했음을 의미합니다. 이로 인해 에이전트가 성공할 때 유효한 쌍을 구성하게 되었을 것입니다.

- 응답이 수신되었습니다\(섹션 7.1.3.2.2 참조\). 이제 에이전트는 유효한 쌍의 지정된 플래그를 true로 설정합니다. 이로 인해 이 미디어 스트림에 대한 ICE 처리가 종료될 수 있습니다. 섹션 8을 참조하세요.

o 이 쌍의 상태가 진행 중\(In-Progress\)인 경우 검사 결과가 성공적이면 응답이 도착할 때 결과로 나온 유효한 쌍에는 지정된 플래그가 설정됩니다. 이 미디어 스트림이 도착하면 이에 대한 ICE 처리가 종료될 수 있습니다. 섹션 8을 참조하세요.

---
#### **7.2.2.  Additional Procedures for Lite Implementations**

방금 수신한 검사에 USE-CANDIDATE 속성이 포함된 경우 에이전트는 로컬 후보가 요청이 수신된 전송 주소와 동일하고 원격 후보가 요청의 소스 전송 주소와 동일한 후보 쌍을 구성합니다. 받은 것입니다. 이 후보 쌍에는 임의의 우선 순위가 할당되고 유효한 목록이라는 유효한 후보 목록에 배치됩니다. 에이전트는 해당 쌍에 대해 지정된 플래그를 true로 설정합니다. 유효한 목록에 각 구성 요소에 대한 후보 쌍이 포함되어 있으면 미디어 스트림에 대한 ICE 처리가 완료된 것으로 간주됩니다.

---
## **8.  Concluding ICE Processing**

이 섹션에서는 에이전트가 ICE를 완료하는 방법을 설명합니다.

---
### **8.1.  Procedures for Full Implementations**

ICE를 종료하려면 제어 에이전트가 쌍을 지명하고 상태 시스템을 업데이트해야 합니다.

---
#### **8.1.1.  Nominating Pairs**

통제 에이전트는 정규 지명 또는 공격적 지명이라는 두 가지 기술 중 하나를 사용하여 ICE가 선택할 쌍을 지명합니다. 피어가 라이트 구현을 갖고 있는 경우 에이전트는 일반 지명 알고리즘을 사용해야 합니다. 피어가 에이전트가 이해하지 못하는 ICE 옵션\(피어의 ice-options 속성에 있음\)을 사용하는 경우 에이전트는 정규 지명 알고리즘을 사용해야 합니다. 피어가 전체 구현이고 ICE 옵션을 사용하지 않거나 에이전트가 이해하는 ICE 옵션을 사용하는 경우 에이전트는 공격적 또는 일반 지명 알고리즘을 사용할 수 있습니다. 그러나 일반 알고리즘은 더 높은 안정성을 제공하므로 권장됩니다.\(MUST, MUST, MAY, SHOULD\)

---
##### **8.1.1.1.  Regular Nomination**

정기적인 지정을 통해 에이전트는 몇 가지 검사를 완료할 수 있으며 각 검사에서는 USE-CANDIDATE 속성이 생략됩니다. 미디어 스트림의 구성 요소에 대해 하나 이상의 검사가 성공적으로 완료되면 유효한 쌍이 생성되어 유효한 목록에 추가됩니다. 에이전트는 일부 중지 기준이 충족될 때까지 검사를 계속한 다음 평가 기준에 따라 유효한 쌍 중에서 선택합니다. 검사를 중지하고 유효한 쌍을 평가하는 기준은 전적으로 로컬 최적화의 문제입니다.

제어 에이전트가 유효한 쌍을 선택하면 이 유효한 쌍을 생성한 검사를 반복합니다\(검사를 생성한 쌍을 트리거된 검사 대기열에 추가하여\). 이번에는 USE-CANDIDATE 속성을 사용합니다. 이 검사는 성공해야 하며\(이전 검사 이후\) 해당 플래그와 해당 쌍만 설정되도록 지정해야 합니다. 결과적으로 각 구성 요소에 대한 유효한 목록에는 지정된 쌍이 하나만 있으며, 검사 목록 상태가 완료됨으로 이동하면 해당 구성 요소에 대한 미디어를 보내고 받기 위해 ICE가 정확한 쌍을 선택합니다.

정기 지정은 상담원이 점검 중지 및 선택 기준을 제어할 수 있으므로 유연성이 가장 높습니다. 유일한 요구 사항은 에이전트가 결국 단 하나의 후보 쌍을 선택하고 USE-CANDIDATE 속성이 있는 해당 쌍에 대한 검사를 생성해야 한다는 것입니다. 정기적인 지명은 또한 구현의 변화에 ​​대한 ICE의 탄력성을 향상시킵니다\(섹션 14 참조\). 또한 일반 지정은 보다 안정적이므로 공격적인 알고리즘에서 발생할 수 있는 일시적인 선택 없이 두 에이전트가 미디어에 대한 단일 쌍으로 수렴할 수 있습니다. 정기 지명의 단점은 추가 확인이 필요하기 때문에 지연 시간이 증가한다는 점입니다.\(MUST\)

---
##### **8.1.1.2.  Aggressive Nomination**

공격적인 지명을 통해 제어 에이전트는 보내는 모든 검사에 USE-CANDIDATE 속성을 포함합니다. 구성 요소에 대한 첫 번째 확인이 성공하면 유효한 목록에 추가되고 지정된 플래그가 설정됩니다. 모든 구성 요소에 유효한 목록에 지정된 쌍이 있으면 미디어는 우선 순위가 가장 높은 지정된 쌍을 사용하여 흐름을 시작할 수 있습니다. 그러나 에이전트가 모든 검사에 USE-CANDIDATE 속성을 포함했기 때문에 또 다른 검사가 완료되어 다른 유효한 쌍에 지정된 플래그가 설정될 수 있습니다. ICE는 항상 유효한 목록에서 가장 우선순위가 높은 후보 쌍을 미디어에 사용되는 후보 쌍으로 선택합니다. 결과적으로 선택된 쌍은 ICE 검사가 완료됨에 따라 실제로 잠시 변경될 수 있으며, 그 결과 안정화될 때까지 일련의 일시적인 선택이 발생합니다.

---
#### **8.1.2.  Updating States**

제어 에이전트와 제어 에이전트 모두에 대해 ICE 처리 상태는 유효한 목록에 지명된 후보 쌍이 있는지와 체크리스트 상태에 따라 달라집니다. 언제든지 다음 사례 중 하나 이상이 적용될 수 있습니다.

o 미디어 스트림에 대한 유효한 목록에 지정된 쌍이 없고 체크 목록의 상태가 실행 중이면 ICE 처리가 계속됩니다.

o 미디어 스트림에 대한 유효한 목록에 지정된 쌍이 하나 이상 있고 체크 목록 상태가 실행 중인 경우:

- \* 에이전트는 해당 미디어 스트림에 대해 지정된 쌍과 동일한 구성 요소에 대해 체크 목록 및 트리거된 체크 큐에서 모든 대기 및 고정 쌍을 제거해야 합니다.\(MUST\)

- \* 체크리스트의 진행 중인 쌍이 지정된 쌍과 동일한 구성 요소에 대한 경우 에이전트는 해당 쌍 우선 순위가 해당 구성 요소에 대해 가장 낮은 우선 순위로 지정된 쌍보다 낮은 경우 확인을 위한 재전송을 중단해야 합니다.\(SHOULD\)

o 적어도 하나의 미디어 스트림의 모든 구성 요소에 대한 유효한 목록에 적어도 하나의 지정된 쌍이 있고 체크 목록의 상태가 실행 중이면:

- \* 에이전트는 해당 미디어 스트림에 대한 체크리스트 처리 상태를 완료로 변경해야 합니다.\(MUST\)

- \* 에이전트는 해당 미디어 스트림에 대해 수신할 수 있는 모든 검사에 계속 응답해야 하며 섹션 7.2의 처리에 필요한 경우 트리거된 검사를 수행해야 합니다.\(MUST\)

- \* 에이전트는 해당 체크리스트에 대해 진행 중인 체크를 계속해서 재전송해야 합니다.\(MUST\)

- \* 에이전트는 섹션 11.1에 설명된 대로 이 미디어 스트림에 대한 미디어 전송을 시작할 수 있습니다.\(MAY\)

o 각 체크리스트의 상태가 완료되면:

\* 에이전트는 전반적인 ICE 처리 상태를 다음과 같이 설정합니다.

-     완전한.

- \* 에이전트가 제어하는 ​​경우 각 미디어 스트림의 각 구성 요소에 대해 가장 높은 우선순위로 지정된 후보 쌍을 검사합니다. 해당 후보 쌍 중 하나라도 다른 경우

- 가장 최근 제안/답변 교환의 기본 후보 쌍, 제어 에이전트는 섹션 9에 설명된 대로 업데이트된 제안을 생성해야 합니다. 제어 에이전트가 공격적인 지명 알고리즘을 사용하는 경우 선택한 쌍으로 여러 업데이트된 제안이 발생할 수 있습니다. 미디어 변화. 에이전트는 선택한 쌍이 안정화될 수 있도록 짧은 간격\(1초 권장\) 동안 제안 전송을 지연할 수 있습니다.\(MUST, SHOULD\)

o 체크리스트 상태가 실패인 경우 ICE가 이 미디어 스트림을 완료할 수 없습니다. 올바른 동작은 다른 미디어 스트림의 확인 목록 상태에 따라 달라집니다.

- \* 모든 체크리스트가 Failed인 경우 ICE 처리 전체가 Failed 상태인 것으로 간주되며 에이전트는 세션을 실패로 간주해야 하며 ICE를 다시 시작해서는 안 되며 제어 에이전트는 전체 세션을 종료해야 합니다.\(SHOULD NOT\)

- \* 다른 미디어 스트림에 대한 체크리스트 중 하나 이상이 완료되면 제어 에이전트는 업데이트된 제안의 세션에서 실패한 미디어 스트림을 제거해야 합니다.\(SHOULD\)

\* 다른 미디어 스트림에 대한 체크리스트가 하나도 없는 경우

- 완료되었지만 적어도 하나가 실행 중이면 에이전트는 ICE가 계속되도록 해야 합니다.\(SHOULD\)

---
### **8.2.  Procedures for Lite Implementations**

라이트 구현을 위한 ICE 결론은 비교적 간단합니다. 고려해야 할 두 가지 경우가 있습니다.

- 구현은 간단하고 피어는 가득 찼습니다.

-구현은 라이트이고 피어는 라이트입니다.

ICE 결론의 효과는 섹션 8.3에 설명된 대로 에이전트가 ICE에 의해 활용되지 않은 할당된 호스트 후보를 해제할 수 있다는 것입니다.

---
#### **8.2.1.  Peer Is Full**

이 경우 에이전트는 피어로부터 연결 확인을 받습니다. 에이전트가 미디어 스트림의 각 구성 요소에 대한 USE-CANDIDATE 특성이 포함된 연결 확인을 받으면 해당 미디어 스트림에 대한 ICE 처리 상태가 실행 중에서 완료로 전환됩니다. 모든 미디어 스트림에 대한 ICE 처리 상태가 완료되면 전체 ICE 처리 상태는 완료됩니다.

라이트 구현은 미디어 스트림에 대한 ICE 처리가 실패했는지 자체적으로 판단하지 않습니다. 오히려 전체 피어가 결정을 내린 다음 후속 제안에서 실패한 미디어 스트림을 제거하거나 다시 시작합니다.

---
#### **8.2.2.  Peer Is Lite**

제안/답변 교환이 완료되면 두 에이전트는 자신의 후보와 동료의 후보를 검사합니다. 각 미디어 스트림에 대해 각 에이전트는 자체 후보와 해당 미디어 스트림에 대한 피어 후보를 쌍으로 만듭니다. 두 후보는 동일한 구성 요소에 대해, 동일한 전송 프로토콜\(이 사양에서는 UDP\)을 사용하고, 동일한 IP 주소 제품군\(IPv4 또는 IPv6\)에 속할 때 쌍을 이룹니다.

o 구성 요소당 단일 쌍이 있는 경우 해당 쌍이 유효 목록에 추가됩니다. 미디어 스트림의 모든 구성 요소에 한 쌍이 있는 경우 해당 미디어 스트림의 ICE 처리 상태는 완료됨으로 설정됩니다. 모든 미디어 스트림이 완료되면 ICE 처리 상태가 전체적으로 완료됨으로 설정됩니다. 이는 IPv4 전용 구현의 경우 항상 해당됩니다.

o 구성 요소당 쌍이 두 개 이상인 경우:

- \* 에이전트는 로컬 정책에 따라 쌍을 선택해야 합니다. 이 경우는 IPv6에서만 발생하므로 에이전트는 RFC 3484 \[RFC3484\]의 절차에 따라 단일 쌍을 선택하는 것이 좋습니다.\(MUST, SHOULD\)

- \* 에이전트는 각 구성 요소에 대해 선택한 쌍을 유효한 목록에 추가합니다. 섹션 11.1에 설명된 대로 이렇게 하면 매체가 흐르기 시작합니다. 그러나 두 에이전트가 서로 다른 쌍을 선택했을 가능성이 있습니다.

- \* 이를 조정하려면 제어 에이전트는 원격 후보 속성을 포함하는 섹션 9.1.3에 설명된 대로 업데이트된 제안을 보내야 합니다.\(MUST\)

- \* 에이전트는 제안이 전송될 때 ICE 처리 상태를 업데이트해서는 안 됩니다. 이 후속 제안이 완료되면 제어 에이전트는 모든 미디어 스트림에 대해 ICE 처리 상태를 완료로 변경하고 전체 ICE 처리 상태를 완료로 변경해야 합니다. 제어 에이전트의 상태는 섹션 9.2.3의 논리를 기반으로 설정됩니다.\(MUST NOT, MUST\)

---
### **8.3.  Freeing Candidates**
---
#### **8.3.1.  Full Implementation Procedures**

섹션 8의 절차에서는 에이전트가 계속해서 STUN 요청을 수신하고 해당 스트림에 대한 처리가 완료된 후에도 미디어 스트림에 대해 트리거된 검사를 계속 생성해야 합니다. 이 섹션의 규칙은 대리인이 ICE가 선택하지 않은 후보자에 대한 수표 보내기 또는 받기를 중단하고 후보자를 해제하는 것이 안전한 경우를 설명합니다.

ICE가 SIP와 함께 사용되고 제안이 여러 수신자에게 분기되는 경우 ICE는 동일한 로컬 후보를 사용하여 각 응답자와 병렬 및 독립적으로 진행됩니다. ICE 처리가 해당 후보를 사용하는 미디어 스트림의 모든 피어에 대해 완료 상태에 도달하면 에이전트는 추가로 3초를 기다려야 하며 그런 다음 해당 후보에 대한 검사에 대한 응답 또는 트리거된 검사 생성을 중단할 수 있습니다. 그 당시 후보자를 석방할 수도 있습니다. 서버 반사 후보를 해제하는 것은 결코 명시적이지 않습니다. 이는 keepalive가 부족하여 발생합니다. 3초 지연은 공격적인 지명이 사용되는 경우를 처리하며 ICE가 완료된 후 선택한 쌍이 빠르게 변경될 수 있습니다.\(SHOULD, MAY\)

---
#### **8.3.2.  Lite Implementation Procedures**

라이트 구현에서는 ICE 처리가 해당 후보를 사용하는 모든 미디어 스트림의 모든 피어에 대해 완료 상태에 도달하자마자 ICE에서 선택하지 않은 후보를 해제할 수 있습니다.\(MAY\)

---
## **9.  Subsequent Offer/Answer Exchanges**

어느 에이전트든 RFC 3264 \[RFC3264\]에서 허용하는 언제든지 후속 제안을 생성할 수 있습니다. 섹션 8의 규칙은 ICE가 기본 쌍과 다른 후보 쌍을 선택한 경우 ICE 처리가 끝나면 제어 에이전트가 업데이트된 제안을 보내도록 합니다. 이 섹션에서는 후속 제안 및 답변 구성에 대한 규칙을 정의합니다.\(MAY\)

후속 제안이 거부되면 후속 제안이 전혀 이루어지지 않은 것처럼 ICE 처리가 계속됩니다.

---
### **9.1.  Generating the Offer**
---
#### **9.1.1.  Procedures for All Implementations**
---
##### **9.1.1.1.  ICE Restarts**

에이전트는 기존 미디어 스트림에 대한 ICE 처리를 다시 시작할 수 있습니다. ICE를 다시 시작하면 이름에서 알 수 있듯이 ICE 처리의 모든 이전 상태가 플러시되고 검사가 새로 시작됩니다. ICE 다시 시작과 새로운 미디어 세션 간의 유일한 차이점은 다시 시작하는 동안 미디어가 이전에 검증된 쌍으로 계속 전송될 수 있다는 것입니다.\(MAY\)

다음과 같은 경우 에이전트는 미디어 스트림에 대해 ICE를 다시 시작해야 합니다.\(MUST\)

o 미디어 스트림의 대상을 변경하기 위한 목적으로 제안이 생성되고 있습니다. 즉, 에이전트가 ICE를 사용하지 않은 경우 미디어 구성 요소의 대상에 대한 새로운 값을 생성하는 업데이트된 제안을 생성하려는 경우입니다.

o 에이전트가 구현 수준을 변경하고 있습니다. 이는 일반적으로 신호를 수행하는 엔터티가 미디어를 수신하는 엔터티가 아니고 세션 중간에 미디어 대상을 다른 ICE 구현이 있는 다른 엔터티로 변경한 제3자 통화 제어 사용 사례에서만 발생합니다.

이러한 규칙은 c 줄의 IP 주소를 0.0.0.0으로 설정하면 ICE가 다시 시작된다는 것을 의미합니다. 결과적으로 ICE 구현은 통화 보류를 위해 이 메커니즘을 활용해서는 안 되며, 대신 \[RFC3264\]에 설명된 대로 a=inactive 및 a=sendonly를 사용해야 합니다.\(MUST NOT\)

ICE를 다시 시작하려면 에이전트는 제안에서 미디어 스트림에 대한 ice-pwd와 ice-ufrag를 모두 변경해야 합니다. 한 제안에서는 세션 수준 속성을 사용하는 것이 허용되지만 후속 제안에서는 미디어 수준 속성으로 동일한 ice-pwd 또는 ice-ufrag를 제공하는 것이 허용됩니다. 이는 비밀번호 변경이 아니라 단지 표현의 변경일 뿐이며 ICE가 다시 시작되지는 않습니다.\(MUST\)

에이전트는 이 미디어 스트림의 초기 제안에서와 마찬가지로 이 미디어 스트림에 대한 SDP의 나머지 필드를 설정합니다\(섹션 4.3 참조\). 결과적으로, 후보 세트에는 해당 스트림에 대한 이전 후보의 일부, 없음 또는 전부가 포함될 수 있으며 섹션 4.1.1에 설명된 대로 수집된 완전히 새로운 후보 세트가 포함될 수 있습니다.\(MAY\)

---
##### **9.1.1.2.  Removing a Media Stream**

에이전트가 포트를 0으로 설정하여 미디어 스트림을 제거하는 경우 해당 미디어 스트림에 대한 후보 속성을 포함해서는 안 되며 해당 미디어 스트림에 대해 섹션 15에 정의된 다른 ICE 관련 속성을 포함해서는 안 됩니다.\(MUST NOT\)

---
##### **9.1.1.3.  Adding a Media Stream**

에이전트가 새 미디어 스트림을 추가하려는 경우 해당 미디어 스트림에 대한 초기 제안인 것처럼 이 미디어 스트림에 대한 SDP의 필드를 설정합니다\(섹션 4.3 참조\). 그러면 이 미디어 스트림에 대한 ICE 처리가 시작됩니다.

---
#### **9.1.2.  Procedures for Full Implementations**

이 섹션에서는 기존 미디어 스트림을 포함하여 전체 구현을 위한 추가 절차를 설명합니다.

사용자 이름 조각, 비밀번호 및 구현 수준은 이전에 사용된 것과 동일하게 유지되어야 합니다. 에이전트가 이들 중 하나를 변경해야 하는 경우 해당 미디어 스트림에 대해 ICE를 다시 시작해야 합니다.\(MUST, MUST\)

추가 동작은 해당 미디어 스트림에 대한 상태 ICE 처리에 따라 달라집니다.

---
##### **9.1.2.1.  Existing Media Streams with ICE Running**

에이전트가 이전에 설정된 미디어 스트림을 포함하고 ICE 검사가 실행 중 상태인 업데이트된 제안을 생성하는 경우 에이전트는 여기에 정의된 절차를 따릅니다.

에이전트는 해당 미디어 스트림에 대해 이전에 신호를 보낸 모든 로컬 후보에 대한 후보 속성을 포함해야 합니다. SDP에 표시된 해당 후보의 속성\(우선순위, 기반, 유형 및 관련 전송 주소\)은 동일하게 유지되어야 합니다. 해당 후보를 근본적으로 식별하는 IP 주소, 포트 및 전송 프로토콜은 동일하게 유지되어야 합니다\(변경되면 새로운 후보가 됩니다\). 구성 요소 ID는 동일하게 유지되어야 합니다. 에이전트는 이전에 제공하지 않았지만 동료 반사 후보를 포함하여 마지막 제안/답변 교환 이후 수집한 추가 후보를 포함할 수 있습니다.\(MUST, SHOULD, MUST, MUST, MAY\)

에이전트는 미디어의 기본 대상을 변경할 수 있습니다. 초기 제안과 마찬가지로 이 기본 대상과 일치하는 제안 속성 집합이 있어야 합니다.\(MAY, MUST\)

---
##### **9.1.2.2.  Existing Media Streams with ICE Completed**

에이전트가 이전에 설정된 미디어 스트림을 포함하고 ICE 확인이 완료됨 상태인 업데이트된 제안을 생성하는 경우 에이전트는 여기에 정의된 절차를 따릅니다.

미디어의 기본 대상\(즉, 해당 미디어 스트림에 사용되는 m 및 c 라인의 IP 주소 및 포트 값\)은 각 구성 요소에 대한 유효한 목록에서 가장 높은 우선 순위로 지정된 쌍의 로컬 후보여야 합니다. 이는 미디어에 대해 ICE가 선택한 대상과 동일하도록 미디어의 기본 대상을 "수정"합니다.\(MUST\)

에이전트는 미디어 스트림의 각 구성 요소에 대한 기본 대상과 일치하는 후보에 대한 후보 속성을 포함해야 하며 다른 후보를 포함해서는 안 됩니다.\(MUST NOT\)

또한 에이전트가 제어하는 ​​경우 체크리스트가 완료 상태인 각 미디어 스트림에 대해 a=remote-candidates 속성을 포함해야 합니다. 이 속성에는 해당 미디어 스트림의 각 구성 요소에 대한 유효한 목록에서 가장 높은 우선 순위로 지정된 쌍의 원격 후보가 포함됩니다. 제어 에이전트가 해당 쌍을 선택하는 경쟁 조건을 피해야 하지만 업데이트된 제안은 이러한 쌍이 선택은커녕 유효하다는 사실조차 모르는 제어 에이전트에 대한 연결 확인을 능가합니다. 이 경쟁 조건에 대한 자세한 내용은 부록 B.6을 참조하세요.\(MUST\)

---
#### **9.1.3.  Procedures for Lite Implementations**
---
##### **9.1.3.1.  Existing Media Streams with ICE Running**

이 섹션에서는 ICE가 실행 중인 기존 스트림에 대한 라이트 구현 절차를 설명합니다.

라이트 구현은 후속 제안의 a=candidate 속성에 각 미디어 스트림의 각 구성 요소에 대한 모든 후보를 포함해야 합니다. 이러한 후보자는 섹션 4.2에 설명된 대로 초기 제안 절차와 동일하게 구성됩니다.\(MUST\)

라이트 구현은 후속 제안에 추가 호스트 후보를 추가해서는 안 됩니다. 에이전트가 추가 후보자를 제공해야 하는 경우 ICE를 다시 시작해야 합니다.\(MUST NOT, MUST\)

사용자 이름 조각, 비밀번호 및 구현 수준은 이전에 사용된 것과 동일하게 유지되어야 합니다. 에이전트가 이들 중 하나를 변경해야 하는 경우 해당 미디어 스트림에 대해 ICE를 다시 시작해야 합니다.\(MUST, MUST\)

---
##### **9.1.3.2.  Existing Media Streams with ICE Completed**

ICE가 미디어 스트림에 대해 완료된 경우 해당 미디어 스트림의 기본 대상은 유효한 목록에 있는 해당 구성 요소에 대한 후보 쌍의 원격 후보로 설정되어야 합니다. 간단한 구현의 경우 미디어 스트림의 각 구성 요소에 대한 유효한 목록에는 항상 단일 후보 쌍만 있습니다. 또한 에이전트는 각 기본 대상에 대한 후보 속성을 포함해야 합니다.\(MUST, MUST\)

또한 에이전트가 제어하는 ​​경우\(두 에이전트가 모두 라이트인 경우에만 발생\) 에이전트는 각 미디어 스트림에 대해 a=remote-candidates 속성을 포함해야 합니다. 속성에는 유효한 목록의 후보 쌍\(각 미디어 스트림의 각 구성 요소에 대해 한 쌍\)의 원격 후보가 포함됩니다.\(MUST\)

---
### **9.2.  Receiving the Offer and Generating an Answer**
---
#### **9.2.1.  Procedures for All Implementations**

기존 세션 내에서 후속 제안을 받을 때 에이전트는 이전 제안/답변 교환의 확인 결과에 관계없이 섹션 5.1의 확인 절차를 다시 적용해야 합니다. 실제로 이전 제안/응답 교환으로 인해 ICE가 사용되지 않았을 가능성이 있지만 후속 교환의 결과로 사용됩니다.\(MUST\)

---
##### **9.2.1.1.  Detecting ICE Restart**

제안에 피어의 이전 SDP와 비교하여 a=ice-ufrag 또는 a=ice-pwd 속성의 변경 사항이 포함된 경우 이는 이 미디어 스트림에 대해 ICE가 다시 시작되고 있음을 나타냅니다. 모든 미디어 스트림이 다시 시작되면 ICE가 전체적으로 다시 시작됩니다.

미디어 스트림에 대해 ICE가 다시 시작되는 경우:

o 에이전트는 답변에서 a=ice-ufrag 및 a=ice-pwd 속성을 변경해야 합니다.\(MUST\)

o 에이전트는 답변의 구현 수준을 변경할 수 있습니다.\(MAY\)

에이전트는 이 미디어 스트림에 대한 초기 응답에서와 마찬가지로 이 미디어 스트림에 대한 SDP의 나머지 필드를 설정합니다\(섹션 4.3 참조\). 결과적으로, 후보 세트에는 해당 스트림에 대한 이전 후보의 일부, 없음 또는 전부가 포함될 수 있으며 섹션 4.1.1에 설명된 대로 수집된 완전히 새로운 후보 세트가 포함될 수 있습니다.\(MAY\)

---
##### **9.2.1.2.  New Media Stream**

제안에 새로운 미디어 스트림이 포함된 경우 에이전트는 해당 미디어 스트림이 포함된 초기 제안을 받은 것처럼 답변의 필드를 설정합니다\(섹션 4.3 참조\). 그러면 이 미디어 스트림에 대한 ICE 처리가 시작됩니다.

---
##### **9.2.1.3.  Removed Media Stream**

제안에 포트가 0인 미디어 스트림이 포함된 경우 에이전트는 응답에 해당 미디어 스트림에 대한 후보 속성을 포함해서는 안 되며 해당 미디어 스트림에 대해 섹션 15에 정의된 다른 ICE 관련 속성을 포함해서는 안 됩니다.\(MUST NOT\)

---
#### **9.2.2.  Procedures for Full Implementations**

에이전트가 제안에서 ICE 재시작을 감지하지 않는 한 사용자 이름 조각, 비밀번호 및 구현 수준은 이전에 사용된 것과 동일하게 유지되어야 합니다. 에이전트가 이들 중 하나를 변경해야 하는 경우 제안을 생성하여 해당 미디어 스트림에 대해 ICE를 다시 시작해야 합니다. 응답으로 ICE를 다시 시작할 수 없습니다.\(MUST, MUST\)

추가 동작은 해당 미디어 스트림의 ICE 처리 상태에 따라 달라집니다.

9.2.2.1. ICE가 실행되고 원격 후보가 없는 기존 미디어 스트림

ICE가 미디어 스트림에 대해 실행 중이고 해당 미디어 스트림에 대한 제안에 원격 후보 속성이 부족한 경우 답변 구성 규칙은 섹션 9.1.2.1에 설명된 대로 제안자에 대한 규칙과 동일합니다.

9.2.2.2. ICE가 완료되고 원격 후보가 없는 기존 미디어 스트림

미디어 스트림에 대해 ICE가 완료되고 해당 미디어 스트림에 대한 제안에 원격 후보 속성이 부족한 경우 응답 구성 규칙은 응답자가 반드시 해야 한다는 점을 제외하고 섹션 9.1.2.2에 설명된 제안자에 대한 규칙과 동일합니다. 답변에 a=remote-candidates 속성을 포함하지 마세요.\(MUST NOT\)

---
##### **9.2.2.3.  Existing Media Streams and remote-candidates**

제어된 에이전트는 피어가 해당 미디어 스트림에 대한 ICE 처리를 완료하면 해당 미디어 스트림에 대한 a=remote-candidates 속성이 있는 제안을 받게 됩니다. 이 속성은 제안 수신 사이의 경쟁 조건을 처리하기 위해 제안에 존재합니다.

응답자에게 ICE가 선택할 후보자를 알려주는 바인딩 응답 수신. 이 경쟁 조건에 대한 설명은 부록 B.6을 참조하세요. 결과적으로 이 속성이 있는 제안 처리는 경주의 승자에 따라 달라집니다.

에이전트는 다음을 통해 미디어 스트림의 각 구성 요소에 대한 후보 쌍을 형성합니다.

```text
   o  Setting the remote candidate equal to the offerer's default
      destination for that component (e.g., the contents of the m and c
      lines for RTP, and the a=rtcp attribute for RTCP)
```

o 제안의 a=remote-candidates 속성에 있는 동일한 구성 요소에 대한 전송 주소와 동일하게 로컬 후보를 설정합니다.

그런 다음 에이전트는 이러한 각 후보 쌍이 유효한 목록에 있는지 확인합니다. 특정 쌍이 유효한 목록에 없으면 검사에서 경주가 "패배"된 것입니다. 그러한 쌍을 "잃어버린 쌍"이라고 부릅니다.

에이전트는 원격 후보가 손실된 쌍의 원격 후보와 동일한 모든 쌍을 체크리스트에서 찾습니다.

o 쌍 중 어느 것도 진행 중이 아니며 적어도 하나가 실패인 경우 네트워크 분할 또는 심각한 패킷 손실과 같은 네트워크 오류가 발생했을 가능성이 높습니다. 에이전트는 마치 원격 후보 속성이 존재하지 않은 것처럼 이 미디어 스트림에 대한 응답을 생성한 다음 이 스트림에 대해 ICE를 다시 시작해야 합니다.\(SHOULD\)

o 쌍 중 하나 이상이 진행 중인 경우 에이전트는 해당 검사가 완료될 때까지 기다려야 하며, 각 검사가 완료되면 손실되는 쌍이 없을 때까지 이 섹션의 처리를 다시 실행해야 합니다.\(SHOULD\)

손실된 쌍이 없으면 에이전트는 답변을 생성할 수 있습니다. 미디어의 기본 대상을 제안의 원격 후보 속성에 있는 후보로 설정해야 합니다\(각각은 이제 유효한 목록에 있는 후보 쌍의 로컬 후보가 됩니다\). 제안의 원격 후보 속성에 있는 각 후보에 대한 답변에 후보 속성을 포함해야 합니다.\(MUST, MUST\)

---
#### **9.2.3.  Procedures for Lite Implementations**

수신된 제안에 미디어 스트림에 대한 원격 후보 속성이 포함되어 있는 경우 에이전트는 다음을 통해 미디어 스트림의 각 구성 요소에 대한 후보 쌍을 형성합니다.

o 해당 구성 요소에 대한 제공자의 기본 대상과 동일하게 원격 후보를 설정합니다\(예: RTP의 경우 m 및 c 라인의 내용, RTCP의 경우 a=rtcp 속성\).

o 제안의 a=remote-candidates 속성에 있는 동일한 구성 요소에 대한 전송 주소와 동일하게 로컬 후보를 설정합니다.

그런 다음 해당 후보를 미디어 스트림의 유효한 목록에 배치합니다. 해당 미디어 스트림에 대한 ICE 처리 상태는 완료됨으로 설정됩니다.

또한 에이전트가 자신이 제어하고 있다고 믿었지만 제안에 원격 후보 속성이 포함된 경우 두 에이전트 모두 자신이 제어하고 있다고 믿습니다. 이 경우 두 사람 모두 거의 동시에 업데이트된 제안을 보냈을 것입니다. 그러나 제안/응답 교환을 전달하는 신호 프로토콜은 이러한 눈부심 조건을 해결하여 한 에이전트가 동료가 제안을 보내기 전에 제안을 받음으로써 항상 '승자'가 됩니다. 승자는 통제된 역할을 맡으므로 패자\(이 섹션에서 고려 중인 응답자\)는 자신의 역할을 통제된 역할로 변경해야 합니다. 결과적으로 에이전트가 섹션 8.2.2의 규칙에 따라 제어하고 있었기 때문에 업데이트된 제안을 보내려고 했다면 더 이상 그럴 필요가 없습니다.\(MUST\)

잠재적인 역할 변경, 유효 목록 변경 및 상태 변경 외에도 응답 구성은 섹션 9.1.3에 설명된 제안 구성과 동일하게 수행됩니다.

---
### **9.3.  Updating the Check and Valid Lists**
---
#### **9.3.1.  Procedures for Full Implementations**
---
##### **9.3.1.1.  ICE Restarts**

에이전트는 다시 시작하기 전에 이전에 선택한 쌍이라고 하는 미디어 스트림의 각 구성 요소에 대한 유효 목록에서 가장 높은 우선순위로 지정된 쌍을 기억해야 합니다. 에이전트는 섹션 11.1에 설명된 대로 이러한 쌍을 사용하여 미디어를 계속 전송합니다. 이러한 대상이 기록되면 에이전트는 유효한 목록과 확인 목록을 플러시한 다음 섹션 5.7에 설명된 대로 확인 목록과 해당 상태를 다시 계산해야 합니다.\(MUST, MUST\)

---
##### **9.3.1.2.  New Media Stream**

제안/응답 교환이 새로운 미디어 스트림을 추가한 경우 에이전트는 섹션 5.7에 설명된 대로 이에 대한 새로운 체크리스트\(물론 시작하려면 빈 유효 목록도 포함\)를 생성해야 합니다.\(MUST\)

---
##### **9.3.1.3.  Removed Media Stream**

제안/응답 교환이 미디어 스트림을 제거했거나 응답이 제공된 미디어 스트림을 거부한 경우 에이전트는 해당 미디어 스트림에 대한 유효 목록을 플러시해야 합니다. 해당 미디어 스트림에 대해 진행 중인 모든 STUN 트랜잭션을 종료해야 합니다. 에이전트는 해당 미디어 스트림에 대한 체크리스트를 제거하고 이에 대해 보류 중인 일반 검사를 취소해야 합니다.\(MUST, MUST, MUST\)

---
##### **9.3.1.4.  ICE Continuing for Existing Media Stream**

유효한 목록은 ICE가 다시 시작되지 않는 한 업데이트된 제안/답변 교환의 영향을 받지 않습니다.

에이전트가 해당 미디어 스트림에 대해 실행 중 상태인 경우 확인 목록이 업데이트됩니다\(상태가 완료되면 확인 목록은 관련이 없음\). 이를 위해 에이전트는 섹션 5.7에 설명된 절차를 사용하여 체크리스트를 다시 계산합니다. 새 체크리스트의 쌍이 이전 체크리스트에도 있었고 해당 상태가 대기 중, 진행 중, 성공 또는 실패인 경우 해당 상태가 복사됩니다. 그렇지 않으면 해당 상태가 Frozen으로 설정됩니다.

활성화된 체크 목록이 없는 경우\(각 체크 목록의 쌍이 고정됨을 의미\), 전체 모드 에이전트는 첫 번째 미디어 스트림에 대한 체크 목록의 첫 번째 쌍을 대기 중으로 설정한 다음 다른 모든 스트림의 상태를 설정합니다. 동일한 구성 요소 ID와 대기에 대한 동일한 기반을 가진 해당 체크리스트의 쌍도 마찬가지입니다.

다음으로 에이전트는 우선순위가 가장 높은 쌍부터 시작하여 각 체크리스트를 검토합니다. 쌍의 상태가 성공이고 구성 요소 ID가 1인 경우 구성 요소 ID가 1이 아닌 동일한 기초가 있는 동일한 검사 목록의 모든 Frozen 쌍의 상태는 대기 중으로 설정됩니다. 특정 체크리스트에 대해 성공 상태의 해당 미디어 스트림의 각 구성 요소에 대한 쌍이 있는 경우 에이전트는 다른 모든 미디어 스트림\(따라서 다른 체크리스트\)의 첫 번째 구성 요소에 대한 모든 고정 쌍의 상태를 다음과 같이 이동합니다. Waiting과 동일한 기반입니다.

---
#### **9.3.2.  Procedures for Lite Implementations**

ICE가 미디어 스트림에 대해 다시 시작하는 경우 에이전트는 해당 미디어 스트림에 대한 새로운 유효한 목록을 시작해야 합니다. 이전에 선택한 쌍이라고 하는 미디어 스트림의 각 구성 요소에 대한 이전 유효 목록의 쌍을 기억해야 하며 섹션 11.1에 설명된 대로 계속해서 그곳으로 미디어를 보내야 합니다. 각 미디어 스트림에 대한 ICE 처리 상태는 실행 중으로 변경되어야 하며, ICE 처리 상태는 실행 중으로 변경되어야 합니다.\(MUST, MUST, MUST\)

---
## **10.  Keepalives**

모든 엔드포인트는 각 미디어 세션에 대해 Keepalive를 전송해야 합니다. 이러한 연결 유지는 미디어 세션 동안 NAT 바인딩을 유지하는 목적으로 사용됩니다. 이러한 Keepalive는 미디어 스트림이 현재 비활성인지, sendonly, Recvonly 또는 sendrecv인지 여부와 대역폭 속성의 존재 여부 또는 값에 관계없이 전송되어야 합니다. 이러한 Keepalive는 ICE가 세션에 전혀 활용되지 않는 경우에도 전송되어야 합니다. Keepalive는 피어가 지원하는 형식을 사용하여 전송되어야 합니다. ICE 엔드포인트는 UDP 스트림에 대한 STUN 기반 킵얼라이브를 허용하므로 에이전트가 전체 ICE 구현이고 ICE\(라이트 또는 전체\)를 지원하는 피어와 통신할 때 STUN 킵얼라이브를 사용해야 합니다. 에이전트는 각 미디어 세션에 대한 a=candidate 속성의 존재 여부를 통해 해당 피어가 ICE를 지원하는지 확인할 수 있습니다. 피어가 ICE를 지원하지 않는 경우 연결 유지에 대한 패킷 형식 선택은 로컬 구현의 문제입니다. 실제 미디어 콘텐츠가 없을 때 패킷을 쉽게 보낼 수 있는 형식을 권장합니다. 이 목표를 쉽게 충족할 수 있는 형식의 예로는 RTP No-Op \[NO-OP-RTP\]가 있으며, 양측이 이를 지원하는 경우 RTP Comfort Noise \[RFC3389\]가 있습니다. 피어가 keepalive에 특히 적합한 형식을 지원하지 않는 경우 에이전트는 잘못된 버전 번호 또는 피어에 의해 폐기되도록 하는 다른 형태의 오류가 있는 RTP 패킷을 보내야 합니다\(SHOULD\).\(MUST, MUST, MUST, SHOULD, MUST, SHOULD, SHOULD\)

ICE가 Tr 초 동안 미디어 구성 요소에 사용하는 후보 쌍에서 전송된 패킷이 없는 경우\(패킷에는 구성 요소\(RTP 또는 RTCP\) 및 이전 킵얼라이브에 대해 정의된 패킷이 포함됨\), 에이전트는 해당 쌍에서 킵얼라이브를 생성해야 합니다. Tr은 구성 가능해야 하며 기본값은 15초여야 합니다. Tr은 15초 미만으로 구성하면 안 됩니다. 또는 에이전트가 개입 NAT의 바인딩 수명을 검색하는 동적 방법을 가지고 있는 경우 해당 값을 사용하여 Tr을 결정할 수 있습니다. 보다 통제된 네트워킹 환경에서 ICE를 배포하는 관리자는 해당 환경에서 가능한 가장 긴 기간으로 Tr을 설정해야 합니다.\(MUST, SHOULD, MUST NOT, SHOULD\)

STUN이 keepalive에 사용되는 경우 STUN 바인딩 표시가 사용됩니다 \[RFC5389\]. 표시는 어떠한 인증 메커니즘도 활용해서는 안 됩니다. 역다중화를 돕기 위해 FINGERPRINT 속성을 포함해야 하지만 다른 속성을 포함해서는 안 됩니다. 이는 NAT 바인딩을 활성 상태로 유지하는 데에만 사용됩니다. 바인딩 표시는 미디어에 사용되는 것과 동일한 로컬 및 원격 후보를 사용하여 전송됩니다. 연결 유지에 바인딩 표시가 사용되더라도 에이전트는 연결 확인도 받을 준비가 되어 있어야 합니다. 연결 확인이 수신되면 \[RFC5389\]에 설명된 대로 응답이 생성되지만 그렇지 않은 경우 ICE 처리에는 영향이 없습니다.\(MUST NOT, SHOULD NOT, MUST\)

에이전트는 ICE가 미디어와 함께 사용할 후보를 선택하거나 미디어 흐름이 시작되는 중 먼저 발생하는 경우 연결 유지 처리를 시작해야 합니다. 세션이 종료되거나 미디어 스트림이 제거되면 Keepalive가 종료됩니다.\(MUST\)

---
## **11.  Media Handling**
---
### **11.1.  Sending Media**

미디어 전송 절차는 전체 구현과 라이트 구현에 따라 다릅니다.

---
#### **11.1.1.  Procedures for Full Implementations**

에이전트는 항상 선택된 후보 쌍이라고 하는 후보 쌍을 사용하여 미디어를 보냅니다. 에이전트는 선택한 쌍의 원격 후보에게 미디어를 보내고\(패킷의 대상 주소와 포트를 해당 원격 후보와 동일하게 설정\) 선택한 쌍의 로컬 후보에서 미디어를 보냅니다. 로컬 후보가 서버 또는 피어 반사적일 때 미디어는 베이스에서 시작됩니다. 중계된 후보로부터 전송된 미디어는 \[RFC5766\]에 정의된 절차를 사용하여 해당 TURN 서버를 통해 베이스에서 전송됩니다.

로컬 후보가 중계된 후보인 경우 에이전트가 원격 후보를 향한 TURN 서버에 채널을 생성하는 것이 권장됩니다. 이는 \[RFC5766\]의 섹션 11에 정의된 채널 생성 절차를 사용하여 수행됩니다.\(SHOULD\)

미디어 스트림의 구성 요소에 대해 선택된 쌍은 다음과 같습니다.

o 해당 미디어 스트림에 대한 체크리스트 상태가 실행 중이고 ICE 재시작으로 인해 해당 구성 요소에 대해 이전에 선택한 쌍이 없는 경우 비어 있습니다.

o 해당 미디어 스트림의 체크리스트 상태가 실행 중이고 ICE 재시작으로 인해 해당 구성 요소에 대해 이전에 선택한 쌍이 있었던 경우 미디어 스트림의 구성 요소에 대해 이전에 선택한 쌍과 동일합니다.

o 체크리스트 상태가 완료인 경우 유효한 목록의 해당 구성요소에 대해 가장 높은 우선순위로 지정된 쌍과 동일합니다.

미디어 스트림의 하나 이상의 구성 요소에 대해 선택된 쌍이 비어 있는 경우 에이전트는 해당 미디어 스트림의 구성 요소에 대한 미디어를 전송해서는 안 됩니다. 미디어 스트림의 각 구성 요소에 대해 선택된 쌍에 값이 있으면 에이전트는 해당 미디어 스트림의 모든 구성 요소에 대한 미디어를 보낼 수 있습니다.\(MUST NOT, MAY\)

미디어 스트림의 구성 요소에 대해 선택된 쌍은 가장 최근 제안/답변 교환의 동일한 구성 요소에 대한 기본 쌍과 동일하지 않을 수 있습니다. 이 경우 기본 쌍이 아닌 선택한 쌍이 미디어에 사용됩니다. ICE가 처음 완료될 때 선택한 쌍이 기본 쌍과 일치하지 않으면 제어 에이전트는 업데이트된 제안/응답 교환을 보내 이러한 차이를 해결합니다. 그러나 업데이트된 제안이 도착할 때까지는 일치하는 항목이 없습니다. 또한 매우 특이한 경우에는 업데이트된 제안/답변의 기본 후보가 일치하지 않을 수 있습니다.

---
#### **11.1.2.  Procedures for Lite Implementations**

라이트 구현은 해당 미디어 스트림의 각 구성 요소에 대한 후보 쌍을 포함하는 유효한 목록이 있을 때까지 미디어를 전송해서는 안 됩니다. 그런 일이 발생하면 에이전트는 미디어 패킷 전송을 시작할 수 있습니다. 이를 위해 쌍의 원격 후보에게 미디어를 보내고\(패킷의 대상 주소와 포트를 해당 원격 후보와 동일하게 설정\) 로컬 후보로부터 미디어를 보냅니다.\(MUST NOT, MAY\)

---
#### **11.1.3.  Procedures for All Implementations**

ICE는 지터 버퍼 적응 메커니즘과 상호 작용합니다. RTP 스트림은 하나의 후보를 사용하여 시작하고 다른 후보로 전환할 수 있지만 ICE에서는 이런 일이 거의 발생하지 않습니다. 새로운 후보로 인해 RTP 패킷이 네트워크를 통해 다른 경로\(지연 특성이 다른 경로\)를 사용하게 될 수 있습니다. 아래에서 설명하는 것처럼 에이전트는 미디어 패킷의 소스 또는 대상 주소가 변경될 때 지터 버퍼를 다시 조정하는 것이 좋습니다. 또한 많은 오디오 코덱은 지터 버퍼 적응을 위해 마커 비트를 사용하여 토크 퍼트의 시작을 알립니다. 이러한 코덱의 경우 에이전트가 한 후보 쌍에서 다른 후보 쌍으로 미디어 전송을 전환할 때 발신자가 마커 비트 \[RFC3550\]를 설정하는 것이 좋습니다.\(SHOULD\)

---
### **11.2.  Receiving Media**

ICE 구현은 가장 최근의 제안/응답 교환에서 해당 구성 요소에 대해 제공된 모든 후보의 각 구성 요소에 대한 미디어를 수신할 준비가 되어 있어야 합니다\(RTP의 경우 후보가 둘 다에 대해 제공된 경우 RTP와 RTCP가 모두 포함됩니다\).\(MUST\)

에이전트가 특정 미디어 스트림에 대한 새로운 소스 또는 대상 IP 주소가 포함된 RTP 패킷을 수신하면 에이전트가 지터 버퍼를 다시 조정하는 것이 좋습니다.\(SHOULD\)

RFC 3550 \[RFC3550\]은 동기화 소스\(SSRC\) 충돌 및 루프를 감지하기 위한 섹션 8.2의 알고리즘을 설명합니다. 이러한 알고리즘은 부분적으로 다양한 소스 전송을 확인하는 데 기반을 두고 있습니다.

동일한 SSRC를 가진 주소. 그러나 ICE를 사용하면 미디어 스트림이 후보 간에 전환되면서 이러한 변경이 발생하는 경우가 있습니다. 에이전트는 미디어 전송을 진행하는 STUN 교환의 결과로 미디어 스트림이 동일한 피어에서 온 것인지 확인할 수 있습니다. 따라서 소스 전송 주소가 변경되었지만 미디어 패킷이 동일한 피어 에이전트에서 온 경우 이는 SSRC 충돌로 처리되어서는 안 됩니다.\(SHOULD NOT\)

---
## **12.  Usage with SIP**
---
### **12.1.  Latency Guidelines**

ICE는 엔드포인트 간에 일련의 STUN 기반 연결 확인이 필요합니다. 이러한 확인은 응답 생성 시 응답자로부터 시작되고, 응답을 수신할 때 제안자로부터 시작됩니다. 이러한 검사는 완료하는 데 시간이 걸릴 수 있으므로 제안 및 답변과 함께 사용할 메시지 선택이 인지된 사용자 대기 시간에 영향을 미칠 수 있습니다. 두 가지 대기 시간 수치가 특히 중요합니다. 픽업 후 지연과 다이얼 후 지연이 있습니다. 픽업 후 지연은 사용자가 "전화에 응답"하는 시점과 사용자가 발언한 내용이 발신자에게 전달될 수 있는 시점 사이의 시간을 나타냅니다. 다이얼 후 지연은 사용자가 사용자의 대상 주소를 입력한 시점부터 수신자의 전화 벨이 성공적으로 울리기 시작한 결과 링백이 시작되는 시점까지의 시간을 의미합니다.

두 가지 경우를 고려할 수 있습니다. 하나는 제안이 초기 INVITE에 있는 경우이고 다른 하나는 응답에 있는 경우입니다.

---
#### **12.1.1.  Offer in INVITE**

다이얼 후 지연을 줄이려면 발신자가 실제로 초기 INVITE를 보내기 전에 후보자 수집을 시작하는 것이 좋습니다. 이는 키패드 활동이나 전화기가 오프훅 상태가 되는 등 통화가 보류 중이라는 사용자 인터페이스 신호에 따라 시작될 수 있습니다.\(SHOULD\)

INVITE 요청에서 제안이 수신되면 응답자는 제안 수신 시 후보자를 수집하기 시작해야 하며 해당 프로세스가 완료되면 임시 응답으로 답변을 생성해야 합니다. ICE에서는 SDP를 통한 임시 응답이 안정적으로 전송될 것을 요구합니다. 이는 기존 PRACK\(Provisional Response Acknowledgement\) 메커니즘\[RFC3262\] 또는 ICE에 특정한 최적화를 통해 수행될 수 있습니다. 이 최적화를 사용하면 하나 이상의 미디어 스트림에 대한 ICE 처리를 시작하는 SDP 응답이 포함된 임시 응답을 RFC 3262 없이 안정적으로 전송할 수 있습니다. 이를 위해 에이전트는 RFC 3262에 설명된 지수 백오프 타이머를 사용하여 임시 응답을 재전송해야 합니다. STUN 바인딩 수신 시 중지\(SHOULD, MUST\)

해당 SDP에서 신호를 받은 미디어 스트림 중 하나에 대한 요청\(바인딩 요청을 수신하면 제안자가 답변을 수신했음을 나타냄\) 또는 2xx 응답으로 답변을 전송할 때. 피어 에이전트가 라이트인 경우 STUN 바인딩 요청이 절대 발생하지 않습니다. 이러한 경우 에이전트는 18x를 4번 보낸 후 재전송을 중단해야 합니다\(ICE는 피어가 18x를 수신하지 못하더라도 실제로 작동합니다. 그러나 경험에 따르면 미들박스 및 방화벽 통과에 전송이 중요하다는 것이 밝혀졌습니다\). 마지막 재전송 전에 바인딩 요청이 수신되지 않으면 에이전트는 세션이 종료된 것으로 간주하지 않습니다. 임시 응답이 안정적으로 전달된다는 사실에도 불구하고 상담원이 업데이트된 제안이나 답변을 보낼 수 있는 시기에 대한 규칙은 RFC 3262에 지정된 규칙과 동일합니다. 특히 INVITE에 제안이 포함된 경우 동일한 답변이 모든 항목에 나타납니다. 1xx 및 INVITE에 대한 2xx 응답에서. 2xx가 전송된 후에만 업데이트된 제안/응답 교환이 발생할 수 있습니다. 두 에이전트가 모두 PRACK을 지원하는 경우 이 최적화를 사용하면 안 됩니다. 최적화는 ICE 처리를 시작하는 응답을 전달하는 임시 응답에 매우 구체적입니다. 이는 1xx 신뢰성을 위한 일반적인 기술이 아닙니다.\(MUST, SHOULD NOT\)

또는 에이전트는 200 OK가 될 때까지 응답 전송을 지연할 수 있습니다. 그러나 이는 사용자 경험을 저하시키므로 권장되지 않습니다.\(SHOULD NOT\)

응답이 전송되면 에이전트는 연결 확인을 시작해야 합니다. 미디어 스트림의 각 구성 요소에 대한 후보 쌍이 유효한 목록에 입력되면 응답자는 해당 미디어 스트림에서 미디어 전송을 시작할 수 있습니다.\(SHOULD\)

그러나 이 시점 이전에는 호출자에게 전송되어야 하는 모든 미디어\(예: SIP 초기 미디어 \[RFC3960\]\)를 전송해서는 안 됩니다. 이러한 이유로 구현에서는 각 미디어 스트림의 각 구성 요소에 대한 후보가 유효한 목록에 입력될 때까지 수신자에게 경고하는 것을 지연해야 합니다. PSTN 게이트웨이의 경우 이는 PSTN으로의 설정 메시지가 이 지점까지 지연된다는 것을 의미합니다. 이렇게 하면 다이얼 후 지연이 증가하지만 '고스트 링'을 제거하는 효과가 있습니다. 고스트링은 상대방이 전화벨 소리를 듣고 전화를 받았으나 아무 소리도 들리지 않고 들리지 않는 경우를 말합니다. 이 기술은 지역화된 결정이기 때문에 전제 조건 \[RFC3312\]에 대한 지원이나 사용 없이 작동합니다. 또한 미디어의 단일 패킷이 잘리지 않도록 보장하여 픽업 후 지연이 0이 되는 이점도 있습니다. 에이전트가 이러한 방식으로 로컬 경고를 지연하기로 선택한 경우 경고가 시작된 후 180 응답을 생성해야 합니다\(SHOULD\).\(MUST NOT, SHOULD, SHOULD\)

---
#### **12.1.2.  Offer in Response**

제안이 INVITE에 있고 답변이 임시 및/또는 200 OK 응답에 있는 사용 외에도 ICE는 제안이 응답에 나타나는 경우에도 작동합니다. 제3자 통화 제어 \[RFC3725\]에서 흔히 발생하는 이러한 경우 ICE 에이전트는 신뢰할 수 있는 임시 응답\(RFC 3262를 활용해야 함\)으로 제안을 생성해야 하며 INVITE 수신 시 사용자에게 경고하지 않아야 합니다. 답변은 PRACK을 통해 도착합니다. 이를 통해 경고 전에 ICE 처리가 수행되므로 통화 설정 지연이 늘어나는 대신 픽업 후 지연이 발생하지 않습니다. ICE가 완료되면 수신자는 사용자에게 경고한 다음 사용자가 응답하면 200 OK를 생성할 수 있습니다. 제안/답변 교환이 완료되었으므로 200 OK에는 SDP가 포함되지 않습니다.\(MUST\)

대안으로 상담원은 대신 2xx에 제안을 넣을 수도 있습니다\(이 경우 답변은 ACK로 제공됩니다\). 이런 일이 발생하면 호출 수신자는 INVITE 수신 시 사용자에게 알리고 사용자가 응답한 후에만 ICE 교환이 발생합니다. 이는 통화 설정 지연을 줄이는 효과가 있지만 상당한 픽업 후 지연 및 미디어 클리핑이 발생할 수 있습니다.\(MAY\)

---
### **12.2.  SIP Option Tags and Media Feature Tags**

\[RFC5768\]은 ICE와 함께 사용할 SIP 옵션 태그와 미디어 기능 태그를 지정합니다. SIP를 사용하는 ICE 구현은 등록 시 기능 태그를 사용하여 신호 중개자를 통한 상호 운용성을 촉진하는 이 사양을 지원해야 합니다.\(SHOULD\)

---
### **12.3.  Interactions with Forking**

ICE는 포크와 매우 잘 상호 작용합니다. 실제로 ICE는 포크와 관련된 일부 문제를 해결합니다. ICE가 없으면 호출이 분기되고 호출자가 여러 개의 수신 미디어 스트림을 수신할 때 어떤 미디어 스트림이 어떤 호출 수신자에 해당하는지 확인할 수 없습니다.

ICE를 사용하면 이 문제가 해결됩니다. 미디어 전송 전에 발생하는 연결 확인은 사용자 이름 조각을 전달하며, 이는 차례로 특정 수신자와 상호 연관됩니다. 연결 확인과 동일한 후보 쌍에 도착하는 후속 미디어 패킷은 동일한 호출 수신자와 연결됩니다. 따라서 호출자는 응답을 받은 동안 이 상관 관계를 수행할 수 있습니다.

---
### **12.4.  Interactions with Preconditions**

RFC 3312 \[RFC3312\] 및 RFC 4032 \[RFC4032\]에 정의된 QoS\(서비스 품질\) 전제 조건은 제안/응답에서 미디어의 기본 대상으로 나열된 전송 주소에만 적용됩니다.

ICE가 미디어가 수신되는 전송 주소를 변경하는 경우 이 변경 사항은 ICE의 선택과 일치하도록 미디어의 기본 대상을 변경하는 업데이트된 제안에 반영됩니다. 따라서 이는 다른 re-INVITE와 마찬가지로 나타나며 "백그라운드에서" 발생하는 ICE 협상으로 인해 미디어 대상이 변경된다는 사실과 관계없이 적용되는 RFC 3312 및 4032에서 완전히 처리됩니다.

실제로 에이전트는 검사가 완료되고 미디어에 사용할 후보 쌍을 선택할 때까지 QoS 전제 조건이 충족되었음을 표시해서는 안 됩니다.\(SHOULD NOT\)

ICE는 또한 연결 전제 조건 \[SDP-PRECON\]과 \(의도적인\) 상호 작용을 합니다. 이러한 상호 작용은 거기에 설명되어 있습니다. 섹션 12.1에 설명된 절차는 비록 \[SDP-PRECON\]의 명시적인 전제 조건에 의해 제공되는 것보다 기능이 적음에도 불구하고 자체 유형의 "전제 조건"을 설명합니다.

---
### **12.5.  Interactions with Third Party Call Control**

ICE는 \[RFC3725\]에 설명된 대로 흐름 I, III 및 IV와 함께 작동합니다. Flow I은 ​​컨트롤러가 ICE를 지원하거나 인식하지 않고도 작동합니다. 흐름 IV는 컨트롤러가 변경 없이 ICE 속성을 전달하는 한 작동합니다. Flow II는 기본적으로 ICE와 호환되지 않습니다. 각 에이전트는 자신이 응답자라고 믿으므로 결코 re-INVITE를 생성하지 않습니다.

RFC 3725의 섹션 7에 설명된 대로 지속적인 작업 흐름을 지원하려면 ICE 구현의 추가 동작이 필요합니다. 특히 에이전트가 제안이 포함되지 않은 중간 대화 re-INVITE를 수신하는 경우 각 미디어 스트림에 대해 ICE를 다시 시작하고 새로운 후보자를 수집하는 프로세스를 거쳐야 합니다. 또한 해당 후보자 목록에는 현재 미디어에 사용되는 후보자가 포함되어야 합니다.\(MUST, SHOULD\)

---
## **13.  Relationship with ANAT**

SDP 그룹화 프레임워크에 대한 ANAT\(Alternative Network Address Types\) 의미 체계인 RFC 4091 \[RFC4091\] 및 SIP와 함께 사용되는 RFC 4092 \[RFC4092\]는 에이전트가 미디어에 대해 IPv4 및 IPv6를 모두 지원할 수 있음을 나타내는 메커니즘을 정의합니다. 2개의 m 라인\(v4용 하나, v6용 하나\)을 포함하여 이를 수행합니다. 이는 에이전트가 후보 속성을 사용하여 여러 전송 주소를 표시할 수 있도록 하는 ICE와 유사합니다. 그러나 ANAT는 ICE에서 사용하는 동적 연결 확인보다는 정적 선택을 사용하여 선택 사항을 선택합니다.

이 사양은 RFC 4091 및 RFC 4092를 더 이상 사용하지 않습니다. 대신 듀얼 스택을 지원하려는 에이전트는 ICE를 활용합니다.

---
## **14.  Extensibility Considerations**

이 사양은 미디어용으로 선택된 후보 쌍 집합에 도달하기 위해 세션의 두 에이전트가 어떻게 조정되는지에 대해 매우 구체적인 선택을 합니다. 타이머 조정과 같은 단순한 변경이든 우선 순위 알고리즘 개편과 같은 대규모 변경이든 향후 사양에서는 이러한 알고리즘을 변경하려고 할 것으로 예상됩니다. 이러한 변경이 이루어지면 세션의 두 에이전트 간에 상호 운용성을 제공하는 것이 중요합니다.

첫째, ICE는 a=ice-options SDP 속성을 제공합니다. ICE에 대한 각 확장 또는 변경 사항은 토큰과 연결됩니다. 그러한 확장이나 변경을 지원하는 에이전트가 제안이나 답변을 생성할 때 이 속성에 해당 확장에 대한 토큰을 포함해야 합니다. 이를 통해 양측은 상대방이 무엇을 하고 있는지 알 수 있습니다. 에이전트가 ICE 확장이나 변경 사항을 지원하지 않는 경우 이 속성이 존재해서는 안 됩니다.\(MUST, MUST NOT\)

현재 이러한 옵션 태그에 대해 IANA 레지스트리 또는 등록 절차가 정의되어 있지 않습니다. 이 글을 쓰는 시점에서는 ICE 변경 및 확장이 등록을 보장할 만큼 충분히 일반적인지 여부가 불분명합니다.

상호 운용성을 달성하는 과정에서 발생하는 복잡한 문제 중 하나는 ICE가 합의된 후보 쌍 집합에 수렴하기 위해 두 에이전트에서 실행되는 분산 알고리즘에 의존한다는 것입니다. 두 에이전트가 서로 다른 알고리즘을 실행하는 경우 동일한 후보 쌍에 대한 수렴을 보장하기 어려울 수 있습니다. 섹션 8에 설명된 정규 지명 절차는 선택 알고리즘을 완전히 제어 에이전트에 위임함으로써 일부 엄격한 조정을 제거합니다. 결과적으로, 제어 에이전트가 자신이 알지 못하는 옵션을 지원하는 피어와 통신할 때 에이전트는 정기적인 지명 알고리즘을 실행해야 합니다. 정규 지명을 사용하면 두 에이전트가 서로 다른 쌍 우선 순위 알고리즘을 사용하더라도 ICE는 완벽하게 수렴됩니다. 이러한 수렴의 핵심 중 하나는 지정된 쌍이 두 에이전트 모두에 의해 검증되었는지 확인하는 트리거된 검사입니다. 결과적으로 향후 ICE 개선 사항은 트리거된 검사를 유지해야 합니다.\(MUST, MUST\)

ICE는 RTP 이상의 다른 미디어 스트림과 UDP 이상의 전송 프로토콜로 확장 가능합니다. 비RTP 미디어 스트림을 위한 ICE 확장은 사용하는 구성 요소 수를 지정하고 가장 중요한 구성 요소 ID에 대해 1부터 시작하여 구성 요소 ID를 할당해야 합니다. 새로운 전송 프로토콜에 대한 사양은 ICE 처리의 다양한 단계가 UDP와 어떻게 다른지 정의해야 합니다.

---
## **15.  Grammar**

이 사양은 "candidate", "remote-candidates", "ice-lite", "ice-mismatch", "ice-ufrag", "ice-pwd" 및 "ice-options" 등 7개의 새로운 SDP 속성을 정의합니다. 속성.

---
### **15.1.  "candidate" Attribute**

후보 속성은 미디어 수준 속성뿐입니다. 여기에는 연결 확인에 사용할 수 있는 후보의 전송 주소가 포함되어 있습니다.

이 속성의 구문은 RFC 5234 \[RFC5234\]에 정의된 대로 Augmented BNF를 사용하여 정의됩니다.

```text
   candidate-attribute   = "candidate" ":" foundation SP component-id SP
                           transport SP
                           priority SP
                           connection-address SP     ;from RFC 4566
                           port         ;port from RFC 4566
                           SP cand-type
                           [SP rel-addr]
                           [SP rel-port]
                           *(SP extension-att-name SP
                                extension-att-value)

   foundation            = 1*32ice-char
   component-id          = 1*5DIGIT
   transport             = "UDP" / transport-extension
   transport-extension   = token              ; from RFC 3261
   priority              = 1*10DIGIT
   cand-type             = "typ" SP candidate-types
   candidate-types       = "host" / "srflx" / "prflx" / "relay" / token
   rel-addr              = "raddr" SP connection-address
   rel-port              = "rport" SP port
   extension-att-name    = byte-string    ;from RFC 4566
   extension-att-value   = byte-string
   ice-char              = ALPHA / DIGIT / "+" / "/"
```

이 문법은 후보에 대한 기본 정보\(IP 주소, 포트 및 전송 프로토콜\)와 해당 속성\(기본, 구성 요소 ID, 우선 순위, 유형 및 관련 전송 주소\)을 인코딩합니다.

<연결 주소\>: RFC 4566 \[RFC4566\]에서 가져왔습니다. 이는 IPv4 주소, IPv6 주소 및 FQDN\(정규화된 도메인 이름\)을 허용하는 후보의 IP 주소입니다. 에이전트는 이 필드를 구문 분석할 때 IPv4 주소와 IPv6 주소를 구별할 수 있습니다.

- 값에 콜론이 있으면 주소를 지정합니다. - 콜론이 있으면 IPv6을 나타냅니다. 에이전트는 지원되거나 인식되지 않는 IP 주소 버전의 후보를 포함하는 후보 라인을 무시해야 합니다. IP 주소를 사용해야 하지만 IP 주소 대신 FQDN을 사용할 수도 있습니다. 이 경우 a=candidate 속성에 FQDN이 포함된 제안이나 답변을 받으면 먼저 AAAA 레코드를 사용하여 DNS에서 FQDN을 조회합니다\(에이전트가 IPv6를 지원한다고 가정\). 결과가 없거나 에이전트가 A를 사용하여 IPv4만 지원합니다. DNS 쿼리가 둘 이상의 IP 주소를 반환하는 경우 하나가 선택되어 나머지 ICE 처리에 사용됩니다.\(MUST, SHOULD\)

<port\>: RFC 4566 \[RFC4566\]에서도 따왔습니다. 후보자의 항구입니다.

<transport\>: 후보자의 전송 프로토콜을 나타냅니다. 이 사양은 UDP만 정의합니다. 그러나 TCP 또는 데이터그램 혼잡 제어 프로토콜\(DCCP\) \[RFC4340\]과 같은 향후 전송 프로토콜을 ICE와 함께 사용할 수 있도록 확장성이 제공됩니다.

<foundation\> : 1\~32개의 <ice-char\>로 구성된다. 이것은

- 동일한 유형이고, 동일한 베이스를 공유하며, 동일한 STUN 서버에서 온 두 후보에 대해 동등한 식별자입니다. 기반은 Frozen 알고리즘에서 ICE 성능을 최적화하는 데 사용됩니다.

<comComponent-id\>: 후보인 미디어 스트림의 특정 구성 요소를 식별하는 1에서 256 사이의 양의 정수입니다. 이는 1부터 시작해야 하며 특정 후보의 각 구성 요소에 대해 1씩 증가해야 합니다. RTP 기반 미디어 스트림의 경우 실제 RTP 미디어 후보는 구성 요소 ID 1을 가져야 하며 RTCP 후보는 구성 요소 ID 2를 가져야 합니다. 여러 구성 요소가 필요한 다른 유형의 미디어 스트림은 매핑을 정의하는 사양을 개발해야 합니다. 구성 요소를 구성 요소 ID로 변경합니다. ICE를 새로운 미디어 스트림으로 확장하는 방법에 대한 추가 논의는 섹션 14를 참조하세요.\(MUST, MUST, MUST\)

<우선순위\>: 1과 \(2\*\*31 - 1\) 사이의 양의 정수입니다.

<cand-type\>: 후보 유형을 인코딩합니다. 이 사양은 호스트, 서버 반사, 피어 반사 및 릴레이된 후보에 대해 각각 "host", "srflx", "prflx" 및 "relay" 값을 정의합니다. 후보 유형 세트는 향후 확장 가능합니다.

<rel-addr\> 및 <rel-port\>: 후보와 관련된 전송 주소를 전달하며 진단 및 기타 목적에 유용합니다. <rel-addr\> 및 <rel-port\>는 서버 반사, 피어 반사 및 릴레이 후보에 대해 있어야 합니다. 후보가 서버 또는 피어 반사적이면 <rel-addr\> 및 <rel-port\>는 해당 서버 또는 피어 반사적 후보의 기본과 동일합니다. 후보가 릴레이되는 경우 <rel-addr\> 및 <rel-port\>는 클라이언트에 릴레이된 후보를 제공한 Allocate 응답의 매핑된 주소와 동일합니다\(목적에 대한 설명은 부록 B.3 참조\). 후보가 호스트 후보인 경우 <rel-addr\> 및 <rel-port\>를 생략해야 합니다.\(MUST, MUST\)

후보 속성 자체를 확장할 수 있습니다. 문법을 사용하면 속성 끝에 새 이름/값 쌍을 추가할 수 있습니다. 구현은 이해하지 못하는 이름/값 쌍을 무시해야 합니다.\(MUST\)

---
### **15.2.  "remote-candidates" Attribute**

"remote-candidates" 속성의 구문은 RFC 5234 \[RFC5234\]에 정의된 대로 Augmented BNF를 사용하여 정의됩니다. 원격 후보 속성은 미디어 수준 속성뿐입니다.

```text
   remote-candidate-att = "remote-candidates" ":" remote-candidate
                           0*(SP remote-candidate)
   remote-candidate = component-ID SP connection-address SP port
```

속성에는 각 구성 요소에 대한 연결 주소와 포트가 포함됩니다. 구성 요소의 순서는 중요하지 않습니다. 그러나 미디어 스트림의 각 구성 요소에는 값이 있어야 합니다. 이 속성은 완료된 미디어 스트림에 대한 제어 에이전트의 제안에 포함되어야 하며 다른 경우에는 포함되어서는 안 됩니다.\(MUST, MUST NOT\)

---
### **15.3.  "ice-lite" and "ice-mismatch" Attributes**

둘 다 플래그인 "ice-lite" 및 "ice-mismatch" 속성의 구문은 다음과 같습니다.

```text
   ice-lite               = "ice-lite"
   ice-mismatch           = "ice-mismatch"
```

"ice-lite"는 세션 수준 속성일 뿐이며 에이전트가 라이트 구현임을 나타냅니다. "ice-mismatch"는 미디어 수준 속성일 뿐이며 답변에 있는 경우 해당 후보 속성이 없는 미디어 구성 요소에 대한 기본 대상과 함께 제안이 도착했음을 나타냅니다.

---
### **15.4.  "ice-ufrag" and "ice-pwd" Attributes**

"ice-ufrag" 및 "ice-pwd" 속성은 메시지 무결성을 위해 ICE에서 사용하는 사용자 이름 조각과 비밀번호를 전달합니다. 해당 구문은 다음과 같습니다.

```text
   ice-pwd-att           = "ice-pwd" ":" password
   ice-ufrag-att         = "ice-ufrag" ":" ufrag
   password              = 22*256ice-char
   ufrag                 = 4*256ice-char
```

"ice-pwd" 및 "ice-ufrag" 속성은 세션 수준이나 미디어 수준에서 나타날 수 있습니다. 둘 다에 존재할 경우 미디어 수준의 값이 우선합니다. 따라서 세션 수준의 값은 미디어 수준 값으로 재정의되지 않는 한 사실상 모든 미디어 스트림에 적용되는 기본값입니다. 세션 또는 미디어 수준에 존재하든 각 미디어 스트림에는 ice-pwd 및 ice-ufrag 속성이 있어야 합니다. 두 개의 미디어 스트림에 동일한 ice-ufrag가 있는 경우 동일한 ice-pwd가 있어야 합니다.\(MUST, MUST\)

ice-ufrag 및 ice-pwd 속성은 세션 시작 시 무작위로 선택되어야 합니다. ice-ufrag 속성은 최소 24비트의 임의성을 포함해야 하며, ice-pwd 속성은 최소 128비트의 임의성을 포함해야 합니다. 즉, ice-ufrag 속성의 길이는 최소 4자이고 ice-pwd의 길이는 최소 22자입니다. 이러한 속성에 대한 문법은 문자당 6비트의 임의성을 허용하기 때문입니다. 속성은 각각 4자 및 22자를 초과할 수 있으며 최대 256자까지 가능합니다. 상한은 구현 시 버퍼 크기를 허용합니다. 상한이 크면 시간이 지남에 따라 더 많은 양의 무작위성이 추가될 수 있습니다.\(MUST, MUST, MAY\)

---
### **15.5.  "ice-options" Attribute**

"ice-options" 속성은 세션 수준 속성입니다. 여기에는 에이전트가 지원하는 옵션을 식별하는 일련의 토큰이 포함되어 있습니다. 문법은 다음과 같습니다:

```text
   ice-options           = "ice-options" ":" ice-option-tag
                             0*(SP ice-option-tag)
   ice-option-tag        = 1*ice-char
```

---
## **16.  Setting Ta and RTO**

ICE 수집 단계\(섹션 4.1.1\)와 ICE가 연결 확인을 수행하는 동안\(섹션 7\) 에이전트는 STUN 및 TURN 트랜잭션을 보냅니다. 이러한 트랜잭션은 Ta 밀리초마다 1회의 속도로 진행되며 특정 RTO를 활용합니다. 이 섹션에서는 Ta 및 RTO 값을 계산하는 방법을 설명합니다. 이것

계산은 ICE가 실시간 미디어 스트림\(예: RTP\)과 함께 사용되는지 아니면 다른 것과 함께 사용되는지에 따라 달라집니다. ICE가 최대 대역폭이 알려진 스트림에 사용되는 경우 ICE 교환 속도를 제어하기 위해 섹션 16.1의 계산을 따를 수 있습니다. 다른 모든 스트림의 경우 섹션 16.2의 계산을 따라야 합니다.\(MAY, MUST\)

---
### **16.1.  RTP Media Streams**

RTO 및 Ta 값은 ICE 처리 기간 동안 변경됩니다. 한 값 집합은 수집 단계에 적용되고 다른 값 집합은 연결 확인에 적용됩니다.

Ta의 값은 구성 가능해야 하며 기본값은 다음과 같아야 합니다.\(SHOULD\)

각 미디어 스트림에 대해 다음을 수행합니다.

```text
    Ta_i = (stun_packet_size / rtp_packet_size) * rtp_ptime

                           1
     Ta = MAX (20ms, ------------------- )
                           k
                         ----
                         \        1
                          >    ------
                         /       Ta_i
                         ----
                          i=1
```

여기서 k는 미디어 스트림 수입니다. 수집 단계에서 Ta는 에이전트가 제안 또는 답변에 표시한 미디어 스트림 수를 기반으로 계산되며 RTP 패킷 크기 및 RTP ptime은 각 미디어 스트림에 가장 선호되는 코덱의 값입니다. 제안과 답변이 교환되면 에이전트는 Ta를 다시 계산하여 연결 확인 속도를 조정합니다. 이 경우 Ta의 값은 해당 세션에서 실제로 사용될 미디어 스트림의 개수를 기준으로 하며, RTP 패킷 크기와 RTP ptime은 에이전트가 전송할 가장 선호하는 코덱의 값입니다.

또한 \[RFC5389\]에 정의된 STUN 트랜잭션의 재전송 타이머 RTO는 구성 가능해야 하며 수집 단계 동안 기본값은 다음과 같아야 합니다.\(SHOULD\)

```text
     RTO = MAX (100ms, Ta * (number of pairs))
```

여기서 쌍 수는 STUN 또는 TURN 서버의 후보 쌍 수를 나타냅니다.

연결 확인을 위해 RTO는 구성 가능해야 하며 기본값은 다음과 같아야 합니다.\(SHOULD\)

```text
     RTO = MAX (100ms, Ta*N * (Num-Waiting + Num-In-Progress))
```

여기서 Num-Waiting은 대기 상태의 체크 리스트에 있는 검사 수이고 Num-In-Progress는 In-Progress 상태의 검사 수입니다. 대기 및 진행 중 상태의 확인 수가 변경됨에 따라 RTO는 각 트랜잭션마다 달라집니다.

이러한 공식은 STUN 트랜잭션이 미디어와 동일한 속도로 진행되도록 하는 것을 목표로 합니다. 이렇게 하면 ICE도 미디어를 지원하는 데 필요한 동일한 네트워크 조건에서 제대로 작동할 수 있습니다. 추가 논의 및 동기는 부록 B.1을 참조하세요. 이러한 속도로 인해 서버 반사 및 릴레이 후보를 모두 확보하는 데 일정 시간이 소요됩니다. 구현에서는 이를 수행하는 데 필요한 시간을 알고 있어야 하며, 애플리케이션에 시간 예산이 필요한 경우 수집되는 후보자 수를 제한하십시오.

수식을 사용하면 에이전트가 재전송을 수행하기 전에 모든 단일 연결 확인에 대해 첫 번째 패킷을 보내는 동작이 발생합니다. 이는 RTO\(재전송 간격을 나타냄\) 공식에서 확인할 수 있습니다. 이러한 공식은 수행할 검사 횟수인 N에 따라 확장됩니다. 결과적으로 ICE는 일정한 속도를 유지하지만 패킷 손실에 더욱 민감해집니다. 연결 확인에 대한 첫 번째 단일 패킷이 손실되면 해당 쌍을 검증하는 데 오랜 시간이 걸릴 가능성이 높으며, 대신 우선 순위가 낮은 확인\(그러나 패킷 손실이 없었던 확인\)이 훨씬 더 가능성이 높습니다. 먼저 완료하세요. 이로 인해 ICE는 차선책으로 수행되어 우선순위가 높은 쌍보다 우선순위가 낮은 쌍을 선택하게 됩니다. 구현자는 이 결과를 알고 있어야 하지만 여기에 설명된 타이머 값을 활용해야 합니다.

---
### **16.2.  Non-RTP Sessions**

ICE가 실시간이 아닌 일종의 세션을 설정하는 데 사용되고 ICE가 배포된 네트워크에서 작동하는 것으로 알려진 고정 속도가 없는 경우 Ta 및 RTO는 보다 보수적인 값으로 되돌아갑니다. Ta는 구성 가능해야 하며\(SHOULD\) 기본값은 500ms여야 하며, 500ms 미만으로 구성해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

또한 STUN 트랜잭션에 대한 재전송 타이머인 RTO는 구성 가능해야 하며 수집 단계 동안 기본값은 다음과 같아야 합니다.\(SHOULD\)

```text
     RTO = MAX (500ms, Ta * (number of pairs))
```

여기서 쌍 수는 STUN 또는 TURN 서버의 후보 쌍 수를 나타냅니다.

연결 확인을 위해 RTO는 구성 가능해야 하며 기본값은 다음과 같아야 합니다.\(SHOULD\)

```text
     RTO = MAX (500ms, Ta*N * (Num-Waiting + Num-In-Progress))
```

---
## **17.  Example**

이 예는 그림 8의 단순화된 토폴로지를 기반으로 합니다.

```text
                             +-----+
                             |     |
                             |STUN |
                             | Srvr|
                             +-----+
                                |
                     +---------------------+
                     |                     |
                     |      Internet       |
                     |                     |
                     |                     |
                     +---------------------+
                       |                |
                       |                |
                +---------+             |
                |  NAT    |             |
                +---------+             |
                     |                  |
                     |                  |
                     |                  |
                  +-----+            +-----+
                  |     |            |     |
                  |  L  |            |  R  |
                  |     |            |     |
                  +-----+            +-----+

                        Figure 8: Example Topology
```

L, R 두 에이전트가 ICE를 사용하고 있습니다. 둘 다 풀 모드 ICE 구현이며 제어할 때 공격적인 지정을 사용합니다. 두 에이전트 모두 단일 IPv4 주소를 갖습니다. 에이전트 L의 경우 개인 주소 공간\[RFC1918\]에서는 10.0.1.1이고, 에이전트 R의 경우 공용 인터넷에서는 192.0.2.1입니다. 둘 다 동일한 STUN 서버로 구성됩니다\(단순화를 위해 이 예에 표시되어 있지만

실제로 에이전트는 IP 주소 192.0.2.2 및 포트 3478에서 STUN 바인딩 요청을 수신하는 동일한 STUN 서버를 사용할 필요가 없습니다. 이 예에서는 TURN 서버가 사용되지 않습니다. 에이전트 L은 NAT 뒤에 있고 에이전트 R은 공용 인터넷에 있습니다. NAT에는 엔드포인트 독립적 매핑 속성과 주소 종속 필터링 속성이 있습니다. NAT의 공개 측 IP 주소는 192.0.2.3입니다.

이해를 돕기 위해 전송 주소는 니모닉 이름이 있는 변수를 사용하여 나열됩니다. 이름의 형식은 엔터티-유형-seqno입니다. 여기서 엔터티는 전송 주소가 있는 IP 주소의 엔터티를 나타내며 "L", "R", "STUN" 또는 "NAT" 중 하나입니다. 유형은 공개 전송 주소의 경우 "PUB"이고 비공개 전송 주소의 경우 "PRIV"입니다. 마지막으로 seq-no는 특정 엔터티에서 동일한 유형의 각 전송 주소마다 다른 시퀀스 번호입니다. 각 변수에는 각각 varname.IP 및 varname.PORT로 표시되는 IP 주소와 포트가 있습니다. 여기서 varname은 변수의 이름입니다.

STUN 서버는 전송 주소 STUN-PUB-1\(192.0.2.2:3478\)을 광고했습니다.

호출 흐름 자체에서 STUN 메시지에는 여러 속성이 주석으로 추가됩니다. "S=" 속성은 메시지의 소스 전송 주소를 나타냅니다. "D=" 속성은 메시지의 대상 전송 주소를 나타냅니다. "MA=" 속성은 STUN 바인딩 응답 메시지에 사용되며 매핑된 주소를 나타냅니다. "USE-CAND"는 USE-CANDIDATE 속성이 있음을 의미합니다.

호출 흐름 예에서는 STUN 인증 작업과 RTCP를 생략하고 두 가지 전체 구현 간의 단일 미디어 스트림에 대한 RTP에 중점을 둡니다.

```text
             L             NAT           STUN             R
             |RTP STUN alloc.              |              |
             |(1) STUN Req  |              |              |
             |S=$L-PRIV-1   |              |              |
             |D=$STUN-PUB-1 |              |              |
             |------------->|              |              |
             |              |(2) STUN Req  |              |
             |              |S=$NAT-PUB-1  |              |
             |              |D=$STUN-PUB-1 |              |
             |              |------------->|              |

             |              |(3) STUN Res  |              |
             |              |S=$STUN-PUB-1 |              |
             |              |D=$NAT-PUB-1  |              |
             |              |MA=$NAT-PUB-1 |              |
             |              |<-------------|              |
             |(4) STUN Res  |              |              |
             |S=$STUN-PUB-1 |              |              |
             |D=$L-PRIV-1   |              |              |
             |MA=$NAT-PUB-1 |              |              |
             |<-------------|              |              |
             |(5) Offer     |              |              |
             |------------------------------------------->|
             |              |              |              |RTP STUN
             alloc.
             |              |              |(6) STUN Req  |
             |              |              |S=$R-PUB-1    |
             |              |              |D=$STUN-PUB-1 |
             |              |              |<-------------|
             |              |              |(7) STUN Res  |
             |              |              |S=$STUN-PUB-1 |
             |              |              |D=$R-PUB-1    |
             |              |              |MA=$R-PUB-1   |
             |              |              |------------->|
             |(8) answer    |              |              |
             |<-------------------------------------------|
             |              |(9) Bind Req  |              |Begin
             |              |S=$R-PUB-1    |              |Connectivity
             |              |D=L-PRIV-1    |              |Checks
             |              |<----------------------------|
             |              |Dropped       |              |
             |(10) Bind Req |              |              |
             |S=$L-PRIV-1   |              |              |
             |D=$R-PUB-1    |              |              |
             |USE-CAND      |              |              |
             |------------->|              |              |
             |              |(11) Bind Req |              |
             |              |S=$NAT-PUB-1  |              |
             |              |D=$R-PUB-1    |              |
             |              |USE-CAND      |              |
             |              |---------------------------->|
             |              |(12) Bind Res |              |
             |              |S=$R-PUB-1    |              |
             |              |D=$NAT-PUB-1  |              |
             |              |MA=$NAT-PUB-1 |              |
             |              |<----------------------------|

             |(13) Bind Res |              |              |
             |S=$R-PUB-1    |              |              |
             |D=$L-PRIV-1   |              |              |
             |MA=$NAT-PUB-1 |              |              |
             |<-------------|              |              |
             |RTP flows     |              |              |
             |              |(14) Bind Req |              |
             |              |S=$R-PUB-1    |              |
             |              |D=$NAT-PUB-1  |              |
             |              |<----------------------------|
             |(15) Bind Req |              |              |
             |S=$R-PUB-1    |              |              |
             |D=$L-PRIV-1   |              |              |
             |<-------------|              |              |
             |(16) Bind Res |              |              |
             |S=$L-PRIV-1   |              |              |
             |D=$R-PUB-1    |              |              |
             |MA=$R-PUB-1   |              |              |
             |------------->|              |              |
             |              |(17) Bind Res |              |
             |              |S=$NAT-PUB-1  |              |
             |              |D=$R-PUB-1    |              |
             |              |MA=$R-PUB-1   |              |
             |              |---------------------------->|
             |              |              |              |RTP flows

                          Figure 9: Example Flow
```

먼저, 에이전트 L은 로컬 IP 주소\(표시되지 않음\)로부터 호스트 후보를 획득하고, 그것으로부터 STUN 바인딩 요청을 STUN 서버에 전송하여 서버 반사 후보를 획득합니다\(메시지 1-4\). NAT에는 주소와 포트 독립적인 매핑 속성이 있다는 점을 기억하세요. 여기서는 이 UDP 요청에 대한 NAT-PUB-1 바인딩을 생성하고 이것이 RTP에 대한 서버 반사 후보가 됩니다.

에이전트 L은 호스트 후보에 대해 126, 서버 반사에 대해 100의 유형 기본 설정을 설정합니다. 로컬 선호도는 65535이다. 이를 바탕으로 호스트 후보의 우선순위는 2130706431이고, 서버 반사 후보의 우선순위는 1694498815이다. 호스트 후보에는 파운데이션 1, 서버 반사적 후보에는 2의 우선순위가 할당된다. 서버 반사 후보를 기본 후보로 지정하고 이를 m 및 c 라인으로 인코딩합니다. 결과 제안\(메시지 5\)은 다음과 같습니다\(명확성을 위해 선을 접었습니다\).

```text
       v=0
       o=jdoe 2890844526 2890842807 IN IP4 $L-PRIV-1.IP
       s=
       c=IN IP4 $NAT-PUB-1.IP
       t=0 0
       a=ice-pwd:asd88fgpdd777uzjYhagZg
       a=ice-ufrag:8hhY
       m=audio $NAT-PUB-1.PORT RTP/AVP 0
       b=RS:0
       b=RR:0
       a=rtpmap:0 PCMU/8000
       a=candidate:1 1 UDP 2130706431 $L-PRIV-1.IP $L-PRIV-1.PORT typ
       host
       a=candidate:2 1 UDP 1694498815 $NAT-PUB-1.IP $NAT-PUB-1.PORT typ
        srflx raddr $L-PRIV-1.IP rport $L-PRIV-1.PORT
```

변수가 해당 값으로 대체된 제안은 다음과 같습니다\(명확성을 위해 선을 접었습니다\).

```text
       v=0
       o=jdoe 2890844526 2890842807 IN IP4 10.0.1.1
       s=
       c=IN IP4 192.0.2.3
       t=0 0
       a=ice-pwd:asd88fgpdd777uzjYhagZg
       a=ice-ufrag:8hhY
       m=audio 45664 RTP/AVP 0
       b=RS:0
       b=RR:0
       a=rtpmap:0 PCMU/8000
       a=candidate:1 1 UDP 2130706431 10.0.1.1 8998 typ host
       a=candidate:2 1 UDP 1694498815 192.0.2.3 45664 typ srflx raddr
   10.0.1.1 rport 8998
```

이 제안은 에이전트 R에서 수신됩니다. 에이전트 R은 호스트 후보를 획득하고, 이로부터 서버 반사 후보를 획득합니다\(메시지 6-7\). R은 NAT 뒤에 있지 않기 때문에 이 후보는 호스트 후보와 동일하며 동일한 기반을 공유합니다. 따라서 이 중복 후보를 삭제하고 단일 호스트 후보로 끝납니다. L과 동일한 유형 및 로컬 선호도를 갖는 이 후보의 우선순위는 2130706431입니다. 단일 후보에 대해 1의 기반을 선택합니다. 결과 답변은 다음과 같습니다.

```text
       v=0
       o=bob 2808844564 2808844564 IN IP4 $R-PUB-1.IP
       s=
       c=IN IP4 $R-PUB-1.IP
       t=0 0
       a=ice-pwd:YH75Fviy6338Vbrhrlp8Yh
       a=ice-ufrag:9uB6
       m=audio $R-PUB-1.PORT RTP/AVP 0
       b=RS:0
       b=RR:0
       a=rtpmap:0 PCMU/8000
       a=candidate:1 1 UDP 2130706431 $R-PUB-1.IP $R-PUB-1.PORT typ host
```

변수가 채워진 상태에서:

```text
       v=0
       o=bob 2808844564 2808844564 IN IP4 192.0.2.1
       s=
       c=IN IP4 192.0.2.1
       t=0 0
       a=ice-pwd:YH75Fviy6338Vbrhrlp8Yh
       a=ice-ufrag:9uB6
       m=audio 3478 RTP/AVP 0
       b=RS:0
       b=RR:0
       a=rtpmap:0 PCMU/8000
       a=candidate:1 1 UDP 2130706431 192.0.2.1 3478 typ host
```

어느 쪽도 라이트라고 표시하지 않았기 때문에 ICE 처리를 시작한 제안을 보낸 에이전트\(에이전트 L\)가 제어 에이전트가 됩니다.

에이전트 L과 R은 모두 후보를 쌍으로 만듭니다. 둘 다 처음에는 두 쌍이 있습니다. 그러나 에이전트 L은 서버 반사 후보를 포함하는 쌍을 잘라내어 하나만 생성합니다. 에이전트 L에서 이 쌍은 $L\_PRIV\_1의 로컬 후보와 $R\_PUB\_1의 원격 후보를 가지며 후보 쌍 우선순위는 4.57566E+18입니다\(구현에서는 이를 잃지 않도록 64비트 정수로 나타냅니다\). 정도\). 에이전트 R에는 두 쌍이 있습니다. 가장 높은 우선순위는 로컬 후보 $R\_PUB\_1, 원격 후보 $L\_PRIV\_1, 우선순위 4.57566E+18을 가지며, 두 번째 우선순위는 로컬 후보 $R\_PUB\_1, 원격 후보 $NAT\_PUB\_1, 우선순위 3.63891E+18을 갖습니다.

에이전트 R은 첫 번째 쌍\(두 호스트 후보 간\)에 대한 연결 확인\(메시지 9\)을 시작합니다. R은 이 세션의 제어되는 에이전트이므로 검사에서 USE-CANDIDATE 속성이 생략됩니다. 그만큼

에이전트 L의 호스트 후보는 비공개이고 NAT 뒤에 있으므로 패킷이 R에서 L로 라우팅될 수 없기 때문에 이 검사는 성공하지 못합니다.

에이전트 L이 응답을 받으면 유일한 연결 확인을 수행합니다\(메시지 10-13\). 이는 공격적인 지명 알고리즘을 구현하므로 이 검사에 USE-CANDIDATE 속성이 포함됩니다. 검사가 성공했으므로 에이전트 L은 로컬 후보가 바인딩 응답\(메시지 13의 NAT-PUB-1\)에 매핑된 주소이고 원격 후보가 요청 대상\(R-PUB-1\)인 새 쌍을 생성합니다. 메시지 10에서\). 이는 유효한 목록에 추가됩니다. 또한 바인딩 요청에 USE-CANDIDATE 속성이 포함되어 있으므로 선택된 것으로 표시됩니다. 이 미디어 스트림의 한 구성 요소에 대해 유효한 목록에 선택된 후보가 있으므로 이 스트림에 대한 ICE 처리는 완료됨 상태로 이동합니다. 이제 에이전트 L은 원하는 경우 미디어를 보낼 수 있습니다.

에이전트 L\(메시지 11\)로부터 STUN 바인딩 요청을 수신한 직후 에이전트 R은 트리거된 확인을 생성합니다. 이 검사는 호스트 후보부터 에이전트 L의 서버 반사 후보까지 검사 목록의 다음 항목과 일치합니다. 이 확인\(메시지 14-17\)은 성공합니다. 결과적으로 에이전트 R은 응답의 매핑된 주소를 로컬 후보\(R-PUB-1\)로 사용하고 요청 대상\(NAT-PUB-1\)을 원격 후보로 사용하여 새로운 후보 쌍을 구성합니다. 이 쌍은 해당 미디어 스트림의 유효한 목록에 추가됩니다. USE-CANDIDATE 속성이 포함된 검사의 반대 방향으로 검사가 생성되었으므로 후보 쌍이 선택된 것으로 표시됩니다. 결과적으로 이 스트림에 대한 처리는 Completed 상태로 이동하고 에이전트 R도 미디어를 보낼 수 있습니다.

---
## **18.  Security Considerations**

ICE 시스템에는 여러 유형의 공격이 가능합니다. 이 섹션에서는 이러한 공격과 그에 대한 대응책을 고려합니다. 이러한 대책에는 다음이 포함됩니다.

o SIPS와 같은 보안 신호 기술과 함께 ICE를 사용합니다.

o 총 연결 확인 수를 100으로 제한하고 선택적으로 제안이나 답변에서 수락할 후보자 수를 제한합니다.

---
### **18.1.  Attacks on Connectivity Checks**

공격자는 STUN 연결 확인을 방해하려고 시도할 수 있습니다. 궁극적으로 이러한 모든 공격은 에이전트가 연결 확인 결과에 대해 잘못된 것을 생각하도록 속입니다. 공격자가 시도하여 야기할 수 있는 잘못된 결론은 다음과 같습니다.

거짓 무효: 공격자는 에이전트 쌍이 유효하지 않은 후보 쌍이 유효하지 않다고 생각하도록 속일 수 있습니다. 이는 에이전트가 다른 후보\(예: 공격자가 삽입한 후보\)를 선호하도록 하거나 모든 후보를 실패하게 하여 통화를 방해하는 데 사용될 수 있습니다.

거짓 유효: 공격자는 에이전트 쌍이 유효하지 않은 후보 쌍이 유효하다고 생각하도록 속일 수 있습니다. 이로 인해 상담원이 세션을 진행하지만 미디어를 수신할 수 없게 될 수 있습니다.

거짓 피어 반사 후보: 공격자는 에이전트가 발견해서는 안 되는 새로운 피어 반사 후보를 발견하도록 만들 수 있습니다. 이는 도청 또는 기타 목적으로 미디어 스트림을 서비스 거부\(DoS\) 대상이나 공격자에게 리디렉션하는 데 사용될 수 있습니다.

거짓 후보에 대한 거짓 유효: 공격자는 이미 에이전트에게 실제로 해당 에이전트로 라우팅되지 않는 주소를 가진 후보가 있다고 확신했습니다\(예: 거짓 피어 반사 후보 또는 거짓 서버 반사 후보 삽입\). 그런 다음 에이전트가 이 후보가 유효하다고 믿도록 강제하는 공격을 시작해야 합니다.

- 공격자가 거짓 피어 반사 후보 또는 거짓 후보에 대해 거짓 유효를 유발할 수 있는 경우 \[RFC5389\]에 설명된 공격을 시작할 수 있습니다.

잘못된 잘못된 결과를 강제로 적용하려면 공격자는 에이전트 중 하나에서 연결 확인이 전송될 때까지 기다려야 합니다. 그럴 경우 공격자는 400과 같은 복구할 수 없는 오류 응답과 함께 가짜 응답을 주입해야 합니다. 그러나 후보가 실제로 유효하므로 원래 요청이 피어 에이전트에 도달하여 성공 응답이 나올 수 있습니다. . 공격자는 DoS 공격, 레이어 2 네트워크 중단 또는 기타 기술을 통해 이 패킷이나 해당 응답을 강제로 삭제해야 합니다. 이렇게 하지 않으면 성공 응답도 발신자에게 전달되어 공격 가능성에 대해 경고합니다. 다행스럽게도 이 공격은 STUN 단기 자격 증명 메커니즘을 통해 완전히 완화됩니다. 공격자는 가짜 응답을 주입해야 하며, 이 응답을 처리하려면 공격자에게 비밀번호가 필요합니다. 제안/답변인 경우

신호가 보호되면 공격자는 비밀번호를 알 수 없으며 해당 응답은 삭제됩니다.

가짜 유효한 결과를 강제하는 것도 비슷한 방식으로 작동합니다. 에이전트는 각 에이전트의 바인딩 요청을 기다리고 가짜 성공 응답을 삽입해야 합니다. 공격자는 후보가 유효하지 않으면 어쨌든 수신되지 않을 것이므로 실제 응답을 방해하는 것에 대해 걱정할 필요가 없습니다. 그러나 가짜 유효하지 않은 공격과 마찬가지로 이 공격은 안전한 제안/답변 교환과 함께 STUN 단기 자격 증명 메커니즘에 의해 완화됩니다.

거짓 피어 반사 후보 결과를 강제하는 것은 가짜 요청이나 응답 또는 재생을 통해 수행될 수 있습니다. 가짜 요청 및 응답 사례를 먼저 고려합니다. 이를 위해서는 공격자가 잘못된 후보에 대한 소스 IP 주소와 포트를 사용하여 하나의 에이전트에 바인딩 요청을 보내야 합니다. 또한 공격자는 다른 에이전트의 바인딩 요청을 기다려야 하며 잘못된 후보가 포함된 XOR-MAPPED-ADDRESS 속성을 사용하여 가짜 응답을 생성해야 합니다. 여기에 설명된 다른 공격과 마찬가지로 이 공격은 STUN 메시지 무결성 메커니즘과 안전한 제안/응답 교환을 통해 완화됩니다.

패킷 재생을 통해 잘못된 피어 반사 후보 결과를 강제하는 것은 다릅니다. 공격자는 에이전트 중 하나가 수표를 보낼 때까지 기다립니다. 이 요청을 가로채서 위조된 소스 IP 주소를 사용하여 다른 에이전트를 향해 재생합니다. 또한 DoS 공격을 시작하여 패킷을 삭제하거나 계층 2 메커니즘을 사용하여 강제로 삭제함으로써 원래 요청이 원격 에이전트에 도달하는 것을 방지해야 합니다. 재생된 패킷은 다른 에이전트에서 수신되고 무결성 검사가 통과되었으므로 허용됩니다\(무결성 검사는 소스 IP 주소 및 포트를 포함할 수 없으며 포함하지 않습니다\). 그런 다음 응답됩니다. 이 응답에는 잘못된 후보와 함께 XOR-MAPPED-ADDRESS가 포함되며 해당 잘못된 후보에게 전송됩니다. 그런 다음 공격자는 이를 수신하여 발신자에게 전달해야 합니다.

그런 다음 다른 에이전트는 해당 잘못된 후보에 대한 연결 확인을 시작합니다. 이 유효성 검사는 성공해야 합니다. 이를 위해서는 공격자가 잘못된 후보에 대해 잘못된 유효성을 강제해야 합니다. 이 목표를 달성하기 위해 가짜 요청이나 응답을 주입하는 것은 STUN의 무결성 메커니즘과 제안/응답 교환을 사용하여 방지됩니다. 따라서 이 공격은 리플레이를 통해서만 실행될 수 있습니다. 이를 위해 공격자는 이 잘못된 후보에 대한 확인을 가로채서 다른 에이전트를 향해 재생해야 합니다. 그런 다음 응답을 가로채서 다시 재생해야 합니다.

이 공격은 공격자가 가짜 후보로 식별되지 않는 한 시작하기가 매우 어렵습니다. 이는 공격자가 서로 다른 두 호스트에서 보낸 패킷을 가로채서 재생해야 하기 때문입니다. 두 에이전트가 서로 다른 네트워크\(예: 공용 인터넷\)에 있는 경우 이 공격은 네트워크의 서로 다른 부분에 있는 서로 다른 두 엔드포인트에 대해 동시에 발생해야 하므로 조정하기 어려울 수 있습니다.

공격자 자신이 가짜 후보로 식별되면 공격 조율이 더 쉬워진다. 그러나 SRTP가 \[RFC3711\] 사용되는 경우 공격자는 미디어 패킷을 재생할 수 없고 폐기만 할 수 있어 통화에 대한 미디어 스트림을 효과적으로 비활성화할 수 있습니다. 그러나 이 공격에서는 연결 확인이 대상에 도달하는 것을 차단하기 위해 에이전트가 패킷을 중단해야 합니다. 이 경우 목표가 미디어 스트림을 방해하는 것이라면 ICE를 공격하는 것보다 동일한 메커니즘으로 미디어 스트림을 방해하는 것이 훨씬 쉽습니다.

---
### **18.2.  Attacks on Server Reflexive Address Gathering**

ICE 엔드포인트는 STUN 서버에서 서버 반사 후보를 수집하기 위해 STUN 바인딩 요청을 사용합니다. 이러한 요청은 어떤 방식으로도 인증되지 않습니다. 결과적으로 공격자가 클라이언트에 잘못된 서버 반사 후보를 제공하기 위해 사용할 수 있는 다양한 기술이 있습니다.

o 공격자는 DNS를 손상시켜 DNS 쿼리가 악성 STUN 서버 주소를 반환하도록 할 수 있습니다. 해당 서버는 클라이언트에게 가짜 서버 반사 후보를 제공할 수 있습니다. 이 공격은 DNS 보안에 의해 완화되지만 DNS-SEC는 이를 해결하는 데 필요하지 않습니다.

o STUN 메시지를 관찰할 수 있는 공격자\(예: WiFi와 같은 공유 네트워크 세그먼트의 공격자\)는 유효하고 클라이언트에서 수락할 가짜 응답을 주입할 수 있습니다.

o 공격자는 바이러스를 통해 STUN 서버를 손상시키고 잘못된 매핑된 주소로 응답을 보내게 할 수 있습니다.

이러한 공격으로 학습된 잘못된 매핑 주소는 ICE 교환에서 서버 반사 후보로 사용됩니다. 이 후보가 실제로 미디어에 사용되려면 공격자는 연결 검사도 공격해야 하며, 특히 잘못된 후보에 대해 거짓 유효성을 강제해야 합니다. 이 공격은 세션의 각 에이전트가 생성한 검사를 공격해야 하고 공격자를 식별하는 경우 SRTP에 의해 방지되기 때문에 잘못된 주소가 제4자\(제공자, 응답자, 공격자 모두\)를 식별하는 경우 시작하기가 매우 어렵습니다. 자신.

공격자가 연결 검사를 공격하지 않기로 선택한 경우, 공격자가 할 수 있는 최악의 방법은 서버 반사 후보가 사용되는 것을 막는 것입니다. 그러나 피어 에이전트에 공격을 받는 에이전트가 연결할 수 있는 후보가 하나 이상 있는 경우 STUN 연결 확인 자체가 미디어 교환에 사용할 수 있는 피어 반사 후보를 제공합니다. 동료 반사 후보자는 일반적으로 서버 반사 후보자보다 선호됩니다. 따라서 STUN 주소 수집에만 대한 공격은 일반적으로 세션에 전혀 영향을 미치지 않습니다.

---
### **18.3.  Attacks on Relayed Candidate Gathering**

공격자는 릴레이된 후보의 수집을 방해하여 클라이언트가 잘못된 릴레이 후보가 있다고 믿게 만들려고 시도할 수 있습니다. TURN 서버와의 교환은 장기 자격 증명을 사용하여 인증됩니다. 결과적으로 가짜 응답이나 요청을 삽입하는 것은 작동하지 않습니다. 또한 바인딩 요청과 달리 할당 요청은 수정된 소스 IP 주소 및 포트를 사용한 재생 공격에 취약하지 않습니다. 소스 IP 주소 및 포트가 클라이언트에 중계된 후보를 제공하는 데 사용되지 않기 때문입니다.

그러나 TURN 서버는 DNS 공격이나 TURN 서버를 좀비 또는 불량 서버로 전환하려는 목적으로 바이러스에 취약합니다. 이러한 공격은 DNS-SEC와 TURN 서버의 Good Box 및 소프트웨어 보안을 통해 완화될 수 있습니다.

공격자가 클라이언트가 거짓으로 릴레이된 후보를 믿게 만든 경우에도 연결 확인을 통해 해당 후보가 성공한 경우에만 사용됩니다. 따라서 공격자는 위와 같이 잘못된 후보에 대해 잘못된 유효 공격을 시작해야 하며 이는 조정하기 매우 어려운 공격입니다.

---
### **18.4.  Attacks on the Offer/Answer Exchanges**

제안/응답 교환 자체를 수정하거나 방해할 수 있는 공격자는 ICE를 사용하여 다양한 공격을 쉽게 시작할 수 있습니다. DoS 공격 대상으로 미디어를 보낼 수도 있고 미디어 스트림에 자신을 삽입할 수도 있습니다. 이는 제안/응답 교환에 대한 일반적인 보안 고려 사항과 유사하며 RFC 3264 \[RFC3264\]의 보안 고려 사항이 적용됩니다. 이를 위해서는 SIP가 사용될 때 SIPS 메커니즘\[RFC3261\]에 의해 충족되는 제안 및 답변에 대한 메시지 무결성 및 암호화 기술이 필요합니다. 따라서 ICE와 함께 SIPS를 사용하는 것이 좋습니다.\(SHOULD\)

---
### **18.5.  Insider Attacks**

공격자가 가짜 제안, 답변 또는 기절 메시지를 삽입하려는 제3자인 공격 외에도 공격자가 ICE 교환에 인증되고 유효한 참가자인 경우 ICE를 사용하여 여러 가지 공격이 가능합니다.

---
#### **18.5.1.  The Voice Hammer Attack**

보이스 해머 공격은 증폭 공격이다. 이 공격에서 공격자는 다른 에이전트에 대한 세션을 시작하고 DoS 대상의 IP 주소와 포트를 SDP에서 신호를 보내는 미디어 트래픽의 대상으로 악의적으로 포함합니다. 이로 인해 상당한 증폭이 발생합니다. 단일 제안/답변 교환으로 인해 높은 속도로 계속해서 미디어 패킷의 홍수가 발생할 수 있습니다\(비디오 소스 고려\). 이 공격은 ICE에만 국한되지 않지만 ICE는 치료를 제공하는 데 도움이 될 수 있습니다.

특히 ICE가 사용되는 경우 악성 SDP를 수신하는 에이전트는 미디어를 전송하기 전에 먼저 미디어 대상에 대한 연결 확인을 수행합니다. 이 대상이 타사 호스트인 경우 검사가 성공하지 못하고 미디어가 전송되지 않습니다.

안타깝게도 ICE를 사용하지 않으면 도움이 되지 않습니다. 이 경우 공격자는 ICE 매개변수 없이 제안을 보낼 수 있습니다. 그러나 클라이언트 집합이 알려져 있고 ICE를 지원하는 클라이언트로 제한되는 환경에서는 서버가 ICE 지원을 나타내지 않는 제안이나 응답을 거부할 수 있습니다.

---
#### **18.5.2.  STUN Amplification Attack**

STUN 증폭 공격은 보이스 해머와 유사합니다. 그러나 음성 패킷이 대상으로 전달되는 대신 STUN 연결 확인이 대상으로 전달됩니다. 공격자는 예를 들어 50명과 같이 많은 수의 후보가 포함된 제안을 보냅니다. 응답자는 제안을 받고 대상을 향한 검사를 시작하므로 결과적으로 응답이 생성되지 않습니다. 응답자는 Ta ms\(예: Ta=20ms\)마다 새로운 연결 확인을 시작합니다. 다만, 후보 수가 많아 재전송 타이머를 크게 설정한다. 결과적으로 패킷은 Ta 밀리초마다 1개의 간격으로 전송되고 그 이후에는 간격이 증가합니다. 따라서 STUN은 미디어가 전송되는 것보다 빠른 속도로 패킷을 전송하지 않으며 STUN 패킷은 ICE가 세션에 실패할 때까지 잠시 동안만 지속됩니다. 그럼에도 불구하고 이는 증폭 메커니즘입니다.

증폭을 제거하는 것은 불가능하지만 다양한 휴리스틱을 통해 볼륨을 줄일 수 있습니다. 상담원은 다음을 제한해야 합니다.\(SHOULD\)

수행하는 연결 확인의 총 수는 100입니다. 또한 에이전트는 제안이나 답변에서 수락할 후보자 수를 제한할 수 있습니다.\(MAY\)

이러한 종류의 공격을 피하려는 프로토콜은 개시자가 다음 메시지를 보내기 전에 응답을 기다리도록 하는 경우가 많습니다. 그러나 ICE의 경우에는 이것이 불가능합니다. 다음 두 가지 경우를 구별하는 것은 불가능합니다.

o 개시자가 응답하지 않을 의심하지 않는 대상에 대해 DoS 공격을 시작하는 데 사용되고 있기 때문에 응답이 없습니다.

o 개시자가 해당 IP 주소와 포트에 접근할 수 없어 응답이 없습니다.

두 번째 경우에는 다음 기회에 또 다른 수표를 보내야 하며, 전자의 경우에는 더 이상 수표를 보내서는 안 됩니다.

---
### **18.6.  Interactions with Application Layer Gateways and SIP**

ALG\(애플리케이션 계층 게이트웨이\)는 애플리케이션 프로토콜에 대한 NAT 통과를 용이하게 하기 위해 패킷의 내용을 검사하고 수정하는 NAT 장치에 있는 기능입니다. SBC\(Session Border Controller\)는 ALG와 가까운 친척이지만 실제로는 애플리케이션 계층 SIP 중개자로 존재하므로 투명성이 떨어집니다. ICE는 SBC 및 ALG와 상호 작용합니다.

ALG가 SIP를 인식하지만 ICE를 인식하지 못하는 경우 ALG가 SDP를 올바르게 수정하는 한 ICE는 이를 통해 작동합니다. 올바른 ALG 구현은 다음과 같이 동작합니다.

o ALG는 외부 주소가 포함된 경우 m 및 c 라인이나 rtcp 속성을 수정하지 않습니다.

o m 및 c 라인에 내부 주소가 포함된 경우 수정은 ALG의 상태에 따라 달라집니다.

- ALG에 외부 포트를 내부 IP 주소에 매핑하고 m 및 c 라인 또는 rtcp 속성의 값과 일치하는 포트를 매핑하는 바인딩이 이미 설정된 경우 ALG는 새 바인딩을 만드는 대신 해당 바인딩을 사용합니다.

- ALG에 아직 바인딩이 없으면 새 바인딩을 만들고 SDP를 수정하여 m 및 c 라인과 rtcp 속성을 다시 작성합니다.

불행히도 많은 ALG는 이러한 특수한 경우에 제대로 작동하지 않는 것으로 알려져 있습니다. ICE는 손상된 ALG를 해결하려고 시도하지 않습니다. 이는 해당 기능의 범위를 벗어나기 때문입니다. ICE는 종종 후보 집합과 m 및 c 라인, rtcp 속성 간의 불일치로 나타나는 이러한 조건을 진단하는 데 도움을 줄 수 있습니다. ice-mismatch 속성은 이 목적으로 사용됩니다.

ICE는 신호가 TLS를 통해 실행될 때 ALG를 통해 가장 잘 작동합니다. 이렇게 하면 ALG가 SDP 메시지를 조작하고 ICE 작업을 방해하는 것을 방지할 수 있습니다. ALG 뒤에 배포될 것으로 예상되는 구현은 SDP의 TLS 전송을 제공해야 합니다.\(SHOULD\)

SBC가 SIP를 인식하지만 ICE를 인식하지 못하는 경우 결과는 SBC의 동작에 따라 달라집니다. 적절한 B2BUA\(Back-to-Back User Agent\) 역할을 하는 경우 SBC는 ICE 속성을 포함하여 이해하지 못하는 모든 SDP 속성을 제거합니다. 결과적으로 통화는 마치 상대방이 ICE를 지원하지 않는 것처럼 두 끝점 모두에 표시됩니다. 그러면 SBC가 요청한 경우 ICE가 비활성화되고 미디어가 SBC를 통해 흐르게 됩니다. 그러나 SBC가 수정 없이 ICE 특성을 전달하지만 미디어의 기본 대상\(m 및 c 라인과 rtcp 특성에 포함됨\)을 수정하는 경우 이는 ICE 불일치로 감지되고 통화에 대한 ICE 처리가 중단됩니다. . SBC를 "해결"하기 위한 도구 역할을 하는 것은 ICE의 범위를 벗어납니다. ICE가 있는 경우 ICE는 사용되지 않으며 SBC 기술이 우선 적용됩니다.

---
## **19.  STUN Extensions**
---
### **19.1.  New Attributes**

이 사양은 PRIORITY, USE-CANDIDATE, ICE-ControlLED 및 ICE-ControlLING의 네 가지 새로운 속성을 정의합니다.

PRIORITY 속성은 이 검사를 통해 발견된 동료 반사 후보와 연관될 우선순위를 나타냅니다. 32비트 부호 없는 정수이며 속성 값은 0x0024입니다.

USE-CANDIDATE 속성은 이 검사로 인한 후보 쌍이 미디어 전송에 사용되어야 함을 나타냅니다. 속성에 콘텐츠가 없습니다\(속성의 길이 필드가 0임\). 그것은 깃발 역할을합니다. 속성 값은 0x0025입니다.

ICE-CONTROLLED 속성은 바인딩 요청에 존재하며 클라이언트가 현재 제어된 역할에 있다고 믿고 있음을 나타냅니다. 속성의 내용은 역할 충돌의 순위 결정에 사용되는 임의의 숫자를 포함하는 네트워크 바이트 순서의 64비트 부호 없는 정수입니다.

ICE-CONTROLLING 속성은 바인딩 요청에 존재하며 클라이언트가 현재 제어 역할에 있다고 믿고 있음을 나타냅니다. 속성의 내용은 역할 충돌의 순위 결정에 사용되는 임의의 숫자를 포함하는 네트워크 바이트 순서의 64비트 부호 없는 정수입니다.

---
### **19.2.  New Error Response Codes**

이 사양은 단일 오류 응답 코드를 정의합니다.

487\(역할 충돌\): 바인딩 요청에는 서버와 충돌한 역할을 나타내는 ICE- CONTROLLING 또는 ICE-ControlLED 속성이 포함되어 있습니다. 서버는 요청의 순위 결정 값을 기반으로 순위 결정을 실행하고 클라이언트가 역할을 전환해야 한다고 결정했습니다.

---
## **20.  Operational Considerations**

이 섹션에서는 ICE를 배포하려는 네트워크 운영자와 관련된 문제에 대해 설명합니다.

---
### **20.1.  NAT and Firewall Types**

ICE는 기존 NAT 및 방화벽 장비와 함께 작동하도록 설계되었습니다. 결과적으로 ICE 배포를 촉진하기 위해 기존 방화벽 및 NAT 장비를 교체하거나 재구성할 필요가 없습니다. 실제로 ICE는 VoIP\(Voice over IP\) 운영자가 방화벽 및 NAT를 포함한 IP 네트워크 인프라를 제어할 수 없는 환경에 배포되도록 개발되었습니다.

즉, ICE는 NAT 장치가 \[RFC4787\] 및 \[RFC5766\]에 정의된 권장 사항을 충족하면서 "동작"하는 환경에서 가장 잘 작동합니다. 동작 호환 NAT가 있는 네트워크에서 ICE는 TURN 서버 없이 작동하므로 음성 품질이 향상되고 통화 설정 시간이 단축되며 네트워크 운영자의 대역폭 요구가 줄어듭니다.

---
### **20.2.  Bandwidth Requirements**

ICE 배포에는 운영자가 고려해야 하는 사용 가능한 네트워크 용량과 여러 가지 상호 작용이 있을 수 있습니다.

---
#### **20.2.1.  STUN and TURN Server Capacity Planning**

무엇보다도 ICE는 일반적으로 네트워크 사업자의 데이터 센터에 위치한 TURN 및 STUN 서버를 사용합니다. STUN 서버에는 상대적으로 적은 대역폭이 필요합니다. 각 미디어 스트림의 각 구성 요소에는 하나 이상의 STUN이 있습니다.

각 클라이언트에서 STUN 서버로의 트랜잭션. 기본 음성 전용 IPv4 VoIP 구축에서는 통화당 4개의 트랜잭션이 발생합니다\(발신자와 수신자 모두에 대해 RTP용 트랜잭션 하나, RTCP용 트랜잭션 하나\). 각 트랜잭션은 단일 요청과 단일 응답으로, 전자의 길이는 20바이트이고 후자의 길이는 28바이트입니다. 결과적으로 시스템에 N명의 사용자가 있고 각 사용자가 바쁜 시간에 4번의 호출을 하는 경우 N\*1.7bps가 필요합니다. . 백만 명의 사용자의 경우 이는 1.7Mbps로 상대적으로 매우 작은 수치입니다.

TURN 트래픽이 더 상당합니다. TURN 서버는 실제 미디어 트래픽에 대한 트래픽 외에 STUN 볼륨과 동일한 트래픽 볼륨을 보게 됩니다\(실제로 TURN 서버가 배포되면 별도의 STUN 서버가 필요하지 않습니다\). 미디어 중계를 위해 TURN이 필요한 통화량은 네트워크 토폴로지에 따라 크게 달라지며 시간이 지남에 따라 달라질 수 있습니다. 100% 동작 호환 NAT를 사용하는 네트워크에서는 정확히 0입니다. 이 글을 쓰는 시점에 대규모 소비자 배포에서는 TURN 서버가 필요한 호출이 5\~10% 정도였습니다. 바쁜 시간 동안 .2 얼랭을 사용하여 G.711\(각 방향으로 80kbps\)을 사용하는 음성 전용 배포를 고려하면 이는 N\*3.2kbps입니다. 백만 명의 사용자 인구에 대해 이는 TURN 서버 사용량을 10%로 가정할 때 3.2Gbps입니다.

---
#### **20.2.2.  Gathering and Connectivity Checks**

후보를 수집하고 연결 확인을 수행하는 프로세스에는 대역폭이 많이 사용될 수 있습니다. ICE는 이 두 가지 프로세스 모두에 속도를 맞추도록 설계되었습니다. 수집 단계와 연결 확인 단계는 미디어 트래픽 자체와 거의 동일한 대역폭에서 트래픽을 생성하기 위한 것입니다. 이는 네트워크가 특정 유형\(음성, 비디오 또는 텍스트\)의 멀티미디어 트래픽을 지원하도록 설계된 경우 해당 미디어에 대한 ICE 검사를 지원할 수 있는 충분한 용량을 갖도록 하기 위해 수행되었습니다. 물론 ICE 확인으로 인해 전체 활용도가 약간 증가합니다. 그러나 이는 일반적으로 매우 작은 증가입니다.

수집 및 확인 단계로 인한 혼잡은 페이싱을 활용하지 않은 배포에서 문제가 되는 것으로 입증되었습니다. 일반적으로 엔드포인트가 보낼 수 있는 한 빠른 속도로 검사로 인해 네트워크가 넘쳐 액세스 링크가 혼잡해졌습니다. 결과적으로 네트워크 운영자는 ICE 구현이 페이싱 기능을 지원하는지 확인해야 합니다. 이 속도로 인해 통화 설정 시간이 늘어나지만 ICE 네트워크가 친숙해지고 배포가 쉬워집니다.

---
#### **20.2.3.  Keepalives**

STUN 연결 유지\(STUN 바인딩 표시 형식\)는 미디어 세션 중에 전송됩니다. 그러나 실제 미디어 트래픽이 없는 경우에만 전송됩니다. 그렇지 않은 배포에서는

VAD\(음성 활동 감지\)를 활용하면 연결 유지가 전혀 사용되지 않으며 대역폭 사용량도 증가하지 않습니다. VAD를 사용하는 경우 침묵 기간 동안 연결 유지가 전송됩니다. 여기에는 15\~20초마다 단일 패킷이 포함되며, 이는 음성이 있을 때 전송되는 20\~30ms마다 패킷보다 훨씬 적습니다. 따라서 연결 유지는 용량 계획에 실제 영향을 미치지 않습니다.

---
### **20.3.  ICE and ICE-lite**

ICE와 ICE-lite를 혼합하여 활용하는 배포는 완벽하게 상호 운용됩니다. 기능 손실 없이 그렇게 하도록 명시적으로 설계되었습니다.

그러나 ICE-lite는 제한된 사용 사례에만 배포할 수 있습니다. 이러한 경우와 그에 따른 주의 사항은 부록 A에 문서화되어 있습니다.

---
### **20.4.  Troubleshooting and Performance Management**

ICE는 엔드투엔드 연결 확인을 활용하고 대부분의 처리를 엔드포인트에 배치합니다. 이는 네트워크 운영자에게 과제를 안겨줍니다. ICE 배포 문제를 어떻게 해결할 수 있습니까? ICE의 성능을 어떻게 알 수 있나요?

ICE에는 이러한 문제를 해결하는 데 도움이 되는 기능이 내장되어 있습니다. 일반적으로 네트워크 사업자의 데이터 센터에 배포되는 신호 경로의 SIP 서버는 ICE 매개변수를 전달하는 제안/응답 교환 내용을 확인합니다. 이러한 매개변수에는 관련 주소와 함께 각 후보 유형\(호스트, 서버 재귀 또는 릴레이\)이 포함됩니다. ICE 처리가 완료되면 업데이트된 제안/응답 교환이 발생하여 선택한 주소\(및 해당 유형\)를 알립니다. 이 업데이트된 re-INVITE는 ICE 처리 결과에 대해 네트워크 장비\(예: SIP 서버에 연결된 진단 도구\)를 교육하기 위한 목적으로 정확하게 수행됩니다.

결과적으로, 네트워크 운영자는 SIP 서버에서 생성된 로그를 통해 각 통화에 어떤 유형의 후보자가 사용되고 있는지, ICE가 어떤 주소를 선택했는지 관찰할 수 있습니다. 이는 ICE의 성과를 평가하는 데 도움이 되는 기본 정보입니다.

---
### **20.5.  Endpoint Configuration**

ICE는 엔드포인트에 구성되는 여러 데이터 조각에 의존합니다. 이 구성 데이터에는 타이머, TURN 서버의 자격 증명, STUN 및 TURN 서버의 호스트 이름이 포함됩니다. ICE 자체는 이 구성에 대한 메커니즘을 제공하지 않습니다. 대신, 이 정보는 어떤 메커니즘에든 첨부되어 있다고 가정합니다.

엔드포인트의 다른 모든 매개변수를 구성하는 데 사용됩니다. SIP 전화의 경우 구성 프레임워크 \[SIP-UA-FRMWK\]와 같은 표준 솔루션이 정의되었습니다.

---
## **21.  IANA Considerations**

이 사양은 새로운 SDP 속성, 4개의 새로운 STUN 속성 및 1개의 새로운 STUN 오류 응답을 등록합니다.

---
### **21.1.  SDP Attributes**

이 사양은 \[RFC4566\]의 섹션 8.2.4 절차에 따라 7개의 새로운 SDP 속성을 정의합니다. 등록에 필요한 정보가 여기에 포함되어 있습니다.

---
#### **21.1.1.  candidate Attribute**

```text
   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.

   Attribute Name:  candidate

   Long Form:  candidate
```

속성 유형: 미디어 수준

Charset 고려사항: 속성은 charset 속성의 적용을 받지 않습니다.

목적: 이 속성은 ICE\(대화형 연결 설정\)와 함께 사용되며 통신에 사용할 수 있는 여러 후보 주소 중 하나를 제공합니다. 이러한 주소는 STUN\(Session Traversal Utilities for NAT\)을 사용하여 종단 간 연결 확인을 통해 검증됩니다.

적절한 값: RFC 5245의 섹션 15를 참조하세요.

---
#### **21.1.2.  remote-candidates Attribute**

```text
   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.

   Attribute Name:  remote-candidates

   Long Form:  remote-candidates
```

속성 유형: 미디어 수준

Charset 고려사항: 속성은 charset 속성의 적용을 받지 않습니다.

목적: 이 속성은 ICE\(대화형 연결 설정\)와 함께 사용되며 제안자가 응답자가 답변에 사용하기를 원하는 원격 후보자의 신원을 제공합니다.

적절한 값: RFC 5245의 섹션 15를 참조하세요.

---
#### **21.1.3.  ice-lite Attribute**

```text
   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.

   Attribute Name:  ice-lite

   Long Form:  ice-lite
```

속성 유형: 세션 수준

Charset 고려사항: 속성은 charset 속성의 적용을 받지 않습니다.

목적: 이 속성은 ICE\(대화형 연결 설정\)와 함께 사용되며 에이전트가 전체 구현을 갖춘 피어와의 ICE 상호 운용을 지원하는 데 필요한 최소 기능을 가지고 있음을 나타냅니다.

적절한 값: RFC 5245의 섹션 15를 참조하세요.

---
#### **21.1.4.  ice-mismatch Attribute**

```text
   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.

   Attribute Name:  ice-mismatch

   Long Form:  ice-mismatch
```

속성 유형: 세션 수준

Charset 고려사항: 속성은 charset 속성의 적용을 받지 않습니다.

목적: 이 속성은 ICE\(대화형 연결 설정\)와 함께 사용되며 에이전트가 ICE 가능하지만 SDP에서 신호를 보내는 미디어의 기본 대상과 후보가 일치하지 않아 ICE를 진행하지 않았음을 나타냅니다.

적절한 값: RFC 5245의 섹션 15를 참조하세요.

---
#### **21.1.5.  ice-pwd Attribute**

```text
   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.

   Attribute Name:  ice-pwd

   Long Form:  ice-pwd
```

속성 유형: 세션 또는 미디어 수준

Charset 고려사항: 속성은 charset 속성의 적용을 받지 않습니다.

목적: 이 속성은 ICE\(대화형 연결 설정\)와 함께 사용되며 STUN 연결 확인을 보호하는 데 사용되는 비밀번호를 제공합니다.

적절한 값: RFC 5245의 섹션 15를 참조하세요.

---
#### **21.1.6.  ice-ufrag Attribute**

```text
   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.

   Attribute Name:  ice-ufrag

   Long Form:  ice-ufrag
```

속성 유형: 세션 또는 미디어 수준

Charset 고려사항: 속성은 charset 속성의 적용을 받지 않습니다.

목적: 이 속성은 ICE\(대화형 연결 설정\)와 함께 사용되며 STUN 연결 확인에서 사용자 이름을 구성하는 데 사용되는 조각을 제공합니다.

적절한 값: RFC 5245의 섹션 15를 참조하세요.

---
#### **21.1.7.  ice-options Attribute**

```text
   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.

   Attribute Name:  ice-options

   Long Form:  ice-options
```

속성 유형: 세션 수준

Charset 고려사항: 속성은 charset 속성의 적용을 받지 않습니다.

목적: 이 속성은 ICE\(대화형 연결 설정\)와 함께 사용되며 에이전트가 사용하는 ICE 옵션 또는 확장을 나타냅니다.

적절한 값: RFC 5245의 섹션 15를 참조하세요.

---
### **21.2.  STUN Attributes**

이 섹션에서는 \[RFC5389\]의 절차에 따라 4개의 새로운 STUN 속성을 등록합니다.

```text
      0x0024 PRIORITY
      0x0025 USE-CANDIDATE
      0x8029 ICE-CONTROLLED
      0x802A ICE-CONTROLLING
```

---
### **21.3.  STUN Error Responses**

이 섹션에서는 \[RFC5389\]의 절차에 따라 하나의 새로운 STUN 오류 응답 코드를 등록합니다.

- 487 역할 충돌: 클라이언트가 서버의 역할과 충돌하는 ICE 역할\(제어 또는 제어\)을 주장했습니다.

---
## **22.  IAB Considerations**

IAB는 에이전트가 협업 프로토콜 반영 메커니즘\[RFC3424\]을 통해 NAT 반대편의 다른 영역에서 자신의 주소를 확인하려고 시도하는 일반적인 프로세스인 "일방적 자체 주소 수정" 문제를 연구했습니다. ICE는 이러한 유형의 기능을 수행하는 프로토콜의 예입니다. 흥미롭게도 ICE의 과정은 일방적이지 않고 양자적이며, 그 차이는 IAB가 제기하는 문제에 상당한 영향을 미칩니다. 실제로 ICE는 UNSAF 프로토콜이 아닌 B-SAF\(양방향 자체 주소 수정\) 프로토콜로 간주될 수 있습니다. 그럼에도 불구하고 IAB는 이 목적을 위해 개발된 모든 프로토콜에 특정 고려 사항을 문서화하도록 의무화했습니다. 이 섹션은 이러한 요구 사항을 충족합니다.

---
### **22.1.  Problem Definition**

```text
   >From RFC 3424, any UNSAF proposal must provide:
```

- UNSAF 제안으로 해결해야 할 구체적이고 제한된 범위의 문제에 대한 정확한 정의. 다른 문제를 해결하기 위해 단기적인 수정을 일반화해서는 안 됩니다. 이것이 "단기적인 수정이 일반적으로 이루어지지 않는" 이유입니다.

ICE가 해결하고 있는 구체적인 문제는 다음과 같습니다.

- 두 피어가 통신에 사용할 수 있는 전송 주소 집합을 결정할 수 있는 수단을 제공합니다.

- 에이전트가 통신하려는 다른 피어가 연결할 수 있는 주소를 결정할 수 있는 수단을 제공합니다.

---
### **22.2.  Exit Strategy**

```text
   >From RFC 3424, any UNSAF proposal must provide:
```

- 출구 전략/전환 계획에 대한 설명입니다. 더 나은 단기 수정은 적절한 기술이 배포됨에 따라 자연스럽게 사용이 점점 줄어들게 되는 수정입니다.

ICE 자체는 쉽게 단계적으로 폐지되지 않습니다. 그러나 예를 들어 라우터 오류로 인해 연결이 일시적으로 중단되었는지 여부를 감지하는 수단으로 사용하는 것은 전 세계적으로 연결된 인터넷에서도 유용합니다. ICE는 또한 NAT와 관련이 없는 특정 보안 공격을 방지하는 데도 도움이 됩니다. 그러나 ICE가 하는 일은 다른 UNSAF 메커니즘을 단계적으로 폐지하는 것입니다. ICE는 이러한 메커니즘 중에서 효과적으로 선택하여 더 나은 메커니즘의 우선 순위를 지정하고 더 나쁜 메커니즘의 우선 순위를 낮춥니다. 로컬 IPv6 주소가 선호될 수 있습니다. IPv6가 도입되면서 NAT가 사라지기 시작하면 서버 반사 및 릴레이 후보\(두 가지 형태의 UNSAF 주소 모두\)는 절대 사용되지 않습니다. 기본 호스트 후보에 대한 우선순위가 더 높은 연결이 존재하기 때문입니다. 따라서 서버는 점점 더 적게 사용되며 사용량이 0이 되면 결국 제거될 수 있습니다.

실제로 ICE는 IPv4에서 IPv6로의 전환을 지원할 수 있습니다. 두 개의 듀얼 스택 호스트가 SIP와 통신할 때\(IPv6가 사용됨\) IPv6을 사용할지 아니면 IPv4를 사용할지 결정하는 데 사용할 수 있습니다. 또한 6to4 및 기본 v6 연결을 모두 갖춘 네트워크가 피어와 통신할 때 사용할 주소를 결정할 수 있습니다.

---
### **22.3.  Brittleness Introduced by ICE**

```text
   >From RFC 3424, any UNSAF proposal must provide:
```

- 시스템을 더욱 "취약하게" 만들 수 있는 특정 문제에 대해 논의합니다. 예를 들어, 여러 네트워크 계층에서 데이터를 사용하는 접근 방식은 더 많은 종속성을 생성하고 디버깅 문제를 증가시키며 전환을 더 어렵게 만듭니다.

ICE는 실제로 기존 UNSAF 메커니즘의 취약성을 제거합니다. 특히, 전통적인 STUN\(RFC 3489 \[RFC3489\]에 설명된 대로\)에는 몇 가지 취성 지점이 있습니다. 그 중 하나는 에이전트가 뒤에 있는 NAT 유형을 분류하도록 요구하는 검색 프로세스입니다. 이 프로세스는 오류가 발생하기 쉽습니다. ICE에서는 해당 검색 프로세스가 사용되지 않습니다. 주소의 유효성을 일방적으로 평가하는 것이 아니라 피어에 대한 연결을 측정하여 주소의 유효성을 동적으로 결정합니다. 연결성을 결정하는 프로세스는 매우 강력합니다.

기존 STUN 및 기타 일방적 메커니즘의 또 다른 취약점은 추가 서버에 대한 절대적인 의존성입니다. ICE는 일방적인 주소 할당을 위해 서버를 사용하지만 가능하면 에이전트가 직접 연결할 수 있도록 허용합니다. 따라서 어떤 경우에는 STUN 서버의 오류로 인해 ICE가 사용될 때 호출이 계속 진행될 수 있습니다.

기존 STUN의 또 다른 취약성은 STUN 서버가 공용 인터넷에 있다고 가정한다는 것입니다. 흥미롭게도 ICE에서는 그럴 필요가 없습니다. 다양한 주소 영역에 다수의 STUN 서버가 있을 수 있습니다. ICE는 사용 가능한 주소를 제공한 주소를 검색합니다.

기존 STUN의 취약성 중 가장 문제가 되는 점은 모든 네트워크 토폴로지에서 작동하지 않는다는 것입니다. 각 에이전트와 STUN 서버 간에 공유 NAT가 있는 경우 기존 STUN이 작동하지 않을 수 있습니다. ICE를 사용하면 이러한 제한이 제거됩니다.

Classic STUN에는 몇 가지 보안 고려 사항도 도입되었습니다. 다행히도 ICE에서는 이러한 보안 고려 사항도 완화됩니다.

결과적으로 ICE는 기존 STUN에 도입된 취성을 복구하는 역할을 하며 시스템에 추가적인 취성을 도입하지 않습니다.

이러한 개선의 단점은 ICE가 세션 설정 시간을 증가시킨다는 것입니다.

---
### **22.4.  Requirements for a Long-Term Solution**

RFC 3424에서 모든 UNSAF 제안은 다음을 제공해야 합니다.

- ...장기적이고 건전한 기술 솔루션에 대한 요구 사항 - 올바른 장기 솔루션을 찾는 프로세스에 기여합니다.

RFC 3489의 결론은 변경되지 않았습니다. 그러나 우리는 ICE가 장기적인 솔루션의 일부가 될 수 있다고 믿기 때문에 실제로 도움이 된다고 생각합니다.

---
### **22.5.  Issues with Existing NAPT Boxes**

RFC 3424에서 모든 UNSAF 제안은 다음을 제공해야 합니다.

- 기존 배포된 NA\[P\]T 및 경험 보고서에 대해 언급된 실제 문제의 영향에 대한 논의.

현재 "일반" ALG 기능을 제공하기 위해 수많은 NAT 상자가 시장에 배포되고 있습니다. 이러한 일반 ALG는 패킷 내에서 텍스트 또는 바이너리 형식으로 IP 주소를 찾아 바인딩과 일치하면 다시 작성합니다. 이는 기존 STUN을 방해합니다. 그러나 STUN \[RFC5389\]에 대한 업데이트는 일반 ALG에서 이러한 바이너리 주소를 숨기는 인코딩을 사용합니다.

기존 NAPT 상자는 UDP 기반 바인딩에 대해 비결정적이며 일반적으로 짧은 만료 시간을 갖습니다. 이를 위해서는 해당 바인딩을 유지하기 위해 정기적인 연결 유지를 보내는 구현이 필요합니다. ICE는 기본값인 15초를 사용하는데, 이는 매우 보수적인 추정치입니다. 결국 시간이 지남에 따라 NAT 상자가 \[RFC4787\] 동작을 준수하게 되면 이 최소 연결 유지가 결정적이고 잘 알려지게 되며 ICE 타이머를 조정할 수 있습니다. 최소 연결 유지 간격을 찾아 제어할 수 있는 방법이 있으면 훨씬 더 좋습니다.

---
## **23.  Acknowledgements**

저자들은 의견을 주신 Dan Wing, Eric Rescorla, Flemming Andreasen, Rohan Mahy, Dean Willis, Eric Cooper, Jason Fischl, Douglas Otis, Tim Moore, Jean-Francois Mule, Kevin Johns, Jonathan Lennox 및 Francois Audet에게 감사의 말씀을 전하고 싶습니다. 그리고 입력. 이 사양의 여러 개념을 제안한 Bill May, 이 사양의 여러 핵심 성능 최적화를 제안한 Philip Matthews, 서론의 텍스트 초안을 작성한 Eric Rescorla 및 Magnus Westerlund에게 특별한 감사를 드립니다. 이 사양의 다양한 개정판에 대한 몇 가지 자세한 검토.

---
## **24.  References**
---
### **24.1.  Normative References**

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC3605\] Huitema, C., "SDP\(세션 설명 프로토콜\)의 RTCP\(실시간 제어 프로토콜\) 특성", RFC 3605, 2003년 10월.

\[RFC3261\] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M. 및 E. Schooler, "SIP: 세션 시작 프로토콜" , RFC 3261, 2002년 6월.

\[RFC3264\] Rosenberg, J. 및 H. Schulzrinne, "세션 설명 프로토콜\(SDP\)을 사용한 제안/응답 모델", RFC 3264, 2002년 6월.

\[RFC3556\] Casner, S., "RTCP 제어 프로토콜\(RTCP\) 대역폭에 대한 세션 설명 프로토콜\(SDP\) 대역폭 수정자", RFC 3556, 2003년 7월.

\[RFC3312\] Camarillo, G., Marshall, W. 및 J. Rosenberg,

- "리소스 관리 및 세션 시작 프로토콜\(SIP\)의 통합", RFC 3312, 2002년 10월.

\[RFC4032\] Camarillo, G. 및 P. Kyzivat, "SIP\(Session Initiation Protocol\) 전제 조건 프레임워크 업데이트", RFC 4032, 2005년 3월.

\[RFC3262\] Rosenberg, J. 및 H. Schulzrinne, "신뢰성

- SIP\(Session Initiation Protocol\)의 임시 응답", RFC 3262, 2002년 6월.

\[RFC4566\] Handley, M., Jacobson, V. 및 C. Perkins, "SDP: 세션 설명 프로토콜", RFC 4566, 2006년 7월.

\[RFC4091\] Camarillo, G. 및 J. Rosenberg, "SDP\(세션 설명 프로토콜\) 그룹화 프레임워크에 대한 ANAT\(대체 네트워크 주소 유형\) 의미 체계", RFC 4091, 2005년 6월.

\[RFC4092\] Camarillo, G. 및 J. Rosenberg, "SIP\(세션 시작 프로토콜\)에서 SDP\(Session Description Protocol\) 대체 네트워크 주소 유형\(ANAT\) 의미 체계의 사용", RFC 4092, 2005년 6월.

\[RFC3484\] Draves, R., "인터넷 프로토콜 버전 6\(IPv6\)에 대한 기본 주소 선택", RFC 3484, 2003년 2월.

\[RFC5234\] Crocker, D., Ed. 및 P. Overell, "구문 사양을 위한 증강 BNF: ABNF", STD 68, RFC 5234, 2008년 1월.

\[RFC5389\] Rosenberg, J., Mahy, R., Matthews, P. 및 D. Wing, "STUN\(NAT용 세션 탐색 유틸리티\)", RFC 5389, 2008년 10월.

\[RFC5766\] Mahy, R., Matthews, P. 및 J. Rosenberg, "NAT 주변 릴레이를 사용한 탐색\(TURN\): NAT용 세션 탐색 유틸리티에 대한 릴레이 확장\(STUN\)", RFC 5766, 2010년 4월.

\[RFC5768\] Rosenberg, J., "SIP\(세션 시작 프로토콜\)에서 ICE\(대화형 연결 설정\)에 대한 지원 표시", RFC 5768, 2010년 4월.

---
### **24.2.  Informative References**

\[RFC3489\] Rosenberg, J., Weinberger, J., Huitema, C. 및 R. Mahy, "STUN - NAT\(네트워크 주소 변환기\)를 통한 UDP\(사용자 데이터그램 프로토콜\)의 단순 탐색", RFC 3489, 2003년 3월.

```text
   [RFC3235]  Senie, D., "Network Address Translator (NAT)-Friendly
              Application Design Guidelines", RFC 3235, January 2002.
```

\[RFC3303\] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A. 및 A. Rayhan, "미들박스 통신 아키텍처 및 프레임워크", RFC 3303, 2002년 8월.

\[RFC3725\] Rosenberg, J., Peterson, J., Schulzrinne, H. 및 G. Camarillo, "SIP\(세션 시작 프로토콜\)의 제3자 통화 제어\(3pcc\)에 대한 현재 모범 사례", BCP 85, RFC 3725 , 2004년 4월.

\[RFC3102\] Borella, M., Lo, J., Grabelsky, D. 및 G. Montenegro, "영역별 IP: 프레임워크", RFC 3102, 2001년 10월.

\[RFC3103\] Borella, M., Grabelsky, D., Lo, J. 및 K. Taniguchi, "영역별 IP: 프로토콜 사양", RFC 3103, 2001년 10월.

\[RFC3424\] Daigle, L. 및 IAB, "네트워크 주소 변환 전반에 걸친 UNSAF\(단방향 자체 주소 수정\)에 대한 IAB 고려 사항", RFC 3424, 2002년 11월.

\[RFC3550\] Schulzrinne, H., Casner, S., Frederick, R. 및 V. Jacobson, "RTP: 실시간 애플리케이션을 위한 전송 프로토콜", STD 64, RFC 3550, 2003년 7월.

\[RFC3711\] Baugher, M., McGrew, D., Naslund, M., Carrara, E. 및 K. Norrman, "SRTP\(보안 실시간 전송 프로토콜\)", RFC 3711, 2004년 3월.

\[RFC3056\] Carpenter, B. 및 K. Moore, "IPv4 클라우드를 통한 IPv6 도메인 연결", RFC 3056, 2001년 2월.

\[RFC3389\] Zopf, R., "편안한 소음\(CN\)을 위한 실시간 전송 프로토콜\(RTP\) 페이로드", RFC 3389, 2002년 9월.

\[RFC3960\] Camarillo, G. 및 H. Schulzrinne, "SIP\(세션 시작 프로토콜\)의 초기 미디어 및 벨소리 생성", RFC 3960, 2004년 12월.

\[RFC2475\] Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z. 및 W. Weiss, "차등화된 서비스를 위한 아키텍처", RFC 2475, 1998년 12월.

\[RFC1918\] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G. 및 E. Lear, "개인 인터넷에 대한 주소 할당", BCP 5, RFC 1918, 1996년 2월.

\[RFC4787\] Audet, F. 및 C. Jennings, "유니캐스트 UDP에 대한 NAT\(네트워크 주소 변환\) 동작 요구 사항", BCP 127, RFC 4787, 2007년 1월.

\[SDP-프리콘\]

- Andreasen, F., Camarillo, G., Oran, D. 및 D. Wing, "세션 설명 프로토콜 미디어 스트림을 위한 연결 전제 조건", 진행 중인 작업, 2010년 3월.

\[NO-OP-RTP\]

- Andreasen, F., Oran, D. 및 D. Wing, "RTP를 위한 무작동 페이로드 형식", 진행 중인 작업, 2007년 5월.

\[RFC5761\] Perkins, C. 및 M. Westerlund, "단일 포트에서 RTP 데이터 및 제어 패킷 다중화", RFC 5761, 2010년 4월.

\[RFC4340\] Kohler, E., Handley, M. 및 S. Floyd, "데이터그램

- 혼잡 제어 프로토콜\(DCCP\)", RFC 4340, 2006년 3월.

\[RFC4103\] Hellstrom, G. 및 P. Jones, "텍스트용 RTP 페이로드

- 대화", RFC 4103, 2005년 6월.

\[RFC5626\] Jennings, C., Mahy, R. 및 F. Audet, "SIP\(세션 시작 프로토콜\)에서 클라이언트 시작 연결 관리", RFC 5626, 2009년 10월.

\[RFC5382\] Guha, S., Biswas, K., Ford, B., Sivakumar, S. 및 P. Srisuresh, "TCP에 대한 NAT 동작 요구 사항", BCP 142, RFC 5382, 2008년 10월.

\[SIP-UA-FRMWK\]

- Petrie, D. 및 S. Channabasappa, Ed., "세션 시작 프로토콜 사용자 에이전트 프로필 전달을 위한 프레임워크", 진행 중인 작업, 2010년 2월.

\[ICE-TCP\] Perreault, S., Ed. J. Rosenberg, "ICE\(대화형 연결 구축\)를 통한 TCP 후보", 진행 중인 작업, 2009년 10월.

---
# **Appendix A.  Lite and Full Implementations**

ICE는 두 가지 유형의 구현을 허용합니다. 전체 구현은 세션에서 제어 및 제어된 역할을 지원하며 주소 수집도 수행할 수 있습니다. 대조적으로, 라이트 구현은 STUN 검사에 응답하는 것 외에는 거의 수행하지 않는 최소한의 구현입니다.

ICE는 두 엔드포인트 모두에 이점을 제공하기 위해 두 엔드포인트 모두 이를 지원해야 하기 때문에 네트워크에서 ICE를 점진적으로 배포하는 것은 더 복잡합니다. 많은 세션에는 자체적으로 NAT 뒤에 있지 않고 NAT 통과에 대해 걱정할 엔드포인트가 없는 엔드포인트가 포함됩니다. 매우 일반적인 경우는 NAT 통과가 필요한 하나의 엔드포인트\(예: VoIP 하드폰 또는 소프트폰\)가 이러한 장치 중 하나에 전화를 걸도록 하는 것입니다. 전화기가 완전한 ICE 구현을 지원하더라도 다른 장치가 이를 지원하지 않으면 ICE는 전혀 사용되지 않습니다. 라이트 구현을 통해 이러한 장치에 대한 저렴한 진입점이 가능합니다. 라이트 구현을 지원하면 전체 구현이 이에 연결되어 ICE의 모든 이점을 얻을 수 있습니다.

결과적으로, 라이트 구현은 \*항상\* 공용 인터넷에 연결되고 모든 통신원으로부터 패킷을 수신할 수 있는 공용 IP 주소가 있는 장치에만 적합합니다. NAT 뒤에 라이트 구현이 배치되면 ICE가 작동하지 않습니다.

ICE를 사용하면 단일 IPv4 호스트 후보와 여러 IPv6 주소를 가질 수 있는 간단한 구현이 가능합니다. 이 경우 후보 쌍은 이 사양에서 권장하는 RFC 3484의 알고리즘과 같은 정적 알고리즘을 사용하여 제어 에이전트에 의해 선택됩니다. 그러나 주소 선택을 위한 정적 메커니즘은 실제 토폴로지를 반영할 수 없고 연결에 대한 실제 보장을 제공할 수 없기 때문에 항상 오류가 발생하기 쉽습니다. 그들은 항상 경험적 방법입니다. 결과적으로 에이전트가 IPv4와 IPv6 주소 중 하나를 선택하기 위해 ICE를 구현하고 해당 IP 주소가 NAT 뒤에 있는 경우, 가장 강력한 주소 선택 형식을 제공하기 위해 전체 ICE를 사용하는 것이 여전히 권장됩니다.\(SHOULD\)

전체 구현에 대한 디딤돌을 제공하기 위해 이 사양에 라이트 구현이 추가되었다는 점에 유의하는 것이 중요합니다. 단일 IPv4 주소만으로 항상 공용 인터넷에 연결되는 장치의 경우에도 가능하다면 전체 구현이 바람직합니다. ICE의 공격적 모드를 사용할 수 있으므로 전체 구현을 통해 통화 설정 시간이 단축됩니다. 전체 구현은 NAT 통과와 관련되지 않은 ICE의 보안 이점도 얻습니다. 특히, 18절에 설명된 보이스 해머 공격은 전체 구현에 대해서만 방지됩니다.

라이트가 아닙니다. 마지막으로, 오늘 공개 주소가 있는 장치가 내일 NAT 뒤에 있는 네트워크에 배치되는 경우가 많습니다. 장치나 제품의 수명이 다할 때까지 그것이 항상 공용 인터넷에서 사용될 것이라는 점을 확실하게 아는 것은 어렵습니다. 전체 구현은 통신이 항상 작동한다는 보장을 제공합니다.

---
# **Appendix B.  Design Motivations**

ICE에는 그 자체로는 단순할 수 있지만 복잡하거나 명확하지 않은 사고나 추가 논의가 필요한 사용 사례에서 파생되는 다수의 규범적 동작이 포함되어 있습니다. 이러한 설계 동기는 구현 목적으로 이해할 필요가 없으므로 사양의 부록에서 여기에서 논의됩니다. 이 섹션은 비표준입니다.

---
### **B.1.  Pacing of STUN Transactions**

후보를 수집하고 연결을 확인하는 데 사용되는 STUN 트랜잭션은 매 Ta 밀리초마다 하나의 새로운 트랜잭션의 대략적인 속도로 진행됩니다. 각 트랜잭션에는 Ta의 기능인 재전송 타이머 RTO도 있습니다. 이러한 거래가 진행되는 이유는 무엇이며 이러한 공식이 사용되는 이유는 무엇입니까?

이러한 STUN 요청을 보내면 클라이언트와 STUN 서버 사이의 NAT 장치에 바인딩이 생성되는 효과가 있는 경우가 많습니다. 경험에 따르면 많은 NAT 장치에는 새 바인딩을 생성하는 속도에 상한이 있는 것으로 나타났습니다. 실험에 따르면 20ms마다 한 번씩이 잘 지원되지만 그보다 훨씬 낮지는 않습니다. 이것이 Ta의 하한이 20ms인 이유입니다. 또한 네트워크에서 이러한 패킷을 전송하려면 대역폭을 사용하고 에이전트에 의해 속도가 제한되어야 합니다. 이 문서의 이전 초안 버전을 기반으로 한 배포는 속도가 제한된 액세스 링크에 과부하가 걸리고 전반적으로 성능이 저하되는 경향이 있었으며 네트워크에 부정적인 영향을 미쳤습니다. 결과적으로 페이싱은 NAT 장치가 과부하되지 않고 트래픽이 합리적인 속도로 유지되도록 보장합니다.

"합리적인" 속도의 정의는 STUN이 미디어 흐름이 시작되면 RTP 자체가 사용하는 것보다 더 많은 대역폭을 사용해서는 안 된다는 것입니다. Ta의 공식은 STUN 패킷이 Ta초마다 전송되면 모든 미디어 스트림에서 합산된 RTP 패킷과 동일한 양의 대역폭을 소비하도록 설계되었습니다. 물론 STUN은 재전송을 수행하며 이러한 속도도 조절하고자 합니다. 이러한 이유로 RTO는 마지막 트랜잭션에서 첫 번째 STUN 요청이 발생하는 것과 마찬가지로 첫 번째 트랜잭션에서 첫 번째 재전송이 발생하도록 설정됩니다. 그림으로:

```text
              First Packets              Retransmits

                    |                        |
                    |                        |
             -------+------           -------+------
            /               \        /               \
           /                 \      /                 \

           +--+    +--+    +--+    +--+    +--+    +--+
           |A1|    |B1|    |C1|    |A2|    |B2|    |C2|
           +--+    +--+    +--+    +--+    +--+    +--+

        ---+-------+-------+-------+-------+-------+------------ Time
           0       Ta      2Ta     3Ta     4Ta     5Ta
```

이 그림에는 전송될 트랜잭션이 3개 있습니다\(예를 들어 후보 수집의 경우 호스트 후보/STUN 서버 쌍이 3개 있습니다\). 이들은 트랜잭션 A, B, C이다. 재전송 타이머는 첫 번째 트랜잭션\(패킷 A2\)에 대한 첫 번째 재전송이 3Ta 시간에 전송되도록 설정된다.

첫 번째 재전송 이후 후속 재전송은 Ta 밀리초 간격보다 훨씬 덜 자주 발생합니다. STUN은 재전송에 지수 백오프를 사용하기 때문입니다.

---
### **B.2.  Candidates with Multiple Bases**

섹션 4.1.3에서는 전송 주소와 기반이 동일한 후보를 제거하는 방법에 대해 설명합니다. 그러나 전송 주소는 동일하지만 베이스가 다른 후보는 중복되지 않습니다. IP 주소와 포트는 동일하지만 기반이 다른 두 후보가 에이전트에 있을 수 있는 경우는 언제입니까? 그림 10의 토폴로지를 고려하십시오.

```text
          +----------+
          | STUN Srvr|
          +----------+
               |
               |
             -----
           //     \\
          |         |
         |  B:net10  |
          |         |
           \\     //
             -----
               |
               |
          +----------+
          |   NAT    |
          +----------+
               |
               |
             -----
           //     \\
          |    A    |
         |192.168/16 |
          |         |
           \\     //
             -----
               |
               |
               |192.168.1.100      -----
          +----------+           //     \\             +----------+
          |          |          |         |            |          |
          | Offerer  |---------|  C:net10  |-----------| Answerer |
          |          |10.0.1.100|         | 10.0.1.101 |          |
          +----------+           \\     //             +----------+
                                   -----

           Figure 10: Identical Candidates with Different Bases
```

이 경우 제안자는 멀티홈입니다. net 10 개인 네트워크인 네트워크 C에 하나의 IP 주소 10.0.1.100이 있습니다. 응답자는 동일한 네트워크에 있습니다. 제공자는 네트워크 A\(192.168/16\)에도 연결되어 있습니다. 제공자는 이 네트워크에서 192.168.1.100의 IP 주소를 가지고 있습니다. 이 네트워크에는 NAT가 있으며, 또 다른 net 10 개인 네트워크인 네트워크 B에 연결되지만 네트워크 C에는 연결되어 있지 않습니다. 네트워크 B에는 STUN 서버가 있습니다.

제공자는 네트워크 C\(10.0.1.100:2498\)의 IP 주소에서 호스트 후보를 얻고 네트워크 A의 IP 주소에서 호스트 후보를 얻습니다.

\(192.168.1.100:3344\). 192.168.1.100:3344에서 구성된 STUN 서버에 STUN 쿼리를 수행합니다. 이 쿼리는 바인딩 10.0.1.100:2498을 할당하는 NAT를 통과합니다. STUN 서버는 이를 STUN 바인딩 응답에 반영합니다. 이제 제안자는 호스트 후보\(10.0.1.100:2498\)와 동일한 전송 주소를 가진 서버 반사 후보를 얻었습니다. 그러나 서버 재귀 후보의 베이스는 192.168.1.100:3344이고, 호스트 후보의 베이스는 10.0.1.100:2498입니다.

---
### **B.3.  Purpose of the <rel-addr> and <rel-port> Attributes**

Candidate 속성에는 ICE 자체에서 전혀 사용되지 않는 두 개의 값인 <rel-addr\> 및 <rel-port\>가 포함되어 있습니다. 왜 존재합니까?

포함된 동기는 두 가지입니다. 첫 번째는 진단입니다. 다양한 유형의 후보자 간의 관계를 아는 것은 매우 유용합니다. 이를 포함함으로써 에이전트는 어떤 릴레이된 후보가 어떤 반사 후보와 연관되어 있고, 이는 다시 특정 호스트 후보와 연관되어 있는지 알 수 있습니다. 한 후보에 대한 검사가 성공하고 다른 후보에 대한 검사는 성공하지 못한 경우 이는 네트워크에서 무슨 일이 일어나고 있는지에 대한 유용한 진단을 제공합니다.

두 번째 이유는 오프패스 QoS\(Quality of Service\) 메커니즘과 관련이 있습니다. PacketCable 2.0과 같은 환경에서 ICE가 사용되는 경우 프록시는 일반적인 SIP 작업을 수행하는 것 외에도 SIP 메시지에서 SDP를 검사하고 미디어 트래픽에 대한 IP 주소와 포트를 추출합니다. 그런 다음 정책 서버를 통해 네트워크의 액세스 라우터와 상호 작용하여 미디어 흐름에 대해 보장된 QoS를 설정할 수 있습니다. 이 QoS는 5-튜플을 기반으로 RTP 트래픽을 분류한 다음 보장된 속도를 제공하거나 Diffserv 코드 포인트를 적절하게 표시하여 제공됩니다. 주거용 NAT가 있고 중계된 후보가 미디어용으로 선택되면 이 중계된 후보는 실제 TURN 서버의 전송 주소가 됩니다. 해당 주소는 QoS 처리를 위해 패킷을 분류하는 데 사용되는 액세스 라우터의 실제 전송 주소에 대해 아무 것도 말하지 않습니다. 오히려 TURN 서버를 향한 서버 반사 후보가 필요합니다. SDP에서 변환을 수행함으로써 프록시는 해당 전송 주소를 사용하여 액세스 라우터에서 QoS를 요청할 수 있습니다.

---
### **B.4.  Importance of the STUN Username**

ICE는 단기 자격 증명 기능을 사용하여 STUN과 함께 메시지 무결성을 사용해야 합니다. 실제 단기 자격 증명은 SDP 제안/답변 교환에서 사용자 이름 조각을 교환하여 형성됩니다. 이 메커니즘의 필요성은 단순한 보안 이상의 것입니다. 이는 실제로 ICE의 올바른 작동을 위해 필요합니다.

에이전트 L, R 및 Z를 고려하십시오. L 및 R은 10.0.0.0/8을 사용하는 민간 기업 1 내에 있습니다. Z는 역시 10.0.0.0/8을 사용하는 민간 기업 2 내에 있습니다. 알고 보니 R과 Z 모두 IP 주소가 10.0.1.1입니다. L은 Z에게 제안을 보냅니다. Z는 이에 대한 답변으로 L에게 호스트 후보를 제공합니다. 이 경우 해당 후보는 10.0.1.1:8866 및 10.0.1.1:8877입니다. 알고 보니 R은 동시에 세션에 있고 10.0.1.1:8866 및 10.0.1.1:8877을 호스트 후보로 사용하고 있습니다. 이는 R이 Z와 마찬가지로 해당 포트에서 STUN 메시지를 수락할 준비가 되어 있음을 의미합니다. L은 10.0.1.1:8866에 STUN 요청을 보내고 10.0.1.1:8877에 또 다른 STUN 요청을 보냅니다. 그러나 예상대로 Z로 이동하지 않습니다. 대신에 그들은 R로 갑니다! R이 방금 응답했다면 L은 Z에 연결되어 있다고 믿을 것입니다. 그러나 실제로는 완전히 다른 사용자인 R에 연결되어 있습니다. 이 문제를 해결하기 위해 STUN 단기 자격 증명 메커니즘이 사용됩니다. 사용자 이름 조각은 충분히 무작위적이어서 R이 Z와 동일한 값을 사용할 가능성이 거의 없습니다. 결과적으로 자격 증명이 유효하지 않기 때문에 R은 STUN 요청을 거부합니다. 본질적으로 STUN 사용자 이름 조각은 특정 제안/응답 세션에 바인딩된 임시 호스트 식별자의 형태를 제공합니다.

IP 주소의 고유하지 않음으로 인한 불행한 결과는 위의 예에서 R이 ICE 에이전트가 아닐 수도 있다는 것입니다. 이는 임의의 호스트일 수 있으며, STUN 패킷이 전달되는 포트는 해당 호스트의 임시 포트일 수 있습니다. 이 소켓에서 패킷을 수신하는 응용 프로그램이 있고 사용 중인 프로토콜에 관계없이 잘못된 패킷을 처리할 준비가 되어 있지 않은 경우 해당 응용 프로그램의 작동이 영향을 받을 수 있습니다. 다행스럽게도 SDP에서 교환되는 포트는 일시적이고 일반적으로 동적 또는 등록된 범위에서 가져오므로 포트가 호스트 R에서 서버를 실행하는 데 사용되지 않고 오히려 일부 프로토콜의 에이전트 측일 가능성이 높습니다. 이렇게 하면 이 범위에서 포트 사용의 일시적인 특성으로 인해 할당된 포트에 도달할 확률이 줄어듭니다. 그러나 문제가 발생할 가능성이 있으므로 네트워크 배포자는 이에 대비해야 합니다. 이는 ICE에만 국한된 문제가 아닙니다. 길 잃은 패킷은 모든 유형의 프로토콜, 특히 공용 인터넷의 프로토콜에 대해 언제든지 포트에 도착할 수 있습니다. 따라서 이 요구 사항은 인터넷 응용 프로그램에 대한 일반적인 설계 지침을 다시 설명하는 것입니다. 즉, 모든 포트에서 알 수 없는 패킷에 대비해야 합니다.

---
### **B.5.  The Candidate Pair Priority Formula**

후보 쌍의 우선순위는 이상한 형식을 갖습니다. 그것은:

```text
      pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)
```

왜 이런거야? 이 값을 기준으로 후보 쌍을 정렬하면 결과 정렬에는 MAX/MIN 속성이 포함됩니다. 즉, 두 우선순위 중 최소값이 감소하는 기준으로 쌍이 먼저 정렬됩니다. 최소 우선순위 값이 동일한 쌍의 경우 최대 우선순위를 사용하여 쌍을 정렬합니다. 최대 우선순위와 최소 우선순위가 동일한 경우 제어 에이전트의 우선순위가 표현식의 마지막 부분에서 순위 결정자로 사용됩니다. 단일 후보의 우선순위는 항상 2\*32보다 작기 때문에 2\*32 인수가 사용됩니다. 결과적으로 쌍 우선순위는 두 구성요소 우선순위의 "연결"이 됩니다. 그러면 MAX/MIN 정렬이 생성됩니다. MAX/MIN은 특정 에이전트에 대해 우선 순위가 높은 후보가 모두 시도될 때까지 우선 순위가 낮은 후보가 사용되지 않도록 합니다.

---
### **B.6.  The remote-candidates Attribute**

a=remote-candidates 속성은 업데이트된 제안과 후보를 유효 목록으로 이동시킨 STUN 바인딩 요청에 대한 응답 간의 경쟁 조건을 제거하기 위해 존재합니다. 이 경쟁 조건은 그림 11에 나와 있습니다. 메시지 4를 수신하면 에이전트 L은 후보 쌍을 유효한 목록에 추가합니다. 단일 구성 요소가 포함된 단일 미디어 스트림만 있는 경우 에이전트 L은 이제 업데이트된 제안을 보낼 수 있습니다. 그러나 에이전트 R의 확인은 아직 응답을 생성하지 않았으며 에이전트 R은 응답\(메시지 9\)을 받기 전에 업데이트된 제안\(메시지 7\)을 받습니다. 따라서 이 특정 쌍이 유효한지 아직 알 수 없습니다. 이 조건을 제거하기 위해 제안자\(원격 후보자\)가 선택한 R의 실제 후보자가 제안 자체에 포함되고 응답자는 해당 쌍이 검증될 때까지 답변을 지연합니다.

```text
          Agent A               Network               Agent B
             |(1) Offer            |                     |
             |------------------------------------------>|
             |(2) Answer           |                     |
             |<------------------------------------------|
             |(3) STUN Req.        |                     |
             |------------------------------------------>|
             |(4) STUN Res.        |                     |
             |<------------------------------------------|
             |(5) STUN Req.        |                     |
             |<------------------------------------------|
             |(6) STUN Res.        |                     |
             |-------------------->|                     |
             |                     |Lost                 |
             |(7) Offer            |                     |
             |------------------------------------------>|
             |(8) STUN Req.        |                     |
             |<------------------------------------------|
             |(9) STUN Res.        |                     |
             |------------------------------------------>|
             |(10) Answer          |                     |
             |<------------------------------------------|

                      Figure 11: Race Condition Flow
```

---
### **B.7.  Why Are Keepalives Needed?**

미디어가 후보 쌍에서 흐르기 시작하면 세션 기간 동안 중간 NAT에서 바인딩을 활성 상태로 유지해야 합니다. 일반적으로 미디어 스트림 패킷 자체\(예: RTP\)가 이 목표를 충족합니다. 그러나 몇몇 사례에 대해서는 추가 논의가 필요합니다. 첫째, SIP와 같은 일부 RTP 사용에서는 미디어 스트림이 "보류"될 수 있습니다. 이는 RFC 3264 \[RFC3264\]에 정의된 대로 SDP "sendonly" 또는 "inactive" 속성을 사용하여 수행됩니다. RFC 3264는 이러한 경우 미디어 전송을 중단하도록 구현에 지시합니다. 그러나 그렇게 하면 NAT 바인딩이 시간 초과되어 미디어가 보류 상태에서 해제되지 않을 수 있습니다.

둘째, 텍스트 대화용 페이로드 형식\[RFC4103\]과 같은 일부 RTP 페이로드 형식은 간격이 NAT 바인딩 시간 초과를 초과할 정도로 패킷을 드물게 보낼 수 있습니다.

셋째, 묵음 억제를 사용하는 경우 오랜 시간 동안 묵음이 지속되면 NAT 바인딩이 시간 초과될 만큼 오랫동안 미디어 전송이 중단될 수 있습니다.

이러한 이유로 미디어 패킷 자체는 신뢰할 수 없습니다. ICE는 STUN 바인딩 표시를 활용하여 간단한 주기적인 연결 유지를 정의합니다. 이로 인해 대역폭 요구 사항이 매우 예측 가능해지며 QoS 예약이 가능해집니다.

---
### **B.8.  Why Prefer Peer Reflexive Candidates?**

섹션 4.1.2에서는 후보자 유형 및 지역 선호도를 기반으로 후보자의 우선순위를 계산하는 절차를 설명합니다. 해당 섹션에서는 동료 반사 후보자에 대한 유형 선호도가 항상 서버 반사보다 높아야 합니다. 왜 그런 겁니까? 그 이유는 섹션 18의 보안 고려 사항과 관련이 있습니다. 공격자가 에이전트가 잘못된 피어 반사 후보를 사용하도록 하는 것보다 공격자가 에이전트가 잘못된 서버 반사 후보를 사용하도록 하는 것이 훨씬 쉽습니다. 결과적으로, 바인딩 요청을 통한 주소 수집에 대한 공격은 피어 반사 후보를 선호함으로써 ICE에 의해 저지됩니다.

---
### **B.9.  Why Send an Updated Offer?**

섹션 11.1에서는 미디어 전송 규칙을 설명합니다. 두 상담원 모두 ICE 확인이 완료되면 업데이트된 제안을 기다리지 않고 미디어를 보낼 수 있습니다. 실제로 업데이트된 제안의 유일한 목적은 미디어의 기본 대상이 ICE 절차\(우선순위가 가장 높은 후보 쌍이 됨\)에 따라 전송되는 미디어와 일치하도록 SDP를 "수정"하는 것입니다.

그러면 업데이트된 제안/답변 교환이 왜 필요한가요?라는 질문이 생깁니다. 실제로 순수한 제안/응답 환경에서는 그렇지 않습니다. 제안자와 응답자는 ICE를 통해 사용할 후보자에 대해 동의한 후 사용을 시작할 수 있습니다. 상담원 자체에 관한 한 업데이트된 제안/답변은 새로운 정보를 제공하지 않습니다. 그러나 실제로는 신호 경로에 있는 수많은 구성 요소가 SDP 정보를 확인합니다. 여기에는 경로를 벗어난 QoS 예약을 수행하는 엔터티, ALG 및 SBC\(Session Border Controller\)와 같은 NAT 통과 구성 요소, 네트워크를 수동적으로 모니터링하는 진단 도구가 포함됩니다. 이러한 도구가 변경 없이 계속 작동하려면 미디어에 사용되는 주소의 기존 ICE 정의\(m 및 c 라인 및 rtcp 속성\)가 유지되어야 한다는 SDP의 핵심 속성이 유지되어야 합니다. 이러한 이유로 업데이트된 제안을 보내야 합니다.

---
### **B.10.  Why Are Binding Indications Used for Keepalives?**

미디어 킵얼라이브는 섹션 10에 설명되어 있습니다. 이러한 킵얼라이브는 두 엔드포인트 모두 ICE를 지원하는 경우 STUN을 사용합니다. 그러나 바인딩 요청 트랜잭션\(응답 생성\)을 사용하는 대신 Keepalive는 표시를 사용합니다. 왜 그런 겁니까?

주된 이유는 네트워크 QoS 메커니즘과 관련이 있습니다. 미디어 흐름이 시작되면 네트워크 요소는 미디어 스트림이 지터 가능성과 함께 고정된 간격으로 주기적인 패킷을 사용하는 상당히 규칙적인 구조를 가지고 있다고 가정합니다. 에이전트가 미디어 패킷을 보낸 다음 바인딩 요청을 받으면 미디어 패킷과 함께 응답 패킷을 생성해야 합니다. 이로 인해 미디어 패킷을 전달하는 5튜플에 대한 실제 대역폭 요구 사항이 증가하고 해당 패킷 전달에 지터가 발생합니다. 분석에 따르면 이는 미디어에 상당히 엄격한 패킷 스케줄러를 사용하는 특정 레이어 2 액세스 네트워크에서 문제가 되는 것으로 나타났습니다.

또한 바인딩 표시를 사용하면 무결성을 비활성화하여 성능을 향상할 수 있습니다. 이는 PSTN 게이트웨이 및 SBC와 같은 대규모 끝점에 유용합니다.

---
### **B.11.  Why Is the Conflict Resolution Mechanism Needed?**

ICE가 두 피어 사이에서 실행되면 한 에이전트는 제어되는 에이전트로 작동하고 다른 에이전트는 제어하는 ​​에이전트로 작동합니다. 규칙은 누가 제어하고 누가 제어되는지를 결정하기 위해 구현 유형 및 제공자/응답자의 함수로 정의됩니다. 그러나 사양에는 어떤 경우에는 양측이 자신이 통제하고 있다고 믿을 수도 있고 양측이 통제되고 있다고 믿을 수도 있다고 언급되어 있습니다. 어떻게 이런 일이 일어날 수 있습니까?

두 상담원 모두 자신이 통제되고 있다고 믿는 조건은 제3자 통화 통제 사례에 나타납니다. 다음 흐름을 고려하세요.

```text
             A         Controller          B
             |(1) INV()     |              |
             |<-------------|              |
             |(2) 200(SDP1) |              |
             |------------->|              |
             |              |(3) INV()     |
             |              |------------->|
             |              |(4) 200(SDP2) |
             |              |<-------------|
             |(5) ACK(SDP2) |              |
             |<-------------|              |
             |              |(6) ACK(SDP1) |
             |              |------------->|

                       Figure 12: Role Conflict Flow
```

이 흐름은 RFC 3725\[RFC3725\]의 흐름 III에 대한 변형입니다. 실제로 더 적은 수의 메시지를 생성하므로 흐름 III보다 더 잘 작동합니다. 이 흐름에서 컨트롤러는 에이전트 A에게 제안 없는 INVITE를 보냅니다.

SDP1이라는 제안으로 응답합니다. 그런 다음 에이전트는 에이전트 B에게 제안 없는 INVITE를 보내고 에이전트 B는 제안인 SDP2로 응답합니다. 그런 다음 컨트롤러는 각 에이전트의 제안을 사용하여 답변을 생성합니다. 이 흐름을 사용하면 ICE는 에이전트 A와 B 사이에서 실행되지만 둘 다 자신이 제어 역할을 하고 있다고 믿습니다. 역할 충돌 해결 절차를 사용하면 ICE를 사용할 때 이 흐름이 제대로 작동합니다.

현재로서는 두 에이전트가 모두 제어된다고 믿는 경우가 발생할 수 있는 문서화된 흐름이 없습니다. 그러나 충돌 해결 절차에서는 이 범주에 맞는 흐름이 발생하는 경우 이 경우를 허용합니다.

---
# **Author's Address**

```text
   Jonathan Rosenberg
   jdrosen.net
   Monmouth, NJ
   US

   Email: jdrosen@jdrosen.net
   URI:   http://www.jdrosen.net
```
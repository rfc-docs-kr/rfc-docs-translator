

```text
Network Working Group                                         A. Bhushan
Request for Comments: 114                                MIT Project MAC
NIC: 5823                                                  16 April 1971
```

- 파일 전송 프로토콜

---
## **I. Introduction**

컴퓨터 네트워크 사용은 직접 및 간접의 두 가지 광범위한 범주로 나눌 수 있습니다. 직접 사용은 네트워크 사용자가 원격 호스트에 "로그인"되어 이를 로컬 사용자로 사용한다는 의미입니다. 터미널\(텔레타이프라이터, 그래픽 콘솔\) 또는 컴퓨터를 통해 원격 시스템과 상호 작용합니다. 터미널 특성의 차이는 표준 프로토콜\(예: 텔레타이프라이터 통신용 TELNET\(RFC 97\), 원격 작업 입력용 NETRJS\(RFC 88\)\)에 따라 호스트 시스템 프로그램에서 처리됩니다. 그러나 원격 시스템을 사용하려면 원격 시스템의 다양한 규칙을 알아야 합니다.

이와 대조적으로 간접 사용의 경우 명시적으로 원격 시스템에 로그인하거나 원격 시스템을 "사용"하는 방법을 알 필요가 없습니다. 중간 프로세스를 통해 명령과 규칙의 차이점이 대부분 눈에 보이지 않게 됩니다. 예를 들어, 원격 파일 시스템을 활용하려면 로컬 시스템에 대한 표준 네트워크 파일 전송 명령 세트만 알고 있으면 됩니다. 이는 공통 프로토콜을 통해 협력하는 각 호스트에 네트워크 파일 전송 프로세스가 존재한다고 가정합니다.

간접 사용은 파일 전송에만 국한되지 않습니다. 여기에는 원격 호스트에서의 프로그램 실행과 핵심 이미지 전송이 포함될 수 있습니다. 확장된 파일 전송 프로토콜은 컴퓨터 간의 프로그램 및 데이터 교환, 다른 컴퓨터\(아마도 1조 비트 저장 데이터 컴퓨터 포함\)의 저장 및 파일 처리 기능 사용을 용이하게 하며 원격 호스트의 프로그램이 사용자의 입력 및 출력을 반환합니다.

여기에 설명된 프로토콜은 MIT의 두 호스트인 GE645/Multics 및 PDP-10/DM/CG-ITS\(및 Harvard의 PDP-10\)에서 즉시 구현하기 위해 개발되었습니다. 기능이 제한된 임시 버전은 현재 디버깅 단계에 있습니다. \[1\] 우리의 구현에는 서로 다른 파일 시스템\(Multics는 정교한 액세스 제어를 제공하고 ITS는 아무것도 제공하지 않음\)을 가진 두 개의 서로 다른 시스템\(Multics는 "서비스" 시스템, ITS는 아님\)이 포함되어 있으므로 제안된 파일 전송 메커니즘이 일반화 가능하다고 생각합니다. 또한 우리의 사양은 네트워크의 다른 파일 시스템에 대한 고려 사항을 반영합니다. 네트워크 호스트에 대한 조사 \[2\]를 실시했습니다.

요구 사항과 기능을 결정하는 시스템입니다. 이 문서는 네트워크의 모든 호스트에 있는 사용자가 모든 협력 호스트의 파일 시스템을 사용할 수 있도록 하는 프로토콜에 대한 "첫 번째 부분"입니다.

---
## **II.  Discussion**

프로토콜을 논의하기 전에 몇 가지 정의가 필요합니다. 파일은 컴퓨터 명령 및/또는 데이터로 구성된 주문된 세트입니다. 파일의 길이는 임의일 수 있습니다\[3\]. 명명된 파일은 파일 이름과 디렉터리 이름으로 시스템에서 고유하게 식별됩니다. 디렉터리 이름은 물리적 디렉터리의 이름일 수도 있고 물리적 장치의 이름일 수도 있습니다. 물리적 디렉터리 이름의 예는 소유자의 프로젝트 프로그래머 번호이고 물리적 장치 이름의 예는 테이프 번호입니다.

파일에는 연결된 액세스 제어가 있을 수도 있고 없을 수도 있습니다. 액세스 제어는 사용자의 액세스 권한을 지정합니다. 액세스 제어가 없으면 우발적이거나 무단 사용으로부터 파일을 보호할 수 없습니다.

프로토콜의 주요 목적은 네트워크에서 컴퓨터의 간접적인 사용을 촉진하는 것입니다. 따라서 사용자 또는 사용자의 프로그램은 네트워크의 파일 시스템에 대해 간단하고 균일한 인터페이스를 가져야 하며 다양한 호스트 컴퓨터의 파일 및 저장 시스템의 변형으로부터 보호되어야 합니다. 이는 각 호스트에 표준 프로토콜이 존재함으로써 달성됩니다.

사용자 수준 프로토콜을 판단할 수 있는 기준은 논리적 레코드의 개념, 프로그램 수정 없이 파일에 액세스하는 능력 및 구현 가능성과 관련된 것으로 Mealy에 의해 RFC 91에 설명되어 있습니다. 이러한 효율성, 확장성, 적응성 및 오류 복구 메커니즘 제공에 추가하겠습니다.

이 사양의 시도는 네트워크 ASCII\(가장 왼쪽 비트가 0인 8비트 필드의 7비트 ASCII\)뿐만 아니라 "바이너리" 데이터 파일의 안정적인 전송을 비교적 쉽게 가능하게 하는 것이었습니다. EBCDIC와 같은 다른 문자 코드와 다양한 형식의 데이터\(10진수, 8진수, 다르게 포장된 ASCII 문자\)의 사용은 설명자 제목에 데이터 유형을 포함함으로써 용이해집니다. 데이터 정의를 위한 대체 메커니즘은 파일 제목의 속성 형태로도 사용할 수 있습니다. 이 프로토콜의 구문을 위해 예약된 형식 제어 문자는 ASCII 및 EBCDIC에서 동일한 코드 표현을 갖습니다. \(해당 문자는 SOH, STX, ETX, DC1, DC2, DC3, US, RS, GS 및 FS입니다.\)

여기서는 메시지\(NCP 간에 전달되는 데이터의 물리적 블록\) 개념을 억제하고 "논리적" 기록 및 트랜잭션 개념을 강조합니다. NCP가 전달한 데이터는 섹션 III에 설명된 대로 간단한 설명자\(코드 및 카운트 메커니즘\)를 사용하여 논리적 블록으로 구문 분석됩니다. 개수에 대한 대안은 고정 길이 블록 또는 표준 파일 끝 문자\(스캔 데이터 스트림\)입니다. 둘 다 개수보다 덜 바람직해 보입니다.

협력 프로세스는 합의된 소켓을 "수신"하고 "로거"와 동일한 방식으로 초기 연결 프로토콜을 따르는 "데몬" 프로세스일 수 있습니다. 데이터와 제어 정보 모두의 교환을 위해 단일 전이중 연결을 사용하고\[4\], 필요한 경우 동기화를 달성하기 위해 CLS를 사용하는 것이 좋습니다\(RFNM이 수신될 때까지 CLS는 전송되지 않습니다\).

사용자는 사용 프로세스가 연결 시작 시 사용자 이름 정보\(사용자가 전달했거나 사용 시스템에 알려진 정보\)를 보내도록 하여 식별할 수 있습니다\[5\]. 이 사용자 이름 정보\(표준 ASCII 문자 시퀀스\)는 호스트 번호\(NCP에 알려짐\)와 함께 서비스 제공 프로세스에서 사용자를 확실히 식별합니다.

현재로서는 비밀번호와 같은 보다 정교한 액세스 제어 메커니즘이 제안되지 않습니다. 그러나 사용자는 서비스 제공 시스템에서 제공하는 보안과 보호를 받게 됩니다. 서비스 제공 호스트에 액세스 제어 기능이 있는 경우 다른 호스트 사이트에서 사용자가 권한 없이 액세스하는 것을 방지할 수 있습니다. 자체 사용자가 액세스 규칙을 위반하는 것을 방지하는 것은 사용하는 호스트에 달려 있습니다.

파일 시스템의 파일은 RFC 76\(Bouknight, Madden 및 Grossman\)에 설명된 레이블과 유사한 경로 이름으로 식별됩니다. 경로 이름에는 데이터 저장 및 검색과 관련된 필수 정보가 포함되어 있습니다.

원활한 사용을 위해서는 기본 옵션을 제공해야 합니다. 예를 들어 디스크의 기본 파일 디렉터리는 PDP-10/ITS의 기본값이고 풀 디렉터리는 Multics의 기본값입니다.

전송될 파일은 완전한 파일일 수도 있고 더 작은 레코드로 구성될 수도 있습니다. 제목이 있을 수도 있고 없을 수도 있습니다. 제목에는 파일 속성을 정의하는 ASCII 또는 EBCDIC 문자가 포함되어야 합니다. 파일 속성은 합의된 몇 가지 간단한 유형일 수도 있고, RFC 83\(Anderson, Haslern 및 Heffner\)에 설명된 것과 유사한 데이터 재구성 또는 해석 언어 또는 조합으로 설명될 수도 있습니다.

프로토콜은 파일에 있는 데이터의 성격을 제한하지 않습니다. 예를 들어, 파일에는 ASCII 텍스트, 바이너리 코어 이미지, 그래픽 데이터 또는 기타 유형의 데이터가 포함될 수 있습니다. 프로토콜에는 프로그램인 파일에 대한 "실행" 요청이 포함되어 있습니다. 이는 원격 호스트 컴퓨터에서 프로그램과 서브루틴의 실행을 용이하게 하기 위한 것입니다\[6\].

---
## **III.  SPECIFICATIONS**
---
## **1. Transactions**

1A. 프로토콜은 트랜잭션 지향적입니다. 트랜잭션은 협력 프로세스 간에 전달되는 정보의 개체로 정의됩니다.

```text
   1B.   Syntax
```

- 트랜잭션에는 아래와 같이 72비트 설명자 필드와 가변 길이\(0 포함\) 데이터 및 필러 필드의 세 가지 필드가 있습니다. 트랜잭션의 총 길이는 \(72 + 데이터 + 필러\) 비트입니다.

```text
   | <code><filler count><NUL><data count><NUL> |    <data><filler>   |
   | |____||____________||___||__________||___| |    |____________|   |
   |   |         |         |        |       |   |          |          |
   | 24-bits   8-bits    8-bits  24-bits  8-bits|    variable length  |
   | <-------descriptor field 72-bits---------> |<--data and filler-->|
   |                                            |                     |

   1C.   Semantics
```

- 코드 필드에는 3개의 8비트 바이트가 있습니다. 첫 번째 바이트는 트랜잭션 유형으로 해석되고, 두 번째 바이트는 데이터 유형으로, 세 번째 바이트는 데이터 유형의 확장으로 해석됩니다.

- 필러 카운트는 트랜잭션이 끝날 때 "필러"\(즉, 정보가 아님\)로 사용되는 비트의 이진수입니다\[7\]. 필러 카운트 필드의 길이는 8비트이므로 필러의 비트 수는 255비트를 초과할 수 없습니다.

- 데이터 개수는 필러 비트를 포함하지 않고 데이터 필드에 있는 데이터\(즉, 정보\) 비트 수의 이진수입니다. 데이터 카운트 필드에는 24비트가 있으므로 데이터 비트 수는 \(2^24-1\)로 제한됩니다.

NUL 바이트는 주로 필러로 삽입됩니다.

- 설명자 필드를 사용하여 다양한 단어 길이 기계에 대한 편리한 단어 경계에 개수 정보가 표시되도록 합니다\[8\].

---
## **2.  Transaction Types**

2A. 트랜잭션은 요청, 응답, 전송 및 종료의 네 가지 기본 유형 중 하나일 수 있습니다. 많은 수의 요청 및 전송 유형이 정의되어 있지만 하위 집합의 구현은 특별히 허용됩니다. 특정 트랜잭션 유형이 구현되지 않은 호스트 컴퓨터는 종료 실패로 응답하여 해당 트랜잭션 수락을 거부할 수 있습니다.

- 다음과 같은 거래 유형 코드가 잠정적으로 정의됩니다.

```text
         Transaction Type                       Transaction Type Code

                                             ASCII   Octal   Hexidecimal

         Request
                 Identify                        I       111     49
                 Retrieve                        R       122     52
                 Store                           S       123     53
                 Append                          A       101     41
                 Delete                          D       104     44
                 Rename                          N       116     4E
                 addname (Plus)                  P       120     50
                 deletename (Minus)              M       115     4D
                 Lookup                          L       114     4C
                 Open                            O       117     4F
                 Close                           C       103     43
                 Execute [9]                     E       105     45

         Response
                 ready-to-receive (rr)           <       074     3C
                 ready-to-send (rs)              >       076     3E

         Transfer
                 complete_file                   *       052
                 heading                         #       043     23
                 part_of_file                    '       054     2C
                 last_part                       .       056     2E

         Terminate
                 successful (pos.)               +       053     2B
                 unsuccessful (neg.)             -       055     2D

   2B.   Syntax
```

- 다음 논의에서 US, RS, GS, FS, DC1, DC2, DC3은 ASCII 문자, 단위 구분 기호\(8진수 037\), 레코드 구분 기호\(8진수 036\), 그룹 구분 기호\(8진수 035\), 파일 구분 기호\(8진수 034\)입니다. \), 장치 제어 1\(8진수 021\), 장치 제어 2\(8진수 022\), 장치 제어 3\(8진수 023\)으로 구성됩니다. 이는 EBCDIC에서도 동일한 해석을 갖습니다.

```text
   2B.1  Requests
```

- 요청 식별, 검색, 저장, 추가, 삭제, 열기, 조회 및 실행에는 다음과 같은 데이터 필드가 있습니다.

```text
                       <path name>
```

- 이름 바꾸기 요청에는 다음 데이터 필드가 있습니다.

```text
                       <path name> GS <name>
```

- Addname 및 deletename 요청에는 다음 데이터 필드가 있습니다.

```text
                       <path name> GS <filenames>
```

- 여기서 경로 이름 \[10\], 이름 및 파일 이름은 다음 구문을 갖습니다\(ALGOL 60 보고서의 메타 언어인 BNF로 표현됨\):

```text
         <pathname> ::= <device name>|<name>|<pathname>US<name>
         <device name> ::= DC1<name>
```

<이름\> ::= <문자\> | <이름\> <문자\>

- <char\> ::= 다음을 제외한 모든 8비트 ASCII 또는 EBCDIC 문자

- 미국, RS, GS, FS, DC1, DC2 및 DC3.

```text
         <filenames> ::= <name>|<filenames> RS <name>
```

- 요청 트랜잭션의 데이터 유형은 A\(ASCII의 경우 8진수 101\) 또는 EBCDIC의 경우 E\(8진수 105\)입니다\[11\].

- 경로명의 몇 가지 예는 다음과 같습니다.

```text
         DC1 MT08
         DC1 DSK 1.2 US Net<3> US J.Doe US Foo
         udd US proj. US h,n/x US user US file
         filename 1 filename 2

   2B.2  Responses
```

- 응답 트랜잭션에는 일반적으로 빈 데이터 필드가 있어야 합니다.

```text
   2B.3  Transfers
```

- 섹션 4에 정의된 데이터 유형은 전송 트랜잭션의 데이터 필드 구문을 제어합니다. 다른 구문 제한은 없습니다.

```text
   2B.4  Terminates
```

- 성공적인 종료에는 일반적으로 빈 데이터 필드가 있어야 합니다. 실패한 종료에는 ASCII의 경우 A\(8진수 101\), EBCDIC의 경우 E\(8진수 105\) 또는 상태의 경우 S\(8진수 123\) 데이터 유형으로 정의된 데이터 필드가 있을 수 있습니다.

- 데이터 유형 코드 'S'는 데이터 필드의 바이트 지향 오류 반환 상태 코드를 의미합니다. 다음 오류 반환 상태 코드는 임시적으로 정의됩니다.

```text
         Error Code Meaning                        Error Code
                                             ASCII   Octal  Hexadecimal

         Undefined error                       U       125     55
         Transaction type error                T       124     54
         Syntax error                          S       123     53
         File search failed                    F       106     46
         Data type error                       D       104     44
         Access denied                         A       101     41
         Improper transaction sequence         I       111     49
         Time-out error                        O       117     4F
         Error condition by system             E       105     45

   2C.   Semantics

   2C.1  Requests
```

- 요청은 항상 호스트를 통해 전송됩니다. 장치 이름이나 전체 경로 이름이 없으면 모든 유형의 요청에 대해 기본 옵션을 제공해야 합니다.

\_Identify\_ 요청은 다음과 같이 사용자를 식별합니다.

- <pathname\> 서비스부터 호스트 사용까지.

- \_Retrieve\_ 요청은 <pathname\>에 지정된 파일을 서비스에서 사용 호스트로 전송합니다.

- \_Store\_ 요청은 <pathname\>에 지정된 파일을 사용 중인 호스트에서 제공 호스트로 전송합니다.

- \_Append\_ 요청으로 인해 경로 이름에 지정된 파일에 데이터가 추가됩니다.

```text
         _Rename_ request causes name of file specified in <pathname> to
         be replaced by name specified in <name>.
```

- \_Delete\_ 요청으로 인해 <pathname\>에 지정된 파일이 삭제됩니다. 삭제에 대한 추가 보호 수준이 필요한 경우\(예: '파일 x를 삭제하시겠습니까?'라는 쿼리\) 로컬 구현 옵션입니다.

- \_Addname\_ 및 \_deletename\_ 요청으로 인해 <filenames\>의 이름이 <pathname\>에 지정된 파일의 기존 이름에 추가되거나 삭제됩니다. 이러한 요청은 여러 이름을 파일과 연결할 수 있는 Multics와 같은 시스템에서 유용합니다.

- \_Lookup\_ 요청은 파일 자체가 아닌 <pathname\>에 지정된 파일의 속성\(예: 마지막 수정 날짜, 액세스 목록 등\)을 전송합니다.

- \_Open\_ 요청으로 인해 데이터 전송이 발생하지 않고 대신 <pathname\>에 지정된 파일이 검색\(읽기\) 또는 저장\(쓰기\)을 위해 "열립니다". 후속 요청은 닫기 요청이 수신될 때까지 열린 파일과 관련된 요청으로 처리됩니다.

- \_Execute\_ 요청은 실행 가능한 프로그램이어야 하는 <pathname\>에 지정된 파일을 실행합니다. rr 응답을 받으면 호스트를 사용하여 필요한 입력 데이터\(매개변수, 인수 등\)를 전송합니다. 실행이 완료되면 서비스 제공 호스트는 결과를 사용 호스트에 보내고 종료됩니다 \[12\].

```text
   2C.2  Response
```

- 응답은 항상 서비스 호스트를 통해 전송됩니다. rr 응답은 제공 호스트가 이전 요청에 표시된 파일을 수신할 준비가 되었음을 나타냅니다. rs 응답은 서비스 제공 호스트의 다음 트랜잭션이 이전 요청에 표시된 파일 전송이 될 것임을 나타냅니다.

```text
   2C.3  Transfers
```

- 전송은 두 호스트 모두에서 보낼 수 있습니다. 전송 트랜잭션은 요청에 의해 표시된 파일의 전송을 나타냅니다. 파일은 Complete\_file 트랜잭션 또는 part\_of\_file 트랜잭션과 last\_part 트랜잭션으로 전송될 수 있습니다. 파일의 시작 부분에 제목 트랜잭션이 있을 수도 있습니다. 따라서 파일의 구문은 다음과 같이 정의될 수 있습니다.

```text
         <file> ::= <text> | <heading> <text>
         <text> ::= <complete_file> | <parts> <last_part>
         <parts> ::= <part_of_file> | <parts> <part_of_file>
```

- 제목은 파일의 속성을 전달하는 데 사용될 수 있습니다. 제목의 형식은 공식적으로 지정되지 않지만 이 프로토콜의 가능한 확장으로 섹션 IV에서 논의됩니다.

```text
   2C.4  Terminates
```

- 성공적인 종료는 항상 서비스 제공 호스트에서 전송됩니다. 서비스를 제공하는 호스트가 요청 서비스에 성공하여 초기 상태로 전환되었음을 사용 호스트에게 나타냅니다. 그런 다음 호스트를 사용하면 사용자에게 요청이 성공적으로 처리되었음을 알리고 초기 상태로 이동합니다.

- 실패한 종료는 두 호스트 모두에서 보낼 수 있습니다. 이는 종료를 보낸 사람이 요청을 처리할 수 없음\(또는 원하지 않음\)을 나타냅니다. 그러면 두 호스트 모두 초기 상태로 전환됩니다. 사용 호스트는 사용자에게 요청이 중단되었음을 알립니다. 종료 실패 이유\(텍스트 또는 오류 반환 상태 코드\)가 수신되면 이를 사용자에게 전달해야 합니다.

---
## **3.    Transaction Sequence**

3A. 트랜잭션 시퀀스는 요청에 의해 시작되고 종료에 의해 종료되는 파일 전송의 인스턴스로 정의될 수 있습니다\[13\]. 트랜잭션이 발생하는 정확한 순서는 요청 유형에 따라 다릅니다. 섹션 3C에 설명된 대로 트랜잭션 시퀀스는 어느 호스트에서나 언제든지 중단될 수 있습니다.

```text
   3B.   Examples
```

- 식별 요청은 응답이나 종료를 요구하지 않으며 그 자체로 트랜잭션 시퀀스를 구성합니다.

- 이름 바꾸기, 삭제, 이름 추가, 이름 삭제 및 열기 요청에는 데이터 전송이 포함되지 않지만 종료가 필요합니다. 사용자가 요청을 보내고 서버는 요청에 성공적으로 응했는지 여부에 따라 종료 성공 또는 실패를 보냅니다.

- 검색 및 조회 요청에는 서버에서 사용자로의 데이터 전송이 포함됩니다. 사용자가 요청을 보내고, 서버는 rs로 응답하고, 요청에 지정된 데이터를 전송합니다. 데이터 전송이 완료되면 서버는 모든 것이 잘 진행되면 성공적인 종료로 트랜잭션 시퀀스를 종료하고, 종료에 실패하면 오류가 감지됩니다.

- 저장 및 추가 요청에는 사용자에서 서버로의 데이터 전송이 포함됩니다. 사용자가 요청을 보내고 서버는 rr로 응답합니다. 그런 다음 사용자는 데이터를 전송합니다. 데이터를 수신하면 서버는 시퀀스를 종료합니다.

- 실행 요청에는 사용자에서 서버로의 입력 전송과 서버에서 사용자로의 출력 전송이 포함됩니다. 사용자는 서버가 rr로 응답하는 요청을 보냅니다. 그런 다음 사용자는 필요한 입력을 전송합니다. 서버는 프로그램이나 서브루틴을 "실행"하고 출력을 사용자에게 전송합니다. 출력 전송이 완료되면 서버는 트랜잭션 시퀀스를 종료합니다.

```text
   3C.   Aborts
```

- 호스트 중 하나는 실패한 종료를 보내거나 연결을 닫음\(연결에 대한 CLS를 전송하는 NCP\)을 통해 언제든지 트랜잭션 시퀀스를 중단할 수 있습니다. CLS는 보다 과감한 중단 유형으로, 심각한 오류가 발생하거나 긴 파일 전송 중에 중단이 필요한 경우에 사용해야 합니다. 중단은 다른 호스트가 트랜잭션 시퀀스를 종료하기를 원하며 현재 초기 상태에 있음을 수신 호스트에 나타냅니다. CLS를 사용하여 중단하면 사용 호스트가 연결을 다시 엽니다.

---
## **4.    Data Types**

4A. 확장 코드와 함께 데이터 유형 코드는 데이터 필드가 구문 분석되고 해석되는 방식을 정의합니다\[14\]. 많은 수의 데이터 유형이 정의되어 있지만 특정 구현에서는 데이터 유형의 제한된 하위 집합만 처리할 수 있습니다. 모든 호스트 사이트에서 다음을 수락하는 것이 좋습니다.

- "네트워크 ASCII" 및 "바이너리" 데이터 유형. 특정 데이터 유형을 "인식"하지 못하는 호스트 컴퓨터는 트랜잭션 순서를 중단하고 데이터 유형 오류 상태 코드를 반환할 수 있습니다.

4B. 다음 데이터 유형은 잠정적으로 정의됩니다. 유형 및 확장 필드의 코드는 8번째 비트가 0인 ASCII로 표시됩니다.

```text
        Data Type                                    Code
                                     Byte Size       Type     Extension
ASCII character, bit8=0 (network)       8             A          NUL
```

---
# **ASCII characters, bit8=1                8             A          1**
---
# **ASCII characters, bit8=even parity      8             A          E**
---
# **ASCII characters, bit8=odd parity       8             A          O**
---
# **ASCII characters, 8th bit info.         8             A          8**
---
# **ASCII characters, 7 bits                7             A          7**

```text
ASCII characters, in 9-bit field        9             A          9
ASCII formatted files (with SOH,
        STX, ETX, etc.)                 8             A          F
DEC-packed ASCII (5 7-bit char.,
        36th bit 1 or 0)                36            A          D
EBCDIC characters                       8             E         NUL
SIXBIT characters                       6             S         NUL
Binary data                             1             B         NUL
Binary bytes (size is binary ext.)      1-255         B        (any)
Decimal numbers, net ASCII              8             D          A
Decimal numbers, EBCDIC                 8             D          E
Decimal numbers, sixbit                 6             D          S
Decimal numbers, BCD (binary coded)     4             D          B
Octal numbers, net. ASCII               8             O          A
Octal numbers, EBCDIC                   8             O          E
Octal numbers, SIXBIT                   6             O          S
Hexadecimal numbers, net. ASCII         8             H          A
Hexadecimal numbers, EBCDIC             8             H          E
Hexadecimal numbers, SIXBIT             6             H          S
Unsigned integers, binary (ext.
        field is byte size)             1-225         U        (any)
Sign magnitude integers (field is
        binary size)                    1-255         I        (any)
2's complement integers (ext.
        field is byte size)             1-255         2        (any)
1's complement integers (ext.
        field is byte size)             1-255         1        (any)
Floating point (IBM360)                 32            F          I
Floating point (PDP-10)                 36            F          D
Status codes                            8             S         NUL
```

4C. 데이터 유형 정보는 해석을 위한 것입니다. 호스트가 데이터 유형을 허용하면 이를 문자나 숫자의 내부 표현에 적합한 형식으로 해석할 수 있습니다\[15\]. 특히 변환이 수행되지 않는 경우 사용되는 데이터 유형은 이진입니다. 암시적 또는 명시적 바이트 크기는 데이터 저장을 용이하게 하므로 유용합니다. 예를 들어, PDP-10이 데이터 유형 A, A1, AE 또는 A7을 수신하는 경우 ASCII 문자 5개를 단어\(DEC로 압축된 ASCII\)로 저장할 수 있습니다. 데이터 유형이 A8 또는 A9인 경우 문자 4개를 단어 단위로 저장합니다. 6비트 문자는 한 단어에 6개씩 저장됩니다. 시스템에서 변환 루틴을 사용할 수 있는 경우 시스템 프로그램을 사용하면 데이터를 한 형식에서 다른 형식으로 변환할 수 있습니다\(예: EBCDIC에서 ASCII로, IBM 부동 소수점에서 DEC 부동 소수점으로, 10진수 ASCII에서 정수로 등\).

---
## **5. Initial Connection, CLS, and Identifying Users**

5A. 해당 소켓 번호 \[16\]가 미리 설정되어 있습니다.

- 서빙 호스트에서의 협력 프로세스. 연결 설정은 RFC 80에 의해 수정된 RFC 66의 초기 연결 프로토콜을 따릅니다. NCP 대화 상자는 다음과 같습니다.

```text
              user to server:    RTS<us><3><p>
```

승인된 경우 서버에서 사용자로: STR<3\><us\><CLS\><3\><us\>

- 링크 p의 서버에서 사용자로: <ss\> 서버에서 사용자로: STR<ss+1\><us\>RTS<ss\><us+1\><q\> 사용자에서 서버로: STR<us\><ss+1\>RTS <us+1\><ss\><r\>

- 이는 서버가 링크 q를 통해 원격 소켓 us+1에서 로컬 소켓 ss를 통해 수신하고 링크 r을 통해 로컬 소켓 ss+1을 통해 원격 소켓 us로 보내는 사용자와 서버 프로세스 간의 전이중 연결을 설정합니다.

5B. 두 연결 각각에 대해 NCP 간의 CLS를 거래하면 연결이 끊어집니다. 일반적으로 사용자는 CLS를 시작합니다.

- CLS는 사용자나 서버가 중간에 데이터 전송을 중단하는 데 사용될 수도 있습니다. 트랜잭션 시퀀스 도중에 CLS가 수신되면 전체 트랜잭션 시퀀스가 ​​중단됩니다. 그러면 사용 호스트가 연결을 다시 엽니다.

5C. 사용자에서 서버로의 첫 번째 트랜잭션은 식별 트랜잭션입니다. 사용자는 트랜잭션의 데이터 필드에 있는 경로 이름으로 식별됩니다.

- 서버에서 허용되는 형식입니다. 서버는 자체 사용을 위해 경로 이름을 자유롭게 자를 수 있습니다. 식별 트랜잭션은 응답이나 종료가 필요하지 않으므로 사용자는 다른 요청을 직접 진행할 수 있습니다.

---
## **IV.  Extensions to Protocol**

위에 지정된 프로토콜은 확장 가능하도록 설계되었습니다. 명백한 확장은 트랜잭션 유형\(새로운 유형의 요청\), 오류 반환 상태 단어 및 데이터 유형 영역에 있습니다. 내가 시각화할 수 있는 명확하지 않은 확장 중 일부는 액세스 제어 메커니즘 제공, 파일 제목에 파일 속성을 지정하는 통일된 방법 개발, 서브루틴 조정을 포함하도록 실행 명령의 범위 증가 및 트랜잭션 시퀀스 제공입니다. 동일한 연결 쌍을 통한 여러 요청 처리를 용이하게 하기 위한 식별 번호입니다.

보호된 파일 시스템의 사용자는 원격 사용자를 올바르게 식별하는 서비스 프로세스의 능력에 대해 합리적인 수준의 확신을 가질 수 있어야 합니다. 이러한 확신이 없으면 일부 사용자는 서비스 프로세스에 대한 액세스 권한\(특히 쓰기 액세스 권한\)을 기꺼이 부여하지 않을 것입니다. 비밀번호와 같은 액세스 제어 메커니즘을 포함하면 개인 정보 보호 및 보안을 염려하는 사용자의 네트워크 간접 사용이 향상될 수 있습니다. 프로토콜에 대한 간단한 확장은 서비스 제공 호스트가 트랜잭션 유형 "password?"를 보내도록 하는 것입니다. 사용자 이름을 받은 후. "비밀번호?"를 받으면 사용 호스트는 성공적으로 승인되면 요청이 진행될 수 있음을 사용자에게 알리는 비밀번호를 전송합니다.

파일 자체나 트랜잭션 설명자의 데이터 유형이 아닌 파일 제목에 적절하게 속하는 파일 속성이 많이 있습니다. 이러한 속성에는 액세스 제어 목록, 파일이 마지막으로 수정된 날짜, 파일 특성에 대한 정보, 데이터 설명 또는 데이터 재구성 언어로 된 내용 설명이 포함됩니다. 파일 속성을 지정하는 방식의 일부 통일성이 유용할 것입니다. 그때까지 제목의 해석은 사용자나 사용 프로세스에 달려 있습니다. 예를 들어, 데이터 재구성\(양식\) 기계에 입력되는 파일의 제목은 재구성 언어로 표현된 원하는 변환일 수 있습니다.

원격 호스트에 있는 프로그램을 실행하는 "실행" 명령은 원격 호스트를 간접적으로 사용하는 데 중요한 부분입니다. 사양에 설명된 대로 현재 실행 명령의 범위는 다소 제한되어 있습니다. 이는 사용자 또는

프로세스를 사용하면 인수와 결과가 교환되어야 하는 방식을 알고 있습니다. 프로그램 조정 프로토콜\[17\]을 도입하여 실행 명령의 범위를 확장할 수 있습니다.

현재 프로토콜 사양에서는 동일한 연결 쌍을 통한 여러 요청의 동시 전송 및 처리를 허용하지 않습니다. 그러한 기능이 필요한 경우 사소한 변경만으로 쉽게 구현할 수 있는 방법이 있습니다. 트랜잭션 시퀀스 식별 번호\(TSid\)는 트랜잭션 설명자의 NUL 필드를 대체할 수 있습니다. TSid는 특정 거래 순서와 관련된 거래 조정을 용이하게 합니다. TSid에서 허용하는 256개의 코드 조합은 라운드 로빈 방식으로 사용됩니다\(실제 구현에서는 두 사용자 프로세스 간에 처리되지 않은 요청이 256개 이상인 것을 볼 수 없습니다\). 요청을 동시에 처리하는 또 다른 방법은 새로운 연결 쌍을 여는 것입니다. 요청을 동시에 처리하는 것이 얼마나 유용한지, 둘 중 어느 것이 더 합리적인 접근 방식인지 잘 모르겠습니다.

---
## **V. Conclusions**

나는 사용자와 프로그램을 사용하여 원격 호스트 컴퓨터를 간접적으로 사용할 수 있도록 허용하는 사용자 수준 프로토콜을 제시하려고 했습니다. 이 프로토콜은 파일 시스템 작업뿐만 아니라 원격 호스트에서의 프로그램 실행도 용이하게 합니다. 이는 협력 프로세스에 의해 처리되는 요청을 정의함으로써 달성됩니다. 트랜잭션 순서 방향은 더 큰 확신을 제공하고 오류 제어를 용이하게 합니다. 데이터 유형의 개념은 개별 호스트 사이트에서 단순하고 제한된 형태의 데이터에 대한 해석, 재구성 및 저장을 용이하게 하기 위해 도입되었습니다. 프로토콜은 쉽게 확장 가능합니다.

---
# **Endnotes**

\[1\] ASCII 파일 전송으로 제한된 프로토콜의 임시 버전은 Project MAC의 Chander Ramchandani와 Howard Brodie가 개발했습니다. 트랜잭션, 설명자, 오류 복구, 중단, 파일 제목 및 속성, 프로그램 실행, 데이터 유형 사용, 경로 이름 및 기본 메커니즘에 대한 아이디어가 여기에 새로 추가되었습니다. Howard Brodie와 Neal Ryan은 각각 PDP-10과 645에 임시 프로토콜을 코딩했습니다.

\[2\] 네트워크 시스템 조사는 지난 가을 Project MAC의 Howard Brodie가 주로 전화를 통해 실시했습니다.

```text
   [3] PDP-10 Reference Handbook, page 306.
```

\[4\] 우리는 두 개의 전이중 링크\(하나는 제어 정보용, 다른 하나는 데이터용\) 사용을 고려했습니다. 협력 프로세스 간에 별도의 제어 링크를 사용하면 중단, 오류 복구 및 동기화가 단순화됩니다. 동기화 기능은 연결을 닫고\(트랜잭션 시퀀스 중간에\) 중단 메시지와 함께 다시 열어 수행할 수도 있습니다. \(NCP 제어 링크를 통해 전송되는 INR 및 INS의 사용에는 Kalin이 RFC 103에서 언급한 것과 같은 문제가 있습니다.\) 우리는 후자의 접근 방식을 선호합니다.

\[5\] 고유한 사용자 식별 번호가 구현되지 않았고, 파일 시스템이 번호가 아닌 이름으로 사용자를 식별하므로 소켓 번호를 사용하여 사용자를 식별하는 것은 실용적이지 않습니다.

\[6\] 이 주제는 곧 나올 논문에서 Bob Metcalfe에 의해 자세히 고려됩니다.

\[7\] NCP의 특정 구현에서는 비트의 자유로운 통신을 허용하지 않을 수 있으므로 필러 비트가 필요할 수 있습니다. 대신 NCP는 RFC 102에 제안된 대로 바이트만 허용할 수 있습니다. 필러 수는 트랜잭션 간의 경계를 결정하는 데 필요합니다.

\[8\] 설명자 필드의 72비트는 ARPA 네트워크 호스트 컴퓨터에서 일반적으로 사용되는 바이트 크기인 6, 8, 9, 18, 24 및 30의 최소 공배수이므로 편리합니다.

\[9\] 실행 요청은 프로그램과 서브루틴의 간접적인 실행을 용이하게 하기 위한 것입니다. 그러나 현재 형태의 이 요청은 제한된 용도로만 사용될 수 있습니다. 실행 기능을 보다 광범위하게 사용하려면 서브루틴 또는 프로그램 중재 프로토콜이 필요합니다. Metcalfe는 곧 나올 논문에서 이 문제를 고려합니다.

\[10\] Multics에서 사용되는 경로 이름 아이디어는 Bouknight, Madden 및 Grossman이 작성한 RFC 76의 레이블 아이디어와 유사합니다.

\[11\] 그러나 우리는 표준 네트워크 ASCII의 사용을 촉구합니다.

\[12\] 입력과 출력이 전송되는 정확한 방식은 특정 중재 규칙에 따라 달라집니다. 데이터 자체 대신 입력 및 출력 파일의 이름이 전송될 수 있습니다.

\[13\] 트랜잭션\(종료 포함\)은 "에코"되지 않습니다. 에코는 "정지" 조건을 해결하지 못하기 때문입니다. 대신 끊김을 방지하기 위해 시간 초과 메커니즘을 사용하는 것이 좋습니다.

\[14\] 여기서 제안하는 데이터 유형 메커니즘은 Harslem과 Heafner가 RFC 83 및 NIC5772에서 제안한 데이터 재구성 서비스를 대체하지 않습니다. 실제로 이는 재구성을 보완합니다. 을 위한

예를 들어, 데이터 재구성 언어는 EBCDIC, 네트워크 ASCII 또는 기계를 구성하는 기타 코드로 표현될 수 있으며 "인식"할 수 있습니다. 후속 데이터는 바이너리로 전송될 수 있으며 양식 기계는 이를 필요한 양식으로 재구성합니다. 나는 개별 호스트 사이트에서 단순한 형태의 데이터에 대한 해석, 재구성 및 저장을 배제하고 싶지 않기 때문에 Harslem과 Heafner가 제안한 많은 수의 데이터 유형을 데이터 유형에 포함시켰습니다.

\[15\] 호스트의 내부 문자 표현은 ASCII에서도 다를 수 있습니다. 예를 들어 PDP-10은 7비트 문자를 저장하며, 단어당 5개\(36비트는 상관 없음\)를 저장하는 반면 Multics는 9비트 필드에 오른쪽 정렬되어 단어당 4개를 저장합니다.

\[16\] 소켓 1은 로거에, 소켓 5는 NETRJS에 할당된 것 같습니다. 소켓 3은 파일 전송 프로세스에 적합한 선택인 것 같습니다.

\[17\] 프로그램 중재라는 용어는 이 주제에 관한 논문을 쓰려고 했던 Bob Metcalfe에 의해 제안되었습니다.

- \[ 이 RFC는 입력을 위해 기계 판독 가능한 형식으로 작성되었습니다. \] \[ 6월 1일 Ryan Kato가 온라인 RFC 아카이브에 입력함\]
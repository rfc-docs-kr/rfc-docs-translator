

```text
Network Working Group                                        E. Rescorla
Request for Comments: 3552                                    RTFM, Inc.
BCP: 72                                                        B. Korver
Category: Best Current Practice                          Xythos Software
                                             Internet Architecture Board
                                                                     IAB
                                                               July 2003

       Guidelines for Writing RFC Text on Security Considerations
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 모범 사례를 명시하고 개선을 위한 토론과 제안을 요청합니다. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

---
# **Abstract**

모든 RFC에는 보안 고려 사항 섹션이 있어야 합니다. 역사적으로 이러한 섹션은 상대적으로 약했습니다. 이 문서는 RFC 작성자에게 좋은 보안 고려 사항 섹션을 작성하는 방법에 대한 지침을 제공합니다.

---
# **Table of Contents**

```text
   1. Introduction . . . . . . . . . . . . . . . . . . . . . . .   3
      1.1. Requirements. . . . . . . . . . . . . . . . . . . . .   3
   2. The Goals of Security. . . . . . . . . . . . . . . . . . .   3
      2.1. Communication Security. . . . . . . . . . . . . . . .   3
           2.1.1. Confidentiality. . . . . . . . . . . . . . . .   4
           2.1.2. Data Integrity . . . . . . . . . . . . . . . .   4
           2.1.3. Peer Entity authentication . . . . . . . . . .   4
      2.2. Non-Repudiation . . . . . . . . . . . . . . . . . . .   5
      2.3. Systems Security. . . . . . . . . . . . . . . . . . .   5
           2.3.1. Unauthorized Usage . . . . . . . . . . . . . .   6
           2.3.2. Inappropriate Usage. . . . . . . . . . . . . .   6
           2.3.3. Denial of Service. . . . . . . . . . . . . . .   6
   3. The Internet Threat Model. . . . . . . . . . . . . . . . .   6
      3.1. Limited Threat Models . . . . . . . . . . . . . . . .   7
      3.2. Passive Attacks . . . . . . . . . . . . . . . . . . .   7
           3.2.1. Confidentiality Violations . . . . . . . . . .   8
           3.2.2. Password Sniffing. . . . . . . . . . . . . . .   8
           3.2.3. Offline Cryptographic Attacks. . . . . . . . .   9
      3.3. Active Attacks. . . . . . . . . . . . . . . . . . . .   9
           3.3.1. Replay Attacks . . . . . . . . . . . . . . . .  10
           3.3.2. Message Insertion. . . . . . . . . . . . . . .  10
           3.3.3. Message Deletion . . . . . . . . . . . . . . .  11
           3.3.4. Message Modification . . . . . . . . . . . . .  11
           3.3.5. Man-In-The-Middle. . . . . . . . . . . . . . .  12
      3.4. Topological Issues. . . . . . . . . . . . . . . . . .  12
      3.5. On-path versus off-path . . . . . . . . . . . . . . .  13
      3.6. Link-local. . . . . . . . . . . . . . . . . . . . . .  13
   4. Common Issues. . . . . . . . . . . . . . . . . . . . . . .  13
      4.1. User Authentication . . . . . . . . . . . . . . . . .  14
           4.1.1. Username/Password. . . . . . . . . . . . . . .  14
           4.1.2. Challenge Response and One Time Passwords. . .  14
           4.1.3. Shared Keys. . . . . . . . . . . . . . . . . .  15
           4.1.4. Key Distribution Centers . . . . . . . . . . .  15
           4.1.5. Certificates . . . . . . . . . . . . . . . . .  15
           4.1.6. Some Uncommon Systems. . . . . . . . . . . . .  15
           4.1.7. Host Authentication. . . . . . . . . . . . . .  16
      4.2. Generic Security Frameworks . . . . . . . . . . . . .  16
      4.3. Non-repudiation . . . . . . . . . . . . . . . . . . .  17
      4.4. Authorization vs. Authentication. . . . . . . . . . .  18
           4.4.1. Access Control Lists . . . . . . . . . . . . .  18
           4.4.2. Certificate Based Systems. . . . . . . . . . .  18
      4.5. Providing Traffic Security. . . . . . . . . . . . . .  19
           4.5.1. IPsec. . . . . . . . . . . . . . . . . . . . .  19
           4.5.2. SSL/TLS. . . . . . . . . . . . . . . . . . . .  20
           4.5.3. Remote Login . . . . . . . . . . . . . . . . .  22
      4.6. Denial of Service Attacks and Countermeasures . . . .  22
           4.6.1. Blind Denial of Service. . . . . . . . . . . .  23
           4.6.2. Distributed Denial of Service. . . . . . . . .  23
           4.6.3. Avoiding Denial of Service . . . . . . . . . .  24
           4.6.4. Example: TCP SYN Floods. . . . . . . . . . . .  24
           4.6.5. Example: Photuris. . . . . . . . . . . . . . .  25
      4.7. Object vs. Channel Security . . . . . . . . . . . . .  25
      4.8. Firewalls and Network Topology. . . . . . . . . . . .  26
   5. Writing Security Considerations Sections . . . . . . . . .  26
   6. Examples . . . . . . . . . . . . . . . . . . . . . . . . .  28
      6.1. SMTP. . . . . . . . . . . . . . . . . . . . . . . . .  29
           6.1.1. Security Considerations. . . . . . . . . . . .  29
           6.1.2. Communications security issues . . . . . . . .  34
           6.1.3. Denial of Service. . . . . . . . . . . . . . .  36
      6.2. VRRP. . . . . . . . . . . . . . . . . . . . . . . . . .36
           6.2.1. Security Considerations. . . . . . . . . . . .  36
   7. Acknowledgments. . . . . . . . . . . . . . . . . . . . . .  38
   8. Normative References . . . . . . . . . . . . . . . . . . .  39
   9. Informative References . . . . . . . . . . . . . . . . . .  41
   10.Security Considerations. . . . . . . . . . . . . . . . . .  42
   Appendix A. . . . . . . . . . . . . . . . . . . . . . . . . .  43
   Authors' Addresses. . . . . . . . . . . . . . . . . . . . . .  43
   Full Copyright Statement. . . . . . . . . . . . . . . . . . .  44
```

---
## **1. Introduction**

RFC 2223에서는 모든 RFC에 보안 고려 사항 섹션을 포함해야 합니다. 이것의 목적은 문서 작성자가 설계 시 보안을 고려하도록 장려하고 독자에게 관련 보안 문제를 알리는 것입니다. 이 메모는 양측 모두를 위해 RFC 작성자에게 지침을 제공하기 위한 것입니다.

이 문서는 세 부분으로 구성되어 있습니다. 첫 번째는 보안 튜토리얼과 일반 용어 정의를 결합한 것입니다. 두 번째는 보안 고려사항 작성을 위한 일련의 지침입니다. 세 번째는 일련의 예입니다.

---
### **1.1. Requirements**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. BCP 14, RFC 2119 \[키워드\]에 설명된 대로 해석됩니다.

---
## **2. The Goals of Security**

대부분의 사람들은 보안이 프로토콜이나 시스템의 단일한 단일 속성인 것처럼 이야기하지만, 곰곰히 생각해 보면 그것이 분명히 사실이 아니라는 것을 깨닫게 됩니다. 오히려 보안은 일련의 관련되어 있지만 다소 독립적인 속성입니다. 모든 애플리케이션에 이러한 속성이 모두 필요한 것은 아닙니다.

보안 목표를 통신 보호\(COMSEC라고도 알려진 통신 보안\)와 관련된 목표와 시스템 보호\(관리 보안 또는 시스템 보안\)와 관련된 목표로 느슨하게 나눌 수 있습니다. 통신은 시스템에 의해 수행되고 시스템에 대한 액세스는 통신 채널을 통해 이루어지기 때문에 이러한 목표는 분명히 연동되지만 독립적으로 제공될 수도 있습니다.

---
### **2.1. Communication Security**

저자마다 통신 보안의 목표를 다르게 구분합니다. 우리가 가장 유용하다고 생각하는 분할은 이를 기밀성, 데이터 무결성 및 피어 엔터티 인증의 세 가지 주요 범주로 나누는 것입니다.

---
#### **2.1.1. Confidentiality**

대부분의 사람들은 보안에 대해 생각할 때 기밀성을 생각합니다. 기밀성은 귀하의 데이터가 의도하지 않은 청취자로부터 비밀로 유지된다는 것을 의미합니다. 일반적으로 이러한 청취자는 단순히 도청자입니다. 적이 귀하의 전화기를 도청하면 귀하의 기밀이 위협받을 수 있습니다.

분명히, 당신에게 비밀이 있다면 다른 사람들이 그 비밀을 발견하는 것에 대해 걱정할 것입니다. 따라서 최소한 기밀을 유지하고 싶습니다. 영화에서 스파이가 화장실에 들어가서 도청을 막기 위해 물을 모두 틀 때 그들이 찾고 있는 재산은 기밀입니다.

---
#### **2.1.2. Data Integrity**

두 번째 주요 목표는 데이터 무결성입니다. 여기서의 기본 아이디어는 우리가 수신한 데이터가 보낸 사람이 보낸 데이터와 동일한지 확인하려는 것입니다. 종이 기반 시스템에서는 일부 데이터 무결성이 자동으로 제공됩니다. 펜으로 쓴 편지를 받으면 펜 자국은 종이에서 제거하기 어렵기 때문에 공격자가 어떤 단어도 제거하지 않았음을 상당히 확신할 수 있습니다. 그러나 공격자는 쉽게 종이에 일부 표시를 추가하여 메시지의 의미를 완전히 바꿀 수 있었습니다. 마찬가지로 메시지를 자르기 위해 페이지를 줄이는 것도 쉽습니다.

반면에 전자 세계에서는 모든 비트가 비슷해 보이기 때문에 전송 중인 메시지를 변조하는 것이 쉬운 일이 아닙니다. 단순히 전선에서 메시지를 제거하고, 원하는 부분을 복사하고, 원하는 데이터를 추가하고, 선택한 새 메시지를 생성하면 수신자가 더 현명해지지 않습니다. 이것은 공격자가 당신이 쓴 편지를 가져다가 새 종이를 사서 메시지를 다시 복사하고 그대로 바꾸는 것과 도덕적으로 동일합니다. 모든 비트가 비슷해 보이기 때문에 전자적으로 수행하는 것이 훨씬 쉽습니다.

---
#### **2.1.3. Peer Entity authentication**

우리가 관심을 갖는 세 번째 속성은 PEER ENTITY AUTHENTICATION입니다. 이것이 의미하는 바는 통신의 끝점 중 하나가 우리가 의도한 끝점임을 안다는 것입니다. 피어 엔터티 인증이 없으면 기밀성이나 데이터 무결성을 제공하기가 매우 어렵습니다. 예를 들어, Alice로부터 메시지를 받은 경우, 해당 메시지가 실제로 공격자가 아니라 Alice가 보낸 것임을 알지 못하는 한 데이터 무결성 속성은 우리에게 큰 도움이 되지 않습니다. 마찬가지로 Bob에게 기밀 메시지를 보내려고 할 때 실제로 공격자에게 기밀 메시지를 보내는 것은 우리에게 별 가치가 없습니다.

피어 엔터티 인증은 비대칭적으로 제공될 수 있습니다. 전화로 누군가에게 전화를 걸면 올바른 사람이 있는지 또는 적어도 실제로 전화한 전화번호에 있는 사람이 있는지 상당히 확신할 수 있습니다. 반면에 발신자 ID가 없으면 전화를 받는 사람은 자신에게 전화한 사람이 누구인지 알 수 없습니다. 전화로 누군가에게 전화하는 것은 수신자 인증의 한 예입니다. 전화의 수신자가 누구인지 알지만 발신자에 대해서는 아무것도 모르기 때문입니다.

메시징 상황에서는 특정 메시지를 보낸 사람의 신원을 확인하기 위해 피어 엔터티 인증을 사용하려는 경우가 많습니다. 이러한 맥락에서 이 속성을 DATA ORIGIN AUTHENTICATION이라고 합니다.

---
### **2.2. Non-Repudiation**

엔드포인트 인증을 제공하는 시스템을 통해 한 당사자는 자신이 통신하는 사람의 신원을 확신할 수 있습니다. 시스템이 데이터 무결성을 제공하면 수신자는 발신자의 신원과 발신자가 보내려고 했던 데이터를 수신하고 있음을 확신할 수 있습니다. 그러나 반드시 이 사실을 제3자에게 입증할 수는 없습니다. 이러한 증명을 할 수 있는 능력을 부인방지\(NON-REPUDIATION\)라고 합니다.

부인방지가 바람직한 상황은 많이 있습니다. 두 당사자가 계약을 체결했지만 일방이 일방적으로 파기하려는 상황을 생각해 보십시오. 그는 애초에 자신이 서명한 적이 없다고 단순히 주장할 수도 있습니다. 부인방지는 그가 그렇게 하는 것을 방지하여 상대방을 보호합니다.

불행히도, 부인방지는 실제로 달성하기가 매우 어려울 수 있으며 순진한 접근 방식은 일반적으로 부적절합니다. 섹션 4.3에서는 일반적으로 두 당사자의 이해관계가 일치하지 않는다는 사실에서 비롯되는 몇 가지 어려움에 대해 설명합니다. 즉, 한 당사자는 다른 당사자가 거부하고 싶어하는 것을 증명하려고 합니다.

---
### **2.3. Systems Security**

일반적으로 시스템 보안은 시스템과 데이터를 보호하는 것과 관련이 있습니다. 그 목적은 승인된 사용자만이 기계를 소유자가 의도한 목적으로만 사용해야 한다는 것입니다. 또한 이러한 목적으로 사용할 수 있어야 합니다. 공격자는 합법적인 사용자의 리소스를 빼앗을 수 없어야 합니다.

---
#### **2.3.1. Unauthorized Usage**

대부분의 시스템은 대중이 완전히 접근할 수 있도록 설계되지 않았습니다. 오히려 승인된 특정 개인만 사용하도록 고안되었습니다. 모든 인터넷 사용자가 많은 인터넷 서비스를 사용할 수 있지만 이러한 서버도 일반적으로 특정 사용자에게 더 큰 서비스 하위 집합을 제공합니다. 예를 들어 웹 서버는 모든 사용자에게 데이터를 제공하지만 페이지를 수정하는 기능을 특정 사용자로 제한하는 경우가 많습니다. 일반 대중에 의한 그러한 수정은 무단 사용이 됩니다.

---
#### **2.3.2. Inappropriate Usage**

인증된 사용자가 된다고 해서 시스템을 자유롭게 실행할 수 있다는 의미는 아닙니다. 위에서 말했듯이 일부 활동은 승인된 사용자에게만 제한되고, 일부 활동은 특정 사용자에게만 제한되며, 일부 활동은 일반적으로 관리자를 제외한 모든 사람에게 금지됩니다. 또한, 일반적으로 허용되는 활동이라도 어떤 경우에는 금지될 수 있습니다. 예를 들어, 사용자에게 이메일 전송은 허용되지만 특정 크기 이상의 파일이나 바이러스가 포함된 파일 전송은 금지될 수 있습니다. 이는 부적절한 사용의 예입니다.

---
#### **2.3.3. Denial of Service**

우리의 세 번째 목표는 합법적인 사용자가 시스템을 사용할 수 있어야 한다는 것이었습니다. 이러한 사용을 위협하는 다양한 공격이 가능합니다. 이러한 공격을 집합적으로 서비스 거부\(DENIAL OF SERVICE\) 공격이라고 합니다. 서비스 거부 공격은 실행하기가 매우 쉽고 중지하기 어려운 경우가 많습니다. 이러한 공격 중 다수는 시스템 리소스를 소비하도록 설계되어 합법적인 사용자에게 서비스를 제공하는 것을 어렵거나 불가능하게 만듭니다. 다른 공격으로 인해 대상 시스템이 충돌하여 사용자에 대한 서비스가 완전히 거부됩니다.

---
## **3. The Internet Threat Model**

위협 모델은 공격자가 리소스에 대해 배포할 수 있다고 가정되는 기능을 설명합니다. 여기에는 정보, 컴퓨팅 기능, 시스템 제어 측면에서 공격자가 사용할 수 있는 리소스와 같은 정보가 포함되어야 합니다. 위협 모델의 목적은 두 가지입니다. 먼저, 우리가 우려하고 있는 위협을 확인하고 싶습니다. 둘째, 우리는 명시적으로 범위를 벗어나는 일부 위협을 배제하고자 합니다. 거의 모든 보안 시스템은 충분히 헌신적이고 유능한 공격자에게 취약합니다.

인터넷 환경에는 상당히 잘 이해된 위협 모델이 있습니다. 일반적으로 우리는 프로토콜 교환에 참여하는 최종 시스템 자체가 손상되지 않았다고 가정합니다. 최종 시스템 중 하나가 손상되었을 때 공격으로부터 보호하는 것은

매우 어렵습니다. 그러나 이러한 상황에서 발생하는 피해 정도를 최소화하는 프로토콜을 설계하는 것은 가능합니다.

대조적으로, 공격자는 최종 시스템이 통신하는 통신 채널을 거의 완벽하게 제어할 수 있다고 가정합니다. 이는 공격자가 네트워크의 모든 PDU\(프로토콜 데이터 단위\)를 읽고 감지할 수 없게 위조된 패킷을 제거, 변경 또는 회선에 주입할 수 있음을 의미합니다. 여기에는 신뢰할 수 있는 시스템에서 온 것처럼 보이는 패킷을 생성할 수 있는 기능이 포함됩니다. 따라서 통신하려는 최종 시스템 자체가 안전하더라도 인터넷 환경은 해당 시스템에서 발생한다고 주장하는 패킷이 실제로 안전하다는 보장을 제공하지 않습니다.

PDU의 의미는 수준에 따라 다르다는 점을 인식하는 것이 중요합니다. IP 수준에서 PDU는 IP 패킷을 의미합니다. TCP 수준에서는 TCP 세그먼트를 의미합니다. 애플리케이션 계층에서는 일종의 애플리케이션 PDU를 의미합니다. 예를 들어 이메일 수준에서는 RFC-822 메시지 또는 단일 SMTP 명령을 의미할 수 있습니다. HTTP 수준에서는 요청이나 응답을 의미할 수 있습니다.

---
### **3.1. Limited Threat Models**

앞서 말했듯이, 수완이 풍부하고 헌신적인 공격자는 전체 통신 채널을 제어할 수 있습니다. 그러나 더 적은 자원을 가진 공격자가 많은 수의 공격을 수행할 수 있습니다. 현재 알려진 다수의 공격은 네트워크에 대한 제한된 제어를 통해 공격자가 수행할 수 있습니다. 예를 들어 임의의 패킷만 읽을 수 있는 공격자가 비밀번호 스니핑 공격을 수행할 수 있습니다. 이는 일반적으로 수동 공격 \[INTAUTH\]이라고 합니다.

대조적으로, Morris의 시퀀스 번호 추측 공격 \[SEQNUM\]은 임의의 패킷을 쓸 수는 있지만 읽을 수는 없는 공격자에 의해 탑재될 수 있습니다. 공격자가 네트워크에 기록해야 하는 모든 공격을 활성 공격이라고 합니다.

따라서 공격을 구성하는 유용한 방법은 공격을 수행하는 데 필요한 기능을 기준으로 공격을 나누는 것입니다. 이 섹션의 나머지 부분에서는 이러한 범주를 설명하고 각 범주의 몇 가지 예를 제공합니다.

---
### **3.2. Passive Attacks**

수동적 공격에서는 공격자가 네트워크에서 패킷을 읽기는 하지만 쓰지는 않습니다. 이러한 공격을 수행하는 가장 간단한 방법은 피해자와 동일한 LAN에 있는 것입니다. 이더넷, 802.3 및 FDDI를 포함한 가장 일반적인 LAN 구성에서 회선의 모든 시스템은 네트워크의 다른 시스템으로 향하는 모든 트래픽을 읽을 수 있습니다.

같은 LAN. 스위칭 허브를 사용하면 이러한 종류의 스니핑이 훨씬 더 어려워집니다. 왜냐하면 특정 시스템으로 향하는 트래픽은 해당 시스템이 있는 네트워크 세그먼트로만 이동하기 때문입니다.

마찬가지로 두 피해자 컴퓨터 간의 통신 경로에서 호스트를 제어하는 ​​공격자는 해당 컴퓨터의 통신에 수동적 공격을 가할 수 있습니다. 트래픽이 손상된 시스템을 통과하도록 구체적으로 배열하기 위해 라우팅 인프라를 손상시키는 것도 가능합니다. 여기에는 피해자 시스템에 대한 수동적 공격을 용이하게 하기 위해 라우팅 인프라에 대한 능동적 공격이 포함될 수 있습니다.

무선 통신 채널은 특히 802.11을 사용하는 LAN과 같은 최근 무선 기반 LAN의 인기가 높아지고 있는 상황에서 특별히 고려할 가치가 있습니다. 데이터는 단순히 잘 알려진 무선 주파수로 방송되므로 공격자는 해당 전송을 수신할 수만 있으면 됩니다. 이러한 채널은 특히 수동적 공격에 취약합니다. 이러한 채널에는 암호화 보호 기능이 포함되어 있지만 품질이 좋지 않아 거의 쓸모가 없는 경우가 많습니다\[WEP\].

일반적으로 수동적 공격의 목표는 송신자와 수신자가 비공개로 유지하기를 원하는 정보를 얻는 것입니다. 이러한 개인 정보에는 전자 세계에서 유용한 자격 증명 및/또는 비즈니스 기밀 정보와 같이 외부 세계에서 유용한 암호 또는 자격 증명이 포함될 수 있습니다.

---
#### **3.2.1. Confidentiality Violations**

수동적 공격의 전형적인 예는 본질적으로 일부 개인 데이터를 회선에서 스니핑하는 것입니다. 예를 들어, SSL의 광범위한 가용성에도 불구하고 많은 신용카드 거래가 여전히 인터넷을 통해 암호화되지 않고 이루어지고 있습니다. 공격자는 이러한 메시지를 스니핑하여 신용카드 번호를 알아낸 후 사기 거래에 사용될 수 있습니다. 더욱이, 기밀 비즈니스 정보는 이메일을 통해 일반 네트워크를 통해 일상적으로 전송됩니다.

---
#### **3.2.2. Password Sniffing**

수동 공격의 또 다른 예는 비밀번호 스니핑\(PASSWORD SNIFFING\)입니다. 비밀번호 스니핑은 리소스를 무단으로 사용하는 것을 목표로 합니다. \[TELNET\], \[POP\] 및 \[NNTP\]를 포함한 많은 프로토콜은 공유 비밀번호를 사용하여 클라이언트를 서버에 인증합니다. 종종 이 비밀번호는 통신 채널을 통해 클라이언트에서 서버로 암호화되지 않은 상태로 전송됩니다. 따라서 이 트래픽을 읽을 수 있는 공격자는 비밀번호를 캡처하고 재생할 수 있습니다. 즉, 공격자는 서버에 대한 연결을 시작하고 클라이언트로 가장하여 캡처된 비밀번호를 사용하여 로그인할 수 있습니다.

공격의 로그인 단계는 활성화되어 있지만 실제 비밀번호 캡처 단계는 수동적입니다. 또한 서버가 연결의 원래 주소를 확인하지 않는 한 로그인 단계에서는 네트워크에 대한 특별한 제어가 필요하지 않습니다.

---
#### **3.2.3. Offline Cryptographic Attacks**

많은 암호화 프로토콜이 오프라인 공격을 받기 쉽습니다. 이러한 프로토콜에서 공격자는 피해자의 비밀 키를 사용하여 처리된 데이터를 복구한 다음 해당 키에 암호 분석 공격을 가합니다. 비밀번호는 일반적으로 엔트로피가 낮기 때문에 특히 취약한 대상이 됩니다. 널리 사용되는 다수의 비밀번호 기반 시도 응답 프로토콜은 사전 공격에 취약합니다. 공격자는 시도-응답 쌍을 캡처한 다음 올바른 응답을 생성하는 암호를 찾을 때까지 일반적인 단어 목록\(예: 사전 파일\)에서 항목을 시도합니다.

NIS를 사용할 때 유사한 공격이 로컬 네트워크에 탑재될 수 있습니다. Unix 비밀번호는 단방향 기능을 사용하여 암호화되지만 이러한 암호화된 비밀번호를 해독하는 도구가 존재합니다 \[KLEIN\]. NIS를 사용하면 암호화된 비밀번호가 로컬 네트워크를 통해 전송되므로 공격자가 비밀번호를 스니핑하여 공격할 수 있다.

역사적으로, 능동적인 공격을 통해 비밀번호 파일을 복구하기 위해 작은 운영 체제 보안 허점을 이용하는 것도 가능했습니다. 그런 다음 앞서 언급한 오프라인 비밀번호 복구 기술을 사용하여 이러한 허점을 실제 계정으로 부트스트랩할 수 있습니다. 따라서 우리는 낮은 수준의 능동 공격과 오프라인 수동 공격을 결합합니다.

---
### **3.3. Active Attacks**

공격이 네트워크에 데이터를 쓰는 것과 관련된 경우 이를 활성 공격이라고 합니다. IPsec 없이 IP를 사용하는 경우 보낸 사람 주소에 대한 인증이 없습니다. 결과적으로 공격자가 자신이 선택한 소스 주소로 패킷을 생성하는 것은 간단합니다. 우리는 이것을 스푸핑 공격\(SPOOFING ATTACK\)이라고 부릅니다.

특정 상황에서는 이러한 패킷이 네트워크에 의해 차단될 수 있습니다. 예를 들어, 많은 패킷 필터링 방화벽은 외부 인터페이스에 도착하는 내부 네트워크의 소스 주소를 가진 모든 패킷을 차단합니다. 그러나 이는 방화벽 내부에 있는 공격자에 대한 보호 기능을 제공하지 않습니다. 일반적으로 설계자는 공격자가 패킷을 위조할 수 있다고 가정해야 합니다.

그러나 패킷을 위조하는 기능은 임의의 패킷을 수신하는 기능과 함께 사용되지 않습니다. 실제로 위조된 패킷을 보낼 수 있지만 응답을 받지 못하는 적극적인 공격이 있습니다. 우리는 이것을 블라인드 공격\(BLIND ATTACK\)이라고 부를 것입니다.

모든 활성 공격에 주소 위조가 필요한 것은 아닙니다. 예를 들어, TCP SYN 서비스 거부 공격\(TCPSYN\)은 보낸 사람의 주소를 위장하지 않고도 성공적으로 탑재될 수 있습니다. 그러나 공격이 발견될 경우 신원을 숨기기 위해 주소를 위장하는 것이 일반적입니다.

각 프로토콜은 특정 활성 공격에 취약하지만 경험에 따르면 여러 가지 일반적인 공격 패턴이 특정 프로토콜에 적용될 수 있습니다. 다음 섹션에서는 이러한 패턴의 수를 설명하고 알려진 프로토콜에 적용되는 구체적인 예를 제공합니다.

---
#### **3.3.1. Replay Attacks**

REPLAY 공격에서 공격자는 유선에서 일련의 메시지를 녹음하고 원래 수신한 당사자에게 이를 재생합니다. 공격자는 메시지를 이해할 필요가 없습니다. 그는 단지 그것들을 포착해서 재전송하기만 하면 됩니다.

예를 들어 신용 카드 구매나 주식 거래와 같은 일부 서비스를 요청하기 위해 S/MIME 메시지를 사용하는 경우를 생각해 보십시오. 공격자는 피해자에게 불편을 주기 위해서만 서비스를 두 번 실행하기를 원할 수 있습니다. 그는 메시지를 읽을 수는 없지만 메시지를 캡처하고 재생할 수 있으므로 트랜잭션이 두 번 실행됩니다.

---
#### **3.3.2. Message Insertion**

MESSAGE INSERTION 공격에서 공격자는 선택한 속성 집합으로 메시지를 위조하여 네트워크에 삽입합니다. 종종 이 메시지에는 공격자의 신원을 위장하기 위해 위조된 소스 주소가 포함됩니다.

예를 들어, 대상 호스트를 향한 일련의 가짜 TCP SYN 패킷을 삽입하여 서비스 거부 공격을 탑재할 수 있습니다. 대상 호스트는 자체 SYN으로 응답하고 새 연결을 위해 커널 데이터 구조를 할당합니다. 공격자는 3방향 핸드셰이크를 완료하지 않으므로 할당된 연결 끝점이 커널 메모리를 차지합니다. 일반적인 TCP 스택 구현에만 해당

이 "반 개방" 상태에서는 제한된 수의 연결을 허용하고 이 제한에 도달하면 합법적인 호스트에서도 더 이상 연결을 시작할 수 없습니다. 공격자가 피해자의 SYN을 처리할 필요가 없기 때문에 이 공격은 맹목적인 공격입니다.

---
#### **3.3.3. Message Deletion**

MESSAGE DELETION 공격에서 공격자는 회선에서 메시지를 제거합니다. Morris의 시퀀스 번호 추측 공격 \[SEQNUM\]은 메시지 삭제 공격이 성공적으로 수행되어야 하는 경우가 많습니다. 이 블라인드 공격에서는 주소가 위조되는 호스트가 공격받는 호스트로부터 가짜 TCP SYN 패킷을 받게 됩니다. 이 SYN 패킷을 수신하면 RST가 생성되어 불법적인 연결이 끊어집니다. 공격이 성공적으로 수행될 수 있도록 이 호스트가 RST를 보내는 것을 방지하기 위해 Morris는 이 호스트를 플러딩하여 SYN 패킷이 손실되어 응답하지 않는 큐 오버플로를 생성하는 방법을 설명합니다.

---
#### **3.3.4. Message Modification**

MESSAGE MODIFICATION 공격에서 공격자는 회선에서 메시지를 제거하고 수정한 후 네트워크에 다시 주입합니다. 이러한 종류의 공격은 공격자가 메시지의 일부 데이터를 전송하고 일부를 변경하려는 경우에 특히 유용합니다.

공격자가 인터넷을 통해 주문한 상품을 공격하려는 경우를 생각해 보십시오. 그는 피해자의 신용카드 번호가 없기 때문에 피해자가 주문할 때까지 기다린 다음 배송 주소\(및 상품 설명\)를 자신의 주소로 바꿉니다. 이 특정 공격은 공격자가 원본 메시지에서 신용 카드 번호를 잘라내어 새 메시지에 붙여넣기 때문에 CUT-AND-PASTE 공격으로 알려져 있습니다.

잘라내기 및 붙여넣기 공격의 또 다른 흥미로운 예는 \[IPSPPROB\]에서 제공됩니다. MAC 없이 IPsec ESP를 사용하면 공격자가 동일한 시스템에서 피해자를 위해 암호화된 트래픽을 읽을 수 있습니다. 공격자는 암호화된 IP 패킷에 자신이 제어하는 ​​포트에 해당하는 IP 헤더를 첨부한다. 호스트가 패킷을 수신하면 자동으로 암호가 해독되어 공격자의 포트로 전달됩니다. 유사한 기술을 사용하여 세션 하이재킹 공격을 수행할 수 있습니다. 암호화를 사용할 때 항상 메시지 인증을 사용하면 이러한 공격을 모두 피할 수 있습니다. 이 공격은 \(1\) 이 공격이 손상된 패킷을 생성하므로 MAC 검사가 사용되지 않는 경우에만 작동합니다. \(2\) 사용자 간 SA가 불일치를 초래하므로 호스트 간 SA가 사용되는 경우에만 작동합니다. SA와 연결된 포트와 대상 포트 사이. 수신 시스템이 단일 사용자인 경우 이 공격은 불가능합니다.

---
#### **3.3.5. Man-In-The-Middle**

MAN-IN-THE-MIDDLE 공격은 위의 기술을 특별한 형태로 결합합니다. 공격자는 송신자 대 수신자, 수신자 대 송신자로 가장하기 위해 통신 스트림을 파괴합니다.

```text
      What Alice and Bob think:
      Alice  <---------------------------------------------->  Bob

      What's happening:
      Alice  <---------------->  Attacker  <---------------->  Bob
```

이는 데이터 스트림 자체가 아닌 통신 당사자의 신원을 공격한다는 점에서 위의 공격 형태와 근본적으로 다릅니다. 결과적으로, 통신 스트림의 무결성을 제공하는 많은 기술은 중간자 공격으로부터 보호하기에 충분하지 않습니다.

프로토콜에 피어 엔터티 인증이 없을 때마다 중간자 공격이 가능합니다. 예를 들어 공격자가 TCP 핸드셰이크 중에 클라이언트 TCP 연결을 하이재킹할 수 있는 경우\(아마도 서버보다 먼저 클라이언트의 SYN에 응답하여\) 공격자는 서버에 대한 다른 연결을 열고 중간자 공격을 시작할 수 있습니다. 공격. ARP 스푸핑을 통해 로컬 네트워크에 중간자 공격을 가하는 것도 쉽지 않습니다. 공격자는 피해자의 IP 주소와 자신의 MAC 주소를 사용하여 ARP를 위조합니다. 이러한 종류의 공격을 수행하는 도구는 쉽게 사용할 수 있습니다.

중간자 공격을 방지하려면 트랜잭션의 한쪽만 인증하면 됩니다. 이러한 상황에서 피어는 단 하나의 피어만 인증되는 연결을 설정할 수 있습니다. 이러한 시스템에서 공격자는 인증되지 않은 피어인 것처럼 가장하여 연결을 시작할 수 있지만 합법적인 연결을 통해 전송되는 데이터를 전송하거나 액세스할 수 없습니다. 이는 서버만 인증하면 되는\(또는 클라이언트가 신용 카드 번호와 같은 일부 비암호화 메커니즘을 통해 독립적으로 인증되는\) 웹 전자 상거래와 같은 상황에서 허용되는 상황입니다.

---
### **3.4. Topological Issues**

실제로 인터넷이 완전히 연결되어 있지 않기 때문에 공격자가 모든 패킷을 읽고 생성하는 것이 똑같이 쉽다는 가정은 거짓입니다. 이는 두 가지 주요 의미를 갖습니다.

---
### **3.5. On-path versus off-path**

데이터그램이 한 호스트에서 다른 호스트로 전송되기 위해서는 일반적으로 일부 중간 링크 및 게이트웨이 세트를 통과해야 합니다. 이러한 게이트웨이는 해당 경로를 따라 전송되는 모든 데이터그램을 자연스럽게 읽거나 수정하거나 제거할 수 있습니다. 이렇게 하면 경로에 있는 경우 다양한 공격을 훨씬 쉽게 수행할 수 있습니다.

물론 오프패스 호스트는 임의의 호스트에서 오는 것처럼 보이는 임의의 데이터그램을 전송할 수 있지만 반드시 다른 호스트를 대상으로 하는 데이터그램을 수신할 수는 없습니다. 따라서 공격이 데이터 수신 능력에 달려 있는 경우, 경로를 벗어난 호스트는 경로에 위치하기 위해 먼저 토폴로지를 파괴해야 합니다. 이는 결코 불가능하지는 않지만 반드시 사소한 것은 아닙니다.

애플리케이션 프로토콜 설계자는 모든 공격자가 경로를 벗어날 것이라고 가정해서는 안 됩니다. 가능한 경우 프로토콜은 네트워크를 완전히 제어하는 ​​공격자의 공격에 저항하도록 설계되어야 합니다. 그러나 설계자는 경로상의 공격자뿐만 아니라 경로를 벗어난 공격자도 수행할 수 있는 공격에 더 많은 비중을 둘 것으로 예상됩니다.

---
### **3.6. Link-local**

on-path의 특수한 사례 중 하나는 동일한 링크에 있는 것입니다. 어떤 상황에서는 로컬 네트워크에 있는 호스트와 그렇지 않은 호스트를 구별하는 것이 바람직합니다. 이에 대한 표준 기술은 IP TTL 값\[IP\]을 확인하는 것입니다. TTL은 각 전달자에 의해 감소되어야 하므로 프로토콜은 TTL을 255로 설정하고 모든 수신자가 TTL을 확인하도록 요구할 수 있습니다. 그러면 수신자는 적합한 패킷이 동일한 링크에서 왔다고 믿을 만한 몇 가지 이유가 있습니다. 터널링 시스템이 있는 경우 이 기술을 주의해서 사용해야 합니다. 이러한 시스템은 TTL을 줄이지 않고 패킷을 전달할 수 있기 때문입니다.

---
## **4. Common Issues**

각 시스템의 보안 요구 사항은 고유하지만 특정 공통 요구 사항은 여러 프로토콜에 나타납니다. 종종 순진한 프로토콜 설계자는 이러한 요구 사항에 직면할 때 더 나은 솔루션을 사용할 수 있음에도 불구하고 명백하지만 안전하지 않은 솔루션을 선택합니다. 이 섹션에서는 많은 프로토콜에서 볼 수 있는 여러 가지 문제와 이를 해결하는 데 유용할 수 있는 일반적인 보안 기술에 대해 설명합니다.

---
### **4.1. User Authentication**

기본적으로 리소스에 대한 액세스를 제어하려는 모든 시스템에는 사용자를 인증하는 방법이 필요합니다. 이러한 목적을 위해 거의 셀 수 없이 많은 메커니즘이 설계되었습니다. 다음 여러 섹션에서는 이러한 기술 중 일부를 설명합니다.

---
#### **4.1.1. Username/Password**

가장 일반적인 액세스 제어 메커니즘은 간단한 USERNAME/PASSWORD입니다. 사용자는 사용하려는 호스트에 사용자 이름과 재사용 가능한 비밀번호를 제공합니다. 이 시스템은 공격자가 유선에서 비밀번호를 알아낸 다음 비밀번호를 제시하는 새 세션을 시작하는 단순 수동 공격에 취약합니다. 이 위협은 TLS 또는 IPSEC와 같은 암호화된 연결을 통해 프로토콜을 호스팅함으로써 완화될 수 있습니다. 보호되지 않은\(일반 텍스트\) 사용자 이름/비밀번호 시스템은 IETF 표준에서 허용되지 않습니다.

---
#### **4.1.2. Challenge Response and One Time Passwords**

USERNAME/PASSWORD보다 더 강력한 보안을 원하는 시스템은 ONE TIME PASSWORD\[OTP\] 방식이나 CHALLENGE-RESPONSE를 사용하는 경우가 많습니다. 일회용 비밀번호 체계에서는 사용자에게 비밀번호 목록이 제공되며, 비밀번호는 한 번에 한 번씩 순서대로 사용해야 합니다. \(종종 이러한 비밀번호는 일부 비밀 키에서 생성되므로 사용자는 다음 비밀번호를 순서대로 간단하게 계산할 수 있습니다.\) SecureID 및 DES Gold는 이 체계의 변형입니다. 시도-응답 체계에서 호스트와 사용자는 일부 비밀\(종종 비밀번호로 표시됨\)을 공유합니다. 사용자를 인증하기 위해 호스트는 사용자에게 \(무작위로 생성된\) 질문을 제시합니다. 사용자는 챌린지와 비밀을 기반으로 일부 기능을 계산하고 이를 확인하는 호스트에 제공합니다. 종종 이 계산은 DES Gold 카드와 같은 휴대용 장치에서 수행됩니다.

두 가지 유형의 체계 모두 재생 공격에 대한 보호 기능을 제공하지만 종종 오프라인 키 검색 공격\(수동 공격의 일종\)에 취약합니다. 앞서 언급한 것처럼 일회성 비밀번호나 응답은 공유 비밀에서 계산되는 경우가 많습니다. 공격자가 사용 중인 기능을 알고 있다면 올바른 출력을 생성하는 기능을 찾을 때까지 가능한 모든 공유 비밀을 시도하면 됩니다. 공유 비밀이 비밀번호인 경우 이는 더 쉬워집니다. 이 경우 사전 공격을 수행할 수 있습니다. 즉, 무작위 문자열이 아닌 일반적인 단어\(또는 문자열\) 목록을 시도한다는 의미입니다.

이러한 시스템은 적극적인 공격에도 취약한 경우가 많습니다. 전체 세션에 대해 통신 보안이 제공되지 않는 한 공격자는 인증이 수행될 때까지 기다렸다가 연결을 가로챌 수 있습니다.

---
#### **4.1.3. Shared Keys**

CHALLENGE-RESPONSE 유형 시스템은 사용자가 생성한 비밀번호 대신 무작위로 생성된 공유 키를 사용하여 사전 공격으로부터 보안을 유지할 수 있습니다. 키가 충분히 크면 키 검색 공격이 실용적이지 않습니다. 이 접근 방식은 사용자가 충분히 긴 키를 기억하는 데 어려움을 겪기 때문에 사용자가 키를 기억하고 입력하는 대신 최종 노드에 키를 구성할 때 가장 잘 작동합니다.

비밀비밀번호 기반 시스템과 마찬가지로 공유 키 시스템에도 관리 문제가 있습니다. 각 통신 당사자 쌍에는 자체적으로 합의된 키가 있어야 하며 이로 인해 많은 키가 있게 됩니다.

---
#### **4.1.4. Key Distribution Centers**

많은 수의 키 문제를 해결하는 한 가지 접근 방식은 인증 당사자 사이를 중재하는 온라인 "신뢰할 수 있는 제3자"를 이용하는 것입니다. 신뢰할 수 있는 제3자\(일반적으로 KDC\(키 배포 센터\)라고 함\)는 시스템의 각 당사자와 대칭 키 또는 비밀번호를 공유합니다. 먼저 KDC에 연결하여 두 피어의 키로 암호화된 무작위로 생성된 대칭 키가 포함된 TICKET을 제공합니다. 적절한 피어만이 대칭 키를 해독할 수 있으므로 티켓을 사용하여 신뢰할 수 있는 연결을 설정할 수 있습니다. 지금까지 가장 널리 사용되는 KDC 시스템은 Kerberos \[KERBEROS\]입니다.

---
#### **4.1.5. Certificates**

간단한 접근 방식은 모든 사용자가 인증서 \[PKIX\]를 갖고 이를 사용하여 \[TLS\] 또는 \[S/MIME\]과 같은 프로토콜별 방식으로 인증하는 것입니다. 인증서는 엔터티의 신원을 공개 키에 바인딩하는 서명된 자격 증명입니다. 인증서 서명자는 CA\(인증 기관\)이며, 이 인증서 자체는 일부 상위 CA에서 서명할 수 있습니다. 이 시스템이 작동하려면 대역 외 방식으로 하나 이상의 CA에 대한 신뢰를 구축해야 합니다. 이러한 CA를 TRUSTED ROOTS 또는 ROOT CAS라고 합니다. 클라이언트-서버 유형 시스템에서 이 접근 방식의 주요 장애물은 클라이언트에 인증서가 있어야 한다는 점이며, 이는 배포 문제가 될 수 있습니다.

---
#### **4.1.6. Some Uncommon Systems**

위에서 언급한 방식보다 더 나은 작업을 수행할 수 있는 방법이 있지만 연결 보안을 위해 통신 보안\(적어도 메시지 무결성\)을 사용하지 않는 한 일반적으로 많은 보안을 추가하지 않습니다. 그렇지 않으면 공격자가 연결을 하이재킹할 수 있기 때문입니다. 인증이 수행되었습니다. 다양한 프로토콜\(\[EKE\], \[SPEKE\], \[SRP\]\)을 통해 안전하게 부트스트랩할 수 있습니다.

사용자의 비밀번호를 암호화 프로토콜에 대한 입력으로 사용할 수 있는 공유 키로 변환합니다. 이러한 프로토콜 배포의 주요 장애물 중 하나는 지적 재산권 상태가 매우 불분명하다는 것입니다. 마찬가지로 사용자는 공개 키 인증서\(예: S-HTTP 클라이언트 인증\)를 사용하여 인증할 수 있습니다. 일반적으로 이러한 방법은 보다 완전한 보안 프로토콜의 일부로 사용됩니다.

---
#### **4.1.7. Host Authentication**

호스트 인증에는 특별한 문제가 있습니다. 일반적으로 서비스 주소는 DNS 호스트 이름\(예: URL\[URL\]\)을 사용하여 표시됩니다. 이러한 서비스를 요청할 때 대화 중인 엔터티가 인증서를 가지고 있을 뿐만 아니라 해당 인증서가 서버의 예상 ID와 일치하는지 확인해야 합니다. 가장 중요한 것은 인증서와 예상 호스트 이름 간의 보안 바인딩입니다.

예를 들어, 특정 호스트 이름에 대한 요청인 경우 인증서에 IP 주소 형식의 ID가 포함되는 것은 일반적으로 허용되지 않습니다. 보안 이름 확인\[DNSSEC\]을 사용하지 않으면 호스트 이름-IP 매핑이 안전하지 않기 때문에 이는 종단 간 보안을 제공하지 않습니다. 이는 호스트 이름이 애플리케이션 계층에 표시되지만 일부 하위 계층에서 인증이 수행되는 경우 특히 문제가 됩니다.

---
### **4.2. Generic Security Frameworks**

프로토콜에 보안 기능을 제공하는 것은 어려울 수 있습니다. 인증 및 키 설정 메커니즘을 선택하는 문제 외에도 이를 프로토콜에 통합해야 합니다. 이 문제\(IPsec 및 TLS에 구현됨\)에 대한 한 가지 대응은 낮은 수준의 보안 프로토콜을 만든 다음 해당 프로토콜을 통해 새 프로토콜이 실행되도록 하는 것입니다. 최근 대중화되는 또 다른 접근 방식은 일반 애플리케이션 계층 보안 프레임워크를 설계하는 것입니다. 아이디어는 플러그 가능한 방식으로 다양한 보안 메커니즘을 협상할 수 있는 프로토콜을 설계한다는 것입니다. 그러면 애플리케이션 프로토콜 설계자는 자신의 애플리케이션 프로토콜에 보안 프로토콜 PDU를 전달하도록 준비합니다. 이러한 프레임워크의 예로는 GSS-API \[GSS\] 및 SASL \[SASL\]이 있습니다.

일반적인 프레임워크 접근 방식에는 여러 가지 문제가 있습니다. 첫째, 다운그레이드 공격에 매우 취약합니다. 다운그레이드 공격에서는 적극적인 공격자가 협상을 조작하여 당사자들이 원래보다 약한 보호를 협상하도록 강요합니다. 협상과 키 설정이 모두 완료된 후에 무결성 검사를 포함할 수 있지만 이 무결성 검사의 강도는 필연적으로 가장 약한 공통 알고리즘으로 제한됩니다. 이 문제는 모든 협상 접근 방식에 존재하지만

일반 프레임워크는 애플리케이션 프로토콜 작성자가 적절한 기본 메커니즘에 대해 열심히 생각하기보다는 프레임워크만 지정하도록 장려하여 이를 악화시킵니다. 특히 메커니즘이 제공되는 보안 수준에서 매우 광범위할 수 있기 때문입니다.

또 다른 문제는 프레임워크의 다양한 보안 기능이 애플리케이션 계층 프로토콜과 상호 작용하는 방식이 항상 명확하지 않다는 것입니다. 예를 들어, SASL은 인증 프레임워크로만 사용될 수 있습니다. 이 경우 SASL 교환이 발생하지만 연결의 나머지 부분은 보호되지 않지만 메커니즘으로 GSS 등을 통해 트래픽 보호를 협상할 수도 있습니다. 어떤 상황에서 트래픽 보호가 선택 사항이고 어떤 상황이 필요한지 파악하려면 위협 모델에 대해 생각해 볼 필요가 있습니다.

일반적으로 인증 프레임워크는 기존 레거시 인증 시스템이 있는 시스템에 새로운 프로토콜이 추가되는 상황에서 가장 유용합니다. 프레임워크를 사용하면 기존 사이트가 레거시 인증 시스템을 완전히 다시 실행하도록 강요하지 않으면서 새로운 설치에서 더 나은 인증을 제공할 수 있습니다. 시스템의 보안 요구 사항을 명확하게 식별할 수 있고 몇 가지 형태의 인증만 사용하는 경우 단일 보안 메커니즘을 선택하면 더 큰 단순성과 예측 가능성이 제공됩니다. 프레임워크를 사용하는 상황에서 설계자는 프레임워크의 옵션을 주의 깊게 검사하고 특정 위협 모델에 적합한 메커니즘만 지정해야 합니다. 프레임워크가 필요한 경우 디자이너는 자체적으로 디자인하는 대신 확립된 프레임워크 중 하나를 선택해야 합니다.

---
### **4.3. Non-repudiation**

부인 방지에 대한 순진한 접근 방식은 단순히 콘텐츠에 공개 키 디지털 서명을 사용하는 것입니다. 바인딩을 원하는 당사자\(서명 당사자\)가 해당 메시지에 디지털 서명을 합니다. 상대방\(신뢰 당사자\)은 나중에 서명 당사자가 논쟁의 여지가 있는 메시지에 동의했다는 증거로 디지털 서명을 지적할 수 있습니다. 불행하게도 이 접근법은 충분하지 않습서명 당사자가 메시지를 거부하는 가장 쉬운 방법은 자신의 개인 키가 손상되었고 일부 공격자\(반드시 신뢰 당사자는 아니지만\)가 분쟁 메시지에 서명했다고 주장하는 것입니다. 이 공격을 방어하기 위해 신뢰 당사자는 서명 당시 서명 당사자의 키가 손상되지 않았음을 입증해야 합니다. 이를 위해서는 메시지가 서명된 시간을 설정하기 위한 인증서 해지 정보의 보관 저장소와 타임스탬프 서버를 포함한 상당한 인프라가 필요합니다.

또한 신뢰 당사자는 서명 당사자가 다른 메시지에 서명한다고 생각하면서 하나의 메시지에 서명하도록 속이려고 시도할 수도 있습니다. 이 문제는 키오스크 상황과 같이 서명 당사자가 서명에 사용하는 인프라를 신뢰 당사자가 제어할 때 특히 심각합니다. 이러한 상황에서 서명 당사자의 키는 스마트카드에 보관되지만 서명할 메시지는 신뢰 당사자에 의해 표시됩니다.

이러한 모든 복잡성으로 인해 부인 방지는 실제로 배포하기 어려운 서비스입니다.

---
### **4.4. Authorization vs. Authentication**

승인은 인증된 당사자가 특정 리소스나 서비스에 액세스할 수 있는 권한이 있는지 여부를 결정하는 프로세스입니다. 비록 긴밀하게 연결되어 있지만 인증과 권한 부여는 서로 다른 두 가지 메커니즘이라는 점을 인식하는 것이 중요합니다. 아마도 이러한 긴밀한 결합으로 인해 인증이 승인을 의미하는 것으로 잘못 생각되는 경우가 있습니다. 인증은 단순히 당사자를 식별하고 인증은 특정 작업을 수행할 수 있는지 여부를 정의합니다.

권한 부여는 반드시 인증에 의존하지만 인증 자체가 권한 부여를 의미하지는 않습니다. 오히려 작업 수행 권한을 부여하기 전에 권한 부여 메커니즘을 참조하여 해당 작업이 허용되는지 여부를 결정해야 합니다.

---
#### **4.4.1. Access Control Lists**

권한 부여 메커니즘의 일반적인 형태 중 하나는 리소스에 대한 액세스가 허용된 사용자를 나열하는 액세스 제어 목록\(ACL\)입니다. 각 리소스에 개별 인증 권한을 할당하는 것은 지루한 작업이므로 상위 리소스의 ACL이 하위 리소스에 상속되도록 리소스가 계층적으로 배열되는 경우가 많습니다. 이를 통해 관리자는 최상위 정책을 설정하고 필요할 때 이를 재정의할 수 있습니다.

---
#### **4.4.2. Certificate Based Systems**

사용자 이름 및 비밀번호와 같은 간단한 인증 메커니즘을 사용하면\(즉, 모든 사람이 관리자 계정과 사용자 계정의 차이점을 이해함\) 인증과 권한 부여 간의 구별이 직관적이지만, 보다 복잡한 인증 메커니즘을 사용하면 구별이 사라지는 경우가 있습니다.

예를 들어, 인증서의 경우 유효한 서명을 제시한다고 해서 승인을 의미하지는 않습니다. 서명은 신뢰할 수 있는 루트를 포함하는 인증서 체인에 의해 뒷받침되어야 하며 해당 루트는

주어진 상황에서 신뢰할 수 있습니다. 예를 들어, Acme MIS CA에서 발급한 인증서를 소유한 사용자는 Acme Accounting CA에서 발급한 인증서를 소유한 사용자와 다른 웹 액세스 권한을 가질 수 있습니다. 비록 두 CA가 모두 Acme 웹 서버에서 "신뢰"되는 경우에도 마찬가지입니다.

이러한 보다 복잡한 속성을 적용하는 메커니즘은 아직 완전히 연구되지 않았습니다. 한 가지 접근 방식은 어떤 종류의 인증서를 신뢰할 수 있는지 설명하는 정책을 ACL에 연결하는 것입니다. 또 다른 접근 방식은 해당 정보를 인증서 확장/속성\[PKIX, SPKI\] 또는 별도의 "속성 인증서"로 인증서와 함께 전달하는 것입니다.

---
### **4.5. Providing Traffic Security**

안전하게 설계된 프로토콜은 모든 민감한 트래픽을 보호\(무결성 보호, 인증 및 암호화를 의미\)하기 위한 몇 가지 메커니즘을 제공해야 합니다. 한 가지 접근 방식은 \[DNSSEC\], \[S/MIME\] 또는 \[S-HTTP\]와 같이 프로토콜 자체를 보호하는 것입니다. 이는 프로토콜에 가장 적합한 보안을 제공하지만 올바르게 수행하려면 상당한 노력이 필요합니다.

사용 가능한 채널 보안 시스템 중 하나를 사용하면 많은 프로토콜을 적절하게 보호할 수 있습니다. 가장 일반적인 두 가지 IPsec \[AH, ESP\] 및 \[TLS\]에 대해 논의하겠습니다.

---
#### **4.5.1. IPsec**

IPsec 프로토콜\(특히 AH 및 ESP\)은 두 호스트 간의 모든 트래픽에 대한 전송 보안을 제공할 수 있습니다. IPsec 프로토콜은 "IP 서브넷", "IP 주소", "정규화된 도메인 이름" 및 개별 사용자\("사서함 이름"\) 등 다양한 사용자 식별 단위를 지원합니다. 이러한 다양한 수준의 식별은 IPsec의 본질적인 부분인 액세스 제어 시설에 대한 입력으로 사용됩니다. 그러나 특정 IPsec 구현은 모든 ID 유형을 지원하지 않을 수도 있습니다. 특히, 보안 게이트웨이는 사용자 간 인증을 제공하지 않거나 해당 인증 정보를 애플리케이션에 제공하는 메커니즘을 갖고 있지 않을 수 있습니다.

AH 또는 ESP를 사용하는 경우 애플리케이션 프로그래머는 아무것도 수행할 필요가 없거나\(AH 또는 ESP가 시스템 전체에서 활성화된 경우\) 특정 소프트웨어를 변경해야 할 수도 있습니다\(예: 특정 setockopt\(\) 호출 추가\). 사용되는 AH 또는 ESP 구현. 불행하게도 IPsec 구현을 제어하기 위한 API는 아직 표준화되지 않았습니다.

다른 프로토콜을 보호하기 위해 IPsec을 사용하는 데 있어 주요 장애물은 배포입니다. 현재 IPsec의 주요 용도는 VPN 애플리케이션, 특히 원격 네트워크 액세스입니다. 보안 관리자와 애플리케이션 개발자 간의 극도로 긴밀한 조정 없이 VPN 사용은 개별 애플리케이션에 보안 서비스를 제공하는 데 적합하지 않습니다. 해당 애플리케이션이 실제로 어떤 보안 서비스가 제공되었는지 판단하기 어렵기 때문입니다.

호스트 간 환경의 IPsec 배포가 느렸습니다. TLS와 같은 응용 프로그램 보안 시스템과 달리 IPsec이 아닌 시스템에 IPsec을 추가하려면 일반적으로 커널을 수정하거나 새 드라이버를 설치하여 운영 체제를 변경해야 합니다. 이는 단순히 새 애플리케이션을 설치하는 것보다 훨씬 더 큰 작업입니다. 그러나 여러 상용 운영 체제의 최신 버전에는 IPsec 스택이 포함되어 있으므로 배포가 더욱 쉬워지고 있습니다.

IPsec을 확실히 사용할 수 있는 환경에서는 애플리케이션 통신 트래픽을 보호하기 위한 실행 가능한 옵션을 나타냅니다. 보호할 트래픽이 UDP인 경우 IPsec 및 애플리케이션별 개체 보안이 유일한 옵션입니다. 그러나 설계자는 IPsec을 사용할 수 있다고 가정해서는 안 됩니다. 일반 애플리케이션 계층 프로토콜에 대한 보안 정책은 의도한 배포 환경에서 IPsec을 사용할 수 있다고 믿을만한 이유가 없는 한 단순히 IPsec을 사용해야 한다고 명시해서는 안 됩니다. IPsec을 사용할 수 없고 트래픽이 TCP로만 이루어지는 환경에서는 애플리케이션 개발자가 패키지에 TLS 구현을 포함하여 IPsec의 존재를 쉽게 확인할 수 있으므로 TLS를 선택하는 방법입니다.

IPIPv6의 특별한 경우에는 AH와 ESP가 모두 필수로 구현되어야 합니다. 따라서 AH/ESP가 이미 IPv6 전용 프로토콜 또는 IPv6 전용 배포에 사용 가능하다고 가정하는 것이 합리적입니다. 그러나 자동 키 관리\(IKE\)는 구현하는 데 필요하지 않으므로 프로토콜 설계자는 IKE가 존재할 것이라고 가정해서는 안 됩니다. \[USEIPSEC\]는 언제 IPsec을 선택하는 것이 좋은지에 대한 상당한 지침을 제공합니다.

---
#### **4.5.2. SSL/TLS**

현재 가장 일반적인 접근 방식은 SSL 또는 그 후속 TLS를 사용하는 것입니다. 이는 애플리케이션 수준에서 TCP 연결에 대한 채널 보안을 제공합니다. 즉, TCP를 통해 실행됩니다. SSL 구현은 일반적으로 쉬운 프로그래밍을 위해 Berkeley 소켓과 유사한 인터페이스를 제공합니다. TLS를 중심으로 프로토콜 솔루션을 설계할 때 주요 문제는 TLS를 사용하여 보호되는 연결과 그렇지 않은 연결을 구별하는 것입니다.

사용되는 두 가지 기본 접근 방식에는 TLS 연결을 위한 별도의 잘 알려진 포트가 있거나\(예: TLS 포트를 통한 HTTP는 443입니다\) \[HTTPTLS\] 또는 \[UPGRADE\] 또는 \[ 시작TLS\]. 상향 협상 전략을 사용하는 경우 양측이 TLS를 사용하려고 할 때 공격자가 명확한 연결을 강요할 수 없도록 주의해야 합니다.

TLS는 TCP 또는 SCTP와 같은 신뢰할 수 있는 프로토콜에 의존합니다. 이로 인해 두 가지 주목할만한 어려움이 발생합니다. 첫째, UDP를 사용하는 데이터그램 프로토콜을 보호하는 데 사용할 수 없습니다. 둘째, TLS는 IPsec이 아닌 IP 계층 공격에 취약합니다. 일반적으로 이러한 공격은 서비스 거부 또는 연결 암살의 형태를 취합니다. 예를 들어 공격자는 SSL 연결을 종료하기 위해 TCP RST를 위조할 수 있습니다. TLS에는 잘림 공격을 탐지하는 메커니즘이 있지만 이는 단지 피해자가 자신이 공격을 받고 있다는 사실을 알 수 있도록 허용할 뿐이며 그러한 공격에 직면했을 때 연결 생존성을 제공하지 않습니다. 이와 대조적으로 IPsec을 사용하는 경우 이러한 위조된 RST는 TCP 연결에 영향을 주지 않고 거부될 수 있습니다. 위조된 RST 또는 TCP 연결에 대한 기타 공격이 우려되는 경우 AH/ESP 또는 TCP MD5 옵션 \[TCPMD5\]이 선호되는 선택입니다.

---
##### **4.5.2.1. Virtual Hosts**

TLS에 대한 "별도의 포트" 접근 방식을 사용하는 경우 애플리케이션 계층 트래픽이 전송되기 전에 TLS가 협상됩니다. 이는 TLS 핸드셰이크 중에 서버가 클라이언트에 어떤 인증서를 제공할지 모르기 때문에 \[HTTP\]와 같은 가상 호스트를 사용하는 프로토콜에 문제를 일으킬 수 있습니다. 이 문제를 해결하기 위해 TLS 호스트 이름 확장자 \[TLSEXT\]를 사용할 수 있습니다. 하지만 너무 새로운 기능이라 광범위한 배포를 볼 수는 없습니다.

---
##### **4.5.2.2. Remote Authentication and TLS**

TLS 사용의 한 가지 어려움은 서버가 인증서를 통해 인증된다는 것입니다. 이는 이전에 유일한 인증 형식이 클라이언트와 서버 간에 공유되는 비밀번호였던 환경에서는 불편할 수 있습니다. 인증된 서버 없이\(예: 익명 DH 또는 자체 서명된 RSA 인증서 사용\) TLS를 사용한 다음 CRAM-MD5를 사용하는 SASL과 같은 일부 시도-응답 메커니즘을 통해 인증하고 싶은 유혹이 있습니다.

불행하게도 SASL과 TLS의 이러한 구성은 예상보다 덜 강력합니다. 적극적인 공격자가 이 연결을 가로채는 것은 쉽습니다. 클라이언트는 중간자 역할을 하며 SSL 연결을 수행하고\(일반적으로 이 공격을 방지하기 위해 서버를 인증하는 것이 아니라는 점을 기억하십시오\) SASL 핸드셰이크를 간단히 프록시합니다. 그 이후로는 마치 연결이 된 것처럼 보입니다.

적어도 공격자에 관한 한 분명합니다. 이 공격을 방지하려면 클라이언트는 서버의 인증서를 확인해야 합니다.

그러나 서버가 인증되면 시도-응답이 덜 바람직해집니다. 이미 강화된 채널이 있다면 간단한 비밀번호도 괜찮습니다. 실제로 암호를 서버에 암호화되지 않은 상태로 저장할 필요가 없기 때문에 시도 응답보다 훨씬 뛰어납니다. 따라서 시도-응답 시스템을 사용한 키 파일의 손상은 간단한 비밀번호를 사용한 경우보다 더 심각합니다.

클라이언트에 인증서가 있는 경우 SSL 기반 클라이언트 인증을 사용할 수 있습니다. 이를 더 쉽게 만들기 위해 SASL은 SASL 클라이언트가 서버에 "외부 채널에서 내 신원을 조사"하라고 지시할 수 있는 EXTERNAL 메커니즘을 제공합니다. 분명히 이것은 위에서 설명한 계층화 공격의 대상이 아닙니다.

---
#### **4.5.3. Remote Login**

일부 특별한 경우에는 IPSEC 또는 SSL/TLS를 사용하는 대신 애플리케이션에서 직접 채널 수준 보안을 제공하는 것이 가치가 있을 수 있습니다. 그러한 사례 중 하나가 원격 터미널 보안입니다. 문자는 일반적으로 한 번에 한 문자씩 클라이언트에서 서버로 전달됩니다. SSL/TLS 및 AH/ESP는 모든 패킷을 인증하고 암호화하므로 이는 데이터 확장이 20배 증가할 수 있음을 의미합니다. 텔넷 암호화 옵션 \[ENCOPT\]은 앞서 말한 메시지 무결성을 통해 이러한 확장을 방지합니다.

원격 터미널 서비스를 사용할 때 다른 종류의 통신 서비스를 안전하게 수행하는 것이 바람직한 경우가 많습니다. 원격 로그인을 제공하는 것 외에도 SSH \[SSH\]는 임의의 TCP 포트에 대한 보안 포트 전달을 제공하므로 사용자는 SSH 채널을 통해 임의의 TCP 기반 응용 프로그램을 실행할 수 있습니다. SSH 포트 전달은 방화벽을 우회하고 안전하지 않은 내부 애플리케이션을 외부 세계에 부적절하게 노출하기 위해 부적절하게 사용되는 경우 보안 문제가 될 수 있습니다.

---
### **4.6. Denial of Service Attacks and Countermeasures**

서비스 거부 공격은 너무 자주 현실의 사실로 간주됩니다. 한 가지 문제는 공격자가 피해자에게 가하기 위해 많은 서비스 거부 공격 중 하나를 선택할 수 있다는 것입니다. 이러한 공격의 대부분은 좌절될 수 없기 때문에 일반적인 통념에서는 한 종류의 서비스 거부로부터 보호할 이유가 없다고 가정하는 경우가 많습니다. 가능하지만 예방할 수 없는 다른 서비스 거부 공격이 많이 있을 때 공격합니다.

그러나 모든 서비스 거부 공격이 동일한 것은 아니며 더 중요한 것은 서비스 거부 공격이 비현실적이지는 않더라도 더 어렵게 만들도록 프로토콜을 설계하는 것이 가능하다는 것입니다. 최근 SYN 플러드 공격\[TCPSYN\]은 다음 두 가지 특성을 모두 보여줍니다. SYN 플러드 공격은 매우 쉽고 익명이며 효과적이어서 다른 공격보다 공격자에게 더 매력적입니다. TCP 설계로 인해 이러한 공격이 가능해지기 때문입니다.

완전한 DoS 방어는 매우 어렵기 때문에 DoS에 대한 보안은 실용적으로 처리되어야 합니다. 특히 방어가 바람직한 일부 공격은 경제적으로 방어할 수 없습니다. 목표는 심각도 대 방어 비용의 비율이 충분히 높은 공격을 방어하여 위험을 관리하는 것입니다. 기술이 변화함에 따라 공격의 심각도와 방어 비용이 모두 변하므로 방어해야 하는 일련의 공격도 마찬가지입니다.인터넷 표준 작성자는 자신의 프로토콜이 취약한 서비스 거부 공격을 설명해야 합니다. 이 설명에는 이러한 서비스 거부 공격을 피하려는 시도가 불합리하거나 범위를 벗어난 이유가 포함되어야 합니다.

---
#### **4.6.1. Blind Denial of Service**

BLIND 서비스 거부 공격은 특히 해롭습니다. 맹목적인 공격을 통해 공격자는 상당한 이점을 갖게 됩니다. 공격자가 피해자로부터 트래픽을 수신할 수 있어야 한다면 라우팅 패브릭을 파괴하거나 자신의 IP 주소를 사용해야 합니다. 피해자가 공격자를 추적하거나 그의 트래픽을 필터링할 수 있는 기회를 제공합니다. 맹목적인 공격을 통해 공격자는 위조된 IP 주소를 사용할 수 있으므로 피해자가 자신의 패킷을 필터링하기가 매우 어렵습니다. TCP SYN 플러드 공격은 블라인드 공격의 예입니다. 설계자는 서비스 거부 공격을 방지하기 위해 가능한 모든 시도를 해야 합니다.

---
#### **4.6.2. Distributed Denial of Service**

더욱 위험한 것은 분산 서비스 거부 공격\(DDoS\)\[DDOS\]입니다. DDoS에서 공격자는 여러 시스템이 대상 시스템을 동시에 공격하도록 준비합니다. 일반적으로 이는 원격 공격 시작을 허용하는 프로그램으로 다수의 시스템을 감염시킴으로써 수행됩니다. 실제로 공격을 수행하는 기계를 ZOMBIE라고 하며 실제 공격자와는 완전히 다른 위치에 있는 의심할 여지가 없는 제3자가 소유할 가능성이 높습니다. DDoS 공격은 좀비가 합법적인 프로토콜 요청을 하는 것처럼 보이기 때문에 대응하기가 매우 어려울 수 있습니다.

단순히 실제 사용자를 몰아냅니다. DDoS 공격은 저지하기 어려울 수 있지만 프로토콜 설계자는 프로토콜을 설계하는 동안 이러한 공격 형태를 인식해야 합니다.

---
#### **4.6.3. Avoiding Denial of Service**

서비스 거부 공격을 더 어렵게 만드는 두 가지 일반적인 접근 방식이 있습니다.

---
##### **4.6.3.1. Make your attacker do more work than you do**

공격자가 공격을 시작할 때 귀하보다 더 많은 리소스를 소비하는 경우 귀하보다 리소스가 적은 공격자는 효과적인 공격을 시작할 수 없습니다. 일반적인 기술 중 하나는 공격자가 암호화 작업과 같이 시간이 많이 걸리는 작업을 수행하도록 요구하는 것입니다. 공격자가 충분한 CPU 성능을 확보할 수 있다면 여전히 서비스 거부 공격을 감행할 수 있다는 점에 유의하십시오. 예를 들어, 이 기술은 \[TCPSYN\]에 설명된 분산 공격을 중지하지 않습니다.

---
##### **4.6.3.2. Make your attacker prove they can receive data from you**

맹목적인 공격은 공격자가 피해자로부터 데이터를 받을 수 있다는 것을 증명하도록 강요함으로써 전복될 수 있습니다. 일반적인 기술은 공격자가 메시지 교환에서 이전에 얻은 정보를 사용하여 응답하도록 요구하는 것입니다. 이 대응책을 사용하는 경우 공격자는 자신의 주소를 사용하거나\(추적하기 쉽도록\) 공격이 시작되는 호스트를 통과하는 경로를 따라 다시 라우팅될 주소를 위조해야 합니다.

따라서 작은 서브넷의 호스트는 공격자에게 쓸모가 없습니다\(적어도 스푸핑 공격의 경우\). 공격은 서브넷\(공격자를 찾는 데 충분해야 함\)으로 추적되어 공격 방지 조치를 취할 수 있기 때문입니다. 예를 들어 해당 서브넷의 모든 트래픽을 삭제하도록 경계 라우터를 구성할 수 있습니다. 일반적인 기술은 공격자가 메시지 교환에서 이전에 얻은 정보를 사용하여 응답하도록 요구하는 것입니다.

---
#### **4.6.4. Example: TCP SYN Floods**

TCP/IP는 3방향 핸드셰이크 설계로 인해 SYN 플러드 공격\(섹션 3.3.2에 설명되어 있음\)에 취약합니다. 첫째, 공격자는 단일 패킷을 전송하여 피해자가 상당한 리소스\(이 경우 메모리\)를 소비하도록 강제할 수 있습니다. 둘째, 공격자는 피해자로부터 데이터를 받지 않고도 이 작업을 수행할 수 있기 때문에 공격은 익명으로 수행될 수 있습니다\(따라서 다수의 위조된 소스 주소를 사용함\).

---
#### **4.6.5. Example: Photuris**

\[PHOTURIS\]는 SYN 플러드 공격과 유사한 Photuris에 대한 공격을 방지하는 막힘 방지 메커니즘을 지정합니다. Photuris는 시변 비밀을 사용하여 공격자에게 반환되는 "쿠키"를 생성합니다. 교환이 진행되려면 후속 메시지에서 이 쿠키가 반환되어야 합니다. 흥미로운 특징은 이 쿠키가 나중에 교환 중에 피해자에 의해 재생성될 수 있으므로 공격자가 피해자로부터 패킷을 받을 수 있다는 것을 입증할 때까지 피해자가 상태를 유지할 필요가 없다는 것입니다.

---
### **4.7. Object vs. Channel Security**

개체 보안과 채널 보안을 개념적으로 구분하는 것이 유용합니다. 개체 보안은 전체 데이터 개체에 적용되는 보안 조치를 의미합니다. 채널 보안 조치는 개체를 투명하게 전달할 수 있는 보안 채널을 제공하지만 채널에는 개체 경계에 대한 특별한 지식이 없습니다.

이메일 메시지의 경우를 생각해 보세요. IPSEC 또는 TLS 보안 연결을 통해 전달되는 경우 메시지는 전송 중에 보호됩니다. 그러나 수신자의 메일함과 중간 스풀 파일에서는 보호되지 않습니다. 게다가 메일 서버는 일반적으로 사용자가 아닌 데몬으로 실행되기 때문에 메시지 인증은 일반적으로 사용자가 아닌 데몬의 인증을 의미합니다. 마지막으로 메일 전송은 hop-by-hop이므로 사용자가 첫 번째 홉 릴레이에 인증하더라도 수신자가 인증을 안전하게 확인할 수 없습니다.

이와 대조적으로 이메일 메시지가 S/MIME 또는 OpenPGP로 보호되면 수신자가 검사하고 해독할 때까지 전체 메시지가 암호화되고 무결성이 보호됩니다. 또한 메시지를 보낸 시스템이 아닌 실제 보낸 사람에 대한 강력한 인증을 제공합니다. 이것이 객체 보안입니다. 또한 수신자는 서명된 메시지의 신뢰성을 제3자에게 증명할 수 있습니다.

객체 보안과 채널 보안의 차이점은 관점의 문제입니다. 프로토콜 스택의 한 계층에 있는 개체 보안은 종종 다음 계층의 채널 보안처럼 보입니다. 따라서 IP 계층의 관점에서 볼 때 각 패킷은 개별적으로 보호되는 개체처럼 보입니다. 그러나 웹 클라이언트의 관점에서 보면 IPSEC는 단지 보안 채널을 제공할 뿐입니다.

구별이 항상 명확한 것은 아닙니다. 예를 들어, S-HTTP는 단일 HTTP 트랜잭션에 대해 개체 수준 보안을 제공하지만 웹 페이지는 일반적으로 여러 HTTP 트랜잭션\(기본 페이지 및

수많은 인라인 이미지\). 따라서 전체 웹 페이지의 관점에서 볼 때 이는 채널 보안에 더 가깝습니다. 웹 페이지에 대한 개체 보안은 페이지의 전이적 폐쇄와 단일 단위로 포함된 모든 콘텐츠에 대한 보안으로 구성됩니다.

---
### **4.8. Firewalls and Network Topology**

방화벽을 사용하여 네트워크를 외부 네트워크와 내부 네트워크로 분할하는 것은 현대 네트워크의 일반적인 보안 관행입니다. 내부 네트워크는 안전한 것으로 간주되며 제한된 보안 조치만 사용됩니다. 이러한 네트워크의 내부 부분을 흔히 WALLED GARDEN이라고 합니다.
인터넷 프로토콜 설계자는 세 가지 이유로 자신의 프로토콜이 그러한 환경에 배포될 것이라고 안전하게 가정할 수 없습니다. 첫째, 원래 폐쇄된 환경에 배포되도록 설계된 프로토콜은 나중에 인터넷에 배포되어 심각한 취약점을 야기하는 경우가 많습니다.

둘째, 위상적으로 연결이 끊어진 것처럼 보이는 네트워크는 그렇지 않을 수도 있습니다. 한 가지 이유는 외부 세계의 액세스를 허용하도록 네트워크가 재구성되었기 때문일 수 있습니다. 더욱이 방화벽은 \[SOAP\] 또는 \[HTTP\]와 같은 일반 애플리케이션 계층 프로토콜을 점점 더 많이 전달하고 있습니다. 이러한 일반 프로토콜을 기반으로 하는 네트워크 프로토콜은 일반적으로 방화벽이 이를 보호한다고 가정할 수 없습니다. 마지막으로, 시스템에 대한 가장 심각한 보안 위협 중 하나는 외부인이 아닌 내부자로부터 발생합니다. 내부자는 정의에 따라 내부 네트워크에 액세스할 수 있으므로 방화벽과 같은 토폴로지 보호로는 내부 네트워크를 보호할 수 없습니다.

---
## **5. Writing Security Considerations Sections**

특정 프로토콜이나 시스템이 모든 형태의 공격으로부터 면역되어야 한다는 요구 사항은 아니지만 작성자는 가능한 한 많은 형태를 고려해야 합니다. 보안 고려 사항 섹션의 목적 중 하나는 범위를 벗어나는 공격과 이를 방어하기 위해 적용할 수 있는 대응책을 설명하는 것입니다. \~ 안에

기술된 프로토콜이나 기술에 대한 위협의 종류에 대한 명확한 설명이 있어야 합니다. 이는 잠재적 구현자와 사용자에 대한 알려진 또는 예측 가능한 모든 위험과 위협을 설명하는 "실사"를 수행하려는 노력으로 접근해야 합니다.

```text
   Authors MUST describe
```

1. 어떤 공격이 범위를 벗어났는지\(그리고 그 이유!\) 2. 어떤 공격이 범위 내에 있는지 2.1 프로토콜은 2.2에 취약하며 프로토콜은 다음으로부터 보호합니다.

최소한 도청, 재생, 메시지 삽입, 삭제, 수정, 메시지 가로채기 등의 공격 형태를 고려해야 합니다. 잠재적인 서비스 거부 공격도 식별되어야 합니다. 프로토콜에 암호화 보호 메커니즘이 포함된 경우 데이터의 어느 부분이 보호되고 보호가 무엇인지\(즉, 무결성만, 기밀성 및/또는 엔드포인트 인증 등\) 명확하게 표시되어야 합니다. 암호화 보호가 어떤 종류의 공격에 취약한지에 대한 일부 표시도 제공되어야 합니다. 비밀로 유지되어야 하는 데이터\(키 자료, 무작위 시드 등\)에는 명확하게 라벨이 지정되어야 합니다.

기술에 인증, 특히 사용자 호스트 인증이 포함된 경우 인증 방법의 보안을 명확하게 지정해야 합니다. 즉, 작성자는 이 인증 방법의 보안이 전제된다는 가정을 문서화해야 합니다. 예를 들어, UNIX 사용자 이름/비밀번호 로그인 방법의 경우 다음과 같은 효과에 대한 설명입니다.

- 시스템 내 인증은 최대 8자 길이의 ASCII 비밀번호를 추측하거나 획득하기 어려운 정도까지만 안전합니다. 이러한 비밀번호는 텔넷 세션을 스니핑하거나 /etc/passwd 파일의 내용을 사용하여 'crack' 프로그램을 실행하여 얻을 수 있습니다. \(1\) 여러 번의 로그인 시도 실패 후 연결을 끊고 \(2\) 연속적인 비밀번호 프롬프트 사이에 대기함으로써 온라인 비밀번호 추측으로부터 보호하려는 시도는 공격자가 참을성이 없을 정도로만 효과적입니다.

- /etc/passwd 파일은 사용자 이름을 사용자 ID, 그룹 등에 매핑하기 때문에 누구나 읽을 수 있어야 합니다. 이러한 사용을 허용하지만 크랙 실행을 더 어렵게 만들기 위해 파일은 /etc/passwd와 'shadow' 비밀번호 파일로 분할되는 경우가 많습니다. 섀도우 파일은 누구나 읽을 수 없으며 암호화된 비밀번호를 포함합니다. 일반 /etc/passwd 파일에는 그 자리에 더미 비밀번호가 포함되어 있습니다.

단순히 자신의 프로토콜이 일부 하위 계층 보안 프로토콜을 통해 실행되어야 한다고 말하는 것만으로는 충분하지 않습니다. 시스템이 보안을 위해 하위 계층 보안 서비스에 의존하는 경우

제공할 것으로 예상되는 서비스는 반드시 명확하게 지정되어야 합니다. 또한, 결합된 시스템의 결과 속성을 지정해야 합니다.

참고: 일반적으로 IESG는 프로토콜 내부 또는 하위 계층 보안 프로토콜에 대한 긴밀한 바인딩을 통해 강력한 인증을 제공하지 않는 표준 추적 프로토콜을 승인하지 않습니다.

보안 고려 사항 섹션에서 다루는 위협 환경은 최소한 방화벽이 존재한다는 가정 없이 여러 관리 경계를 넘어 글로벌 인터넷에 걸친 배포를 포함해야 합니다. 이는 그러한 고려 사항이 프로토콜의 범위를 벗어나는 이유에 대한 정당성을 제공하기 위한 것일 지라도 마찬가지입니다. LAN에 적용되는 위협만 논의하고 더 광범위한 위협 환경을 무시하는 것은 허용되지 않습니다. 모든 IETF 표준 추적 프로토콜은 글로벌 인터넷에 배포될 가능성이 있는 것으로 간주됩니다. 어떤 경우에는 특정 환경에서 기술이나 프로토콜의 사용을 권장하지 않는 적용 가능성 설명이 있을 수 있습니다. 그럼에도 불구하고 광범위한 배포의 보안 문제는 문서에서 논의되어야 합니다.

위협 완화가 배포된 후 해당 프로토콜의 사용자 또는 운영자에게 남은 위험에 대한 명확한 설명이 있어야 합니다. 이러한 위험은 관련 프로토콜의 손상\(예: 키 관리가 손상된 경우 IPsec은 쓸모가 없음\), 잘못된 구현, 위험 감소에 사용되는 보안 기술의 손상\(예: 40비트 키를 사용한 암호\), 또는 프로토콜 사양으로 해결되지 않은 위험이 있을 수 있습니다\(예: 기본 링크 프로토콜에 대한 서비스 거부 공격\). 단일 시스템이 손상되면 전체 프로토콜이 손상되는 상황에서는 특별한 주의를 기울여야 합니다. 예를 들어, 일반적으로 프로토콜 설계자는 최종 시스템이 침해되지 않으며 물리적 공격에 대해 걱정하지 않는다고 가정합니다. 그러나 단일 시스템의 손상이 광범위한 손상으로 이어질 수 있는 경우\(예: 인증 기관\)에는 시스템과 물리적 보안도 고려하는 것이 적절합니다.

또한 RFC에 설명된 프로토콜이나 기술의 잠재적인 오용으로 인해 발생하는 잠재적인 보안 위험에 대한 논의도 있어야 합니다. 이는 해당 RFC에 대한 적용 가능성 설명과 결합될 수 있습니다.

---
## **6. Examples**

이 섹션은 독자에게 이 문서에서 의도한 내용을 간략하게 설명하기 위한 몇 가지 보안 고려 사항 섹션 예시로 구성되어 있습니다.

첫 번째 예는 이 문서의 기준을 널리 배포된 기존 프로토콜인 SMTP에 적용하는 '회고적' 예입니다. 두 번째 예는 현재 프로토콜에서 잘라낸 좋은 보안 고려 사항 섹션입니다.

---
### **6.1. SMTP**

RFRFC 821이 작성되었을 때 보안 고려 사항 섹션은 RFC에 필요하지 않았으며 해당 문서에는 아무 것도 포함되어 있지 않습니다. \[RFC 2821\] RFC 821을 업데이트하고 자세한 보안 고려 사항 섹션을 추가했습니다. 여기에 해당 문서의 보안 고려 사항 섹션을 재현합니다\(새 섹션 번호 포함\). 우리의 의견은 들여쓰기되어 있고 앞에 'NOTE:'가 붙습니다. 또한 우리가 중요하다고 생각하는 주제를 다루기 위해 여러 가지 새로운 섹션을 추가했습니다. 해당 섹션은 섹션 헤더에 \[NEW\]로 표시되어 있습니다.

---
#### **6.1.1. Security Considerations**
---
##### **6.1.1.1. Mail Security and Spoofing**

SMTP 메일은 매우 일반적인 사용자라도 수신 및 중계 SMTP 서버와 직접 협상하여 순진한 수신자가 다른 곳에서 온 것처럼 믿도록 속이는 메시지를 생성할 수 있다는 점에서 본질적으로 안전하지 않습니다. 전문가가 "스푸핑된" 행동을 탐지할 수 없도록 그러한 메시지를 구성하는 것은 다소 어렵지만 결단력 있고 지식이 풍부한 사람을 억제할 만큼 충분하지는 않습니다. 결과적으로 인터넷 메일에 대한 지식이 늘어남에 따라 SMTP 메일은 본질적으로 인증될 수 없거나 전송 수준에서 무결성 검사가 제공될 수 없다는 지식도 늘어납니다. 실제 메일 보안은 디지털 서명을 사용하는 방법\(\[14\] 및 PGP \[4\] 또는 S/MIME \[31\] 참조\)과 같이 메시지 본문과 관련된 종단 간 방법에만 있습니다.

- 참고: 보낸 사람 인증에 대한 잘못된 접근 방식 중 하나는 수신 메일 서버가 보낸 사람으로 추정되는 사람에게 연락하여 보낸 사람의 사용자 이름을 묻는 \[IDENT\]입니다. 이는 릴레이, TCP 연결 하이재킹, 원본 서버의 단순한 거짓말 등을 포함하되 이에 국한되지 않는 여러 가지 이유로 나쁜 생각입니다. IDENT의 보안 가치가 낮다는 사실 외에도 수신 사이트에서 IDENT를 사용하면 운영 문제가 발생할 수 있습니다. 많은 송신 사이트가 IDENT 요청을 블랙홀화하므로 수신 서버의 IDENT 요청 시간이 초과될 때까지 메일이 보류됩니다.

전송 수준\(예: SMTP 클라이언트에서 SMTP 서버로\)에서 인증을 제공하는 다양한 프로토콜 확장 및 구성 옵션은 위에서 설명한 기존 상황을 어느 정도 개선합니다. 단, 주의 깊은 보호자가 동반하지 않는 한

신중하게 설계된 신뢰 환경에서 책임의 양도는 전송 시스템의 무결성에 의존하기보다는 디지털 서명된 메시지를 사용하는 종단 간 메커니즘보다 본질적으로 약한 상태로 남아 있습니다.

사용자가 자신의 주소가 아닌 유효한 주소를 가리키도록 봉투 반환 경로와 헤더 "보낸 사람" 필드를 설정하는 것을 더 어렵게 만드는 노력은 대체로 잘못된 것입니다. 이는 한 사용자가 다른 사용자를 대신하여 메일을 보내는 합법적인 응용 프로그램을 좌절시킵니다. 어떤 오류\(또는 일반\) 응답은 특수 주소로 전달되어야 합니까? \(사용자가 메시지별로 이러한 필드를 변경할 수 있는 편리한 방법을 제공하는 시스템은 메시지 데이터 내의 보낸 사람 필드가 현명하게 생성될 수 있도록 사용자에 대한 기본 및 영구 사서함 주소를 설정하려고 시도해야 합니다.\)

이 사양은 메일을 위조하려는 무지한 사용자에 대해 약간의 보호 여유를 제공하기 위해 유용한 기능을 비활성화하지 않도록 옹호하는 것 외에는 SMTP와 관련된 인증 문제를 더 이상 다루지 않습니다.

- 참고: 섹션 6.1.2에 통신 보안 및 SMTP에 대한 추가 자료를 추가했습니다. 최종 사양에서 위 텍스트는 해당 사실을 반영하기 위해 다소 편집될 것입니다.

---
##### **6.1.1.2. Blind Copies**

메시지 헤더에 나타나지 않는 주소는 여러 가지 이유로 SMTP 서버에 대한 RCPT 명령에 나타날 수 있습니다. 가장 일반적인 두 가지 방법은 우편 주소를 "목록 폭발자"\(여러 주소로 확인되는 단일 주소\)로 사용하는 것과 "숨은 참조"로 나타나는 것입니다. 특히 둘 이상의 RCPT 명령이 존재할 때 이러한 메커니즘의 일부 목적을 무효화하는 것을 피하기 위해 SMTP 클라이언트와 서버는 추적 헤더의 일부로 또는 추적 헤더의 일부로 RCPT 명령 인수의 전체 집합을 헤더에 복사해서는 안 됩니다. 정보 또는 개인 확장 헤더. 이 규칙은 실제로 자주 위반되고 시행될 수 없기 때문에 "bcc" 사용을 인식하는 SMTP 시스템을 보내는 것은 단일 RCPT 명령만 포함하는 별도의 메시지 트랜잭션으로 각 숨은 복사본을 보내는 것이 도움이 될 수 있습니다.

SMTP 트랜잭션의 "역방향"\(MAIL, SAML 등의 명령\) 또는 "전달"\(RCPT\) 주소\("봉투"\)와 헤더의 주소 사이에는 고유한 관계가 없습니다. 수신 시스템은 그러한 관계를 추론하여 사용하려고 시도해서는 안 됩니다.

배달할 메시지의 헤더를 변경합니다. 널리 사용되는 "Apparently-to" 헤더는 이 원칙을 위반할 뿐만 아니라 의도하지 않은 정보 공개의 일반적인 소스이므로 사용해서는 안 됩니다.

---
##### **6.1.1.3. VRFY, EXPN, and Security**

섹션 3.5에서 설명한 대로 개별 사이트에서는 보안상의 이유로 VRFY 또는 EXPN 중 하나 또는 둘 다를 비활성화할 수 있습니다. 위의 결과에 따라 이를 허용하는 구현은 실제로 확인되지 않은 확인된 주소를 갖는 것처럼 보여서는 안 됩니다. 사이트에서 보안상의 이유로 이러한 명령을 비활성화하는 경우 SMTP 서버는 확인 성공 또는 실패와 혼동될 수 있는 코드 대신 252 응답을 반환해야 합니다.

구문만 확인한 후 VRFY 명령에 나열된 주소와 함께 250 응답 코드를 반환하는 것은 이 규칙을 위반합니다. 물론 주소가 유효한지 여부에 관계없이 항상 550을 반환하여 VRFY를 "지원"하는 구현은 똑같이 적합하지 않습니다.

지난 몇 년 동안 메일링 리스트의 내용은 소위 "스패머"의 주소 정보 소스로 인기를 끌었습니다. 목록 관리자가 목록 자체의 부적절한 사용에 대한 보호 장치를 설치함에 따라 주소를 "수집"하기 위한 EXPN 사용이 증가했습니다. 구현은 여전히 ​​EXPN에 대한 지원을 제공해야 하지만 사이트는 장단점을 신중하게 평가해야 합니다. 인증 메커니즘이 SMTP에 도입됨에 따라 일부 사이트에서는 인증된 요청자에게만 EXPN을 사용할 수 있도록 선택할 수 있습니다.

- 참고: RCPT TO를 사용하여 주소가 유효한지 여부를 알아내는 것이 가능한 경우가 많기 때문에 VRFY를 비활성화하면 많은 보호 기능이 추가되는지는 확실하지 않습니다.

---
##### **6.1.1.4. Information Disclosure in Announcements**

인사말 응답이나 HELP 명령에 대한 응답에서 서버 유형 및 버전\(때로는 서버 도메인 이름까지\)을 ​​알리는 디버깅 이점과 유용할 수 있는 정보 노출의 단점 사이의 절충점에 대한 지속적인 논쟁이 있었습니다. 잠재적인 적대적 공격에서. 디버깅 정보의 유용성은 의심할 여지가 없습니다. 이를 사용 가능하게 해야 한다고 주장하는 사람들은 서버의 정확한 신원을 숨겨 알려진 취약점을 숨기려고 시도하는 것보다 실제로 SMTP 서버를 보호하는 것이 훨씬 더 낫다고 지적합니다. 사이트에서는 다음 사항을 평가하도록 권장됩니다.

그그 문제를 염두에 두고 절충하십시오. 구현에서는 다른 네트워크 호스트에서 어떤 방식으로든 유형 및 버전 정보를 사용할 수 있도록 최소한으로 제공하는 것이 좋습니다.

---
##### **6.1.1.5. Information Disclosure in Trace Fields**

호스트가 공용 인터넷에 직접 있지 않은 LAN 내에서 메일이 전송되는 경우와 같은 일부 상황에서는 이 사양에 따라 생성된 추적\("수신"\) 필드가 일반적으로 사용할 수 없는 호스트 이름 및 유사한 정보를 공개할 수 있습니다. 이는 일반적으로 문제를 일으키지 않지만, 이름 공개에 대해 특별한 우려가 있는 사이트는 이 사실을 알고 있어야 합니다. 또한 선택적 FOR 절은 여러 수신자가 관련된 경우 "숨은 참조" 수신자의 신원을 다른 사람에게 실수로 공개하지 않도록 주의해서 제공하거나 전혀 제공하지 않아야 합니다.

---
##### **6.1.1.6. Information Disclosure in Message Forwarding**

섹션 3.4에서 논의된 바와 같이, 사서함과 관련된 대체 주소를 식별하기 위해 251 또는 551 응답 코드를 사용하면 실수로 민감한 정보가 공개될 수 있습니다. 이러한 문제를 우려하는 사이트에서는 서버를 적절하게 선택하고 구성해야 합니다.

---
##### **6.1.1.7. Scope of Operation of SMTP Servers**

SMTP 서버가 서버를 제공하는 사이트에 적합한 운영상 또는 기술적인 이유로 메일 수신을 거부할 수 있다는 것은 잘 확립된 원칙입니다. 그러나 사이트와 설치 간의 협력이 인터넷을 가능하게 합니다. 사이트가 트래픽을 거부할 권리를 과도하게 활용하면 이메일 가용성\(인터넷의 강점 중 하나\)의 편재성이 위협받게 됩니다. 사이트가 수용하고 처리할 트래픽을 선별하기로 결정한 경우 상당한 주의를 기울여야 하며 균형이 유지되어야 합니다.

최근에는 메일의 실제 출처를 숨기려는 적대적인 노력의 일환으로 임의 사이트를 통한 중계 기능을 활용하는 경우가 많습니다. 일부 사이트에서는 중계 기능의 사용을 알려졌거나 식별 가능한 소스로 제한하기로 결정했으며 구현에서는 이러한 유형의 필터링을 수행하는 기능을 제공해야 합니다. 이러한 또는 기타 정책 이유로 인해 메일이 거부되면 EHLO, MAIL 또는 RCPT에 대한 응답으로 550 코드를 적절하게 사용해야 합니다.

---
##### **6.1.1.8. Inappropriate Usage [NEW]**

SMTP 자체는 원치 않는 상업용 대량 전자 메일\(스팸이라고도 함\)에 대한 보호 기능을 제공하지 않습니다. 특정 메시지가 스팸인지 아닌지를 선험적으로 판단하는 것은 극히 어렵습니다. 프로토콜 관점에서 스팸은 다른 이메일과 구별할 수 없습니다. 구별은 거의 전적으로 사회적이며 종종 매우 미묘합니다. \(예를 들어 유사한 품목을 광고하기 전에 품목을 구매한 판매자가 보낸 메시지가 스팸입니까?\) SMTP 스팸 억제 메커니즘은 일반적으로 알려진 스팸 발신자를 식별하고 서비스를 거부하거나 처벌/연결 끊김 대상으로 제한됩니다. . \[RFC-2505\]는 SMTP 서버를 스팸 방지하기 위한 광범위한 지침을 제공합니다. 여기서는 주제에 대한 간략한 논의를 제공합니다.

스패머 서비스를 거부하는 주요 도구는 블랙리스트입니다. \[MAPS\]와 같은 일부 기관에서는 알려진 스패머 목록을 수집하고 게시합니다. 그런 다음 개별 SMTP 서버는 블랙리스트에 있는 범죄자를 차단합니다\(일반적으로 IP 주소 기준\).

블랙리스트에 등록되거나 다른 방식으로 식별되는 것을 피하기 위해 스패머는 단순히 허위 SMTP ID를 보내거나 모든 발신자에 대해 메일 릴레이를 수행하는 SMTP 서버인 오픈 릴레이를 통해 메일을 전달하는 방식으로 자신의 신원을 모호하게 시도하는 경우가 많습니다. 결과적으로 이제 오픈 릴레이의 블랙리스트\[ORBS\]도 있습니다.

---
###### **6.1.1.8.1. Closed Relaying [NEW]**

스팸 전달에 사용되는 것을 피하기 위해 많은 SMTP 서버는 폐쇄 릴레이로 작동하여 식별할 수 있는 클라이언트에 대해서만 릴레이 서비스를 제공합니다. 그러한 릴레이는 일반적으로 발신자가 알려진 신원과 일치하는 발신 주소를 광고하도록 주장해야 합니다. 릴레이가 식별 가능한 네트워크\(예: 기업 네트워크 또는 ISP 네트워크\)에 서비스를 제공하는 경우 다른 모든 IP 주소를 차단하는 것으로 충분합니다. 다른 경우에는 명시적 인증을 사용해야 합니다. 이에 대한 두 가지 표준 선택은 TLS \[STARTTLS\]와 SASL \[SASLSMTP\]입니다.

---
###### **6.1.1.8.2. Endpoints [NEW]**

현실적으로 SMTP 끝점은 인증되지 않은 발신자에 대한 서비스 거부를 거부할 수 없습니다. 대다수의 보낸 사람이 인증되지 않았기 때문에 이로 인해 인터넷 메일 상호 운용성이 손상될 수 있습니다. 이에 대한 예외는 엔드포인트 서버가

인증되지 않은 메시지를 받을 수 있는 다른 서버로부터 메일을 받는 경우. 예를 들어, 회사는 공용 게이트웨이를 운영하지만 게이트웨이와만 통신하도록 내부 서버를 구성할 수 있습니다.

---
#### **6.1.2. Communications security issues [NEW]**

SMTP 자체는 통신 보안을 제공하지 않으므로 많은 공격이 가능합니다. SMTP로 전송된 메시지의 텍스트를 복구하려면 수동적 공격만으로도 충분합니다. 프로토콜은 엔드포인트 인증을 제공하지 않습니다. 보낸 사람 스푸핑은 사소한 일이므로 이메일 메시지를 위조하는 일도 쉽지 않습니다. 일부 구현에서는 역방향 이름 확인을 통해 파생된 호스트 이름이 포함된 헤더 라인을 추가합니다\(이는 DNS를 스푸핑하기 어려울 정도로만 안전합니다. 그다지 안전하지는 않습니다\). 하지만 이러한 헤더 라인은 일반적으로 사용자에게 표시되지 않습니다. 수신기 스푸핑도 TCP 연결 하이재킹이나 DNS 스푸핑을 사용하여 매우 간단합니다. 더욱이 이메일 메시지는 종종 SMTP 게이트웨이를 통과하므로 모든 중간 게이트웨이를 신뢰할 수 있어야 하며 이는 글로벌 인터넷에서는 거의 불가능한 조건입니다.

이러한 위협을 완화하기 위해 여러 가지 접근 방식을 사용할 수 있습니다. 프로토콜 스택에서 점점 더 높은 수준으로 올라가기 위해서는 다음이 필요합니다.

- IPSEC SMTP/TLS S/MIME 및 PGP/MIME을 통한 SMTP

---
##### **6.1.2.1. SMTP over IPSEC [NEW]**

IPSEC를 통해 실행되는 SMTP 연결은 보낸 사람과 첫 번째 홉 SMTP 게이트웨이 사이 또는 연결된 SMTP 게이트웨이 쌍 사이의 메시지에 대한 기밀성을 제공할 수 있습니다. 즉, SMTP 연결에 대한 채널 보안을 제공합니다. 메시지가 클라이언트에서 수신자의 게이트웨이로 직접 이동하는 상황에서는 이는 상당한 보안을 제공할 수 있습니다\(수신자는 여전히 게이트웨이를 신뢰해야 함\). 데이터 자체는 보호되고 패킷은 재생할 수 없으므로 재생 공격에 대한 보호가 제공됩니다그러나 수신자의 주소를 직접 암호화 방식으로 인증할 수 없다면 엔드포인트 식별이 문제가 됩니다. 일반적으로 보낸 사람 자신이 아닌 보낸 사람의 컴퓨터만 인증되기 때문에 보낸 사람 식별은 일반적으로 사용할 수 없습니다. 또한 보낸 사람의 신원은 메시지의 보낸 사람 헤더에만 나타나므로 보낸 사람이 쉽게 스푸핑할 수 있습니다. 마지막으로 보안 정책이 극도로 엄격하게 설정되지 않는 한 일반 텍스트 공격으로의 다운그레이드도 활성화됩니다.

SMTP용 보안 솔루션으로서 IPsec의 또 다른 문제점은 표준 IPsec API가 없다는 것입니다. IPsec을 활용하려면 일반적으로 응용 프로그램이 보안 정책에 대해 IPsec 구현에 지시하고 해당 연결에 어떤 보호가 적용되었는지 검색할 수 있어야 합니다. 표준 API가 없으면 이식하기가 매우 어렵습니다.

SMTP 서버 구현자 또는 SMTP 관리자는 IPsec을 사용할 수 있다고 믿을 만한 이유가 없는 한\(예: 두 시스템 간의 기존 연결 존재\) IPsec을 사용할 수 있다고 가정해서는 안 됩니다. 그러나 메일이 배달될 때 피어 서버에 대한 IPsec 연결을 기회적으로 생성하려고 시도하는 것이 합리적인 절차일 수 있습니다. 두 사이트 사이에 VPN 터널을 제공하기 위해 IPsec을 사용하는 경우 이는 위에서 언급한 주의사항에 따라 특히 기밀성이 제공되는 범위에서 상당한 보안 가치를 갖습니다. 또한 IPsec 적용 가능성에 대한 일반적인 지침은 \[USEIPSEC\]를 참조하세요.

---
##### **6.1.2.2. SMTP/TLS [NEW]**

\[STARTTLS\]에 설명된 대로 SMTP는 TLS와 결합될 수 있습니다. 이는 IPSEC를 사용할 때 제공되는 것과 유사한 보호를 제공합니다. TLS 인증서에는 일반적으로 서버의 호스트 이름이 포함되어 있으므로 수신자 인증이 약간 더 명확할 수 있지만 여전히 DNS 스푸핑 공격에 취약합니다. 특히 TLS의 일반적인 구현에는 미국 내보낼 수 있는\(따라서 보안이 낮은\) 모드가 포함되어 있습니다. 높은 수준의 보안을 원하는 애플리케이션에서는 이 모드를 비활성화해야 합니다. 데이터 자체는 보호되고 패킷은 재생할 수 없으므로 재생 공격에 대한 보호가 제공됩니다. \[참고: TLS를 통한 SMTP 문서의 보안 고려 사항 섹션은 매우 훌륭하며 작업 수행 방법의 예로 읽어볼 가치가 있습니다.\]

---
##### **6.1.2.3. S/MIME and PGP/MIME [NEW]**

S/MIME과 PGP/MIME은 모두 메시지 지향 보안 프로토콜입니다. 개별 메시지에 대한 개체 보안을 제공합니다. 다양한 설정을 통해 발신자 및 수신자 인증 및 기밀성을 제공할 수 있습니다. 더 중요한 것은 식별이 송신 및 수신 기계의 식별이 아니라 송신자와 수신자 자체의 식별이라는 것입니다. \(또는 적어도 송신자와 수신자에 해당하는 암호화 키\) 결과적으로 종단 간 보안을 얻을 수 있습니다. 그러나 재생 공격에 대한 보호는 제공되지 않습니다. 또한 S/MIME 및 PGP/MIME은 일반적으로 발신자와 수신자 모두에 대한 식별 표시를 제공합니다. 따라서 기밀성이 제공되더라도 트래픽 분석은 여전히 ​​가능합니다.

---
#### **6.1.3. Denial of Service [NEW]**

이러한 보안 조치 중 어느 것도 서비스 거부에 대한 실질적인 보호를 제공하지 않습니다. SMTP 연결은 과도한 포트 소비, 과도한 디스크 사용\(이메일은 일반적으로 디스크 파일로 전달됨\), 과도한 메모리 소비\(예를 들어 sendmail은 상당히 크고, 일반적으로 각 메시지를 처리하기 위해 새로운 프로세스를 포크합니다.\)

SMTP 연결에 전송 계층 또는 애플리케이션 계층 보안이 사용되는 경우 위조된 RST 또는 다른 종류의 패킷 주입을 사용하여 개별 연결에 다양한 공격을 가하는 것이 가능합니다.

---
### **6.2. VRRP**

두 번째 예는 VRRP\(Virtual Router Redundance Protocol, \[VRRP\]\)의 예입니다. 여기에 해당 문서의 보안 고려 사항 섹션을 재현합니다\(새 섹션 번호 포함\). 우리의 의견은 들여쓰기되어 있고 앞에 'NOTE:'가 붙습니다.

---
#### **6.2.1. Security Considerations**

VRRP는 다양한 보안 정책을 사용할 수 있는 다양한 인터네트워킹 환경을 위해 설계되었습니다. 프로토콜에는 인증 없음, 간단한 일반 텍스트 비밀번호, MD5 HMAC를 통한 IP 인증을 사용한 강력한 인증 등 여러 가지 인증 방법이 포함되어 있습니다. 가능한 공격과 권장 환경을 포함한 각 접근 방식에 대한 세부 정보는 다음과 같습니다.

인증 유형과 관계없이 VRRP에는 다른 원격 네트워크에서 주입되는 VRRP 패킷을 방지하는 메커니즘\(TTL=255 설정, 수신 확인\)이 포함되어 있습니다. 이는 대부분의 취약점을 로컬 공격으로 제한합니다.

- 참고: 다음 섹션에서 설명하는 보안 조치는 다양한 종류의 인증만 제공합니다. 기밀은 전혀 제공되지 않습니다. 이는 범위를 벗어나는 것으로 명시적으로 설명되어야 합니다.

---
##### **6.2.1.1. No Authentication**

이 인증 유형을 사용한다는 것은 VRRP 프로토콜 교환이 인증되지 않음을 의미합니다. 이러한 유형의 인증은 보안 위험이 최소화되고 구성 오류가 발생할 가능성이 거의 없는 환경\(예: LAN에 있는 두 개의 VRRP 라우터\)에서만 사용해야 합니다.

---
##### **6.2.1.2. Simple Text Password**

이 인증 유형을 사용한다는 것은 VRRP 프로토콜 교환이 간단한 일반 텍스트 비밀번호로 인증된다는 것을 의미합니다.

이러한 유형의 인증은 LAN에서 라우터가 실수로 잘못 구성되는 것을 방지하는 데 유용합니다. 라우터가 실수로 다른 라우터를 백업하는 것을 방지합니다. 다른 라우터와 함께 VRRP를 실행하려면 먼저 새 라우터를 올바른 비밀번호로 구성해야 합니다. 이러한 유형의 인증은 LAN에서 VRRP 패킷을 스누핑하는 노드를 통해 비밀번호를 알아낼 수 있는 적대적인 공격으로부터 보호하지 않습니다. TTL 확인과 결합된 단순 텍스트 인증은 VRRP 패킷이 다른 LAN에서 전송되어 VRRP 작업을 방해하는 것을 어렵게 만듭니다.

이러한 유형의 인증은 LAN의 노드가 VRRP 작업을 적극적으로 방해할 위험이 최소화된 경우 권장됩니다. 이러한 유형의 인증을 사용하는 경우 사용자는 이 일반 텍스트 비밀번호가 자주 전송된다는 점을 인식해야 하며 따라서 보안에 중요한 비밀번호와 동일해서는 안 됩니다.

- 참고: 이 섹션은 더 명확해야 합니다. 기본 요점은 인증이 없고 단순 텍스트가 매우 제한된 위협 모델, 즉 로컬 LAN의 노드 중 어느 것도 적대적이지 않다는 것에만 유용하다는 것입니다. TTL 검사는 LAN 외부의 적대적인 노드가 유효한 노드로 위장하는 것을 방지하지만 LAN상의 적대적인 노드가 승인된 노드를 가장하는 것을 막지는 못합니다. 이는 많은 상황에서 특히 현실적인 위협 모델이 아닙니다. 특히 이는 매우 취약합니다. LAN의 모든 노드가 손상되면 VRRP 노드를 재구성할 수 있습니다.

---
##### **6.2.1.3. IP Authentication Header**

이 인증 유형을 사용한다는 것은 VRRP 프로토콜 교환이 \[HMAC\]를 사용하는 IP 인증 헤더 \[AH\]에 의해 정의된 메커니즘을 사용하여 인증된다는 것을 의미합니다. 이는 구성 오류, 재생 공격, 패킷 손상/수정에 대한 강력한 보호 기능을 제공합니다.

이이 유형의 인증은 LAN의 노드 관리에 대한 제어가 제한적일 때 권장됩니다. 이러한 유형의 인증은 VRRP의 작동을 보호하지만 VRRP와 독립적이고 보호되지 않는 공유 미디어 링크\(예: 가짜 ARP 응답 생성\)에 사용할 수 있는 다른 유형의 공격이 있습니다.

- 참고: 이 맥락에서 AH를 RECOMMENDED로 설정하는 것은 실수입니다. AH는 동일한 LAN에 있는 다른 노드의 공격으로부터 VRRP를 보호하는 유일한 메커니즘이므로 동일한 네트워크에 신뢰할 수 없는 노드가 있는 경우 반드시 필요합니다. 어떤 경우든 AH는 반드시 구현되어야 합니다.

- 참고: 이 문서에서만 암시되는 중요한 보안 분석 부분, 즉 VRRP 인증의 비용/이점 균형이 있습니다.

\[이 섹션의 나머지 부분은 새로운 자료입니다.\] VRRP 인증이 방지하려는 위협은 공격자가 VRRP 마스터가 되려고 준비하는 것입니다. 이는 그룹에 가입하고\(아마도 여러 번\) 마스터에게 재갈을 물린 다음 스스로 마스터를 선택함으로써 수행됩니다. 그런 노드는 임의의 바람직하지 않은 방식으로 트래픽을 유도할 수 있습니다.

그러나 이를 수행하기 위해 공격자가 VRRP 마스터일 필요는 없습니다. 공격자는 ARP 패킷을 위조하거나 \(교환 네트워크에서\) 스위치를 속임으로써 네트워크에 유사한 종류의 피해를 입힐 수 있습니다. VRRP 인증은 이러한 공격에 대한 실질적인 보호 기능을 제공하지 않습니다.

불행하게도 인증은 잘못된 구성으로 인해 VRRP 네트워크를 매우 취약하게 만듭니다. 두 노드가 서로 다른 비밀번호로 구성된 경우 어떤 일이 발생하는지 생각해 보세요. 각각은 상대방의 메시지를 거부하므로 둘 다 마스터가 되려고 시도합니다. 이로 인해 네트워크가 상당히 불안정해집니다.

이러한 비용/이익 절충점은 VRRP 인증이 나쁜 생각임을 시사합니다. 왜냐하면 증분적인 보안 이점은 미미하지만 증분적인 위험은 높기 때문입니다. 현재 비VRRP 위협 세트가 제거되면 이 판단을 재검토해야 합니다.

---
## **7. Acknowledgments**



---
## **8. Normative References**

```text
   [AH]       Kent, S. and R. Atkinson, "IP Authentication Header", RFC
              2402, November 1998.

   [DNSSEC]   Eastlake, D., "Domain Name System Security Extensions",
              RFC 2535, March 1999.

   [ENCOPT]   Tso, T., "Telnet Data Encryption Option", RFC 2946,
              September, 2000.

   [ESP]      Kent, S. and R. Atkinson, "IP Encapsulating Security
              Payload (ESP)", RFC 2406, November 1998.

   [GSS]      Linn, J., "Generic Security Services Application Program
              Interface Version 2, Update 1", RFC 2743, January 2000.

   [HTTP]     Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P. and T. Berners-Lee, "HyperText
              Transfer Protocol", RFC 2616, June 1999.

   [HTTPTLS]  Rescorla, E., "HTTP over TLS", RFC 2818, May 2000.

   [HMAC]     Madson, C. and R. Glenn, "The Use of HMAC-MD5-96 within
              ESP and AH", RFC 2403, November 1998.

   KERBEROS]  Kohl, J. and C. Neuman, "The Kerberos Network
              Authentication Service (V5)", RFC 1510, September 1993.

   [KEYWORDS] Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [OTP]      Haller, N., Metz, C., Nesser, P. and M. Straw, "A One-Time
              Password System", STD 61, RFC 2289, February 1998.

   [PHOTURIS] Karn, P. and W. Simpson, "Photuris: Session-Key Management
              Protocol", RFC 2522, March 1999.

   [PKIX]     Housley, R., Polk, W., Ford, W. and D. Solo, "Internet
              X.509 "Public Key Infrastructure Certificate and
              Certificate Restoration List (CRL) Profile", RFC 3280,
              April 2002.

   [RFC-2223] Postel J. and J. Reynolds, "Instructions to RFC Authors",
              RFC 2223, October 1997.

   [RFC-2505] Lindberg, G., "Anti-Spam Recommendations for SMTP MTAs",
              BCP 30, RFC 2505, February 1999.

   [RFC-2821] Klensin, J., "Simple Mail Transfer Protocol", RFC 2821,
              April 2001.

   [SASL]     Myers, J., "Simple Authentication and Security Layer
              (SASL)", RFC 2222, October 1997.

   [SPKI]     Ellison, C., Frantz, B., Lampson, B., Rivest, R., Thomas,
              B. and T. Ylonen, "SPKI Certificate Theory",  RFC 2693,
              September 1999.

   [SSH]      Ylonen, T., "SSH - Secure Login Connections Over the
              Internet", 6th USENIX Security Symposium, p. 37-42, July
              1996.

   [SASLSMTP] Myers, J., "SMTP Service Extension for Authentication",
              RFC 2554, March 1999.

   [STARTTLS] Hoffman, P., "SMTP Service Extension for Secure SMTP over
              Transport Layer Security", RFC 3207, February 2002.

   [S-HTTP]   Rescorla, E. and A. Schiffman, "The Secure HyperText
              Transfer Protocol", RFC 2660, August 1999.

   [S/MIME]   Ramsdell, B., Editor, "S/MIME Version 3 Message
              Specification", RFC 2633, June 1999.

   [TELNET]   Postel, J. and J. Reynolds, "Telnet Protocol
              Specification", STD 8, RFC 854, May 1983.

   [TLS]      Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, January 1999.

   [TLSEXT]   Blake-Wilson, S., Nystrom, M., Hopwood, D. and J.
              Mikkelsen, "Transport Layer Security (TLS) Extensions",
              RFC 3546, May 2003.

   [TCPSYN]   "TCP SYN Flooding and IP Spoofing Attacks", CERT Advisory
              CA-1996-21, 19 September 1996, CERT.
              http://www.cert.org/advisories/CA-1996-21.html

   [UPGRADE]  Khare, R. and S. Lawrence, "Upgrading to TLS Within
              HTTP/1.1", RFC 2817, May 2000.

   [URL]      Berners-Lee, T., Masinter, M. and M. McCahill, "Uniform
              Resource Locators (URL)", RFC 1738, December 1994.

   [VRRP]     Knight, S., Weaver, D., Whipple, D., Hinden, R., Mitzel,
              D., Hunt, P., Higginson, P., Shand, M. and A. Lindemn,
              "Virtual Router Redundancy Protocol", RFC 2338, April
              1998.
```

---
## **9. Informative References**

```text
   [DDOS]     "Denial-Of-Service Tools" CERT Advisory CA-1999-17, 28
              December 1999, CERT http://www.cert.org/advisories/CA-
              1999-17.html

   [EKE]      Bellovin, S., Merritt, M., "Encrypted Key Exchange:
              Password-based protocols secure against dictionary
              attacks", Proceedings of the IEEE Symposium on Research in
              Security and Privacy, May 1992.

   [IDENT]    St. Johns, M. and M. Rose, "Identification Protocol", RFC
              1414, February 1993.

   [INTAUTH]  Haller, N. and R. Atkinson, "On Internet Authentication",
              RFC 1704, October 1994.

   [IPSPPROB] Bellovin, S. M., "Problem Areas for the IP Security
              Protocols", Proceedings of the Sixth Usenix UNIX Security
              Symposium, July 1996.

   [KLEIN]    Klein, D.V., "Foiling the Cracker: A Survey of and
              Improvements to Password Security",  1990.

   [NNTP]     Kantor, B. and P. Lapsley, "Network News Transfer
              Protocol", RFC 977, February 1986.

   [POP]      Myers, J. and M. Rose, "Post Office Protocol - Version 3",
              STD 53, RFC 1939, May 1996.

   [SEQNUM]   Morris, R.T., "A Weakness in the 4.2 BSD UNIX TCP/IP
              Software", AT&T Bell Laboratories, CSTR 117, 1985.

   [SOAP]     Box, D., Ehnebuske, D., Kakivaya, G., Layman, A.,
              Mendelsoh, N., Nielsen, H., Thatte, S., Winer, D., "Simple
              Object Access Protocol (SOAP) 1.1", May 2000.

   [SPEKE]    Jablon, D., "Strong Password-Only Authenticated Key
              Exchange", Computer Communication Review, ACM SIGCOMM,
              vol. 26, no. 5, pp. 5-26, October 1996.

   [SRP]      Wu T.,   [NNTP]     Kantor, B. and P. Lapsley, "Network News Transfer
              Protocol", RFC 977, February 1986.

   [POP]      Myers, J. and M. Rose, "Post Office Protocol - Version 3",
              STD 53, RFC 1939, May 1996.

   [SEQNUM]   Morris, R.T., "A Weakness in the 4.2 BSD UNIX TCP/IP
              Software", AT&T Bell Laboratories, CSTR 117, 1985.

   [SOAP]     Box, D., Ehnebuske, D., Kakivaya, G., Layman, A.,
              Mendelsoh, N., Nielsen, H., Thatte, S., Winer, D., "Simple
              Object Access Protocol (SOAP) 1.1", May 2000.

   [SPEKE]    Jablon, D., "Strong Password-Only Authenticated Key
              Exchange", Computer Communication Review, ACM SIGCOMM,
              vol. 26, no. 5, pp. 5-26, October 1996.

   [SRP]      Wu T., "The Secure Remote Password Protocol", ISOC NDSS
              Symposium, 1998.

   [USEIPSEC] Bellovin, S., "Guidelines for Mandating the Use of IPsec",
              Work in Progress.

   [WEP]      Borisov, N., Goldberg, I., Wagner, D., "Intercepting
              Mobile Communications: The Insecurity of 802.11",
              http://www.isaac.cs.berkeley.edu/isaac/wep-draft.pdf
```

---
## **10. Security Considerations**

이 문서 전체는 보안 고려사항에 관한 것입니다.

---
# **Appendix A.**

이 글을 쓰는 시점의 IAB 회원

```text
   Harald Alvestrand
   Ran Atkinson
   Rob Austein
   Fred Baker
   Leslie Daigle
   Steve Deering
   Sally Floyd
   Ted Hardie
   Geoff Huston
   Charlie Kaufman
   James Kempf
   Eric Rescorla
   Mike St. Johns
```

---
# **Authors' Addresses**

```text
   Eric Rescorla
   RTFM, Inc.
   2439 Alvin Drive
   Mountain View, CA 94043

   Phone: (650)-320-8549
   EMail: ekr@rtfm.com

   Brian Korver
   Xythos Software, Inc.
   77 Maiden Lane, 6th Floor
   San Francisco, CA, 94108

   Phone: (415)-248-3800
   EMail: briank@xythos.com

   Internet Architecture Board
   IAB
   EMail: iab@iab.org
```

---
# **Full Copyright Statement**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

본 문서와 그 번역본은 다른 사람에게 복사 및 제공될 수 있으며, 본 문서에 대해 논평하거나 설명하거나 구현을 지원하는 파생 저작물은 어떤 종류의 제한 없이 전체 또는 일부를 준비, 복사, 출판 및 배포할 수 있습니다. 단, 위의 저작권 표시와 이 단락은 모든 사본과 파생물에 포함되어 있어야 합니다. 그러나 이 문서 자체는 저작권 표시를 제거하거나 인터넷 협회 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떠한 방식으로도 수정할 수 없습니다. 단, 인터넷 표준을 개발할 목적으로 필요한 경우는 제외됩니다. 이 경우 저작권에 대한 절차는 인터넷 표준 프로세스를 따라야 하거나 영어 이외의 언어로 번역하려면 필요한 대로 따라야 합니다.

위에 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회와 인터넷 엔지니어링 태스크 포스는 여기에 있는 정보의 사용으로 인해 발생하지 않는 모든 보증을 포함하되 이에 국한되지 않고 명시적이든 묵시적이든 모든 보증을 부인합니다. 특정 목적에 대한 상품성이나 적합성에 대한 권리나 묵시적인 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집 기능을 위한 자금은 현재 Internet Society에서 제공됩니다.
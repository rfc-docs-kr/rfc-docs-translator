

```text
Internet Engineering Task Force (IETF)                   D. Crocker, Ed.
Request for Comments: 6376                   Brandenburg InternetWorking
Obsoletes: 4871, 5672                                     T. Hansen, Ed.
Category: Standards Track                              AT&T Laboratories
ISSN: 2070-1721                                        M. Kucherawy, Ed.
                                                               Cloudmark
                                                          September 2011

              DomainKeys Identified Mail (DKIM) Signatures
```

---
# **Abstract**

DKIM\(DomainKeys Identified Mail\)을 사용하면 서명 도메인을 소유한 사람, 역할 또는 조직이 도메인을 메시지와 연결하여 메시지에 대한 일부 책임을 주장할 수 있습니다. 이는 작성자의 조직, 운영 중계기 또는 해당 에이전트 중 하나일 수 있습니다. DKIM은 메시지 서명자의 신원에 대한 질문과 메시지 작성자를 분리합니다. 책임 주장은 암호화 서명을 통해 그리고 서명자의 도메인을 직접 쿼리하여 적절한 공개 키를 검색함으로써 검증됩니다. 작성자에서 수신자로의 메시지 전송은 일반적으로 메시지 내용을 실질적으로 변경하지 않으므로 DKIM 서명을 보존하는 릴레이를 통해 이루어집니다.

이 메모는 RFC 4871 및 RFC 5672를 더 이상 사용하지 않습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc6376에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2011 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  DKIM Architecture Documents  . . . . . . . . . . . . . . .  5
     1.2.  Signing Identity . . . . . . . . . . . . . . . . . . . . .  5
     1.3.  Scalability  . . . . . . . . . . . . . . . . . . . . . . .  5
     1.4.  Simple Key Management  . . . . . . . . . . . . . . . . . .  6
     1.5.  Data Integrity . . . . . . . . . . . . . . . . . . . . . .  6
   2.  Terminology and Definitions  . . . . . . . . . . . . . . . . .  6
     2.1.  Signers  . . . . . . . . . . . . . . . . . . . . . . . . .  6
     2.2.  Verifiers  . . . . . . . . . . . . . . . . . . . . . . . .  7
     2.3.  Identity . . . . . . . . . . . . . . . . . . . . . . . . .  7
     2.4.  Identifier . . . . . . . . . . . . . . . . . . . . . . . .  7
     2.5.  Signing Domain Identifier (SDID) . . . . . . . . . . . . .  7
     2.6.  Agent or User Identifier (AUID)  . . . . . . . . . . . . .  7
     2.7.  Identity Assessor  . . . . . . . . . . . . . . . . . . . .  7
     2.8.  Whitespace . . . . . . . . . . . . . . . . . . . . . . . .  8
     2.9.  Imported ABNF Tokens . . . . . . . . . . . . . . . . . . .  8
     2.10. Common ABNF Tokens . . . . . . . . . . . . . . . . . . . .  9
     2.11. DKIM-Quoted-Printable  . . . . . . . . . . . . . . . . . .  9
   3.  Protocol Elements  . . . . . . . . . . . . . . . . . . . . . . 10
     3.1.  Selectors  . . . . . . . . . . . . . . . . . . . . . . . . 10
     3.2.  Tag=Value Lists  . . . . . . . . . . . . . . . . . . . . . 12
     3.3.  Signing and Verification Algorithms  . . . . . . . . . . . 13
     3.4.  Canonicalization . . . . . . . . . . . . . . . . . . . . . 14
     3.5.  The DKIM-Signature Header Field  . . . . . . . . . . . . . 18
     3.6.  Key Management and Representation  . . . . . . . . . . . . 26
     3.7.  Computing the Message Hashes . . . . . . . . . . . . . . . 29
     3.8.  Input Requirements . . . . . . . . . . . . . . . . . . . . 32
     3.9.  Output Requirements  . . . . . . . . . . . . . . . . . . . 32
     3.10. Signing by Parent Domains  . . . . . . . . . . . . . . . . 33
     3.11. Relationship between SDID and AUID . . . . . . . . . . . . 33
   4.  Semantics of Multiple Signatures . . . . . . . . . . . . . . . 34
     4.1.  Example Scenarios  . . . . . . . . . . . . . . . . . . . . 34
     4.2.  Interpretation . . . . . . . . . . . . . . . . . . . . . . 35
   5.  Signer Actions . . . . . . . . . . . . . . . . . . . . . . . . 36
     5.1.  Determine Whether the Email Should Be Signed and by
           Whom . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
     5.2.  Select a Private Key and Corresponding Selector
           Information  . . . . . . . . . . . . . . . . . . . . . . . 37
     5.3.  Normalize the Message to Prevent Transport Conversions . . 37
     5.4.  Determine the Header Fields to Sign  . . . . . . . . . . . 38
     5.5.  Compute the Message Hash and Signature . . . . . . . . . . 43
     5.6.  Insert the DKIM-Signature Header Field . . . . . . . . . . 43
   6.  Verifier Actions . . . . . . . . . . . . . . . . . . . . . . . 43
     6.1.  Extract Signatures from the Message  . . . . . . . . . . . 44
     6.2.  Communicate Verification Results . . . . . . . . . . . . . 49
     6.3.  Interpret Results/Apply Local Policy . . . . . . . . . . . 50
   7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 51
     7.1.  Email Authentication Methods Registry  . . . . . . . . . . 51
     7.2.  DKIM-Signature Tag Specifications  . . . . . . . . . . . . 51
     7.3.  DKIM-Signature Query Method Registry . . . . . . . . . . . 52
     7.4.  DKIM-Signature Canonicalization Registry . . . . . . . . . 52
     7.5.  _domainkey DNS TXT Resource Record Tag Specifications  . . 53
     7.6.  DKIM Key Type Registry . . . . . . . . . . . . . . . . . . 53
     7.7.  DKIM Hash Algorithms Registry  . . . . . . . . . . . . . . 54
     7.8.  DKIM Service Types Registry  . . . . . . . . . . . . . . . 54
     7.9.  DKIM Selector Flags Registry . . . . . . . . . . . . . . . 55
     7.10. DKIM-Signature Header Field  . . . . . . . . . . . . . . . 55
   8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 55
     8.1.  ASCII Art Attacks  . . . . . . . . . . . . . . . . . . . . 55
     8.2.  Misuse of Body Length Limits ("l=" Tag)  . . . . . . . . . 55
     8.3.  Misappropriated Private Key  . . . . . . . . . . . . . . . 56
     8.4.  Key Server Denial-of-Service Attacks . . . . . . . . . . . 56
     8.5.  Attacks against the DNS  . . . . . . . . . . . . . . . . . 57
     8.6.  Replay/Spam Attacks  . . . . . . . . . . . . . . . . . . . 57
     8.7.  Limits on Revoking Keys  . . . . . . . . . . . . . . . . . 58
     8.8.  Intentionally Malformed Key Records  . . . . . . . . . . . 58
     8.9.  Intentionally Malformed DKIM-Signature Header Fields . . . 58
     8.10. Information Leakage  . . . . . . . . . . . . . . . . . . . 58
     8.11. Remote Timing Attacks  . . . . . . . . . . . . . . . . . . 59
     8.12. Reordered Header Fields  . . . . . . . . . . . . . . . . . 59
     8.13. RSA Attacks  . . . . . . . . . . . . . . . . . . . . . . . 59
     8.14. Inappropriate Signing by Parent Domains  . . . . . . . . . 59
     8.15. Attacks Involving Extra Header Fields  . . . . . . . . . . 60
   9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 61
     9.1.  Normative References . . . . . . . . . . . . . . . . . . . 61
     9.2.  Informative References . . . . . . . . . . . . . . . . . . 62
   Appendix A.  Example of Use (INFORMATIVE)  . . . . . . . . . . . . 64
     A.1.  The User Composes an Email . . . . . . . . . . . . . . . . 64
     A.2.  The Email is Signed  . . . . . . . . . . . . . . . . . . . 65
     A.3.  The Email Signature is Verified  . . . . . . . . . . . . . 66
   Appendix B.  Usage Examples (INFORMATIVE)  . . . . . . . . . . . . 67
     B.1.  Alternate Submission Scenarios . . . . . . . . . . . . . . 67
     B.2.  Alternate Delivery Scenarios . . . . . . . . . . . . . . . 69
   Appendix C.  Creating a Public Key (INFORMATIVE) . . . . . . . . . 71
     C.1.  Compatibility with DomainKeys Key Records  . . . . . . . . 72
     C.2.  RFC 4871 Compatibility . . . . . . . . . . . . . . . . . . 73
   Appendix D.  MUA Considerations (INFORMATIVE)  . . . . . . . . . . 73
   Appendix E.  Changes since RFC 4871  . . . . . . . . . . . . . . . 73
   Appendix F.  Acknowledgments . . . . . . . . . . . . . . . . . . . 75
```

---
## **1.  Introduction**

DKIM\(DomainKeys Identified Mail\)을 사용하면 개인, 역할 또는 조직이 도메인 이름 \[RFC1034\]을 사용 권한이 있는 메시지 \[RFC5322\]와 연결하여 메시지에 대한 일부 책임을 주장할 수 있습니다. 이는 작성자의 조직, 운영 중계기 또는 해당 에이전트 중 하나일 수 있습니다. 책임 주장은 암호화 서명을 통해 그리고 서명자의 도메인을 직접 쿼리하여 적절한 공개 키를 검색함으로써 검증됩니다. 작성자에서 수신자로의 메시지 전송은 일반적으로 메시지 내용을 실질적으로 변경하지 않으므로 DKIM 서명을 보존하는 릴레이를 통해 이루어집니다. 메시지에는 메시지와 관련된 동일하거나 다른 조직의 여러 서명이 포함될 수 있습니다.

DKIM이 취한 접근 방식은 다음과 같은 점에서 메시지 서명에 대한 이전 접근 방식\(예: 보안/다목적 인터넷 메일 확장\(S/MIME\) \[RFC5751\], OpenPGP \[RFC4880\]\)과 다릅니다.

```text
   o  the message signature is written as a message header field so that
      neither human recipients nor existing MUA (Mail User Agent)
      software is confused by signature-related content appearing in the
      message body;

   o  there is no dependency on public- and private-key pairs being
      issued by well-known, trusted certificate authorities;

   o  there is no dependency on the deployment of any new Internet
      protocols or services for public-key distribution or revocation;

   o  signature verification failure does not force rejection of the
      message;
```

o 암호화를 메커니즘의 일부로 포함시키려는 시도는 없습니다. 그리고

o 메시지 보관은 설계 목표가 아닙니다.

```text
   DKIM:

   o  is compatible with the existing email infrastructure and
      transparent to the fullest extent possible;

   o  requires minimal new infrastructure;

   o  can be implemented independently of clients in order to reduce
      deployment time;
```

o 점진적으로 배포할 수 있습니다. 그리고

o 제3자에게 서명 위임을 허용합니다.

---
### **1.1.  DKIM Architecture Documents**

독자는 각각 DKIM 개발의 배경, 서비스 개요, 배포 및 운영 지침과 조언을 제공하는 \[RFC4686\], \[RFC5585\] 및 \[RFC5863\]의 자료를 숙지하는 것이 좋습니다.

---
### **1.2.  Signing Identity**

DKIM은 메시지 서명자의 신원에 대한 질문과 메시지 작성자를 분리합니다. 특히 서명에는 서명자의 신원이 포함됩니다. 검증자는 서명 정보를 사용하여 메시지 처리 방법을 결정할 수 있습니다. 서명 ID는 서명 헤더 필드의 일부로 포함됩니다.

- 정보 근거: MUA를 포함하여 수신자 메일 시스템의 광범위한 해석 방법으로 인해 DKIM 서명으로 지정된 서명 ID는 특정 헤더 필드의 주소와 일치할 필요가 없습니다.

---
### **1.3.  Scalability**

DKIM은 이메일 식별 문제를 특징짓는 극도의 확장성 요구 사항을 지원하도록 설계되었습니다. 수백만 개의 도메인과 훨씬 더 많은 수의 개별 주소가 있습니다.

DKIM은 소개 없이 누구나 다른 사람과 통신할 수 있는 기능과 같은 현재 이메일 인프라의 긍정적인 측면을 보존하려고 합니다.

---
### **1.4.  Simple Key Management**

DKIM은 인증 기관 인프라가 필요하지 않다는 점에서 기존의 계층적 공개 키 시스템과 다릅니다. 검증자는 제3자가 아닌 청구된 서명자의 도메인에 있는 저장소에서 직접 공개 키를 요청합니다.

DNS는 공개 키의 초기 메커니즘으로 제안되었습니다. 따라서 DKIM은 현재 DNS 관리 및 DNS 시스템 보안에 의존합니다. DKIM은 다른 키 가져오기 서비스가 출시되면 확장 가능하도록 설계되었습니다.

---
### **1.5.  Data Integrity**

DKIM 서명은 다른 메시지에 서명이 재사용되는 것을 방지하기 위해 "d=" 이름을 메시지 일부 또는 전부의 계산된 해시와 연결합니다\(섹션 3.7 참조\). 서명을 확인하면 해시된 콘텐츠가 서명된 이후 변경되지 않았음을 확인하고 메시지의 종단 간 무결성을 "보호"하는 것과 관련하여 다른 어떤 것도 주장하지 않습니다.

---
## **2.  Terminology and Definitions**

이 섹션에서는 문서의 나머지 부분에서 사용되는 용어를 정의합니다.

DKIM은 \[RFC5598\]에 정의된 대로 인터넷 메일 서비스 내에서 작동하도록 설계되었습니다. 기본 이메일 용어는 해당 사양에서 가져옵니다.

```text
   Syntax descriptions use Augmented BNF (ABNF) [RFC5234].
```

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 \[RFC2119\]에 설명된 대로 해석됩니다. 이 단어는 모두 대문자로 표시되는 경우에만 규범적인 의미를 갖습니다.\(MUST NOT\)

---
### **2.1.  Signers**

도메인을 대신하여 메시지에 서명하는 메일 시스템의 요소를 서명자라고 합니다. 이는 MUA\(Mail User Agents\), MSA\(Mail Submission Agents\), MTA\(Mail Transfer Agents\) 또는 메일링 목록 분해기와 같은 기타 에이전트일 수 있습니다. 일반적으로 모든 서명자는

어떤 방식으로든 메시지 시스템에 메시지를 주입하는 데 관여합니다. 중요한 문제는 메시지가 서명자의 관리 도메인을 떠나기 전에 서명되어야 한다는 것입니다.

---
### **2.2.  Verifiers**

서명을 확인하는 메일 시스템의 요소를 검증자라고 합니다. 이는 MTA, MDA\(메일 배달 에이전트\) 또는 MUA일 수 있습니다. 대부분의 경우 검증자는 메시지의 최종 사용자\(독자\)나 메일링 목록 분석기와 같은 일부 소비 에이전트에 가까이 있을 것으로 예상됩니다.

---
### **2.3.  Identity**

사람, 역할 또는 조직입니다. DKIM의 맥락에서 예로는 작성자, 작성자의 조직, 처리 경로에 따른 ISP, 독립적인 신뢰 평가 서비스 및 메일링 리스트 운영자가 포함됩니다.

---
### **2.4.  Identifier**

ID를 나타내는 레이블입니다.

---
### **2.5.  Signing Domain Identifier (SDID)**

DKIM의 필수 페이로드 출력이며 메시지에 서명하여 메시지에 대한 일부 책임을 주장하는 ID를 나타내는 단일 도메인 이름입니다. 이는 섹션 3.5에 명시되어 있습니다.

---
### **2.6.  Agent or User Identifier (AUID)**

SDID\(서명 도메인 식별자\)가 책임을 맡은 에이전트 또는 사용자를 나타내는 단일 식별자입니다. AUID는 도메인 이름과 선택적 <local-part\>로 구성됩니다. 도메인 이름은 SDID에 사용된 이름과 동일하거나 SDID의 하위 도메인입니다. DKIM 처리의 경우 AUID의 도메인 이름 부분에는 기본 도메인 이름 의미 체계만 있습니다. 가능한 소유자별 의미 체계는 DKIM의 범위를 벗어납니다. 이는 섹션 3.5에 명시되어 있습니다.

AUID에 허용되는 값은 공개 키 레코드의 플래그를 통해 제한될 수 있습니다. \(섹션 3.6.1 참조\)

---
### **2.7.  Identity Assessor**

담당 SDID\(서명 도메인 식별자\)인 DKIM의 페이로드를 사용하는 메일 시스템의 요소입니다. 신원 평가자는 전달된 식별자 평가를 전담합니다.

다른 DKIM\(및 비DKIM\) 값도 신원 평가자\(사용 가능한 경우\)에서 사용되어 보다 일반적인 메시지 평가 필터링 엔진을 제공할 수 있습니다. 그러나 이 추가 활동은 이 사양의 범위를 벗어납니다.

---
### **2.8.  Whitespace**

공백에는 세 가지 형태가 있습니다.

o WSP는 단순 공백, 즉 공백 또는 탭 문자를 나타냅니다\(\[RFC5234\]의 공식 정의\).

o LWSP는 WSP와 CRLF\(\[RFC5234\]의 공식 정의\)로 정의되는 선형 공백입니다.

o FWS는 공백을 접습니다. CRLF와 최소한 하나의 공백으로 구분된 여러 줄을 결합할 수 있습니다.

이에 대한 공식 ABNF는 다음과 같습니다\(WSP 및 LWSP는 정보용으로만 제공됨\).

```text
   WSP =   SP / HTAB
   LWSP =  *(WSP / CRLF WSP)
   FWS =   [*WSP CRLF] 1*WSP
```

FWS의 정의는 obs-FWS를 제외하고는 \[RFC5322\]의 정의와 동일합니다.

---
### **2.9.  Imported ABNF Tokens**

다음 토큰은 명시된 대로 다른 RFC에서 가져옵니다. 이러한 RFC는 최종적인 것으로 간주되어야 합니다.

\[RFC5321\]에서 다음 토큰을 가져옵니다.

```text
   o  "local-part" (implementation warning: this permits quoted strings)

   o  "sub-domain"
```

\[RFC5322\]에서 다음 토큰을 가져옵니다.

```text
   o  "field-name" (name of a header field)

   o  "dot-atom-text" (in the local-part of an email address)
```

\[RFC2045\]에서 다음 토큰을 가져옵니다.

```text
   o  "qp-section" (a single line of quoted-printable-encoded text)

   o  "hex-octet" (a quoted-printable encoded octet)
```

- 참고 사항: \[RFC2045\]의 ABNF는 \[RFC5234\]의 규칙을 따르지 않으며 특히 케이스 접기와 관련하여 그에 따라 해석되어야 합니다.

여기에 정의되지 않은 다른 토큰은 \[RFC5234\]에서 가져옵니다. 이는 SP, HTAB, WSP, ALPHA, DIGIT, CRLF 등과 같은 직관적인 기본 요소입니다.

---
### **2.10.  Common ABNF Tokens**

다음 ABNF 토큰은 이 문서의 다른 곳에서 사용됩니다.

```text
   hyphenated-word =  ALPHA [ *(ALPHA / DIGIT / "-") (ALPHA / DIGIT) ]
   ALPHADIGITPS    =  (ALPHA / DIGIT / "+" / "/")
   base64string    =  ALPHADIGITPS *([FWS] ALPHADIGITPS)
                      [ [FWS] "=" [ [FWS] "=" ] ]
   hdr-name        =  field-name
   qp-hdr-value    =  dkim-quoted-printable    ; with "|" encoded
```

---
### **2.11.  DKIM-Quoted-Printable**

DKIM-Quoted-Printable 인코딩 구문은 Quoted-Printable \[RFC2045\], 섹션 6.7에 설명된 것과 유사합니다. 모든 문자는 "=" 다음에 알파벳 "0123456789ABCDEF"\(소문자는 허용되지 않음\)의 두 개의 16진수 숫자로 인코딩될 수 있습니다. 해당 문자의 16진수로 인코딩된 정수 값입니다. 모든 제어 문자\(값 < %x20\), 8비트 문자\(값 \> %x7F\), 문자 DEL\(%x7F\), SPACE\(%x20\) 및 세미콜론\(";", %x3B\)은 다음과 같아야 합니다. 인코딩되었습니다. SPACE, CR 및 LF 문자를 포함한 모든 공백은 인코딩되어야 합니다. 인코딩 후 지나치게 긴 줄을 피하기 위해 FWS를 임의의 위치에 추가할 수 있습니다. 이러한 공백은 값의 일부가 아니며 디코딩하기 전에 제거해야 합니다. \[RFC2049\]에 "메일 안전"으로 나열되지 않은 문자를 사용하는 것은 권장되지 않습니다.\(MAY, MUST, MUST, MUST, SHOULD NOT\)

```text
   ABNF:

   dkim-quoted-printable =  *(FWS / hex-octet / dkim-safe-char)
                               ; hex-octet is from RFC2045
   dkim-safe-char        =  %x21-3A / %x3C / %x3E-7E
                               ; '!' - ':', '<', '>' - '~'
```

- 참고 사항: DKIM-Quoted-Printable은 여러 가지 중요한 측면에서 \[RFC2045\]에 정의된 Quoted-Printable과 다릅니다.

- 1. 입력 텍스트의 CR, LF를 포함한 공백을 인코딩해야 합니다. \[RFC2045\]는 이러한 인코딩을 요구하지 않으며 CRLF 줄 바꿈의 일부인 CR 또는 LF 문자의 인코딩을 허용하지 않습니다.

- 2. 인코딩된 텍스트의 공백은 무시됩니다. 이는 DKIM-Quoted-Printable을 사용하여 인코딩된 태그를 필요에 따라 래핑할 수 있도록 하기 위한 것입니다. 특히 \[RFC2045\]에서는 입력의 줄 바꿈이 물리적 줄 바꿈으로 표시되도록 요구합니다. 여기서는 그렇지 않습니다.

- 3. "소프트 라인 브레이크" 구문\(라인에서 공백이 아닌 마지막 문자인 "="\)은 적용되지 않습니다.

- 4. DKIM-Quoted-Printable에서는 인코딩된 줄의 길이가 76자 이하여야 한다고 요구하지 않습니다\(단, 인코딩된 텍스트가 사용되는 상황에 따라 다른 요구 사항이 있을 수 있음\).

---
## **3.  Protocol Elements**

프로토콜 요소는 서명자나 검증자에게 특정되지 않은 프로토콜의 개념적 부분입니다. 서명자와 검증자에 대한 프로토콜 설명은 이후 섹션\("서명자 작업"\(섹션 5\) 및 "검증자 작업"\(섹션 6\)\)에서 설명됩니다. 참고: 이 섹션은 해당 섹션의 맥락에서 읽어야 합니다.

---
### **3.1.  Selectors**

서명 도메인당 여러 개의 동시 공개 키를 지원하기 위해 키 네임스페이스는 "선택기"를 사용하여 세분화됩니다. 예를 들어 선택자는 사무실 위치 이름\(예: "sanfrancisco", "coolumbeach" 및 "reykjavik"\), 서명 날짜\(예: "2005년 1월", "2005년 2월" 등\) 또는 개인을 나타낼 수 있습니다. 사용자.

몇 가지 중요한 사용 사례를 지원하려면 선택기가 필요합니다. 예를 들어:

o 특정 기간 동안 특정 주소에 대한 서명 기능을 광고 제공업체 또는 기타 아웃소싱 기능과 같은 파트너에게 위임하려는 도메인.

o 자주 여행하는 사람이 특정 MSA에 연결할 필요 없이 로컬로 메시지를 보낼 수 있도록 하려는 도메인.

o 수신 메일 전달을 제공하지만 발신 메일에 대한 메일 제출 에이전트를 운영하지 않는 "친화성" 도메인\(예: 대학 동창회\).

선택자에는 마침표가 허용되며 구성 요소 구분 기호입니다. DNS에서 키를 검색할 때 선택기의 마침표는 도메인 이름의 일반적인 사용과 유사한 방식으로 DNS 레이블 경계를 정의합니다. 선택기 구성 요소는 날짜와 위치를 결합하는 데 사용될 수 있습니다\(예: "march2005.reykjavik"\). DNS 구현에서 이는 선택기 네임스페이스의 일부를 위임하는 데 사용될 수 있습니다.

```text
   ABNF:

   selector =   sub-domain *( "." sub-domain )
```

각 도메인의 공개 키 수와 해당 선택기 수는 도메인 소유자가 결정합니다. 많은 도메인 소유자는 하나의 선택기로 만족하는 반면, 관리적으로 분산된 조직은 서로 다른 지역이나 서로 다른 이메일 서버에서 서로 다른 선택기와 키 쌍을 관리하도록 선택할 수 있습니다.

관리 편의성 외에도 선택기를 사용하면 정기적으로 공개 키를 원활하게 교체할 수 있습니다. 도메인이 선택기 "january2005"와 연결된 공개 키 사용에서 선택기 "february2005"와 연결된 공개 키로 변경하려는 경우 전환 기간 동안 두 공개 키가 공개 키 저장소에 동시에 광고되는지 확인하기만 하면 됩니다. 확인 전에 이메일이 전송 중일 수 있습니다. 전환 기간이 시작되면 아웃바운드 이메일 서버는 "2005년 2월" 개인 키로 서명하도록 구성됩니다. 전환 기간이 끝나면 "2005년 1월" 공개 키가 공개 키 저장소에서 제거됩니다.

- 참고 사항: 아래 설명에 따라 키가 취소될 수도 있습니다. 키 선택기 레코드 취소와 제거의 차이는 미묘합니다. 위에 설명된 대로 키를 단계적으로 폐지하는 경우 서명 도메인은 전환 기간 후에 키 레코드를 단순히 제거할 수도 있습니다. 그러나 서명 도메인은 추가 기간 동안 키를 취소하도록 선택할 수 있습니다\(그러나 키 레코드는 유지함\). 해지된 키와 제거된 키 사이에는 정의된 의미상 차이가 없습니다.

일부 도메인에서는 선택기 값을 잘 알리기를 원하지만 다른 도메인에서는 외부 당사자가 데이터를 수집할 수 있는 방식으로 선택기 이름을 할당하지 않도록 주의해야 합니다. 예를 들어, 사용자별 키가 발급되면 도메인 소유자는 다음을 결정해야 합니다.

이 선택기를 등록된 최종 사용자의 이름과 직접 연결할지, 아니면 공개 키의 지문과 같은 연결되지 않은 임의의 값으로 만들지 여부입니다.

- 정보 작업 참고: 새 키와 함께 선택기를 재사용하면\(예: 사용자 이름과 연결된 키 변경\) 키가 더 이상 유효하지 않기 때문에 확인되지 않은 메시지와 메시지 간의 차이를 구분하는 것이 불가능해집니다. 그건 실제로 위조된 것입니다. 이러한 이유로 서명자는 새 키에 선택기를 재사용하지 않는 것이 좋습니다. 더 나은 전략은 새 선택기에 새 키를 할당하는 것입니다.

---
### **3.2.  Tag=Value Lists**

DKIM은 메시지 및 도메인 서명 레코드를 포함하여 여러 컨텍스트에서 간단한 "tag=value" 구문을 사용합니다.

값은 일반 텍스트, "base64" 텍스트\(\[RFC2045\], 섹션 6.8에 정의됨\), "qp-section"\(ibid, 섹션 6.7\) 또는 "dkim-quoted-printable"\(정의됨\)을 포함하는 일련의 문자열입니다. 섹션 2.11에서\). 태그 이름에 따라 각 값의 인코딩이 결정됩니다. 인코딩되지 않은 세미콜론\(";"\) 문자는 태그 사양을 구분하므로 태그 값에 사용되어서는 안 됩니다.\(MUST NOT\)

- 정보 구현 참고: 아래 정의된 "일반 텍스트"\("태그 값"\)에는 7비트 문자만 포함되어 있지만 미래 표준을 예상하려는 구현에서는 UTF-8 인코딩 사용을 배제하지 않는 것이 좋습니다. \(\[RFC3629\]\) 태그=값 목록의 텍스트입니다.

공식적으로 ABNF 구문 규칙은 다음과 같습니다.

```text
   tag-list  =  tag-spec *( ";" tag-spec ) [ ";" ]
   tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]
   tag-name  =  ALPHA *ALNUMPUNC
   tag-value =  [ tval *( 1*(WSP / FWS) tval ) ]
                     ; Prohibits WSP and FWS at beginning and end
   tval      =  1*VALCHAR
   VALCHAR   =  %x21-3A / %x3C-7E
                     ; EXCLAMATION to TILDE except SEMICOLON
   ALNUMPUNC =  ALPHA / DIGIT / "_"
```

WSP는 태그 주변 어디에서나 허용됩니다. 특히 "=" 뒤의 WSP와 종료 ";" 앞의 WSP 값의 일부가 아닙니다. 그러나 값 내부의 WSP는 중요합니다.

태그는 대소문자를 구분하여 해석되어야 합니다. 의미론의 특정 태그 설명이 대소문자 구분을 지정하지 않는 한 값은 대소문자를 구분하여 처리되어야 합니다.\(MUST, MUST\)

중복된 이름을 가진 태그는 단일 태그 목록 내에서 발생해서는 안 됩니다. 태그 이름이 두 번 이상 발생하면 전체 태그 목록이 유효하지 않습니다.\(MUST NOT\)

특정 태그 설명에 의해 명시적으로 제외되지 않는 한 값 내의 공백은 유지되어야 합니다.\(MUST\)

가독성을 높이기 위해 기본값을 나타내는 태그=값 쌍이 포함될 수 있습니다.\(MAY\)

인식되지 않는 태그는 무시되어야 합니다.\(MUST\)

값이 비어 있는 태그는 생략된 태그와 동일하지 않습니다. 생략된 태그는 기본값을 갖는 것으로 처리됩니다. 빈 값이 있는 태그는 빈 문자열을 값으로 명시적으로 지정합니다.

---
### **3.3.  Signing and Verification Algorithms**

DKIM은 여러 디지털 서명 알고리즘을 지원합니다. 현재 이 사양에서는 rsa-sha1 및 rsa-sha256이라는 두 가지 알고리즘이 정의됩니다. 서명자는 rsa-sha256을 사용하여 구현하고 서명해야 합니다. 검증자는 rsa-sha1과 rsa-sha256을 모두 구현해야 합니다.\(MUST, MUST\)

- 참고 사항: rsa-sha256을 적극 권장하지만 일부 발신자는 보안 강도와 성능, 복잡성 또는 기타 요구 사항의 균형을 맞출 때 rsa-sha1 사용을 선호할 수 있습니다. 그러나 일반적으로 가능하면 항상 rsa-sha256을 사용해야 합니다.

---
#### **3.3.1.  The rsa-sha1 Signing Algorithm**

rsa-sha1 서명 알고리즘은 SHA-1 \[FIPS-180-3-2008\]을 hash-alg로 사용하여 섹션 3.7에 설명된 대로 메시지 해시를 계산합니다. 그런 다음 해당 해시는 RSA 알고리즘\(PKCS\(공개 키 암호화 표준\) #1 버전 1.5 \[RFC3447\]에 정의됨\)을 crypt-alg 및 서명자의 개인 키로 사용하여 서명자에 의해 서명됩니다. 해시는 서명되기 전에 잘리거나 기본 바이너리 형식이 아닌 다른 형식으로 변환되어서는 안 됩니다. 서명 알고리즘은 65537의 공개 지수를 사용해야 합니다.\(MUST NOT, SHOULD\)

---
#### **3.3.2.  The rsa-sha256 Signing Algorithm**

rsa-sha256 서명 알고리즘은 SHA-256 \[FIPS-180-3-2008\]을 hash-alg로 사용하여 섹션 3.7에 설명된 대로 메시지 해시를 계산합니다. 그런 다음 해당 해시는 RSA 알고리즘을 사용하여 서명자에 의해 서명됩니다\(

PKCS#1 버전 1.5 \[RFC3447\]\)을 crypt-alg 및 서명자의 개인 키로 사용합니다. 해시는 서명되기 전에 잘리거나 기본 바이너리 형식이 아닌 다른 형식으로 변환되어서는 안 됩니다. 서명 알고리즘은 65537의 공개 지수를 사용해야 합니다.\(MUST NOT, SHOULD\)

---
#### **3.3.3.  Key Sizes**

적절한 키 크기를 선택하는 것은 비용, 성능 및 위험 간의 균형을 유지하는 것입니다. 짧은 RSA 키는 오프라인 공격에 더 쉽게 굴복하므로 서명자는 수명이 긴 키에 대해 최소 1024비트의 RSA 키를 사용해야 합니다. 검증자는 512비트에서 2048비트 범위의 키를 사용하여 서명을 검증할 수 있어야 하며\(MUST\) 더 큰 키를 사용하여 서명을 검증할 수 있습니다. 검증자 정책은 서명이 허용되는지 여부를 결정하기 위한 하나의 측정 기준으로 서명 키의 길이를 사용할 수 있습니다.\(MUST, MUST\)

키 크기 선택에 영향을 미치는 요소는 다음과 같습니다.

o 큰\(예: 4096비트\) 키가 512바이트 DNS UDP 응답 패킷에 맞지 않을 수 있다는 실질적인 제약

o 1024비트보다 작은 키는 오프라인 공격을 받기 쉽다는 보안 제약

o 키가 클수록 이메일을 확인하고 서명하는 데 더 많은 CPU 비용이 발생합니다.

o 열쇠는 정기적으로 교체될 수 있습니다. 따라서 수명이 상대적으로 짧을 수 있습니다.

o 이 사양의 보안 목표는 디지털 서명을 사용하는 다른 시스템의 일반적인 목표에 비해 미미합니다.

키 크기 선택에 대한 자세한 내용은 \[RFC3766\]을 참조하세요.

---
#### **3.3.4.  Other Algorithms**

향후 다른 알고리즘이 정의될 수도 있습니다. 검증자는 자신이 구현하지 않은 알고리즘을 사용하는 모든 서명을 무시해야 합니다.\(MAY, MUST\)

---
### **3.4.  Canonicalization**

일부 메일 시스템은 전송 중인 이메일을 수정하여 잠재적으로 서명을 무효화합니다. 대부분의 서명자의 경우 전자 메일을 약간 수정하는 것은 DKIM 도메인 이름 사용을 확인하는 데 중요하지 않습니다. 이러한 서명자의 경우 적당한 전송 중 수정을 유지하는 정규화 알고리즘이 선호됩니다.

다른 서명자는 아무리 사소하더라도 이메일을 수정하면 서명 확인이 실패할 것을 요구합니다. 이러한 서명자는 서명된 이메일의 전송 중 수정을 허용하지 않는 정규화 알고리즘을 선호합니다.

일부 서명자는 \[RFC5322\]와 같은 전자 메일 표준 범위 내에 있는 헤더 필드에 대한 수정을 기꺼이 허용할 수 있지만 메시지 본문에 대한 수정은 허용하지 않을 수 있습니다.

모든 요구 사항을 충족하기 위해 헤더와 본문 각각에 대해 두 개의 정규화 알고리즘이 정의됩니다. 하나는 수정을 거의 허용하지 않는 "단순" 알고리즘이고 다른 하나는 공백 교체 및 헤더 필드 줄 다시 래핑과 같은 일반적인 수정을 허용하는 "완화" 알고리즘입니다. 서명자는 이메일에 서명할 때 헤더 또는 본문에 대한 알고리즘을 지정할 수 있습니다. 서명자가 정규화 알고리즘을 지정하지 않으면 헤더와 본문 모두에 대해 "단순" 알고리즘이 기본값으로 사용됩니다. 검증자는 두 정규화 알고리즘을 모두 구현해야 합니다. 헤더와 본문은 서로 다른 정규화 알고리즘을 사용할 수 있습니다. 향후에 추가 정규화 알고리즘이 정의될 수 있습니다. 검증자는 인식되지 않은 정규화 알고리즘을 사용하는 모든 서명을 무시해야 합니다.\(MAY, MUST, MUST\)

정규화는 서명 또는 확인 알고리즘에 표시할 이메일을 준비하는 것뿐입니다. 어떤 방식으로든 전송된 데이터를 변경해서는 안 됩니다. 헤더 필드와 본문의 정규화는 아래에 설명되어 있습니다.\(MUST NOT\)

참고: 이 섹션에서는 메시지가 이미 "네트워크 일반" 형식\(텍스트는 ASCII로 인코딩되고 줄은 CRLF 문자로 구분됨\)이라고 가정합니다. 메시지 정규화에 대한 자세한 내용은 섹션 5.3을 참조하세요.

---
#### **3.4.1.  The "simple" Header Canonicalization Algorithm**

"간단한" 헤더 정규화 알고리즘은 어떤 방식으로든 헤더 필드를 변경하지 않습니다. 헤더 필드는 서명되거나 확인되는 메시지에 있는 것과 정확히 동일하게 서명 또는 확인 알고리즘에 제공되어야 합니다. 특히 헤더 필드 이름은 대소문자를 구분해서는 안 되며 공백을 변경해서는 안 됩니다.\(MUST, MUST NOT\)

---
#### **3.4.2.  The "relaxed" Header Canonicalization Algorithm**

"완화된" 헤더 정규화 알고리즘은 다음 단계를 순서대로 적용해야 합니다.\(MUST\)

o 모든 헤더 필드 이름\(헤더 필드 값 아님\)을 소문자로 변환합니다. 예를 들어, "제목: AbC"를 "제목: AbC"로 변환합니다.

o \[RFC5322\]에 설명된 대로 모든 헤더 필드 연속 행을 펼칩니다. 특히, 연속된 헤더 필드 값\(즉, WSP가 뒤따르는 CRLF 시퀀스\)에 종결자가 포함된 행은 CRLF 없이 해석되어야 합니다. 구현 시 헤더 필드 값 끝에 있는 CRLF를 제거해서는 안 됩니다.\(MUST, MUST NOT\)

o 하나 이상의 WSP 문자로 구성된 모든 시퀀스를 단일 SP 문자로 변환합니다. 여기서 WSP 문자에는 줄 접기 경계 앞과 뒤의 문자가 포함됩니다.

o 펼쳐진 각 헤더 필드 값 끝에 있는 모든 WSP 문자를 삭제합니다.

o 헤더 필드 값과 헤더 필드 이름을 구분하는 콜론 앞뒤에 남아 있는 WSP 문자를 삭제합니다. 콜론 구분 기호를 유지해야 합니다.\(MUST\)

---
#### **3.4.3.  The "simple" Body Canonicalization Algorithm**

"간단한" 본문 정규화 알고리즘은 메시지 본문 끝에 있는 모든 빈 줄을 무시합니다. 빈 줄은 줄 종결자를 제거한 후 길이가 0이 되는 줄입니다. 메시지 본문에 본문이 없거나 후행 CRLF가 없으면 CRLF가 추가됩니다. 메시지 본문에는 다른 변경 사항이 없습니다. 좀 더 공식적인 용어로 말하면, "간단한" 본문 정규화 알고리즘은 본문 끝에 있는 "\*CRLF"를 단일 "CRLF"로 변환합니다.

완전히 비어 있거나 누락된 본문은 단일 "CRLF"로 정규화됩니다. 즉, 표준화된 길이는 2옥텟이 됩니다.

빈 본문\("CRLF"로 정규화됨\)에 대한 SHA-1 값\(base64\)은 다음과 같습니다.

```text
   uoq1oCgLlTqpdDX/iUbLy7J1Wic=
```

SHA-256 값은 다음과 같습니다.

```text
   frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY=
```

---
#### **3.4.4.  The "relaxed" Body Canonicalization Algorithm**

"완화된" 본문 정규화 알고리즘은 다음 단계 \(a\)와 \(b\)를 순서대로 적용해야 합니다.\(MUST\)

```text
   a.  Reduce whitespace:
```

- \* 줄 끝의 공백은 모두 무시합니다. 구현 시 줄 끝의 CRLF를 제거해서는 안 됩니다.\(MUST NOT\)

- \* 한 줄 내 WSP의 모든 시퀀스를 단일 SP 문자로 줄입니다.

비. 메시지 본문 끝에 있는 빈 줄을 모두 무시하세요. "빈 라인"은 섹션 3.4.3에 정의되어 있습니다. 본문이 비어 있지 않지만 CRLF로 끝나지 않으면 CRLF가 추가됩니다. \(이메일의 경우 이는 SMTP 확장 또는 비SMTP 전송 메커니즘을 사용할 때만 가능합니다.\)

빈 본문\(널 입력으로 정규화됨\)에 대한 SHA-1 값\(base64\)은 다음과 같습니다.

```text
   2jmj7l5rSw0yVb/vlWAYkK/YBwk=
```

SHA-256 값은 다음과 같습니다.

```text
   47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=
```

---
#### **3.4.5.  Canonicalization Examples (INFORMATIVE)**

다음 예에서는 명확성을 위해서만 실제 공백이 사용되었습니다. 실제 입력 및 출력 텍스트는 괄호로 묶인 설명자를 사용하여 지정됩니다. 공백 문자는 "<SP\>", 탭 문자는 "<HTAB\>", 캐리지 리턴/줄 바꿈 시퀀스는 "<CRLF\>"입니다. 예를 들어, "X <SP\> Y" 및 "X<SP\>Y"는 동일한 세 문자를 나타냅니다.

예 1: 메시지 읽기:

```text
   A: <SP> X <CRLF>
   B <SP> : <SP> Y <HTAB><CRLF>
                   <HTAB> Z <SP><SP><CRLF>
   <CRLF>
   <SP> C <SP><CRLF>
   D <SP><HTAB><SP> E <CRLF>
   <CRLF>
   <CRLF>
```

헤더와 본문 모두에 대해 완화된 정규화를 사용하여 정규화하면 헤더 읽기가 발생합니다.

```text
   a:X <CRLF>
   b:Y <SP> Z <CRLF>
```

그리고 본문 읽기 :

```text
   <SP> C <CRLF>
   D <SP> E <CRLF>
```

예 2: 헤더와 본문 모두에 대해 단순 정규화를 사용하여 정규화된 동일한 메시지의 헤더 읽기는 다음과 같습니다.

```text
   A: <SP> X <CRLF>
   B <SP> : <SP> Y <HTAB><CRLF>
          <HTAB> Z <SP><SP><CRLF>
```

그리고 본문 읽기 :

```text
   <SP> C <SP><CRLF>
   D <SP><HTAB><SP> E <CRLF>
```

예 3: 완화된 헤더 정규화 및 단순 본문 정규화를 사용하여 처리할 때 정규화된 버전의 헤더는 다음과 같습니다.

```text
   a:X <CRLF>
   b:Y <SP> Z <CRLF>
```

그리고 본문 읽기 :

```text
   <SP> C <SP><CRLF>
   D <SP><HTAB><SP> E <CRLF>
```

---
### **3.5.  The DKIM-Signature Header Field**

이메일의 서명은 DKIM-Signature 헤더 필드에 저장됩니다. 이 헤더 필드에는 모든 서명 및 키 가져오기 데이터가 포함됩니다. DKIM-Signature 값은 섹션 3.2에 설명된 태그 목록입니다.

DKIM-서명 헤더 필드는 \[RFC5322\]의 섹션 3.6에 정의된 추적 헤더 필드인 것처럼 처리되어야 하며 따라서 순서를 변경해서는 안 되며 메시지 앞에 추가되어야 합니다.\(SHOULD NOT\)

생성되거나 확인되는 DKIM-서명 헤더 필드는 나머지 헤더 필드가 서명된 후 항상 서명 계산에 포함됩니다. 그러나 서명을 계산하거나 확인할 때 해당 DKIM-Signature 헤더 필드의 "b=" 태그\(서명 값\) 값은 빈 문자열인 것처럼 처리되어야 합니다. DKIM-서명 헤더 필드의 알 수 없는 태그는 서명 계산에 포함되어야 하지만 검증자는 이를 무시해야 합니다. 서명에 포함된 다른 DKIM-Signature 헤더 필드는 일반 헤더 필드로 처리되어야 합니다. 특히 "b=" 태그는 특별히 취급되지 않습니다.\(MUST, MUST\)

각 필드 유형에 대한 인코딩은 다음과 같습니다. qp-section으로 설명된 태그는 MIME Part One \[RFC2045\]의 섹션 6.7에 설명된 대로 인코딩되며 세미콜론 문자를 "=3B"로 추가 변환합니다. 직관적으로 이것은 인용된 인쇄 가능한 인코딩된 텍스트의 한 줄입니다. dkim-quoted-printable 구문은 섹션 2.11에 정의되어 있습니다.

DKIM 서명 헤더 필드의 태그와 해당 유형 및 요구 사항 상태가 아래에 표시됩니다. 인식되지 않는 태그는 무시되어야 합니다.\(MUST\)

v= 버전\(일반 텍스트, 필수\). 이 태그는 서명 레코드에 적용되는 이 사양의 버전을 정의합니다. 이 버전의 DKIM을 준수하는 구현의 경우 값이 "1"이어야 합니다.\(MUST, MUST\)

```text
      ABNF:

      sig-v-tag       = %x76 [FWS] "=" [FWS] 1*DIGIT
```

- 참고 사항: DKIM 서명 버전 번호는 이 사양의 새 버전이 출시됨에 따라 산술적으로 증가할 수 있습니다.

a= 서명을 생성하는 데 사용되는 알고리즘\(일반 텍스트;

-  필수의\). 검증자는 "rsa-sha1" 및 "rsa-sha256"을 지원해야 합니다. 서명자는 "rsa-sha256"을 사용하여 서명해야 합니다. 알고리즘에 대한 설명은 섹션 3.3을 참조하세요.\(MUST, MUST\)

```text
      ABNF:

      sig-a-tag       = %x61 [FWS] "=" [FWS] sig-a-tag-alg
      sig-a-tag-alg   = sig-a-tag-k "-" sig-a-tag-h
      sig-a-tag-k     = "rsa" / x-sig-a-tag-k
      sig-a-tag-h     = "sha1" / "sha256" / x-sig-a-tag-h
      x-sig-a-tag-k   = ALPHA *(ALPHA / DIGIT)
                           ; for later extension
      x-sig-a-tag-h   = ALPHA *(ALPHA / DIGIT)
                           ; for later extension
```

b= 서명 데이터\(base64, 필수\). 이 값에서는 공백이 무시되며 원본 서명을 다시 어셈블할 때 무시되어야 합니다. 특히 서명 프로세스에서는 행 길이 제한을 준수하기 위해 임의의 위치에 이 값에 FWS를 안전하게 삽입할 수 있습니다. 서명이 계산되는 방법은 "서명자 작업"\(섹션 5\)을 참조하세요.\(MUST, MUST\)

```text
      ABNF:

      sig-b-tag       = %x62 [FWS] "=" [FWS] sig-b-tag-data
      sig-b-tag-data  = base64string
```

bh= "l=" 태그\(base64; 필수\)로 제한되는 메시지의 정규화된 본문 부분의 해시입니다. 이 값에서는 공백이 무시되며 원본 서명을 다시 어셈블할 때 무시되어야 합니다. 특히 서명 프로세스에서는 행 길이 제한을 준수하기 위해 임의의 위치에 이 값에 FWS를 안전하게 삽입할 수 있습니다. 본문 해시 계산 방법은 섹션 3.7을 참조하세요.\(MUST, MUST\)

```text
      ABNF:

      sig-bh-tag      = %x62 %x68 [FWS] "=" [FWS] sig-bh-tag-data
      sig-bh-tag-data = base64string
```

c= 메시지 정규화\(일반 텍스트, 선택 사항, 기본값은 "단순/단순"\). 이 태그는 서명할 메시지를 준비하는 데 사용되는 정규화 유형을 검증자에게 알립니다. 이는 각각 헤더 및 본문 정규화 알고리즘에 해당하는 "슬래시"\(%d47\) 문자로 구분된 두 개의 이름으로 구성됩니다. 이러한 알고리즘은 섹션 3.4에 설명되어 있습니다. 알고리즘 이름이 하나만 지정된 경우 해당 알고리즘이 헤더에 사용되고 본문에는 "simple"이 사용됩니다. 예를 들어 "c=relaxed"는 "c=relaxed/simple"과 동일하게 처리됩니다.\(MAY\)

```text
      ABNF:

      sig-c-tag       = %x63 [FWS] "=" [FWS] sig-c-tag-alg
                        ["/" sig-c-tag-alg]
      sig-c-tag-alg   = "simple" / "relaxed" / x-sig-c-tag-alg
      x-sig-c-tag-alg = hyphenated-word    ; for later extension
```

d= 메일 스트림에 메시지를 도입하는 책임을 주장하는 SDID\(일반 텍스트, 필수\). 따라서 SDID 값은 공개 키에 대한 쿼리를 구성하는 데 사용됩니다. SDID는 DKIM 키 레코드가 게시되는 유효한 DNS 이름과 일치해야 합니다. 특정 SDID를 생성하고 사용하기 위해 서명자가 사용하는 규칙 및 의미 체계는 이러한 규칙 및 의미 체계의 사용과 마찬가지로 이 사양의 범위를 벗어납니다. 이러한 요구 사항을 충족하지 않는 서명이 제시되면 검증자는 서명이 유효하지 않은 것으로 간주해야 합니다.\(MUST, MUST, MUST\)

- 국제화된 도메인 이름은 \[RFC5890\]의 섹션 2.3에 설명된 대로 A-레이블로 인코딩되어야 합니다.\(MUST\)

```text
      ABNF:

      sig-d-tag       = %x64 [FWS] "=" [FWS] domain-name
      domain-name     = sub-domain 1*("." sub-domain)
                        ; from [RFC5321] Domain,
                        ; excluding address-literal
```

h= 서명된 헤더 필드\(일반 텍스트, 설명 참조, 필수\). 서명 알고리즘에 제공되는 헤더 필드를 식별하는 콜론으로 구분된 헤더 필드 이름 목록입니다. 필드에는 서명 알고리즘에 제시된 순서대로 헤더 필드의 전체 목록이 포함되어야 합니다. 필드에는 서명 시 존재하지 않는 헤더 필드의 이름이 포함될 수 있습니다. 존재하지 않는 헤더 필드는 서명 계산에 기여하지 않습니다. 즉, 헤더 필드 이름, 구분 콜론, 헤더 필드 값 및 모든 CRLF 종결자를 포함하여 null 입력으로 처리됩니다. 필드에는 헤더 필드 이름의 여러 인스턴스가 포함될 수 있습니다. 즉, 해당 헤더 필드가 여러 번 발생하면 헤더 해시에 포함됩니다. 필드에는 생성되거나 확인되는 DKIM-Signature 헤더 필드가 포함되어서는 안 되지만 다른 필드도 포함될 수 있습니다. 접는 공백\(FWS\)은 콜론 구분 기호의 양쪽에 포함될 수 있습니다. 헤더 필드 이름은 대소문자를 구분하지 않고 실제 헤더 필드 이름과 비교되어야 합니다. 이 목록은 비어 있으면 안 됩니다. 서명할 헤더 필드 선택에 대한 설명은 섹션 5.4를 참조하고 단일 필드의 여러 인스턴스에 서명할 때 요구 사항은 섹션 5.4.2를 참조하세요.\(MUST, MUST, MAY, MAY, MUST NOT, MAY, MUST, MUST NOT\)

```text
      ABNF:

      sig-h-tag       = %x68 [FWS] "=" [FWS] hdr-name
                         *( [FWS] ":" [FWS] hdr-name )
```

- 정보 설명: 실제로 존재하지 않는 헤더 필드를 "서명"함으로써 서명자는 검증자가 서명 후 해당 헤더 필드의 삽입을 감지하도록 허용할 수 있습니다. 그러나 서명자는 앞으로 어떤 헤더 필드가 정의될지 알 수 없기 때문에 이 메커니즘을 사용하여 알 수 없는 헤더 필드가 추가되는 것을 방지할 수 없습니다.

- 정보 참고 사항: 서명 시 존재하지 않는 "서명" 필드는 필드와 값이 추가되는 것을 방지할 뿐만 아니라 값이 없는 필드를 추가하는 것도 방지합니다.

i= SDID가 담당하는 AUID\(에이전트 또는 사용자 식별자\)\(dkim-quoted-printable; 선택사항, 기본값은 빈 로컬 부분, "@", "d=의 도메인 순\)입니다. " 태그\).\(MAY\)

- 구문은 로컬 부분이 생략될 수 있는 표준 이메일 주소입니다. 주소의 도메인 부분은 "d=" 태그 값과 동일하거나 하위 도메인이어야 합니다.\(MAY, MUST\)

- 국제화된 도메인 이름은 \[RFC5890\]의 섹션 2.3에 설명된 대로 A-레이블로 인코딩되어야 합니다.\(MUST\)

```text
      ABNF:

      sig-i-tag       = %x69 [FWS] "=" [FWS] [ Local-part ]
                                 "@" domain-name
```

- AUID는 이메일 주소와 동일한 구문을 갖도록 지정되지만 동일한 의미를 가질 필요는 없습니다. 특히 도메인 이름은 DNS에 등록할 필요가 없으므로 쿼리에서 확인되지 않을 수 있으며 로컬 부분은 사서함과 관련되지 않은 네임스페이스에서 가져올 수 있습니다. 네임스페이스의 구조 및 의미에 대한 세부 사항은 서명자에 의해 결정됩니다. 검증자 또는 평가자가 해당 세부 정보를 알고 사용하는 것은 이 사양의 범위를 벗어납니다. 서명자는 AUID에 대해 사용자의 이메일 주소와 동일한 네임스페이스를 사용하도록 선택하거나 사용자를 나타내는 다른 방법을 선택할 수 있습니다. 그러나 서명자는 SDID보다 더 세분화된 안정적인 식별자로 AUID를 사용하는 옵션을 수신자에게 제공하려는 경우 동일한 책임 범위 내에 있는 것으로 평가하려는 각 메시지에 대해 동일한 AUID를 사용해야 합니다.\(MAY, MAY, SHOULD\)

- 참고 사항: "i=" 태그의 로컬 부분은 선택 사항입니다. 어떤 경우에는 서명자가 확인된 개인 신원을 설정하지 못할 수도 있기 때문입니다. 이러한 경우 서명자는 도메인에 서명할 의향이 있지만 도메인 내의 개별 사용자 이름을 커밋할 수 없거나 커밋할 의사가 없다고 주장할 수 있습니다. 도메인 부분은 포함하지만 ID의 로컬 부분은 포함하지 않음으로써 그렇게 할 수 있습니다.

- 정보 토론: 이 사양에서는 메시지 헤더 필드의 ID와 일치하기 위해 "i=" 태그 값이 필요하지 않습니다. 이는 검증기 정책 문제로 간주됩니다. "i=" 태그 값과 다른 헤더 필드의 다른 ID 사이의 제약 조건은 콘텐츠 작성자와 같은 역할과 관련된 신뢰 의미에 기본 인증을 적용하려고 합니다. 신뢰는 광범위하고 복잡한 주제이며, 신뢰 메커니즘은 매우 창의적인 공격을 받기 쉽습니다. "i=" 값과 다른 ID 사이의 가장 기본적인 바인딩을 제외한 모든 것의 실제 유효성은 잘 확립되어 있지 않으며 공격자에 의한 전복에 대한 취약성도 없습니다. 따라서 이러한 옵션의 사용에 의존해야 합니다.

- 엄격하게 제한됩니다. 특히, 일반적인 최종 사용자 수신자가 "i=" 옵션을 성공적으로 사용하여 얻을 수 있는 보장을 어느 정도까지 신뢰할 수 있는지는 전혀 명확하지 않습니다.

l= 본문 길이 수\(일반 텍스트 부호 없는 십진 정수, 선택 사항, 기본값은 전체 본문\) 이 태그는 본문 앞의 CRLF 바로 다음 0부터 시작하여 암호화 해시에 포함된 정규화 후 이메일 본문의 옥텟 수를 검증자에게 알립니다. 이 값은 정규화된 메시지 본문의 실제 옥텟 수보다 커서는 안 됩니다. 섹션 8.2의 추가 논의를 참조하십시오.\(MAY, MUST NOT\)

- 참고 사항: "l=" 태그의 값은 십진수 76자리로 제한됩니다. 이 제약 조건은 향후 메시지의 크기를 예측하거나 가능한 최대 값을 나타낼 수 있을 만큼 큰 정수 표현을 사용하도록 구현을 요구하기 위한 것이 아니지만 구현자가 확인 중에 이 태그와 다른 모든 태그의 길이를 확인하고 확인하도록 상기시키기 위한 것입니다. 값을 디코딩할 때 정수 오버플로를 테스트합니다. 구현자는 메시지가 사용 가능한 저장 공간에 맞도록 하기 위해 표현되는 실제 값을 10^76보다 작은 값으로 제한해야 할 수도 있습니다.

```text
      ABNF:

      sig-l-tag    = %x6c [FWS] "=" [FWS]
                     1*76DIGIT
```

q= 공개 키를 검색하는 데 사용되는 콜론으로 구분된 쿼리 방법 목록\(일반 텍스트, 선택 사항, 기본값은 "dns/txt"\). 각 쿼리 방법은 "type\[/options\]" 형식입니다. 여기서 옵션의 구문과 의미는 유형과 지정된 옵션에 따라 달라집니다. 나열된 쿼리 메커니즘이 여러 개인 경우 쿼리 메커니즘의 선택으로 인해 서명 해석이 변경되어서는 안 됩니다. 구현은 제시된 순서대로 인식된 쿼리 메커니즘을 사용해야 합니다. 인식할 수 없는 쿼리 메커니즘은 무시되어야 합니다.\(MAY, MUST NOT, MUST, MUST\)

- 현재 유일하게 유효한 값은 이 문서의 다른 부분에 설명된 DNS TXT 리소스 레코드\(RR\) 조회 알고리즘을 정의하는 "dns/txt"입니다. "dns" 쿼리 유형에 대해 정의된 유일한 옵션은 "txt"이며 반드시 포함되어야 합니다. 검증자와 서명자는 "dns/txt"를 지원해야 합니다.\(MUST, MUST\)

```text
      ABNF:

      sig-q-tag        = %x71 [FWS] "=" [FWS] sig-q-tag-method
                            *([FWS] ":" [FWS] sig-q-tag-method)
```

sig-q-tag-방법 = "dns/txt" / x-sig-q-tag-유형

- \["/" x-sig-q-tag-args\] x-sig-q-tag-type = 하이픈 단어 ; 향후 확장을 위해 x-sig-q-tag-args = qp-hdr-value

s= "d="\(도메인\) 태그에 대한 네임스페이스를 세분화하는 선택기\(일반 텍스트, 필수\).\(MUST\)

- 국제화된 선택기 이름은 \[RFC5890\]의 섹션 2.3에 설명된 대로 A-레이블로 인코딩되어야 합니다.\(MUST\)

```text
      ABNF:

      sig-s-tag    = %x73 [FWS] "=" [FWS] selector
```

t= 서명 타임스탬프\(일반 텍스트 부호 없는 십진 정수;

- RECOMMENDED, 기본값은 생성 시간을 알 수 없음\). 이 서명이 생성된 시간입니다. 형식은 UTC 시간대 기준으로 1970년 1월 1일 00:00:00 이후의 초 수입니다. 값은 ASCII 10진수로 부호 없는 정수로 표현됩니다. 이 값은 31비트 또는 32비트 정수에 맞게 제한되지 않습니다. 구현은 최소 10^12\(약 AD 200,000까지, 이는 40비트에 적합\)까지의 값을 처리할 수 있도록 준비해야 합니다. 서비스 거부 공격을 방지하기 위해 구현에서는 12자리보다 긴 값을 무한한 것으로 간주할 수 있습니다. 윤초는 계산되지 않습니다. 구현 시 미래의 타임스탬프가 있는 서명을 무시할 수 있습니다\(MAY\).\(SHOULD, SHOULD, MAY, MAY\)

```text
      ABNF:

      sig-t-tag    = %x74 [FWS] "=" [FWS] 1*12DIGIT
```

x= 서명 만료\(일반 텍스트 부호 없는 10진수 정수, 권장, 기본값은 만료 없음\). 형식은 서명 타임스탬프의 시간 델타가 아닌 절대 날짜로 표시되는 "t=" 태그와 동일합니다. 값은 "t=" 태그의 값에 대한 동일한 제약 조건을 사용하여 10진수 ASCII의 부호 없는 정수로 표현됩니다. 검증자의 검증 시간이 만료 날짜를 지난 경우 서명은 유효하지 않은 것으로 간주될 수 있습니다. 확인 시간은 해당 시간이 안정적으로 사용 가능한 경우 확인자의 관리 도메인에서 메시지가 처음 수신된 시간이어야 합니다. 그렇지 않으면 현재 시간을 사용해야 합니다. "x=" 태그의 값은 "t=" 태그가 둘 다 존재하는 경우 값보다 커야 합니다.\(SHOULD, MAY, MUST\)

- 정보 참고 사항: "x=" 태그는 재생 방지 방어를 위한 것이 아닙니다.

- 참고 사항: 클록 드리프트로 인해 서명이 만료된 것으로 간주해야 하는 시점에 대한 수신자의 개념이 발신자가 기대하는 것과 정확하게 일치하지 않을 수 있습니다. 수신기는 이러한 드리프트 가능성을 허용하기 위해 '퍼지 요소'를 추가할 수 있습니다.\(MAY\)

```text
      ABNF:

      sig-x-tag    = %x78 [FWS] "=" [FWS]
                                    1*12DIGIT
```

z= 복사된 헤더 필드\(dkim-quoted-printable, 설명 참조, 선택사항, 기본값은 null임\) 필드 이름과 값을 모두 포함하여 메시지가 서명되었을 때 표시되는 선택한 헤더 필드의 세로 막대로 구분된 목록입니다. 서명 시 존재하는 모든 헤더 필드를 포함할 필요는 없습니다. 이 필드에는 "h=" 태그에 나열된 것과 동일한 헤더 필드가 포함될 필요는 없습니다. 헤더 필드 텍스트 자체는 세로 막대\("|", %x7C\) 문자를 인코딩해야 합니다. 즉, "z=" 텍스트의 세로 막대는 메타 문자이고 복사된 헤더 필드의 실제 세로 막대 문자는 인코딩되어야 합니다. \). 콜론과 헤더 필드 값 사이의 공백을 포함하여 모든 공백을 인코딩해야 합니다. 인코딩 후 지나치게 긴 줄을 피하기 위해 FWS를 임의의 위치에 추가할 수 있습니다. 이러한 공백은 헤더 필드 값의 일부가 아니며 디코딩하기 전에 제거해야 합니다.\(MAY, MUST\)

- "h=" 태그에 의해 참조되는 헤더 필드는 "z=" 태그에 복사된 필드가 아니라 메시지의 \[RFC5322\] 헤더에 있는 필드를 참조합니다. 복사된 헤더 필드 값은 진단용입니다.

```text
      ABNF:

      sig-z-tag      = %x7A [FWS] "=" [FWS] sig-z-tag-copy
                       *( "|" [FWS] sig-z-tag-copy )
      sig-z-tag-copy = hdr-name [FWS] ":" qp-hdr-value
```

- 여러 연속 라인에 분산된 서명 헤더 필드의 정보 예:

```text
   DKIM-Signature: v=1; a=rsa-sha256; d=example.net; s=brisbane;
      c=simple; q=dns/txt; i=@eng.example.net;
      t=1117574938; x=1118006938;
      h=from:to:subject:date;
      z=From:foo@eng.example.net|To:joe@example.com|
       Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700;
      bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;
      b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZVoG4ZHRNiYzR
```

---
### **3.6.  Key Management and Representation**

서명 응용 프로그램에는 확인 공개 키가 청구된 서명자와 연결되어 있다는 일정 수준의 보증이 필요합니다. 많은 애플리케이션은 신뢰할 수 있는 제3자가 발급한 공개 키 인증서를 사용하여 이를 달성합니다. 그러나 DKIM은 검증자가 공개 키를 검색하기 위해 서명자의 DNS 항목\(또는 일부 보안과 동등한 항목\)을 쿼리하도록 함으로써 확장성이 크게 향상되어 충분한 수준의 보안을 달성할 수 있습니다.

DKIM 키는 잠재적으로 여러 유형의 키 서버와 여러 형식으로 저장될 수 있습니다. 키의 저장 및 형식은 DKIM 알고리즘의 나머지 부분과 관련이 없습니다.

키 조회 알고리즘에 대한 매개변수는 조회 유형\("q=" 태그\), 서명자의 도메인\(DKIM-서명 헤더 필드의 "d=" 태그\) 및 선택기\("s= " 태그\).

```text
   public_key = dkim_find_key(q_val, d_val, s_val)
```

이 문서에서는 DNS TXT RR을 사용하여 키를 배포하는 단일 바인딩을 정의합니다. 나중에 다른 바인딩이 정의될 수 있습니다.

---
#### **3.6.1.  Textual Representation**

많은 키 서버가 구조화되지 않은 텍스트 형식으로 키를 표시하도록 선택할 것으로 예상됩니다\(예를 들어, XML 형식은 이 목적을 위해 구조화되지 않은 텍스트로 간주되지 않습니다\). 구조화되지 않은 텍스트 형식으로 표현되는 모든 DKIM 키에는 다음 정의를 사용해야 합니다.\(MUST\)

전체 구문은 섹션 3.2에 설명된 태그 목록입니다. 현재 유효한 태그는 아래에 설명되어 있습니다. 다른 태그가 존재할 수 있으며 이를 이해하지 못하는 구현에서는 반드시 무시해야 합니다.\(MUST\)

v= DKIM 키 레코드의 버전\(일반 텍스트, 권장됨, 기본값은 "DKIM1"\). 지정된 경우 이 태그는 "DKIM1"\(따옴표 제외\)로 설정되어야 합니다. 이 태그는 레코드의 첫 번째 태그여야 합니다. 다른 값을 갖는 "v=" 태그로 시작하는 레코드는 폐기되어야 합니다. 검증자는 이 값에 대해 문자열 비교를 수행해야 합니다. 예를 들어 "DKIM1"은 "DKIM1.0"과 동일하지 않습니다.\(SHOULD, MUST, MUST, MUST\)

```text
      ABNF:

      key-v-tag    = %x76 [FWS] "=" [FWS] %x44.4B.49.4D.31
```

h= 허용되는 해시 알고리즘\(일반 텍스트, 선택사항, 기본값은 모든 알고리즘 허용\) 사용할 수 있는 해시 알고리즘의 콜론으로 구분된 목록입니다. 인식할 수 없는 알고리즘은 무시해야 합니다. 서명자와 검증자가 구현하는 해시 알고리즘에 대한 논의는 섹션 3.3을 참조하세요. 각 레코드의 이 태그에 나열된 알고리즘 세트는 서명자가 선택한 작업입니다.\(MAY, MUST\)

```text
      ABNF:

      key-h-tag       = %x68 [FWS] "=" [FWS] key-h-tag-alg
                        *( [FWS] ":" [FWS] key-h-tag-alg )
      key-h-tag-alg   = "sha1" / "sha256" / x-key-h-tag-alg
      x-key-h-tag-alg = hyphenated-word   ; for future extension
```

k= 키 유형\(일반 텍스트, 선택 사항, 기본값은 "rsa"\) 서명자와 검증자는 "rsa" 키 유형을 지원해야 합니다. "rsa" 키 유형은 ASN.1 DER로 인코딩된 \[ITU-X660-1997\] RSAPublicKey\(\[RFC3447\], 섹션 3.1 및 A.1.1 참조\)가 "p=" 태그에서 사용되고 있음을 나타냅니다. \(참고: "p=" 태그는 base64 알고리즘을 사용하여 값을 추가로 인코딩합니다.\) 인식할 수 없는 키 유형은 무시해야 합니다.\(MAY, MUST, MUST\)

```text
      ABNF:

      key-k-tag        = %x76 [FWS] "=" [FWS] key-k-tag-type
      key-k-tag-type   = "rsa" / x-key-k-tag-type
      x-key-k-tag-type = hyphenated-word   ; for future extension
```

n= 사람이 관심을 가질 수 있는 메모\(qp-섹션; 선택 사항, 기본값은 비어 있음\) 어떤 프로그램에서도 해석이 이루어지지 않습니다. 이 태그는 공간 제한이 있는 모든 키 서버 메커니즘\(특히 DNS\)에서는 자제해서 사용해야 합니다. 이는 최종 사용자가 아닌 관리자가 사용하기 위한 것입니다.\(MAY\)

```text
      ABNF:

      key-n-tag    = %x6e [FWS] "=" [FWS] qp-section
```

p= 공개 키 데이터\(base64, 필수\). 값이 비어 있으면 이 공개 키가 취소되었음을 의미합니다. base64로 인코딩되기 전 이 태그 값의 구문과 의미는 "k=" 태그로 정의됩니다.\(MUST\)

- 정보 근거: 개인 키가 손상되었거나 비활성화된 경우\(예: 아웃소싱 계약이 종료된 경우\) 서명자는 선택기에 대해 알고 있다고 명시적으로 밝히고 싶어할 수 있지만 해당 선택기를 사용하는 모든 메시지는

- 검증에 실패해야 합니다. 검증자는 취소된 키를 참조하는 선택기와 함께 모든 DKIM 서명 헤더 필드에 대한 오류 코드를 반환해야 합니다\(SHOULD\). \(자세한 내용은 섹션 6.1.2를 참조하세요.\)\(SHOULD\)

```text
      ABNF:

      key-p-tag    = %x70 [FWS] "=" [ [FWS] base64string]
```

- 참고 사항: base64string은 임의의 위치에 공백\(FWS\)을 포함하는 것이 허용됩니다. 그러나 모든 CRLF 뒤에는 최소한 하나의 WSP 문자가 와야 합니다. 구현자와 관리자는 선택기 TXT RR이 이 사양을 준수하는지 확인해야 합니다.

s= 서비스 유형\(일반 텍스트, 선택 사항, 기본값은 "\*"\). 이 레코드가 적용되는 콜론으로 구분된 서비스 유형 목록입니다. 특정 서비스 유형에 대한 검증자는 적절한 유형이 나열되지 않은 경우 이 기록을 무시해야 합니다. 인식할 수 없는 서비스 유형은 무시해야 합니다. 현재 정의된 서비스 유형은 다음과 같습니다.\(MAY, MUST, MUST\)

```text
      *  matches all service types

      email   electronic mail (not necessarily limited to SMTP)
```

- 이 태그는 향후 다른 서비스에서 DKIM 사용을 정의할 경우 다른 목적으로 키 사용을 제한하기 위한 것입니다.

```text
      ABNF:

      key-s-tag        = %x73 [FWS] "=" [FWS] key-s-tag-type
                         *( [FWS] ":" [FWS] key-s-tag-type )
      key-s-tag-type   = "email" / "*" / x-key-s-tag-type
      x-key-s-tag-type = hyphenated-word   ; for future extension
```

t= 콜론으로 구분된 이름 목록으로 표시되는 플래그입니다\(일반 텍스트, 선택 사항, 기본값은 플래그가 설정되지 않음\). 인식할 수 없는 플래그는 무시해야 합니다. 정의된 플래그는 다음과 같습니다.\(MAY, MUST\)

- y 이 도메인은 DKIM을 테스트하고 있습니다. 검증자는 테스트 모드에 있는 서명자의 메시지를 서명되지 않은 이메일과 다르게 처리해서는 안 됩니다. 서명이 검증에 실패하는 경우에도 마찬가지입니다. 검증자는 서명자를 지원하기 위해 테스트 모드 결과를 추적할 수 있습니다.\(MUST NOT, MAY\)

- s "i=" 태그를 사용하는 모든 DKIM 서명 헤더 필드는 "i=" 태그의 "@" 오른쪽에 있는 동일한 도메인 값과 "d=" 태그 값을 가져야 합니다. 즉, "i=" 도메인은 "d="의 하위 도메인이 되어서는 안 됩니다. 하위 도메인 지정이 필요하지 않은 경우 이 플래그를 사용하는 것이 좋습니다.\(MUST, MUST NOT, SHOULD\)

```text
      ABNF:

      key-t-tag        = %x74 [FWS] "=" [FWS] key-t-tag-flag
                         *( [FWS] ":" [FWS] key-t-tag-flag )
      key-t-tag-flag   = "y" / "s" / x-key-t-tag-flag
      x-key-t-tag-flag = hyphenated-word   ; for future extension
```

---
#### **3.6.2.  DNS Binding**

DNS TXT RR을 주요 서비스로 사용하는 바인딩이 이에 따라 정의됩니다. 모든 구현은 이 바인딩을 지원해야 합니다.\(MUST\)

---
##### **3.6.2.1.  Namespace**

모든 DKIM 키는 "\_domainkey"라는 하위 도메인에 저장됩니다. "example.com"의 "d=" 태그와 "foo.bar"의 "s=" 태그가 있는 DKIM 서명 필드가 있는 경우 DNS 쿼리는 "foo.bar.\_domainkey.example.com"에 대한 것입니다. .

---
##### **3.6.2.2.  Resource Record Types for Key Storage**

사용되는 DNS 리소스 레코드 유형은 쿼리 유형\("q="\) 태그에 대한 옵션으로 지정됩니다. 이 기본 사양에 정의된 유일한 옵션은 TXT RR의 사용을 나타내는 "txt"입니다. 이 표준의 이후 확장에서는 다른 RR 유형을 정의할 수 있습니다.

TXT RR의 문자열은 사용하기 전에 공백 없이 함께 연결되어야 합니다. TXT RR은 특정 선택기 이름에 대해 고유해야 합니다. 즉, RRset에 여러 레코드가 있으면 결과가 정의되지 않습니다.\(MUST, MUST\)

TXT RR은 섹션 3.6.1에 설명된 대로 인코딩됩니다.

---
### **3.7.  Computing the Message Hashes**

```text
   Both signing and verifying message signatures start with a step of
   computing two cryptographic hashes over the message.  Signers will
   choose the parameters of the signature as described in "Signer
   Actions" (Section 5); Verifiers will use the parameters specified in
   the DKIM-Signature header field being verified.  In the following
   discussion, the names of the tags in the DKIM-Signature header field
   that either exists (when verifying) or will be created (when signing)
```

사용됩니다. 정규화\(섹션 3.4\)는 서명 또는 확인을 위해 이메일을 준비하는 데에만 사용됩니다. 전송된 이메일에는 어떤 방식으로도 영향을 미치지 않습니다.

서명자/검증자는 메시지 본문에 대해 하나, 메시지의 선택된 헤더 필드에 대해 하나, 두 개의 해시를 계산해야 합니다.\(MUST\)

서명자는 표시된 순서대로 이를 계산해야 합니다. 검증자는 검증자에게 편리한 순서로 이를 계산할 수 있습니다. 단, 결과는 이 순서로 계산된 경우의 의미론과 의미론적으로 동일해야 합니다.\(MUST, MAY\)

해시 1단계에서 서명자/검증자는 메시지 본문을 해시해야 하며, "c=" 태그에 지정된 본문 정규화 알고리즘을 사용하여 정규화된 다음 "l=" 태그에 지정된 길이로 잘립니다. 그런 다음 해당 해시 값은 base64 형식으로 변환되어 DKIM-Signature 헤더 필드의 "bh=" 태그\(서명자\)에 삽입되거나 \(검증자\)와 비교됩니다.\(MUST\)

해시 2단계에서 서명자/검증자는 표시된 순서대로 해시 알고리즘에 다음을 전달해야 합니다.\(MUST\)

1. "h=" 태그에 의해 지정된 헤더 필드는 해당 태그에 지정된 순서대로, "c=" 태그에 지정된 헤더 정규화 알고리즘을 사용하여 정규화됩니다. 각 헤더 필드는 단일 CRLF로 종료되어야 합니다.\(MUST\)

2. "b=" 태그\(주변의 모든 공백 포함\) 값이 삭제된\(즉, 빈 문자열로 처리됨\) 메시지에 존재\(검증\)하거나 삽입\(서명\)될 DKIM-Signature 헤더 필드 , "c=" 태그에 지정된 헤더 정규화 알고리즘을 사용하여 후행 CRLF 없이 정규화됩니다.

DKIM-Signature 헤더 필드의 모든 태그와 해당 값은 null 문자열로 처리되어야 하는 "b="\(서명\) 태그의 값 부분을 제외하고 암호화 해시에 포함됩니다. 모든 태그는 검증자가 이해하지 못하더라도 반드시 포함되어야 합니다. 헤더 필드는 나머지 헤더 필드가 아닌 메시지 본문 다음에 해시 알고리즘에 제시되어야 하며 "c="\(정규화\) 태그에 지정된 대로 정규화되어야 합니다. DKIM-Signature 헤더 필드는 자체 "h=" 태그에 포함되어서는 안 되지만, 다른 DKIM-Signature 헤더 필드는 서명될 수 있습니다\(섹션 4 참조\).\(MUST, MUST, MUST, MUST NOT\)

base64 또는 quoted-printable 인코딩을 사용하여 전송될 메시지의 해시를 계산할 때 서명자는 인코딩 후에 해시를 계산해야 합니다. 마찬가지로 검증자는 다음을 통합해야 합니다.\(MUST, MUST\)

base64 또는 인용된 인쇄 가능한 텍스트를 디코딩하기 전에 값을 해시에 추가합니다. 그러나 해시는 SMTP "점 채우기"\(\[RFC5321\]에 지정된 대로 SMTP 메시지 끝 표시와의 혼동을 피하기 위해 "."으로 시작하는 줄 수정\)와 같은 전송 수준 인코딩 전에 계산되어야 합니다. \).\(MUST\)

섹션 3.4에 설명된 정규화 절차를 제외하고 DKIM 서명 프로세스는 메시지 본문을 단순히 옥텟 문자열로 처리합니다. DKIM 메시지는 일반 텍스트 또는 MIME 형식일 수 있습니다. MIME 콘텐츠에는 특별한 처리가 제공되지 않습니다. MIME 형식의 메시지 첨부 파일은 서명된 콘텐츠에 포함되어야 합니다.\(MAY, MUST\)

보다 공식적으로 서명 알고리즘의 의사 코드는 다음과 같습니다.

```text
   body-hash    =  hash-alg (canon-body, l-param)
   data-hash    =  hash-alg (h-headers, D-SIG, body-hash)
   signature    =  sig-alg (d-domain, selector, data-hash)

   where:
```

body-hash: hash-alg를 사용하여 본문을 해싱한 결과입니다.

hash-alg: "a" 매개변수에 지정된 해싱 알고리즘입니다.

canon-body: 섹션 3.4에 정의된 대로 "c" 매개변수에 지정된 본문 알고리즘을 사용하고 DKIM 서명 필드를 제외하고 생성된 본문의 정규화된 표현입니다.

l-param: "l" 매개변수의 본문 길이 값입니다.

data-hash: DKIM-Signature 헤더를 포함한 헤더와 본문 해시를 해시하기 위해 hash-alg 알고리즘을 사용한 출력입니다.

h-headers: "h" 매개변수에 지정된 대로 서명할 헤더 목록입니다.

D-SIG: 매개변수의 서명 값 부분, 즉 빈 매개변수 값이 없는 정규화된 DKIM-Signature 필드 자체입니다.

서명: 서명 알고리즘에 의해 생성된 서명 값입니다.

sig-alg: "a"로 지정된 서명 알고리즘입니다.

- 매개변수.

d-domain: "d" 매개변수에 지정된 도메인 이름입니다.

선택기: "s" 매개변수에 지정된 선택기 값입니다.

- 참고: 많은 디지털 서명 API는 단일 "sign\(\)" 프리미티브를 사용하여 RSA 개인 키의 해싱과 적용을 모두 제공합니다. 이러한 API를 사용할 때 알고리즘의 마지막 두 단계는 아마도 "a-hash-alg"와 "sig-alg"를 모두 수행하는 단일 호출로 결합될 것입니다.

---
### **3.8.  Input Requirements**

\[RFC5322\], \[RFC2045\] 및 \[RFC2047\]을 준수하지 않는 메시지는 중개자가 해당 콘텐츠를 수정하거나 해석하려는 시도를 받을 수 있습니다. 일반적으로 수행되는 변경의 예는 \[RFC4409\]의 섹션 8을 참조하세요. 이러한 "수정"은 DKIM 서명을 무효화하거나 메시지가 최종 사용자에게 표시되는 방식의 변경을 포함하는 기타 바람직하지 않은 영향을 미칠 수 있습니다.

따라서 DKIM의 설계는 유효한 입력을 전제로 합니다. 따라서 서명자와 검증자는 처리 중인 메시지가 \[RFC5322\], \[RFC2045\] 및 기타 관련 메시지 형식 표준에 따라 유효한지 확인하기 위해 합리적인 조치를 취해야 합니다.\(SHOULD\)

추가 논의는 섹션 8.15를 참조하십시오.

---
### **3.9.  Output Requirements**

각 서명의 평가는 이 문서에서 다음과 같이 언급하는 세 가지 상태 중 하나로 끝납니다.

성공: 성공적인 검증

PERMFAIL: 서명 확인 실패와 같은 영구적이고 복구 불가능한 오류

TEMPFAIL: DNS 쿼리 시간 초과와 같은 일시적이고 복구 가능한 오류

성공적으로 확인되거나 TEMPFAIL 결과를 생성하는 각 서명에 대해 DKIM 알고리즘의 출력에는 다음 집합이 포함되어야 합니다.\(MUST\)

o "d=" 서명 태그에서 가져온 도메인 이름입니다. 그리고

o 해당 서명에 대한 확인 시도 결과.

출력에는 해당 결과를 소비하는 모듈에서 사용할 수 있는 PERMFAILed 또는 무시된 서명을 포함하여 다른 서명 속성이나 결과 메타데이터가 포함될 수 있습니다.\(MAY\)

서명 검증 결과 코드에 대한 논의는 섹션 6.1을 참조하십시오.

---
### **3.10.  Signing by Parent Domains**

어떤 상황에서는 도메인이 각 하위 도메인에서 별도의 선택기\(키 레코드\)를 유지할 필요 없이 하위 도메인을 대신하여 서명을 적용하는 것이 바람직합니다. 기본적으로 키 레코드에 해당하는 개인 키를 사용하여 해당 키가 있는 도메인의 하위 도메인에 대한 메시지에 서명할 수 있습니다. 예를 들어 example.com 도메인의 키 레코드를 사용하여 AUID\(서명의 "i=" 태그\)가 sub.example.com 또는 sub1.sub2.example.com인 메시지를 확인할 수 있습니다. 의도하지 않은 경우 해당 키의 기능을 제한하려면 키 레코드의 "t=" 태그에 "s" 플래그를 설정하여 AUID 도메인의 유효성을 제한할 수 있습니다. 참조된 키 레코드에 "t=" 태그의 일부로 "s" 플래그가 포함되어 있는 경우 AUID\("i=" 플래그\)의 도메인은 SDID\(d=\) 도메인의 도메인과 동일해야 합니다. 이 플래그가 없으면 AUID의 도메인은 SDID와 동일하거나 SDID의 하위 도메인이어야 합니다.\(MAY, MUST, MUST\)

---
### **3.11.  Relationship between SDID and AUID**

DKIM의 기본 작업은 책임 있는 ID를 참조하는 단일 SDID\(서명 도메인 식별자\)를 서명자에서 수신자 측 ID 평가자에게 전달하는 것입니다. DKIM은 선택적으로 단일 책임 에이전트 또는 사용자 식별자\(AUID\)를 제공할 수 있습니다.\(MAY\)

따라서 수신측 ID 평가자에 대한 DKIM의 필수 출력은 단일 도메인 이름입니다. DKIM 출력으로 사용되는 범위 내에서 이름은 기본 도메인 이름 의미 체계만 갖습니다. 가능한 소유자별 의미 체계는 DKIM의 범위를 벗어납니다. 즉, DKIM 식별자로서의 역할 내에서 신원 평가자는 추가적인 의미를 가정할 수 없습니다.

서명을 성공적으로 확인한 후 수신측 DKIM 검증자는 서명 도메인 식별자\(d=\)를 소비 신원 평가자 모듈에 전달해야 하며, 존재하는 경우 에이전트 또는 사용자 식별자\(i=\)를 전달할 수 있습니다.\(MUST\)

수신기가 식별자 중 하나에 대해 구조화된 의미를 직관하려고 시도하는 경우 이는 DKIM의 사양 및 의미 체계 범위를 벗어나는 경험적 기능입니다.

따라서 다양한 입력을 통합하고 이에 대한 경험적 분석을 수행하는 배달 처리 필터와 같은 상위 수준 서비스로 이관됩니다.

- 정보 토론: 이 문서에서는 다른 메시지 헤더 필드의 식별자와 일치하기 위해 SDID 또는 AUID 값을 요구하지 않습니다. 대신 이 요구 사항은 평가자 정책 문제입니다. 이러한 연결의 목적은 다른 헤더 필드의 값을 인증하는 것입니다. 이는 결국 식별자 값을 기반으로 신뢰 평가를 적용하는 기초가 됩니다. 신뢰는 광범위하고 복잡한 주제이며, 신뢰 메커니즘은 매우 창의적인 공격을 받기 쉽습니다. SDID 또는 AUID와 다른 ID 간의 가장 기본적인 바인딩을 제외한 모든 것의 실제 효율성은 잘 확립되어 있지 않으며 공격자에 의한 전복에 대한 취약성도 없습니다. 따라서 그러한 바인딩 사용에 대한 의존은 엄격히 제한되어야 합니다. 특히, 일반적인 최종 사용자 수신자가 SDID 또는 AUID의 성공적인 사용을 통해 얻을 수 있는 보장을 어느 정도까지 신뢰할 수 있는지는 전혀 명확하지 않습니다.

---
## **4.  Semantics of Multiple Signatures**
---
### **4.1.  Example Scenarios**

메시지에 여러 서명이 있는 데에는 여러 가지 이유가 있습니다. 예를 들어, 향후 SHA-256의 성능이 충분하지 않은 것으로 확인되어 DKIM 사용이 SHA-1024로 전환된다고 가정해 보겠습니다. 서명자는 최신 알고리즘을 사용하여 즉시 서명할 수 있지만 아직 업그레이드되지 않은 검증자와의 상호 운용성을 위해 이전 알고리즘을 사용하여 계속 서명할 수도 있습니다. 서명자는 각 알고리즘을 사용하여 하나씩 두 개의 DKIM-Signature 헤더 필드를 추가하여 이를 수행합니다. SHA-1024를 허용 가능한 알고리즘으로 인식하지 못한 이전 검증자는 해당 서명을 건너뛰고 이전 알고리즘을 사용합니다. 최신 검증자는 자신의 선택에 따라 두 서명 중 하나를 사용할 수 있으며 다른 모든 사항이 동일하다면 다른 서명을 확인하려고 시도하지 않을 수도 있습니다.

마찬가지로 서명자는 모든 헤더 필드를 포함하고 "l=" 태그 없이\(엄격한 검증자를 만족시키기 위해\) 메시지에 서명할 수 있으며, 제한된 헤더 필드 세트와 "l=" 태그\(가능한 메시지 수정을 예상하여\)를 사용하여 두 번째로 서명할 수 있습니다. 다른 검증자로 가는 도중\). 그러면 검증자는 자신이 선호하는 서명을 선택할 수 있습니다.

물론 메시지는 여러 서명자를 통과했기 때문에 여러 서명을 가질 수도 있습니다. 일반적인 사례는 서명된 메시지가 메일링 리스트를 통과하는 경우일 것으로 예상됩니다.

모든 메시지에 서명합니다. 두 서명이 모두 확인되었다고 가정하면 수신자는 해당 서명 중 하나가 신뢰할 수 있는 소스에서 나온 것으로 알려진 경우 메시지를 수락하도록 선택할 수 있습니다.

특히, 수신자는 알 수 없는 작성자가 보낸 메시지라도 해당 목록으로 전송되는 메시지를 허용하기 위해 자신이 구독하고 허용 가능한 남용 방지 정책이 있는 메일링 목록을 화이트리스트에 추가하도록 선택할 수 있습니다. 또한 신뢰도가 낮은 메일링 목록\(예: 남용 방지 보호 기능이 없는 메일링 목록\)을 구독하고 특정 작성자의 모든 메시지를 기꺼이 수락하지만 다른 메시지에 대한 추가 남용 검색을 고집할 수도 있습니다.

여러 서명자의 또 다른 관련된 예는 일반적으로 학계 동문 사이트와 관련된 서비스 전달일 수 있습니다. 예를 들어, 수신자는 수신자가 선호하는 것보다 다소 덜 효과적인 남용 방지 보호 기능을 갖춘 사이트인members.example.org에 주소를 가지고 있을 수 있습니다. 이러한 수신자에게는 메시지를 절대적으로 신뢰할 수 있는 특정 작성자가 있을 수 있지만 전달자의 조사를 통과한 알 수 없는 작성자가 보낸 메시지의 신뢰도는 중간 정도입니다.

---
### **4.2.  Interpretation**

메시지에 서명을 추가하는 서명자는 "h=" 옵션의 일반적인 의미를 사용하여 새로운 DKIM-Signature 헤더를 생성할 뿐입니다. 서명자는 추적 헤더 필드에 서명하기 위해 섹션 5.4에 설명된 방법을 사용하여 기존 DKIM 서명 헤더 필드에 서명할 수 있습니다.\(MAY\)

서명자는 DKIM-Signature 헤더 필드에 서명하면 DKIM-Signature 헤더 필드가 추적 헤더 필드임을 인식하지 못하고 무의식적으로 순서를 변경하여 해당 서명을 손상시키는 중개자에 의해 서명 실패가 발생할 수 있다는 점을 인식해야 합니다. 이러한 이유로 기존 DKIM-Signature 헤더 필드에 서명하는 것은 합법적이기는 하지만 권장되지 않습니다.

- 참고 사항: 여러 인스턴스가 있는 헤더 필드가 서명된 경우 해당 헤더 필드는 항상 아래에서 위로 서명됩니다. 따라서 특정 DKIM-Signature 헤더 필드에만 서명하는 것은 불가능합니다. 예를 들어 서명 중인 메시지에 이미 3개의 DKIM 서명 헤더 필드 A, B, C가 포함되어 있는 경우 B와 C만 또는 C만 서명할 수 있지만 A만, B만, A는 서명할 수 없습니다. B만, 또는 A와 C만.

서명자는 서로 다른 매개변수를 사용하여 두 개 이상의 DKIM 서명 헤더 필드를 추가할 수 있습니다. 예를 들어 전환 기간 동안 서명자는 두 가지 다른 해시 알고리즘을 사용하여 서명을 생성하려고 할 수 있습니다.\(MAY\)

서명자는 서명을 확인할 수 없다는 것을 알고 있더라도 서명 중인 메시지에서 DKIM-Signature 헤더 필드를 제거해서는 안 됩니다.\(SHOULD NOT\)

여러 서명이 있는 메시지를 평가할 때 검증자는 서명을 독립적으로 평가해야 합니다. 예를 들어 정책에 따라 더 이상 사용되지 않는 암호화 알고리즘이 포함된 서명을 허용하지 않기로 선택한 검증자는 해당 서명이 유효하지 않은 것으로 간주합니다. 검증자는 자신이 선택한 순서대로 서명을 처리할 수 있습니다. 예를 들어 일부 검증자는 메시지 헤더의 보낸 사람 필드에 해당하는 서명을 다른 서명보다 먼저 처리하도록 선택할 수 있습니다. 서명 선택에 대한 자세한 내용은 섹션 6.1을 참조하세요.\(SHOULD, MAY\)

- 정보 구현 참고: 검증자는 서명이 실패한 이유를 추측하기 위해 유효한 서명과 잘못된 서명을 연관시키려는 시도를 시도합니다. 특히 검증자가 유효하지 않은 서명이 유효했는지 확인할 수 있는 일반적인 방법은 없습니다.

검증자는 서명이 검증자가 만족할 만큼 성공적으로 검증될 때까지 서명을 계속 확인해야 합니다. 잠재적인 서비스 거부 공격을 제한하기 위해 검증자는 검증을 시도할 총 서명 수를 제한할 수 있습니다.\(SHOULD, MAY\)

검증 모듈이 평가에서 PERMFAIL 결과를 생성한 서명을 보고하는 경우 신원 평가자는 해당 서명을 무시해야 하며\(섹션 6.1 참조\) 마치 메시지에 없는 것처럼 행동해야 합니다.\(SHOULD\)

---
## **5.  Signer Actions**

서명자는 다음 단계를 순서대로 수행합니다.

---
### **5.1.  Determine Whether the Email Should Be Signed and by Whom**

서명자는 개인 키와 해당 공개 키 및 선택기 정보에 대한 필요한 지식이 있는 도메인에 대해서만 전자 메일에 서명할 수 있습니다. 그러나 서명자가 전자 메일에 서명하지 않기로 선택할 수 있는 이유는 개인 키가 부족한 것 외에도 여러 가지 다른 이유가 있습니다.

- 참고 사항: 서명자는 MUA, SUBMISSION 서버 또는 MTA를 포함하여 적절하다고 간주되는 메일 시스템의 일부로 구현될 수 있습니다. 구현된 모든 위치에서 서명자는 문제가 될 수 있는 메시지 서명\(따라서 이에 대한 책임 주장\)을 주의해야 합니다. 특히, 신뢰할 수 있는 엔클레이브 내에서 서명 도메인은 다음과 같을 수 있습니다.

- 로컬 정책에 따라 헤더에서 파생됩니다. SUBMISSION 서버는 적절하게 인증되고 권한이 부여된 사용자의 메시지에만 서명할 수 있습니다.

- 유익한 구현자 조언: 나가는 게이트웨이 MTA가 수신 헤더 필드를 난독 처리하는 경우\(예: 내부 토폴로지의 세부 정보를 숨기기 위해\) SUBMISSION 서버는 수신 헤더 필드에 서명해서는 안 됩니다.

어떤 이유로 이메일에 서명할 수 없는 경우 해당 이메일을 어떻게 처리할지에 대한 로컬 정책 결정이 있습니다.

---
### **5.2.  Select a Private Key and Corresponding Selector Information**

이 사양은 서명자가 사용할 개인 키와 선택기 정보를 선택해야 하는 기준을 정의하지 않습니다. 현재 이 사양에 관한 한 모든 선택자는 동일하므로 결정은 대체로 관리상의 편의에 관한 문제입니다. 개인 키의 배포 및 관리도 이 문서의 범위를 벗어납니다.

- 유익한 작업 조언: 검증자가 서명을 검증할 기회를 갖기 전에 해당 공개 키를 포함하는 선택기가 취소되거나 제거될 것으로 예상되는 경우 서명자는 개인 키로 서명해서는 안 됩니다. 서명자는 최종 수신자가 메시지를 실제로 읽을 때까지 검증자가 유효성 검사를 연기하도록 선택할 수 있음을 예상해야 합니다. 특히, 새 키 쌍으로 교체하는 경우 새 개인 키로 서명이 즉시 시작되어야 하며, 이전 공개 키는 키 서버에서 제거되기 전에 합리적인 검증 간격 동안 보관되어야 합니다.

---
### **5.3.  Normalize the Message to Prevent Transport Conversions**

일부 메시지, 특히 8비트 문자를 사용하는 메시지는 전송 중에 수정될 수 있으며, 특히 7비트 형식으로 변환됩니다. 이러한 변환으로 인해 DKIM 서명이 손상됩니다. 이러한 손상 가능성을 최소화하기 위해 서명자는 서명하기 전에 \[RFC2045\]에 설명된 대로 quoted-printable 또는 base64와 같은 적절한 MIME 콘텐츠 전송 인코딩으로 메시지를 변환해야 합니다. 이러한 변환은 DKIM의 범위를 벗어납니다. 실제 메시지는 DKIM 알고리즘에 표시되기 전에 MUA 또는 MSA에 의해 7비트 MIME으로 변환되어야 합니다.\(SHOULD, SHOULD\)

메시지가 전송 전에 수정될 로컬 인코딩을 사용하여 서명자에게 제출되는 경우 표준 \[RFC5322\] 형식에 대한 수정은 서명 전에 수행되어야 합니다. 특히, 베어 CR 또는 LF 문자\(일부 시스템에서는 로컬 회선으로 사용됨\)\(MUST\)

구분 기호 규칙\)은 메시지가 서명되기 전에 반드시 SMTP 표준 CRLF 시퀀스로 변환되어야 합니다. 이러한 종류의 모든 변환은 서명 알고리즘에 제시된 버전뿐만 아니라 수신자에게 실제로 전송된 메시지에 적용되어야 합니다.\(MUST, SHOULD\)

보다 일반적으로 서명자는 로컬 또는 내부 형식이 아닌 검증자가 수신할 것으로 예상되는 메시지에 서명해야 합니다.\(MUST\)

---
#### **5.3.1.  Body Length Limits**

서명 계산을 옥텟 단위로 측정된 본문 텍스트의 초기 접두사로 제한하기 위해 본문 길이 수를 지정할 수 있습니다. 본문 길이 개수를 지정하지 않으면 전체 메시지 본문이 서명됩니다.\(MAY\)

- 정보 근거: 메일링 목록에서 메시지에 예고편을 추가하는 것이 매우 일반적이기 때문에 이 기능이 제공됩니다\(예: 목록에서 벗어나는 방법에 대한 지침\). 해당 메시지도 서명될 때까지 본문 길이 수는 검증 도구에 유용한 도구입니다. 정책에 따라 외부 데이터가 포함된 유효한 서명이 있는 메시지를 허용할 수 있기 때문입니다.

실제로 해시된 길이는 DKIM-Signature 헤더 필드의 "l=" 태그에 삽입되어야 합니다. \(섹션 3.5 참조\)

본문 길이 수를 사용하면 메시지 서명자가 서명된 메시지 본문 끝에 데이터를 추가할 수 있습니다. 본문 길이 수는 정규화 알고리즘에 따라 계산되어야 합니다. 예를 들어 정규화 알고리즘에서 무시된 공백은 본문 길이 계산의 일부로 포함되지 않습니다.\(MUST\)

본문 길이 개수가 0이라는 것은 본문이 완전히 부호가 없음을 의미합니다.

어떤 종류의 수정도 발생하지 않도록 하려는 서명자는 헤더와 본문 모두에 대해 "간단한" 정규화 알고리즘을 지정하고 본문 길이 수를 생략해야 합니다.

자세한 내용은 섹션 8.2를 참조하세요.

---
### **5.4.  Determine the Header Fields to Sign**

From 헤더 필드는 서명되어야 합니다\(즉, 결과 DKIM-Signature 헤더 필드의 "h=" 태그에 포함됨\). 서명자는 전송 중에 합법적으로 수정되거나 제거될 가능성이 있는 기존 헤더 필드에 서명해서는 안 됩니다. 특히 \[RFC5321\]에서는 명시적으로 허용합니다.\(MUST, SHOULD NOT\)

전송 중인 Return-Path 헤더 필드의 수정 또는 제거. 서명자는 서명자의 재량에 따라 서명 당시 존재하는 다른 헤더 필드를 포함할 수 있습니다.\(MAY\)

- 정보 작업 참고: 서명할 헤더 필드의 선택은 명확하지 않습니다. 한 가지 전략은 기존의 반복 불가능한 헤더 필드를 모두 서명하는 것입니다. 대체 전략은 수신자에게 표시될 가능성이 있거나 수신자의 메시지 처리에 영향을 미칠 가능성이 있는 헤더 필드에만 서명하는 것입니다. 세 번째 전략은 "잘 알려진" 헤더에만 서명하는 것입니다. 검증자는 서명되지 않은 헤더 필드를 최종 사용자에게 표시하는 것을 거부하거나 특정 헤더 필드를 포함하지 않는 경우 서명을 무시하는 등 극도로 회의적인 태도로 처리할 수 있습니다. 이러한 이유로 날짜, 제목, 회신, 보낸 사람 및 모든 MIME 헤더 필드와 같은 메시지에 있는 서명 필드를 적극 권장합니다.

DKIM-Signature 헤더 필드는 항상 암시적으로 서명되며 다른 기존 서명도 서명되었음을 나타내는 경우를 제외하고 "h=" 태그에 포함되어서는 안 됩니다.\(MUST NOT\)

서명자는 존재하지 않는 서명된 헤더 필드가 있다고 주장할 수 있습니다. 즉, 서명자는 해당 헤더 필드가 메시지에 존재하지 않더라도 "h=" 태그에 헤더 필드 이름을 포함할 수 있습니다. 서명을 계산할 때 존재하지 않는 헤더 필드는 반드시 널 문자열\(헤더 필드 이름, 헤더 필드 값, 모든 구두점 및 후행 CRLF 포함\)로 처리되어야 합니다.\(MAY, MUST\)

- 정보 근거: 이를 통해 서명자는 헤더 필드가 없음을 명시적으로 주장할 수 있습니다. 해당 헤더 필드가 나중에 추가되면 서명이 실패합니다.

- 참고 사항: 헤더 필드 이름은 추가 추가를 방지하기 위해 서명 시 메시지에 있는 해당 헤더 필드의 실제 수보다 한 번만 더 나열하면 됩니다. 예를 들어 서명 시 Comments 헤더 필드가 하나만 있는 경우 "h=" 태그에 Comments를 두 번 나열하면 여러 Comments 헤더 필드가 추가되는 것을 방지할 수 있습니다. "h=" 태그에 주석을 세 번 이상 나열할 필요는 없습니다\(그러나 합법적입니다\).

특정 헤더 필드 이름의 인스턴스가 두 개 이상인 헤더를 정규화할 때 따라야 하는 절차에 대한 논의는 섹션 5.4.2를 참조하세요.

서명자는 배달 프로세스 후반에 추가 인스턴스가 추가될 수 있는 헤더 필드에 서명할 때 주의해야 합니다. 이러한 헤더 필드는 서명된 인스턴스 뒤에 삽입되거나

그렇지 않으면 재정렬됩니다. 추적 헤더 필드\(예: 수신됨\) 및 Resent-\* 블록은 \[RFC5322\]에서 재정렬을 금지하는 유일한 필드입니다. 특히 DKIM-Signature 헤더 필드는 일부 중간 MTA에 의해 재정렬될 수 있으므로 기존 DKIM-Signature 헤더 필드에 서명하면 오류가 발생하기 쉽습니다.

- 참고 사항: \[RFC5322\]가 헤더 필드의 재정렬을 금지하지 않는다는 사실에도 불구하고 중간 MTA에 의해 여러 인스턴스가 있는 서명된 헤더 필드를 재정렬하면 DKIM 서명이 손상될 수 있습니다. 그러한 반사회적 행동은 피해야 합니다.

- 정보 구현자 참고 사항: 이 사양에서는 필요하지 않지만 최종 사용자가 볼 수 있는 모든 헤더 필드는 "간접 스팸" 가능성을 피하기 위해 서명되어야 합니다. 예를 들어 제목 헤더 필드가 서명되지 않은 경우 스패머는 합법적인 제목을 한 줄 스팸으로 대체하여 이전에 서명된 메일을 다시 보낼 수 있습니다.

---
#### **5.4.1.  Recommended Signature Content**

DKIM 암호화 알고리즘의 목적은 일반적인 전송 관련 변경에 대해 강력하고 일종의 재생 공격에 저항하는 방식으로 메시지에 식별자를 첨부하는 것입니다. 이러한 요구 사항을 충족하는 데 필수적인 측면은 해시에 포함할 헤더 필드와 제외할 필드를 선택하는 것입니다.

포함할 필드를 선택하는 기본 규칙은 메시지 콘텐츠의 "핵심"을 구성하는 필드를 선택하는 것입니다. 따라서 서명이 성공하려면 모든 재생 공격에 이러한 항목이 포함되어야 합니다. 그러나 이를 포함하면 새 수신자에게 전송되더라도 메시지의 핵심은 유효합니다.

주소가 있는 필드와 본문과 관련된 텍스트 내용이 있는 필드의 일반적인 예는 다음과 같습니다.

```text
   o  From (REQUIRED; see Section 5.4)

   o  Reply-To

   o  Subject

   o  Date

   o  To, Cc

   o  Resent-Date, Resent-From, Resent-To, Resent-Cc

   o  In-Reply-To, References

   o  List-Id, List-Help, List-Unsubscribe, List-Subscribe, List-Post,
      List-Owner, List-Archive
```

"l=" 서명 태그가 사용 중인 경우\(섹션 3.5 참조\) Content-Type 필드도 포함할 후보입니다. 수신 사용자에게 완전히 다른 콘텐츠가 렌더링되도록 하는 방식으로 대체될 수 있기 때문입니다.

메시지의 "핵심"을 구성하는 요소를 결정하는 데는 상충 관계가 있습니다. 일부 분야에서는 주관적인 개념입니다. 예를 들어 "Message-ID"와 같은 필드를 포함하는 것은 동일한 메시지의 개별 인스턴스를 핵심 콘텐츠로 구별할 수 있는 메커니즘을 고려하는 경우 유용합니다. 마찬가지로 메시지 스레딩을 메시지의 핵심 부분으로 간주하는 경우 "In-Reply-To" 및 "References"를 포함하는 것이 바람직할 수 있습니다.

관심을 가질 수 있는 또 다른 필드 클래스는 인증 결과 \[RFC5451\]와 같이 메시지에 대한 보안 관련 정보를 전달하는 필드입니다.

제외할 필드를 선택하는 기본 규칙은 이름이 동일한 필드가 여러 개 있고 전송 중에 수정되는 필드가 있는 필드를 선택하는 것입니다. 이에 대한 예는 다음과 같습니다.

```text
   o  Return-Path

   o  Received

   o  Comments, Keywords
```

DKIM-Signature 필드도 처리가 별도로 지정되므로 헤더 해시에서 제외됩니다.

일반적으로 동일한 이름의 추가 필드가 확인 전에 합법적으로 추가되거나 재정렬될 가능성이 있으므로 다른 선택 필드를 제외하는 것이 좋습니다. 메시지에 적용될 수 있는 다양한 애플리케이션별 헤더 필드로 인해 이 규칙에 대한 합법적인 예외가 있을 수 있으며, 그 중 일부는 복제, 수정 또는 재정렬될 가능성이 없습니다.

서명자는 처리하는 메시지 유형과 위험에 대한 혐오감을 기반으로 정규화 알고리즘을 선택해야 합니다. 예를 들어 메일링 리스트나 메시지를 수정할 가능성이 있는 기타 소프트웨어에 의해 처리되지 않을 것으로 예상되는 구매 영수증을 주로 보내는 전자 상거래 사이트는 일반적으로 "간단한" 정규화를 선호합니다.\(SHOULD\)

주로 개인 대 개인 이메일을 보내는 사이트는 "완벽한" 정규화를 사용하여 전송 중 수정에 대한 탄력성을 더 선호할 것입니다.

메일이 메시지 본문 하단에 "구독 취소" 지침을 추가할 수 있는 메일링 목록과 같은 중개자를 통해 처리되지 않는 한, "l=" 태그는 승인되지 않은 텍스트 추가 경로를 제공하는 동시에 추가적인 이점을 전달하지 못할 가능성이 높습니다. 메시지. "l=0"을 사용하면 이를 극단적으로 활용하여 서명을 무효화하지 않고 메시지 텍스트를 완전히 변경할 수 있습니다. 또한 검증자는 부분적으로 서명된 메시지 본문을 허용되지 않는 것으로 간주할 권리가 있습니다. 신중하게 사용하는 것이 좋습니다.

---
#### **5.4.2.  Signatures Involving Multiple Instances of a Field**

메시지에서 두 번 이상 발생하는 기존 헤더 필드\(예: 수신됨\)에 서명하기로 선택한 서명자는 헤더 블록에 있는 해당 헤더 필드의 물리적으로 마지막 인스턴스에 서명해야 합니다. 이러한 헤더 필드의 여러 인스턴스에 서명하려는 서명자는 DKIM 서명 헤더 필드의 "h=" 태그에 헤더 필드 이름을 여러 번 포함해야 하며 헤더 필드 블록의 맨 아래부터 순서대로 헤더 필드에 서명해야 합니다. 상단. 서명자는 실제 해당 헤더 필드보다 "h="에 헤더 필드 이름의 인스턴스를 더 많이 포함할 수 있으므로 해당 이름의 추가 헤더 필드가 추가되었는지 서명이 확인하지 않습니다.\(MUST, MUST, MAY\)

```text
      INFORMATIVE EXAMPLE:
```

- 서명자가 두 개의 기존 수신 헤더 필드에 서명하기를 원하고 기존 헤더에 다음이 포함된 경우:

```text
      Received: <A>
      Received: <B>
      Received: <C>
```

- 결과 DKIM-Signature 헤더 필드는 다음과 같아야 합니다.

```text
      DKIM-Signature: ... h=Received : Received :...
```

- 수신된 헤더 필드 <C\> 및 <B\>는 해당 순서로 서명됩니다.

---
### **5.5.  Compute the Message Hash and Signature**

서명자는 섹션 3.7에 설명된 대로 메시지 해시를 계산한 다음 선택한 공개 키 알고리즘을 사용하여 서명해야 합니다. 그러면 본문 해시와 헤더 해시의 서명을 포함하는 DKIM-서명 헤더 필드가 생성되며, 해당 헤더에는 DKIM-서명 헤더 필드 자체가 포함됩니다.\(MUST\)

DKIM을 구현하고 메시지를 재전송하기 전에 메시지 또는 헤더 필드를 수정\(예: 구독 취소 정보 삽입\)하는 메일링 목록 관리자와 같은 엔터티는 입력 시 기존 서명을 확인해야 하며 메시지를 다시 서명하기 전에 그러한 수정을 수행해야 합니다.\(MUST\)

---
### **5.6.  Insert the DKIM-Signature Header Field**

마지막으로 서명자는 이메일을 전송하기 전에 이전 단계에서 생성된 DKIM-Signature 헤더 필드를 삽입해야 합니다. DKIM-서명 헤더 필드는 위에서 설명한 대로 해시를 계산하는 데 사용된 것과 동일해야 합니다. 단, "b=" 태그의 값은 이전 단계에서 계산된 적절하게 서명된 해시여야 하며, 다음 단계에 지정된 알고리즘을 사용하여 서명되어야 합니다. DKIM-서명 헤더 필드의 "a=" 태그 및 위의 섹션 5.2에서 선택한 DKIM-서명 헤더 필드의 "s=" 태그에 제공된 선택기에 해당하는 개인 키를 사용합니다.\(MUST, MUST\)

DKIM 서명 헤더 필드는 헤더 블록의 다른 DKIM 서명 필드 앞에 삽입되어야 합니다.\(MUST\)

- 정보 구현 참고: 이를 달성하는 가장 쉬운 방법은 헤더 블록 시작 부분에 DKIM 서명 헤더 필드를 삽입하는 것입니다. 특히 기존 수신 헤더 필드 앞에 배치될 수 있습니다. 이는 DKIM-Signature를 추적 헤더 필드로 처리하는 것과 일치합니다.

---
## **6.  Verifier Actions**

서명자는 언제든지 공개 키를 제거하거나 취소할 수 있으므로 적시에 확인을 수행하는 것이 좋습니다. 많은 구성에서 가장 시기적절한 장소는 국경 MTA가 승인하는 동안이나 그 직후입니다. 특히 최종 사용자가 메시지에 액세스할 때까지 확인을 연기하는 것은 권장되지 않습니다.\(MAY\)

테두리 또는 중간 MTA는 메시지 서명을 확인할 수 있습니다. 검증을 수행한 MTA는 수신 메시지에 검증 헤더 필드를 추가하여 해당 검증 결과를 전달할 수 있습니다. 이는 사용자의 작업을 상당히 단순화합니다.\(MAY, MAY\)

이제 기존 메일 사용자 에이전트를 사용하세요. 대부분의 MUA에는 메시지 헤더 필드나 콘텐츠를 기반으로 메시지를 필터링하는 기능이 있습니다. 이러한 필터는 서명되지 않은 메일과 관련하여 사용자가 원하는 모든 정책을 구현하는 데 사용됩니다.

확인 MTA는 서명된 메시지에 확인 헤더 필드를 적용하는지 여부에 관계없이 확인 불가능한 메일에 관한 정책을 구현할 수 있습니다.\(MAY\)

검증자는 섹션 6.1, 6.1.1 및 6.1.2에 나열된 단계를 순서대로 적용하는 것과 의미상 동일한 결과를 생성해야 합니다. 실제로 성능 향상을 위해 이러한 단계 중 여러 단계를 병렬로 수행할 수 있습니다.\(MUST\)

---
### **6.1.  Extract Signatures from the Message**

검증자가 DKIM 서명 헤더 필드를 시도하는 순서는 정의되지 않습니다. 검증자는 원하는 순서대로 서명을 시도할 수 있습니다. 예를 들어, 한 구현에서는 텍스트 순서로 서명을 시도할 수 있는 반면, 다른 구현에서는 다른 서명을 시도하기 전에 From 헤더 필드의 내용과 일치하는 ID로 서명을 시도할 수 있습니다. 검증자는 여러 DKIM 서명 헤더 필드의 순서에 궁극적인 의미를 부여해서는 안 됩니다. 특히, 일부 릴레이가 잠재적으로 임의적인 방식으로 헤더 필드를 재정렬할 것이라고 믿을 만한 이유가 있습니다.\(MAY, MUST NOT\)

- 정보 구현 참고: 검증자는 다른 정보가 없는 경우 주문 서명에 대한 단서로 해당 주문을 사용할 수 있습니다. 그러나 여러 서명의 의미에 대한 다른 단서\(예: 서명 호스트를 수신된 헤더 필드와 연관시키는 것\)도 고려할 수 있습니다.

전송 후 서명의 생존성은 보장되지 않으며, 서명자의 잘못 없이 서명을 확인하지 못할 수도 있습니다. 따라서 검증자는 하나 이상의 잘못된 서명이 있고 좋은 서명이 없는 메시지를 서명이 전혀 없는 메시지와 다르게 처리해서는 안 됩니다.\(SHOULD NOT\)

서명이 성공적으로 확인되면 검증자는 구현 재량에 따라 처리를 중지하거나 다른 서명 확인을 시도합니다. 검증자는 서비스 거부 공격을 피하기 위해 시도하는 서명 수를 제한할 수 있습니다\(자세한 내용은 섹션 8.4 참조\).\(MAY\)

다음 설명에서 "반환 상태\(설명\)"\("상태"는 "PERMFAIL" 또는 "TEMPFAIL" 중 하나\)라는 텍스트는 검증자가 해당 서명 처리를 즉시 중단해야 함을 의미합니다. 검증자는 다음 서명으로 진행해야 합니다.\(MUST, SHOULD\)

존재하며 잘못된 서명을 완전히 무시합니다. 상태가 "PERMFAIL"이면 서명이 실패한 것이므로 재검토해서는 안 됩니다. 상태가 "TEMPFAIL"인 경우 지금은 서명을 확인할 수 없지만 나중에 다시 시도할 수 있습니다. 검증자는 나중에 처리하기 위해 메시지를 연기하거나 다른 서명을 시도하도록 준비할 수 있습니다. 좋은 서명이 발견되지 않고 서명 중 하나라도 TEMPFAIL 상태가 된 경우 검증자는 나중에 처리하기 위해 메시지를 연기하도록 준비할 수 있습니다. "\(설명\)"은 규범적인 텍스트가 아닙니다. 이는 설명을 위해서만 제공됩니다.\(MAY\)

여러 서명 헤더 필드의 유효성을 검사하도록 준비된 검증자는 다음 서명 헤더 필드\(존재하는 경우\)로 진행해야 합니다. 그러나 검증자는 이후 단계에서 고려할 수 있도록 유효하지 않은 서명이 존재했다는 사실을 기록할 수 있습니다.\(SHOULD, MAY\)

- 참고 사항: 이 요구 사항의 이론적 근거는 유효하지 않은 서명이 있지만 유효한 서명도 있는 메시지가 작동하도록 허용하는 것입니다. 예를 들어 메일링 목록 분해기는 원래 제출자 서명을 그대로 유지하기로 선택할 수 있습니다. 비록 분해기가 서명을 깨뜨리는 방식으로 메시지를 수정하고 있음을 알고 자체 서명을 삽입하는 경우에도 마찬가지입니다. 이 경우 알려진 손상된 서명이 있어도 메시지는 성공해야 합니다.

유효성을 검사할 각 서명에 대해 표시된 순서대로 수행하는 것과 의미상 동일한 결과를 생성하는 방식으로 다음 단계를 수행해야 합니다.

---
#### **6.1.1.  Validate the Signature Header Field**

구현자는 DKIM 서명 헤더 필드의 형식과 값을 꼼꼼하게 검증해야 합니다. 불일치 또는 예상치 못한 값으로 인해 헤더 필드가 완전히 무시되고 검증자가 PERMFAIL\(서명 구문 오류\)을 반환해야 합니다. "당신이 받아들이는 것에 있어서 자유주의"하는 것은 확실히 이 보안 맥락에서 나쁜 전략입니다. 그러나 명시적으로 허용되는 DKIM-Signature 헤더 필드에 알 수 없는 태그가 존재하는 것은 여기에 포함되지 않습니다. 검증자는 이 사양과 일치하지 않는 "v=" 태그가 포함된 DKIM 서명 헤더 필드가 제공되면 PERMFAIL\(호환되지 않는 버전\)을 반환해야 합니다.\(MUST, MUST\)

- 정보 구현 참고: 물론 구현 시 이 사양의 이전 버전에서 생성된 서명을 확인하도록 선택할 수도 있습니다.

섹션 3.5에 "필수"로 나열된 태그가 DKIM-서명 헤더 필드에서 생략된 경우 검증자는 DKIM-서명 헤더 필드를 무시하고 PERMFAIL\(서명 누락 필수 태그\)을 반환해야 합니다.\(MUST\)

- 참고 사항: 섹션 3.5에서 요구하는 대로 나열된 태그는 "v=", "a=", "b=", "bh=", "d=", "h=" 및 "s="입니다. 본 참고 사항과 섹션 3.5 사이에 충돌이 있는 경우 섹션 3.5가 규범적입니다.

DKIM-Signature 헤더 필드에 "i=" 태그가 포함되어 있지 않은 경우 검증자는 해당 태그의 값이 "@d"인 것처럼 동작해야 합니다. 여기서 "d"는 "d=" 태그의 값입니다.\(MUST\)

검증자는 "d=" 태그에 지정된 도메인이 "i=" 태그의 도메인 부분과 동일하거나 상위 도메인인지 확인해야 합니다. 그렇지 않은 경우 DKIM-Signature 헤더 필드는 무시되어야 하며 검증자는 PERMFAIL\(도메인 불일치\)을 반환해야 합니다.\(MUST, MUST\)

"h=" 태그에 From 헤더 필드가 포함되지 않은 경우 검증자는 DKIM-Signature 헤더 필드를 무시하고 PERMFAIL\(From 필드가 서명되지 않음\)을 반환해야 합니다.\(MUST\)

검증자는 "x=" 태그가 포함되어 있고 서명이 만료된 경우 DKIM-Signature 헤더 필드를 무시하고 PERMFAIL\(서명 만료됨\)을 반환할 수 있습니다.\(MAY\)

"d=" 태그에서 서명자가 사용하는 도메인이 유효한 서명 엔터티와 연결되지 않은 경우 검증자는 DKIM-Signature 헤더 필드를 무시할 수 있습니다. 예를 들어 "com" 및 "co.uk"와 같이 "d=" 값이 있는 서명은 무시될 수 있습니다. 허용되지 않는 도메인 목록은 구성 가능해야 합니다.\(MAY, SHOULD\)

검증자는 다른 이유로 인해 DKIM 서명 헤더 필드를 무시하고 PERMFAIL\(허용되지 않는 서명 헤더\)을 반환할 수 있습니다. 예를 들어 서명이 검증자가 필수로 간주하는 헤더 필드에 서명하지 않는 경우입니다. 예를 들어, MIME 헤더 필드가 서명되지 않은 경우 검증자가 피하고 싶어하는 특정 공격이 가능할 수 있습니다.\(MAY\)

---
#### **6.1.2.  Get the Public Key**

확인 프로세스를 완료하려면 서명의 공개 키가 필요합니다. 공개 키를 검색하는 프로세스는 DKIM-Signature 헤더 필드의 "q=" 태그에 정의된 쿼리 유형에 따라 다릅니다. 분명히 공개 키는 서명 정보 추출 프로세스가 완전히 성공한 경우에만 검색하면 됩니다.

키 관리 및 표현에 대한 자세한 내용은 섹션 3.6에 설명되어 있습니다. 검증자는 키 레코드를 검증해야 하며 형식이 잘못된 모든 공개 키 레코드를 무시해야 합니다\(MUST\).\(MUST\)

- 참고: 쿼리된 DKIM 도메인 이름을 포함하는 와일드카드 TXT RR을 사용하면 유효한 DKIM 키 레코드가 아닐 가능성이 높은 DKIM 쿼리에 대한 응답이 생성됩니다. 이 문제는 DKIM에만 국한된 것이 아니며 다른 많은 유형의 쿼리에 적용됩니다. DNS 응답을 처리하는 클라이언트 소프트웨어는 이 문제를 고려해야 합니다.

메시지를 검증할 때 검증자는 표시된 순서대로 수행하는 것과 의미상 동일한 방식으로 다음 단계를 수행해야 합니다. 어떤 경우에는 의미 체계가 변경되지 않는 한 구현 시 이러한 단계를 병렬화하거나 재정렬할 수 있습니다.\(MUST\)

1. 검증자는 "q=" 태그의 알고리즘, "d=" 태그의 도메인, "s=" 태그의 선택기를 사용하여 섹션 3.6에 설명된 대로 공개 키를 검색합니다.

2. 공개 키에 대한 쿼리가 응답하지 않으면 검증자는 TEMPFAIL\(키를 사용할 수 없음\)을 반환하여 나중에 검증을 시도할 수 있습니다.\(MAY\)

3. 해당 키 레코드가 존재하지 않아 공개 키에 대한 쿼리가 실패하는 경우 검증자는 즉시 PERMFAIL\(서명을 위한 키 없음\)을 반환해야 합니다.\(MUST\)

4. 공개 키에 대한 쿼리가 여러 키 레코드를 반환하는 경우 검증자는 키 레코드 중 하나를 선택하거나 키 레코드를 순환하면서 구현자의 재량에 따라 각 레코드에 대해 나머지 단계를 수행할 수 있습니다. 키 레코드의 순서는 지정되지 않습니다. 검증자가 키 레코드를 순환하기로 선택한 경우 이 섹션의 나머지 부분에 있는 "반환 ..."이라는 표현은 "다음 키 레코드가 있으면 시도하고, 없으면 돌아가서 일반적인 방법으로 다른 서명을 시도하십시오"를 의미합니다. .

5. 쿼리에서 반환된 결과가 이 사양에 정의된 형식을 준수하지 않는 경우 검증자는 키 레코드를 무시하고 PERMFAIL\(키 구문 오류\)을 반환해야 합니다. 검증자는 공격 시도를 피하기 위해 주요 기록의 구문을 주의 깊게 검증해야 합니다. 특히 검증자는 구현하지 않은 버전 코드\("v=" 태그\)가 있는 키를 무시해야 합니다.\(MUST, MUST\)

6. "h=" 태그가 공개 키 레코드에 존재하고 DKIM-Signature 헤더 필드의 "a=" 태그에 의해 암시된 해시 알고리즘이 "h=" 태그의 내용에 포함되지 않은 경우, 검증자는 키 레코드를 무시하고 PERMFAIL\(부적절한 해시 알고리즘\)을 반환해야 합니다.\(MUST\)

7. 공개 키 데이터\("p=" 태그\)가 비어 있으면 이 키는 취소되었으며 검증자는 이를 서명 확인 실패로 처리하고 PERMFAIL\(키 취소됨\)을 반환해야 합니다. 취소된 키와 제거된 키 레코드 사이에는 정의된 의미상 차이가 없습니다.\(MUST\)

8. 공개 키 데이터가 DKIM-Signature 헤더 필드의 "a=" 및 "k=" 태그로 정의된 알고리즘 및 키 유형과 함께 사용하기에 적합하지 않은 경우 검증기는 즉시 PERMFAIL\(부적절한 키 알고리즘\)을 반환해야 합니다. \).\(MUST\)

---
#### **6.1.3.  Compute the Verification**

서명자와 공개 키가 주어지면 서명 확인은 의미상 다음 단계와 동일한 작업으로 구성됩니다.

1. "c=" 태그에 정의된 알고리즘, "l=" 태그에 지정된 본문 길이, "h=" 태그에 있는 헤더 필드 이름을 기반으로 설명된 대로 정규화된 버전의 메시지를 준비합니다. 섹션 3.7\(이 정규화된 버전은 실제로 원본 콘텐츠를 대체하지 않습니다.\) "h=" 태그의 헤더 필드 이름을 실제 메시지 헤더 필드와 일치시킬 때 비교는 대소문자를 구분해야 합니다.\(MUST\)

2. "a=" 태그에 표시된 알고리즘을 기반으로 섹션 3.7에 설명된 대로 정식 복사본에서 메시지 해시를 계산합니다.

3. 이전 단계에서 계산된 정규화된 메시지 본문의 해시가 "bh=" 태그에 전달된 해시 값과 일치하는지 확인합니다. 해시가 일치하지 않으면 검증자는 서명을 무시하고 PERMFAIL\(본문 해시가 검증되지 않음\)을 반환해야 합니다.\(SHOULD\)

4. "b=" 태그에 전달된 서명을 사용하여

- "a=" 태그에 설명된 공개 키 알고리즘에 적합한 메커니즘을 사용하여 헤더 해시에 대한 서명입니다. 서명이 검증되지 않으면 검증자는 서명을 무시하고 PERMFAIL\(서명이 검증되지 않음\)을 반환해야 합니다.\(SHOULD\)

5. 그렇지 않으면 서명이 올바르게 확인된 것입니다.

- 정보 구현자 참고: 최종 암호 해독이 계산될 때까지 공개 키가 필요하지 않으므로 구현에서는 해시 계산과 동시에 공개 키 쿼리를 시작하려고 할 수 있습니다. 구현에서는 DKIM-Signature 헤더 필드의 "bh=" 태그에 나열된 메시지 해시가 실제 메시지 본문의 해시와 일치하는지 확인하기 전에 메시지 헤더의 서명을 확인할 수도 있습니다. 그러나 본문 해시가 일치하지 않으면 전체 서명이 실패한 것으로 간주되어야 합니다.

서명의 "l=" 태그에 지정된 본문 길이는 확인 알고리즘에 전달되는 본문의 바이트 수를 제한합니다. 해당 한도를 초과하는 모든 데이터는 DKIM에 의해 검증되지 않습니다. 따라서 검증자는 표시된 본문 길이를 초과하는 바이트가 포함된 메시지를 의심스럽게 처리할 수 있으며 서명을 유효하지 않은 것처럼 처리하도록 선택할 수 있습니다\(예: PERMFAIL\(서명되지 않은 콘텐츠\)을 반환하여\).

알고리즘이 이 지점에 도달하면 확인이 성공한 것이며 DKIM은 이 서명에 대해 SUCCESS를 보고합니다.

---
### **6.2.  Communicate Verification Results**

검증 결과를 메일 시스템의 다른 부분에 전달하려는 검증자는 적합하다고 판단되는 방식으로 그렇게 할 수 있습니다. 예를 들어, 구현에서는 메시지를 전달하기 전에 메시지에 이메일 헤더 필드를 추가하도록 선택할 수 있습니다. 이러한 헤더 필드는 헤더 필드 블록의 기존 DKIM 서명 또는 기존 인증 상태 헤더 필드 앞에 삽입되어야 합니다. 인증-결과: 헤더 필드\(\[RFC5451\]\)는 이 목적으로 사용될 수 있습니다.\(SHOULD, MAY\)

- MUA 필터 작성자를 위한 정보 조언: 최종 사용자를 위해 인증된 메일을 시각적으로 표시하기 위해 결과 헤더 필드를 검색하기 위한 패턴은 해당 헤더 필드가 적절한 확인 도메인에 의해 추가되었는지, 확인된 ID가 작성자 ID와 일치하는지 확인해야 합니다. MUA에 의해 표시됩니다. 특히 MUA 필터는 공격자가 추가한 가짜 결과 헤더 필드의 영향을 받아서는 안 됩니다. 이 공격을 우회하기 위해 검증자는 검증 후 새 헤더 필드를 추가하기 전에 기존 결과 헤더 필드의 삭제를 요청할 수 있습니다.\(MAY\)

---
### **6.3.  Interpret Results/Apply Local Policy**

신원 평가자가 수행할 수 있는 작업을 설명하는 것은 이 사양의 범위를 벗어나지만, 검증된 SDID를 전달하는 메일은 인증되지 않은 이메일이 제공하지 않는 기회를 신원 평가자에게 제공합니다. 특히, 인증된 이메일은 신뢰 및 평판과 같은 다른 결정을 안정적으로 관리할 수 있는 예측 가능한 식별자를 생성합니다. 반대로, 인증되지 않은 이메일에는 신뢰와 평판을 할당하는 데 사용할 수 있는 신뢰할 수 있는 식별자가 부족합니다. 인증되지 않은 이메일은 신뢰가 부족하고 긍정적인 평판이 없는 것으로 간주하는 것이 합리적입니다.

일반적으로 DKIM 확인 출력을 사용하는 모듈은 서명이 없거나 확인할 수 없는 서명만을 토대로 메시지 허용 여부를 결정해서는 안 됩니다. 그러한 거부는 심각한 상호 운용성 문제를 야기할 수 있습니다. MTA가 SMTP 세션 중에 그러한 메시지를 거부하기를 원하고\(예: 사전 동의에 따라 서명된 메시지만 보내기로 동의한 피어와 통신할 때\) 서명이 없거나 확인하지 않는 경우 처리 MTA는 다음과 같이 해야 합니다. 550/5.7.x 응답 코드를 사용하세요.\(SHOULD NOT, SHOULD\)

검증자가 MTA 내에 통합되어 있고 공개 키를 가져올 수 없는 경우\(아마도 키 서버를 사용할 수 없기 때문에\) 다음과 같은 451/4.7.5 응답 코드를 사용하여 임시 실패 메시지가 생성될 수 있습니다.\(MAY\)

451 4.7.5 서명을 확인할 수 없음 - 키 서버를 사용할 수 없음

키 서버 또는 기타 외부 서비스에 액세스할 수 없는 등의 일시적인 오류는 4xx SMTP 응답 코드를 사용해야 하는 유일한 조건입니다. 특히, 암호화 서명 확인 실패가 4xx SMTP 응답을 유발해서는 안 됩니다.\(SHOULD, MUST NOT\)

서명이 확인되면 해당 정보는 ID 평가자\(예: 명시적 허용/화이트리스트 및 평판 시스템\) 및/또는 최종 사용자에게 전달되어야 합니다. SDID가 From: 헤더 필드의 주소와 동일하지 않은 경우 메일 시스템은 실제 SDID가 독자에게 명확한지 확인해야 합니다.\(MUST, SHOULD\)

검증 실패의 증상은 명백하지만\(서명이 검증되지 않음\), 정확한 원인을 규명하는 것이 더 어려울 수 있습니다. 선택기를 찾을 수 없다면 선택기가 제거되었기 때문입니까, 아니면 이동 중에 값이 변경되었습니까? 서명란이 누락된 경우 해당 내용이 없었기 때문입니까, 아니면 과도한 필터에 의해 제거되었습니까? 진단 목적을 위해 검증이 실패한 정확한 이유를 제공하고 시스템 로그에 기록할 수 있어야 합니다.\(SHOULD\)

이메일을 확인할 수 없는 경우 서명된 것처럼 보이는지 여부에 관계없이 확인되지 않은 모든 이메일과 동일하게 처리되어야 합니다.\(SHOULD\)

추가 논의는 섹션 8.15를 참조하십시오.

---
## **7.  IANA Considerations**

DKIM은 IANA에 네임스페이스를 등록했습니다. 모든 경우에 새 값은 IETF 합의\[RFC5226\]가 있는 게시된 RFC에 문서화된 값에 대해서만 할당됩니다.

이 메모는 아래 설명된 대로 이러한 레지스트리를 업데이트합니다. 주목할 만한 점은 새로운 "상태" 열이 추가되었다는 것입니다. 이러한 네임스페이스에 대한 모든 등록에는 등록되는 이름, 등록 또는 업데이트된 문서, 현재 상태 표시가 포함되어야 하며, 이는 "활성"\(현재 사용 중\) 또는 "역사적"\(더 이상 사용되지 않음\) 중 하나여야 합니다. 현재 사용 중\).\(MUST\)

\[RFC4871\]과 비교하여 이 사양에는 새로운 태그가 정의되어 있지 않지만 하나는 "역사적"으로 지정되었습니다.

또한 이 업데이트를 참조하도록 "이메일 인증 방법" 레지스트리가 수정되었습니다.

---
### **7.1.  Email Authentication Methods Registry**

"이메일 인증 방법" 레지스트리가 업데이트되어 이 메모에 "dkim"이 정의되어 있음을 나타냅니다.

---
### **7.2.  DKIM-Signature Tag Specifications**

DKIM 서명은 태그 사양 목록을 제공합니다. IANA는 DKIM 서명 필드에 사용할 수 있는 태그 사양에 대한 "DKIM 서명 태그 사양" 레지스트리를 구축했습니다.

```text
                    +------+-----------------+--------+
                    | TYPE | REFERENCE       | STATUS |
                    +------+-----------------+--------+
                    |   v  | (this document) | active |
                    |   a  | (this document) | active |
                    |   b  | (this document) | active |
                    |  bh  | (this document) | active |
                    |   c  | (this document) | active |
                    |   d  | (this document) | active |
                    |   h  | (this document) | active |
                    |   i  | (this document) | active |
                    |   l  | (this document) | active |
                    |   q  | (this document) | active |
                    |   s  | (this document) | active |
                    |   t  | (this document) | active |
                    |   x  | (this document) | active |
                    |   z  | (this document) | active |
                    +------+-----------------+--------+

    Table 1: DKIM-Signature Tag Specifications Registry Updated Values
```

---
### **7.3.  DKIM-Signature Query Method Registry**

"q=" 태그 사양\(섹션 3.5에 지정됨\)은 쿼리 메서드 목록을 제공합니다.

IANA는 DKIM을 사용하여 서명된 메시지의 검증 처리를 허용하는 키를 검색하는 데 사용할 수 있는 메커니즘에 대해 "DKIM-서명 쿼리 방법" 레지스트리를 확립했습니다.

```text
               +------+--------+-----------------+--------+
               | TYPE | OPTION | REFERENCE       | STATUS |
               +------+--------+-----------------+--------+
               |  dns |   txt  | (this document) | active |
               +------+--------+-----------------+--------+

       Table 2: DKIM-Signature Query Method Registry Updated Values
```

---
### **7.4.  DKIM-Signature Canonicalization Registry**

"c=" 태그 사양\(섹션 3.5에 지정됨\)은 메시지의 헤더와 본문에 대한 정규화 알고리즘에 대한 지정자를 제공합니다.

IANA는 DKIM을 사용하여 서명하거나 확인하기 전에 메시지를 정식 형식으로 변환하는 알고리즘에 대한 "DKIM 서명 정규화 헤더" 레지스트리를 구축했습니다.

```text
                  +---------+-----------------+--------+
                  |   TYPE  | REFERENCE       | STATUS |
                  +---------+-----------------+--------+
                  |  simple | (this document) | active |
                  | relaxed | (this document) | active |
                  +---------+-----------------+--------+

     Table 3: DKIM-Signature Canonicalization Header Registry Updated
                                  Values

                  +---------+-----------------+--------+
                  |   TYPE  | REFERENCE       | STATUS |
                  +---------+-----------------+--------+
                  |  simple | (this document) | active |
                  | relaxed | (this document) | active |
                  +---------+-----------------+--------+

   Table 4: DKIM-Signature Canonicalization Body Registry Updated Values
```

---
### **7.5.  _domainkey DNS TXT Resource Record Tag Specifications**

\_domainkey DNS TXT RR은 태그 사양 목록을 제공합니다. IANA는 DNS TXT 리소스 레코드에 사용할 수 있는 태그 사양에 대한 DKIM "\_domainkey DNS TXT 레코드 태그 사양" 레지스트리를 설정했습니다.

```text
                   +------+-----------------+----------+
                   | TYPE | REFERENCE       | STATUS   |
                   +------+-----------------+----------+
                   |   v  | (this document) | active   |
                   |   g  | [RFC4871]       | historic |
                   |   h  | (this document) | active   |
                   |   k  | (this document) | active   |
                   |   n  | (this document) | active   |
                   |   p  | (this document) | active   |
                   |   s  | (this document) | active   |
                   |   t  | (this document) | active   |
                   +------+-----------------+----------+

      Table 5: _domainkey DNS TXT Record Tag Specifications Registry
                              Updated Values
```

---
### **7.6.  DKIM Key Type Registry**

"k=" <key-k-tag\>\(섹션 3.6.1에 지정\) 및 "a=" <si- a-tag-k\>\(섹션 3.5에 지정\) 태그는 다음을 수행할 수 있는 메커니즘 목록을 제공합니다. DKIM 서명을 디코딩하는 데 사용됩니다.

IANA는 이러한 메커니즘에 대해 "DKIM 키 유형" 레지스트리를 확립했습니다.

```text
                       +------+-----------+--------+
                       | TYPE | REFERENCE | STATUS |
                       +------+-----------+--------+
                       |  rsa | [RFC3447] | active |
                       +------+-----------+--------+

              Table 6: DKIM Key Type Registry Updated Values
```

---
### **7.7.  DKIM Hash Algorithms Registry**

"h=" <key-h-tag\>\(섹션 3.6.1에 지정\) 및 "a=" <si- a-tag-h\>\(섹션 3.5에 지정\) 태그는 다음을 수행할 수 있는 메커니즘 목록을 제공합니다. 메시지 데이터의 다이제스트를 생성하는 데 사용됩니다.

IANA는 이러한 메커니즘에 대해 "DKIM 해시 알고리즘" 레지스트리를 확립했습니다.

```text
                  +--------+-------------------+--------+
                  |  TYPE  | REFERENCE         | STATUS |
                  +--------+-------------------+--------+
                  |  sha1  | [FIPS-180-3-2008] | active |
                  | sha256 | [FIPS-180-3-2008] | active |
                  +--------+-------------------+--------+

           Table 7: DKIM Hash Algorithms Registry Updated Values
```

---
### **7.8.  DKIM Service Types Registry**

"s=" <key-s-tag\> 태그\(섹션 3.6.1에 지정됨\)는 이 선택기가 적용될 수 있는 서비스 유형 목록을 제공합니다.

IANA는 서비스 유형에 대한 "DKIM 서비스 유형" 레지스트리를 확립했습니다.

```text
                   +-------+-----------------+--------+
                   |  TYPE | REFERENCE       | STATUS |
                   +-------+-----------------+--------+
                   | email | (this document) | active |
                   |   *   | (this document) | active |
                   +-------+-----------------+--------+

            Table 8: DKIM Service Types Registry Updated Values
```

---
### **7.9.  DKIM Selector Flags Registry**

"t=" <key-t-tag\> 태그\(섹션 3.6.1에 지정됨\)는 선택기의 해석을 수정하기 위한 플래그 목록을 제공합니다.

IANA는 추가 플래그에 대해 "DKIM 선택기 플래그" 레지스트리를 구축했습니다.

```text
                    +------+-----------------+--------+
                    | TYPE | REFERENCE       | STATUS |
                    +------+-----------------+--------+
                    |   y  | (this document) | active |
                    |   s  | (this document) | active |
                    +------+-----------------+--------+

           Table 9: DKIM Selector Flags Registry Updated Values
```

---
### **7.10.  DKIM-Signature Header Field**

IANA는 이 문서를 참조로 사용하여 "메일" 프로토콜에 대한 "영구 메시지 헤더 필드 이름" 레지스트리\(\[RFC3864\] 참조\)에 DKIM 서명을 추가했습니다.

---
## **8.  Security Considerations**

스팸의 흐름을 막기 위해 도입된 모든 메커니즘은 집중적인 공격을 받는 것으로 나타났습니다. 잠재적인 공격 벡터와 각각에 대한 취약성을 식별하려면 DKIM을 주의 깊게 조사해야 합니다. \[RFC4686\]도 참조하세요.

---
### **8.1.  ASCII Art Attacks**

완화된 본문 정규화 알고리즘은 단어 사이의 간격을 조정하여 메시지가 전달될 수 있는 특정 유형의 매우 조잡한 "ASCII Art" 공격을 가능하게 할 수 있습니다. 이것이 문제가 된다면 "간단한" 본문 정규화 알고리즘을 대신 사용해야 합니다.

---
### **8.2.  Misuse of Body Length Limits ("l=" Tag)**

"l=" 태그를 사용하면 최종 사용자에게 적절한 경고 없이 사기성 콘텐츠가 표시될 수 있습니다. "l=" 태그는 내용을 수정하고 수정된 메시지에 서명하지 않는 메일링 리스트에 보낼 때 서명 견고성을 높이기 위한 것입니다. 그러나 "l=" 태그를 사용하면 악의적인 의도를 가진 중개자가 공격자에게만 이익이 되는 콘텐츠를 포함하도록 메시지를 수정할 수 있는 공격이 가능합니다. 첨부된 내용으로 가능합니다

최종 수신자의 눈에 원본 콘텐츠를 완전히 대체하고 중복 메시지 감지 알고리즘을 무력화합니다.

이러한 공격의 예로는 MIME 구조 변경, MUA의 느슨한 HTML 구문 분석 활용, 중복 메시지 감지 알고리즘 무력화 등이 있습니다.

이 공격을 방지하려면 서명자는 이 태그 사용에 매우 주의해야 하며 평가자는 태그를 사용하는 서명을 무시할 수 있습니다.

---
### **8.3.  Misappropriated Private Key**

개인 또는 공개 키 쌍을 사용하는 다른 보안 애플리케이션과 마찬가지로 DKIM은 키 처리 및 보호에 주의를 기울여야 합니다. 손상된 개인 키 또는 이에 대한 액세스는 침입자 또는 악성 코드가 일치하는 공개 키를 광고하는 도메인에서 서명한 메일을 보낼 수 있음을 의미합니다.

따라서 ADMD\(관리 관리 도메인\) 자체에서 사용하는 키가 아닌 사용자에게 발급된 개인 키는 ADMD에 영향을 미칠 수 있는 개인 리소스에 저장된 데이터를 보호하는 일반적인 문제를 야기합니다.

보다 안전한 아키텍처에는 기존 기술\(예: SMTP 인증\)을 사용하여 제출자를 인증할 수 있는 나가는 MTA를 통해 메시지를 보내는 것이 포함되며, 메시지 자체의 유효성을 검사할 수도 있습니다\(예: 헤더가 합법적인지, 콘텐츠가 스팸 콘텐츠 검사를 통과하는지 확인\). 을 클릭하고 제출자 주소에 적합한 키를 사용하여 메시지에 서명하세요. 이러한 MTA는 대량 이메일을 생성하는 맬웨어의 기능을 더욱 제한하기 위해 각 사용자가 보내는 메일의 양에 대한 제어를 적용할 수도 있습니다.

---
### **8.4.  Key Server Denial-of-Service Attacks**

주요 서버가 분산되어 있기 때문에\(각 도메인마다 별도\) 인터넷 전체에서 이 메커니즘을 무력화하기 위해 공격해야 하는 서버의 수가 매우 많습니다. 그럼에도 불구하고 개별 도메인의 주요 서버가 공격을 받아 해당 도메인의 메시지 확인이 방해받을 수 있습니다. 이는 들어오는 메일이 아닌 나가는 메일에 영향을 주지만 공격자가 특정 도메인에 대한 메일 교환기에 대한 서비스를 거부하는 능력과 크게 다르지 않습니다.

```text
   A variation on this attack involves a very large amount of mail being
   sent using spoofed signatures from a given domain: the key servers
   for that domain could be overwhelmed with requests in a denial-of-
```

서비스 공격\(\[RFC4732\] 참조\). 그러나 이메일 메시지 자체를 처리하는 것에 비해 확인 오버헤드가 낮다는 점을 고려하면 이러한 공격은 발생하기 어려울 것입니다.

---
### **8.5.  Attacks against the DNS**

DNS는 주요 서비스에 대한 필수 바인딩이므로 DNS에 대한 특정 공격을 고려해야 합니다.

현재 DNS는 안전하지 않지만\[RFC3833\] 이러한 보안 문제는 DNS 보안\(DNSSEC\)\[RFC4033\]의 동기가 되며 모든 DNS 사용자는 해당 작업의 이점을 얻게 됩니다.

DKIM은 진위를 입증하는 "충분한" 방법으로만 사용됩니다. 저작권이나 콘텐츠에 대한 강력한 암호화 증거를 제공하기 위한 것이 아닙니다. OpenPGP \[RFC4880\] 및 S/MIME \[RFC5751\]과 같은 다른 기술은 이러한 요구 사항을 해결합니다.

DNS와 관련된 두 번째 보안 문제는 선택기 기반 데이터 가져오기 및 서명 도메인 정책 가져오기의 결과로 증가된 DNS 트래픽과 관련이 있습니다. DKIM이 널리 배포되면 청구된 서명 도메인에 대한 DNS 쿼리가 크게 증가합니다. 대규모 위조의 경우 DNS 서버의 쿼리가 크게 증가할 수 있습니다.

DKIM 검증자가 고려해야 하는 특정 DNS 보안 문제는 \[RFC3833\]의 섹션 2.3에 설명된 이름 연결 공격입니다. DKIM 검증자는 DKIM 서명 헤더 필드를 확인하는 동안 공격자가 선택한 키 레코드를 검색하라는 메시지를 받을 수 있습니다. 이러한 위협은 검증자가 사용하는 재귀 이름 서버를 포함한 이름 서버가 DNS 응답의 "접착제" 및 기타 추가 정보를 엄격하게 검사하여 이 공격에 취약하지 않도록 함으로써 최소화될 수 있습니다.

---
### **8.6.  Replay/Spam Attacks**

이 공격에서 스패머는 자신의 도메인이 아닌 서명 도메인\(예: 유명 메일박스 제공업체\)의 평판을 이용하여 서명하는 MTA를 통해 스팸 조각을 보낸 다음 해당 메시지를 대형 도메인으로 다시 보냅니다. 예정된 수신자 수. 수신자는 잘 알려진 도메인의 유효한 서명을 관찰하여 메시지에 대한 신뢰도를 높이고 사용자에게 전달 및 표시될 가능성을 높입니다.

이 문제에 대한 부분적인 해결책은 평판 서비스를 사용하여 특정 전자 메일 주소가 스팸에 사용되고 있으며 해당 서명자의 메시지가 스팸일 가능성이 높다는 사실을 전달하는 것입니다. 이를 위해서는 실시간 탐지 메커니즘이 필요합니다.

충분히 빠르게 반응하세요. 그러나 예를 들어 공격자가 피해자를 스패머로 보이게 하기 위해 피해자로부터 받은 대량의 메시지를 재전송하는 경우 이러한 조치는 남용되기 쉽습니다.

대규모 검증자는 짧은 시간 내에 동일한 서명을 가진 비정상적으로 많은 양의 메일을 탐지할 수 있습니다. 소규모 검증자는 기존 협업 시스템을 통해 실질적으로 동일한 양의 정보를 얻을 수 있습니다.

---
### **8.7.  Limits on Revoking Keys**

대규모 도메인이 사용자 중 한 사람의 바람직하지 않은 행동을 감지하면 아직 확인되지 않았거나 재생 대상인 메시지에 대한 책임을 부인하기 위해 해당 사용자의 메시지에 서명하는 데 사용된 키를 취소할 수 있습니다. 공격. 그러나 확장성 이유로 동일한 키를 사용하여 다른 많은 사용자의 메시지에 서명하는 경우 도메인의 기능이 제한될 수 있습니다. 주소별로 키를 명시적으로 취소하는 메커니즘이 제안되었지만 그 유틸리티와 그것이 나타내는 DNS 부하에 대한 추가 연구가 필요합니다.

---
### **8.8.  Intentionally Malformed Key Records**

공격자가 강력하지 않은 검증 도구 구현에 서비스 거부 공격을 일으키려는 의도로 의도적으로 기형인 DNS의 주요 레코드를 게시할 수 있습니다. 그런 다음 공격자는 서명에서 기형 레코드를 참조하는 메시지를 사용자 중 한 명에게 보내 검증자가 기형 키 레코드를 읽도록 할 수 있습니다. 검증자는 DNS에서 검색된 모든 키 레코드를 철저하게 검증해야 하며 의도적으로 또는 의도치 않게 잘못된 형식의 키 레코드에 대해 견고해야 합니다.\(MUST\)

---
### **8.9.  Intentionally Malformed DKIM-Signature Header Fields**

검증자는 잘못된 형식의 DKIM-Signature 헤더 필드가 있는 메시지를 수신하고 해당 내용에 의존하기 전에 헤더 필드를 철저히 검증할 준비를 해야 합니다.\(MUST\)

---
### **8.10.  Information Leakage**

공격자는 메시지별 선택기를 사용한 다음 키 조회를 위해 DNS 트래픽을 모니터링하여 특정 서명이 언제 확인되었는지 확인할 수 있습니다. 이는 메시지를 읽은 시간이 아닌 확인 시간에 대한 "웹 버그"와 동등한 역할을 합니다.

---
### **8.11.  Remote Timing Attacks**

어떤 경우에는 원격 타이밍 공격\[BONEH03\]을 사용하여 개인 키를 추출하는 것이 가능할 수도 있습니다. 구현에서는 이러한 공격을 방지하기 위해 타이밍을 난독화하는 것을 고려해야 합니다.

---
### **8.12.  Reordered Header Fields**

기존 표준을 사용하면 중간 MTA가 헤더 필드를 재정렬할 수 있습니다. 서명자가 동일한 이름의 두 개 이상의 헤더 필드에 서명하면 합법적인 메시지에 대해 허위 확인 오류가 발생할 수 있습니다. 특히 기존 DKIM-서명 필드에 서명하는 서명자는 메시지 확인에 잘못 실패할 위험이 있습니다.

---
### **8.13.  RSA Attacks**

공격자는 작은 지수로 대규모 RSA 서명 키를 생성할 수 있으므로 확인 키에 큰 지수가 필요합니다. 이로 인해 검증자는 서명을 검증하기 위해 상당한 컴퓨팅 리소스를 사용해야 합니다. 검증자는 불합리한 지수를 가진 공개 키가 있는 선택기를 참조하는 서명 검증을 거부함으로써 이 공격을 피할 수 있습니다.

일반적으로 공격자는 확인이 필요한 메시지를 너무 많이 보내 확인자를 압도하려고 시도할 수 있습니다. 이는 다른 MTA 서비스 거부 공격과 유사하며 비슷한 방식으로 처리해야 합니다.

---
### **8.14.  Inappropriate Signing by Parent Domains**

섹션 3.10에 설명된 신뢰 관계는 관리상 상위 도메인과 관련되지 않은 하위 도메인의 ID로 메시지에 서명하기 위해 상위 도메인에서 사용될 수 있습니다. 예를 들어, ".com" 레지스트리는 example.com 도메인의 "i=" 값을 사용하여 서명이 포함된 메시지를 생성할 수 있습니다. 관리상의 절단은 도메인 이름의 어느 곳에서나 발생할 수 있으므로 이 문제에 대한 일반적인 해결책은 없습니다. 예를 들어, "example.podunk.ca.us" 도메인에는 세 개의 관리 컷\(podunk.ca.us, ca.us 및 us\)이 있으며, 이들 중 하나는 전체 도메인에서 ID를 사용하여 메시지를 생성할 수 있습니다.

- 참고 사항: 이는 도메인 위임에 허용되는 것과 동일한 이유로 허용 가능한 위험으로 간주됩니다. 예를 들어 위의 경우 모든 도메인은 잠재적으로 "example.podunk.ca.us"를 선택한 서버에 위임할 수 있습니다.

- 모든 DNS 제공 정보를 완전히 교체합니다. 섹션 6.1.1에 설명된 대로 검증자는 ".com"과 같은 가능성이 낮은 도메인에서 오는 서명을 무시할 수 있습니다.\(MAY\)

---
### **8.15.  Attacks Involving Extra Header Fields**

MTA, MSA, MUA 및 필터링 모듈을 포함한 많은 이메일 구성 요소는 메시지 형식 검사를 느슨하게만 구현합니다. 이는 지원 비용을 줄이기 위해 메일 스트림에 허용되는 내용을 자유롭게 하라는 업계의 수년간의 압력으로 인해 수행되었습니다. 부적절하게 구성된 메시지는 전송 중에 자동으로 수정되거나, 수정되지 않은 채 전달되거나, 부적절하게 표시되는 경우가 많습니다\(예: 여러 보낸 사람: 필드 중 첫 번째 항목만 표시\).

DKIM 출력을 평가하거나 적용하는 에이전트는 DKIM 서명자가 잘못된 형식\(예: 한 번만 허용되는 필드의 여러 인스턴스를 갖는 등 \[RFC5322\] 위반\), 전송 중에 잘못된 형식이 되는 메시지에 서명할 수 있다는 점을 인식해야 합니다. , 또는 사실이 아니거나 유효하지 않은 헤더나 본문 내용을 포함하고 있습니다. 이러한 메시지에 DKIM을 사용하면 수신자에 대한 공격이 될 수 있습니다. 특히 서명자에 대한 적절한 평가 없이 서명된 메시지에 추가적인 신뢰가 부여되는 경우 더욱 그렇습니다.

이는 심각한 공격을 나타낼 수 있지만 DKIM과는 아무런 관련이 없습니다. 이는 수신자 또는 잘못 식별된 작성자에 대한 공격입니다.

더욱이 에이전트가 헤더 필드의 모든 인스턴스가 서명되었다는 이유만으로 서명되었다고 추론하는 것은 올바르지 않습니다.

공격을 받는 도메인의 실제 서명은 합법적인 방법으로 얻을 수 있지만 가로채기나 재생을 통해 추가 헤더 필드가 추가될 수 있습니다. 이 시나리오에서 DKIM은 전송 중인 특정 필드 추가를 감지하는 데 도움을 줄 수 있습니다. 이는 서명자가 추가 시간에 걸쳐 "h=" 태그에 필드 이름을 나열하도록 함으로써 수행됩니다\(예: 보낸 사람 필드가 하나인 메시지의 경우 "h=from:from:..."\). 해당 필드 다운스트림 인스턴스의 서명을 확인할 수 없게 됩니다. \(자세한 내용은 섹션 3.5를 참조하십시오.\) 이는 본질적으로 서명자가 이러한 잘못된 메시지에 대한 책임을 부인한다는 명시적인 표시입니다.

DKIM은 지시받은 데이터에 서명하고 유효성을 검사하며 올바르게 작동합니다. 따라서 이 경우 DKIM은 검증된 도메인\("d=" 값\)을 전달하는 작업을 수행했으며 DKIM 서명의 의미를 고려할 때 기본적으로 서명자는 문제가 있는 메시지에 대해 어느 정도 책임을 지게 됩니다. 이는 신원 평가자 또는 기타 다른 사람에게 달려 있습니다.

후속 에이전트는 메시지\(또는 실제로 서명자의 신뢰\)를 저하시키거나, 수신자에게 경고하거나, 배달을 거부하는 등 필요에 따라 해당 메시지에 대해 조치를 취합니다.

다른 메일 표준을 느슨하게 적용하는 메일 시스템의 모든 구성 요소는 DKIM을 통합할 때, 특히 설명된 것과 같은 잠재적인 공격 문제를 고려할 때 해당 자세를 다시 검토해야 합니다.

---
## **9.  References**
---
### **9.1.  Normative References**

\[FIPS-180-3-2008\]

- 미국 상무부, "보안 해시 표준", FIPS PUB 180-3, 2008년 10월.

\[ITU-X660-1997\]

- "정보 기술 - ASN.1 인코딩 규칙: 기본 인코딩 규칙\(BER\), 표준 인코딩 규칙\(CER\) 및 고유 인코딩 규칙\(DER\)의 사양", 1997.

\[RFC1034\] Mockapetris, P., "도메인 이름 - 개념 및 기능", STD 13, RFC 1034, 1987년 11월.

\[RFC2045\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 1부: 인터넷 메시지 본문 형식", RFC 2045, 1996년 11월.

\[RFC2049\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 5부: 적합성 기준 및 예", RFC 2049, 1996년 11월.

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC3447\] Jonsson, J. 및 B. Kaliski, "공개 키 암호화 표준\(PKCS\) #1: RSA 암호화 사양 버전 2.1", RFC 3447, 2003년 2월.

\[RFC5234\] Crocker, D. 및 P. Overell, "구문 사양을 위한 증강 BNF: ABNF", STD 68, RFC 5234, 2008년 1월.

```text
   [RFC5321]  Klensin, J., "Simple Mail Transfer Protocol", RFC 5321,
              October 2008.

   [RFC5322]  Resnick, P., Ed., "Internet Message Format", RFC 5322,
              October 2008.

   [RFC5598]  Crocker, D., "Internet Mail Architecture", RFC 5598,
              July 2009.
```

\[RFC5890\] Klensin, J., "국제화된 도메인 이름

- 애플리케이션\(IDNA\): 정의 및 문서 프레임워크", RFC 5890, 2010년 8월.

---
### **9.2.  Informative References**

\[BONEH03\] "원격 타이밍 공격은 실용적입니다", 제12회 USENIX 보안 심포지엄, 2003년 진행.

\[RFC2047\] Moore, K., "MIME\(다목적 인터넷 메일 확장\) 3부: 비ASCII 텍스트에 대한 메시지 헤더 확장", RFC 2047, 1996년 11월.

\[RFC3629\] Yergeau, F., "UTF-8, ISO 10646의 변환 형식", STD 63, RFC 3629, 2003년 11월.

\[RFC3766\] Orman, H. 및 P. Hoffman, "대칭 키 교환에 사용되는 공개 키의 강도 결정", BCP 86, RFC 3766, 2004년 4월.

\[RFC3833\] Atkins, D. 및 R. Austein, "DNS\(도메인 이름 시스템\)의 위협 분석", RFC 3833, 2004년 8월.

\[RFC3864\] Klyne, G., Nottingham, M. 및 J. Mogul, "메시지 헤더 필드 등록 절차", BCP 90, RFC 3864, 2004년 9월.

\[RFC4033\] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose, "DNS 보안 소개 및 요구 사항", RFC 4033, 2005년 3월.

\[RFC4409\] Gellens, R. 및 J. Klensin, "메일을 위한 메시지 제출", RFC 4409, 2006년 4월.

\[RFC4686\] Fenton, J., "DKIM\(도메인 키 식별 메일\)을 유발하는 위협 분석", RFC 4686, 2006년 9월.

\[RFC4732\] Handley, M., Rescorla, E. 및 IAB, "인터넷 서비스 거부 고려 사항", RFC 4732, 2006년 12월.

\[RFC4870\] Delany, M., "DNS\(DomainKeys\)에 광고된 공개 키를 사용한 도메인 기반 이메일 인증", RFC 4870, 2007년 5월.

\[RFC4871\] Allman, E., Callas, J., Delany, M., Libbey, M., Fenton, J. 및 M. Thomas, "DKIM\(DomainKeys Identified Mail\) 서명", RFC 4871, 2007년 5월.

\[RFC4880\] Callas, J., Donnerhacke, L., Finney, H., Shaw, D. 및 R. Thayer, "OpenPGP 메시지 형식", RFC 4880, 2007년 11월.

\[RFC5226\] Narten, T. 및 H. Alvestrand, "RFC에서 IANA 고려 사항 섹션 작성 지침", BCP 26, RFC 5226, 2008년 5월.

\[RFC5451\] Kucherawy, M., "메시지 인증 상태를 나타내는 메시지 헤더 필드", RFC 5451, 2009년 4월.

\[RFC5585\] Hansen, T., Crocker, D. 및 P. Hallam-Baker, "DKIM\(DomainKeys Identified Mail\) 서비스 개요", RFC 5585, 2009년 7월.

```text
   [RFC5672]  Crocker, D., "RFC 4871 DomainKeys Identified Mail (DKIM)
              Signatures -- Update", RFC 5672, August 2009.
```

\[RFC5751\] Ramsdell, B. 및 S. Turner, "S/MIME\(Secure/Multipurpose Internet Mail Extensions\) 버전 3.2 메시지 사양", RFC 5751, 2010년 1월.

\[RFC5863\] Hansen, T., Siegel, E., Hallam-Baker, P. 및 D. Crocker, "DKIM\(DomainKeys Identified Mail\) 개발, 배포 및 운영", RFC 5863, 2010년 5월.

\[RFC6377\] Kucherawy, M., "DKIM\(DomainKeys Identified Mail\) 및 메일링 목록", RFC 6377, 2011년 9월.

---
# **Appendix A.  Example of Use (INFORMATIVE)**

이 섹션에서는 제출부터 최종 전달까지 이메일의 전체 흐름을 보여 주며, 다양한 구성 요소가 어떻게 조화를 이루는지 보여줍니다. 이 예에 사용된 키는 부록 C에 나와 있습니다.

---
### **A.1.  The User Composes an Email**

보낸 사람: Joe SixPack <joe@football.example.com\> 받는 사람: Suzie Q <suzie@shopping.example.net\> 제목: 저녁 식사 준비됐나요? 날짜: 2003년 7월 11일 금요일 21:00:37 -0700\(PDT\) 메시지 ID: <20030712040037.46341.5F8J@football.example.com\>

```text
   Hi.
```

우리는 게임에서 졌습니다. 아직 배가 고프신가요?

```text
   Joe.

                   Figure 1: The User Composes an Email
```

---
### **A.2.  The Email is Signed**

이 이메일은 example.com 아웃바운드 이메일 서버에 의해 서명되었으며 이제 다음과 같습니다.

DKIM-서명: v=1; a=rsa-sha256; s=브리즈번; d=example.com; c=단순/단순; q=dns/txt; i=joe@football.example.com; h=수신 : 보낸 사람 : 받는 사람 : 제목 : 날짜 : 메시지 ID; bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=; b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB 4nujc7YopdG5dWLSdNg6xNAZpOPr+kHxt1IrE+NahM6L/LbvaHut KVdkLLkpVaVVQPzeRDI009SO2Il5Lu7rDNH6mZckBdrI x0또는EtZV 4bmp/YzhwvcubU4=; 수신: client1.football.example.com \[192.0.2.1\]에서 submitserver.example.com에 의해 SUBMISSION으로; 2003년 7월 11일 금요일 21:01:54 -0700 \(PDT\) 보낸 사람: Joe SixPack <joe@football.example.com\> 받는 사람: Suzie Q <suzie@shopping.example.net\> 제목: 저녁 식사 준비됐나요? 날짜: 2003년 7월 11일 금요일 21:00:37 -0700\(PDT\) 메시지 ID: <20030712040037.46341.5F8J@football.example.com\>

```text
   Hi.
```

우리는 게임에서 졌습니다. 아직 배가 고프신가요?

```text
   Joe.

                       Figure 2: The Email is Signed
```

서명 이메일 서버는 이 서명을 생성하기 위해 "brisbane" 선택기와 연결된 개인 키에 액세스해야 합니다.

---
### **A.3.  The Email Signature is Verified**

서명은 일반적으로 인바운드 SMTP 서버 또는 최종 배달 에이전트에 의해 확인됩니다. 그러나 개입하는 MTA도 원하는 경우 이 확인을 수행할 수 있습니다. 확인 프로세스에서는 DKIM-Signature 헤더 필드의 "d=" 태그에서 추출된 도메인 "example.com"과 "s=" 태그의 선택기 "brisbane"을 사용하여 다음에 대한 DNS DKIM 쿼리를 구성합니다. brisbane.\_domainkey .example.com

서명 확인은 "h=" 태그에 나열된 순서대로 물리적으로 마지막 수신 헤더 필드, 보낸 사람 헤더 필드부터 시작됩니다. 확인은 단일 CRLF와 본문\("Hi."로 시작\)으로 이어집니다. 이메일은 "간단한" 방법으로 확인하기 위해 정식으로 준비되었습니다. 쿼리 결과와 서명에 대한 후속 확인은 \(이 예에서는\) X-Authentication-Results 헤더 필드 라인에 저장됩니다. 성공적으로 확인되면 이메일은 다음과 같습니다.

X-인증-결과: shopping.example.net header.from=joe@football.example.com; dkim=pass 수신: mout23.football.example.com\(192.168.1.1\)에서 SMTP를 사용하여 shopping.example.net으로; 2003년 7월 11일 금요일 21:01:59 -0700 \(PDT\) DKIM-서명: v=1; a=rsa-sha256; s=브리즈번; d=example.com; c=단순/단순; q=dns/txt; i=joe@football.example.com; h=수신 : 보낸 사람 : 받는 사람 : 제목 : 날짜 : 메시지 ID; bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=; b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB 4nujc7YopdG5dWLSdNg6xNAZpOPr+kHxt1IrE+NahM6L/LbvaHut KVdkLLkpVaVVQPzeRDI009SO2Il5Lu7rDNH6mZckBdrI x0또는EtZV 4bmp/YzhwvcubU4=; 수신: client1.football.example.com \[192.0.2.1\]에서 submitserver.example.com에 의해 SUBMISSION으로; 2003년 7월 11일 금요일 21:01:54 -0700 \(PDT\) 보낸 사람: Joe SixPack <joe@football.example.com\> 받는 사람: Suzie Q <suzie@shopping.example.net\> 제목: 저녁 식사 준비됐나요? 날짜: 2003년 7월 11일 금요일 21:00:37 -0700\(PDT\) 메시지 ID: <20030712040037.46341.5F8J@football.example.com\>

```text
   Hi.
```

우리는 게임에서 졌습니다. 아직 배가 고프신가요?

```text
   Joe.

                     Figure 3: Successful Verification
```

---
# **Appendix B.  Usage Examples (INFORMATIVE)**

DKIM 서명 및 유효성 검사는 다양한 운영 시나리오에 따라 다양한 방식으로 사용될 수 있습니다. 이 부록에서는 몇 가지 일반적인 예를 설명합니다.

- 참고: 이 부록의 설명은 정보 제공의 목적으로만 제공됩니다. 특정 제약 조건과 요구 사항에 따라 DKIM을 사용할 수 있는 다양한 방법을 설명합니다. 어떤 경우에도 이러한 예제를 구현 생성 시 DKIM 사양 세부 사항에 관한 설명이나 지침을 제공하는 것으로 간주해서는 안 됩니다.

---
### **B.1.  Alternate Submission Scenarios**

가장 간단한 시나리오에서는 사용자의 MUA, MSA 및 인터넷\(경계\) MTA가 모두 동일한 도메인 이름을 사용하여 동일한 관리 환경 내에 있습니다. 따라서 제출 및 초기 전송과 관련된 모든 구성 요소가 서로 연관되어 있습니다. 그러나 둘 이상의 구성 요소가 독립적인 관리 제어를 받는 것이 일반적입니다. 이로 인해 서명에 사용할 도메인 이름과 일반적인 이메일 ID 헤더 필드와의 관계를 선택하고 관리하는 데 어려움이 있습니다.

---
#### **B.1.1.  Delegated Business Functions**

일부 조직에서는 조직 내부 또는 외부의 개별 그룹에 특정 비즈니스 기능을 할당합니다. 따라서 목표는 해당 그룹이 일부 메일에 서명할 수 있도록 권한을 부여하되 생성할 수 있는 서명을 제한하는 것입니다. DKIM 선택기\("s=" 서명 태그\)는 이러한 종류의 제한된 승인을 용이하게 합니다. 이러한 아웃소싱 비즈니스 기능의 예로는 합법적인 이메일 마케팅 제공업체와 기업 혜택 제공업체가 있습니다.

여기서 위임받은 그룹은 클라이언트사의 이메일 도메인을 이용하여 서명된 메시지를 보낼 수 있어야 합니다. 동시에 클라이언트는 도메인의 임의 주소에 대해 메시지를 보낼 수 있는 기능을 부여하는 공급자에 대한 키 등록을 꺼리는 경우가 많습니다.

이러한 사용 시나리오를 관리하는 방법에는 여러 가지가 있습니다. 어떤 경우에는 클라이언트 조직이 모든 공개 쿼리 서비스\(예: DNS\) 관리를 제공하고, 다른 경우에는 DNS 위임을 사용하여 위임된 그룹에 의한 DKIM 키 레코드의 모든 지속적인 관리를 활성화합니다.

DNS 관리를 모두 고객사가 맡는다면 외주업체는 키쌍을 생성해 고객사에 공개키를 제공하고, 고객사는 이를 고유 선택자를 사용해 조회 서비스에 등록할 수 있다. 클라이언트 회사는 언제든지 키를 취소할 수 있는 권한을 보유하므로 위임된 키의 사용에 대한 통제권을 유지합니다.

클라이언트가 위임된 그룹이 DNS 관리를 수행하도록 하려는 경우 공급자의 DNS 서버를 가리키는 선택기로 지정된 도메인 이름을 가질 수 있습니다. 그런 다음 공급자는 해당 선택기에 대한 모든 DKIM 서명 정보를 생성하고 유지 관리합니다. 따라서 클라이언트는 서명된 주소의 로컬 부분에 대한 제약 조건을 제공할 수 없지만 DNS 위임 레코드를 제거하여 공급자의 서명 권한을 취소할 수 있습니다.

---
#### **B.1.2.  PDAs and Similar Devices**

PDA는 도메인당 여러 키를 사용해야 하는 필요성을 보여줍니다. John Doe가 자신의 회사 이메일 주소인 jdoe@example.com을 사용하여 메시지를 보낼 수 있기를 원하지만 그의 이메일 장치에는 회사 네트워크에 VPN\(가상 사설망\) 연결을 설정할 수 있는 기능이 없다고 가정해 보겠습니다. 장치가 제한되어 있거나 인터넷 액세스 공급자가 시행하는 제한 사항이 있기 때문입니다. 장치에 example.com 도메인 관리자가 jdoe@example.com에 등록한 개인 키와 메시지 서명을 위한 적절한 소프트웨어가 장착되어 있는 경우 John은 액세스의 나가는 네트워크를 통해 전송하기 전에 장치 자체에서 메시지에 서명할 수 있습니다. 서비스 제공자.

---
#### **B.1.3.  Roaming Users**

로밍 사용자는 홈 서버가 아닌 SMTP 서버를 사용하는 것이 편리하거나 필요한 상황에 처하는 경우가 많습니다. 예를 들면 컨퍼런스와 많은 호텔이 있습니다. 이러한 상황에서는 제출 서비스에서 추가된 서명이 사용자의 홈 시스템과 다른 ID를 사용합니다.

이상적으로 로밍 사용자는 포트 587에서 SMTP 인증으로 실행되는 VPN 또는 SUBMISSION 서버를 사용하여 홈 서버에 다시 연결합니다. 로밍 사용자의 랩톱에서 서명을 수행할 수 있는 경우 제출 전에 서명할 수 있습니다. 추가 수정이 높습니다. 둘 다 가능하지 않으면 로밍 사용자는 자신의 도메인 키를 사용하여 서명된 메일을 보낼 수 없습니다.

---
#### **B.1.4.  Independent (Kiosk) Message Submission**

워크업 키오스크 및 웹 기반 정보 서비스와 같은 독립형 서비스는 사용자와의 지속적인 이메일 서비스 관계가 없지만 사용자는 때때로 자신을 대신하여 메일을 보내달라고 요청합니다. 예를 들어, 뉴스를 제공하는 웹사이트에서는 독자가 기사 사본을 친구에게 전달할 수 있는 경우가 많습니다. 이는 일반적으로 작성자가 누구인지 나타내기 위해 독자 자신의 이메일 주소를 사용하여 수행됩니다. 이는 사용자가 친구에게 초대장을 보낼 수 있는 동일한 이름의 웹사이트 이름을 따서 "Evite" 문제라고도 합니다.

이를 처리하는 일반적인 방법은 메시지의 보낸 사람 헤더 필드에 독자의 이메일 주소를 계속 입력하고 보낸 사람 헤더 필드에는 이메일 게시 사이트가 소유한 주소를 입력하는 것입니다. 그러면 게시 사이트는 보낸 사람 필드에 있는 도메인을 사용하여 메시지에 서명할 수 있습니다. 이는 서명 도메인을 초기 제출 이메일 역할과 연관시킬 수 있는 수신 이메일 사이트에 유용한 정보를 제공합니다.

수신 사이트에서는 이러한 방식으로 중재되는 메일에 대한 정보를 최종 사용자에게 제공하려는 경우가 많습니다. 다양한 접근 방식의 실제 효율성은 인적 요소 유용성 연구의 주제이지만, 사용되는 한 가지 기술은 확인 시스템이 From 헤더 필드를 다시 작성하여 확인된 주소를 표시하는 것입니다. 예: From: John Doe via news@ news-site.example <jdoe@example.com\>. \(검증 통과가 완료된 후에 수행하지 않는 한 이러한 재작성은 서명을 깨뜨리게 됩니다.\)

---
### **B.2.  Alternate Delivery Scenarios**

이메일은 초기 제출 시 사용된 주소와 다른 주소를 가진 사서함으로 수신되는 경우가 많습니다. 이러한 경우 중개 메커니즘은 원래 사용된 주소에서 작동한 다음 메시지를 최종 대상으로 전달합니다. 이 중재 프로세스에는 DKIM 서명에 대한 몇 가지 문제가 있습니다.

---
#### **B.2.1.  Affinity Addresses**

"친화성 주소"를 사용하면 사용자가 다른 이메일 제공업체 간에 이동하더라도 안정적으로 유지되는 이메일 주소를 가질 수 있습니다. 이들은 일반적으로 장기적인 관계를 맺을 것으로 기대하는 대학 동창회, 전문 단체, 레크리에이션 단체와 연관되어 있습니다. 이러한 도메인은 일반적으로 수신 이메일의 전달 기능을 제공하며 사용자를 인증하고 전달 주소를 허용하는 관련 웹 애플리케이션이 있는 경우가 많습니다.

변경되었습니다. 그러나 이러한 서비스는 일반적으로 자체 서비스 공급자의 MTA를 통해 보내는 메시지를 보내는 사용자에 따라 달라집니다. 따라서 선호도 주소의 도메인으로 서명된 메일은 해당 도메인을 소유한 조직에서 관리하는 엔터티에 의해 서명되지 않습니다.

DKIM을 사용하면 선호도 도메인에서 웹 애플리케이션을 사용하여 사용자가 선호도 주소를 대신하여 메시지에 서명하는 데 사용할 사용자별 키를 등록할 수 있습니다. 사용자는 서명을 위해 키 쌍의 비밀 절반을 가져가고 선호도 도메인은 검증자가 액세스할 수 있도록 DNS에 공개 절반을 게시합니다.

이는 사용자 수준 키잉을 활용하는 또 다른 애플리케이션이며, 선호도 주소에 사용되는 도메인은 일반적으로 매우 많은 수의 사용자 수준 키를 갖습니다. 또는 선호도 도메인은 사용자를 위한 메시지를 수락하고 서명하기 전에 사용자를 인증하는 메일 전송 에이전트를 작동하여 보내는 메일을 처리할 수 있습니다. 물론 이는 메일 제출에 사용되는 관련 TCP 포트를 차단하지 않는 사용자의 서비스 제공업체에 따라 다릅니다.

---
#### **B.2.2.  Simple Address Aliasing (.forward)**

어떤 경우에는 Unix .forward 파일 사용 등을 통해 수신자가 전자 메일 메시지를 원래 주소에서 다른 주소로 자동 리디렉션하도록 전자 메일 주소를 구성할 수 있습니다. 이 경우 메시지는 일반적으로 메시지에 수신 헤더 필드 추가 및 봉투 수신자 주소 변경을 제외하고는 수정 없이 수신자 도메인의 메일 처리 서비스에 의해 리디렉션됩니다. 이 경우 서명된 내용이 변경되지 않았으므로 최종 주소의 사서함에 있는 수신자는 원본 서명을 확인할 수 있을 가능성이 높으며 DKIM은 메시지 서명을 확인할 수 있습니다.

---
#### **B.2.3.  Mailing Lists and Re-Posters**

서비스에는 메시지 전달을 받은 다음 다시 제출하는 다양한 동작이 있습니다. 주요 예는 수신된 헤더 필드를 추가하고 봉투 정보를 변경하는 것 외에 메시지 자체를 수정하지 않는 것부터 헤더 필드를 추가하는 것까지 메일링 목록\(아래에서 통칭하여 "전달자"라고 함\)을 사용하는 것입니다. 제목 헤더 필드를 사용하여 본문에 내용을 추가하거나\(일반적으로 끝 부분\) 어떤 방식으로든 본문 형식을 다시 지정합니다. 간단한 서비스는 자동 별칭 서비스와 매우 유사한 메시지를 생성합니다. 보다 정교한 시스템은 본질적으로 새로운 메시지를 생성합니다.

메시지의 본문이나 서명된 헤더 필드를 수정하지 않는 전달자는 기존 서명의 유효성을 유지할 가능성이 높습니다. 또한 메시지에 자체 서명을 추가하도록 선택할 수도 있습니다.

기존 서명을 무효화할 수 있는 방식으로 메시지를 수정하는 전달자는 자체 서명을 추가하기에 특히 좋은 후보입니다\(예: mailing-list-name@example.net\). \(재\)서명은 메시지 내용에 대한 책임을 지기 때문에 이러한 서명 전달자는 메시지가 유효한 서명으로 수신되었거나 알 수 있는 다른 근거가 있는 경우에만 선택적으로 메시지를 전달하거나 다시 서명할 가능성이 높습니다. 메시지가 스푸핑되지 않았다는 것입니다.

주로 메일을 재배포하는 시스템 사이의 일반적인 관행은 메시지 서명에 사용되는 주소를 식별하기 위해 메시지에 Sender 헤더 필드를 추가하는 것입니다. 이 방법은 \[RFC5322\]에서 요구하는 대로 기존 Sender 헤더 필드를 제거합니다. 전달자는 전달자의 서명, 공개 키 및 관련 정보와 함께 새로운 DKIM-Signature 헤더 필드를 적용합니다.

추가 관련 주제 및 토론은 \[RFC6377\]을 참조하세요.

---
# **Appendix C.  Creating a Public Key (INFORMATIVE)**

기본 서명은 전체 이메일의 RSA 서명 SHA-256 다이제스트입니다. 설명의 편의를 위해 openssl 명령을 사용하여 키와 서명을 관리하는 메커니즘을 설명합니다. DKIM에 적합한 1024비트, 암호화되지 않은 개인 키를 생성하는 한 가지 방법은 다음과 같이 openssl을 사용하는 것입니다.

```text
   $ openssl genrsa -out rsa.private 1024
```

보안 강화를 위해 "-passin" 매개변수를 추가하여 개인 키를 암호화할 수도 있습니다. 이 매개변수를 사용하려면 다음 여러 단계에서 비밀번호를 입력해야 합니다. 서버는 하드웨어 암호화 지원을 선호할 수 있습니다.

"genrsa" 단계를 수행하면 다음과 유사한 주요 정보가 포함된 rsa.private 파일이 생성됩니다.

```text
   -----BEGIN RSA PRIVATE KEY-----
   MIICXwIBAAKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYtIxN2SnFC
   jxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/RtdC2UzJ1lWT947qR+Rcac2gb
   to/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB
   AoGBALmn+XwWk7akvkUlqb+dOxyLB9i5VBVfje89Teolwc9YJT36BGN/l4e0l6QX
   /1//6DWUTB3KI6wFcm7TWJcxbS0tcKZX7FsJvUz1SbQnkS54DJck1EZO/BLa5ckJ
   gAYIaqlA9C0ZwM6i58lLlPadX/rtHb7pWzeNcZHjKrjM461ZAkEA+itss2nRlmyO
   n1/5yDyCluST4dQfO8kAB3toSEVc7DeFeDhnC1mZdjASZNvdHS4gbLIA1hUGEF9m
   3hKsGUMMPwJBAPW5v/U+AWTADFCS22t72NUurgzeAbzb1HWMqO4y4+9Hpjk5wvL/
   eVYizyuce3/fGke7aRYw/ADKygMJdW8H/OcCQQDz5OQb4j2QDpPZc0Nc4QlbvMsj
   7p7otWRO5xRa6SzXqqV3+F0VpqvDmshEBkoCydaYwc2o6WQ5EBmExeV8124XAkEA
   qZzGsIxVP+sEVRWZmW6KNFSdVUpk3qzK0Tz/WjQMe5z0UunY9Ax9/4PVhp/j61bf
   eAYXunajbBSOLlx4D+TunwJBANkPI5S9iylsbLs6NkaMHV6k5ioHBBmgCak95JGX
   GMot/L2x0IYyMLAz6oLWh2hm7zwtb0CgOrPo1ke44hFYnfc=
   -----END RSA PRIVATE KEY-----
```

개인 키에서 공개 키 구성 요소를 추출하려면 다음과 같이 openssl을 사용하십시오.

```text
   $ openssl rsa -in rsa.private -out rsa.public -pubout -outform PEM
```

그러면 다음과 유사한 주요 정보가 포함된 rsa.public 파일이 생성됩니다.

```text
   -----BEGIN PUBLIC KEY-----
   MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkM
   oGeLnQg1fWn7/zYtIxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/R
   tdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToI
   MmPSPDdQPNUYckcQ2QIDAQAB
   -----END PUBLIC KEY-----
```

이 공개 키 데이터\(BEGIN 및 END 태그 제외\)는 DNS에 배치됩니다.

```text
   $ORIGIN _domainkey.example.org.
   brisbane IN  TXT  ("v=DKIM1; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQ"
                      "KBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYt"
                      "IxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v"
                      "/RtdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhi"
                      "tdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB")
```

---
### **C.1.  Compatibility with DomainKeys Key Records**

DKIM 키 레코드는 DomainKeys \[RFC4870\]에서 사용되는 키 레코드\(DomainKeys 컨텍스트에서는 "선택기 레코드"라고도 함\)와 많은 경우 이전 버전과 호환되도록 설계되었습니다. 한 가지 비호환성 영역에는 특별한 주의가 필요합니다. "g=" 태그 값은 DomainKeys 및 \[RFC4871\] 키 레코드에서 사용되어 다음을 제공할 수 있습니다.

특정 로컬 부분에 대한 키 레코드의 유효성을 보다 세밀하게 세분화합니다. DomainKeys의 null "g=" 값은 도메인의 모든 주소에 유효합니다. 이는 null "g=" 값이 모든 주소에 유효하지 않은 원래 DKIM 사양\(\[RFC4871\]\)의 사용법과 다릅니다. 특히 \[RFC4870\]의 섹션 3.2.3에 있는 공개 키 레코드 예시를 참조하세요.

---
### **C.2.  RFC 4871 Compatibility**

"g=" 태그는 이 버전의 DKIM 사양에서 더 이상 사용되지 않지만\(따라서 이제 무시해야 함\) 일부 \[RFC4871\] 호환 확인자는 키 레코드에 "g=" 태그를 포함하지 않는 것이 좋습니다. 앞으로 상당한 기간 동안 사용할 수 있습니다.\(MUST\)

---
# **Appendix D.  MUA Considerations (INFORMATIVE)**

DKIM 서명이 확인되면 처리 시스템에서 수신자 사용자의 MUA에 결과를 제공하는 경우가 있습니다. 사용자에게 도움이 되는 방식으로 이 정보를 제공하는 방법은 지속적인 인적 요소 사용성 연구의 문제입니다. 메시지에 대한 책임을 주장하는 신원을 사용자에게 보여주기 위해 MUA가 SDID를 강조 표시하도록 하는 경향이 있습니다. MUA는 그래픽과 같은 시각적 신호를 사용하여 이 작업을 수행할 수도 있고, 대체 보기에 주소를 포함할 수도 있으며, 확인된 정보를 사용하여 원본 보낸 사람 주소를 다시 쓸 수도 있습니다. 일부 MUA는 검증된 DKIM 서명으로 보호되는 헤더 필드를 나타낼 수 있습니다. 서명되지 않은 헤더 필드를 시각적으로 숨기거나 이들의 일부 조합을 통해 서명된 헤더 필드에 대한 긍정적인 표시, 서명되지 않은 헤더 필드에 대한 부정적인 표시를 사용하여 이를 수행할 수 있습니다. MUA가 서명된 헤더 필드에 대한 시각적 표시를 사용하는 경우 MUA는 최종 사용자가 서명된 것으로 해석할 수 있는 방식으로 서명되지 않은 헤더 필드를 표시하지 않도록 주의해야 할 것입니다. 메시지에 값이 메시지 끝까지 확장되지 않는 "l=" 태그가 있는 경우 MUA는 서명되지 않은 메시지 본문 부분을 숨기거나 표시할 수도 있습니다.

앞서 언급한 정보는 완전한 정보를 제공하기 위한 것이 아닙니다. MUA는 MUA 작성자의 의견에 따라 최종 사용자에게 중요하다고 간주될 수 있는 기타 정보를 강조하거나, 강조하거나, 숨기거나, 표시하도록 선택할 수 있습니다.

---
# **Appendix E.  Changes since RFC 4871**

o 축적된 경험을 바탕으로 초록과 서문을 다듬었습니다.

```text
   o  Various references updated.

   o  Several errata resolved (see http://www.rfc-editor.org/):

      *  1376 applied

      *  1377 applied

      *  1378 applied

      *  1379 applied

      *  1380 applied

      *  1381 applied

      *  1382 applied

      *  1383 discarded (no longer applies)

      *  1384 applied

      *  1386 applied

      *  1461 applied

      *  1487 applied

      *  1532 applied

      *  1596 applied

   o  Introductory section enumerating relevant architectural documents
      added.
```

o 데이터 무결성 문제를 간략하게 설명하는 소개 섹션이 추가되었습니다.

o 일부 클럭 드리프트에 대한 허용 오차가 허용됩니다.

o 주요 기록에서 "g=" 태그를 삭제했습니다. 구현 보고서에는 사용되지 않는 것으로 나타납니다.

o DNS의 와일드카드에 대한 잘못된 메모를 제거했습니다.

o 대부분의 장소에서 SMTP 관련 조언을 제거했습니다.

o 권장되는\(비표준적인\) 서명 콘텐츠 목록을 줄이고 해당 섹션의 텍스트를 재작업했습니다.

o 의사 코드를 다시 작성하여 서명 생성 알고리즘을 명확하게 했습니다.

o \[RFC5672\]에서 가져온 다양한 용어 하위 섹션이 추가되었습니다. 또한 문서 전체에서 이러한 용어\(예: SDID, AUID\)를 사용하기 시작했습니다.

o 입력 및 출력 요구 사항을 지정하는 섹션이 추가되었습니다. 입력 요구 사항은 작업 그룹에서 제기한 보안 문제를 해결합니다\(보안 고려 사항의 새 섹션 참조\). 출력 요구 사항은 \[RFC5672\]에서 가져옵니다.

o DomainKeys\(\[RFC4870\]\) 레코드와의 호환성을 논의하는 부록 하위 섹션이 추가되었습니다.

o DKIM 검증 결과를 전달하는 방법의 예시로 \[RFC5451\]을 참조하세요.

o "l=" 서명 태그의 가능한 사용에 대한 조언을 제거했습니다.

```text
   o  IANA registry updated.
```

o 잘못된 메시지 공격에 대해 설명하는 두 개의 새로운 보안 고려 사항 섹션을 추가했습니다.

```text
   o  Various copy editing.
```

---
# **Appendix F.  Acknowledgments**

DKIM의 이전 IETF 버전 \[RFC4871\]은 Eric Allman, Jon Callas, Mark Delany, Miles Libbey, Jim Fenton 및 Michael Thomas가 편집했습니다.

해당 사양은 Russ Allbery, Edwin Aoki, Claus Assmann, Steve Atkins, Rob Austein, Fred Baker, Mark Baugher, Steve Bellovin, Nathaniel Borenstein, Dave Crocker, Michael Cudahy, Dennis Dayman, Jutta Degener, Frank Ellermann, Patrik Faeltstroem, Mark Fanto, Stephen Farrell, Duncan Findlay, Elliot Gillum, Olafur Gudmundsson, Phillip Hallam-Baker, Tony Hansen, Sam Hartman, Arvel Hathcock, Amir Herzberg, Paul Hoffman, Russ Housley, Craig Hughes, 컬렌 제닝스, 돈 존슨, 해리 카츠, 머레이 S. 쿠체로위, 배리 레이바, 존 레빈, 찰스 린지, 사이먼 롱스데일, 데이비드 마그레이브, 저스틴 메이슨, 데이비드 메인, 티에리 모로, 스티브 머피, 러셀 넬슨, 데이브 오란, 더그 오티스, 샤밈 피르자다, 후안 알트마이어 피조르노, 산제이 폴, 블레이크 램스델, 크리스티안 르노, 스콧 렌프로, 닐

Rerup, Eric Rescorla, Dave Rossetti, Hector Santos, Jim Schaad, Spamhaus.org 팀, Malte S. Stretz, Robert Sanders, Rand Wacker, Sam Weiler 및 Dan Wing.

이전 DomainKeys는 DKIM이 파생된 기본 소스였습니다. DomainKeys에 대한 자세한 내용은 \[RFC4870\]에 있습니다.

이 개정판은 Steve Atkins, Mark Delany, J.D. Falk, Jim Fenton, Michael Hammer, Barry Leiba, John Levine, Charles Lindsey, Jeff Macdonald, Franck Martin, Brett McDowell, Doug Otis, Bill Oxley, Hector Santos, Rolf Sonneveld, 마이클 토마스, 알레산드로 베슬리.

---
# **Authors' Addresses**

```text
   Dave Crocker (editor)
   Brandenburg InternetWorking
   675 Spruce Dr.
   Sunnyvale, CA  94086
   USA

   Phone: +1.408.246.8253
   EMail: dcrocker@bbiw.net
   URI:   http://bbiw.net

   Tony Hansen (editor)
   AT&T Laboratories
   200 Laurel Ave. South
   Middletown, NJ  07748
   USA

   EMail: tony+dkimsig@maillennium.att.com

   Murray S. Kucherawy (editor)
   Cloudmark
   128 King St., 2nd Floor
   San Francisco, CA  94107
   USA

   EMail: msk@cloudmark.com
```


```text
Internet Engineering Task Force (IETF)                         D. McGrew
Request for Comments: 6090                                 Cisco Systems
Category: Informational                                          K. Igoe
ISSN: 2070-1721                                                M. Salter
                                                National Security Agency
                                                           February 2011

           Fundamental Elliptic Curve Cryptography Algorithms
```

---
# **Abstract**

이 노트에서는 1994년 이전의 일부 주요 참고 자료에 정의된 타원 곡선 암호화\(ECC\)의 기본 알고리즘을 설명합니다. 이러한 설명은 다음 해에 개발된 특수 방법을 사용하지 않고 기본 알고리즘을 구현하는 데 유용할 수 있습니다. 3보다 큰 특성 필드에 대해 정의된 타원 곡선만 범위에 포함됩니다. 이 곡선은 Suite B에서 사용되는 곡선입니다.

---
# **Status of This Memo**

이 문서는 인터넷 표준 트랙 사양이 아닙니다. 정보 제공의 목적으로 게시됩니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. IESG가 승인한 모든 문서가 모든 수준의 인터넷 표준에 적합한 것은 아닙니다. RFC 5741의 섹션 2를 참조하세요.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc6090에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2011 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Conventions Used in This Document  . . . . . . . . . . . .  4
   2.  Mathematical Background  . . . . . . . . . . . . . . . . . . .  4
     2.1.  Modular Arithmetic . . . . . . . . . . . . . . . . . . . .  4
     2.2.  Group Operations . . . . . . . . . . . . . . . . . . . . .  5
     2.3.  The Finite Field Fp  . . . . . . . . . . . . . . . . . . .  6
   3.  Elliptic Curve Groups  . . . . . . . . . . . . . . . . . . . .  7
     3.1.  Homogeneous Coordinates  . . . . . . . . . . . . . . . . .  8
     3.2.  Other Coordinates  . . . . . . . . . . . . . . . . . . . .  9
     3.3.  ECC Parameters . . . . . . . . . . . . . . . . . . . . . .  9
       3.3.1.  Discriminant . . . . . . . . . . . . . . . . . . . . . 10
       3.3.2.  Security . . . . . . . . . . . . . . . . . . . . . . . 10
   4.  Elliptic Curve Diffie-Hellman (ECDH) . . . . . . . . . . . . . 10
     4.1.  Data Types . . . . . . . . . . . . . . . . . . . . . . . . 11
     4.2.  Compact Representation . . . . . . . . . . . . . . . . . . 11
   5.  Elliptic Curve ElGamal Signatures  . . . . . . . . . . . . . . 11
     5.1.  Background . . . . . . . . . . . . . . . . . . . . . . . . 11
     5.2.  Hash Functions . . . . . . . . . . . . . . . . . . . . . . 12
     5.3.  KT-IV Signatures . . . . . . . . . . . . . . . . . . . . . 12
       5.3.1.  Keypair Generation . . . . . . . . . . . . . . . . . . 12
       5.3.2.  Signature Creation . . . . . . . . . . . . . . . . . . 13
       5.3.3.  Signature Verification . . . . . . . . . . . . . . . . 13
     5.4.  KT-I Signatures  . . . . . . . . . . . . . . . . . . . . . 14
       5.4.1.  Keypair Generation . . . . . . . . . . . . . . . . . . 14
       5.4.2.  Signature Creation . . . . . . . . . . . . . . . . . . 14
       5.4.3.  Signature Verification . . . . . . . . . . . . . . . . 14
     5.5.  Converting KT-IV Signatures to KT-I Signatures . . . . . . 15
     5.6.  Rationale  . . . . . . . . . . . . . . . . . . . . . . . . 15
   6.  Converting between Integers and Octet Strings  . . . . . . . . 16
     6.1.  Octet-String-to-Integer Conversion . . . . . . . . . . . . 17
     6.2.  Integer-to-Octet-String Conversion . . . . . . . . . . . . 17
   7.  Interoperability . . . . . . . . . . . . . . . . . . . . . . . 17
     7.1.  ECDH . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
     7.2.  KT-I and ECDSA . . . . . . . . . . . . . . . . . . . . . . 18
   8.  Validating an Implementation . . . . . . . . . . . . . . . . . 18
     8.1.  ECDH . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
     8.2.  KT-I . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
   9.  Intellectual Property  . . . . . . . . . . . . . . . . . . . . 20
     9.1.  Disclaimer . . . . . . . . . . . . . . . . . . . . . . . . 20
   10. Security Considerations  . . . . . . . . . . . . . . . . . . . 21
     10.1. Subgroups  . . . . . . . . . . . . . . . . . . . . . . . . 21
     10.2. Diffie-Hellman . . . . . . . . . . . . . . . . . . . . . . 22
     10.3. Group Representation and Security  . . . . . . . . . . . . 22
     10.4. Signatures . . . . . . . . . . . . . . . . . . . . . . . . 23
   11. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 23
   12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 23
     12.1. Normative References . . . . . . . . . . . . . . . . . . . 23
     12.2. Informative References . . . . . . . . . . . . . . . . . . 25
   Appendix A.  Key Words . . . . . . . . . . . . . . . . . . . . . . 29
   Appendix B.  Random Integer Generation . . . . . . . . . . . . . . 29
   Appendix C.  Why Compact Representation Works  . . . . . . . . . . 30
   Appendix D.  Example ECC Parameter Set . . . . . . . . . . . . . . 31
   Appendix E.  Additive and Multiplicative Notation  . . . . . . . . 32
   Appendix F.  Algorithms  . . . . . . . . . . . . . . . . . . . . . 32
     F.1.  Affine Coordinates . . . . . . . . . . . . . . . . . . . . 32
     F.2.  Homogeneous Coordinates  . . . . . . . . . . . . . . . . . 33
```

---
## **1.  Introduction**

ECC는 더 높은 보안 수준에서 성능 이점을 제공하는 공개 키 기술입니다. 여기에는 Diffie-Hellman 키 교환 프로토콜 \[DH1976\]의 타원 곡선 버전과 ElGamal 서명 알고리즘 \[E1985\]의 타원 곡선 버전이 포함됩니다. ECC의 채택은 예상했던 것보다 더디게 진행되었습니다. 아마도 자유롭게 사용할 수 있는 규범 문서가 부족하고 지적 재산권에 대한 불확실성 때문일 것입니다.

이 노트에는 원본 참조 자료를 직접 기반으로 특성이 3보다 큰 유한 필드에 대한 ECC의 기본 알고리즘에 대한 설명이 포함되어 있습니다. 그 목적은 전문화되거나 최적화된 알고리즘보다 앞서는 기본 알고리즘의 요약을 인터넷 커뮤니티에 제공하는 것입니다. 요약은 규범적인 참고 자료로 사용할 수 있을 만큼 상세합니다. 원래의 설명과 표기법을 최대한 그대로 따랐습니다.

IKE\(인터넷 키 교환\), ANSI X9.62 및 IEEE P1363을 포함하여 ECC 알고리즘을 지정하거나 통합하는 여러 표준이 있습니다. 이 노트의 알고리즘은 다음과 상호 운용될 수 있습니다.

매개변수와 옵션을 적절하게 선택하여 이러한 표준의 일부 알고리즘을 사용할 수 있습니다. 구체적인 내용은 7절에 나와 있습니다.

노트의 나머지 부분은 다음과 같이 구성됩니다. 섹션 2.1, 2.2, 2.3은 각각 모듈러 산술, 그룹 이론, 유한장 이론에서 필요한 용어와 표기법을 제공합니다. 섹션 3에서는 3보다 큰 특성을 갖는 유한 필드에 대한 타원 곡선을 기반으로 그룹을 정의합니다. 섹션 4에서는 기본적인 ECDH\(Elliptic Curve Diffie-Hellman\) 알고리즘을 제시합니다. 섹션 5에서는 ElGamal 서명 방법의 타원 곡선 버전을 제시합니다. 옥텟 문자열로 정수를 표현하는 방법은 섹션 6에 명시되어 있습니다. 섹션 2부터 6까지에는 모든 규범 텍스트\(이 사양을 준수하는 구현에 대한 표준을 정의하는 텍스트\)가 포함되어 있으며 다음 섹션은 모두 정보 제공용입니다. . 상호 운용성은 섹션 7에서 논의됩니다. 검증 테스트는 섹션 8에서 설명됩니다. 섹션 9에서는 지적 재산 문제를 검토합니다. 섹션 10에는 보안 고려 사항이 요약되어 있습니다. 부록 B에서는 난수 생성에 대해 설명하고 기타 부록에서는 명확한 세부 정보를 제공합니다.

---
### **1.1.  Conventions Used in This Document**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. 부록 A에 설명된 대로 해석됩니다.

---
## **2.  Mathematical Background**

이 섹션에서는 수학적 예비 사항을 검토하고 아래에서 사용되는 용어와 표기법을 설정합니다.

---
### **2.1.  Modular Arithmetic**

이 섹션에서는 모듈러 연산을 검토합니다. 두 정수 x와 y는 x - y가 n의 정수 배수이면 모듈로 n이 합동이라고 합니다.

두 정수 x와 y는 최대 공약수가 1일 때 서로소입니다. 이 경우 z가 x를 나누고 z가 y를 나누는 세 번째 숫자 z \> 1은 없습니다.

집합 Zq = {0, 1, 2, ..., q-1 }은 모듈러 덧셈, 모듈러 뺄셈, 모듈러 곱셈 및 모듈러 역의 연산에서 닫혀 있습니다. 이러한 작업은 다음과 같습니다.

- Zq의 각 정수 a와 b 쌍에 대해 a + b mod q는 a + b < q이면 a + b와 같고, 그렇지 않으면 a + b - q와 같습니다.

- Zq의 각 정수 a 및 b 쌍에 대해 a - b mod q는 a - b \>= 0인 경우 a - b와 같고, 그렇지 않은 경우 a - b + q와 같습니다.

- Zq의 각 정수 a와 b 쌍에 대해 a \* b mod q는 a \* b를 q로 나눈 나머지와 같습니다.

- q와 서로소인 Zq의 각 정수 x에 대해 x 모듈로 q의 역수는 1/x mod q로 표시되고 확장된 유클리드 알고리즘을 사용하여 계산될 수 있습니다\(예를 들어 \[K1981v2\]의 섹션 4.5.2 참조\). \).

이러한 작업에 대한 알고리즘은 잘 알려져 있습니다. 예를 들어 \[K1981v2\]의 4장을 참조하세요.

---
### **2.2.  Group Operations**

이 섹션에서는 나중에 필요한 수학적 그룹에 대한 몇 가지 용어와 표기법을 설정합니다. 배경 참조가 풍부합니다. 예를 들어 \[D1966\]을 참조하세요.

그룹은 G의 임의의 두 요소를 결합하고 G의 세 번째 요소를 반환하는 연산과 함께 요소 G의 집합입니다. 연산은 \*로 표시되고 그 적용은 임의의 두 요소 a와 b에 대해 a \* b로 표시됩니다. G의 연산은 결합적입니다. 즉, G의 모든 a, b, c에 대해 a \* \(b \* c\)는 \(a \* b\) \* c와 동일합니다. 그룹 연산을 요소 a에 N-1회 반복 적용하는 것은 G의 요소 a와 양의 정수 N에 대해 a^N으로 표시됩니다. 즉, a^2 = a \* a, a^3 = a \* a \* a 등. 그룹 연산의 연관성은 a^n의 계산이 명확함을 보장합니다. 용어를 그룹화하면 동일한 결과가 나타납니다.

위의 그룹 연산 정의는 곱셈 표기법을 사용합니다. 때로는 a \* b를 a + b로 표시하고 a^N을 N \* a로 표시하는 덧셈 표기법이라는 대안이 사용되는 경우도 있습니다. 곱셈 표기법에서 a^N을 지수화라고 하고, 덧셈 표기법에서 동등한 연산을 스칼라 곱셈이라고 합니다. 이 문서에서는 일관성을 위해 전체적으로 곱셈 표기법을 사용합니다. 부록 E에서는 두 표기법 간의 대응 관계를 설명합니다.

모든 그룹에는 정체성 요소\(identity element\)라는 특별한 요소가 있으며, 이를 e로 표시합니다. G의 각 요소 a에 대해 e \* a = a \* e = a입니다. 관례적으로 a^0은 G의 모든 a에 대한 항등 요소와 같습니다.

모든 그룹 요소 a에는 a \* b = b \* a = e가 되는 고유한 역 요소 b가 있습니다. a의 역수는 곱셈 표기법에서 a^-1로 표시됩니다. \(덧셈 표기법에서 a의 역수는 -a로 표시됩니다.\)

임의의 양의 정수 X에 대해 a^\(-X\)는 \(a^-1\)^\(X\)로 정의됩니다. 이 규칙을 사용하면 지수화는 예상대로, 즉 모든 정수 X 및 Y에 대해 동작합니다.

```text
      a^(X+Y) = (a^X)*(a^Y)

      (a^X)^Y = a^(XY) = (a^Y)^X.
```

암호화 응용에서는 일반적으로 유한 그룹\(유한한 수의 요소가 있는 그룹\)을 다루고, 이러한 그룹의 경우 그룹의 요소 수를 그룹 순서라고도 합니다. 그룹 요소 a는 양의 정수 X에 대해 a^X = e인 경우 유한 순서를 갖는다고 하며, a의 차수는 X와 같은 가장 작은 차수입니다. 그러한 X가 존재하지 않으면 a는 무한 차수를 갖는다고 합니다. 유한군의 모든 요소는 유한한 순서를 가지며, 요소의 순서는 항상 그룹 순서의 제수입니다.

그룹 요소 a가 R 차수를 갖는 경우 임의의 정수 X 및 Y에 대해

```text
      a^X = a^(X mod R),
```

- a^X = a^Y X가 Y mod R과 합동인 경우에만,

- 집합 H = { a, a^2, a^3, ... , a^R=e }는 a에 의해 생성된 순환 하위 그룹이라고 불리는 G의 하위 그룹을 형성하고, a는 H의 생성자라고 합니다. .

일반적으로 H를 생성하는 여러 그룹 요소가 있습니다. M이 R에 상대적으로 소수인 a^M 형식의 모든 그룹 요소도 H를 생성합니다. 임의의 비에 대해 a^M은 g^\(M 모듈로 R\)과 같습니다. - 음의 정수 M.

R 차의 요소 a와 1과 R-1 사이의 정수 i가 주어지면 요소 a^i는 \[M1983\]의 섹션 2.1에 설명된 "제곱 및 곱하기" 방법으로 계산할 수 있습니다\(Knuth, Vol.2, 섹션 4.6.3\) 또는 기타 방법.

---
### **2.3.  The Finite Field Fp**

이 섹션에서는 소수 특성을 갖는 유한 필드에 대한 용어 및 표기법을 설정합니다.

p가 소수인 경우 집합 Zp는 덧셈, 뺄셈, 곱셈, 나눗셈 연산을 통해 특성 p를 갖는 유한체입니다. Zp의 0이 아닌 각 요소 x는 역 1/x를 갖습니다. 0과 p-1 사이의 정수와 필드 요소 사이에는 일대일 대응이 있습니다. 필드 Zp는 때때로 Fp 또는 GF\(p\)로 표시됩니다.

필드 요소와 관련된 방정식은 "mod p" 연산을 명시적으로 나타내지는 않지만 암시적인 것으로 이해됩니다. 예를 들어, x, y, z가 Fp에 있고

```text
      z = x + y
```

x, y, z가 집합 {0, 1, ..., p-1 }에 있다는 진술과 동일합니다.

```text
      z = x + y mod p.
```

---
## **3.  Elliptic Curve Groups**

이 노트는 특성이 3보다 큰 필드에 대한 타원 곡선만 다룹니다. 이는 Suite B \[SuiteB\]에서 사용되는 곡선입니다. 다른 필드의 경우 타원 곡선 그룹의 정의가 다릅니다.

필드 Fp 위의 타원 곡선은 곡선 방정식으로 정의됩니다.

```text
      y^2 = x^3 + a*x + b,
```

여기서 x, y, a 및 b는 필드 Fp \[M1985\]의 요소이고 판별식은 0이 아닙니다\(섹션 3.3.1에 설명된 대로\). 타원 곡선 위의 점은 곡선 방정식을 만족하는 Fp 값의 쌍\(x,y\)이거나 항등 요소를 나타내는 특수 점\(@,@\)입니다\(이를 "무한대 점"이라고 함\). \). 타원 곡선 그룹의 순서는 개별 점의 개수입니다.

두 개의 타원 곡선 점 \(x1,y1\) 및 \(x2,y2\)는 x1=x2 및 y1=y2일 때마다 또는 두 점이 무한대에 있는 점일 때 동일합니다. 점 \(x1,y1\)의 역수는 점 \(x1,-y1\)입니다. 무한대의 점은 그 자체가 역수입니다.

타원곡선 그룹과 관련된 그룹 연산은 다음과 같다\[BC1989\]. 각각 좌표 \(x1,y1\) 및 \(x2,y2\)로 지정된 임의의 점 P 및 Q 쌍에 그룹 작업은 좌표 \(x3,y3\)를 사용하여 세 번째 점 P\*Q를 할당합니다. 이러한 좌표는 다음과 같이 계산됩니다.

- \(x3,y3\) = \(@,@\) P가 Q와 같지 않고 x1이 x2와 같을 때.

- x3 = \(\(y2-y1\)/\(x2-x1\)\)^2 - x1 - x2 및 y3 = \(x1-x3\)\*\(y2-y1\)/\(x2-x1\) - P가 다음과 같지 않은 경우 y1 Q와 x1은 x2와 같지 않습니다.

- \(x3,y3\) = \(@,@\) P가 Q와 같고 y1이 0일 때.

- x3 = \(\(3\*x1^2 + a\)/\(2\*y1\)\)^2 - 2\*x1 및 y3 = \(x1-x3\)\*\(3\*x1^2 + a\)/\(2\*y1\) - P가 Q와 같고 y1이 0이 아닌 경우 y1입니다.

위 방정식에서 a, x1, x2, x3, y1, y2 및 y3은 필드 Fp의 요소입니다. 따라서 실제로 x3과 y3의 계산은 우변 모듈로 p를 줄여야 합니다. 그룹 연산을 위한 의사 코드는 부록 F.1에 나와 있습니다.

Zp에서 정수 쌍으로 타원 곡선 점을 표현하는 것을 아핀 좌표 표현이라고 합니다. 이 표현은 그룹 요소를 전달하거나 저장하기 위한 외부 데이터 표현으로 적합하지만 무한대의 지점은 특별한 경우로 처리되어야 합니다.

일부 정수 쌍은 유효한 타원 곡선 점이 아닙니다. 유효한 쌍은 곡선 방정식을 만족하지만 유효하지 않은 쌍은 그렇지 않습니다.

---
### **3.1.  Homogeneous Coordinates**

그룹 연산을 구현하는 또 다른 방법은 동차 좌표를 사용하는 것입니다 \[K1987\]\(\[KMOV1991\] 참조\). 이 방법은 모듈식 반전 작업이 필요하지 않기 때문에 일반적으로 더 효율적입니다.

타원 곡선 점 \(x,y\)\(무한대 점\(@,@\) 제외\)은 x=X/Z mod p 및 y=Y/일 때 동차 좌표의 점\(X,Y,Z\)과 동일합니다. Z 모드 p.

P1=\(X1,Y1,Z1\) 및 P2=\(X2,Y2,Z2\)를 타원 곡선의 점으로 두고 점 P1과 P2가 \(@,@\)와 같지 않고 P1이 같지 않다고 가정합니다. P2, P1은 P2^-1과 동일하지 않습니다. 그러면 곱 P3=\(X3,Y3,Z3\) = P1 \* P2는 다음과 같이 주어집니다.

```text
      X3 = v * (Z2 * (Z1 * u^2 - 2 * X1 * v^2) - v^3) mod p

      Y3 = Z2 * (3 * X1 * u * v^2 - Y1 * v^3 - Z1 * u^3) + u * v^3 mod p

      Z3 = v^3 * Z1 * Z2 mod p
```

여기서 u = Y2 \* Z1 - Y1 \* Z2 mod p 및 v = X2 \* Z1 - X1 \* Z2 mod p입니다.

점 P1과 P2가 같을 때 \(X1/Z1, Y1/Z1\)은 \(X2/Z2, Y2/Z2\)와 같습니다. 이는 u와 v가 모두 0인 경우에만 참입니다.

곱 P3=\(X3,Y3,Z3\) = P1 \* P1은 다음과 같이 계산됩니다.

```text
      X3 = 2 * Y1 * Z1 * (w^2 - 8 * X1 * Y1^2 * Z1) mod p

      Y3 = 4 * Y1^2 * Z1 * (3 * w * X1 - 2 * Y1^2 * Z1) - w^3 mod p

      Z3 = 8 * (Y1 * Z1)^3 mod p
```

여기서 w = 3 \* X1^2 + a \* Z1^2 mod p입니다. 위의 방정식에서 a, u, v, w, X1, X2, X3, Y1, Y2, Y3, Z1, Z2 및 Z3은 집합 Fp의 정수입니다. 동차 좌표계에서의 그룹 연산을 위한 의사 코드는 부록 F.2에 나와 있습니다.

아핀 좌표에서 동차 좌표로 변환할 때는 Z를 1로 설정하는 것이 편리합니다. 동차 좌표에서 아핀 좌표로 변환할 때는 1/Z mod p를 구하기 위해 모듈러 역을 수행해야 합니다.

---
### **3.2.  Other Coordinates**

일부 다른 좌표계가 설명되었습니다. Jacobi 좌표를 포함하여 여러 가지가 \[CC1986\]에 문서화되어 있습니다.

---
### **3.3.  ECC Parameters**

암호화 컨텍스트에서 타원 곡선 매개변수 세트는 타원 곡선의 순환 하위 그룹과 해당 하위 그룹의 기본 생성기로 구성됩니다. 특성이 3보다 큰 소수 유한 필드에 대해 작업할 때 타원 곡선 그룹은 다음 매개변수로 완전히 지정됩니다.

- 필드 Fp의 순서를 나타내는 소수 p입니다.

- 곡선 방정식에 사용되는 값입니다.

- 곡선 방정식에 사용되는 값 b.

- 하위 그룹의 생성기 g.

- g에 의해 생성된 하위 그룹의 차수 n입니다.

ECC 매개변수 세트의 예는 부록 D에 나와 있습니다.

매개변수 생성은 이 노트의 범위를 벗어납니다.

각 타원 곡선 점은 특정 매개변수 세트와 연관되어 있습니다. 타원 곡선 그룹 작업은 동일한 그룹의 두 점 사이에서만 정의됩니다. 그룹을 적용하는 중 오류가 발생했습니다.

다른 그룹에 속한 두 요소에 대한 연산을 수행하거나 유효한 점이 아닌 좌표 쌍에 그룹 연산을 적용합니다. \(Fp의 좌표 쌍 \(x,y\)는 곡선 방정식을 만족할 때만 유효한 점입니다.\) 자세한 내용은 섹션 10.3을 참조하십시오.

---
#### **3.3.1.  Discriminant**

각 타원 곡선 그룹에 대해 판별식 -16\*\(4\*a^3 + 27\*b^2\)는 모듈로 p에 대해 0이 아닌 값이어야 합니다\[S1986\]. 이것은 다음을 요구한다

```text
      4*a^3 + 27*b^2 != 0 mod p.
```

---
#### **3.3.2.  Security**

보안은 이러한 매개변수의 선택에 따라 크게 달라집니다. 이 섹션에서는 허용 가능한 선택에 대한 규범적인 지침을 제공합니다. 유익한 지침은 섹션 10을 참조하세요.

g에 의해 생성된 그룹의 차수는 이산 로그 문제 \[K1987\]의 쉬운 해법을 배제하기 위해 큰 소수로 나누어져야 합니다.

일부 매개변수를 선택하면 이산 로그 문제를 훨씬 더 쉽게 해결할 수 있습니다. 여기에는 b = 0 및 p = 3\(mod 4\)인 매개변수 세트와 a = 0 및 p = 2\(mod 3\)인 매개변수 세트가 포함됩니다\[MOV1993\]. 이러한 매개변수 선택은 암호화 목적에 적합하지 않으며 사용해서는 안 됩니다.

---
## **4.  Elliptic Curve Diffie-Hellman (ECDH)**

DH\(Diffie-Hellman\) 키 교환 프로토콜 \[DH1976\]을 사용하면 안전하지 않은 채널을 통해 통신하는 두 당사자가 비밀 키에 동의할 수 있습니다. 이는 원래 큰 소수 특성을 갖는 필드의 곱셈 그룹의 연산 측면에서 정의되었습니다. Massey \[M1983\]는 이것이 임의의 순환 그룹의 관점에서 정의되도록 쉽게 일반화될 수 있음을 관찰했습니다. Miller \[M1985\]와 Koblitz \[K1987\]는 타원 곡선 그룹에 대한 DH 프로토콜을 분석했습니다. 우리는 이전 참조에 따라 DH를 설명합니다.

G를 그룹으로, g를 해당 그룹의 생성자로 두고, t를 G의 순서로 나타냅니다. DH 프로토콜은 다음과 같이 실행됩니다. 당사자 A는 1과 t-1 사이에서 균일하게 무작위로 지수 j를 선택하고 g^j를 계산한 후 해당 요소를 B로 보냅니다. 당사자 B는 1과 t-1 사이에서 균일하게 무작위로 지수 k를 선택합니다. g^k를 계산하고 해당 요소를 A로 보냅니다. 각 당사자는 g^\(j\*k\)를 계산할 수 있습니다. 당사자 A는 \(g^k\)^j를 계산하고, 당사자 B는 \(g^j\)^k를 계산합니다.

난수 생성에 대해서는 부록 B를 참조하세요.

---
### **4.1.  Data Types**

ECDH 프로토콜의 각 실행은 특정 매개변수 세트\(섹션 3.3에 정의됨\)와 연관되어 있으며 공개 키 g^j 및 g^k와 공유 비밀 g^\(j\*k\)는 연관된 순환 하위 그룹의 요소입니다. 매개변수 세트로.

ECDH 개인 키 z는 Zt의 정수입니다. 여기서 t는 하위 그룹의 순서입니다.

---
### **4.2.  Compact Representation**

\[M1985\]의 마지막 단락에 설명된 대로, 공유 비밀 값 g^\(j\*k\)의 x 좌표는 지수화가 단방향 함수로 사용될 때마다 전체 점에 대한 적절한 표현입니다. ECDH 키 교환 프로토콜에서는 g^\(j\*k\) 요소가 계산된 후 해당 값의 x 좌표를 공유 비밀로 사용할 수 있습니다. 우리는 이것을 컴팩트 출력이라고 부릅니다.

다시 \[M1985\]에 이어 ECDH에서 컴팩트 출력을 사용할 때 일반적인 아핀 좌표 표현에서처럼 두 좌표를 모두 전송하는 대신 타원 곡선 점의 x 좌표만 전송하면 됩니다. 우리는 이것을 컴팩트 표현이라고 부릅니다. 수학적 배경은 부록 C에 설명되어 있습니다.

ECDH는 컴팩트 출력 유무에 관계없이 사용할 수 있습니다. ECDH 프로토콜의 특정 실행에 참여하는 양 당사자는 반드시 동일한 방법을 사용해야 합니다. ECDH는 압축 표현을 사용하거나 사용하지 않고 사용할 수 있습니다. ECDH 프로토콜의 특정 실행에서 압축 표현이 사용되는 경우 압축 출력도 사용해야 합니다.

---
## **5.  Elliptic Curve ElGamal Signatures**
---
### **5.1.  Background**

ElGamal 서명 알고리즘은 1984년 \[E1984a\] \[E1984b\] \[E1985\]에 도입되었습니다. 이는 이산 로그 문제를 기반으로 하며 원래 큰 소수 모듈로 정수의 곱셈 그룹에 대해 정의되었습니다. 유한체 GF\(2^w\) \[AMV1990\] 또는 타원 곡선 그룹 \[A1992\]의 곱셈 그룹과 같은 다른 유한 그룹을 사용하도록 확장하는 것은 간단합니다.

ElGamal 서명은 한 쌍의 구성 요소로 구성됩니다. 두 번째 구성 요소에 대한 방정식을 다르게 재배열하여 얻은 ElGamal 서명 방법에는 여러 가지 가능한 일반화가 있습니다. \[HMP1994\], \[HP1994\], \[NR1994\], \[A1992\] 및

\[AMV1990\]. 이러한 일반화는 사용된 수학적 그룹과 무관하며 소수 모듈로의 곱셈 그룹, GF\(2^w\)의 곱셈 그룹 및 타원 곡선 그룹에 대해 설명되었습니다. \[HMP1994\] \[NR1994\] \[AMV1990\] \[A1992\] .

디지털 서명 알고리즘\(DSA\) \[FIPS186\]은 중요한 ElGamal 서명 변형입니다.

---
### **5.2.  Hash Functions**

ElGamal 서명은 충돌 방지 해시 함수를 사용해야 임의 길이의 메시지에 서명할 수 있고 존재 위조 공격을 피할 수 있습니다. 섹션 10.4를 참조하세요. \(이것은 모든 ElGamal 변형\[HMP1994\]에 해당됩니다.\) 우리는 해시 함수를 h\(\)로 나타냅니다. 입력은 임의 길이의 비트 문자열이고 출력은 음수가 아닌 정수입니다.

H\(\)는 출력이 고정 길이 비트 문자열인 해시 함수를 나타냅니다. ElGamal 서명 방법에서 H를 사용하기 위해 해당 출력과 음수가 아닌 정수 간의 매핑을 정의합니다. 이는 위에서 설명한 함수 h\(\)를 실현합니다. 비트 문자열 m이 주어지면 함수 h\(m\)은 다음과 같이 계산됩니다.

1. H\(m\)이 평가됩니다. 결과는 고정 길이 비트 문자열입니다.

1. 가장 왼쪽\(초기\) 비트를 i의 최상위 비트로 처리하고 가장 오른쪽\(마지막\) 비트를 i의 최하위 비트로 처리하여 결과 비트 문자열을 정수 i로 변환합니다.

---
### **5.3.  KT-IV Signatures**

Koyama와 Tsuruoka는 Elliptic Curve ElGamal을 기반으로 한 서명 방법을 설명했는데, 여기서 첫 번째 서명 구성 요소는 모듈로 q로 감소된 타원 곡선 점의 x 좌표입니다\[KT1994\]. 이 섹션에서는 KT-IV라고 하는 방법을 기억합니다.

알고리즘은 섹션 3.3에 설명된 대로 소수 필드 순서 p와 곡선 방정식 매개변수 a 및 b를 갖는 타원 곡선 그룹을 사용합니다. 생성기를 알파로 표시하고 생성기의 차수를 q로 표시합니다. 예외적인 경우를 확인하는 데에는 \[FIPS186\]을 따릅니다.

---
#### **5.3.1.  Keypair Generation**

개인 키 z는 1과 q-1 사이의 정수이며 균일하게 무작위로 생성됩니다. \(임의의 정수에 대해서는 부록 B를 참조하십시오.\) 공개 키는 그룹 요소 Y = alpha^z입니다. 각

공개 키는 섹션 3.3에 따라 설정된 특정 매개변수와 연결됩니다.

---
#### **5.3.2.  Signature Creation**

개인 키 z를 사용하여 메시지 m에 대한 KT-IV 서명을 계산하려면 다음을 수행하십시오.

1. 1과 q-1 사이의 모든 정수 집합에서 무작위로 균일하게 정수 k를 선택합니다. \(난수 정수에 대해서는 부록 B를 참조하세요.\)

```text
   2.  Calculate R = (r_x, r_y) = alpha^k.

   3.  Calculate s1 = r_x mod q.
```

1. h\(m\) + z \* s1 = 0 mod q인지 확인합니다. 그렇다면 새로운 k 값을 생성해야 하며 서명을 다시 계산해야 합니다. 옵션으로 s1 = 0인지 확인할 수도 있습니다. 그렇다면 k의 새로운 값이 생성되어야 하고 서명이 다시 계산되어야 합니다. \(서명이 제대로 생성된 경우 s1 = 0 또는 h\(m\) + z \* s1 = 0 mod q가 될 가능성은 거의 없습니다.\)

```text
   5.  Calculate s2 = k/(h(m) + z*s1) mod q.
```

서명은 순서쌍\(s1, s2\)입니다. 두 서명 구성 요소 모두 음수가 아닌 정수입니다.

---
#### **5.3.3.  Signature Verification**

메시지 m, 생성자 g, 그룹 순서 q, 공개 키 Y 및 서명\(s1, s2\)이 주어지면 검증은 다음과 같습니다.

1. 0 < s1 < q 및 0 < s2 < q인지 확인합니다. 두 조건 중 하나라도 위반되면 서명이 거부됩니다.

1. 음이 아닌 정수 u1과 u2를 계산합니다. 여기서

```text
          u1 = h(m) * s2 mod q, and

          u2 = s1 * s2 mod q.
```

1. 타원 곡선 점 R' = alpha^u1 \* Y^u2를 계산합니다.

1. R' mod q의 x 좌표가 s1과 같으면 서명과 메시지가 검증을 통과한 것입니다. 그렇지 않으면 실패합니다.

---
### **5.4.  KT-I Signatures**

Horster, Michels 및 Petersen은 다양한 ElGamal 서명 방법을 분류하고 동등성을 입증했으며 한 유형의 서명을 다른 유형으로 변환하는 방법을 보여주었습니다\[HMP1994\]. 5.3절과 \[KT1994\]의 서명 방식은 용어상 Type IV 방식이므로 KT-IV로 표기한다.

Type I KT 서명 방법에는 디지털 서명 알고리즘과 동일한 방식으로 계산되는 두 번째 구성 요소가 있습니다. 이 섹션에서는 KT-I라고 하는 이 방법을 설명합니다.

---
#### **5.4.1.  Keypair Generation**

키쌍과 키쌍 생성은 섹션 5.3.1과 똑같습니다.

---
#### **5.4.2.  Signature Creation**

개인 키 z를 사용하여 메시지 m에 대한 KT-I 서명을 계산하려면 다음을 수행합니다.

1. 1과 q-1 사이의 모든 정수 집합에서 무작위로 균일하게 정수 k를 선택합니다. \(난수 정수에 대해서는 부록 B를 참조하세요.\)

```text
   2.  Calculate R = (r_x, r_y) = alpha^k.

   3.  Calculate s1 = r_x mod q.

   4.  Calculate s2 = (h(m) + z*s1)/k mod q.
```

1. 옵션으로 s1 = 0 또는 s2 = 0인지 확인할 수 있습니다. s1 = 0 또는 s2 = 0이면 새로운 k 값이 생성되어야 하며 서명이 다시 계산되어야 합니다. \(서명이 제대로 생성된 경우 s1 = 0 또는 s2 = 0이 될 가능성은 거의 없습니다.\)

서명은 순서쌍\(s1, s2\)입니다. 두 서명 구성 요소 모두 음수가 아닌 정수입니다.

---
#### **5.4.3.  Signature Verification**

메시지 m, 공개 키 Y, 서명\(s1, s2\)이 주어지면 검증은 다음과 같습니다.

1. 0 < s1 < q 및 0 < s2 < q인지 확인합니다. 두 조건 중 하나라도 위반되면 서명이 거부됩니다.

```text
   2.  Compute s2_inv = 1/s2 mod q.
```

1. 음이 아닌 정수 u1과 u2를 계산합니다. 여기서

```text
          u1 = h(m) * s2_inv mod q, and

          u2 = s1 * s2_inv mod q.
```

1. 타원 곡선 점 R' = alpha^u1 \* Y^u2를 계산합니다.

1. R' mod q의 x 좌표가 s1과 같으면 서명과 메시지가 검증을 통과한 것입니다. 그렇지 않으면 실패합니다.

---
### **5.5.  Converting KT-IV Signatures to KT-I Signatures**

메시지 m과 공개 키 Y에 대한 KT-IV 서명은 동일한 메시지와 공개 키에 대한 KT-I 서명으로 쉽게 변환될 수 있습니다. \(s1, s2\)가 메시지 m에 대한 KT-IV 서명인 경우 \(s1, 1/s2 mod q\)는 동일한 메시지 \[HMP1994\]에 대한 KT-I 서명입니다.

변환 작업은 공개 정보만을 사용하며 변환 전 KT-IV 서명 작성자, 변환 후 KT-I 서명 검증자 또는 기타 개체가 수행할 수 있습니다.

구현은 KT-I 서명을 계산하기 위해 이 방법을 사용할 수 있습니다.

---
### **5.6.  Rationale**

이 하위 섹션은 이 사양에 대한 규범이 아니며 배경 정보로만 제공됩니다.

\[HMP1994\]는 ElGamal 서명의 많은 일반화를 제시합니다. 해당 참조의 방정식 \(5\)는 일반적인 서명 방정식을 보여줍니다.

- A = x\_A \* B + k \* C \(mod q\)

여기서 x\_A는 개인키, k는 비밀값, A, B, C는 \[HMP1994\]의 표 1과 같이 방정식의 Type에 따라 결정된다. DSA \[FIPS186\]는 EG-I.1 서명 방법\(KT-I와 마찬가지로\)으로 A = m, B = -r, C = s입니다. \(여기서는 첫 번째 서명 구성 요소가 r이고 두 번째 서명 구성 요소가 s인 \[HMP1994\]의 표기법을 사용합니다. KT-I 및 KT-IV에서는 이러한 구성 요소를 각각 s1 및 s2로 표시합니다. 개인 키 x\_A는 개인 키 z에.\) 서명 방정식은 다음과 같습니다.

```text
      m = -r * z + s * k (mod q).
```

\[KT1994\] 및 5.3절의 서명 방법은 EG-IV.1 방법으로 A = m \* s, B = -r \* s, C = 1이다. 서명 방정식은 다음과 같다.

```text
      m * s = -r * s * z + k (mod q)
```

\[HMP1994\]의 표 1에 언급된 함수 f와 g는 "다섯 번째 일반화"라는 제목 아래 설명된 것처럼 단순한 곱셈입니다.

위의 방정식에서 우리는 비트 문자열에서 정수로의 메시지 m의 암시적 변환에 의존합니다. 이 방정식에는 해시 함수가 표시되지 않지만 섹션 10.4에 설명된 대로 실존 위조 공격을 방지하기 위해 서명하기 전에 메시지에 해시 함수를 적용해야 합니다.

Nyberg와 Rueppel \[NR1994\]은 다양한 ElGamal 서명 방법을 연구하고 다음과 같이 "강력한 동등성"을 정의했습니다.

- 개인 키에 대한 지식 없이 첫 번째 체계의 서명이 두 번째 체계의 서명으로 효율적으로 변환되거나 그 반대로 변환될 수 있는 경우 두 가지 서명 방법을 강력히 동일하다고 합니다.

KT-I 및 KT-IV 서명은 분명히 강력하게 동일합니다.

s2=0인 유효한 서명은 비밀 키를 유출합니다. 이 경우 z = -h\(m\) / s1 mod q이기 때문입니다. 우리는 이 예외적인 경우와 s1=0인 경우를 확인하는데 있어 \[FIPS186\]을 따릅니다. s2=0 검사는 Rivest \[R1992\]에 의해 제안되었으며 \[BS1992\]에서 논의되었습니다.

\[KT1994\]는 타원 곡선 점 R = \(r\_x, r\_y\)의 x 좌표 r\_x로부터 서명 성분 s1을 계산할 때 "q를 초과하지 않는 양의 정수 q'"를 사용합니다. q' 값은 계산된 타원 곡선 점의 x 좌표를 s1 값과 비교할 때 서명 유효성 검사 중에도 사용됩니다. 이 노트에서는 q' = q라는 단순화 규칙을 사용합니다.

---
## **6.  Converting between Integers and Octet Strings**

정수와 옥텟 문자열 간의 변환 방법은 공개 키 암호화 \[R1993\]의 확립된 규칙에 따라 이 섹션에 지정됩니다. 이 방법을 사용하면 정수를 전송이나 저장에 적합한 옥텟 문자열로 표현할 수 있습니다. 이 방법은 이 노트에 정의된 대로 타원 곡선 점이나 타원 곡선 좌표를 나타낼 때 사용해야 합니다.

---
### **6.1.  Octet-String-to-Integer Conversion**

옥텟 문자열 S는 다음과 같이 정수 x로 변환됩니다. S1, ..., Sk를 처음부터 끝까지 S의 옥텟이라고 하자. 그러면 정수 x는 다음을 만족해야 합니다.

```text
                          k
                    x =  SUM  2^(8(k-i)) Si .
                        i = 1
```

즉, S의 첫 번째 옥텟은 정수 중 가장 큰 의미를 가지며 S의 마지막 옥텟은 가장 작은 의미를 갖습니다.

참고: 정수 x는 0 <= x < 2^\(8\*k\)를 충족합니다.

---
### **6.2.  Integer-to-Octet-String Conversion**

정수 x는 다음과 같이 길이 k의 옥텟 문자열 S로 변환됩니다. 문자열 S는 다음을 만족해야 합니다.

```text
                          k
                    y =  SUM  2^(8(k-i)) Si .
                        i = 1
```

여기서 S1, ..., Sk는 처음부터 끝까지 S의 옥텟입니다.

즉, S의 첫 번째 옥텟은 정수 중 가장 중요한 의미를 갖고, S의 마지막 옥텟은 가장 작은 의미를 갖습니다.

---
## **7.  Interoperability**

이 노트의 알고리즘은 다른 ECC 사양과 상호 운용되는 데 사용될 수 있습니다. 이 섹션에서는 각 알고리즘에 대한 세부 정보를 제공합니다.

---
### **7.1.  ECDH**

섹션 4는 IKE\(인터넷 키 교환\) 버전 1 \[RFC2409\] 또는 2 \[RFC5996\]과 함께 사용할 수 있습니다. 이러한 알고리즘은 \[RFC5903\], \[RFC5114\], \[RFC2409\] 및 \[RFC2412\]에서 정의된 ECP 그룹과 호환됩니다. 이 프로토콜의 그룹 정의는 공개 키의 아핀 좌표 표현을 사용합니다. \[RFC5903\]은 섹션 4.2의 압축 출력을 사용하는 반면 \[RFC4753\]\(RFC 5903에 의해 폐기됨\)은 사용하지 않습니다. 해당 RFC 중 어느 것도 압축 표현을 사용하지 않습니다. 일부 그룹은 곡선 매개변수 "a"가 음수임을 나타냅니다. 이러한 값은 필드 순서에 따라 모듈로 해석됩니다. 예를 들어, a = -3의 매개변수는 p - 3과 같습니다. 여기서 p는 필드의 차수입니다. 테스트 케이스

\[RFC5903\]의 섹션 8을 사용하여 구현을 테스트할 수 있습니다. 이러한 경우에는 이 노트와 마찬가지로 곱셈 표기법을 사용합니다. KEi 및 KER 페이로드는 각각 g^j 및 g^k와 동일하며 앞에 64비트 인코딩 데이터가 추가됩니다.

섹션 4의 알고리즘은 3보다 큰 특성 필드를 기반으로 하는 ECDH에 대한 IEEE \[P1363\] 및 ANSI \[X9.62\] 표준과 상호 운용되는 데 사용될 수 있습니다. IEEE P1363 ECDH는 해당 사양의 다음 옵션 및 매개변수 선택과 함께 이 노트와 상호 운용되는 방식으로 사용될 수 있습니다.

- 보조 인자가 1인 소수 곡선,

- ECSVDP-DH\(타원 곡선 비밀 값 파생 프리미티브, Diffie-Hellman 버전\),

- KDF\(Key Derivation Function\)는 "identity" 함수여야 합니다\(동등하게 KDF 단계를 생략하고 공유 비밀 값을 직접 출력해야 함\).

---
### **7.2.  KT-I and ECDSA**

디지털 서명 알고리즘\(DSA\)은 큰 소수 차수를 갖는 유한 필드의 곱셈 하위 그룹에 대한 이산 로그 문제를 기반으로 합니다\[DSA1991\]\[FIPS186\]. ECDSA\(타원 곡선 디지털 서명 알고리즘\) \[P1363\] \[X9.62\]는 DSA의 타원 곡선 버전입니다.

KT-I는 수학적으로나 기능적으로 ECDSA와 동일하며, 3개 이상의 특성 필드를 기반으로 하는 타원 곡선 DSA\(ECDSA\)에 대한 IEEE \[P1363\] 및 ANSI \[X9.62\] 표준과 상호 운용할 수 있습니다. KT-I 서명은 ECDSA 검증 알고리즘을 이용하여 검증할 수 있고, ECDSA 서명은 KT-I 검증 알고리즘을 이용하여 검증할 수 있다.

---
## **8.  Validating an Implementation**

암호화 알고리즘의 구현을 검증하는 것이 필수적입니다. 이 섹션에서는 이 노트에 정의된 알고리즘에 대해 수행해야 하는 테스트에 대해 간략하게 설명합니다.

KAT\(Known Answer Test\)는 고정된 입력 세트를 사용하여 알고리즘을 테스트합니다. 알고리즘의 출력은 역시 고정된 값인 예상 출력과 비교됩니다. ECDH 및 KT-I에 대한 KAT는 다음 하위 섹션에 설명되어 있습니다.

일관성 테스트는 테스트 중인 두 번째 알고리즘을 사용하여 테스트 중인 하나의 알고리즘에 대한 입력을 생성한 다음 첫 번째 알고리즘의 출력을 확인합니다. 서명 생성 알고리즘은 서명 확인 알고리즘과 비교하여 일관성을 테스트할 수 있습니다. KT-I의 구현은 이런 방식으로 테스트되어야 합니다. 서명 생성 프로세스는 비결정적이므로 KAT를 사용하여 테스트할 수 없습니다. 반면에 서명 확인 알고리즘은 결정적이므로 KAT를 통해 테스트해야 합니다. 이러한 테스트 조합은 키 쌍 생성을 포함한 모든 작업에 대한 적용 범위를 제공합니다. 일관성 테스트는 ECDH에도 적용되어야 합니다.

---
### **8.1.  ECDH**

ECDH 구현은 \[RFC5903\] 또는 \[RFC5114\]의 알려진 답변 테스트 사례를 사용하여 검증할 수 있습니다. RFC 5903의 표기법과 이 노트의 표기법 간의 대응 관계는 다음 표에 요약되어 있습니다. \(섹션 3.3 및 4를 참조하십시오. 생성기 g는 아핀 좌표 표현으로 \(gx, gy\)로 표현됩니다.\)

```text
     +----------------------+---------------------------------------+
     | ECDH                 | RFC 5903                              |
     +----------------------+---------------------------------------+
     | order p of field Fp  | p                                     |
     | curve coefficient a  | -3                                    |
     | curve coefficient b  | b                                     |
     | generator g          | g=(gx, gy)                            |
     | private keys j and k | i and r                               |
     | public keys g^j, g^k | g^i = (gix, giy) and g^r = (grx, gry) |
     +----------------------+---------------------------------------+
```

RFC 5114의 표기법과 이 노트의 표기법 간의 대응 관계는 다음 표에 요약되어 있습니다.

```text
           +-----------------------+---------------------------+
           | ECDH                  | RFC 5114                  |
           +-----------------------+---------------------------+
           | order p of field Fp   | p                         |
           | curve coefficient a   | a                         |
           | curve coefficient b   | b                         |
           | generator g           | g=(gx, gy)                |
           | group order n         | n                         |
           | private keys j and k  | dA and dB                 |
           | public keys g^j, g^k  | g^(dA) = (x_qA, y_qA) and |
           |                       | g^(dB) = (x_qB, y_qB)     |
           | shared secret g^(j*k) | g^(dA*dB) = (x_Z, y_Z)    |
           +-----------------------+---------------------------+
```

---
### **8.2.  KT-I**

KT-I 구현은 \[RFC4754\]의 알려진 답변 테스트 사례를 사용하여 검증할 수 있습니다. 해당 RFC의 표기법과 이 노트의 표기법 간의 대응 관계는 다음 표에 요약되어 있습니다.

```text
                +---------------------+------------------+
                | KT-I                | RFC 4754         |
                +---------------------+------------------+
                | order p of field Fp | p                |
                | curve coefficient a | -3               |
                | curve coefficient b | b                |
                | generator alpha     | g                |
                | group order q       | q                |
                | private key z       | w                |
                | public key Y        | g^w = (gwx,gwy)  |
                | random k            | ephem priv k     |
                | s1                  | r                |
                | s2                  | s                |
                | s2_inv              | sinv             |
                | u1                  | u = h*sinv mod q |
                | u2                  | v = r*sinv mod q |
                +---------------------+------------------+
```

---
## **9.  Intellectual Property**

최근 몇 년 동안 수많은 최적화 및 전문 알고리즘이 특허를 받았기 때문에 지적 재산에 대한 우려로 인해 ECC 채택이 둔화되었습니다.

ECDH\(섹션 4에 정의됨\)에 대한 모든 규범적 참고문헌은 1989년 또는 그 이전에 출판되었으며, KT-I에 대한 규범적 참고문헌은 1994년 5월 또는 그 이전에 출판되었습니다. 이러한 알고리즘에 대한 모든 규범적 텍스트는 해당 참고문헌에만 기반을 두고 있습니다. .

---
### **9.1.  Disclaimer**

이 문서는 법적 조언을 제공하기 위한 것이 아닙니다. 독자가 자신의 권리에 대한 법적 해석을 원하는 경우 법률 고문과 상담하는 것이 좋습니다.

지적 재산 및 특허에 관한 IETF 정책 및 프로세스는 \[RFC3979\] 및 \[RFC4879\]와 https://datatracker.ietf.org/ipr/about/에 요약되어 있습니다.

---
## **10.  Security Considerations**

타원 곡선 암호 시스템의 보안 수준은 공격자가 구현하는 데 가장 비용이 적게 드는 암호 분석 알고리즘에 의해 결정됩니다. 고려해야 할 몇 가지 알고리즘이 있습니다.

Pohlig-Hellman 방법은 분할 정복 기술입니다\[PH1978\]. 그룹 순서 n이 다음과 같이 인수분해될 수 있는 경우

```text
      n = q1 * q2 * ... * qz,
```

그런 다음 그룹에 대한 이산 로그 문제는 q1, q2, ..., qz 순서 그룹의 이산 로그 문제를 독립적으로 해결한 다음 중국 나머지 정리를 사용하여 결과를 결합하여 해결할 수 있습니다. 전체 계산 비용은 차수가 가장 큰 하위 그룹의 이산 로그 문제의 비용에 의해 지배됩니다.

Shanks의 알고리즘 \[K1981v3\]은 O\(sqrt\(n\)\) 연산과 O\(sqrt\(n\)\) 저장을 사용하여 n차 그룹의 이산 로그를 계산합니다. Pollard rho 알고리즘\[P1978\]은 O\(sqrt\(n\)\) 연산을 사용하여 무시할 수 있는 저장 공간을 사용하여 n차 그룹의 이산 로그를 계산하며 효율적으로 병렬화될 수 있습니다\[VW1994\].

Pollard 람다 알고리즘 \[P1978\]은 지수가 너비 w의 간격에 있는 것으로 알려진 경우 O\(sqrt\(w\)\) 연산과 O\(log\(w\)\) 저장을 사용하여 이산 로그 문제를 해결할 수 있습니다.

위에서 설명한 알고리즘은 모든 그룹에서 작동합니다. 특히 타원 곡선 그룹을 대상으로 하는 특수 알고리즘이 있습니다. 특정 특수 타원 곡선 그룹을 대상으로 하는 방법이 있지만 일반 타원 곡선 그룹에 대해 알려진 하위 지수 알고리즘은 없습니다. \[MOV1993\] 및 \[FR1994\]를 참조하세요.

---
### **10.1.  Subgroups**

관련 그룹 연산 \*이 포함된 비어 있지 않은 요소 집합 S로 구성된 그룹은 요소 집합 G가 포함된 그룹의 하위 그룹입니다. 단, 후자 그룹이 동일한 그룹 연산을 사용하고 S가 G의 하위 집합인 경우 각 타원 곡선 방정식에 대해 , 그룹 순서가 타원 곡선의 순서와 동일한 타원 곡선 그룹이 있습니다. 즉, 곡선의 모든 점을 포함하는 그룹이 있습니다.

타원 곡선의 차수 m은 생성기와 관련된 그룹의 차수 n으로 나눌 수 있습니다. 즉, 각 타원 곡선 그룹에 대해 어떤 숫자 c에 대해 m = n \* c입니다. 숫자 c를 "보조인자"라고 합니다\[P1363\]. 섹션 3.3에 설정된 각 ECC 매개변수는 특정 보조 인자와 연관됩니다.

1과 같은 보조 인자를 사용하는 것이 가능하고 바람직합니다.

---
### **10.2.  Diffie-Hellman**

섹션 4에 정의된 키 교환 프로토콜은 활성 공격으로부터 보호하지 않습니다. 당사자 A는 \(g^k\)가 공격자가 아닌 의도된 통신자 B에서 시작되었음을 확인하기 위해 몇 가지 방법을 사용해야 하며, 당사자 B는 \(g^j\)에 대해 동일한 작업을 수행해야 합니다.

공유 비밀 g^\(j\*k\)을 인증하는 것만으로는 충분하지 않습니다. 왜냐하면 공개 키를 조작하는 공격에 프로토콜이 노출되기 때문입니다. 대신, 교환되는 공개 키 g^x 및 g^y의 값을 직접 인증해야 합니다. 이는 Diffie-Hellman을 기반으로 하고 최종 엔터티 인증을 사용하여 OAKLEY \[RFC2412\] 및 인터넷 키 교환 \[RFC2409\] \[RFC4306\] \[RFC5996\]과 같은 활성 공격으로부터 보호하는 프로토콜에서 사용되는 전략입니다.

그룹의 보조 인자가 1이 아닌 경우 ECDH에 대해 가능한 공격이 많이 있습니다. \[VW1996\], \[AV1996\] 및 \[LL1997\]을 참조하십시오.

---
### **10.3.  Group Representation and Security**

타원 곡선 그룹 연산은 곡선 방정식의 매개변수 b를 명시적으로 통합하지 않습니다. 이로 인해 악의적인 공격자가 가짜 공개 키\[BMM2000\]를 제출하여 ECDH 개인 키에 대한 정보를 배울 수 있는 가능성이 열립니다. 공격자는 b가 다르다는 점을 제외하고 ECDH 프로토콜에서 사용되는 그룹 G와 동일한 매개변수를 갖는 타원 곡선 그룹 G'를 만들 수 있습니다. 공격자는 그룹 G를 사용하는 ECDH 프로토콜 실행에 G'의 지점을 제출할 수 있으며, 공격 대상 장치의 개인 키를 사용하는 그룹 작업이 실제로 G' 대신 G'에서 발생한다는 사실로부터 정보를 얻을 수 있습니다. G.

이 공격은 정적 공개 키\(예: 둘 이상의 프로토콜 실행에서 사용되는 공개 키\)와 연결된 ECDH 개인 키에 대한 유용한 정보를 얻을 수 있습니다. 그러나 임시 키에 대해서는 유용한 정보를 얻지 못합니다.

이러한 종류의 공격은 ECDH 구현이 Zp의 각 좌표 쌍이 실제로 적절한 타원 곡선의 한 점이라고 가정하지 않는 경우 좌절됩니다.

이러한 고려 사항은 ECDH가 압축 표현과 함께 사용되는 경우에도 적용됩니다\(부록 C 참조\).

---
### **10.4.  Signatures**

타원 곡선 매개변수는 신뢰할 수 있는 소스에서 가져온 경우에만 사용해야 합니다. 그렇지 않으면 일부 공격이 가능합니다 \[AV1996\] \[V1996\].

ElGamal 서명 시스템에 해시 함수가 사용되지 않으면 시스템은 개인 키를 모르는 공격자가 관련 공개 키에 대해 유효한 서명을 생성할 수 있지만 메시지에 대한 서명을 생성할 수 없는 실존적 위조에 취약합니다. 자신이 선택한 것. \(예를 들어 \[E1985\]를 참조하십시오.\) 충돌 방지 해시 함수를 사용하면 이러한 취약점이 제거됩니다.

원칙적으로 모든 충돌 방지 해시 함수는 KT 서명에 사용하기에 적합합니다. 상호 운용성을 촉진하기 위해 우리는 섹션 5.2에 정의된 함수 H로 사용하기에 적합한 것으로 다음 해시를 인식합니다.

- 256비트 출력을 갖는 SHA-256.

- 384비트 출력을 갖는 SHA-384.

- 512비트 출력을 갖는 SHA-512.

이러한 해시 함수는 모두 \[FIPS180-2\]에 정의되어 있습니다.

KT 서명에 사용되는 해시 출력의 비트 수는 그룹 순서를 나타내는 데 필요한 비트 수와 같거나 가까워야 합니다.

---
## **11.  Acknowledgements**

저자는 이 노트를 가능하게 한 타원 곡선 암호화의 창시자와 귀중한 건설적 피드백을 제공한 모든 검토자에게 감사를 표합니다. 특히 Howard Pinder, Andrey Jivsov, Alfred Hoenes\(부록 F의 알고리즘에 기여한 사람\), Dan Harkins 및 Tina Tsou에게 감사드립니다.

---
## **12.  References**
---
### **12.1.  Normative References**

```text
   [AMV1990]    Agnew, G., Mullin, R., and S. Vanstone, "Improved
                Digital Signature Scheme based on Discrete
                Exponentiation", Electronics Letters Vol. 26, No. 14,
                July, 1990.

   [BC1989]     Bender, A. and G. Castagnoli, "On the Implementation of
                Elliptic Curve Cryptosystems", Advances in Cryptology -
                CRYPTO '89 Proceedings, Springer Lecture Notes in
                Computer Science (LNCS), volume 435, 1989.

   [CC1986]     Chudnovsky, D. and G. Chudnovsky, "Sequences of numbers
                generated by addition in formal groups and new primality
                and factorization tests", Advances in Applied
                Mathematics, Volume 7, Issue 4, December 1986.

   [D1966]      Deskins, W., "Abstract Algebra", MacMillan Company New
                York, 1966.

   [DH1976]     Diffie, W. and M. Hellman, "New Directions in
                Cryptography", IEEE Transactions in Information
                Theory IT-22, pp. 644-654, 1976.

   [FR1994]     Frey, G. and H. Ruck, "A remark concerning
                m-divisibility and the discrete logarithm in the divisor
                class group of curves.", Mathematics of Computation Vol.
                62, No. 206, pp. 865-874, 1994.

   [HMP1994]    Horster, P., Michels, M., and H. Petersen, "Meta-ElGamal
                signature schemes", University of Technology Chemnitz-
                Zwickau Department of Computer Science, Technical
                Report TR-94-5, May 1994.

   [K1981v2]    Knuth, D., "The Art of Computer Programming, Vol. 2:
                Seminumerical Algorithms", Addison Wesley , 1981.

   [K1987]      Koblitz, N., "Elliptic Curve Cryptosystems", Mathematics
                of Computation, Vol. 48, 1987, pp. 203-209, 1987.

   [KT1994]     Koyama, K. and Y. Tsuruoka, "Digital signature system
                based on elliptic curve and signer device and verifier
                device for said system", Japanese Unexamined Patent
                Application Publication H6-43809, February 18, 1994.

   [M1983]      Massey, J., "Logarithms in finite cyclic groups -
                cryptographic issues", Proceedings of the 4th Symposium
                on Information Theory, 1983.

   [M1985]      Miller, V., "Use of elliptic curves in cryptography",
                Advances in Cryptology - CRYPTO '85
                Proceedings, Springer Lecture Notes in Computer Science
                (LNCS), volume 218, 1985.

   [MOV1993]    Menezes, A., Vanstone, S., and T. Okamoto, "Reducing
                Elliptic Curve Logarithms to Logarithms in a Finite
                Field", IEEE Transactions on Information Theory Vol. 39,
                No. 5, pp. 1639-1646, September, 1993.

   [R1993]      RSA Laboratories, "PKCS#1: RSA Encryption Standard",
                Technical Note version 1.5, 1993.

   [S1986]      Silverman, J., "The Arithmetic of Elliptic Curves",
                Springer-Verlag, New York, 1986.
```

---
### **12.2.  Informative References**

```text
   [A1992]      Anderson, J., "Response to the proposed DSS",
                Communications of the ACM, v. 35, n. 7, p. 50-52,
                July 1992.

   [AV1996]     Anderson, R. and S. Vaudenay, "Minding Your P's and
                Q's", Advances in Cryptology - ASIACRYPT '96
                Proceedings, Springer Lecture Notes in Computer Science
                (LNCS), volume 1163, 1996.

   [BMM2000]    Biehl, I., Meyer, B., and V. Muller, "Differential fault
                analysis on elliptic curve cryptosystems", Advances in
                Cryptology - CRYPTO 2000 Proceedings, Springer Lecture
                Notes in Computer Science (LNCS), volume 1880, 2000.

   [BS1992]     Branstad, D. and M. Smid, "Response to Comments on the
                NIST Proposed Digital Signature Standard", Advances in
                Cryptology - CRYPTO '92 Proceedings, Springer Lecture
                Notes in Computer Science (LNCS), volume 740,
                August 1992.

   [DSA1991]    U.S. National Institute of Standards and Technology,
                "DIGITAL SIGNATURE STANDARD", Federal Register, Vol. 56,
                August 1991.

   [E1984a]     ElGamal, T., "Cryptography and logarithms over finite
                fields", Stanford University, UMI Order No. DA 8420519,
                1984.

   [E1984b]     ElGamal, T., "Cryptography and logarithms over finite
                fields", Advances in Cryptology - CRYPTO '84
                Proceedings, Springer Lecture Notes in Computer Science
                (LNCS), volume 196, 1984.

   [E1985]      ElGamal, T., "A public key cryptosystem and a signature
                scheme based on discrete logarithms", IEEE Transactions
                on Information Theory, Vol. 30, No. 4, pp. 469-472,
                1985.

   [FIPS180-2]  U.S. National Institute of Standards and Technology,
                "SECURE HASH STANDARD", Federal Information Processing
                Standard (FIPS) 180-2, August 2002.

   [FIPS186]    U.S. National Institute of Standards and Technology,
                "DIGITAL SIGNATURE STANDARD", Federal Information
                Processing Standard FIPS-186, May 1994.

   [HP1994]     Horster, P. and H. Petersen, "Verallgemeinerte ElGamal-
                Signaturen", Proceedings der Fachtagung SIS '94, Verlag
                der Fachvereine, Zurich, 1994.

   [K1981v3]    Knuth, D., "The Art of Computer Programming, Vol. 3:
                Sorting and Searching", Addison Wesley, 1981.

   [KMOV1991]   Koyama, K., Maurer, U., Vanstone, S., and T. Okamoto,
                "New Public-Key Schemes Based on Elliptic Curves over
                the Ring Zn", Advances in Cryptology - CRYPTO '91
                Proceedings, Springer Lecture Notes in Computer Science
                (LNCS), volume 576, 1991.

   [L1969]      Lehmer, D., "Computer technology applied to the theory
                of numbers", M.A.A. Studies in Mathematics, 180-2, 1969.

   [LL1997]     Lim, C. and P. Lee, "A Key Recovery Attack on Discrete
                Log-based Schemes Using a Prime Order Subgroup",
                Advances in Cryptology - CRYPTO '97
                Proceedings, Springer Lecture Notes in Computer Science
                (LNCS), volume 1294, 1997.

   [NR1994]     Nyberg, K. and R. Rueppel, "Message Recovery for
                Signature Schemes Based on the Discrete Logarithm
                Problem", Advances in Cryptology - EUROCRYPT '94
                Proceedings, Springer Lecture Notes in Computer Science
                (LNCS), volume 950, May 1994.

   [P1363]      "Standard Specifications for Public Key Cryptography",
                Institute of Electric and Electronic Engineers
                (IEEE), P1363, 2000.

   [P1978]      Pollard, J., "Monte Carlo methods for index computation
                mod p", Mathematics of Computation, Vol. 32, 1978.

   [PH1978]     Pohlig, S. and M. Hellman, "An Improved Algorithm for
                Computing Logarithms over GF(p) and its Cryptographic
                Significance", IEEE Transactions on Information
                Theory, Vol. 24, pp. 106-110, 1978.

   [R1988]      Rose, H., "A Course in Number Theory", Oxford
                University Press, 1988.

   [R1992]      Rivest, R., "Response to the proposed DSS",
                Communications of the ACM, v. 35, n. 7, p. 41-47,
                July 1992.

   [RFC2119]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2409]    Harkins, D. and D. Carrel, "The Internet Key Exchange
                (IKE)", RFC 2409, November 1998.

   [RFC2412]    Orman, H., "The OAKLEY Key Determination Protocol",
                RFC 2412, November 1998.

   [RFC3979]    Bradner, S., "Intellectual Property Rights in IETF
                Technology", BCP 79, RFC 3979, March 2005.

   [RFC4086]    Eastlake, D., Schiller, J., and S. Crocker, "Randomness
                Requirements for Security", BCP 106, RFC 4086,
                June 2005.

   [RFC4306]    Kaufman, C., "Internet Key Exchange (IKEv2) Protocol",
                RFC 4306, December 2005.

   [RFC4753]    Fu, D. and J. Solinas, "ECP Groups For IKE and IKEv2",
                RFC 4753, January 2007.

   [RFC4754]    Fu, D. and J. Solinas, "IKE and IKEv2 Authentication
                Using the Elliptic Curve Digital Signature Algorithm
                (ECDSA)", RFC 4754, January 2007.

   [RFC4879]    Narten, T., "Clarification of the Third Party Disclosure
                Procedure in RFC 3979", BCP 79, RFC 4879, April 2007.

   [RFC5114]    Lepinski, M. and S. Kent, "Additional Diffie-Hellman
                Groups for Use with IETF Standards", RFC 5114,
                January 2008.

   [RFC5903]    Fu, D. and J. Solinas, "Elliptic Curve Groups modulo a
                Prime (ECP Groups) for IKE and IKEv2", RFC 5903,
                June 2010.

   [RFC5996]    Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen,
                "Internet Key Exchange Protocol Version 2 (IKEv2)",
                RFC 5996, September 2010.

   [SuiteB]     U. S. National Security Agency (NSA), "NSA Suite B
                Cryptography", <http://www.nsa.gov/ia/programs/
                suiteb_cryptography/index.shtml>.

   [V1996]      Vaudenay, S., "Hidden Collisions on DSS", Advances in
                Cryptology - CRYPTO '96 Proceedings, Springer Lecture
                Notes in Computer Science (LNCS), volume 1109, 1996.

   [VW1994]     van Oorschot, P. and M. Wiener, "Parallel Collision
                Search with Application to Hash Functions and Discrete
                Logarithms", Proceedings of the 2nd ACM Conference on
                Computer and communications security, pp. 210-218, 1994.

   [VW1996]     van Oorschot, P. and M. Wiener, "On Diffie-Hellman key
                agreement with short exponents", Advances in Cryptology
                - EUROCRYPT '96 Proceedings, Springer Lecture Notes in
                Computer Science (LNCS), volume 1070, 1996.

   [X9.62]      "Public Key Cryptography for the Financial Services
                Industry: The Elliptic Curve Digital Signature Algorithm
                (ECDSA)", American National Standards Institute (ANSI)
                X9.62.
```

---
# **Appendix A.  Key Words**

이러한 핵심 단어의 정의는 \[RFC2119\]에서 인용되었으며 인터넷 표준에서 일반적으로 사용됩니다. 1994년 이후의 규범적 참조를 피하기 위해 이 주석에 재현되었습니다.

1. 반드시\(MUST\) - 이 단어 또는 "필수\(REQUIRED\)" 또는 "SHALL\(SHALL\)"이라는 용어는 정의가 사양의 절대 요구 사항임을 의미합니다.

1. MUST NOT - 이 문구 또는 "SHALL NOT" 문구는 정의가 사양을 절대적으로 금지한다는 의미입니다.

1. SHOULD - 이 단어 또는 형용사 "권장"은 특정 상황에서 특정 항목을 무시해야 하는 타당한 이유가 있을 수 있지만 다른 과정을 선택하기 전에 전체 의미를 이해하고 신중하게 평가해야 함을 의미합니다.

1. 하지 말아야 함 - 이 문구 또는 "권장되지 않음" 문구는 특정 동작이 허용되거나 유용할 때 특정 상황에서 타당한 이유가 있을 수 있지만 구현하기 전에 전체 의미를 이해하고 사례를 신중하게 고려해야 함을 의미합니다. 이 라벨로 설명되는 모든 동작.

1. MAY - 이 단어 또는 "OPTIONAL"이라는 형용사는 항목이 실제로 선택 사항임을 의미합니다. 한 공급업체는 특정 시장에서 요구하거나 제품을 향상시키는 반면 다른 공급업체는 동일한 항목을 생략할 수 있다고 생각하기 때문에 해당 항목을 포함하도록 선택할 수 있습니다. 특정 옵션을 포함하지 않는 구현은 아마도 기능이 축소되더라도 해당 옵션을 포함하는 다른 구현과 상호 운용되도록 준비되어야 합니다. 같은 맥락에서 특정 옵션을 포함하는 구현은 해당 옵션을 포함하지 않는 다른 구현과 상호 운용되도록 준비해야 합니다\(물론 옵션이 제공하는 기능은 제외\).

---
# **Appendix B.  Random Integer Generation**

일부 양의 정수 t에 대해 0과 \(2^t\)-1 사이에서 무작위로 균일하게 정수를 생성하는 것은 쉽습니다. 정확히 t 비트를 포함하는 임의의 비트 문자열을 생성한 다음 비트를 정수의 밑이 2인 확장의 계수로 처리하여 비트 문자열을 음이 아닌 정수로 변환합니다.

예를 들어 특정 간격 내에 있는 특정 속성 P를 r이 만족하도록 정수 r을 무작위로 균등하게 생성해야 하는 경우가 있습니다. 이를 수행하는 간단한 방법은 거부 방법을 사용하는 것입니다.

1. 속성 P를 만족하는 모든 숫자\(+ 일부 다른 숫자, 바람직하게는 너무 많지 않음\)를 포함하는 집합에서 무작위로 균일하게 후보 숫자 c를 생성합니다.

1. c가 속성 P를 만족하면 c를 반환합니다. 그렇지 않으면 1단계로 돌아갑니다.

예를 들어 1과 n-1 사이의 숫자를 생성하려면 0과 \(2^t\)-1 사이의 정수를 반복적으로 생성하고 해당 간격 내에 속하는 첫 번째 정수에서 중지합니다.

무작위 비트 문자열을 생성하는 방법에 대한 권장 사항은 \[RFC4086\]에 제공됩니다.

---
# **Appendix C.  Why Compact Representation Works**

아핀 표현에서, 점 P^i의 x 좌표는 음수가 아닌 지수 i와 점 P에 대해 점 P의 y 좌표에 의존하지 않습니다. 이 사실은 다음과 같이 볼 수 있습니다. 점 P의 x 좌표만 주어지면 y 좌표가 무엇인지 정확히 알 수는 없지만 y 값은 곡선 방정식의 해가 됩니다.

```text
      y^2 = x^3 + a*x + b (mod p).
```

최대 두 개의 서로 다른 해 y = w 및 y = -w mod p가 있으며 점 P는 Q=\(x,w\) 또는 Q^-1=\(x,-w\) 중 하나여야 합니다. 따라서 P^n은 Q^n 또는 \(Q^-1\)^n = \(Q^n\)^-1과 같습니다. 이들 값은 동일한 x 좌표를 갖습니다. 따라서 점 P^i의 x 좌표는 P의 y 좌표의 가능한 값 중 하나를 계산한 다음 P의 i승을 계산하고 다음을 무시하여 점 P의 x 좌표에서 계산할 수 있습니다. 해당 결과의 y좌표입니다.

일반적으로 Shanks의 방법 \[K1981v2\]을 사용하여 제곱근 모듈로 p를 계산하는 것이 가능합니다. p의 일부 값에 대해 간단한 방법이 존재합니다. p = 3\(mod 4\)일 때 z mod p의 제곱근은 w 및 -w mod p입니다. 여기서

```text
      w = z ^ ((p+1)/4) (mod p);
```

이 관찰은 Lehmer \[L1969\]에 의한 것입니다. p가 이 속성을 만족하면 y는 곡선 방정식에서 계산될 수 있으며 y = w 또는 y = -w mod p입니다. 여기서

```text
      w = (x^3 + a*x + b)^((p+1)/4) (mod p).
```

모듈로 p에 대한 제곱근은 2차 나머지 모듈로 p에 대해서만 존재합니다\(\[R1988\]\). z가 2차 잔수가 아닌 경우 w^2 = z\(mod p\)를 충족하는 숫자 w는 없습니다. w를 계산한 후 z가 2차 잔차인지 확인하는 간단한 방법은 w \* w = z\(mod p\)를 확인하는 것입니다. 이 관계가 위 방정식에 적용되지 않으면 값 x는 유효한 타원 곡선 점에 대한 유효한 x 좌표가 아닙니다. 이는 ECDH를 컴팩트 출력과 함께 사용할 때 중요한 고려 사항입니다. 섹션 10.3을 참조하세요.

\[RFC5903\]에 설명된 P-256, P-384 및 P-521 곡선에 사용된 소수는 모두 p = 3\(mod 4\)이라는 속성을 갖습니다.

---
# **Appendix D.  Example ECC Parameter Set**

구체적으로 말하자면 \[RFC5903\]에서 Solinas와 Fu가 정의하고 128비트 보안 수준을 제공하는 것으로 여겨지는 P-256이라고 하는 타원 곡선을 기억해 보겠습니다. 우리는 섹션 3.3의 표기법을 사용하고 생성기를 아핀 좌표 표현 g=\(gx,gy\)로 표현합니다. 여기서 gx와 gy 값은 Fp에 있습니다.

```text
   p: FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF

   a: - 3

   b: 5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B

   n: FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551

   gx: 6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296

   gy: 4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5
```

p는 다음과 같이 표현될 수도 있습니다.

```text
      p = 2^(256)-2^(224)+2^(192)+2^(96)-1.
```

---
# **Appendix E.  Additive and Multiplicative Notation**

타원 곡선 암호화에 관한 초기 출판물에서는 곱셈 표기법을 사용했지만 대부분의 최신 출판물에서는 덧셈 표기법을 사용합니다. 이 섹션에는 두 규칙 간의 테이블 매핑이 포함되어 있습니다. 이 섹션에서 a와 b는 타원 곡선 그룹의 요소이고 N은 정수입니다.

```text
            +-------------------------+-----------------------+
            | Multiplicative Notation | Additive Notation     |
            +-------------------------+-----------------------+
            | multiplication          | addition              |
            | a * b                   | a + b                 |
            | squaring                | doubling              |
            | a * a = a^2             | a + a = 2a            |
            | exponentiation          | scalar multiplication |
            | a^N = a * a * ... * a   | Na = a + a + ... + a  |
            | inverse                 | inverse               |
            | a^-1                    | -a                    |
            +-------------------------+-----------------------+
```

---
# **Appendix F.  Algorithms**

이 섹션에는 타원 곡선 그룹 작업에 대한 의사 코드 설명이 포함되어 있습니다. "//" 기호 뒤에 오는 텍스트는 지침이 아닌 설명으로 해석됩니다.

---
### **F.1.  Affine Coordinates**

아핀 좌표 P=\(x1,y1\) 및 Q=\(x2,y2\)로 지정된 임의의 쌍의 타원 곡선 점 P 및 Q에 그룹 연산은 좌표 \(x3, y3\). 이러한 좌표는 다음과 같이 계산됩니다.

P가 \(@,@\)인 경우, R = Q, 그렇지 않은 경우 Q가 \(@,@\)인 경우, R = P, 그렇지 않은 경우 P가 Q와 같지 않고 x1이 x2와 같은 경우, R = \(@,@\), 그렇지 않은 경우 P Q와 같지 않고 x1은 x2와 같지 않습니다. x3 = \(\(y2-y1\)/\(x2-x1\)\)^2 - x1 - x2 mod p 및 y3 = \(x1-x3\)\*\(y2-y1\) /\(x2-x1\) - y1 mod p else if P가 Q와 같고 y1이 0과 같으면 R = \(@,@\) else // P는 Q와 같고 y1은 0과 같지 않습니다. x3 = \(\( 3\*x1^2 + a\)/\(2\*y1\)\)^2 - 2\*x1 mod p 및 y3 = \(x1-x3\)\*\(3\*x1^2 + a\)/\(2\*y1\) - y mod 피.

첫 번째와 두 번째 경우에서 무한대의 점이 이 연산의 중립 요소이며, 이는 그 자체의 역수라는 결론이 나옵니다.

곡선 방정식으로부터 무한대 점과 구별되는 주어진 곡선 점 P = \(x,y\)에 대해 \(x,-y\)도 곡선 점이며 세 번째와 다섯 번째 경우에서는 다음과 같습니다. 이는 P, P^-1의 역수입니다.

참고: 다섯 번째와 여섯 번째 경우는 "점 제곱"으로 알려져 있습니다.

---
### **F.2.  Homogeneous Coordinates**

타원 곡선 점 \(x,y\)\(무한대 점\(@,@\) 제외\)은 동차 좌표\(Fp에 X, Y 및 Z가 있고 전부는 아님\)의 점\(X,Y,Z\)과 동일합니다. 3개는 동시에 0임\) x=X/Z 및 y=Y/Z일 때마다. "균질 좌표"는 Fp에 0이 아닌 s가 다음과 같은 경우 두 개의 트리플 \(X,Y,Z\) 및 \(X',Y',Z'\)가 "동등"\(즉, 동일한 점을 나타냄\)으로 간주됨을 의미합니다. X'=s\*X, Y'=s\*Y, Z'=s\*Z. 무한대\(@,@\)에 있는 점은 동질 좌표\(0,1,0\)와 동일한 것으로 간주됩니다. 즉, Fp에서 Y가 0이 아닌 삼중\(0,Y,0\)으로 표현될 수 있습니다.

P1=\(X1,Y1,Z1\) 및 P2=\(X2,Y2,Z2\)를 타원 곡선의 점으로 하고 u = Y2 \* Z1 - Y1 \* Z2 및 v = X2 \* Z1 - X1 \* Z2라고 가정합니다.

우리는 u와 v가 모두 0인 경우에만 점 P1과 P2가 동일하다는 것을 관찰합니다. 그렇지 않고, P1 또는 P2가 무한대의 점과 같으면 v는 0이고 u는 0이 아닙니다\(그러나 반대의 의미는 성립하지 않습니다\).

그러면 곱 P3=\(X3,Y3,Z3\) = P1 \* P2는 다음과 같이 계산됩니다.

```text
     if P1 is the point at infinity,
        P3 = P2
     else if P2 is the point at infinity,
        P3 = P1
     else if u is not equal to 0 but v is equal to 0,
        P3 = (0,1,0)
     else if both u and v are not equal to 0,
        X3 = v * (Z2 * (Z1 * u^2 - 2 * X1 * v^2) - v^3)
        Y3 = Z2 * (3 * X1 * u * v^2 - Y1 * v^3 - Z1 * u^3) + u * v^3
        Z3 = v^3 * Z1 * Z2
     else    // P2 equals P1, P3 = P1 * P1
         w = 3 * X1^2 + a * Z1^2
        X3 = 2 * Y1 * Z1 * (w^2 - 8 * X1 * Y1^2 * Z1)
        Y3 = 4 * Y1^2 * Z1 * (3 * w * X1 - 2 * Y1^2 * Z1) - w^3
        Z3 = 8 * (Y1 * Z1)^3
```

따라서 무한대의 점이 항등 요소이고 P1=\(X,Y,Z\)가 무한대의 이 점과 같지 않은 경우 P2=\(X,-Y,Z\)는 P1^-1을 나타냅니다.

---
# **Authors' Addresses**

```text
   David A. McGrew
   Cisco Systems
   510 McCarthy Blvd.
   Milpitas, CA  95035
   USA

   Phone: (408) 525 8651
   EMail: mcgrew@cisco.com
   URI:   http://www.mindspring.com/~dmcgrew/dam.htm
```

Kevin M. Igoe 국가안보국\(National Security Agency\) 상업 솔루션 센터 미국

```text
   EMail: kmigoe@nsa.gov

   Margaret Salter
   National Security Agency
   9800 Savage Rd.
   Fort Meade, MD  20755-6709
   USA

   EMail: msalter@restarea.ncsc.mil
```
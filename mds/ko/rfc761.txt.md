

```text
RFC: 761
IEN: 129
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                              DOD STANDARD
                                    
                     TRANSMISSION CONTROL PROTOCOL
                                    
                                    
                                    
                              January 1980
```

준비

- 국방 고급 연구 프로젝트 기관 정보 처리 기술 사무소 1400 Wilson Boulevard Arlington, Virginia 22209

```text
                                   by

                     Information Sciences Institute
                   University of Southern California
                           4676 Admiralty Way
                   Marina del Rey, California  90291
January 1980                                                            
                                           Transmission Control Protocol
```

- 목차

```text
    PREFACE ........................................................ iii
```

```text
1.  INTRODUCTION ..................................................... 1
  1.1  Motivation .................................................... 1
  1.2  Scope ......................................................... 2
  1.3  About This Document ........................................... 2
  1.4  Interfaces .................................................... 3
  1.5  Operation ..................................................... 3
2.  PHILOSOPHY ....................................................... 7
  2.1  Elements of the Internetwork System ........................... 7
  2.2  Model of Operation ............................................ 7
  2.3  The Host Environment .......................................... 8
  2.4  Interfaces .................................................... 9
  2.5  Relation to Other Protocols ................................... 9
  2.6  Reliable Communication ....................................... 10
  2.7  Connection Establishment and Clearing ........................ 10
  2.8  Data Communication ........................................... 12
  2.9  Precedence and Security ...................................... 13
  2.10 Robustness Principle ......................................... 13
3.  FUNCTIONAL SPECIFICATION ........................................ 15
  3.1  Header Format ................................................ 15
  3.2  Terminology .................................................. 19
  3.3  Sequence Numbers ............................................. 24
  3.4  Establishing a connection .................................... 29
  3.5  Closing a Connection ......................................... 35
  3.6  Precedence and Security ...................................... 38
  3.7  Data Communication ........................................... 38
  3.8  Interfaces ................................................... 42
  3.9  Event Processing ............................................. 52
GLOSSARY ............................................................ 75
REFERENCES .......................................................... 83
```

```text
                                                                [Page i]

                                                            January 1980
Transmission Control Protocol

[Page ii]                                                               

January 1980                                                            
                                           Transmission Control Protocol

                                PREFACE
```

이 문서에서는 DoD 표준 전송 제어 프로토콜에 대해 설명합니다.
\(TCP\). ARPA TCP에는 8개의 이전 버전이 있습니다.
이 표준의 기반이 되는 사양 및 현재 텍스트
그들로부터 많은 것을 끌어냅니다. 이번 작업에는 많은 기여자가 있었습니다.
개념적인 측면에서도 그렇고, 텍스트 측면에서도 그렇습니다. 이 버전
보안, 구획화 및 우선순위 추가를 통합합니다.
개념을 TCP 사양에 추가합니다.

```text
                                                           Jon Postel

                                                           Editor

                                                              [Page iii]

January 1980 
RFC:761
IEN:129
Replaces:  IENs 124, 112,
81, 55, 44, 40, 27, 21, 5

                              DOD STANDARD

                     TRANSMISSION CONTROL PROTOCOL

                            1.  INTRODUCTION
```

전송 제어 프로토콜\(TCP\)은 매우 높은 용도로 사용되도록 고안되었습니다.
패킷 교환 컴퓨터의 호스트 간 안정적인 호스트 간 프로토콜
통신 네트워크, 특히 이러한 상호 연결된 시스템에서
네트워크.

이 문서는 다음에서 수행할 기능을 설명합니다.
전송 제어 프로토콜, 이를 구현하는 프로그램 및 해당 프로토콜
서비스를 필요로 하는 프로그램 또는 사용자에 대한 인터페이스.

---
### **1.1.  Motivation**

컴퓨터 통신 시스템은 군대, 정부 및 민간 환경에서 점점 더 중요한 역할을 하고 있습니다. 이 문서는 주로 군용 컴퓨터 통신 요구 사항, 특히 통신이 불안정할 때의 견고성과 혼잡 시 가용성에 초점을 맞추고 있지만 이러한 문제 중 상당수는 민간 및 정부 부문에서도 발견됩니다.

전략적 및 전술적 컴퓨터 통신 네트워크가 개발되고 배치됨에 따라 이를 상호 연결하는 수단을 제공하고 광범위한 응용 프로그램을 지원할 수 있는 표준 프로세스 간 통신 프로토콜을 제공하는 것이 필수적입니다. 이러한 표준의 필요성을 예상하여 국방부 연구 및 엔지니어링 차관은 여기에 설명된 전송 제어 프로토콜\(TCP\)이 DoD 전체 프로세스 간 통신 프로토콜 표준화의 기초가 될 것이라고 선언했습니다.

TCP는 다중 네트워크 응용 프로그램을 지원하는 계층화된 프로토콜 계층 구조에 적합하도록 설계된 연결 지향 종단 간 신뢰할 수 있는 프로토콜입니다. TCP는 별개이지만 상호 연결된 컴퓨터 통신 네트워크에 연결된 호스트 컴퓨터의 프로세스 쌍 간에 안정적인 프로세스 간 통신을 제공합니다. TCP 계층 아래의 통신 프로토콜의 신뢰성에 대한 가정은 거의 없습니다. TCP는 하위 수준 프로토콜에서 간단하고 잠재적으로 신뢰할 수 없는 데이터그램 서비스를 얻을 수 있다고 가정합니다. 원칙적으로 TCP는 유선 연결에서 패킷 교환 또는 회선 교환 네트워크에 이르는 광범위한 통신 시스템에서 작동할 수 있어야 합니다.

TCP는 \[1\]에서 Cerf와 Kahn이 처음 설명한 개념을 기반으로 합니다. TCP는 TCP가 인터넷 데이터그램 "봉투"에 포함된 정보의 가변 길이 세그먼트를 송수신하는 방법을 제공하는 기본 인터넷 프로토콜\[2\] 바로 위의 계층화된 프로토콜 아키텍처에 적합합니다. 인터넷 데이터그램은 서로 다른 네트워크에서 소스 및 대상 TCP의 주소를 지정하는 수단을 제공합니다. 인터넷 프로토콜은 또한 여러 네트워크와 상호 연결 게이트웨이를 통해 전송 및 전달을 달성하는 데 필요한 TCP 세그먼트의 조각화 또는 재조립을 처리합니다. 인터넷 프로토콜은 또한 TCP 세그먼트의 우선 순위, 보안 분류 및 구획에 대한 정보를 전달하므로 이 정보는 여러 네트워크에서 엔드 투 엔드로 전달될 수 있습니다.

```text
                           Protocol Layering

                        +---------------------+
                        |     higher-level    |
                        +---------------------+
                        |        TCP          |
                        +---------------------+
                        |  internet protocol  |
                        +---------------------+
                        |communication network|
                        +---------------------+

                                Figure 1
```

이 문서의 대부분은 호스트 컴퓨터에서 더 높은 수준의 프로토콜과 함께 상주하는 TCP 구현의 맥락에서 작성되었습니다. 실제로 많은 컴퓨터 시스템은 TCP 및 인터넷 프로토콜 계층과 네트워크 특정 소프트웨어를 수용하는 프런트 엔드 컴퓨터를 통해 네트워크에 연결됩니다. TCP 사양은 적절한 호스트-프론트 엔드 프로토콜이 구현되는 한 프런트 엔드 사례에서도 구현 가능한 것으로 보이는 상위 수준 프로토콜에 대한 인터페이스를 설명합니다.

---
### **1.2.  Scope**

TCP는 다중 네트워크 환경에서 안정적인 프로세스 간 통신 서비스를 제공하기 위한 것입니다. TCP는 여러 네트워크에서 일반적으로 사용되는 호스트 간 프로토콜입니다.

---
### **1.3.  About this Document**

```text
  This document represents a specification of the behavior required of
  any TCP implementation, both in its interactions with higher level
  protocols and in its interactions with other TCPs.  The rest of this
```

섹션은 프로토콜 인터페이스 및 작동에 대한 매우 간략한 보기를 제공합니다. 섹션 2에서는 TCP 설계의 철학적 기반을 요약합니다. 섹션 3에서는 다양한 이벤트\(새 세그먼트 도착, 사용자 호출, 오류 등\)가 발생할 때 TCP에 필요한 조치에 대한 자세한 설명과 TCP 세그먼트의 형식에 대한 세부 정보를 모두 제공합니다.

---
### **1.4.  Interfaces**

TCP는 한쪽에서 사용자 또는 응용 프로그램 프로세스에 연결하고 다른 쪽에서 인터넷 프로토콜과 같은 하위 수준 프로토콜에 연결합니다.

애플리케이션 프로세스와 TCP 사이의 인터페이스가 합리적으로 자세히 설명되어 있습니다. 이 인터페이스는 운영 체제가 파일을 조작하기 위해 애플리케이션 프로세스에 제공하는 호출과 매우 유사한 일련의 호출로 구성됩니다. 예를 들어, 연결을 열고 닫는 호출, 설정된 연결에서 편지를 보내고 받는 호출이 있습니다. 또한 TCP는 애플리케이션 프로그램과 비동기적으로 통신할 수 있을 것으로 예상됩니다. 특정 운영 체제 환경에 적합한 인터페이스를 설계하기 위해 TCP 구현자에게는 상당한 자유가 허용되지만 유효한 구현을 위해서는 TCP/사용자 인터페이스에 최소한의 기능이 필요합니다.

TCP와 하위 수준 프로토콜 간의 인터페이스는 기본적으로 두 수준이 서로 정보를 비동기적으로 전달할 수 있는 메커니즘이 있다고 가정하는 것을 제외하고는 지정되지 않습니다. 일반적으로 이 인터페이스를 지정하는 하위 수준 프로토콜을 기대합니다. TCP는 상호 연결된 네트워크의 매우 일반적인 환경에서 작동하도록 설계되었습니다. 이 문서 전체에서 가정되는 하위 수준 프로토콜은 인터넷 프로토콜\[2\]입니다.

---
### **1.5.  Operation**

위에서 언급한 바와 같이 TCP의 주요 목적은 신뢰할 수 있고 안전한 논리 회로 또는 프로세스 쌍 간의 연결 서비스를 제공하는 것입니다. 신뢰성이 낮은 인터넷 통신 시스템 위에서 이 서비스를 제공하려면 다음 영역의 시설이 필요합니다.

```text
    Basic Data Transfer
    Reliability
    Flow Control
    Multiplexing
    Connections
    Precedence and Security
```

이러한 각 영역에서 TCP의 기본 작동은 다음 단락에 설명되어 있습니다.

```text
  Basic Data Transfer:
```

TCP는 인터넷 시스템을 통한 전송을 위해 일부 수의 옥텟을 세그먼트로 패키징하여 사용자 간에 각 방향으로 연속적인 옥텟 스트림을 전송할 수 있습니다. 이 스트림 모드에서 TCP는 편의에 따라 데이터를 차단하고 전달할 시기를 결정합니다.

기록 중심 서비스를 원하는 사용자의 경우 TCP는 사용자가 전송을 위해 편지라는 기록을 제출하도록 허용합니다. 송신 사용자가 레코드 경계\(문자 끝\)를 표시하면 TCP는 해당 지점까지의 데이터를 수신자에게 즉시 전달하고 전달합니다.

```text
  Reliability:
```

TCP는 인터넷 통신 시스템에 의해 손상, 손실, 복제 또는 순서 없이 전달된 데이터로부터 복구해야 합니다. 이는 전송된 각 옥텟에 시퀀스 번호를 할당하고 수신 TCP에서 긍정적인 승인\(ACK\)을 요구함으로써 달성됩니다. 시간 초과 간격 내에 ACK를 받지 못하면 데이터가 다시 전송됩니다. 수신기에서 시퀀스 번호는 잘못된 순서로 수신될 수 있는 세그먼트를 올바르게 정렬하고 중복을 제거하는 데 사용됩니다. 손상은 전송된 각 세그먼트에 체크섬을 추가하고 수신자에서 확인하고 손상된 세그먼트를 버리는 방식으로 처리됩니다.

TCP가 계속 제대로 작동하고 인터넷 시스템이 완전히 분할되지 않는 한 전송 오류는 사용자에게 영향을 미치지 않습니다. TCP는 인터넷 통신 시스템 오류를 복구합니다.

```text
  Flow Control:
```

TCP는 송신자가 보낸 데이터의 양을 수신자가 제어할 수 있는 수단을 제공합니다. 이는 성공적으로 수신된 마지막 세그먼트 이후에 허용 가능한 시퀀스 번호 범위를 나타내는 모든 ACK와 함께 "창"을 반환함으로써 달성됩니다. 스트림 모드의 경우 창에는 발신자가 추가 허가를 받기 전에 전송할 수 있는 허용된 옥텟 수가 표시됩니다. 기록 모드의 경우 창에는 보낸 사람이 사용할 수 있는 허용된 버퍼 공간 크기가 표시됩니다. 이는 문자 크기와 버퍼 크기가 일치하지 않는 경우 전송되는 데이터 옥텟 수보다 클 수 있습니다.

```text
  Multiplexing:
```

단일 호스트 내의 많은 프로세스가 동시에 TCP 통신 기능을 사용할 수 있도록 하기 위해 TCP는 각 호스트 내에 일련의 주소 또는 포트를 제공합니다. 인터넷 통신 계층의 네트워크 및 호스트 주소와 연결되어 소켓을 형성합니다. 소켓 쌍은 각 연결을 고유하게 식별합니다. 즉, 하나의 소켓을 여러 연결에서 동시에 사용할 수 있습니다.

프로세스에 대한 포트 바인딩은 각 호스트에서 독립적으로 처리됩니다. 그러나 대중에게 알려진 고정 소켓에 자주 사용되는 프로세스\(예: "로거" 또는 시분할 서비스\)를 연결하는 것이 유용합니다. 그런 다음 알려진 주소를 통해 이러한 서비스에 액세스할 수 있습니다. 다른 프로세스의 포트 주소를 설정하고 학습하려면 보다 동적인 메커니즘이 필요할 수 있습니다.

```text
  Connections:
```

위에서 설명한 안정성 및 흐름 제어 메커니즘은 TCP가 각 데이터 스트림에 대한 특정 상태 정보를 초기화하고 유지 관리할 것을 요구합니다. 소켓, 시퀀스 번호 및 창 크기를 포함하여 이 정보의 조합을 연결이라고 합니다. 각 연결은 양쪽을 식별하는 한 쌍의 소켓으로 고유하게 지정됩니다.

두 프로세스가 통신하려면 TCP가 먼저 연결을 설정해야 합니다\(양쪽에서 상태 정보 초기화\). 통신이 완료되면 연결이 종료되거나 종료되어 리소스를 다른 용도로 사용할 수 있습니다.

신뢰할 수 없는 호스트 간에 그리고 신뢰할 수 없는 인터넷 통신 시스템을 통해 연결을 설정해야 하므로 잘못된 연결 초기화를 방지하기 위해 시계 기반 시퀀스 번호가 있는 핸드셰이크 메커니즘이 사용됩니다.

우선 순위 및 보안:

TCP 사용자는 통신의 보안 및 우선 순위를 나타낼 수 있습니다. 이러한 기능이 필요하지 않을 때 사용할 기본값이 제공됩니다.

```text
    

                             2.  PHILOSOPHY
```

---
### **2.1.  Elements of the Internetwork System**

인터네트워크 환경은 게이트웨이를 통해 상호 연결된 네트워크에 연결된 호스트로 구성됩니다. 여기서 네트워크는 로컬 네트워크\(예: ETHERNET\) 또는 대규모 네트워크\(예: ARPANET\)일 수 있지만 어떤 경우든 패킷 교환 기술을 기반으로 한다고 가정합니다. 메시지를 생성하고 소비하는 활성 에이전트는 프로세스입니다. 네트워크, 게이트웨이 및 호스트의 다양한 수준의 프로토콜은 프로세스 포트 간의 논리적 연결에서 양방향 데이터 흐름을 제공하는 프로세스 간 통신 시스템을 지원합니다.

우리는 구체적으로 데이터가 일련의 네트워크를 통해 호스트에서 호스트로 전송된다고 가정합니다. 네트워크라고 하면 PSN\(패킷 교환 네트워크\)이 떠오릅니다. 회선 교환 네트워크나 이 둘의 하이브리드 조합도 사용할 수 있으므로 이러한 가정은 아마도 불필요할 것입니다. 그러나 구체적으로 말하자면 호스트가 PSN의 하나 이상의 패킷 스위치에 연결되어 있다고 명시적으로 가정합니다.

여기서 패킷이라는 용어는 일반적으로 호스트와 패킷 스위치 사이의 하나의 트랜잭션 데이터를 의미하는 데 사용됩니다. 네트워크의 패킷 스위치 간에 교환되는 데이터 블록의 형식은 일반적으로 우리가 관심을 두지 않습니다.

호스트는 네트워크에 연결된 컴퓨터이며 통신 네트워크의 관점에서 보면 패킷의 소스와 목적지입니다. 프로세스는 호스트 컴퓨터에서 활성 요소로 간주됩니다\(프로세스를 실행 중인 프로그램으로 정의하는 일반적인 정의에 따름\). 터미널과 파일 또는 기타 I/O 장치도 프로세스를 사용하여 서로 통신하는 것으로 간주됩니다. 따라서 모든 통신은 프로세스 간 통신으로 간주됩니다.

프로세스는 자신과 다른 프로세스\(또는 프로세스\) 사이의 여러 통신 스트림을 구별해야 할 수 있으므로 각 프로세스에는 다른 프로세스의 포트와 통신하는 데 사용되는 여러 포트가 있을 수 있다고 가정합니다.

---
### **2.2.  Model of Operation**

프로세스는 TCP를 호출하고 데이터 버퍼를 인수로 전달하여 데이터를 전송합니다. TCP는 이러한 버퍼의 데이터를 세그먼트로 패키징하고 인터넷 모듈을 호출하여 각 세그먼트를 대상 TCP로 전송합니다. 수신 TCP는 세그먼트의 데이터를 수신 사용자의 버퍼에 놓고 수신 사용자에게 알립니다. TCP는 신뢰할 수 있는 주문 데이터 전송을 보장하기 위해 사용하는 세그먼트에 제어 정보를 포함합니다.

인터넷 통신 모델은 로컬 네트워크에 인터페이스를 제공하는 각 TCP와 연결된 인터넷 프로토콜 모듈이 있다는 것입니다. 이 인터넷 모듈은 인터넷 데이터그램 내부의 TCP 세그먼트를 패키징하고 이러한 데이터그램을 대상 인터넷 모듈 또는 중간 게이트웨이로 라우팅합니다. 로컬 네트워크를 통해 데이터그램을 전송하기 위해 로컬 네트워크 패킷에 포함됩니다.

패킷 스위치는 로컬 패킷을 대상 인터넷 모듈로 전달하기 위해 추가 패키징, 단편화 또는 기타 작업을 수행할 수 있습니다.

네트워크 사이의 게이트웨이에서 인터넷 데이터그램은 로컬 패킷에서 "언래핑"되고 인터넷 데이터그램이 다음에 이동해야 하는 네트워크를 결정하기 위해 검사됩니다. 그런 다음 인터넷 데이터그램은 다음 네트워크에 적합한 로컬 패킷으로 "래핑"되어 다음 게이트웨이 또는 최종 목적지로 라우팅됩니다.

게이트웨이는 다음 네트워크를 통한 전송에 필요한 경우 인터넷 데이터그램을 더 작은 인터넷 데이터그램 조각으로 분할하는 것이 허용됩니다. 이를 위해 게이트웨이는 일련의 인터넷 데이터그램을 생성합니다. 각각은 조각을 가지고 있습니다. 조각은 중간 게이트웨이에서 더 작은 조각으로 분할될 수 있습니다. 인터넷 데이터그램 조각 형식은 대상 인터넷 모듈이 조각을 인터넷 데이터그램으로 재조립할 수 있도록 설계되었습니다.

대상 인터넷 모듈은 데이터그램에서 세그먼트를 풀고\(필요한 경우 데이터그램을 재조립한 후\) 대상 TCP로 전달합니다.

이 간단한 작업 모델은 많은 세부 사항을 얼버무립니다. 중요한 기능 중 하나는 서비스 유형입니다. 이는 게이트웨이\(또는 인터넷 모듈\)에 정보를 제공하여 다음 네트워크 통과에 사용할 서비스 매개변수를 선택하도록 안내합니다. 서비스 정보 유형에는 데이터그램의 우선 순위가 포함됩니다. 데이터그램은 또한 보안 고려 사항을 위해 데이터그램을 적절하게 분리하기 위해 다단계 보안 환경에서 작동하는 호스트 및 게이트웨이를 허용하는 보안 정보를 전달할 수 있습니다.

---
### **2.3.  The Host Environment**

TCP는 시분할 운영 체제의 모듈로 가정됩니다. 사용자는 파일 시스템에 액세스하는 것처럼 TCP에 액세스합니다. TCP는 예를 들어 데이터 구조를 관리하기 위해 다른 운영 체제 기능을 호출할 수 있습니다. 네트워크에 대한 실제 인터페이스는 장치 드라이버 모듈에 의해 제어되는 것으로 가정됩니다. TCP는 네트워크 장치 드라이버를 직접 호출하지 않고 대신 장치 드라이버를 호출할 수 있는 인터넷 데이터그램 프로토콜 모듈을 호출합니다.

여기서는 프로세스가 호스트 운영 체제에서 지원된다고 가정하지만 TCP 메커니즘은 프런트엔드 프로세서에서 TCP 구현을 배제하지 않습니다. 그러나 이러한 구현에서 호스트-프론트 엔드 프로토콜은 위에 설명된 TCP 사용자 인터페이스 유형을 지원하는 기능을 제공해야 합니다.

---
### **2.4.  Interfaces**

TCP/사용자 인터페이스는 연결을 열거나 닫거나, 데이터를 보내거나 받거나, 연결에 대한 STATUS를 얻기 위해 TCP에서 사용자가 만든 호출을 제공합니다. 이러한 호출은 예를 들어 파일 열기, 읽기 및 닫기 호출과 같이 운영 체제의 사용자 프로그램에서 발생하는 다른 호출과 같습니다.

TCP/인터넷 인터페이스는 인터넷 시스템의 호스트에 있는 TCP 모듈로 지정된 데이터그램을 송수신하기 위한 호출을 제공합니다. 이러한 호출에는 주소, 서비스 유형, 우선 순위, 보안 및 기타 제어 정보를 전달하기 위한 매개 변수가 있습니다.

---
### **2.5.  Relation to Other Protocols**

다음 다이어그램은 프로토콜 계층에서 TCP의 위치를 ​​보여줍니다.

```text
                                    
       +------+ +-----+ +-----+       +-----+                    
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level 
       +------+ +-----+ +-----+       +-----+                    
             |   |         |             |                       
            +-----+     +-----+       +-----+                    
            | TCP |     | RTP |  ...  |     |  Host Level        
            +-----+     +-----+       +-----+                    
               |           |             |                       
            +-------------------------------+                    
            |      Internet Protocol        |  Gateway Level     
            +-------------------------------+                    
                           |                                     
              +---------------------------+                      
              |   Local Network Protocol  |    Network Level     
              +---------------------------+                      
                           |                                     

                         Protocol Relationships

                               Figure 2.
```

TCP는 더 높은 수준의 프로토콜을 효율적으로 지원할 수 있을 것으로 예상됩니다. ARPANET Telnet\[3\] 또는 AUTODIN II THP와 같은 상위 수준 프로토콜을 TCP에 인터페이스하는 것은 쉬워야 합니다.

---
### **2.6.  Reliable Communication**

TCP 연결에서 전송된 데이터 스트림은 대상에서 순서대로 안정적으로 전달됩니다.

시퀀스 번호와 승인을 사용하여 전송을 안정적으로 수행할 수 있습니다. 개념적으로 데이터의 각 옥텟에는 시퀀스 번호가 할당됩니다. 세그먼트에 있는 데이터의 첫 번째 옥텟의 시퀀스 번호는 해당 세그먼트와 함께 전송되는 시퀀스 번호이며 세그먼트 시퀀스 번호라고 합니다. 세그먼트에는 또한 역방향 전송의 다음 예상 데이터 옥텟의 시퀀스 번호인 승인 번호가 포함됩니다. TCP가 세그먼트를 전송할 때 재전송 대기열에 복사본을 넣고 타이머를 시작합니다. 해당 데이터에 대한 승인이 수신되면 해당 세그먼트가 대기열에서 삭제됩니다. 타이머가 종료되기 전에 승인이 수신되지 않으면 세그먼트가 재전송됩니다.

TCP의 승인은 데이터가 최종 사용자에게 전달되었음을 보장하지 않으며 수신 TCP가 이에 대한 책임을 졌다는 것을 의미할 뿐입니다.

TCP로의 데이터 흐름을 관리하기 위해 흐름 제어 메커니즘이 사용됩니다. 데이터 수신 TCP는 송신 TCP에 창을 보고합니다. 이 창에서는 데이터 수신 TCP가 현재 수신할 준비가 되어 있는 승인 번호부터 시작하여 옥텟 수를 지정합니다.

---
### **2.7.  Connection Establishment and Clearing**

TCP가 처리할 수 있는 별도의 데이터 스트림을 식별하기 위해 TCP는 포트 식별자를 제공합니다. 포트 식별자는 각 운영 체제, TCP 또는 사용자에 의해 독립적으로 선택되므로 고유하지 않을 수 있습니다. 각 TCP에 고유한 주소를 제공하기 위해 TCP를 식별하는 인터넷 주소를 포트 식별자와 연결하여 함께 연결된 모든 네트워크에서 고유한 소켓을 만듭니다.

연결은 끝에 있는 한 쌍의 소켓으로 완전히 지정됩니다. 로컬 소켓은 다른 외부 소켓에 대한 많은 연결에 참여할 수 있습니다. 연결은 양방향으로 데이터를 전달하는 데 사용할 수 있습니다. 즉, "전이중"입니다.

TCP는 원하는 대로 포트를 프로세스와 자유롭게 연결할 수 있습니다. 그러나 모든 구현에는 몇 가지 기본 개념이 필요한 것 같습니다.

TCP가 어떤 방법으로든 "적절한" 프로세스에만 연결하는 잘 알려진 소켓이 있어야 합니다. 우리는 프로세스가 포트를 "소유"할 수 있고 프로세스가 자신이 소유한 포트에서만 연결을 시작할 수 있다고 생각합니다. \(소유권을 구현하는 방법은 로컬 문제이지만 포트 요청 사용자 명령 또는 포트 이름의 상위 비트를 지정된 프로세스와 연결하는 등 포트 그룹을 지정된 프로세스에 고유하게 할당하는 방법을 구상합니다. .\)

연결은 로컬 포트 ​​및 외부 소켓 인수에 의해 OPEN 호출에서 지정됩니다. 그 대가로 TCP는 사용자가 후속 호출에서 연결을 참조하는 \(짧은\) 로컬 연결 이름을 제공합니다. 연결에 관해 기억해야 할 몇 가지 사항이 있습니다. 이 정보를 저장하기 위해 전송 제어 블록\(TCB\)이라는 데이터 구조가 있다고 가정합니다. 한 가지 구현 전략은 로컬 연결 이름이 이 연결에 대한 TCB에 대한 포인터가 되도록 하는 것입니다. OPEN 호출은 또한 연결 설정을 적극적으로 추구할지 아니면 수동적으로 기다릴지 여부를 지정합니다.

수동 OPEN 요청은 프로세스가 연결을 시작하려고 시도하는 대신 들어오는 연결 요청을 수락하려고 함을 의미합니다. 종종 수동 OPEN을 요청하는 프로세스는 모든 호출자의 연결 요청을 수락합니다. 이 경우 모두 0인 외부 소켓이 지정되지 않은 소켓을 나타내는 데 사용됩니다. 지정되지 않은 외부 소켓은 수동 OPEN에서만 허용됩니다.

알려지지 않은 다른 프로세스에 서비스를 제공하려는 서비스 프로세스가 지정되지 않은 외부 소켓을 사용하여 수동 OPEN 요청을 발행할 수 있습니다. 그러면 이 로컬 소켓에 대한 연결을 요청한 모든 프로세스와 연결이 이루어질 수 있습니다. 이 로컬 소켓이 이 서비스와 연관되어 있는 것으로 알려지면 도움이 될 것입니다.

잘 알려진 소켓은 소켓 주소를 표준 서비스와 먼저 연결하는 편리한 메커니즘입니다. 예를 들어 "Telnet-Server" 프로세스는 특정 소켓에 영구적으로 할당될 수 있으며 다른 소켓은 파일 전송, 원격 작업 항목, 텍스트 생성기, 에코어 및 싱크 프로세스용으로 예약될 수 있습니다\(마지막 세 개는 테스트용임\). . 새로 생성된 서비스가 제공되는 특정 소켓을 반환하는 "조회" 서비스에 액세스하기 위해 소켓 주소가 예약될 수 있습니다. 잘 알려진 소켓의 개념은 TCP 사양의 일부이지만 서비스에 대한 소켓 할당은 이 사양을 벗어납니다.

```text
  Processes can issue passive OPENs and wait for matching calls from
  other processes and be informed by the TCP when connections have been
  established.  Two processes which issue calls to each other at the
  same time are correctly connected.  This flexibility is critical for
```

구성 요소가 서로 비동기적으로 작동하는 분산 컴퓨팅 지원.

로컬 요청과 수신 세그먼트의 소켓을 일치시키는 경우에는 두 가지가 있습니다. 첫 번째 경우에는 로컬 요청이 외부 소켓을 완전히 지정했습니다. 이 경우 일치 항목이 정확해야 합니다. 두 번째 경우에는 로컬 요청으로 인해 외부 소켓이 지정되지 않은 상태로 남아 있습니다. 이 경우 로컬 소켓이 일치하는 한 모든 외부 소켓이 허용됩니다.

동일한 로컬 소켓에 여러 개의 보류 중인 수동 OPEN\(TCB에 기록됨\)이 있는 경우, 들어오는 세그먼트는 지정되지 않은 외부 소켓이 있는 요청을 선택하기 전에 해당 요청이 존재하는 경우 세그먼트의 특정 외부 소켓이 있는 요청과 일치해야 합니다. 소켓.

연결을 설정하고 해제하는 절차에서는 동기화\(SYN\) 및 finis\(FIN\) 제어 플래그를 활용하고 세 가지 메시지를 교환합니다. 이 교환을 3자간 악수라고 합니다\[4\].

연결은 사용자 OPEN 명령에 의해 생성된 SYN 및 대기 중인 TCB 항목을 포함하는 도착 세그먼트의 랑데부에 의해 시작됩니다. 로컬 소켓과 외부 소켓의 일치에 따라 연결이 시작된 시기가 결정됩니다. 시퀀스 번호가 양방향으로 동기화되면 연결이 "설정"됩니다.

연결 해제에는 세그먼트 교환도 포함되며, 이 경우에는 FIN 제어 플래그를 전달합니다.

---
### **2.8.  Data Communication**

연결을 통해 흐르는 데이터는 옥텟 스트림 또는 레코드 시퀀스로 간주될 수 있습니다. TCP에서는 레코드를 문자라고 부르며 길이가 가변적입니다. 송신 사용자는 각 SEND 호출에서 해당 호출의 데이터가 문자 끝 매개변수의 설정에 따라 문자를 완성하는지 여부를 나타냅니다.

편지의 길이는 목적지로 전송되기 전에 여러 부분으로 나누어야 할 정도일 수 있습니다. 우리는 세그먼트가 수신 프로세스로 전달되기 전에 일반적으로 편지로 재조립된다고 가정합니다. 세그먼트에는 문자 전체 또는 일부가 포함될 수 있지만 세그먼트에는 두 개 이상의 문자로 구성된 부분이 포함되지 않습니다. 문자의 끝은 세그먼트에 EOL 제어 플래그가 나타나는 것으로 표시됩니다. 송신 TCP는 송신 사용자로부터 데이터를 수집하고 편의에 따라 해당 데이터를 세그먼트로 보낼 수 있습니다. 문자의 끝이 신호될 때까지 전송되지 않은 모든 데이터를 보내야 합니다. 수신 TCP에 완전한 문자가 있는 경우 문자를 수신 프로세스에 전달하기 전에 송신 TCP에서 더 많은 데이터를 기다리면 안 됩니다.

전송된 문자와 TCP/사용자 인터페이스를 통과하는 데이터 버퍼 사용 사이에는 결합이 있습니다. EOL\(End-of-Letter\) 플래그가 수신 사용자의 버퍼에 있는 데이터와 연관될 때마다 버퍼가 채워지지 않은 경우에도 처리를 위해 버퍼가 사용자에게 반환됩니다. 문자가 사용자의 버퍼보다 ​​긴 경우 문자는 버퍼 크기 단위로 사용자에게 전달되며 마지막 문자는 부분적으로만 가득 찰 수 있습니다. 연결이 설정될 때 수신 TCP의 버퍼 크기가 송신 TCP에 전달될 수 있습니다.

TCP는 트래픽이 포화되거나 과부하되는 것을 방지하기 위해 연결의 세그먼트 흐름을 규제하는 역할을 합니다. 이는 창 흐름 제어 메커니즘을 사용하여 수행됩니다. 데이터 수신 TCP는 데이터 수신 TCP가 현재 받아들일 준비가 되어 있는 데이터 옥텟의 시퀀스 번호 범위인 창을 데이터 송신 TCP에 보고합니다.

또한 TCP는 수신자가 현재 읽고 있는 것보다 데이터 스트림의 어느 지점에 긴급 데이터가 있다는 것을 데이터 수신자에게 전달하는 수단을 제공합니다. TCP는 보류 중인 긴급 데이터에 대한 알림을 받은 사용자가 구체적으로 수행하는 작업을 정의하려고 시도하지 않지만 일반적으로 수신 프로세스는 최종 긴급 데이터를 신속하게 읽기 위한 조치를 취해야 한다는 것입니다.

---
### **2.9.  Precedence and Security**

TCP는 인터넷 프로토콜 유형의 서비스 필드와 보안 옵션을 활용하여 TCP 사용자에게 연결별로 우선순위와 보안을 제공합니다. 모든 TCP 모듈이 반드시 다단계 보안 환경에서 작동하는 것은 아니며 일부는 분류되지 않은 사용으로만 제한될 수 있으며 다른 일부는 하나의 보안 수준 및 구획에서만 작동할 수 있습니다. 결과적으로 사용자에 대한 일부 TCP 구현 및 서비스는 다중 레벨 보안 사례의 하위 집합으로 제한될 수 있습니다.

다중 레벨 보안 환경에서 작동하는 TCP 모듈은 보안, 구획 및 우선 순위를 사용하여 나가는 세그먼트를 적절하게 표시해야 합니다. 이러한 TCP 모듈은 또한 사용자나 Telnet 또는 THP와 같은 더 높은 수준의 프로토콜에 원하는 보안 수준, 구획 및 연결 우선 순위를 지정할 수 있는 인터페이스를 제공해야 합니다.

---
### **2.10.  Robustness Principle**

TCP 구현은 견고성의 일반 원칙을 따라야 합니다. 즉, 수행하는 작업에는 보수적이고 다른 사람의 의견을 수용하는 데에는 자유로워야 합니다.

```text
  

                      3.  FUNCTIONAL SPECIFICATION
```

---
### **3.1.  Header Format**

TCP 세그먼트는 인터넷 데이터그램으로 전송됩니다. 인터넷 프로토콜 헤더는 소스 및 대상 호스트 주소를 포함하여 여러 정보 필드를 전달합니다\[2\]. TCP 헤더는 인터넷 헤더 다음에 TCP 프로토콜에 특정한 정보를 제공합니다. 이 분할은 TCP 이외의 호스트 수준 프로토콜의 존재를 허용합니다.

```text
  TCP Header Format

                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|E|R|S|F|                               |
   | Offset| Reserved  |R|C|O|S|Y|I|            Window             |
   |       |           |G|K|L|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            TCP Header Format
```

- 하나의 눈금 표시는 하나의 비트 위치를 나타냅니다.

```text
                               Figure 3.

  Source Port:  16 bits
```

소스 포트 번호입니다.

```text
  Destination Port:  16 bits
```

대상 포트 번호입니다.

```text
  Sequence Number:  32 bits
```

이 세그먼트에 있는 첫 번째 데이터 옥텟의 시퀀스 번호입니다\(SYN이 있는 경우 제외\).

```text
  Acknowledgment Number:  32 bits
```

ACK 제어 비트가 설정되면 이 필드에는 세그먼트의 송신자가 수신할 것으로 예상되는 다음 시퀀스 번호의 값이 포함됩니다. 연결이 설정되면 항상 전송됩니다.

```text
  Data Offset:  4 bits
```

TCP 헤더의 32비트 단어 수입니다. 이는 데이터가 시작되는 위치를 나타냅니다. 옵션을 포함하는 TCP 헤더는 32비트 길이의 정수이다.

```text
  Reserved:  6 bits
```

향후 사용을 위해 예약되었습니다. 0이어야 합니다.

제어 비트: 8비트\(왼쪽에서 오른쪽으로\):

```text
    URG:  Urgent Pointer field significant
    ACK:  Acknowledgment field significant
    EOL:  End of Letter
    RST:  Reset the connection
    SYN:  Synchronize sequence numbers
    FIN:  No more data from sender

  Window:  16 bits
```

이 세그먼트의 송신자가 수락할 의향이 있는 승인 필드에 표시된 것으로 시작하는 데이터 옥텟의 수입니다.

```text
  Checksum:  16 bits
```

체크섬 필드는 헤더와 텍스트에 있는 모든 16비트 단어의 1의 보수 합계에 대한 16비트 1의 보수입니다. 세그먼트에 체크섬을 계산할 홀수 개의 헤더 및 텍스트 옥텟이 포함된 경우 마지막 옥텟의 오른쪽이 0으로 채워져 체크섬 목적을 위한 16비트 워드를 형성합니다. 패드는 세그먼트의 일부로 전송되지 않습니다. 체크섬을 계산하는 동안 체크섬 필드 자체는 0으로 대체됩니다.

```text
    The checksum also covers a 96 bit pseudo header conceptually
    prefixed to the TCP header.  This pseudo header contains the Source
```

주소, 대상 주소, 프로토콜 및 TCP 길이. 이는 잘못 라우팅된 세그먼트에 대한 TCP 보호를 제공합니다. 이 정보는 인터넷 프로토콜을 통해 전달되며 IP의 TCP에 의한 호출 결과나 인수로 TCP/네트워크 인터페이스를 통해 전송됩니다.

```text
                     +--------------------------+
                     |      Source Address      |
                     +--------------------------+
                     |    Destination Address   |
                     +--------------------------+
                     | zero | PTCL | TCP Length |
                     +--------------------------+
```

- TCP 길이는 TCP 헤더에 옥텟 단위의 데이터 길이를 더한 값입니다\(명시적으로 전송되는 수량은 아니지만 전체 길이와 헤더 길이로 계산됩니다\).

```text
  Urgent Pointer:  16 bits
```

이 필드는 긴급 포인터의 현재 값을 이 세그먼트의 시퀀스 번호에서 양수 오프셋으로 전달합니다. 긴급 포인터는 긴급 데이터 뒤에 오는 옥텟의 시퀀스 번호를 가리킵니다. 이 필드는 URG 제어 비트가 설정된 세그먼트에서만 해석되어야 합니다.

```text
  Options:  variable
```

옵션은 TCP 헤더 끝에서 공간을 차지할 수 있으며 길이가 8비트의 배수입니다. 모든 옵션은 체크섬에 포함됩니다. 옵션은 모든 옥텟 경계에서 시작할 수 있습니다. 옵션 형식에는 두 가지 경우가 있습니다.

- 사례 1: 옵션 종류의 단일 옥텟.

- 사례 2: 옵션 종류의 옥텟, 옵션 길이의 옥텟 및 실제 옵션 데이터 옥텟.

옵션 길이는 옵션 데이터 옥텟뿐만 아니라 옵션 종류 및 옵션 길이의 두 옥텟을 계산합니다.

옵션 목록은 데이터 오프셋 필드가 암시하는 것보다 짧을 수 있습니다. 옵션 끝 옵션 이후의 헤더 내용은 헤더 패딩\(즉, 0\)이어야 합니다.

TCP는 모든 옵션을 구현해야 합니다.

현재 정의된 옵션에는 다음이 포함됩니다\(종류는 8진수로 표시됨\).

```text
      Kind     Length    Meaning
      ----     ------    -------
       0         -       End of option list.
       1         -       No-Operation.
      100        -       Reserved.
      105        4       Buffer Size.
      

    Specific Option Definitions
```

- 옵션 목록 끝

```text
        +--------+
        |00000000|
        +--------+
         Kind=0
```

- 이 옵션 코드는 옵션 목록의 끝을 나타냅니다. 이것은 데이터 오프셋 필드에 따라 TCP 헤더의 끝과 일치하지 않을 수 있습니다. 이것은 각 옵션의 끝이 아니라 모든 옵션의 끝에서 사용되며 옵션의 끝이 TCP 헤더의 끝과 일치하지 않는 경우에만 사용해야 합니다.

```text
      No-Operation

        +--------+
        |00000001|
        +--------+
         Kind=1
```

- 이 옵션 코드는 예를 들어 단어 경계에서 후속 옵션의 시작을 정렬하기 위해 옵션 사이에 사용될 수 있습니다. 발신자가 이 옵션을 사용한다는 보장이 없으므로 수신자는 단어 경계에서 시작하지 않더라도 옵션을 처리할 준비가 되어 있어야 합니다.

```text
      Buffer Size

        +--------+--------+---------+--------+
        |01000101|00000100|    buffer size   |
        +--------+--------+---------+--------+
         Kind=105 Length=4

        Buffer Size Option Data:  16 bits
```

- 이 옵션이 있으면 이 세그먼트를 보내는 TCP에서 수신 버퍼 크기를 전달합니다. 이 필드는 초기 연결 요청\(예: SYN 제어 비트가 설정된 세그먼트\)에서만 전송되어야 합니다. 이 옵션을 사용하지 않으면 기본 버퍼 크기는 1옥텟으로 가정됩니다.

```text
  Padding:  variable
```

TCP 헤더 패딩은 TCP 헤더가 끝나고 데이터가 32비트 경계에서 시작되도록 하는 데 사용됩니다. 패딩은 0으로 구성됩니다.

---
### **3.2.  Terminology**

TCP 작동에 대해 많은 논의를 하기 전에 몇 가지 자세한 용어를 소개해야 합니다. TCP 연결을 유지하려면 여러 변수를 기억해야 합니다. 이러한 변수는 전송 제어 블록\(TCB\)이라는 연결 레코드에 저장된다고 생각합니다. TCB에 저장된 변수 중에는 로컬 및 원격 소켓 번호, 연결의 보안 및 우선 순위, 사용자의 송신 및 수신 버퍼에 대한 포인터, 재전송 큐 및 현재 세그먼트에 대한 포인터가 있습니다. 또한 송신 및 수신 시퀀스 번호와 관련된 여러 변수가 TCB에 저장됩니다.

```text
    Send Sequence Variables

      SND.UNA - send unacknowledged
      SND.NXT - send sequence
      SND.WND - send window
      SND.BS  - send buffer size
      SND.UP  - send urgent pointer
      SND.WL  - send sequence number used for last window update
      SND.LBB - send last buffer beginning
      ISS     - initial send sequence number

    Receive Sequence Variables

      RCV.NXT - receive sequence
      RCV.WND - receive window
      RCV.BS  - receive buffer size
      RCV.UP  - receive urgent pointer
      RCV.LBB - receive last buffer beginning
      IRS     - initial receive sequence number
```

다음 다이어그램은 이러한 변수 중 일부를 시퀀스 공간과 관련시키는 데 도움이 될 수 있습니다.

```text
  Send Sequence Space

                   1         2          3          4      
              ----------|----------|----------|---------- 
                     SND.UNA    SND.NXT    SND.UNA        
                                          +SND.WND        

        1 - old sequence numbers which have been acknowledged  
        2 - sequence numbers of unacknowledged data            
        3 - sequence numbers allowed for new data transmission 
        4 - future sequence numbers which are not yet allowed  

                          Send Sequence Space

                               Figure 4.
    
    

  Receive Sequence Space

                       1          2          3      
                   ----------|----------|---------- 
                          RCV.NXT    RCV.NXT        
                                    +RCV.WND        

        1 - old sequence numbers which have been acknowledged  
        2 - sequence numbers allowed for new reception         
        3 - future sequence numbers which are not yet allowed  

                         Receive Sequence Space

                               Figure 5.
    
    
```

현재 세그먼트의 필드에서 값을 가져오는 토론에서 자주 사용되는 일부 변수도 있습니다.

```text
    Current Segment Variables

      SEG.SEQ - segment sequence number
      SEG.ACK - segment acknowledgment number
      SEG.LEN - segment length
      SEG.WND - segment window
      SEG.UP  - segment urgent pointer
      SEG.PRC - segment precedence value
```

연결은 수명 동안 일련의 상태를 통해 진행됩니다. 상태는 LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING 및 가상 상태 CLOSED입니다. CLOSED는 TCB가 없어 연결이 없는 상태를 나타내므로 허구입니다. 간략하게 상태의 의미는 다음과 같습니다.

LISTEN - 원격 TCP 및 포트에서 연결 요청을 기다리는 중임을 나타냅니다.

SYN-SENT - 연결 요청을 보낸 후 일치하는 연결 요청을 기다리는 것을 나타냅니다.

SYN-RECEIVED - 연결 요청을 받고 보낸 후 확인 연결 요청 확인을 기다리는 것을 나타냅니다.

ESTABLISHED - 데이터 세그먼트를 전송하고 수신할 준비가 된 열린 연결을 나타냅니다.

FIN-WAIT-1 - 원격 TCP의 연결 종료 요청 또는 이전에 전송된 연결 종료 요청에 대한 승인을 기다리는 것을 나타냅니다.

FIN-WAIT-2 - 원격 TCP의 연결 종료 요청을 기다리는 것을 나타냅니다.

TIME-WAIT - 원격 TCP가 연결 종료 요청에 대한 승인을 받았는지 확인하기 위해 충분한 시간을 기다리는 것을 나타냅니다.

CLOSE-WAIT - 로컬 사용자의 연결 종료 요청을 기다리는 것을 나타냅니다.

CLOSING - 원격 TCP의 연결 종료 요청 승인을 기다리는 것을 나타냅니다.

CLOSED - 연결 상태가 전혀 없음을 나타냅니다.

TCP 연결은 이벤트에 대한 응답으로 한 상태에서 다른 상태로 진행됩니다. 이벤트는 사용자 호출, OPEN, SEND, RECEIVE, CLOSE, ABORT 및 STATUS입니다. 들어오는 세그먼트, 특히 SYN 및 FIN 플래그를 포함하는 세그먼트; 그리고 시간 초과.

용어집에는 보다 완전한 용어 및 정의 목록이 포함되어 있습니다.

그림 6의 상태 다이어그램은 원인 이벤트 및 결과 동작과 함께 상태 변경만 설명하지만 오류 조건이나 상태 변경과 연결되지 않은 동작은 다루지 않습니다. 이후 섹션에서는 이벤트에 대한 TCP의 반응에 대해 더 자세히 설명합니다.

```text
                                    
                              +---------+ ---------\      active OPEN  
                              |  CLOSED |            \    -----------  
                              +---------+<---------\   \   create TCB  
                                |     ^              \   \  snd SYN    
                   passive OPEN |     |   CLOSE        \   \           
                   ------------ |     | ----------       \   \         
                    create TCB  |     | delete TCB         \   \       
                                V     |                      \   \     
                              +---------+            CLOSE    |    \   
                              |  LISTEN |          ---------- |     |  
                              +---------+          delete TCB |     |  
                   rcv SYN      |     |     SEND              |     |  
                  -----------   |     |    -------            |     V  
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |<-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------                  
   |                  x         |     |     snd ACK                    
   |                            V     V                                
   |  CLOSE                   +---------+                              
   | -------                  |  ESTAB  |                              
   | snd FIN                  +---------+                              
   |                   CLOSE    |     |    rcv FIN                     
   V                  -------   |     |    -------                     
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  CLOSE  |
 | WAIT-1  |------------------           -------------------|   WAIT  |
 +---------+          rcv FIN  \       /   CLOSE            +---------+
   | rcv ACK of FIN   -------   |     |   -------                      
   | --------------   snd ACK   |     |   snd FIN                      
   V        x                   V     V                                
 +---------+                  +---------+                              
 |FINWAIT-2|                  | CLOSING |                              
 +---------+                  +---------+                              
   | rcv FIN                          | rcv ACK of FIN                 
   | -------    Timeout=2MSL          | --------------                 
   V snd ACK    ------------          V   delete TCB                   
 +---------+     delete TCB   +---------+                              
 |TIME WAIT|----------------->| CLOSED  |                              
 +---------+                  +---------+                              

                      TCP Connection State Diagram
                               Figure 6.
```

---
### **3.3.  Sequence Numbers**

설계의 기본 개념은 TCP 연결을 통해 전송되는 모든 데이터 옥텟에 시퀀스 번호가 있다는 것입니다. 모든 옥텟이 시퀀싱되기 때문에 각 옥텟을 확인할 수 있습니다. 채택된 승인 메커니즘은 누적되므로 시퀀스 번호 X의 승인은 X를 제외한 모든 옥텟이 수신되었음을 나타냅니다. 이 메커니즘은 재전송이 있을 때 간단한 중복 감지를 허용합니다. 세그먼트 내 옥텟의 번호 매기기는 헤더 바로 다음의 첫 번째 데이터 옥텟이 가장 낮은 번호가 매겨지고 다음 옥텟이 연속적으로 번호가 매겨지는 것입니다.

실제 시퀀스 번호 공간은 매우 크더라도 유한하다는 점을 기억하는 것이 중요합니다. 이 공간의 범위는 0에서 2\*\*32 - 1입니다. 공간은 유한하므로 시퀀스 번호를 다루는 모든 산술은 모듈로 2\*\*32로 수행되어야 합니다. 이 부호 없는 산술은 2\*\*32 - 1에서 0으로 다시 순환할 때 시퀀스 번호의 관계를 유지합니다. 컴퓨터 모듈로 연산에는 몇 가지 미묘한 부분이 있으므로 이러한 값의 비교를 프로그래밍할 때는 세심한 주의가 필요합니다. TCP가 수행해야 하는 일반적인 종류의 시퀀스 번호 비교는 다음과 같습니다.

\(a\) 확인이 전송되었지만 아직 확인되지 않은 일부 시퀀스 번호를 참조하는지 확인합니다.

\(b\) 세그먼트에 의해 점유된 모든 시퀀스 번호가 승인되었는지 결정\(예: 재전송 대기열에서 세그먼트 제거\).

\(c\) 들어오는 세그먼트가 예상되는 시퀀스 번호를 포함하는지 결정\(즉, 세그먼트가 수신 창과 "겹침"\).

송신 연결에서는 다음과 같은 비교가 필요합니다.

```text
    older sequence numbers                        newer sequence numbers

                                    
        SND.UNA                SEG.ACK                 SND.NXT  
           |                      |                       |     
       ----|----XXXXXXX------XXXXXXXXXX---------XXXXXX----|---- 
           |    |            |    |             |         |     
                |            |                  |               
             Segment 1    Segment 2          Segment 3          

                      <----- sequence space ----->

                   Sending Sequence Space Information

                               Figure 7.

    SND.UNA = oldest unacknowledged sequence number

    SND.NXT = next sequence number to be sent

    SEG.ACK = acknowledgment (next sequence number expected by the
              acknowledging TCP)

    SEG.SEQ = first sequence number of a segment

    SEG.SEQ+SEG.LEN-1 = last sequence number of a segment
```

새로운 확인\("허용 가능한 확인"이라고 함\)은 다음과 같은 부등식을 유지하는 것입니다.

```text
    SND.UNA < SEG.ACK =< SND.NXT
```

모든 산술은 모듈로 2\*\*32이며 비교는 부호가 없습니다. "=<"는 "작거나 같음"을 의미합니다.

재전송 큐의 세그먼트는 해당 시퀀스 번호와 길이의 합이 수신 세그먼트의 승인 값보다 작은 경우 완전히 승인됩니다.

SEG.LEN은 세그먼트의 데이터가 차지하는 옥텟 수입니다. SEG.LEN은 0이 아니어야 한다는 점에 유의하는 것이 중요합니다. 시퀀스 공간을 차지하지 않는 세그먼트\(예: 빈 승인 세그먼트\)는 재전송 대기열에 배치되지 않으므로 이 특정 테스트를 거치지 않습니다.

수신 연결에서는 다음 비교가 필요합니다.

```text
    older sequence numbers                        newer sequence numbers

                                    
                RCV.NXT                         RCV.NXT+RCV.WND 
                   |                               |            
       ---------XXX|XXX------XXXXXXXXXX---------XXX|XX--------- 
                |  |         |                  |  |            
                |            |                  |               
             Segment 1    Segment 2          Segment 3          

                      <----- sequence space ----->

                  Receiving Sequence Space Information

                                Figure 8.

    RCV.NXT = next sequence number expected on incoming segments

    RCV.NXT+RCV.WND = last sequence number expected on incoming
        segments, plus one

    SEG.SEQ = first sequence number occupied by the incoming segment

    SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming
        segment

  A segment is judged to occupy a portion of valid receive sequence
  space if

     0 =< (SEG.SEQ+SEG.LEN-1 - RCV.NXT) < (RCV.NXT+RCV.WND - RCV.NXT)
```

SEG.SEQ+SEG.LEN-1은 세그먼트가 차지하는 마지막 시퀀스 번호입니다. RCV.NXT는 수신 세그먼트에서 예상되는 다음 시퀀스 번호입니다. RCV.NXT+RCV.WND는 수신 창의 오른쪽 가장자리입니다.

실제로는 이것보다 조금 더 복잡합니다. 제로 윈도우와 제로 길이 세그먼트로 인해 들어오는 세그먼트의 허용 가능성에 대한 네 가지 경우가 있습니다.

```text
    Segment Receive  Test
    Length  Window
    ------- -------  -------------------------------------------

       0       0     SEG.SEQ = RCV.NXT

       0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

      >0       0     not acceptable

      >0      >0     RCV.NXT < SEG.SEQ+SEG.LEN =< RCV.NXT+RCV.WND
```

세그먼트의 끝이 창에 있어야 하기 때문에 세그먼트에 대한 승인 테스트는 절대적으로 필요한 것보다 다소 제한적입니다. 최소한 세그먼트의 첫 번째 시퀀스 번호가 수신 창에 있거나 세그먼트의 일부가 수신 창에 있는 경우 해당 세그먼트는 허용 가능한 것으로 판단될 수 있습니다. 따라서 그림 8에서 최소한 세그먼트 1과 2는 엄격한 규칙에 따라 허용되며 세그먼트 3은 규칙 해석의 엄격함에 따라 허용될 수도 있고 그렇지 않을 수도 있습니다.

수신 창이 0이면 ACK 세그먼트를 제외하고는 어떤 세그먼트도 허용되지 않아야 합니다. 따라서 TCP가 데이터를 전송하고 ACK를 수신하는 동안 제로 수신 창을 유지하는 것이 가능해야 합니다.

특정 제어 정보도 보호하기 위해 번호 매기기 체계를 활용했습니다. 이는 혼란 없이 재전송 및 승인될 수 있도록 시퀀스 공간에 일부 제어 플래그를 암시적으로 포함함으로써 달성됩니다\(즉, 하나의 제어 복사본만 작동됩니다\). 제어 정보는 세그먼트 데이터 공간에 물리적으로 전달되지 않습니다. 결과적으로 제어에 암시적으로 시퀀스 번호를 할당하는 규칙을 채택해야 합니다. SYN 및 FIN은 이러한 보호가 필요한 유일한 컨트롤이며 이러한 컨트롤은 연결을 열고 닫을 때만 사용됩니다. 시퀀스 번호 목적으로 SYN은 발생하는 세그먼트의 첫 번째 실제 데이터 옥텟 이전에 발생하는 것으로 간주되는 반면, FIN은 발생하는 세그먼트의 마지막 실제 데이터 옥텟 이후에 발생하는 것으로 간주됩니다. 세그먼트 길이에는 컨트롤을 차지하는 데이터 및 시퀀스 공간이 모두 포함됩니다. SYN이 있는 경우 SEG.SEQ는 SYN의 시퀀스 번호입니다.

```text
  Initial Sequence Number Selection

  The protocol places no restriction on a particular connection being
  used over and over again.  A connection is defined by a pair of
  sockets.  New instances of a connection will be referred to as
  incarnations of the connection.  The problem that arises owing to this
```

- "TCP는 이전 연결 화신의 중복 세그먼트를 어떻게 식별합니까?" 이 문제는 연결이 빠르게 연속적으로 열리고 닫히는 경우 또는 메모리 손실로 인해 연결이 끊어졌다가 다시 설정되는 경우에 분명해집니다.

혼란을 피하기 위해 동일한 시퀀스 번호가 이전 구현의 네트워크에 계속 존재할 수 있는 동안 연결의 한 구현에서 세그먼트가 사용되는 것을 방지해야 합니다. 우리는 TCP가 충돌하여 사용 중인 시퀀스 번호에 대한 모든 지식을 잃어버리더라도 이를 보장하고 싶습니다. 새로운 연결이 생성되면 새로운 32비트 ISN을 선택하는 초기 시퀀스 번호\(ISN\) 생성기가 사용됩니다. 생성기는 하위 비트가 대략 4마이크로초마다 증가하는 \(아마도 가상의\) 32비트 클록에 바인딩되어 있습니다. 따라서 ISN은 대략 4.55시간마다 순환합니다. 세그먼트가 네트워크에 수십 초 또는 몇 분 이상 머물지 않을 것이라고 가정하므로 최악의 경우 ISN이 고유할 것이라고 합리적으로 가정할 수 있습니다.

각 연결에는 송신 시퀀스 번호와 수신 시퀀스 번호가 있습니다. 초기 전송 시퀀스 번호\(ISS\)는 데이터 전송 TCP에 의해 선택되고 초기 수신 시퀀스 번호\(IRS\)는 연결 설정 절차 중에 학습됩니다.

연결을 설정하거나 초기화하려면 두 TCP가 서로의 초기 시퀀스 번호를 동기화해야 합니다. 이는 "SYN"\(동기화용\)이라는 제어 비트와 초기 시퀀스 번호를 전달하는 연결 설정 메시지 교환으로 수행됩니다. 간단히 말해서 SYN 비트를 전달하는 메시지를 "SYN"이라고도 합니다. 따라서 솔루션에는 초기 시퀀스 번호를 선택하는 데 적합한 메커니즘과 ISN을 교환하기 위한 약간의 핸드셰이크가 필요합니다. 시퀀스 번호는 네트워크의 글로벌 시계에 연결되어 있지 않으며 TCP는 ISN을 선택하기 위한 다른 메커니즘을 가질 수 있으므로 "3방향 핸드셰이크"가 필요합니다. 첫 번째 SYN의 수신자는 연결에 사용된 마지막 시퀀스 번호를 기억하지 않는 한\(항상 가능한 것은 아님\) 세그먼트가 이전에 지연된 세그먼트인지 여부를 알 수 없으므로 발신자에게 확인을 요청해야 합니다. 이 SYN.

"3방향 핸드셰이크"와 "클럭 구동" 방식의 장점은 \[4\]에서 논의됩니다.

```text
  Knowing When to Keep Quiet

  To be sure that a TCP does not create a segment that carries a
  sequence number which may be duplicated by an old segment remaining in
  the network, the TCP must keep quiet for a maximum segment lifetime
  (MSL) before assigning any sequence numbers upon starting up or
  recovering from a crash in which memory of sequence numbers in use was
```

잃어버린. 이 사양의 경우 MSL은 2분으로 간주됩니다. 이는 공학적 선택이며, 경험상 그렇게 하는 것이 바람직하다고 판단되는 경우 변경될 수 있습니다. TCP가 어떤 의미에서 다시 초기화되었지만 사용 중인 시퀀스 번호의 메모리를 유지한다면 전혀 기다릴 필요가 없습니다. 최근에 사용된 것보다 큰 시퀀스 번호만 사용해야 합니다.

이 전략은 스푸핑이나 기타 재생 유형 중복 메시지 문제로부터 보호하지 못한다는 점에 유의해야 합니다.

---
### **3.4.  Establishing a connection**

"3방향 핸드셰이크"는 연결을 설정하는 데 사용되는 절차입니다. 이 절차는 일반적으로 하나의 TCP에 의해 시작되고 다른 TCP에 의해 응답됩니다. 두 TCP가 동시에 절차를 시작하는 경우에도 절차가 작동합니다. 동시 시도가 발생하면 TCP는 "SYN"을 보낸 후 승인을 전달하지 않는 "SYN" 세그먼트를 수신합니다. 물론 오래된 중복 "SYN" 세그먼트가 도착하면 수신자에게 동시 연결 시작이 진행 중인 것처럼 나타날 수 있습니다. "재설정" 세그먼트를 올바르게 사용하면 이러한 경우를 명확하게 할 수 있습니다. 연결 시작의 몇 가지 예는 다음과 같습니다. 이러한 예에서는 데이터 전달 세그먼트를 사용한 연결 동기화를 보여주지 않지만 수신 TCP가 데이터가 유효하다는 것이 명확해질 때까지\(즉, 데이터가 버퍼링되어야 함\) 사용자에게 데이터를 전달하지 않는 한 이는 완전히 합법적입니다. 연결이 ESTABLISHED 상태에 도달할 때까지 수신기에서\). 3방향 핸드셰이크는 잘못된 연결 가능성을 줄여줍니다. 이 검사에 대한 정보를 제공하는 것은 메모리와 메시지 사이의 균형을 구현하는 것입니다.

```text
  The simplest three-way handshake is shown in figure 9 below.  The
  figures should be interpreted in the following way.  Each line is
  numbered for reference purposes.  Right arrows (-->) indicate
  departure of a TCP segment from TCP A to TCP B, or arrival of a
  segment at B from A.  Left arrows (<--), indicate the reverse.
  Ellipsis (...) indicates a segment which is still in the network
  (delayed).  An "XXX" indicates a segment which is lost or rejected.
  Comments appear in parentheses.  TCP states represent the state AFTER
  the departure or arrival of the segment (whose contents are shown in
  the center of each line).  Segment contents are shown in abbreviated
  form, with sequence number, control flags, and ACK field.  Other
  fields such as window, addresses, lengths, and text have been left out
  in the interest of clarity.

  

      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED

          Basic 3-Way Handshake for Connection Synchronization

                                Figure 9.
```

그림 9의 2행에서 TCP A는 시퀀스 번호 100으로 시작하는 시퀀스 번호를 사용할 것임을 나타내는 SYN 세그먼트를 보내는 것으로 시작합니다. 3행에서 TCP B는 SYN을 보내고 TCP A로부터 받은 SYN을 확인합니다. 승인 필드는 TCP B가 이제 시퀀스 101을 듣고 시퀀스 100을 점유한 SYN을 승인할 것으로 예상하고 있음을 나타냅니다.

4행에서 TCP A는 TCP B의 SYN에 대한 ACK를 포함하는 빈 세그먼트로 응답합니다. 5번째 줄에서 TCP A는 일부 데이터를 보냅니다. ACK가 시퀀스 번호 공간을 차지하지 않기 때문에 라인 5에 있는 세그먼트의 시퀀스 번호는 라인 4와 동일합니다\(그렇다면 ACK를 ACK하는 것입니다!\).

동시 시작은 그림 10에 표시된 것처럼 약간 더 복잡합니다. 각 TCP는 CLOSED에서 SYN-SENT, SYN-RECEIVED, ESTABLISHED로 순환합니다.

3방향 핸드셰이크의 주요 이유는 오래된 중복 연결 시작으로 인해 혼란이 발생하는 것을 방지하는 것입니다. 이를 처리하기 위해 특별한 제어 메시지인 재설정이 고안되었습니다. 수신 TCP가 동기화되지 않은 상태\(예: SYN-SENT, SYN-RECEIVED\)인 경우 허용 가능한 재설정을 수신하면 LISTEN으로 돌아갑니다. TCP가 동기화된 상태\(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING\) 중 하나에 있으면 연결을 중단하고 사용자에게 알립니다. 우리는 아래의 "반개방" 연결에서 후자의 경우를 논의합니다.

```text
  

      TCP A                                        TCP B

  1.  CLOSED                                       CLOSED

  2.  SYN-SENT     --> <SEQ=100><CTL=SYN>          ...

  3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>          <-- SYN-SENT

  4.               ... <SEQ=100><CTL=SYN>          --> SYN-RECEIVED

  5.  SYN-RECEIVED --> <SEQ=101><ACK=301><CTL=ACK> ...

  6.  ESTABLISHED  <-- <SEQ=301><ACK=101><CTL=ACK> <-- SYN-RECEIVED

  7.               ... <SEQ=101><ACK=301><CTL=ACK> --> ESTABLISHED

                Simultaneous Connection Synchronization

                               Figure 10.

  

      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...

  3.  (duplicate) ... <SEQ=1000><CTL=SYN>              --> SYN-RECEIVED

  4.  SYN-SENT    <-- <SEQ=300><ACK=1001><CTL=SYN,ACK> <-- SYN-RECEIVED

  5.  SYN-SENT    --> <SEQ=1001><CTL=RST>              --> LISTEN
  

  6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  7.  SYN-SENT    <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED

                    Recovery from Old Duplicate SYN

                               Figure 11.

  As a simple example of recovery from old duplicates, consider
```

그림 11. 라인 3에서 이전 중복 SYN이 TCP B에 도착합니다. TCP B는 이것이 이전 중복임을 알 수 없으므로 정상적으로 응답합니다\(라인 4\). TCP A는 ACK 필드가 올바르지 않음을 감지하고 세그먼트를 믿을 수 있도록 선택된 SEQ 필드와 함께 RST\(재설정\)를 반환합니다. TCP B는 RST를 수신하면 LISTEN 상태로 돌아갑니다. 원래 SYN\(말장난 의도\)이 마침내 라인 6에 도착하면 동기화가 정상적으로 진행됩니다. 6행의 SYN이 RST보다 먼저 도착했다면 RST가 양방향으로 전송되어 더 복잡한 교환이 발생했을 수 있습니다.

```text
  Half-Open Connections and Other Anomalies
```

설정된 연결은 TCP 중 하나가 다른 쪽을 알지 못한 채 연결을 종료하거나 중단한 경우 또는 충돌로 인해 연결의 두 끝이 동기화되지 않은 경우 "반개방"이라고 합니다. 기억상실중. 이러한 연결은 어느 방향으로든 데이터를 보내려고 하면 자동으로 재설정됩니다. 그러나 반쯤 열린 연결은 일반적이지 않을 것으로 예상되며 복구 절차가 약간 포함됩니다.

사이트 A에서 연결이 더 이상 존재하지 않는 경우 사이트 B에서 사용자가 해당 사이트에 데이터를 보내려고 시도하면 사이트 B TCP가 재설정 제어 메시지를 받게 됩니다. 이러한 메시지는 사이트 B TCP에 무엇인가 잘못되었음을 알려야 하며 연결이 중단될 것으로 예상됩니다.

충돌이 발생하여 A의 TCP에 메모리가 손실될 때 두 사용자 프로세스 A와 B가 서로 통신하고 있다고 가정합니다. A의 TCP를 지원하는 운영 체제에 따라 일부 오류 복구 메커니즘이 존재할 가능성이 있습니다. TCP가 다시 가동되면 A는 처음부터 다시 시작하거나 복구 지점에서 다시 시작할 가능성이 높습니다. 결과적으로 A는 연결을 다시 OPEN하려고 시도하거나 열려 있다고 생각되는 연결에 대해 SEND를 시도할 것입니다. 후자의 경우 로컬\(A's\) TCP로부터 "connection not open"이라는 오류 메시지를 수신합니다. 연결을 설정하려는 시도에서 A의 TCP는 SYN이 포함된 세그먼트를 보냅니다. 이 시나리오는 그림 12에 표시된 예제로 이어집니다. TCP A 충돌 후 사용자는 연결을 다시 열려고 시도합니다. 그 동안 TCP B는 연결이 열려 있다고 생각합니다.

```text
  

      TCP A                                           TCP B

  1.  (CRASH)                               (send 300,receive 100)

  2.  CLOSED                                           ESTABLISHED

  3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)

  4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED

  5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)

  6.                                                   CLOSED

  7.  SYN-SENT --> <SEQ=400><CTL=SYN>              -->

                     Half-Open Connection Discovery

                               Figure 12.
```

SYN이 라인 3에 도달하면 동기화 상태에 있는 TCP B는 다음에 어떤 시퀀스를 듣게 될지 나타내는 승인으로 응답합니다\(ACK 100\). TCP A는 이 세그먼트가 자신이 보낸 어떤 것도 승인하지 않는다는 것을 확인하고, 동기화되지 않은 상태에서 반개방 연결을 감지했기 때문에 재설정\(RST\)을 보냅니다. TCP B는 라인 5에서 중단됩니다. TCP A는 계속해서 연결 설정을 시도합니다. 이제 문제는 그림 9의 기본 3방향 핸드셰이크로 축소되었습니다.

흥미로운 대체 사례는 TCP A가 충돌하고 TCP B가 동기화된 연결이라고 생각하는 데이터를 보내려고 할 때 발생합니다. 이는 그림 13에 설명되어 있습니다. 이 경우 TCP B\(라인 2\)에서 TCP A에 도착하는 데이터는 해당 연결이 존재하지 않기 때문에 허용되지 않으므로 TCP A는 RST를 보냅니다. RST가 허용되므로 TCP B가 이를 처리하고 연결을 중단합니다.

```text
  

        TCP A                                              TCP B

  1.  (CRASH)                                   (send 300,receive 100)

  2.  (??)    <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED

  3.          --> <SEQ=100><CTL=RST>                   --> (ABORT!!)

           Active Side Causes Half-Open Connection Discovery

                               Figure 13.
```

그림 14에서는 SYN을 기다리는 수동 연결이 있는 두 개의 TCP A와 B를 찾을 수 있습니다. TCP B\(라인 2\)에 도착하는 오래된 복제본이 B를 자극하여 행동을 취하게 합니다. SYN-ACK가 반환되고\(라인 3\) TCP A가 RST를 생성하도록 합니다\(라인 3의 ACK는 허용되지 않음\). TCP B는 재설정을 수락하고 수동 LISTEN 상태로 돌아갑니다.

```text
  

      TCP A                                         TCP B

  1.  LISTEN                                        LISTEN

  2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED

  3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED

  4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)

  5.  LISTEN                                        LISTEN

       Old Duplicate SYN Initiates a Reset on two Passive Sockets

                               Figure 14.
```

다양한 다른 경우가 가능하며 모두 RST 생성 및 처리에 대한 다음 규칙에 의해 설명됩니다.

```text
  Reset Generation

  As a general rule, reset (RST) should be sent whenever a segment
  arrives which apparently is not intended for the current or a future
  incarnation of the connection.  A reset should not be sent if it is
  not clear that this is the case.  Thus, if any segment arrives for a
  nonexistent connection, a reset should be sent.  If a segment ACKs
```

현재 연결에서 전송된 적이 없는 경우 다음 두 가지 경우 중 하나가 적용됩니다.

1. 연결이 동기화되지 않은 상태\(LISTEN, SYN-SENT, SYN-RECEIVED\)이거나 연결이 존재하지 않는 경우 재설정\(RST\)이 형성되어 아직 전송되지 않은 것을 확인하는 모든 세그먼트에 대해 전송되어야 합니다. . RST는 문제가 있는 세그먼트의 ACK 필드에서 SEQ 필드를 가져와야 하며\(ACK 제어 비트가 설정된 경우\) 초기 SYN을 거부하는 경우를 제외하고 ACK 비트를 재설정\(0\)해야 합니다. 수신 세그먼트에 연결에 요청된 수준 및 구획과 정확히 일치하지 않는 보안 수준 또는 구획이 있는 경우에도 재설정이 전송됩니다. 들어오는 세그먼트의 우선 순위가 요청된 우선 순위 수준보다 낮으면 재설정이 전송됩니다.

2. 연결이 동기화된 상태\(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING\)인 경우 허용할 수 없는 세그먼트는 현재 전송을 포함하는 빈 승인 세그먼트만 유도해야 합니다. - 시퀀스 번호와 수신될 것으로 예상되는 다음 시퀀스 번호를 나타내는 승인.

```text
  Reset Processing
```

모든 재설정\(RST\) 세그먼트는 SEQ 필드를 확인하여 검증됩니다. 재설정은 해당 시퀀스 번호가 창에 있는 경우 유효합니다. 초기 SYN에 대한 응답으로 수신된 RST의 경우 ACK 필드가 SYN을 확인하면 모든 시퀀스 번호가 허용됩니다.

RST의 수신자는 먼저 유효성을 검사한 다음 상태를 변경합니다. 수신자가 LISTEN 상태에 있으면 무시합니다. 수신자가 SYN-RECEIVED 상태이고 이전에 LISTEN 상태였다면 수신자는 LISTEN 상태로 돌아가고, 그렇지 않으면 수신자는 연결을 중단하고 CLOSED 상태로 이동합니다. 수신자가 다른 상태에 있으면 연결을 중단하고 사용자에게 알리고 CLOSED 상태로 이동합니다.

---
### **3.5.  Closing a Connection**

```text
  CLOSE is an operation meaning "I have no more data to send."  The
  notion of closing a full-duplex connection is subject to ambiguous
  interpretation, of course, since it may not be obvious how to treat
  the receiving side of the connection.  We have chosen to treat CLOSE
  in a simplex fashion.  The user who CLOSEs may continue to RECEIVE
  until he is told that the other side has CLOSED also.  Thus, a program
  could initiate several SENDs followed by a CLOSE, and then continue to
  RECEIVE until signaled that a RECEIVE failed because the other side
  has CLOSED.  We assume that the TCP will signal a user, even if no
  RECEIVEs are outstanding, that the other side has closed, so the user
```

그의 편을 우아하게 끝낼 수 있습니다. TCP는 연결이 닫히기 전에 보낸 모든 버퍼를 안정적으로 전달하므로 반환되는 데이터가 없을 것으로 예상하는 사용자는 연결이 성공적으로 닫혔음을 듣고 모든 데이터가 대상 TCP에서 수신되었음을 알 수 있을 때까지 기다리기만 하면 됩니다.

기본적으로 세 가지 경우가 있습니다.

1\) 사용자는 TCP에 연결을 닫으라고 지시하여 시작합니다.

2\) 원격 TCP는 FIN 제어 신호를 전송하여 시작합니다.

```text
    3) Both users CLOSE simultaneously

  Case 1:  Local user initiates the close
```

이 경우 FIN 세그먼트를 구성하여 나가는 세그먼트 큐에 배치할 수 있습니다. 사용자의 더 이상 SEND는 TCP에 의해 승인되지 않으며 FIN-WAIT-1 상태로 들어갑니다. 이 상태에서는 RECEIVE가 허용됩니다. FIN 이전 및 FIN을 포함한 모든 세그먼트는 승인될 때까지 재전송됩니다. 다른 TCP가 FIN을 확인하고 자체 FIN을 보낸 경우 첫 번째 TCP는 이 FIN을 ACK할 수 있습니다. FIN을 수신한 TCP는 ACK를 보내지만 사용자가 연결을 닫을 때까지 자체 FIN을 보내지 않는다는 점에 유의해야 합니다.

```text
  Case 2:  TCP receives a FIN from the network
```

원치 않는 FIN이 네트워크에서 도착하면 수신 TCP는 이를 ACK하고 사용자에게 연결이 닫히고 있음을 알릴 수 있습니다. 사용자는 CLOSE로 응답해야 하며, 이에 따라 TCP는 다른 TCP에 FIN을 보낼 수 있습니다. 그런 다음 TCP는 자체 FIN이 승인될 때까지 기다린 후 연결을 삭제합니다. ACK가 오지 않으면 시간 초과 후 연결이 중단되고 사용자에게 알립니다.

```text
  Case 3:  both users close simultaneously
```

연결의 양쪽 끝에서 사용자가 동시에 CLOSE하면 FIN 세그먼트가 교환됩니다. FIN 앞에 있는 모든 세그먼트가 처리되고 확인되면 각 TCP는 수신한 FIN을 ACK할 수 있습니다. 둘 다 이러한 ACK를 수신하면 연결을 삭제합니다.

```text
  

      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)
      FIN-WAIT-1  --> <SEQ=100><CTL=FIN>               --> CLOSE-WAIT

  3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT

  4.                                                       (Close)
      TIME-WAIT   <-- <SEQ=301><CTL=FIN>               <-- CLOSING

  5.  TIME-WAIT   --> <SEQ=100><ACK=301><CTL=ACK>      --> CLOSED

  6.  (2 MSL)
      CLOSED

                         Normal Close Sequence

                               Figure 15.

  

      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)                                              (Close)
      FIN-WAIT-1  --> <SEQ=100><CTL=FIN>               ... FIN-WAIT-1
                  <-- <SEQ=300><CTL=FIN>               <--
                  ... <SEQ=100><CTL=FIN>               -->

  3.  CLOSING     --> <SEQ=100><ACK=301><CTL=ACK>      ... CLOSING
                  <-- <SEQ=300><ACK=101><CTL=ACK>      <--
                  ... <SEQ=100><ACK=301><CTL=ACK>      -->

  4.  CLOSED                                               CLOSED

                      Simultaneous Close Sequence

                               Figure 16.
```

---
### **3.6.  Precedence and Security**

그 의도는 정확히 동일한 보안 및 구획 값으로 작동하는 포트와 두 부분에서 요청한 우선 순위 수준 중 더 높은 경우에만 연결이 허용된다는 것입니다.

우선순위 수준은 다음과 같습니다.

```text
    flash override - 111
    flash          - 110
    immediate      - 10X
    priority       - 01X
    routine        - 00X
```

보안 수준은 다음과 같습니다.

```text
    top secret    - 11
    secret        - 10
    confidential  - 01
    unclassified  - 00
```

구획은 국방 통신국에 의해 할당됩니다. 기본값은 우선순위: 루틴, 보안: 분류되지 않음, 구획: 0입니다. 우선 순위나 보안 기능을 구현하지 않는 호스트는 전송하는 세그먼트에 대해 이러한 필드를 0으로 지워야 합니다.

일치하지 않는 보안/구획 값 ​​또는 더 낮은 우선 순위 값을 사용한 연결 시도는 재설정을 전송하여 거부해야 합니다.

우선 순위의 기본값에서만 작동하는 TCP 모듈은 들어오는 세그먼트의 우선 순위를 확인하고 가능하면 연결에서 사용하는 우선 순위 수준을 높여야 합니다.

---
### **3.7.  Data Communication**

연결이 설정되면 세그먼트 교환을 통해 데이터가 전달됩니다. 오류\(체크섬 테스트 실패\) 또는 네트워크 정체로 인해 세그먼트가 손실될 수 있으므로 TCP는 모든 세그먼트의 전달을 보장하기 위해 재전송\(시간 초과 후\)을 사용합니다. 네트워크 또는 TCP 재전송으로 인해 중복 세그먼트가 도착할 수 있습니다. 시퀀스 번호 섹션에서 설명한 것처럼 TCP는 세그먼트의 시퀀스 및 승인 번호에 대한 특정 테스트를 수행하여 허용 여부를 확인합니다.

```text
  The sender of data keeps track of the next sequence number to use in
  the variable SND.NXT.  The receiver of data keeps track of the next
```

변수 RCV.NXT에 예상되는 시퀀스 번호입니다. 데이터 송신자는 변수 SND.UNA에서 가장 오래되고 승인되지 않은 시퀀스 번호를 추적합니다. 데이터 흐름이 일시적으로 유휴 상태이고 전송된 모든 데이터가 확인된 경우 세 가지 변수는 동일합니다.

송신자가 세그먼트를 생성하여 전송할 때 송신자는 SND.NXT를 진행합니다. 수신자가 세그먼트를 수락하면 RCV.NXT를 진행하고 승인을 보냅니다. 데이터 송신자가 승인을 받으면 SND.UNA가 진행됩니다. 이러한 변수의 값이 다른 정도는 통신 지연의 척도입니다.

일반적으로 변수가 향상되는 양은 세그먼트의 데이터 길이입니다. 그러나 문자를 사용하는 경우 시퀀스 번호, 문자 경계 및 수신 버퍼 경계를 조정하기 위한 특별 규정이 있습니다.

```text
  End of Letter Sequence Number Adjustments
```

TCP에는 연결 동기화 시 수신자의 버퍼 크기에 따라 연결에 대한 데이터 송신자와 선택적으로 통신할 수 있는 데이터 수신자가 제공됩니다. 이것이 완료되면 수신자는 연결 수명 동안 고정된 크기의 버퍼를 사용해야 합니다. 버퍼 크기가 전달되면 수신 버퍼, 문자 및 시퀀스 번호 간에 조정이 이루어집니다.

버퍼가 채워지거나 문자 끝으로 인해 완료될 때마다 시퀀스 번호는 해당 버퍼의 끝을 통해 증가됩니다.

즉, EOL이 전송될 때마다 송신자는 수신자의 버퍼에서 사용되지 않은 공간을 모두 소비하기에 충분한 양만큼 송신 시퀀스 번호 SND.NXT를 앞당깁니다. 이러한 방식으로 소비되는 공간의 양은 실제 데이터가 소비하는 공간과 마찬가지로 송신 창에서 차감됩니다.

그리고 EOL이 수신될 때마다 수신기는 수신기 버퍼에서 사용되지 않은 공간을 모두 소비하기에 충분한 양만큼 수신 시퀀스 번호 RCV.NXT를 앞당깁니다. 이러한 방식으로 소비되는 공간의 양은 실제 데이터가 소비하는 공간과 마찬가지로 수신 창에서 차감됩니다.

```text
    older sequence numbers                        newer sequence numbers

            |           Buffer 1            |   Buffer 2       
            |                               |                  
        ----+-------------------------------+----------------- 
            XXXXXXXXXXXXXXXXXXXXX+++++++++++                   
            |                    |          |                  
            |<-----SEG.LEN------>|          |                  
            |                    |          |                  
            |                    |          |                  
         SEG.SEQ                 A          B                  

                    XXX - data octets from segment 
                    +++ - phantom data             

                      <----- sequence space ----->
```

- 문자 조정 종료

```text
                               Figure 17.
```

위에 설명된 경우 세그먼트에 EOL 플래그가 없으면 SND.NXT 또는 RCV.NXT의 다음 값은 A가 됩니다. EOL 플래그가 있으면 다음 값은 B가 됩니다.

버퍼 크기와 순서 정보 교환은 옥텟 단위로 이루어집니다. 버퍼 크기가 명시되지 않은 경우 버퍼 크기는 1옥텟으로 간주됩니다. 수신자는 TCP 헤더의 옵션 필드에 16비트 버퍼 크기 데이터가 포함된 SYN 세그먼트의 버퍼 크기를 발신자에게 알려줍니다.

```text
  Each EOL advances the sequence number (SN) to the next buffer boundary

    While LBB < SEG.SEQ+SEG.LEN
    Do LBB <- LBB + BS End
    SN <- LBB
```

여기서 LBB는 마지막 버퍼 시작이고 BS는 버퍼 크기입니다.

CLOSE 사용자 호출은 들어오는 세그먼트의 FIN 제어 플래그와 마찬가지로 문자 끝을 의미합니다.

```text
  The Communication of Urgent Information
```

TCP 긴급 메커니즘의 목적은 송신 사용자가 수신 사용자가 일부 긴급 데이터를 수락하도록 자극하고 수신 TCP가 현재 알려진 모든 긴급 데이터가 사용자에 의해 수신되었을 때 수신 사용자에게 알리도록 허용하는 것입니다.

이 메커니즘을 사용하면 데이터 스트림의 한 지점을 "긴급" 정보의 끝으로 지정할 수 있습니다. 이 지점이 수신 TCP의 수신 시퀀스 번호\(RCV.NXT\)보다 앞에 있을 때마다 해당 TCP는 사용자에게 "긴급 모드"로 들어가도록 알려야 합니다. 수신 시퀀스 번호가 긴급 포인터를 따라잡으면 TCP는 사용자에게 "일반 모드"로 들어가도록 알려야 합니다. 사용자가 "빠른 읽기" 모드에 있는 동안 긴급 포인터가 업데이트되면 업데이트가 사용자에게 표시되지 않습니다.

이 방법은 전송되는 모든 세그먼트에 전달되는 긴급 필드를 사용합니다. URG 제어 플래그는 긴급 필드가 의미가 있으며 긴급 포인터를 생성하기 위해 세그먼트 시퀀스 번호에 추가되어야 함을 나타냅니다. 이 플래그가 없으면 긴급 포인터가 변경되지 않았음을 나타냅니다.

긴급 표시를 보내려면 사용자는 최소한 하나의 데이터 옥텟도 보내야 합니다. 보내는 사용자가 편지 끝을 표시하는 경우 긴급 정보를 대상 프로세스에 적시에 전달하는 것이 향상됩니다.

```text
  Managing the Window
```

각 세그먼트에 전송된 창은 창의 전송자\(데이터 수신자\)가 현재 수락할 준비가 되어 있는 시퀀스 번호의 범위를 나타냅니다. 이는 이 연결에 사용할 수 있는 현재 사용 가능한 데이터 버퍼 공간과 관련이 있다는 가정이 있습니다. 창 정보는 목표로 삼아야 할 지침입니다.

큰 창을 표시하면 전송이 촉진됩니다. 허용할 수 있는 것보다 더 많은 데이터가 도착하면 폐기됩니다. 이로 인해 과도한 재전송이 발생하여 네트워크 및 TCP에 불필요하게 부하가 추가됩니다. 작은 창을 표시하면 전송되는 각각의 새로운 세그먼트 사이에 왕복 지연을 도입하는 지점까지 데이터 전송을 제한할 수 있습니다.

제공되는 메커니즘을 통해 TCP는 큰 창을 광고하고 이후에 많은 데이터를 수락하지 않고도 훨씬 작은 창을 광고할 수 있습니다. 소위 "창 축소"라고 하는 이 작업은 권장되지 않습니다. 견고성 원칙에 따르면 TCP는 창 자체를 축소하지 않지만 다른 TCP의 일부에서 이러한 동작에 대비해야 합니다.

```text
  The sending TCP must be prepared to accept and send at least one octet
  of new data even if the send window is zero.  The sending TCP should
  regularly retransmit to the receiving TCP even when the window is
  zero.  Two minutes is recommended for the retransmission interval when
  the window is zero.  This retransmission is essential to guarantee
```

두 TCP 중 하나에 창이 0인 경우 창 다시 열기가 다른 TCP에 안정적으로 보고됩니다.

송신 TCP는 전송할 데이터를 현재 창에 맞는 세그먼트로 패키징하고 재전송 대기열의 세그먼트를 다시 패키징할 수 있습니다. 이러한 재포장은 필수는 아니지만 도움이 될 수 있습니다.

사용자는 TCP가 더 이상 데이터가 없다고 말할 때까지 보내기 위해 닫은 연결을 계속 읽어야 합니다.

단방향 데이터 흐름과 관련하여 창 정보는 모두 동일한 시퀀스 번호를 갖는 승인 세그먼트에 전달되므로 순서가 잘못되어 도착하면 순서를 바꿀 방법이 없습니다. 이는 심각한 문제는 아니지만 때때로 데이터 수신기의 이전 보고서를 기반으로 창 정보가 일시적으로 표시될 수 있습니다.

---
### **3.8.  Interfaces**

물론 두 가지 인터페이스, 즉 사용자/TCP 인터페이스와 TCP/IP 인터페이스가 있습니다. 우리는 사용자/TCP 인터페이스에 대한 상당히 정교한 모델을 가지고 있지만 하위 수준 프로토콜 모듈에 대한 인터페이스의 스케치만 있습니다.

```text
  User/TCP Interface
```

TCP에 대한 사용자 명령의 기능 설명은 기껏해야 허구일 뿐입니다. 모든 운영 체제에는 서로 다른 기능이 있기 때문입니다. 결과적으로 우리는 독자들에게 서로 다른 TCP 구현이 서로 다른 사용자 인터페이스를 가질 수 있음을 경고해야 합니다. 그러나 모든 TCP 구현이 동일한 프로토콜 계층을 지원할 수 있도록 모든 TCP는 특정 최소 서비스 집합을 제공해야 합니다. 이 섹션에서는 모든 TCP 구현에 필요한 기능적 인터페이스를 지정합니다.

```text
    TCP User Commands
```

- 다음 섹션은 USER/TCP 인터페이스를 기능적으로 특성화합니다. 사용된 표기법은 고급 언어에서 대부분의 프로시저 또는 함수 호출과 유사하지만 이 사용법이 트랩 유형 서비스 호출\(예: SVC, UUO, EMT\)을 배제하기 위한 것은 아닙니다.

- 아래 설명된 사용자 명령은 프로세스 간 통신을 지원하기 위해 TCP가 수행해야 하는 기본 기능을 지정합니다. 개별 구현은 고유한 정확한 형식을 정의해야 하며 기본 기능의 조합 또는 하위 집합을 제공할 수 있습니다.

- 단일 통화. 특히, 일부 구현에서는 주어진 연결에 대해 사용자가 발행한 첫 번째 SEND 또는 RECEIVE에서 연결을 자동으로 OPEN하기를 원할 수 있습니다.

- 프로세스 간 통신 기능을 제공할 때 TCP는 명령을 수락할 뿐만 아니라 서비스를 제공하는 프로세스에 정보를 반환해야 합니다. 후자는 다음으로 구성됩니다.

- \(a\) 연결에 대한 일반 정보\(예: 인터럽트, 원격 닫기, 지정되지 않은 외부 소켓 바인딩\).

- \(b\) 성공 또는 다양한 유형의 실패를 나타내는 특정 사용자 명령에 응답합니다.

```text
      Open

        Format:  OPEN (local port, foreign socket, active/passive
        [, buffer size] [, timeout] [, precedence]
        [, security/compartment]) -> local connection name
```

- 로컬 TCP가 자신이 제공하는 프로세스의 ID를 알고 있으며 지정된 연결을 사용하기 위해 프로세스의 권한을 확인한다고 가정합니다. TCP 구현에 따라 소스 주소에 대한 로컬 네트워크 및 TCP 식별자는 TCP 또는 TCP를 제공하는 프로세스\(예: TCP 네트워크와 인터페이스하는 프로그램\)에 의해 제공됩니다. 이러한 고려 사항은 어떤 TCP도 다른 TCP로 가장할 수 없을 정도로 보안에 대한 우려의 결과입니다. 마찬가지로 TCP의 공모 없이는 어떤 프로세스도 다른 프로세스로 가장할 수 없습니다.

- 활성/수동 플래그가 수동으로 설정되어 있으면 들어오는 연결에 대한 LISTEN 호출입니다. 수동적 열기에는 특정 연결을 기다리는 완전히 지정된 외부 소켓 또는 호출을 기다리는 지정되지 않은 외부 소켓이 있을 수 있습니다. 완전히 지정된 수동 호출은 SEND의 후속 실행에 의해 활성화될 수 있습니다.

- 전이중 전송 제어 블록\(TCB\)이 생성되고 OPEN 명령 매개변수의 데이터로 부분적으로 채워집니다.

- 활성 OPEN 명령에서 TCP는 즉시 연결을 동기화\(즉, 설정\)하는 절차를 시작합니다.

```text
        The buffer size, if present, indicates that the caller will
        always receive data from the connection in that size of buffers.
        This buffer size is a measure of the buffer between the user and
```

- 로컬 TCP. 두 TCP 사이의 버퍼 크기는 다를 수 있습니다.

- 시간 제한이 있는 경우 호출자는 연결에서 전송된 모든 버퍼에 대한 시간 제한을 설정할 수 있습니다. 제한 시간 내에 버퍼가 대상으로 성공적으로 전달되지 않으면 TCP는 연결을 중단합니다. 현재 전역 기본값은 30초입니다. 버퍼 재전송 속도는 다양할 수 있습니다. 아마도 이는 원격 TCP의 응답에 대해 측정된 시간과 관련이 있을 것입니다.

- TCP 또는 운영 체제의 일부 구성 요소는 지정된 우선 순위 또는 보안/구획으로 연결을 열 수 있는 사용자 권한을 확인합니다. OPEN 호출에 우선순위나 보안/구획 사양이 없으면 기본값을 사용해야 함을 나타냅니다.

- TCP는 security/compartment 정보가 정확히 동일하고 우선 순위가 OPEN 호출에서 요청된 우선 순위보다 높거나 같은 경우에만 들어오는 요청을 일치하는 것으로 수락합니다.

- 연결 우선 순위는 OPEN 호출에서 요청하고 들어오는 요청에서 받은 값 중 더 높은 값이며 연결 수명 동안 해당 값으로 고정됩니다.

- TCP 구현에 따라 로컬 연결 이름이 TCP에 의해 사용자에게 반환되거나 사용자가 이 로컬 연결 이름을 지정합니다\(이 경우 호출에 다른 매개변수가 필요함\). 그런 다음 로컬 연결 이름을 <로컬 소켓, 외부 소켓\> 쌍으로 정의된 연결에 대한 간단한 용어로 사용할 수 있습니다.

```text
      Send

        Format:  SEND(local connection name, buffer address, byte count,
        EOL flag, URGENT flag [, timeout])
```

- 이 호출로 인해 표시된 사용자 버퍼에 포함된 데이터가 표시된 연결에서 전송됩니다. 연결이 열리지 않은 경우 SEND는 오류로 간주됩니다. 일부 구현에서는 사용자가 먼저 SEND를 허용할 수 있습니다. 이 경우 자동 OPEN이 수행됩니다. 호출 프로세스가 이 연결을 사용할 권한이 없으면 오류가 반환됩니다.

```text
        If the EOL flag is set, the data is the End Of a Letter, and the
        EOL bit will be set in the last TCP segment created from the
```

- 버퍼. EOL 플래그가 설정되지 않은 경우 후속 SEND는 동일한 문자의 일부로 나타납니다.

- URGENT 플래그가 설정된 경우 이 호출로 인해 발생하는 세그먼트에는 이 호출과 관련된 일부 데이터가 긴급함을 나타내도록 설정된 긴급 포인터가 있습니다. 예를 들어 이 기능은 터미널의 "중단" 신호나 I/O 장치의 오류 또는 완료 코드를 시뮬레이션하는 데 사용할 수 있습니다. 수신 프로세스에 대한 이 신호의 의미는 지정되지 않습니다. 긴급 포인터가 긴급 포인터 이전의 데이터가 수신 프로세스에 의해 소비되지 않았음을 나타내는 한, 수신 TCP는 긴급 상황을 수신 프로세스에 알립니다. 긴급함의 목적은 수신기가 일부 긴급 데이터를 받아들이도록 자극하고 현재 알려진 모든 긴급 데이터가 수신된 시기를 수신기에 알리는 것입니다.

- 보내는 사용자의 TCP 신호 긴급 횟수가 수신 사용자에게 긴급 데이터가 있음을 알리는 횟수와 반드시 같지는 않습니다.

OPEN에 외부 소켓이 지정되지 않았지만

- 연결이 설정되면\(예: 로컬 소켓에 도착하는 외부 세그먼트로 인해 LISTENing 연결이 특정화되었기 때문에\) 지정된 버퍼가 암시된 외부 소켓으로 전송됩니다. 일반적으로 지정되지 않은 외부 소켓으로 OPEN을 사용하는 사용자는 외부 소켓 주소를 명시적으로 알지 않고도 SEND를 사용할 수 있습니다.

- 단, 외부 소켓이 지정되기 전에 SEND를 시도하면 에러가 반환된다. 사용자는 STATUS 호출을 사용하여 연결 상태를 확인할 수 있습니다. 일부 구현에서 TCP는 지정되지 않은 소켓이 바인드될 때 사용자에게 알릴 수 있습니다.

- 시간 초과가 지정되면 이 연결의 현재 시간 초과가 새 시간 초과로 변경됩니다.

- 가장 간단한 구현에서 SEND는 전송이 완료되거나 시간 초과가 초과될 때까지 전송 프로세스에 제어권을 반환하지 않습니다. 그러나 이 간단한 방법은 교착 상태에 걸리기 쉽고\(예를 들어 연결 양쪽에서 RECEIVE를 수행하기 전에 SEND를 시도할 수 있음\) 성능이 저하되므로 권장되지 않습니다. 보다 정교한 구현은 프로세스가 네트워크 I/O와 동시에 실행될 수 있도록 즉시 반환하고 더 나아가 여러 SEND가 진행되도록 허용합니다.

- 여러 개의 SEND가 선착순으로 제공되므로 TCP는 즉시 서비스할 수 없는 SEND를 대기열에 넣습니다.

- 우리는 SEND가 나중에 서비스 제공 TCP로부터 일종의 SIGNAL 또는 의사 인터럽트를 유도하는 비동기 사용자 인터페이스를 암시적으로 가정했습니다. 대안은 즉시 응답을 반환하는 것입니다. 예를 들어, 전송된 세그먼트가 먼 TCP에 의해 승인되지 않은 경우에도 SEND는 즉각적인 로컬 승인을 반환할 수 있습니다. 우리는 궁극적인 성공을 낙관적으로 가정할 수 있습니다. 우리가 틀렸다면 시간 초과로 인해 연결이 종료됩니다. 이런 종류의\(동기식\) 구현에는 여전히 일부 비동기식 신호가 있지만 이는 특정 세그먼트나 문자가 아닌 연결 자체를 처리합니다.

- 참고 사항: 프로세스가 서로 다른 SEND에 대한 오류 또는 성공 표시를 구별하기 위해 SEND 요청에 대한 코딩된 응답과 함께 버퍼 주소가 반환되는 것이 적절할 수 있습니다. 호출 프로세스에 반환되어야 하는 정보를 나타내는 TCP-사용자 신호는 아래에 설명되어 있습니다.

```text
      Receive

        Format:  RECEIVE (local connection name, buffer address, byte
        count)
```

- 이 명령은 지정된 연결과 관련된 수신 버퍼를 할당합니다. 이 명령 앞에 OPEN이 없거나 호출 프로세스가 이 연결을 사용할 권한이 없으면 오류가 반환됩니다.

- 가장 간단한 구현에서는 버퍼가 채워지거나 일부 오류가 발생할 때까지 제어가 호출 프로그램으로 반환되지 않지만 이 체계는 교착 상태에 매우 취약합니다. 보다 정교한 구현을 통해 여러 RECEIVE를 동시에 뛰어난 상태로 유지할 수 있습니다. 세그먼트가 도착하면 이러한 내용이 채워집니다. 이 전략을 사용하면 호출 프로그램에 문자가 수신되었거나 버퍼가 채워졌음을 알리기 위해 보다 정교한 체계\(비동기화 가능\)를 사용하여 처리량을 늘릴 수 있습니다.

- 완전한 문자를 재조립하기 위한 버퍼 공간이 충분하지 않은 경우 RECEIVE에 대한 응답에 EOL 플래그가 설정되지 않습니다. 버퍼는 보유할 수 있는 만큼의 데이터로 채워집니다. 문자를 보유하는 데 필요한 마지막 버퍼는 EOL 신호와 함께 반환됩니다.

- 부분적으로 전달된 편지의 나머지 부분은 연속적인 RECEIVE를 통해 사용할 수 있게 되므로 버퍼에 배치됩니다. 다수의 RECEIVE가 미결 상태인 경우 단일 긴 문자의 일부로 채워지거나 각각 최대 하나의 문자로 채워질 수 있습니다. 각 RECEIVE와 관련된 반환 코드는 버퍼에 포함된 내용을 나타냅니다.

- OPEN 호출에 버퍼 크기가 제공된 경우 RECEIVE 호출에 표시된 모든 버퍼는 정확히 해당 크기여야 합니다. 그렇지 않으면 오류 표시가 반환됩니다.

- URGENT 플래그는 수신 사용자가 이전에 TCP-to-사용자 신호를 통해 긴급 데이터가 대기 중임을 알린 경우에만 설정됩니다. 따라서 수신 사용자는 "빠른 읽기" 모드에 있어야 합니다. URGENT 플래그가 켜져 있으면 추가 긴급 데이터가 남습니다. URGENT 플래그가 꺼진 경우 RECEIVE에 대한 이 호출은 모든 긴급 데이터를 반환했으며 사용자는 이제 "빠른 읽기" 모드를 종료할 수 있습니다.

- 여러 개의 뛰어난 RECEIVE를 구별하고 문자가 제공된 버퍼보다 ​​작은 경우를 처리하기 위해 반환 코드에는 버퍼 포인터와 수신된 문자의 실제 길이를 나타내는 바이트 수가 함께 제공됩니다.

- RECEIVE의 대체 구현에는 TCP 할당 버퍼 저장소가 있거나 TCP가 사용자와 링 버퍼를 공유할 수 있습니다. 이런 종류의 변형은 TCP에 대한 사용자 인터페이스에 명백한 변형을 가져옵니다.

```text
      Close

        Format:  CLOSE(local connection name)

        This command causes the connection specified to be closed.  If
        the connection is not open or the calling process is not
        authorized to use this connection, an error is returned.
        Closing connections is intended to be a graceful operation in
        the sense that outstanding SENDs will be transmitted (and
        retransmitted), as flow control permits, until all have been
        serviced.  Thus, it should be acceptable to make several SEND
        calls, followed by a CLOSE, and expect all the data to be sent
        to the destination.  It should also be clear that users should
        continue to RECEIVE on CLOSING connections, since the other side
        may be trying to transmit the last of its data.  Thus, CLOSE
        means "I have no more to send" but does not mean "I will not
        receive any more."  It may happen (if the user level protocol is
        not well thought out) that the closing side is unable to get rid
```

- 시간 초과되기 전에 모든 데이터를 삭제합니다. 이 경우 CLOSE는 ABORT로 바뀌고 닫는 TCP는 포기됩니다.

- 사용자는 자신의 주도로 또는 TCP의 다양한 프롬프트\(예: 원격 닫기 실행, 전송 시간 초과 초과, 대상 액세스 불가\)에 대한 응답으로 언제든지 연결을 닫을 수 있습니다.

- 연결을 종료하려면 외부 TCP와의 통신이 필요하므로 연결이 잠시 종료 상태로 유지될 수 있습니다. TCP가 CLOSE 명령에 응답하기 전에 연결을 다시 열려고 하면 오류 응답이 발생합니다.

- Close는 편지의 끝을 의미하기도 합니다.

```text
      Status

        Format:  STATUS(local connection name)
```

- 이것은 구현 종속 사용자 명령이며 역효과 없이 제외될 수 있습니다. 반환된 정보는 일반적으로 연결과 관련된 TCB에서 가져옵니다.

- 이 명령은 다음 정보가 포함된 데이터 블록을 반환합니다.

로컬 소켓,

- 외부 소켓, 로컬 연결 이름, 수신 창, 전송 창, 연결 상태, 승인 대기 버퍼 수, 수신 대기 버퍼 수\(부분 버퍼 포함\), 수신 버퍼 크기, 긴급 상태, 우선 순위, 보안/구획 및 기본 전송 시간 초과.

연결 상태에 따라 또는

- 구현 자체에서 이 정보 중 일부는 사용 가능하지 않거나 의미가 없을 수 있습니다. 호출 프로세스가 이 연결을 사용할 권한이 없으면 오류가 반환됩니다. 이렇게 하면 승인되지 않은 프로세스가 연결에 대한 정보를 얻는 것을 방지할 수 있습니다.

```text
      Abort

        Format:  ABORT (local connection name)
```

- 이 명령은 보류 중인 모든 SEND 및 RECEIVES가 중단되고 TCB가 제거되며 특수 RESET 메시지가 연결의 다른 쪽에서 TCP로 전송되도록 합니다. 구현에 따라 사용자는 각 미해결 SEND 또는 RECEIVE에 대한 중단 표시를 받거나 단순히 ABORT 승인을 받을 수 있습니다.

```text
    TCP-to-User Messages
```

- 운영 체제 환경은 TCP가 사용자 프로그램에 비동기적으로 신호를 보낼 수 있는 수단을 제공한다고 가정합니다. TCP가 사용자 프로그램에 신호를 보내면 특정 정보가 사용자에게 전달됩니다. 종종 사양에서 정보는 오류 메시지가 됩니다. 다른 경우에는 SEND 또는 RECEIVE 또는 다른 사용자 호출 처리 완료와 관련된 정보가 있습니다.

- 제공되는 정보는 다음과 같습니다.

```text
        Local Connection Name                    Always
        Response String                          Always
        Buffer Address                           Send & Receive
        Byte count (counts bytes received)       Receive
        End-of-Letter flag                       Receive
        End-of-Urgent flag                       Receive

  TCP/Network Interface
```

TCP는 실제로 네트워크를 통해 정보를 보내고 받기 위해 하위 수준 프로토콜 모듈을 호출합니다. 그 중 하나는 하위 레벨 모듈이 인터넷 프로토콜인 ARPA 인터네트워크 시스템의 경우입니다\[2\]. 대부분의 경우 다음과 같은 간단한 인터페이스가 적합합니다.

다음 두 호출은 TCP와 인터넷 프로토콜 모듈 간 통신에 대한 요구 사항을 충족합니다.

```text
      SEND (dest, TOS, TTL, BufPTR, len, Id, DF, options => result)

        where:

          dest = destination address
          TOS = type of service
          TTL = time to live
          BufPTR = buffer pointer
          len = length of buffer
          Id  = Identifier
          DF = Don't Fragment
          options = internet option data
          result = response
            OK = datagram sent ok
            Error = error in arguments or local network error
```

우선순위는 TOS에 포함되어 있으며

- 보안/구획이 옵션으로 전달됩니다.

```text
      RECV (BufPTR => result, source, dest, prot, TOS, len)

        where:

          BufPTR = buffer pointer
          result = response
            OK = datagram received ok
            Error = error in arguments
          source = source address
          dest = destination address
          prot = protocol
          TOS = type of service
          options = internet option data
          len = length of buffer
```

우선순위는 TOS에 있으며

- 보안/구획은 옵션입니다.

- TCP가 세그먼트를 보낼 때 모든 인수를 제공하는 SEND 호출을 실행합니다. 인터넷 프로토콜 모듈은 이 호출을 받으면 인수를 확인하고 메시지를 준비하고 보냅니다. 인수가 양호하고 세그먼트가 로컬 네트워크에서 승인되면 호출이 성공적으로 반환됩니다. 인수가 잘못되었거나 로컬 네트워크에서 세그먼트를 승인하지 않으면 호출이 성공적으로 반환되지 않습니다. 반품이 실패한 경우, 반품 원인에 대해 합리적인 보고가 이루어져야 합니다.

- 문제가 있지만 이러한 보고서의 세부 사항은 개별 구현에 달려 있습니다.

- 세그먼트가 로컬 네트워크에서 인터넷 프로토콜 모듈에 도착하면 TCP에서 보류 중인 RECV 호출이 있거나 없습니다. 첫 번째 경우 보류 중인 호출은 세그먼트의 정보를 TCP로 전달하여 충족됩니다. 두 번째 경우에는 TCP에 보류 중인 세그먼트에 대한 알림이 전달됩니다.

- TCP 통지는 구현의 특정 운영 체제 환경에 따라 의사 인터럽트 또는 유사한 메커니즘을 통해 이루어질 수 있습니다.

- TCP의 RECV 호출은 보류 중인 세그먼트에 의해 즉시 충족되거나 세그먼트가 도착할 때까지 호출이 보류될 수 있습니다.

- 인터넷 프로토콜은 서비스 유형과 수명에 대한 주장을 제공합니다. TCP는 이러한 매개변수에 대해 다음 설정을 사용합니다.

서비스 유형 = 우선순위: 없음, 패키지: 스트림,

- 신뢰성: 높음, 선호도: 속도, 속도: 높음; 또는 00011111.

- TTL\(Time to Live\) = 1분 또는 00111100.

- 가정된 최대 세그먼트 수명은 2분입니다. 여기서는 인터넷 시스템에서 1분 이내에 세그먼트를 전달할 수 없는 경우 세그먼트를 삭제하도록 명시적으로 요청합니다.

---
### **3.9.  Event Processing**

TCP의 활동은 이벤트에 대한 응답으로 특징지을 수 있습니다. 발생하는 이벤트는 사용자 호출, 도착 세그먼트 및 시간 초과의 세 가지 범주로 캐스트될 수 있습니다. 이 섹션에서는 각 이벤트에 대한 응답으로 TCP가 수행하는 처리를 설명합니다. 대부분의 경우 필요한 처리는 연결 상태에 따라 다릅니다.

발생하는 이벤트:

```text
      User Calls

        OPEN
        SEND
        RECEIVE
        CLOSE
        ABORT
        STATUS

      Arriving Segments

        SEGMENT ARRIVES

      Timeouts

        USER TIMEOUT
        RETRANSMISSION TIMEOUT
```

TCP/사용자 인터페이스의 모델은 사용자 명령이 이벤트 또는 의사 인터럽트를 통해 즉각적인 반환과 지연된 응답을 받는 것입니다. 다음 설명에서 "신호"라는 용어는 지연된 응답을 유발하는 것을 의미합니다.

오류 응답은 문자열로 제공됩니다. 예를 들어 존재하지 않는 연결을 참조하는 사용자 명령은 "오류: 연결이 열리지 않음"을 수신합니다.

다음에서 시퀀스 번호, 승인 번호, 창 등에 대한 모든 산술은 시퀀스 번호 공간 크기의 모듈로 2\*\*32라는 점에 유의하세요. 또한 "=<"는 작거나 같음을 의미합니다.

수신 세그먼트 처리에 대해 생각하는 자연스러운 방법은 세그먼트가 먼저 적절한 시퀀스 번호\(즉, 해당 내용이 시퀀스 번호 공간에서 예상되는 "수신 창" 범위에 있음\)에 대해 테스트된 다음 일반적으로 다음과 같다고 상상하는 것입니다. 시퀀스 번호 순서대로 대기 및 처리됩니다.

세그먼트가 이미 수신된 다른 세그먼트와 겹치면 새 데이터만 포함하도록 세그먼트를 재구성하고 헤더 필드를 일관되게 조정합니다.

```text
  OPEN Call

    CLOSED STATE (i.e., TCB does not exist)
```

- 연결 상태 정보를 보관하기 위해 새로운 전송 제어 블록\(TCB\)을 생성합니다. 로컬 소켓 식별자, 외부 소켓, 우선 순위, 보안/구획 및 사용자 시간 초과 정보를 입력합니다. "오류: 우선순위가 허용되지 않음" 또는 "오류: 보안/구획이 허용되지 않음"을 반환하지 않는 경우 요청된 보안 및 우선순위가 이 사용자에게 허용되는지 확인하십시오. 활성 상태이고 외부 소켓이 지정되지 않은 경우 "오류: 외부 소켓이 지정되지 않았습니다"를 반환합니다. 활성 상태이고 외부 소켓이 지정된 경우 SYN 세그먼트를 발행하십시오. 초기 ISS\(송신 시퀀스 번호\)가 선택되고 TCP 수신 버퍼 크기가 선택됩니다\(해당되는 경우\). <SEQ=ISS\><CTL=SYN\> 형식의 SYN 세그먼트가 전송됩니다\(해당되는 경우 버퍼 크기 옵션이 포함될 수 있음\). SND.UNA를 ISS로, SND.NXT를 ISS+1로, SND.LBB를 ISS+1로 설정하고 SYN-SENT 상태로 들어가서 돌아옵니다.

- 호출자가 지정된 로컬 소켓에 대한 액세스 권한이 없으면 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다. 새 연결을 만들 공간이 없으면 "오류: 리소스 부족"을 반환합니다.

```text
    LISTEN STATE
    SYN-SENT STATE
    SYN-RECEIVED STATE
    ESTABLISHED STATE
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
    TIME-WAIT STATE
    CLOSE-WAIT STATE
    CLOSING STATE

      Return "error:  connection already exists".

  SEND Call

    CLOSED STATE (i.e., TCB does not exist)
```

- 사용자가 이러한 연결에 액세스할 수 없어야 하는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
      Otherwise, return "error:  connection does not exist".

    LISTEN STATE
```

- 외부 소켓이 지정된 경우 연결을 수동에서 활성으로 변경하고 ISS를 선택한 다음 수신 버퍼 크기를 선택합니다. SYN 세그먼트를 보내고 SND.UNA를 ISS로, SND.NXT를 ISS+1로, SND.LBB를 ISS+1로 설정합니다. SYN-SENT 상태로 들어갑니다. SEND와 관련된 데이터는 SYN 세그먼트와 함께 전송되거나 ESTABLISHED 상태로 들어간 후 전송을 위해 대기할 수 있습니다. 명령에서 요청된 경우 긴급 비트는 이 명령의 결과로 전송된 첫 번째 데이터 세그먼트와 함께 전송되어야 합니다. 요청을 대기열에 넣을 공간이 없으면 "오류: 리소스 부족"으로 응답합니다. 외부 소켓이 지정되지 않은 경우 "오류: 외부 소켓이 지정되지 않았습니다"를 반환합니다.

```text
    SYN-SENT STATE
```

연결 후 처리를 위한 큐가 ESTABLISHED됩니다.

- 일반적으로 상대방이 아직 보내기 창을 설정하지 않았기 때문에 아직 아무 것도 보낼 수 없습니다. 공백이 없으면 "오류: 리소스 부족"을 반환합니다.

```text
    SYN-RECEIVED STATE
```

- ESTABLISHED 상태로 진입한 후 이후 처리를 위한 큐입니다. 대기열에 넣을 공간이 없으면 "오류: 리소스 부족"으로 응답합니다.

```text
    ESTABLISHED STATE
```

- 데이터와 함께 피기백 승인\(승인 값 = RCV.NXT\)을 사용하여 버퍼를 분할하고 출력을 위해 보내거나 대기열에 넣습니다. 이 버퍼를 기억할 공간이 충분하지 않은 경우 간단히 "오류: 리소스 부족"을 반환합니다.

- 원격 버퍼 크기가 1 옥텟이 아닌 경우 문자 끝인 경우 다음과 같은 문자 끝/버퍼 크기 조정 처리를 수행합니다.

```text
        if EOL = 0 then

          SND.NXT <- SEG.SEQ + SEG.LEN

        if EOL = 1 then

          While SND.LBB < SEG.SEQ + SEG.LEN
          Do SND.LBB <- SND.LBB + SND.BS End
          SND.NXT <- SND.LBB
```

- 긴급 플래그가 설정된 경우 SND.UP <- SND.NXT-1이고 나가는 세그먼트에 긴급 포인터를 설정합니다.

```text
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
    TIME-WAIT STATE
```

- "오류: 연결 종료"를 반환하고 요청을 서비스하지 않습니다.

```text
    CLOSE-WAIT STATE

      Segmentize any text to be sent and queue for output.  If there is
      insufficient space to remember the SEND, return "error:
      insufficient resources"

    CLOSING STATE

      Respond with "error:  connection closing"

  RECEIVE Call

    CLOSED STATE (i.e., TCB does not exist)
```

- 사용자가 이러한 연결에 액세스할 수 없어야 하는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
      Otherwise return "error:  connection does not exist".

    LISTEN STATE
    SYN-SENT STATE
    SYN-RECEIVED STATE
```

- ESTABLISHED 상태 진입 후 처리를 위한 대기열. 이 요청을 대기할 공간이 없으면 "오류: 리소스 부족"으로 응답합니다.

```text
    ESTABLISHED STATE
```

- 수신 세그먼트가 충분하지 않아 요청을 충족할 수 없으면 요청을 대기열에 넣습니다. RECEIVE를 기억할 대기열 공간이 없으면 "오류: 리소스 부족"으로 응답합니다.

- 대기열에 있는 수신 세그먼트를 수신 버퍼로 재조립하고 사용자에게 반환합니다. 이 경우 "문자 끝"\(EOL\)을 표시하십시오.

- RCV.UP이 현재 사용자에게 전달되고 있는 데이터보다 앞서 있는 경우 긴급한 데이터가 있음을 사용자에게 알립니다.

- TCP가 사용자에게 데이터를 전달하는 책임을 지는 경우 승인을 통해 발신자에게 해당 사실을 전달해야 합니다. 이러한 승인의 형성은 들어오는 세그먼트 처리에 대한 논의에서 아래에 설명되어 있습니다.

```text
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
```

- 사용자 버퍼에 문자를 재조립하여 반환합니다. 즉시 처리할 수 없는 경우 요청을 대기열에 넣습니다.

```text
    TIME-WAIT STATE
    CLOSE-WAIT STATE
```

- 원격측에서 이미 FIN을 보냈기 때문에 RECEIVE는 이미 재조립되었지만 아직 사용자에게 전달되지 않은 텍스트로 만족되어야 합니다. 재조립된 세그먼트 텍스트가 배달을 기다리고 있지 않은 경우 RECEIVE는 "error: 연결 종료" 응답을 받아야 합니다. 그렇지 않으면 나머지 텍스트를 사용하여 RECEIVE를 만족시킬 수 있습니다.

```text
    CLOSING STATE

      Return "error:  connection closing"

  CLOSE Call

    CLOSED STATE (i.e., TCB does not exist)
```

- 사용자가 이러한 연결에 액세스할 수 없어야 하는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
      Otherwise, return "error:  connection does not exist".

    LISTEN STATE
```

- 모든 미해결 RECEIVE는 "error: Closing" 응답과 함께 반환되어야 합니다. TCB를 삭제하고 "ok"를 반환합니다.

```text
    SYN-SENT STATE
```

- TCB를 삭제하고 대기 중인 모든 SEND 또는 RECEIVE에 대해 "오류: 종료" 응답을 반환합니다.

```text
    SYN-RECEIVED STATE
```

ESTABLISHED 상태로 진입한 후 처리를 위한 큐 또는

- FIN 세그먼트를 분할하여 전송합니다. 후자의 경우 FIN-WAIT-1 상태로 들어갑니다.

```text
    ESTABLISHED STATE
```

- 이전의 모든 SEND가 세그먼트화될 때까지 이것을 대기시킨 다음 FIN 세그먼트를 형성하고 전송합니다. 어쨌든 FIN-WAIT-1 상태로 들어갑니다.

```text
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
```

- 엄밀히 말하면 이것은 오류이며 "오류: 연결 종료" 응답을 받아야 합니다. 두 번째 FIN이 방출되지 않는 한 "ok" 응답도 허용됩니다\(첫 번째 FIN은 재전송될 수 있음\).

```text
    TIME-WAIT STATE
```

- 엄밀히 말하면 이것은 오류이며 "오류: 연결 종료" 응답을 받아야 합니다. "ok" 응답도 허용됩니다. 그러나 FIN이 전송되고 승인되었으므로 아무 것도 전송\(또는 재전송\)해서는 안 됩니다.

```text
    CLOSE-WAIT STATE
```

이전의 모든 SEND가 완료될 때까지 이 요청을 대기열에 넣습니다.

- 세분화; 그런 다음 FIN 세그먼트를 보내고 CLOSING 상태로 들어갑니다.

```text
    CLOSING STATE

      Respond with "error:  connection closing"

  ABORT Call

    CLOSED STATE (i.e., TCB does not exist)
```

- 사용자가 이러한 연결에 액세스할 수 없어야 하는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
      Otherwise return "error:  connection does not exist".

    LISTEN STATE
```

모든 미해결 RECEIVE는 "오류:

- 연결 재설정" 응답. TCB를 삭제하고 "확인"을 반환합니다.

```text
    SYN-SENT STATE
```

- TCB를 삭제하고 대기 중인 SEND 또는 RECEIVE에 "재설정" 응답을 반환합니다.

```text
    SYN-RECEIVED STATE
```

- 다음 형식의 RST를 보냅니다.

```text
        <SEQ=SND.NXT><ACK=RCV.NXT><CTL=RST,ACK>
```

- 처리되지 않은 SEND 또는 "재설정" 코드가 있는 RECEIVE를 반환하고 TCB를 삭제합니다.

```text
    ESTABLISHED STATE
```

- 재설정 세그먼트 보내기:

```text
        <SEQ=SND.NXT><ACK=RCV.NXT><CTL=RST,ACK>
```

- 대기 중인 모든 SEND 및 RECEIVE에는 "재설정" 응답이 제공되어야 합니다. 전송\(위에 형성된 RST 제외\) 또는 재전송을 위해 대기 중인 모든 세그먼트를 플러시해야 하며, TCB를 삭제합니다.

```text
    FIN-WAIT-1 STATE
    FIN-WAIT-2 STATE
```

- 재설정 세그먼트\(RST\)가 구성되어 전송되어야 합니다.

```text
        <SEQ=SND.NXT><ACK=RCV.NXT><CTL=RST,ACK>
```

- 미해결 ​​SEND, RECEIVE, CLOSE 및/또는 재전송 또는 분할을 위해 대기열에 있는 세그먼트는 사용자에게 "연결 재설정" 알림과 함께 플러시되어야 하며 TCB를 삭제해야 합니다.

```text
    TIME-WAIT STATE
```

- "ok"으로 응답하고 TCB를 삭제합니다.

```text
    CLOSE-WAIT STATE
```

- 보류 중인 SEND 및 RECEIVE를 플러시하여 "연결 재설정" 응답을 반환합니다. RST 세그먼트를 구성하고 전송합니다.

```text
        <SEQ=SND.NXT><ACK=RCV.NXT><CTL=RST,ACK>
```

- 모든 세그먼트 대기열을 비우고 TCB를 삭제합니다.

```text
    CLOSING STATE
```

- "확인"으로 응답하고 TCB를 삭제합니다. 나머지 세그먼트 대기열을 모두 플러시합니다. CLOSE 명령이 아직 보류 중인 경우 "error: 연결 재설정"이라고 응답합니다.

```text
  STATUS Call

    CLOSED STATE (i.e., TCB does not exist)
```

- 사용자가 이러한 연결에 액세스할 수 없어야 하는 경우 "오류: 이 프로세스에 대한 연결이 잘못되었습니다"를 반환합니다.

```text
      Otherwise return "error:  connection does not exist".

    LISTEN STATE
```

- "state = LISTEN" 및 TCB 포인터를 반환합니다.

```text
    SYN-SENT STATE
```

- "상태 = SYN-SENT" 및 TCB 포인터를 반환합니다.

```text
    SYN-RECEIVED STATE
```

- "상태 = SYN-RECEIVED" 및 TCB 포인터를 반환합니다.

```text
    ESTABLISHED STATE
```

- "state = ESTABLISHED" 및 TCB 포인터를 반환합니다.

```text
    FIN-WAIT-1 STATE
```

- "상태 = FIN-WAIT-1" 및 TCB 포인터를 반환합니다.

```text
    FIN-WAIT-2 STATE
```

- "상태 = FIN-WAIT-2" 및 TCB 포인터를 반환합니다.

```text
    TIME-WAIT STATE
```

- "상태 = TIME-WAIT 및 TCB 포인터를 반환합니다.

```text
    CLOSE-WAIT STATE
```

- "state = CLOSE-WAIT" 및 TCB 포인터를 반환합니다.

```text
    CLOSING STATE
```

- "state = CLOSING" 및 TCB 포인터를 반환합니다.

```text
  SEGMENT ARRIVES

    If the state is CLOSED (i.e., TCB does not exist) then
```

- 들어오는 세그먼트의 모든 데이터가 삭제됩니다. RST를 포함하는 수신 세그먼트는 폐기됩니다. RST를 포함하지 않는 수신 세그먼트로 인해 응답으로 RST가 전송됩니다. 잘못된 세그먼트를 보낸 TCP에서 재설정 시퀀스를 수락할 수 있도록 승인 및 시퀀스 필드 값이 선택됩니다.

- ACK 비트가 OFF이면 시퀀스 번호 0이 사용되며,

```text
        <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>
```

- ACK 비트가 ON이면

```text
        <SEQ=SEG.ACK><CTL=RST>

      Return.

    If the state is LISTEN then
```

- 먼저 ACK를 확인합니다.

- 여전히 LISTEN 상태인 ​​연결에 도착하면 모든 승인이 잘못된 것입니다. 다른 RST를 제외하고 도착하는 ACK 베어링 세그먼트에 대해 허용 가능한 재설정 세그먼트가 형성되어야 합니다. RST는 다음과 같은 형식이어야 합니다.

```text
          <SEQ=SEG.ACK><CTL=RST>

        Return.
```

- 들어오는 RST는 무시해야 합니다. 반품.

- ACK가 없으면 SYN을 확인합니다.

SYN 비트가 설정된 경우 보안을 확인하십시오. 만약

- 수신 세그먼트의 보안/구획이 TCB의 보안/구획과 정확히 일치하지 않으면 재설정을 보내고 반환합니다. SEG.PRC가 TCB.PRC보다 작으면 재설정을 보내고 반환합니다. SEG.PRC가 TCB.PRC보다 큰 경우 TCB.PRC<-SEG.PRC를 설정합니다. 이제 RCV.NXT 및 RCV.LBB는 SEG.SEQ+1로 설정되고 IRS는 SEG.SEQ로 설정되며 다른 컨트롤이나 텍스트는 나중에 처리하기 위해 대기열에 있어야 합니다. ISS를 선택하고 다음 형식의 SYN 세그먼트를 전송해야 합니다.

```text
          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>
```

- SND.NXT 및 SND.LBB는 ISS+1로, SND.UNA는 ISS로 설정됩니다. 연결 상태를 SYN-RECEIVED로 변경해야 합니다. 다른 모든 수신 제어 또는 데이터\(SYN과 결합\)는 SYN-RECEIVED 상태에서 처리되지만 SYN 및 ACK 처리는 반복되어서는 안 됩니다. 청취가 완전히 지정되지 않은 경우\(즉, 외부 소켓이 완전히 지정되지 않은 경우\) 지정되지 않은 필드를 지금 채워야 합니다.

- SYN은 없지만 다른 텍스트나 컨트롤이 있는 경우

- 다른 제어 또는 텍스트 포함 세그먼트\(SYN을 포함하지 않음\)에는 ACK가 있어야 하므로 ACK 처리에 의해 폐기됩니다. 들어오는 RST 세그먼트는 이 연결 화신에 의해 전송된 어떤 것에 대한 응답으로 전송될 수 없기 때문에 유효하지 않을 수 있습니다. 따라서 여기에 도달할 가능성은 없지만 만약 도달한다면 세그먼트를 삭제하고 돌아오십시오.

```text
    If the state is SYN-SENT then
```

- 먼저 ACK를 확인합니다.

```text
        If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, or the
        security/compartment in the segment does not exactly match the
        security/compartment in the TCB, or the precedence in the
        segment is less than the precedence in the TCB, send a reset

          <SEQ=SEG.ACK><CTL=RST>
```

- 그리고 세그먼트를 폐기합니다. 반품.

- SND.UNA =< SEG.ACK =< SND.NXT이고 보안/구획 및 우선 순위가 허용되는 경우 ACK가 허용됩니다. SND.UNA는 SEG.ACK와 동일하도록 진행되어야 하며, 이로 인해 확인된 재전송 큐의 모든 세그먼트는 제거되어야 합니다.

- ACK가 정상이면\(또는 ACK가 없으면\) RST 비트를 확인합니다.

- RST 비트가 설정되면 사용자에게 "오류: 연결 재설정" 신호를 보내고 CLOSED 상태로 들어가서 세그먼트를 삭제하고 TCB를 삭제한 후 반환합니다.

- ACK가 정상이고\(또는 ACK가 없는 경우\) RST가 아닌 경우 SYN 비트를 확인합니다.

- SYN 비트가 켜져 있고 보안/구획 및 우선 순위가 허용 가능한 경우 RCV.NXT 및 RCV.LBB는 SEG.SEQ+1로 설정되고 IRS는 SEG.SEQ로 설정됩니다. SND.UNA \> ISS\(SYN이 ACK됨\)인 경우 연결 상태를 ESTABLISHED로 변경하고, 그렇지 않으면 SYN-RECEIVED를 입력합니다. 어떤 경우든 ACK 세그먼트를 구성합니다.

```text
          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

그리고 보내세요. 대기 중인 데이터 또는 컨트롤

- 전송이 포함될 수 있습니다.

- SEG.PRC가 TCB.PRC보다 큰 경우 TCB.PRC<-SEG.PRC를 설정합니다.

- 세그먼트에 다른 컨트롤이나 텍스트가 있는 경우 URG 비트가 확인되는 아래 다섯 번째 단계에서 처리를 계속하고, 그렇지 않으면 반환합니다.

```text
    Otherwise,

    first check sequence number

      SYN-RECEIVED STATE
      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE
      TIME-WAIT STATE
      CLOSE-WAIT STATE
      CLOSING STATE
```

- 세그먼트는 순서대로 처리됩니다. 도착 시 초기 테스트는 이전 중복을 폐기하는 데 사용되지만 추가 처리는 SEG.SEQ 순서로 수행됩니다. 세그먼트의 내용이 이전 부분과 새 부분 사이의 경계에 걸쳐 있는 경우 새 부분만 처리해야 합니다.

- 들어오는 세그먼트에 대한 적합성 테스트에는 네 가지 경우가 있습니다.

```text
        Segment Receive  Test
        Length  Window
        ------- -------  -------------------------------------------

           0       0     SEG.SEQ = RCV.NXT

           0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

          >0       0     not acceptable

          >0      >0     RCV.NXT < SEG.SEQ+SEG.LEN =< RCV.NXT+RCV.WND
```

- 위의 테스트는 세그먼트에서 사용된 마지막 시퀀스 번호가 수신 창에 있음을 보장합니다. RCV.WND가 0이면 어떤 세그먼트도 허용되지 않지만 유효한 ACK, URG 및 RST를 허용하려면 특별한 허용이 이루어져야 합니다.

- 들어오는 세그먼트가 허용되지 않는 경우 응답으로 승인을 보내야 합니다.

```text
          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

- 들어오는 세그먼트가 허용되지 않으면 이를 삭제하고 반환합니다.

```text
    second check security and precedence
```

- 세그먼트의 보안/구획 및 우선순위가 TCB의 보안/구획 및 우선순위와 정확히 일치하지 않는 경우 재설정을 구성하고 반환합니다.

- 이 검사는 보안이나 우선 순위가 다른 부분 사이의 이전 연결에서 세그먼트가 현재 연결을 중단하는 것을 방지하기 위해 시퀀스 검사 후에 수행됩니다.

```text
    third check the ACK field,

      SYN-RECEIVED STATE
```

- RST 비트가 꺼지고 SND.UNA < SEG.ACK =< SND.NXT인 경우 SND.UNA <- SEG.ACK를 설정하고 재전송 대기열에서 확인된 세그먼트를 제거하고 ESTABLISHED 상태로 들어갑니다.

```text
        If the segment acknowledgment is not acceptable, form a reset
        segment,

          <SEQ=SEG.ACK><CTL=RST>
```

- 수신 세그먼트가 RST\(또는 ACK가 없는 경우\)가 아니면 이를 전송하고, 이 경우 이를 폐기한 후 반환합니다.

```text
      ESTABLISHED STATE
```

- SND.UNA < SEG.ACK =< SND.NXT인 경우 SND.UNA <- SEG.ACK를 설정합니다. 완전히 승인된 재전송 큐의 모든 세그먼트는 제거됩니다. 사용자는 SENT되고 완전히 확인된 버퍼에 대해 긍정적인 확인을 받아야 합니다\(즉, SEND 버퍼는 "ok" 응답과 함께 반환되어야 함\). ACK가 중복된 경우 무시할 수 있습니다.

- 세그먼트가 시퀀스 번호 및 승인 번호 테스트를 통과하면 전송 창을 업데이트해야 합니다. SND.WL =< SEG.SEQ인 경우 SND.WND <- SEG.WND를 설정하고 SND.WL <- SEG.SEQ를 설정합니다.

```text
        If the remote buffer size is not one, then the
        end-of-letter/buffer-size adjustment to sequence numbers may
        have an effect on the next expected sequence number to be
        acknowledged.  It is possible that the remote TCP will
        acknowledge with a SEG.ACK equal to a sequence number of an
```

- 문자 끝에서 건너뛴 옥텟. 이는 원격 TCP 부분의 가벼운 오류이지만 경보를 유발하지는 않습니다.

```text
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE
```

- ESTABLISHED 상태에 대한 처리 외에 재전송 큐가 비어 있으면 사용자의 CLOSE를 승인\("ok"\)할 수 있지만 TCB를 삭제하지는 않습니다.

```text
      TIME-WAIT STATE
```

- 이 상태에서 도달할 수 있는 것은 원격 FIN의 재전송뿐이다. 이를 확인하고 2 MSL 시간 초과를 다시 시작합니다.

```text
      CLOSE-WAIT STATE
```

- ESTABLISHED 상태와 동일하게 처리합니다.

```text
      CLOSING STATE
```

- ACK가 FIN을 확인하면 TCB를 삭제하고\(CLOSED 상태로 진입\) 그렇지 않으면 세그먼트를 무시합니다.

```text
    fourth check the RST bit,

      SYN-RECEIVED STATE
```

- RST 비트가 설정되면 세그먼트가 시퀀스 및 승인 테스트를 통과한 경우 유효합니다. 이 연결이 수동적 OPEN으로 시작된 경우\(즉, LISTEN 상태에서 나온 경우\) 이 연결을 LISTEN 상태로 되돌립니다. 사용자에게 알릴 필요는 없습니다. 이 연결이 활성 OPEN으로 시작된 경우\(즉, SYN-SENT 상태에서 나온 경우\) 연결이 거부되었으며 사용자에게 "연결이 거부되었습니다"라는 신호를 보냅니다. 두 경우 모두 재전송 큐의 모든 세그먼트를 제거해야 합니다.

```text
      ESTABLISHED
      FIN-WAIT-1
      FIN-WAIT-2
      CLOSE-WAIT
      CLOSING STATE
```

- RST 비트가 설정되면 미해결 RECEIVE 및 SEND는 "재설정" 응답을 수신해야 합니다. 모든 세그먼트 대기열을 플러시해야 합니다. 사용자는 요청하지 않은 일반 "연결 재설정" 신호도 수신해야 합니다. CLOSED 상태로 들어가 TCB를 삭제하고 돌아갑니다.

```text
      TIME-WAIT
```

- CLOSED 상태로 진입하여 TCB를 삭제하고 복귀합니다.

```text
    fifth, check the SYN bit,

      SYN-RECEIVED
      ESTABLISHED STATE
```

- SYN 비트가 설정된 경우 수신 창과 비교하여 세그먼트 시퀀스 번호를 확인합니다. 세그먼트 시퀀스 번호는 수신 창에 있어야 합니다. 그렇지 않은 경우 해당 세그먼트를 무시하십시오. SYN이 켜져 있고 SEG.SEQ = IRS이면 모든 것이 정상이며 조치가 필요하지 않습니다. 그러나 동일하지 않으면 오류가 발생하므로 재설정을 보내야 합니다.

- 재설정을 전송해야 하는 경우 다음과 같이 구성됩니다.

```text
            <SEQ=SEG.ACK><CTL=RST>
```

- RST를 받은 것처럼 연결을 중단해야 합니다.

```text
      FIN-WAIT STATE-1
      FIN-WAIT STATE-2
      TIME-WAIT STATE
      CLOSE-WAIT STATE
      CLOSING STATE
```

- 현재 연결 구현을 시작한 SYN의 중복이 SEG.SEQ 처리에서 필터링되므로 이 경우가 발생해서는 안 됩니다. 다른 SYN도 이 테스트에서 거부됩니다\(설정된 상태에 대한 SYN 처리 참조\).

```text
    sixth, check the URG bit,

      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE
```

- URG 비트가 설정되어 있으면 RCV.UP <- max\(RCV.UP,SEG.UP\), 긴급 포인터\(RCV.UP\)가 데이터 앞에 있으면 원격 측에 긴급 데이터가 있음을 사용자에게 알립니다. 소비. 사용자가 이 연속적인 긴급 데이터 시퀀스에 대해 이미 신호를 받은 경우\(또는 여전히 "긴급 모드"에 있는 경우\) 사용자에게 다시 신호를 보내지 마십시오.

```text
      TIME-WAIT STATE
      CLOSE-WAIT STATE
      CLOSING
```

- FIN이 원격 측에서 수신되었으므로 이런 일이 발생하지 않아야 합니다. URG를 무시하십시오.

```text
    seventh, process the segment text,

      ESTABLISHED STATE
```

- ESTABLISHED 상태가 되면 세그먼트 텍스트를 사용자 RECEIVE 버퍼로 전달할 수 있습니다. 버퍼가 가득 차거나 세그먼트가 비어 있을 때까지 세그먼트의 텍스트를 버퍼로 이동할 수 있습니다. 세그먼트가 비어 있고 EOL 플래그를 전달하는 경우 버퍼가 반환될 때 EOL이 수신되었음을 사용자에게 알립니다.

버퍼 크기가 1옥텟이 아닌 경우 다음을 수행합니다.

- 문자 끝/버퍼 크기 조정 처리:

```text
          if EOL = 0 then

            RCV.NXT <- SEG.SEQ + SEG.LEN

          if EOL = 1 then
```

RCV.LBB < SEG.SEQ+SEG.LEN

- RCV.LBB 수행 <- RCV.LBB + RCV.BS 종료 RCV.NXT <- RCV.LBB

- TCP가 사용자에게 데이터를 전달하는 책임을 맡을 때 데이터 수신을 승인해야 합니다. 양식에 대한 승인을 보냅니다.

```text
          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

- 이 승인은 가능한 한 과도한 지연 없이 전송되는 세그먼트에 피기백되어야 합니다.

```text
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE
```

- 미해결 ​​RECEIVE가 있는 경우 가능하면 이 세그먼트의 텍스트에 만족해야 합니다. 나머지 텍스트는 추가 처리를 위해 대기열에 있어야 합니다. RECEIVE가 만족되면 적절한 경우 "EOL\(end-of-letter\)" 신호를 통해 사용자에게 알려야 합니다.

```text
      TIME-WAIT STATE
      CLOSE-WAIT STATE
```

- FIN이 원격 측에서 수신되었으므로 이런 일이 발생하지 않아야 합니다. 세그먼트 텍스트를 무시하십시오.

```text
    eighth, check the FIN bit,
```

- FIN에 대한 승인을 보냅니다. 사용자에게 "연결 종료" 신호를 보내고 동일한 메시지와 함께 보류 중인 RECEIVE를 반환합니다. FIN은 아직 사용자에게 전달되지 않은 세그먼트 텍스트에 대해 EOL을 의미합니다. 현재 상태가 ESTABLISHED이면 CLOSE-WAIT 상태로 들어갑니다. 현재 상태가 FIN-WAIT-1이면 CLOSING 상태로 진입한다. 현재 상태가 FIN-WAIT-2이면 TIME-WAIT 상태로 진입한다.

그리고 돌아갑니다.

```text
  USER TIMEOUT
```

어떤 상태에서든 사용자 시간 초과가 만료되면 모든 대기열을 비우고 일반적으로 사용자에게 "오류: 사용자 시간 초과로 인해 연결이 중단되었습니다"라는 신호를 보내고 미해결 호출의 경우 TCB를 삭제하고 반환합니다.

```text
  RETRANSMISSION TIMEOUT
```

어떤 상태에서든 재전송 큐의 세그먼트에서 재전송 타임아웃이 만료되면 재전송 큐의 맨 앞에 있는 세그먼트를 다시 보내고 재전송 타이머를 다시 초기화한 다음 반환합니다.

```text
   

                                GLOSSARY
```

1822 BBN 보고서 1822, "호스트와 IMP의 상호 연결 사양". 호스트와 ARPANET 간의 인터페이스 사양입니다.

ACK 시퀀스 공간을 차지하지 않는 제어 비트\(확인\). 이 세그먼트의 확인 필드는 이 세그먼트의 송신자가 받을 것으로 예상하는 다음 시퀀스 번호를 지정하므로 모든 이전 시퀀스 번호의 수신을 확인합니다.

ARPANET 메시지 ARPANET에서 호스트와 IMP 사이의 전송 단위. 최대 크기는 약 1012옥텟\(8096비트\)입니다.

ARPANET 패킷 IMP 사이의 ARPANET에서 내부적으로 사용되는 전송 단위. 최대 크기는 약 126옥텟\(1008비트\)입니다.

버퍼 크기 이 옵션을 보낸 사람의 수신 데이터 버퍼 크기를 지정하는 데 사용되는 옵션\(버퍼 크기\)입니다. SYN을 포함하는 세그먼트에서만 전송될 수 있습니다.

연결 한 쌍의 소켓으로 식별되는 논리적 통신 경로입니다.

데이터그램 패킷 교환 컴퓨터 통신 네트워크에서 전송되는 메시지.

대상 주소 대상 주소, 일반적으로 네트워크 및 호스트 식별자입니다.

EOL 시퀀스 공간을 차지하지 않는 제어 비트\(문자 끝\)로, 이 세그먼트가 세그먼트의 마지막 데이터 옥텟으로 논리 문자로 끝나는 것을 나타냅니다. 이 문자 끝으로 인해 전체 버퍼보다 ​​작은 버퍼가 사용자에게 해제되고 연결 버퍼 크기가 1옥텟이 아닌 경우 수신 시퀀스 번호에 대한 문자 끝/버퍼 크기 조정이 이루어져야 합니다.

FIN 하나의 시퀀스 번호를 차지하는 제어 비트\(finis\). 이는 송신자가 더 이상 데이터를 보내지 않거나 차지하는 시퀀스 공간을 제어할 것임을 나타냅니다.

프래그먼트 데이터의 논리적 단위 부분, 특히 인터넷 프래그먼트는 인터넷 데이터그램의 일부입니다.

FTP 파일 전송 프로토콜입니다.

헤더 메시지, 세그먼트, 조각, 패킷 또는 데이터 블록의 시작 부분에 있는 제어 정보입니다.

호스트 컴퓨터. 특히 통신 네트워크의 관점에서 메시지의 소스 또는 대상입니다.

식별 인터넷 프로토콜 필드입니다. 발신자가 할당한 이 식별 값은 데이터그램 조각을 조립하는 데 도움이 됩니다.

IMP ARPANET의 패킷 스위치인 Interface Message Processor.

인터넷 주소 호스트 수준에 특정한 소스 또는 대상 주소입니다.

인터넷 데이터그램 인터넷 헤더와 함께 인터넷 모듈과 상위 프로토콜 사이에서 교환되는 데이터 단위.

인터넷 조각 인터넷 헤더가 있는 인터넷 데이터그램의 데이터 부분입니다.

```text
IP
          Internet Protocol.
```

IRS 초기 수신 시퀀스 번호입니다. 연결에서 발신자가 사용하는 첫 번째 시퀀스 번호입니다.

ISN 초기 시퀀스 번호입니다. 연결에 사용된 첫 번째 시퀀스 번호\(ISS 또는 IRS\). 시계 기반 절차에서 선택되었습니다.

ISS 초기 전송 시퀀스 번호입니다. 연결에서 발신자가 사용하는 첫 번째 시퀀스 번호입니다.

리더 메시지 또는 데이터 블록의 시작 부분에 있는 제어 정보입니다. 특히, ARPANET에서 호스트-IMP 인터페이스에서 ARPANET 메시지에 대한 제어 정보.

왼쪽 시퀀스 이것은 데이터 수신 TCP\(또는 현재 승인되지 않은 가장 낮은 시퀀스 번호\)에 의해 승인될 다음 시퀀스 번호이며 때때로 전송 창의 왼쪽 가장자리라고 합니다.

문자 데이터의 논리적 단위, 특히 TCP를 통해 프로세스 간에 전송되는 데이터의 논리적 단위입니다.

로컬 패킷 로컬 네트워크 내의 전송 단위.

모듈 일반적으로 소프트웨어에서 프로토콜 또는 기타 절차를 구현합니다.

MSL 최대 세그먼트 수명, TCP 세그먼트가 인터네트워크 시스템에 존재할 수 있는 시간. 임의로 2분으로 정의됩니다.

옥텟 8비트 바이트.

옵션 옵션 필드에는 여러 옵션이 포함될 수 있으며 각 옵션의 길이는 여러 옥텟일 수 있습니다. 옵션은 주로 테스트 상황에서 사용됩니다. 예를 들어 타임스탬프를 전달합니다. 인터넷 프로토콜과 TCP 모두 옵션 필드를 제공합니다.

패킷 헤더가 있을 수도 있고 아닐 수도 있는 데이터 패키지

- 논리적으로 완전하다. 데이터의 논리적 패키징보다 물리적 패키징인 경우가 더 많습니다.

포트 데이터와 관련된 프로세스의 논리적 입력 또는 출력 채널을 지정하는 소켓 부분입니다.

프로세스 실행 중인 프로그램. TCP 또는 기타 호스트 간 프로토콜의 관점에서 본 데이터의 소스 또는 대상입니다.

PSN A 패킷 교환 네트워크. 예를 들어 ARPANET.

RCV.BS 수신 버퍼 크기, 원격 버퍼 크기

```text
RCV.LBB
          receive last buffer beginning

RCV.NXT
          receive next sequence number

RCV.UP
          receive urgent pointer

RCV.WND
          receive window
```

receive 마지막 버퍼 시작 이것은 가장 최근 버퍼의 첫 번째 옥텟의 시퀀스 번호입니다. 이 값은 세그먼트에 문자 끝 표시가 포함된 경우 다음 시퀀스 번호를 계산하는 데 사용됩니다.

다음 시퀀스 번호 수신 이것은 로컬 TCP가 받을 것으로 예상하는 다음 시퀀스 번호입니다.

수신 창 이것은 로컬\(수신\) TCP가 수신하려는 시퀀스 번호를 나타냅니다. 따라서 로컬 TCP는 범위 RCV.NXT에서 RCV.NXT + RCV.WND - 1까지 겹치는 세그먼트가 허용 가능한 데이터 또는 제어를 전달하는 것으로 간주합니다. 이 범위를 완전히 벗어난 시퀀스 번호를 포함하는 세그먼트는 중복으로 간주되어 폐기됩니다.

RST 시퀀스 공간을 차지하지 않는 제어 비트\(재설정\)로, 수신기가 추가 상호 작용 없이 연결을 삭제해야 함을 나타냅니다. 수신기는 들어오는 세그먼트의 시퀀스 번호와 승인 필드를 기반으로 재설정 명령을 존중할지 무시할지 여부를 결정할 수 있습니다. 어떤 경우에도 RST가 포함된 세그먼트를 수신하면 응답으로 RST가 발생하지 않습니다.

RTP 실시간 프로토콜: 시간이 중요한 정보의 통신을 위한 호스트 간 프로토콜입니다.

고무 EOL 버퍼 경계에서 다음 문자의 시작 부분을 정렬하기 위해 시퀀스 번호 조정이 필요한 문자 끝\(EOL\)입니다.

```text
SEG.ACK
          segment acknowledgment

SEG.LEN
          segment length

SEG.PRC
          segment precedence value

SEG.SEQ
          segment sequence

SEG.UP
          segment urgent pointer field

SEG.WND
          segment window field
```

세그먼트 데이터의 논리적 단위, 특히 TCP 세그먼트는 한 쌍의 TCP 모듈 간에 전송되는 데이터 단위입니다.

세그먼트 승인 도착 세그먼트의 승인 필드에 있는 시퀀스 번호입니다.

세그먼트 길이 시퀀스 공간을 차지하는 컨트롤을 포함하여 세그먼트가 차지하는 시퀀스 번호 공간의 양입니다.

세그먼트 시퀀스 도착 세그먼트의 시퀀스 필드에 있는 번호.

마지막 버퍼 시작 보내기 이것은 가장 최근 버퍼의 첫 번째 옥텟의 시퀀스 번호입니다. 이 값은 세그먼트에 문자 끝 표시가 포함된 경우 다음 시퀀스 번호를 계산하는 데 사용됩니다.

send sequence 로컬\(보내는\) TCP가 연결에 사용할 다음 시퀀스 번호입니다. 처음에는 ISN\(Initial Sequence Number Curve\)에서 선택되며 데이터의 각 옥텟 또는 전송된 시퀀스 컨트롤에 대해 증가합니다.

send window 원격\(수신\) TCP가 수신하려는 시퀀스 번호를 나타냅니다. 원격\(데이터 수신\) TCP의 세그먼트에 지정된 창 필드의 값입니다. TCP가 내보낼 수 있는 시퀀스 번호의 범위는 SND.NXT와 SND.UNA + SND.WND - 1 사이입니다.

SND.BS 송신 버퍼 크기, 로컬 버퍼 크기

```text
SND.LBB
          send last buffer beginning

SND.NXT
          send sequence

SND.UNA
          left sequence

SND.UP
          send urgent pointer
```

SND.WL은 마지막 창 업데이트 시 시퀀스 번호를 보냅니다.

```text
SND.WND
          send window
```

소켓 특히 포트 식별자를 포함하는 주소, 즉 인터넷 주소와 TCP 포트의 연결입니다.

소스 주소 일반적으로 네트워크 및 호스트 식별자인 소스 주소입니다.

SYN 시퀀스 번호가 시작되는 위치를 나타내기 위해 연결 시작 시 사용되는 하나의 시퀀스 번호를 차지하는 수신 세그먼트의 제어 비트.

TCB 연결 상태를 기록하는 데이터 구조인 전송 제어 블록.

TCB.PRC 연결의 우선 순위.

TCP 전송 제어 프로토콜: 인터네트워크 환경에서 안정적인 통신을 위한 호스트 간 프로토콜입니다.

TOS 서비스 유형, 인터넷 프로토콜 필드.

서비스 유형 이 인터넷 조각에 대한 서비스 유형을 나타내는 인터넷 프로토콜 필드입니다.

URG 긴급 포인터에 표시된 값보다 작은 시퀀스 번호로 소비할 데이터가 있는 한 수신 사용자에게 긴급 처리를 수행하도록 통지해야 함을 나타내는 데 사용되는 시퀀스 공간을 차지하지 않는 제어 비트\(긴급\).

긴급 포인터 URG 비트가 켜져 있을 때만 의미가 있는 제어 필드. 이 필드는 발신 사용자의 긴급 호출과 관련된 데이터 옥텟을 나타내는 긴급 포인터의 값을 전달합니다.

```text
          

                               REFERENCES
```

\[1\] Cerf, V. 및 R. Kahn, "패킷 네트워크 상호 통신을 위한 프로토콜", IEEE Transactions on Communications, Vol. COM-22, No. 5, pp 637-648, 1974년 5월.

```text
[2]  Postel, J. (ed.), "DOD Standard Internet Protocol," Defense
     Advanced Research Projects Agency, Information Processing
     Techniques Office, RFC 760, IEN 128, January 1980.
```

\[3\] Feinler, E. 및 J. Postel, ARPANET 프로토콜 핸드북, 네트워크 정보 센터, SRI International, Menlo Park, CA, 1978년 1월.

\[4\] Dalal, Y. 및 C. Sunshine, "전송 프로토콜의 연결 관리", 컴퓨터 네트워크, Vol. 2, No. 6, pp. 454-473, 1978년 12월.
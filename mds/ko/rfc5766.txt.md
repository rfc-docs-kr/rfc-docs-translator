

```text
Internet Engineering Task Force (IETF)                           R. Mahy
Request for Comments: 5766                                  Unaffiliated
Category: Standards Track                                    P. Matthews
ISSN: 2070-1721                                           Alcatel-Lucent
                                                            J. Rosenberg
                                                             jdrosen.net
                                                              April 2010

               Traversal Using Relays around NAT (TURN):
     Relay Extensions to Session Traversal Utilities for NAT (STUN)
```

---
# **Abstract**

호스트가 NAT 뒤에 있는 경우 특정 상황에서는 해당 호스트가 다른 호스트\(피어\)와 직접 통신하는 것이 불가능할 수 있습니다. 이러한 상황에서는 호스트가 통신 중계 역할을 하는 중간 노드의 서비스를 이용하는 것이 필요합니다. 이 사양은 호스트가 릴레이의 작동을 제어하고 릴레이를 사용하여 피어와 패킷을 교환할 수 있도록 하는 TURN\(Traversal Using Relays around NAT\)이라는 프로토콜을 정의합니다. TURN은 클라이언트가 단일 릴레이 주소를 사용하여 여러 피어와 통신할 수 있다는 점에서 다른 릴레이 제어 프로토콜과 다릅니다.

TURN 프로토콜은 NAT 통과에 대한 ICE\(대화형 연결 설정\) 접근 방식의 일부로 사용되도록 설계되었지만 ICE 없이도 사용할 수 있습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc5766에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2010 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  Overview of Operation  . . . . . . . . . . . . . . . . . . . .  5
     2.1.  Transports . . . . . . . . . . . . . . . . . . . . . . . .  8
     2.2.  Allocations  . . . . . . . . . . . . . . . . . . . . . . .  9
     2.3.  Permissions  . . . . . . . . . . . . . . . . . . . . . . . 11
     2.4.  Send Mechanism . . . . . . . . . . . . . . . . . . . . . . 12
     2.5.  Channels . . . . . . . . . . . . . . . . . . . . . . . . . 13
     2.6.  Unprivileged TURN Servers  . . . . . . . . . . . . . . . . 15
     2.7.  Avoiding IP Fragmentation  . . . . . . . . . . . . . . . . 16
     2.8.  RTP Support  . . . . . . . . . . . . . . . . . . . . . . . 17
     2.9.  Anycast Discovery of Servers . . . . . . . . . . . . . . . 17
   3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . 18
   4.  General Behavior . . . . . . . . . . . . . . . . . . . . . . . 19
   5.  Allocations  . . . . . . . . . . . . . . . . . . . . . . . . . 22
   6.  Creating an Allocation . . . . . . . . . . . . . . . . . . . . 23
     6.1.  Sending an Allocate Request  . . . . . . . . . . . . . . . 23
     6.2.  Receiving an Allocate Request  . . . . . . . . . . . . . . 24
     6.3.  Receiving an Allocate Success Response . . . . . . . . . . 28
     6.4.  Receiving an Allocate Error Response . . . . . . . . . . . 29
   7.  Refreshing an Allocation . . . . . . . . . . . . . . . . . . . 31
     7.1.  Sending a Refresh Request  . . . . . . . . . . . . . . . . 31
     7.2.  Receiving a Refresh Request  . . . . . . . . . . . . . . . 31
     7.3.  Receiving a Refresh Response . . . . . . . . . . . . . . . 32
   8.  Permissions  . . . . . . . . . . . . . . . . . . . . . . . . . 32
   9.  CreatePermission . . . . . . . . . . . . . . . . . . . . . . . 34
     9.1.  Forming a CreatePermission Request . . . . . . . . . . . . 34
     9.2.  Receiving a CreatePermission Request . . . . . . . . . . . 34
     9.3.  Receiving a CreatePermission Response  . . . . . . . . . . 35
   10. Send and Data Methods  . . . . . . . . . . . . . . . . . . . . 35
     10.1. Forming a Send Indication  . . . . . . . . . . . . . . . . 35
     10.2. Receiving a Send Indication  . . . . . . . . . . . . . . . 35
     10.3. Receiving a UDP Datagram . . . . . . . . . . . . . . . . . 36
     10.4. Receiving a Data Indication  . . . . . . . . . . . . . . . 37
   11. Channels . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
     11.1. Sending a ChannelBind Request  . . . . . . . . . . . . . . 39
     11.2. Receiving a ChannelBind Request  . . . . . . . . . . . . . 39
     11.3. Receiving a ChannelBind Response . . . . . . . . . . . . . 40
     11.4. The ChannelData Message  . . . . . . . . . . . . . . . . . 41
     11.5. Sending a ChannelData Message  . . . . . . . . . . . . . . 41
     11.6. Receiving a ChannelData Message  . . . . . . . . . . . . . 42
     11.7. Relaying Data from the Peer  . . . . . . . . . . . . . . . 43
   12. IP Header Fields . . . . . . . . . . . . . . . . . . . . . . . 43
   13. New STUN Methods . . . . . . . . . . . . . . . . . . . . . . . 45
   14. New STUN Attributes  . . . . . . . . . . . . . . . . . . . . . 45
     14.1. CHANNEL-NUMBER . . . . . . . . . . . . . . . . . . . . . . 45
     14.2. LIFETIME . . . . . . . . . . . . . . . . . . . . . . . . . 46
     14.3. XOR-PEER-ADDRESS . . . . . . . . . . . . . . . . . . . . . 46
     14.4. DATA . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
     14.5. XOR-RELAYED-ADDRESS  . . . . . . . . . . . . . . . . . . . 46
     14.6. EVEN-PORT  . . . . . . . . . . . . . . . . . . . . . . . . 46
     14.7. REQUESTED-TRANSPORT  . . . . . . . . . . . . . . . . . . . 47
     14.8. DONT-FRAGMENT  . . . . . . . . . . . . . . . . . . . . . . 47
     14.9. RESERVATION-TOKEN  . . . . . . . . . . . . . . . . . . . . 48
   15. New STUN Error Response Codes  . . . . . . . . . . . . . . . . 48
   16. Detailed Example . . . . . . . . . . . . . . . . . . . . . . . 48
   17. Security Considerations  . . . . . . . . . . . . . . . . . . . 55
     17.1. Outsider Attacks . . . . . . . . . . . . . . . . . . . . . 55
       17.1.1.  Obtaining Unauthorized Allocations  . . . . . . . . . 55
       17.1.2.  Offline Dictionary Attacks  . . . . . . . . . . . . . 56
       17.1.3.  Faked Refreshes and Permissions . . . . . . . . . . . 56
       17.1.4.  Fake Data . . . . . . . . . . . . . . . . . . . . . . 56
       17.1.5.  Impersonating a Server  . . . . . . . . . . . . . . . 57
       17.1.6.  Eavesdropping Traffic . . . . . . . . . . . . . . . . 58
       17.1.7.  TURN Loop Attack  . . . . . . . . . . . . . . . . . . 58
     17.2. Firewall Considerations  . . . . . . . . . . . . . . . . . 59
       17.2.1.  Faked Permissions . . . . . . . . . . . . . . . . . . 59
       17.2.2.  Blacklisted IP Addresses  . . . . . . . . . . . . . . 60
       17.2.3.  Running Servers on Well-Known Ports . . . . . . . . . 60
     17.3. Insider Attacks  . . . . . . . . . . . . . . . . . . . . . 60
       17.3.1.  DoS against TURN Server . . . . . . . . . . . . . . . 60
       17.3.2.  Anonymous Relaying of Malicious Traffic . . . . . . . 61
       17.3.3.  Manipulating Other Allocations  . . . . . . . . . . . 61
     17.4. Other Considerations . . . . . . . . . . . . . . . . . . . 61
   18. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 61
   19. IAB Considerations . . . . . . . . . . . . . . . . . . . . . . 62
   20. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 63
   21. References . . . . . . . . . . . . . . . . . . . . . . . . . . 64
     21.1. Normative References . . . . . . . . . . . . . . . . . . . 64
     21.2. Informative References . . . . . . . . . . . . . . . . . . 64
```

---
## **1.  Introduction**

NAT 뒤에 있는 호스트는 다른 호스트와 패킷을 교환하기를 원할 수 있으며, 그 중 일부는 NAT 뒤에 있을 수도 있습니다. 이를 위해 관련 호스트는 직접 통신 경로를 발견하기 위해 "홀 펀칭" 기술\(\[RFC5128\] 참조\)을 사용할 수 있습니다. 즉, 중재 NAT 및 라우터를 통해 한 호스트에서 다른 호스트로 이동하지만 릴레이를 통과하지 않는 통신 경로입니다.

\[RFC5128\] 및 \[RFC4787\]에 설명된 대로 홀 펀칭 기술은 두 호스트가 제대로 작동하지 않는 NAT 뒤에 있으면 실패합니다. 예를 들어 두 호스트가 모두 "주소 종속 매핑" 또는 "주소 및 포트 종속 매핑" 매핑 동작을 갖는 NAT 뒤에 있는 경우 홀 펀칭 기술은 일반적으로 실패합니다.

직접 통신 경로를 찾을 수 없는 경우 패킷에 대한 중계 역할을 하는 중간 호스트의 서비스를 사용해야 합니다. 이 릴레이는 일반적으로 공용 인터넷에 위치하며 NAT 뒤에 있는 두 호스트 사이에 패킷을 릴레이합니다.

이 사양은 NAT 뒤에 있는 호스트\(TURN 클라이언트라고 함\)가 다른 호스트\(TURN 서버라고 함\)가 릴레이 역할을 하도록 요청할 수 있도록 하는 TURN이라는 프로토콜을 정의합니다. 클라이언트는 서버가 특정 다른 호스트\(피어라고 함\) 간에 패킷을 중계하도록 준비할 수 있으며 중계가 수행되는 방식을 제어할 수 있습니다. 클라이언트는 릴레이된 전송 주소라고 하는 서버의 IP 주소와 포트를 획득하여 이를 수행합니다. 피어가 릴레이된 전송 주소로 패킷을 보내면 서버는 해당 패킷을 클라이언트에 릴레이합니다. 클라이언트가 서버에 데이터 패킷을 보내면 서버는 중계된 전송 주소를 소스로 사용하여 이를 적절한 피어에 중계합니다.

TURN을 사용하는 클라이언트는 릴레이된 전송 주소를 피어에게 전달하고 각 피어의 IP 주소와 포트\(보다 정확하게는 각 피어의 서버 반사 전송 주소, 섹션 2 참조\)를 알아낼 수 있는 방법이 있어야 합니다. 이것이 수행되는 방법은 TURN 프로토콜의 범위를 벗어납니다. 이를 수행할 수 있는 한 가지 방법은 클라이언트와 동료가 이메일 메시지를 교환하는 것입니다. 또 다른 방법은 클라이언트와 해당 동료가 특수 목적의 "소개" 또는 "랑데부" 프로토콜을 사용하는 것입니다\(자세한 내용은 \[RFC5128\] 참조\).

TURN이 ICE \[RFC5245\]와 함께 사용되면 릴레이된 전송 주소와 피어의 IP 주소 및 포트가 랑데뷰 프로토콜이 전달해야 하는 ICE 후보 정보에 포함됩니다. 예를 들어, TURN 및 ICE가 SIP\[RFC3261\]를 사용하는 멀티미디어 솔루션의 일부로 사용되는 경우 SIP는 SIP 메시지 본문 내부에 ICE 후보 정보를 전달하는 랑데부 프로토콜의 역할을 수행합니다. TURN과 ICE가 다른 것과 함께 사용되는 경우

랑데부 프로토콜인 경우 \[MMUSIC-ICE-NONSIP\]은 랑데부 프로토콜이 수행해야 하는 서비스에 대한 지침을 제공합니다.

NAT 뒤에 있는 두 호스트 간의 통신을 활성화하기 위해 TURN 서버를 사용하는 것이 성공할 가능성이 매우 높지만 서버에는 일반적으로 인터넷에 대한 고대역폭 연결이 필요하므로 TURN 서버 제공자에게는 비용이 많이 듭니다. 따라서 직접 통신 경로를 찾을 수 없는 경우에만 TURN 서버를 사용하는 것이 가장 좋습니다. 클라이언트와 피어가 통신 경로를 결정하기 위해 ICE를 사용할 때 ICE는 홀 펀칭 기술을 사용하여 직접 경로를 먼저 검색하고 직접 경로를 찾을 수 없는 경우에만 TURN 서버를 사용합니다.

TURN은 원래 SIP를 사용하여 신호를 받은 멀티미디어 세션을 지원하기 위해 개발되었습니다. SIP는 분기를 지원하므로 TURN은 릴레이된 전송 주소당 여러 피어를 지원합니다. 다른 접근 방식\(예: SOCKS \[RFC1928\]\)에서는 지원되지 않는 기능입니다. 그러나 TURN이 다른 유형의 애플리케이션에 적합한지 확인하기 위해 주의를 기울였습니다.

TURN은 NAT 통과에 대한 더 큰 ICE 접근 방식의 한 부분으로 설계되었습니다. TURN 구현자는 ICE를 조사하고 이를 애플리케이션에 사용하는 것을 진지하게 고려할 것을 촉구합니다. 그러나 ICE 없이도 TURN을 사용할 수 있습니다.

TURN은 STUN\(Session Traversal Utilities for NAT\) 프로토콜 \[RFC5389\]의 확장입니다. 전부는 아니지만 대부분의 TURN 메시지는 STUN 형식의 메시지입니다. 이 문서를 읽는 독자는 STUN에 대해 잘 알고 있어야 합니다.

---
## **2.  Overview of Operation**

이 섹션에서는 TURN 작동에 대한 개요를 제공합니다. 이는 비표준적입니다.

일반적인 구성에서 TURN 클라이언트는 개인 네트워크 \[RFC1918\]에 연결되고 하나 이상의 NAT를 통해 공용 인터넷에 연결됩니다. 공용 인터넷에는 TURN 서버가 있습니다. 인터넷의 다른 곳에는 TURN 클라이언트가 통신하려는 하나 이상의 피어가 있습니다. 이러한 피어는 하나 이상의 NAT 뒤에 있을 수도 있고 그렇지 않을 수도 있습니다. 클라이언트는 서버를 중계기로 사용하여 이러한 피어에게 패킷을 보내고 이러한 피어로부터 패킷을 받습니다.

```text
                                        Peer A
                                        Server-Reflexive    +---------+
                                        Transport Address   |         |
                                        192.0.2.150:32102   |         |
                                            |              /|         |
                          TURN              |            / ^|  Peer A |
    Client's              Server            |           /  ||         |
    Host Transport        Transport         |         //   ||         |
    Address               Address           |       //     |+---------+
   10.1.1.2:49721       192.0.2.15:3478     |+-+  //     Peer A
            |               |               ||N| /       Host Transport
            |   +-+         |               ||A|/        Address
            |   | |         |               v|T|     192.168.100.2:49582
            |   | |         |               /+-+
 +---------+|   | |         |+---------+   /              +---------+
 |         ||   |N|         ||         | //               |         |
 | TURN    |v   | |         v| TURN    |/                 |         |
 | Client  |----|A|----------| Server  |------------------|  Peer B |
 |         |    | |^         |         |^                ^|         |
 |         |    |T||         |         ||                ||         |
 +---------+    | ||         +---------+|                |+---------+
                | ||                    |                |
                | ||                    |                |
                +-+|                    |                |
                   |                    |                |
                   |                    |                |
             Client's                   |            Peer B
             Server-Reflexive    Relayed             Transport
             Transport Address   Transport Address   Address
             192.0.2.1:7000      192.0.2.15:50000     192.0.2.210:49191

                                 Figure 1
```

그림 1은 일반적인 배포를 보여줍니다. 이 그림에서 TURN 클라이언트와 TURN 서버는 NAT로 분리되어 있으며, 클라이언트는 NAT의 개인 측에 있고 서버는 공용 측에 있습니다. 이 NAT는 "잘못된" NAT로 간주됩니다. 예를 들어 "주소 및 포트 종속 매핑"이라는 매핑 속성이 있을 수 있습니다\(\[RFC4787\] 참조\).

클라이언트는 클라이언트의 HOST TRANSPORT ADDRESS라고 하는 \(IP 주소, 포트\) 조합에서 서버와 통신합니다. \(IP 주소와 포트의 조합을 전송 주소라고 합니다.\)

클라이언트는 호스트 전송 주소에서 TURN 서버 전송 주소로 알려진 TURN 서버의 전송 주소로 TURN 메시지를 보냅니다. 클라이언트는 지정되지 않은 일부 수단\(예: 구성\)을 통해 TURN 서버 전송 주소를 학습하며 이 주소는 일반적으로 많은 클라이언트에서 동시에 사용됩니다.

클라이언트가 NAT 뒤에 있기 때문에 서버는 클라이언트의 패킷이 NAT 자체의 전송 주소에서 오는 것으로 간주합니다. 이 주소는 클라이언트의 SERVER-REFLEXIVE 전송 주소로 알려져 있습니다. 서버가 클라이언트의 서버 반사 전송 주소로 보낸 패킷은 NAT에 의해 클라이언트의 호스트 전송 주소로 전달됩니다.

클라이언트는 TURN 명령을 사용하여 서버에서 ALLOCATION을 생성하고 조작합니다. 할당은 서버의 데이터 구조입니다. 이 데이터 구조에는 무엇보다도 할당에 대한 RELAYED TRANSPORT ADDRESS가 포함됩니다. 릴레이된 전송 주소는 피어가 서버가 클라이언트에 데이터를 릴레이하도록 하는 데 사용할 수 있는 서버의 전송 주소입니다. 할당은 릴레이된 전송 주소로 고유하게 식별됩니다.

할당이 생성되면 클라이언트는 데이터를 보낼 피어에 대한 표시와 함께 애플리케이션 데이터를 서버에 보낼 수 있으며, 서버는 이 데이터를 적절한 피어에 중계합니다. 클라이언트는 TURN 메시지 내에서 애플리케이션 데이터를 서버로 보냅니다. 서버에서는 TURN 메시지에서 데이터가 추출되어 UDP 데이터그램으로 피어에 전송됩니다. 반대 방향으로, 피어는 UDP 데이터그램의 응용 프로그램 데이터를 할당을 위해 중계된 전송 주소로 보낼 수 있습니다. 그런 다음 서버는 이 데이터를 TURN 메시지 내에 캡슐화하고 어느 피어가 데이터를 보냈는지 표시와 함께 클라이언트에 보냅니다. TURN 메시지에는 클라이언트가 어느 피어와 통신하고 있는지에 대한 표시가 항상 포함되어 있으므로 클라이언트는 단일 할당을 사용하여 여러 피어와 통신할 수 있습니다.

피어가 NAT 뒤에 있으면 클라이언트는 호스트 전송 주소가 아닌 서버 반사 전송 주소를 사용하여 피어를 식별해야 합니다. 예를 들어 위의 예에서 애플리케이션 데이터를 피어 A로 보내려면 클라이언트는 192.168.100.2:49582\(피어 A의 호스트 전송 주소\)가 아닌 192.0.2.150:32102\(피어 A의 서버 반사 전송 주소\)를 지정해야 합니다.

서버의 각 할당은 단일 클라이언트에 속하며 해당 할당에서만 사용되는 정확히 하나의 중계 전송 주소를 갖습니다. 따라서 패킷이 서버의 중계된 전송 주소에 도착하면 서버는 데이터가 어느 클라이언트를 대상으로 하는지 알 수 있습니다.

클라이언트는 동시에 서버에서 여러 할당을 가질 수 있습니다.

---
### **2.1.  Transports**

이 사양에 정의된 TURN은 항상 서버와 피어 간에 UDP를 사용합니다. 그러나 이 사양에서는 UDP, TCP 또는 TCP를 통한 TLS\(전송 계층 보안\) 중 하나를 사용하여 클라이언트와 서버 간에 TURN 메시지를 전달할 수 있습니다.

```text
           +----------------------------+---------------------+
           | TURN client to TURN server | TURN server to peer |
           +----------------------------+---------------------+
           |             UDP            |         UDP         |
           |             TCP            |         UDP         |
           |        TLS over TCP        |         UDP         |
           +----------------------------+---------------------+
```

클라이언트와 서버 사이에 TCP 또는 TLS-over-TCP가 사용되는 경우 서버는 피어와 데이터를 중계할 때 이러한 전송과 UDP 전송 간에 변환합니다.

이 버전의 TURN은 서버와 피어 간의 UDP만 지원하므로 대부분의 클라이언트는 클라이언트와 서버 간의 UDP 사용을 선호할 것으로 예상됩니다. 그렇다면 일부 독자들은 왜 TCP와 TLS-over-TCP도 지원하는지 궁금할 것입니다.

일부 방화벽은 UDP를 완전히 차단하도록 구성되어 있으므로 TURN은 클라이언트와 서버 간의 TCP 전송을 지원합니다. 이러한 방화벽은 UDP는 차단하지만 TCP는 차단하지 않습니다. 그 이유 중 하나는 TCP가 방화벽에 의해 보호되는 노드의 의도를 방화벽에 더욱 분명하게 만드는 속성을 갖고 있기 때문입니다. 예를 들어, TCP에는 보호된 노드가 실제로 특정 연결을 설정하기를 원한다는 점을 더욱 명확하게 하는 3방향 핸드셰이크가 있는 반면, UDP의 경우 방화벽이 할 수 있는 최선의 방법은 필터링 규칙을 사용하여 원하는 흐름을 추측하는 것입니다. 또한 TCP에는 명시적인 연결 해제 기능이 있습니다. UDP의 경우 방화벽은 타이머를 사용하여 흐름이 끝나는 시점을 추측해야 합니다.

TURN은 클라이언트와 서버 간의 TLS-over-TCP 전송을 지원합니다. 왜냐하면 TLS는 TURN의 기본 다이제스트 인증에서 제공되지 않는 추가 보안 속성을 제공하기 때문입니다. 일부 고객이 활용하고 싶어할 수 있는 속성입니다. 특히 TLS는 클라이언트가 올바른 서버와 통신하고 있는지 확인하는 방법을 제공하고 TURN 제어 메시지의 기밀성을 제공합니다. TLS 사용에 따른 오버헤드가 다이제스트 인증보다 높기 때문에 TURN에는 TLS가 필요하지 않습니다. 예를 들어, TLS를 사용한다는 것은 대부분의 애플리케이션 데이터가 이중으로 암호화된다는 것을 의미할 수 있습니다\(한 번은 TLS로 암호화되고 한 번은 UDP 데이터그램에서 계속 암호화됩니다\).

서버와 피어 사이에 TCP에 대한 지원을 추가하기 위해 TURN에 대한 확장 계획이 있습니다\[TURN-TCP\]. 이러한 이유로 서버와 피어 간에 UDP를 사용하는 할당을 UDP 할당이라고 하고, 서버와 피어 간에 TCP를 사용하는 할당을 TCP 할당이라고 합니다. 이 사양에서는 UDP 할당만 설명합니다.

본 사양에 정의된 TURN은 IPv4만 지원합니다. 이 사양의 모든 IP 주소는 IPv4 주소여야 합니다. IPv6에 대한 지원과 IPv4와 IPv6 간의 중계를 위한 지원을 추가하기 위해 TURN에 대한 확장이 계획되어 있습니다\[TURN-IPv6\].

TURN에 대한 일부 애플리케이션에서 클라이언트는 서버와 통신하는 데 사용하는 호스트 전송 주소에서 TURN 패킷 이외의 패킷을 보내고 받을 수 있습니다. 예를 들어 ICE와 함께 TURN을 사용할 때 이런 일이 발생할 수 있습니다. 이러한 경우 클라이언트는 도착하는 패킷의 소스 주소를 검사하여 TURN 패킷을 다른 패킷과 구별할 수 있습니다. TURN 서버에서 도착하는 패킷은 TURN 패킷이 됩니다.

---
### **2.2.  Allocations**

서버에 할당을 생성하기 위해 클라이언트는 Allocate 트랜잭션을 사용합니다. 클라이언트는 서버에 할당 요청을 보내고, 서버는 할당된 중계 전송 주소가 포함된 할당 성공 응답으로 응답합니다. 클라이언트는 원하는 할당 유형\(예: 할당 수명\)을 설명하는 속성을 Allocate 요청에 포함할 수 있습니다. 데이터 중계에는 보안 관련 사항이 있으므로 서버는 일반적으로 STUN의 장기 자격 증명 메커니즘을 사용하여 클라이언트가 자신을 인증하여 서버를 사용할 권한이 있음을 나타내도록 요구합니다.

릴레이된 전송 주소가 할당되면 클라이언트는 할당을 활성 상태로 유지해야 합니다. 이를 위해 클라이언트는 주기적으로 서버에 새로 고침 요청을 보냅니다. TURN은 어떤 이유로 할당이 사라지는 경우 클라이언트에 알릴 수 있도록 새로 고침에 대해 의도적으로 다른 방법\(할당 대신 새로 고침\)을 사용합니다.

새로 고침 트랜잭션의 빈도는 할당 수명에 따라 결정됩니다. 할당의 기본 수명은 10분입니다. 이 값은 새로 고침이 일반적으로 클라이언트에 부담이 되지 않도록 충분히 길게 선택되었으며 클라이언트가 예기치 않게 적시에 종료된 할당은 만료됩니다. 그러나 클라이언트는 할당 요청에서 더 긴 수명을 요청할 수 있고 새로 고침 요청에서 해당 요청을 수정할 수 있으며, 서버는 항상 응답에 실제 수명을 표시합니다. 클라이언트는 "수명"초 내에 새로운 새로 고침 트랜잭션을 발행해야 합니다.

이전 할당 또는 새로 고침 트랜잭션. 클라이언트가 더 이상 할당을 사용하지 않으려면 요청 수명이 0인 새로 고침 요청을 사용하여 할당을 삭제해야 합니다.

서버와 클라이언트 모두 5-TUPLE이라는 값을 추적합니다. 클라이언트에서 5-튜플은 클라이언트의 호스트 전송 주소, 서버 전송 주소 및 클라이언트가 서버와 통신하는 데 사용하는 전송 프로토콜로 구성됩니다. 서버에서 5-튜플 값은 클라이언트의 호스트 전송 주소가 클라이언트의 서버 재귀 주소로 대체된다는 점을 제외하면 동일합니다. 왜냐하면 이것이 서버에 표시되는 클라이언트의 주소이기 때문입니다.

클라이언트와 서버 모두 할당 요청에 사용된 5-튜플을 기억합니다. 클라이언트와 서버 간의 후속 메시지는 동일한 5-튜플을 사용합니다. 이러한 방식으로 클라이언트와 서버는 어떤 할당이 참조되고 있는지 알 수 있습니다. 클라이언트가 두 번째 릴레이 전송 주소를 할당하려는 경우 다른 5-튜플\(예: 다른 클라이언트 호스트 주소 또는 포트 사용\)을 사용하여 두 번째 할당을 생성해야 합니다.

- 참고: 이 문서에서 사용된 용어는 5-튜플을 나타내지만 TURN 서버는 동일한 결과를 생성하는 원하는 식별자를 저장할 수 있습니다. 특히 구현에서는 5-튜플 대신 파일 설명자를 사용하여 TCP 연결을 나타낼 수 있습니다.

```text
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |-- Allocate request --------------->|             |             |
    |                                    |             |             |
    |<--------------- Allocate failure --|             |             |
    |                 (401 Unauthorized) |             |             |
    |                                    |             |             |
    |-- Allocate request --------------->|             |             |
    |                                    |             |             |
    |<---------- Allocate success resp --|             |             |
    |            (192.0.2.15:50000)      |             |             |
    //                                   //            //            //
    |                                    |             |             |
    |-- Refresh request ---------------->|             |             |
    |                                    |             |             |
    |<----------- Refresh success resp --|             |             |
    |                                    |             |             |

                                 Figure 2
```

그림 2에서 클라이언트는 자격 증명 없이 서버에 할당 요청을 보냅니다. 서버에서는 STUN의 장기 자격 증명 메커니즘을 사용하여 모든 요청을 인증해야 하므로 서버는 401\(인증되지 않음\) 오류 코드와 함께 요청을 거부합니다. 그런 다음 클라이언트는 이번에는 자격 증명\(표시되지 않음\)을 포함하여 다시 시도합니다. 이번에는 서버가 할당 요청을 수락하고 할당에 할당된 중계 전송 주소가 포함된 할당 성공 응답을 반환합니다. 얼마 후 클라이언트는 할당을 새로 고치기로 결정하고 서버에 새로 고침 요청을 보냅니다. 새로 고침이 수락되고 서버는 새로 고침 성공 응답으로 응답합니다.

---
### **2.3.  Permissions**

TURN을 사용하여 회사 방화벽 보안을 우회할 수 있다는 기업 IT 관리자의 우려를 완화하기 위해 TURN에는 권한 개념이 포함되어 있습니다. TURN 권한은 \[RFC4787\]을 준수하는 NAT의 주소 제한 필터링 메커니즘을 모방합니다.

할당에는 0개 이상의 권한이 있을 수 있습니다. 각 권한은 IP 주소와 수명으로 구성됩니다. 서버가 할당의 릴레이된 전송 주소에 대한 UDP 데이터그램을 받으면 먼저 권한 목록을 확인합니다. 데이터그램의 소스 IP 주소가 권한과 일치하면 애플리케이션 데이터가 클라이언트에 전달되고, 그렇지 않으면 UDP 데이터그램이 자동으로 삭제됩니다.

권한을 새로 고치지 않으면 5분 후에 권한이 만료되며 권한을 명시적으로 삭제할 수 있는 방법이 없습니다. 이 동작은 \[RFC4787\]을 준수하는 NAT의 동작과 일치하도록 선택되었습니다.

클라이언트는 CreatePermission 요청 또는 ChannelBind 요청을 사용하여 권한을 설치하거나 새로 고칠 수 있습니다. CreatePermission 요청을 사용하면 단일 요청으로 여러 권한을 설치하거나 새로 고칠 수 있습니다. 이는 ICE를 사용하는 애플리케이션에 중요합니다. 보안상의 이유로 인증할 수 있는 트랜잭션을 통해서만 권한을 설치하거나 새로 고칠 수 있습니다. 따라서 보내기 표시 및 ChannelData 메시지\(피어에게 데이터를 보내는 데 사용됨\)는 권한을 설치하거나 새로 고치지 않습니다.

권한은 할당 컨텍스트 내에 있으므로 한 할당에서 권한을 추가하거나 만료해도 다른 할당에는 영향을 미치지 않습니다.

---
### **2.4.  Send Mechanism**

클라이언트와 피어가 TURN 서버를 사용하여 애플리케이션 데이터를 교환하는 두 가지 메커니즘이 있습니다. 첫 번째 메커니즘은 Send 및 Data 메서드를 사용하고, 두 번째 방법은 채널을 사용합니다. 두 가지 방법 모두에 공통적인 점은 할당된 단일 릴레이 전송 주소를 사용하여 여러 피어와 통신할 수 있는 클라이언트의 기능입니다. 따라서 두 가지 방법 모두 클라이언트가 어느 피어가 데이터를 수신해야 하는지 서버에 표시하고, 서버는 어느 피어가 데이터를 보냈는지 클라이언트에 표시하는 수단을 포함합니다.

보내기 메커니즘은 보내기 및 데이터 표시를 사용합니다. 보내기 표시는 클라이언트에서 서버로 응용 프로그램 데이터를 보내는 데 사용되는 반면, 데이터 표시는 서버에서 클라이언트로 응용 프로그램 데이터를 보내는 데 사용됩니다.

Send 메커니즘을 사용할 때 클라이언트는 \(a\) 피어의 \(서버 반사\) 전송 주소를 지정하는 XOR-PEER-ADDRESS 속성과 \(b\) 애플리케이션 데이터를 보유하는 DATA 속성을 포함하는 Send 표시를 TURN 서버에 보냅니다. . TURN 서버가 Send 표시를 수신하면 DATA 속성에서 애플리케이션 데이터를 추출하고 할당된 릴레이 주소를 소스 주소로 사용하여 UDP 데이터그램으로 피어에 보냅니다. 송신 표시에 사용되는 5-튜플에 의해 암시되므로 중계된 전송 주소를 지정할 필요가 없습니다.

역방향으로 TURN 서버의 중계 전송 주소에 도착하는 UDP 데이터그램은 데이터 표시로 변환되어 XOR-PEER-ADDRESS 속성에 포함된 피어의 서버 반사 전송 주소와 데이터와 함께 클라이언트로 전송됩니다. DATA 속성에 자체적으로 포함됩니다. 릴레이된 전송 주소가 할당을 고유하게 식별하므로 서버는 어느 클라이언트가 데이터를 받아야 하는지 알고 있습니다.

STUN의 장기 자격 증명 메커니즘은 인증 표시를 지원하지 않기 때문에 보내기 및 데이터 표시는 인증될 수 없습니다. 클라이언트에서 서버로의 구간은 피어로 향하는 전체 경로의 절반에 불과하기 때문에 이는 처음 나타나는 것만큼 큰 문제는 아닙니다. 적절한 보안을 원하는 애플리케이션은 클라이언트와 피어 간에 전송되는 데이터를 암호화해야 합니다.

보내기 표시는 인증되지 않기 때문에 공격자가 가짜 보내기 표시를 서버에 보낼 수 있으며, 그런 다음 이를 피어에 전달합니다. 이 공격을 부분적으로 완화하기 위해 TURN에서는 클라이언트가 보내기 표시를 사용하여 데이터를 보내기 전에 피어에 대한 권한을 설치해야 합니다.

```text
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |-- CreatePermission req (Peer A) -->|             |             |
    |<-- CreatePermission success resp --|             |             |
    |                                    |             |             |
    |--- Send ind (Peer A)-------------->|             |             |
    |                                    |=== data ===>|             |
    |                                    |             |             |
    |                                    |<== data ====|             |
    |<-------------- Data ind (Peer A) --|             |             |
    |                                    |             |             |
    |                                    |             |             |
    |--- Send ind (Peer B)-------------->|             |             |
    |                                    | dropped     |             |
    |                                    |             |             |
    |                                    |<== data ==================|
    |                            dropped |             |             |
    |                                    |             |             |

                                 Figure 3
```

그림 3에서 클라이언트는 이미 할당을 생성했으며 이제 피어에게 데이터를 보내려고 합니다. 클라이언트는 먼저 XOR-PEER-ADDRESS 속성에 피어 A\(서버 반사\)의 IP 주소를 지정하는 CreatePermission 요청을 서버에 보내 권한을 생성합니다. 이것이 완료되지 않으면 서버는 클라이언트와 서버 간에 데이터를 중계하지 않습니다. 그런 다음 클라이언트는 보내기 표시를 사용하여 피어 A에 데이터를 보냅니다. 서버에서는 애플리케이션 데이터가 추출되어 UDP 데이터그램으로 피어 A에 전달되며, 중계된 전송 주소를 소스 전송 주소로 사용합니다. 피어 A의 UDP 데이터그램이 중계된 전송 주소에서 수신되면 내용이 데이터 표시에 배치되어 클라이언트로 전달됩니다. 나중에 클라이언트는 피어 B와 데이터 교환을 시도합니다. 그러나 피어 B에 대한 권한이 설치되지 않았으므로 클라이언트의 보내기 표시와 피어의 UDP 데이터그램이 모두 서버에 의해 삭제됩니다.

---
### **2.5.  Channels**

일부 애플리케이션\(예: VoIP\)의 경우 보내기 표시 또는 데이터 표시가 애플리케이션 데이터에 추가하는 36바이트의 오버헤드로 인해 클라이언트와 서버 간에 필요한 대역폭이 크게 늘어날 수 있습니다. 이 문제를 해결하기 위해 TURN은 클라이언트와 서버가 데이터를 특정 피어와 연결하는 두 번째 방법을 제공합니다.

두 번째 방법은 ChannelData 메시지로 알려진 대체 패킷 형식을 사용합니다. ChannelData 메시지는 STUN을 사용하지 않습니다.

다른 TURN 메시지에서 사용되는 헤더 대신 채널 번호라고 알려진 숫자를 포함하는 4바이트 헤더가 있습니다. 사용 중인 각 채널 번호는 특정 피어에 바인딩되어 있으므로 피어의 호스트 전송 주소에 대한 약어 역할을 합니다.

채널을 피어에 바인딩하기 위해 클라이언트는 바인딩되지 않은 채널 번호와 피어의 전송 주소를 포함하여 서버에 ChannelBind 요청을 보냅니다. 채널이 바인딩되면 클라이언트는 ChannelData 메시지를 사용하여 피어로 향하는 서버 데이터를 보낼 수 있습니다. 마찬가지로 서버는 ChannelData 메시지를 사용하여 해당 피어의 데이터를 클라이언트로 중계할 수 있습니다.

채널 바인딩은 새로 고치지 않는 한 10분 동안 지속됩니다. 이 수명은 권한 수명보다 길게 선택되었습니다. 채널을 피어에 다시 바인딩하는 또 다른 ChannelBind 요청을 보내 채널 바인딩을 새로 고칩니다. 권한과 마찬가지로\(할당과는 달리\) 채널 바인딩을 명시적으로 삭제할 수 있는 방법은 없습니다. 클라이언트는 시간이 초과될 때까지 기다려야 합니다.

```text
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |-- ChannelBind req ---------------->|             |             |
    | (Peer A to 0x4001)                 |             |             |
    |                                    |             |             |
    |<---------- ChannelBind succ resp --|             |             |
    |                                    |             |             |
    |-- [0x4001] data ------------------>|             |             |
    |                                    |=== data ===>|             |
    |                                    |             |             |
    |                                    |<== data ====|             |
    |<------------------ [0x4001] data --|             |             |
    |                                    |             |             |
    |--- Send ind (Peer A)-------------->|             |             |
    |                                    |=== data ===>|             |
    |                                    |             |             |
    |                                    |<== data ====|             |
    |<------------------ [0x4001] data --|             |             |
    |                                    |             |             |

                                 Figure 4
```

그림 4는 사용 중인 채널 메커니즘을 보여줍니다. 클라이언트는 이미 할당을 생성했으며 이제 채널을 피어 A에 바인딩하려고 합니다. 이를 위해 클라이언트는 피어 A의 전송 주소와 채널 번호\(0x4001\)를 지정하여 서버에 ChannelBind 요청을 보냅니다. 그 후 클라이언트는 ChannelData 메시지 내에 캡슐화된 애플리케이션 데이터를 피어 A로 보낼 수 있습니다. 이는 다음과 같이 표시됩니다.

"\[0x4001\] 데이터" 여기서 0x4001은 채널 번호입니다. ChannelData 메시지가 서버에 도착하면 서버는 데이터를 UDP 데이터그램으로 전송하고 이를 피어 A\(채널 번호 0x4001에 바인딩된 피어\)로 보냅니다.

반대 방향으로, 피어 A가 중계된 전송 주소로 UDP 데이터그램을 보낼 때 이 UDP 데이터그램은 할당에 할당된 중계된 전송 주소의 서버에 도착합니다. UDP 데이터그램은 채널 번호가 할당된 피어 A로부터 수신되었으므로 서버는 클라이언트에 데이터를 보낼 때 데이터를 ChannelData 메시지로 캡슐화합니다.

채널이 바인딩되면 클라이언트는 ChannelData 메시지와 Send 표시를 자유롭게 혼합할 수 있습니다. 그림에서 클라이언트는 나중에 추가 데이터를 피어 A에 보내기 위해 ChannelData 메시지 대신 보내기 표시를 사용하기로 결정합니다. 예를 들어 클라이언트는 DONT-FRAGMENT 속성을 사용할 수 있도록 이 작업을 수행하기로 결정할 수 있습니다\(다음 참조\). 부분\). 그러나 채널이 바인딩되면 호출 흐름에 표시된 대로 서버는 항상 ChannelData 메시지를 사용합니다.

ChannelData 메시지는 클라이언트가 채널을 바인딩한 피어에만 사용할 수 있습니다. 위의 예에서 피어 A는 채널에 바인딩되었지만 피어 B는 그렇지 않았습니다. 따라서 피어 B와의 애플리케이션 데이터는 보내기 메커니즘을 사용합니다.

---
### **2.6.  Unprivileged TURN Servers**

이 버전의 TURN은 서버가 특별한 권한 없이 일반적으로 사용 가능한 운영 체제의 사용자 공간에서 실행되는 애플리케이션으로 구현될 수 있도록 설계되었습니다. 이 설계 결정은 TURN 서버 배포를 쉽게 하기 위해 이루어졌습니다. 예를 들어, 한 피어가 다른 피어에게 NAT 통과 서비스를 제공할 수 있도록 TURN 서버를 피어 투 피어 애플리케이션에 통합할 수 있도록 허용합니다.

이 설계 결정은 TURN 서버가 중계하는 데이터에 대해 다음과 같은 의미를 갖습니다.

```text
   o  The value of the Diffserv field may not be preserved across the
      server;

   o  The Time to Live (TTL) field may be reset, rather than
      decremented, across the server;

   o  The Explicit Congestion Notification (ECN) field may be reset by
      the server;

   o  ICMP messages are not relayed by the server;
```

o 패킷이 서버에서 재조립되므로 종단 간 조각화가 없습니다.

향후 작업에서는 이러한 제한 사항을 해결하는 대체 TURN 의미 체계를 지정할 수 있습니다.

---
### **2.7.  Avoiding IP Fragmentation**

\[Frag-Harmful\]에 설명된 이유로 인해 애플리케이션, 특히 대용량 데이터를 전송하는 애플리케이션은 패킷 조각화를 방지하기 위해 열심히 노력해야 합니다. TCP를 사용하는 애플리케이션은 조각화 방지가 이제 TCP의 표준 부분이기 때문에 이 문제를 어느 정도 무시할 수 있지만 UDP를 사용하는 애플리케이션\(따라서 이 TURN 버전을 사용하는 모든 애플리케이션\)은 조각화 방지를 자체적으로 처리해야 합니다.

클라이언트와 피어에서 실행되는 애플리케이션은 IP 조각화를 방지하기 위해 두 가지 접근 방식 중 하나를 사용할 수 있습니다.

첫 번째 접근 방식은 클라이언트와 피어 간에 교환되는 TURN 메시지/UDP 데이터그램에서 대량의 애플리케이션 데이터를 전송하지 않는 것입니다. 이는 대부분의 VoIP\(Voice-over-IP\) 애플리케이션에서 사용하는 접근 방식입니다. 이 접근 방식에서 애플리케이션은 IP 사양 \[RFC0791\]이 최대 576바이트의 IP 패킷을 조각화할 필요가 없다고 지정한다는 사실을 활용합니다.

조각화를 방지하면서 포함할 수 있는 애플리케이션 데이터의 정확한 양은 클라이언트와 서버 간의 TURN 세션 세부 사항, 즉 UDP, TCP 또는 TLS 전송이 사용되는지 여부, ChannelData 메시지 또는 Send/Data 표시가 사용되는지 여부에 따라 달라집니다. DONT-FRAGMENT 속성과 같은 추가 속성이 포함되어 있는지 여부. 결정하기 어려운 또 다른 요소는 IP-in-IP 터널링 사용과 같은 다른 이유로 인해 경로를 따라 어딘가에서 MTU가 감소하는지 여부입니다.

지침에 따라 단일 TURN 메시지\(클라이언트-서버 구간의 클라이언트에 의해\) 또는 UDP 데이터그램\(피어-서버 구간의 피어에 의해\)으로 최대 500바이트의 애플리케이션 데이터를 보내는 것은 일반적으로 IP 조각화를 방지합니다. 조각화 가능성을 더 줄이려면 클라이언트가 상당한 양의 데이터를 전송할 때 ChannelData 메시지를 사용하는 것이 좋습니다. 왜냐하면 ChannelData 메시지의 오버헤드가 보내기 및 데이터 표시보다 적기 때문입니다.

조각화를 방지하기 위해 클라이언트와 피어가 취할 수 있는 두 번째 접근 방식은 경로 MTU 검색 알고리즘을 사용하여 조각화 없이 전송할 수 있는 최대 애플리케이션 데이터 양을 결정하는 것입니다.

불행하게도 이 버전의 TURN을 구현하는 서버는 ICMP 메시지를 릴레이하지 않기 때문에 \[RFC1191\]에 정의된 클래식 경로 MTU 검색 알고리즘은 클라이언트와 피어 간의 전송 경로의 MTU를 검색할 수 없습니다. \(ICMP 메시지를 릴레이하더라도 ICMP 메시지는 결합된 NAT/방화벽 장치에 의해 필터링되는 경우가 많기 때문에 알고리즘이 항상 작동하지는 않습니다.\)

따라서 클라이언트와 서버는 ICMP 메시지가 필요하지 않은 경로 MTU 검색 알고리즘을 사용해야 합니다. \[RFC4821\]에 정의된 Packetized Path MTU Discovery 알고리즘은 그러한 알고리즘 중 하나입니다.

TURN과 함께 \[RFC4821\] 알고리즘을 사용하는 방법에 대한 자세한 내용은 아직 조사 중입니다. 그러나 이 목표를 향한 단계로 이 TURN 버전은 DONT-FRAGMENT 속성을 지원합니다. 클라이언트가 보내기 표시에 이 속성을 포함하면 이는 서버가 피어에게 보내는 결과 UDP 데이터그램에 DF 비트를 설정하도록 지시합니다. 일부 서버는 DF 비트를 설정할 수 없으므로 클라이언트는 할당 요청에 이 속성도 포함해야 합니다. DONT-FRAGMENT 속성을 지원하지 않는 서버는 할당 요청을 거부하여 이를 나타냅니다.

---
### **2.8.  RTP Support**

TURN의 계획된 용도 중 하나는 RTP를 사용하여 실시간 데이터\(예: 음성 또는 비디오\)를 교환하려는 클라이언트 및 피어를 위한 릴레이로 사용되는 것입니다. 이러한 목적으로 TURN을 쉽게 사용할 수 있도록 TURN에는 이전 버전의 RTP에 대한 몇 가지 특별한 지원이 포함되어 있습니다.

RTP의 이전 버전\[RFC3550\]에서는 RTP 스트림이 짝수 포트 번호에 있어야 하고 관련 RTCP\(RTP 제어 프로토콜\) 스트림이 있는 경우 다음으로 높은 포트에 있어야 했습니다. 클라이언트가 여전히 이를 필요로 하는 피어와 작업할 수 있도록 하기 위해 TURN은 클라이언트가 서버에 짝수 포트 번호로 릴레이된 전송 주소를 할당하도록 요청하고, 선택적으로 서버에 후속 할당을 위해 다음으로 높은 포트 번호를 예약하도록 요청할 수 있도록 허용합니다.

---
### **2.9.  Anycast Discovery of Servers**

이 TURN 버전은 UDP를 통해 TURN 서버의 애니캐스트 검색을 수행하는 방법의 향후 사양을 허용하도록 설계되었습니다.

특히 TURN 서버는 클라이언트가 대체 서버를 시도하라는 제안과 함께 할당 요청을 거부할 수 있습니다. 특정 유형의 공격을 방지하려면 클라이언트는 초기 서버에서와 마찬가지로 대체 서버에서도 동일한 자격 증명을 사용해야 합니다.

---
## **3.  Terminology**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. RFC 2119\[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

독자는 \[RFC5389\]와 여기에 정의된 용어에 익숙할 것으로 예상됩니다.

이 문서에서는 다음 용어가 사용됩니다.

TURN: TURN 클라이언트와 TURN 서버 간에 사용되는 프로토콜입니다. 이는 STUN 프로토콜 \[RFC5389\]의 확장입니다. 이 프로토콜을 사용하면 클라이언트가 중계된 전송 주소를 할당하고 사용할 수 있습니다.

TURN 클라이언트: 이 사양을 구현하는 STUN 클라이언트입니다.

TURN 서버: 이 사양을 구현하는 STUN 서버입니다. TURN 클라이언트와 해당 피어 간에 데이터를 중계합니다.

피어\(Peer\): TURN 클라이언트가 통신하려는 호스트입니다. TURN 서버는 TURN 클라이언트와 해당 피어 간의 트래픽을 중계합니다. 피어는 이 문서에 정의된 프로토콜을 사용하여 TURN 서버와 상호 작용하지 않습니다. 오히려 피어는 TURN 서버에서 보낸 데이터를 수신하고 피어는 TURN 서버를 향해 데이터를 보냅니다.

전송 주소: IP 주소와 포트의 조합입니다.

호스트 전송 주소: 클라이언트 또는 피어의 전송 주소입니다.

서버 반사 전송 주소: NAT의 "공용 측"에 있는 전송 주소입니다. 이 주소는 특정 호스트 전송 주소에 해당하도록 NAT에 의해 할당됩니다.

릴레이된 전송 주소: 클라이언트와 피어 간의 패킷을 중계하는 데 사용되는 TURN 서버의 전송 주소입니다. 피어는 TURN 서버에서 이 주소로 전송하고 패킷은 클라이언트로 중계됩니다.

TURN 서버 전송 주소: TURN 메시지를 서버에 보내는 데 사용되는 TURN 서버의 전송 주소입니다. 이는 클라이언트가 서버와 통신하는 데 사용하는 전송 주소입니다.

피어 전송 주소: 서버에 표시되는 피어의 전송 주소입니다. 피어가 NAT 뒤에 있는 경우 이는 피어의 서버 반사 전송 주소입니다.

할당: 권한 및 만료 타이머와 같은 관련 상태와 함께 할당 요청을 통해 클라이언트에 부여된 릴레이된 전송 주소입니다.

5-튜플: 클라이언트와 서버 간 통신에 사용되는 조합\(클라이언트 IP 주소 및 포트, 서버 IP 주소 및 포트, 전송 프로토콜\(현재 UDP, TCP 또는 TLS 중 하나\)\)입니다. 5-튜플은 이 통신 스트림을 고유하게 식별합니다. 5-튜플은 또한 서버의 할당을 고유하게 식별합니다.

채널: 채널 번호 및 관련 피어 전송 주소입니다. 채널 번호가 피어의 전송 주소에 바인딩되면 클라이언트와 서버는 대역폭 효율성이 더 높은 ChannelData 메시지를 사용하여 데이터를 교환할 수 있습니다.

권한: 트래픽을 TURN 서버로 보내고 해당 트래픽을 TURN 클라이언트로 릴레이하도록 허용된 피어의 IP 주소 및 전송 프로토콜\(포트는 아님\)입니다. TURN 서버는 기존 권한과 일치하는 피어의 트래픽만 클라이언트로 전달합니다.

영역: 서버 또는 서버 내의 컨텍스트를 설명하는 데 사용되는 문자열입니다. 영역은 요청을 인증하는 데 사용할 사용자 이름과 비밀번호 조합을 클라이언트에 알려줍니다.

Nonce: 서버에서 무작위로 선택하고 메시지 다이제스트에 포함된 문자열입니다. 응답 공격을 방지하려면 서버는 정기적으로 nonce를 변경해야 합니다.

---
## **4.  General Behavior**

이 섹션에는 모든 TURN 메시지에 적용되는 일반적인 TURN 처리 규칙이 포함되어 있습니다.

TURN은 STUN의 확장입니다. ChannelData 메시지를 제외한 모든 TURN 메시지는 STUN 형식의 메시지입니다. \[RFC5389\]에 설명된 모든 기본 처리 규칙은 STUN 형식의 메시지에 적용됩니다. 이는 이 문서의 모든 메시지 형성 및 메시지 처리 설명에 암시적으로 \[RFC5389\] 규칙이 접두사로 붙는다는 것을 의미합니다.

\[RFC5389\]는 장기 자격 증명 메커니즘이라는 인증 메커니즘을 지정합니다. TURN 서버와 클라이언트는 이 메커니즘을 구현해야 합니다. 서버는 클라이언트의 모든 요청이 이 메커니즘을 사용하여 인증되도록 요구하거나 클라이언트 인증을 위해 동등하거나 더 강력한 메커니즘이 사용되도록 요구해야 합니다.\(MUST, MUST\)

장기 자격 증명 메커니즘은 요청에만 적용되며 표시를 인증하는 데 사용할 수 없습니다. 따라서 TURN의 표시는 인증되지 않습니다. 서버가 인증 요청을 요구하는 경우, 서버 관리자는 클라이언트가 서로 다른 관리하에 여러 서버를 사용하는 경우에도 클라이언트가 사용해야 하는 사용자 이름과 비밀번호 조합을 고유하게 식별하는 영역 값을 선택해야 합니다. 서버 관리자는 각 클라이언트에 고유한 사용자 이름을 할당하도록 선택할 수도 있고, 둘 이상의 클라이언트\(예: 동일한 부서 또는 회사의 모든 클라이언트\)에 동일한 사용자 이름을 할당하도록 선택할 수도 있습니다. 각 할당에 대해 서버는 \[RFC4086\]의 무작위성 권장 사항에 따라 할당이 처음 시도될 때 새로운 무작위 nonce를 생성해야 하며 할당 수명 동안 적어도 한 시간마다 nonce를 만료해야 합니다.\(MUST, MAY, SHOULD\)

초기 할당 이후의 모든 요청은 공격자가 클라이언트 할당을 하이재킹하는 것을 방지하기 위해 할당을 생성하는 데 사용된 것과 동일한 사용자 이름을 사용해야 합니다. 특히, 서버가 장기 자격 증명 메커니즘을 사용해야 하고 할당되지 않은 요청이 이 메커니즘에 따라 인증을 통과하는 경우, 5-튜플이 기존 할당을 식별하지만 요청이 동일한 사용자 이름을 사용하지 않는 경우 할당을 생성하는 데 사용된 경우 요청은 441\(잘못된 자격 증명\) 오류와 함께 거부되어야 합니다.\(MUST\)

TURN 메시지가 클라이언트로부터 서버에 도착하면 서버는 메시지의 5-튜플을 사용하여 연관된 할당을 식별합니다. Allocate 요청을 제외한 모든 TURN 메시지\(ChannelData 포함\)에 대해 5-튜플이 기존 할당을 식별하지 못하는 경우 메시지는 437 Allocation Mismatch 오류\(요청인 경우\)로 거부되거나 자동으로 무시되어야 합니다\(MUST\). 이는 표시 또는 ChannelData 메시지입니다. 할당 이외의 요청에 대해 437 오류 응답을 수신하는 클라이언트는 할당이 더 이상 존재하지 않는다고 가정해야 합니다.\(MUST, MUST\)

\[RFC5389\]는 SOFTWARE 및 FINGERPRINT 속성을 포함한 여러 속성을 정의합니다. 클라이언트는 모든 할당 및 새로 고침 요청에 SOFTWARE 속성을 포함해야 하며 다른 요청이나 표시에도 이를 포함할 수 있습니다. 서버는 모든 할당 및 새로 고침 응답\(성공 또는 실패\)에 SOFTWARE 속성을 포함해야 하며 이를 다른 응답이나 표시에 포함할 수 있습니다. 클라이언트와 서버는 이 문서에 정의된 모든 STUN 형식 메시지에 FINGERPRINT 속성을 포함할 수 있습니다.\(SHOULD, SHOULD, MAY\)

TURN은 \[RFC5389\]에 설명된 이전 버전과의 호환성 메커니즘을 사용하지 않습니다.

본 사양에 정의된 TURN은 IPv4만 지원합니다. 클라이언트의 IP 주소, 서버의 IP 주소 및 릴레이된 전송 주소에 나타나는 모든 IP 주소는 IPv4 주소여야 합니다.\(MUST\)

기본적으로 TURN은 STUN과 동일한 포트\(UDP 및 TCP를 통한 TURN의 경우 3478, TLS를 통한 TURN의 경우 5349\)에서 실행됩니다. 그러나 TURN에는 UDP 및 TCP의 경우 "turn", TLS의 경우 "turns"라는 자체 서비스 레코드\(SRV\) 이름 세트가 있습니다. 섹션 6에 설명된 SRV 프로시저 또는 ALTERNATE-SERVER 프로시저를 사용하여 다른 포트에서 TURN을 실행할 수 있습니다.

상호 운용성을 보장하기 위해 TURN 서버는 클라이언트와 서버 간의 UDP 전송 사용을 지원해야 하며\(MUST\) TCP 및 TLS 전송 사용을 지원해야 합니다\(SHOULD\).\(MUST\)

클라이언트와 서버 간에 UDP 전송이 사용되는 경우 클라이언트는 특정 시간 초과 기간 내에 응답을 받지 못하면 요청을 다시 전송합니다. 이로 인해 서버는 동일한 5-튜플 및 동일한 트랜잭션 ID를 가진 두 개 이상의 요청을 받을 수 있습니다. STUN은 서버가 이 경우를 인식하고 요청을 멱등성으로 처리하도록 요구합니다\(\[RFC5389\] 참조\). 일부 구현에서는 수신된 모든 요청과 해당 응답을 40초 동안 기억하여 이 요구 사항을 충족하도록 선택할 수 있습니다. 다른 구현에서는 요청을 재처리하고 그러한 재처리가 본질적으로 동일한 응답을 반환하도록 조정하도록 선택할 수 있습니다. 후자의 접근 방식\(소위 "상태 비저장 스택 접근 방식"\)을 선택하는 구현자를 돕기 위해 이 사양에는 이를 수행하는 방법에 대한 몇 가지 구현 참고 사항이 포함되어 있습니다. 구현에서는 접근 방식을 자유롭게 선택하거나 동일한 결과를 제공하는 다른 접근 방식을 선택할 수 있습니다.

클라이언트와 서버 간에 TCP 전송이 사용되는 경우 비트 오류로 인해 TURN 패킷의 길이 필드가 손상되어 수신자가 TURN 메시지의 수신 스트림과 동기화를 잃게 될 수 있습니다. TCP 전송을 통해 일련의 잘못된 TURN 메시지를 감지한 클라이언트나 서버는 상대방이 이 상황을 더 신속하게 감지할 수 있도록 해당 TCP 연결을 닫아야 합니다.\(SHOULD\)

유효한 사용자 이름과 비밀번호를 가진 클라이언트의 서버에 대한 고의적이거나 의도하지 않은 서비스 거부 공격을 완화하기 위해 서버는 주어진 사용자 이름과 비밀번호에 대해 동시에 활성화되는 할당 수와 할당량 모두에 제한을 두는 것이 좋습니다. 해당 할당이 사용할 수 있는 대역폭입니다. 서버는 486\(할당 할당량 초과\)\(섹션 6.2 참조\)으로 한 번에 활성화되는 할당 수에 대한 제한을 초과하는 새 할당을 거부해야 하며 대역폭 할당량을 초과하는 애플리케이션 데이터 트래픽을 삭제해야 합니다.\(SHOULD\)

---
## **5.  Allocations**

모든 TURN 작업은 할당을 중심으로 진행되며 모든 TURN 메시지는 할당과 연결됩니다. 할당은 개념적으로 다음 상태 데이터로 구성됩니다.

```text
   o  the relayed transport address;

   o  the 5-tuple: (client's IP address, client's port, server IP
      address, server port, transport protocol);

   o  the authentication information;

   o  the time-to-expiry;

   o  a list of permissions;
```

o 채널 대 피어 바인딩 목록.

릴레이된 전송 주소는 피어와의 통신을 위해 서버에서 할당한 전송 주소이고, 5-튜플은 클라이언트와 서버 간의 통신 경로를 설명합니다. 클라이언트에서 5-튜플은 클라이언트의 호스트 전송 주소를 사용합니다. 서버에서 5-튜플은 클라이언트의 서버 재귀 전송 주소를 사용합니다.

중계된 전송 주소와 5-튜플은 모두 모든 할당에서 고유해야 하므로 둘 중 하나를 사용하여 할당을 고유하게 식별할 수 있습니다.\(MUST\)

인증 정보\(예: 사용자 이름, 비밀번호, 영역 및 nonce\)는 후속 요청을 확인하고 응답의 메시지 무결성을 계산하는 데 사용됩니다. 사용자 이름, 영역 및 nonce 값은 처음에 할당을 생성하는 인증된 Allocate 요청에 사용된 값이지만 서버는 438\(Stale Nonce\) 응답을 사용하여 할당 수명 동안 nonce 값을 변경할 수 있습니다. 보안상의 이유로 비밀번호를 명시적으로 저장하는 것보다 서버가 사용자 이름, 영역 및 비밀번호에 대한 MD5 해시인 키 값을 저장하는 것이 바람직할 수 있습니다\(\[RFC5389\] 참조\).

만료 시간은 할당이 만료될 때까지 남은 시간\(초\)입니다. 각 할당 또는 새로 고침 트랜잭션은 이 타이머를 설정한 다음 0을 향해 내려갑니다. 기본적으로 각 할당 또는 새로 고침 트랜잭션은 이 타이머를 기본 수명 값인 600초\(10분\)로 재설정하지만 클라이언트는 할당 및 새로 고침 요청. 할당은 새로 고침 요청을 통해서만 새로 고칠 수 있습니다. 피어에게 데이터를 보내도 새로 고쳐지지 않습니다.

배당. 할당이 만료되면 할당과 관련된 상태 데이터가 해제될 수 있습니다.

권한 목록은 섹션 8에 설명되어 있으며 채널 목록은 섹션 11에 설명되어 있습니다.

---
## **6.  Creating an Allocation**

서버에 대한 할당은 Allocate 트랜잭션을 사용하여 생성됩니다.

---
### **6.1.  Sending an Allocate Request**

클라이언트는 다음과 같이 할당 요청을 구성합니다.

클라이언트는 먼저 호스트 전송 주소를 선택합니다. 일반적으로 기본 OS가 새 소켓에 대해 현재 사용되지 않는 포트를 선택하도록 허용하여 클라이언트가 현재 사용되지 않는 전송 주소를 선택하는 것이 권장됩니다.\(SHOULD\)

그런 다음 클라이언트는 클라이언트와 서버 간에 사용할 전송 프로토콜을 선택합니다. 전송 프로토콜은 UDP, TCP 또는 TLS-over-TCP 중 하나여야 합니다. 이 사양은 서버와 피어 간의 UDP만 허용하므로 클라이언트가 다른 전송을 사용할 이유가 없는 한 UDP를 선택하는 것이 좋습니다. 다른 전송을 선택하는 한 가지 이유는 클라이언트가 구성이나 실험을 통해 UDP를 사용하여 어떤 TURN 서버에도 연결할 수 없다고 믿기 때문입니다. 자세한 내용은 섹션 2.1을 참조하세요.\(MUST, SHOULD\)

클라이언트는 또한 다음과 같이 수행되어야 하는 서버 전송 주소를 선택합니다. 클라이언트는 \(아마도 구성을 통해\) TURN 서버의 도메인 이름을 받습니다. 그런 다음 클라이언트는 \[RFC5389\]에 설명된 DNS 절차를 사용하지만 "stun"\(또는 "stuns"\) 대신 "turn"\(또는 TLS를 통한 TURN의 경우 "turns"\)이라는 SRV 서비스 이름을 사용합니다. 예를 들어, example.com 도메인에서 서버를 찾기 위해 클라이언트는 '\_turn.\_udp.example.com', '\_turn.\_tcp.example.com' 및 '\_turns.\_tcp.example.com'에 대한 조회를 수행합니다. 클라이언트는 각각 UDP, TCP 또는 TLS-over-TCP를 사용하여 서버와 통신하려고 합니다.\(SHOULD\)

클라이언트는 요청에 REQUESTED-TRANSPORT 속성을 포함해야 합니다. 이 속성은 서버와 피어 간의 전송 프로토콜을 지정합니다\(5-튜플에 나타나는 전송 프로토콜이 아님\). 이 사양에서 REQUESTED-TRANSPORT 유형은 항상 UDP입니다. 이 속성은 향후 확장에서 다른 프로토콜을 지정할 수 있도록 포함됩니다.\(MUST\)

클라이언트가 서버가 할당의 만료 시간 필드를 기본값이 아닌 다른 값으로 초기화하기를 원하는 경우

수명이 있는 경우 원하는 값을 지정하는 LIFETIME 속성을 포함할 수 있습니다. 이는 단지 요청일 뿐이며 서버는 다른 값을 사용하도록 선택할 수 있습니다. 서버는 필드를 기본값보다 작게 초기화하라는 요청을 무시합니다.\(MAY\)

클라이언트가 나중에 이 할당에 대한 하나 이상의 보내기 표시에서 DONT-FRAGMENT 속성을 사용하려는 경우 클라이언트는 할당 요청에 DONT-FRAGMENT 속성을 포함해야 합니다. 이를 통해 클라이언트는 이 속성이 서버에서 지원되는지 여부를 테스트할 수 있습니다.\(SHOULD\)

클라이언트가 릴레이된 전송 주소의 포트 번호가 짝수여야 하는 경우 클라이언트는 EVEN-PORT 속성을 포함합니다. 이 속성이 포함되지 않으면 포트는 짝수 또는 홀수일 수 있습니다. EVEN-PORT 속성의 R 비트를 1로 설정하면 클라이언트는 서버가 후속 할당을 위해 다음으로 높은 포트 번호\(동일한 IP 주소에서\)를 예약하도록 요청할 수 있습니다. R 비트가 0이면 그러한 요청이 이루어지지 않습니다.

클라이언트는 할당을 위해 이전에 예약된 포트를 사용하도록 서버에 요청하는 요청에 RESERVATION-TOKEN 속성을 포함할 수도 있습니다. RESERVATION-TOKEN 속성이 포함된 경우 클라이언트는 EVEN-PORT 속성을 생략해야 합니다.\(MAY, MUST\)

일단 구성되면 클라이언트는 5-튜플에 대한 할당 요청을 보냅니다.

---
### **6.2.  Receiving an Allocate Request**

서버는 할당 요청을 받으면 다음 확인을 수행합니다.

1. 서버는 요청이 인증되도록 요구해야 합니다. 이 인증은 클라이언트와 서버가 이 문서의 범위를 벗어나는 일부 절차를 통해 다른 메커니즘을 사용하는 데 동의하지 않는 한 \[RFC5389\]의 장기 자격 증명 메커니즘을 사용하여 수행되어야 합니다.\(MUST, MUST\)

2. 서버는 5-튜플이 현재 기존 할당에 의해 사용되고 있는지 확인합니다. 그렇다면 서버는 437\(할당 불일치\) 오류로 요청을 거부합니다.

3. 서버는 요청에 REQUESTED-TRANSPORT 속성이 포함되어 있는지 확인합니다. REQUESTED-TRANSPORT 속성이 포함되지 않거나 형식이 잘못된 경우 서버는 400\(잘못된 요청\) 오류로 요청을 거부합니다. 그렇지 않고 속성이 포함되어 있지만 UDP가 아닌 다른 프로토콜을 지정하는 경우 서버는 442\(지원되지 않는 전송 프로토콜\) 오류와 함께 요청을 거부합니다.

4. 요청에는 DONT-FRAGMENT 속성이 포함될 수 있습니다. 그렇다면 서버는 DF 비트가 1로 설정된 UDP 데이터그램 전송을 지원하지 않습니다\(섹션 12 참조\). 그러면 서버는 Allocate 요청의 DONT-FRAGMENT 속성을 알 수 없는 이해 필수 속성으로 처리합니다.

5. 서버는 요청에 RESERVATION-TOKEN 속성이 포함되어 있는지 확인합니다. 그렇다면 요청에 EVEN-PORT 속성도 포함된 경우 서버는 400\(잘못된 요청\) 오류로 요청을 거부합니다. 그렇지 않으면 토큰이 유효한지 확인합니다\(즉, 토큰이 범위 내에 있고 만료되지 않았으며 해당 중계 전송 주소가 여전히 사용 가능함\). 어떤 이유로 토큰이 유효하지 않으면 서버는 508\(용량 부족\) 오류와 함께 요청을 거부합니다.

6. 서버는 요청에 EVEN-PORT 속성이 포함되어 있는지 확인합니다. 그렇다면 서버는 요청을 충족할 수 있는지 확인합니다\(즉, 아래 설명된 대로 중계된 전송 주소를 할당할 수 있음\). 서버가 요청을 충족할 수 없는 경우 서버는 508\(용량 부족\) 오류로 요청을 거부합니다.

7. 어느 시점에서든 클라이언트가 로컬로 정의된 할당 할당량을 초과하려고 시도하는 경우 서버는 486\(할당 할당량 도달\) 오류와 함께 요청을 거부하도록 선택할 수 있습니다. 서버는 원하는 방식으로 이 할당 할당량을 자유롭게 정의할 수 있지만 클라이언트의 전송 주소가 아니라 요청을 인증하는 데 사용된 사용자 이름을 기반으로 정의해야 합니다.\(MAY, SHOULD\)

8. 또한 언제든지 서버는 클라이언트를 다른 서버로 리디렉션하려는 경우 300\(대체 시도\) 오류로 요청을 거부하도록 선택할 수 있습니다. 이 오류 코드 및 속성의 사용은 \[RFC5389\]의 사양을 따릅니다.\(MAY\)

모든 검사가 통과되면 서버는 할당을 생성합니다. 5-튜플은 할당 요청에서 5-튜플로 설정되지만 권한 목록과 채널 목록은 처음에는 비어 있습니다.

서버는 다음과 같이 할당을 위해 중계된 전송 주소를 선택합니다.

o 요청에 RESERVATION-TOKEN이 포함된 경우 서버는 포함된 토큰에 해당하는 이전에 예약된 전송 주소를 사용합니다\(아직 사용 가능한 경우\). RESERVATION-TOKEN을 포함하는 Allocate 요청은 예약을 수행한 Allocate 요청과 다른 5-튜플을 사용하므로 예약은 서버 전체 예약이며 특정 할당에 국한되지 않습니다. 할당을 위한 5튜플

- RESERVATION-TOKEN 속성을 포함하는 요청은 허용되는 5-튜플일 수 있습니다. 다른 클라이언트 IP 주소와 포트, 다른 전송 프로토콜, 심지어 다른 서버 IP 주소와 포트도 사용할 수 있습니다\(물론 서버 IP 주소와 포트가 서버가 TURN 요청을 수신하는 주소와 포트인 경우\).

o 요청에 R 비트가 0으로 설정된 EVEN-PORT 속성이 포함되어 있으면 서버는 짝수 포트 번호를 사용하여 중계된 전송 주소를 할당합니다.

o 요청에 R 비트가 1로 설정된 EVEN-PORT 속성이 포함되어 있으면 서버는 동일한 IP 주소에서 포트 번호 N과 N+1 쌍을 찾습니다. 여기서 N은 짝수입니다. 포트 N은 현재 할당에 사용되는 반면, 포트 N+1로 릴레이된 전송 주소에는 토큰이 할당되고 향후 할당을 위해 예약됩니다. 서버는 이 예약을 최소 30초 동안 유지해야 하며 더 오랫동안 유지하도록 선택할 수 있습니다\(예: 포트 N의 할당이 만료될 때까지\). 그런 다음 서버는 성공 응답의 RESERVATION-TOKEN 속성에 토큰을 포함합니다.\(MUST\)

o 그렇지 않으면 서버는 사용 가능한 중계 전송 주소를 할당합니다.

모든 경우에 서버는 TURN 서버 애플리케이션이 여기에 지정되지 않은 수단을 통해 실행 중인 다른 애플리케이션이 TURN 서버 애플리케이션과 동일한 호스트에 있는 경우 이 범위 밖의 포트를 할당해도 영향을 받지 않습니다. 이 조건은 종종 전용 시스템에서 TURN 서버 애플리케이션을 실행하거나 TURN 서버 애플리케이션이 시작되기 전에 시스템의 다른 애플리케이션이 포트를 할당하도록 조정하여 충족될 수 있습니다. 어떤 경우에도 TURN 서버는 클라이언트가 표준 서비스를 실행하기 위해 TURN을 사용하는 것을 방해하기 위해 0 - 1023 범위\(잘 알려진 포트 범위\)의 포트를 할당해서는 안 됩니다.\(SHOULD, SHOULD NOT\)

- 참고: IETF는 현재 특정 유형의 공격을 피하기 위해 무작위 포트 할당 주제를 조사하고 있습니다\(\[TSVWG-PORT\] 참조\). TURN 구현자는 이 주제를 숙지하고 적절한 경우 무작위 포트 할당 알고리즘을 구현하는 것이 좋습니다. 이는 기본 OS에서 여러 포트를 사전 할당한 다음 나중에 할당에 할당하도록 선택한 서버에 특히 적용됩니다. 예를 들어, 서버는 EVEN-PORT 속성을 구현하기 위해 이 기술을 선택할 수 있습니다.

서버는 만료 시간 필드의 초기 값을 다음과 같이 결정합니다. 요청에 LIFETIME 속성이 포함되어 있으면 서버는 클라이언트가 제안한 최소 수명과 서버가 허용하는 최대 수명을 계산합니다. 이 계산된 값이 기본 수명보다 크면 서버는 계산된 수명을 만료 시간 필드의 초기 값으로 사용합니다. 그렇지 않으면 서버는 기본 수명을 사용합니다. 서버는 3600초\(1시간\) 이하의 최대 허용 수명 값을 사용하는 것이 좋습니다. 할당 할당량을 구현하거나 어떤 방식으로든 할당에 대해 사용자에게 요금을 부과하는 서버는 분리된 할당\(즉, 해당 클라이언트가 충돌하거나 종료된 할당\)을 더 빠르게 제거하기 위해 더 작은 최대 허용 수명\(아마도 기본 수명만큼 작음\)을 사용하기를 원할 수 있습니다. 또는 어떤 이유로 클라이언트 연결이 끊어졌습니다\). 또한 만료 시간은 새로 고침 요청이 성공할 때마다 다시 계산되므로 여기에서 계산된 값은 첫 번째 새로 고침까지만 적용됩니다.\(SHOULD\)

할당이 생성되면 서버는 성공 응답으로 응답합니다. 성공 응답에는 다음이 포함됩니다.

o 중계된 전송 주소를 포함하는 XOR-RELAYED-ADDRESS 속성.

o 만료 시간 타이머의 현재 값을 포함하는 LIFETIME 속성.

o RESERVATION-TOKEN 속성\(두 번째 중계 전송 주소가 예약된 경우\).

o 클라이언트의 IP 주소와 포트\(5-튜플에서\)를 포함하는 XOR-MAPPED-ADDRESS 속성.

- 참고: XOR-MAPPED-ADDRESS 속성은 클라이언트의 편의를 위해 응답에 포함됩니다. TURN 자체는 이 값을 사용하지 않지만 ICE를 실행하는 클라이언트는 종종 이 값이 필요할 수 있으므로 이를 학습하기 위해 일부 STUN 서버와 추가 바인딩 트랜잭션을 수행할 필요가 없습니다.

응답\(성공 또는 오류\)은 5-튜플을 통해 클라이언트로 다시 전송됩니다.

- 참고: Allocate 요청이 UDP를 통해 전송되는 경우 \[RFC5389\]의 섹션 7.3.1에서는 재전송으로 인해 여러 할당이 생성되지 않도록 서버가 요청의 가능한 재전송을 처리하도록 요구합니다. 구현에서는 다음과 같이 소위 "상태 비저장 스택 접근 방식"을 사용하여 이를 달성할 수 있습니다. 원래 요청이 할당 생성에 성공했을 때 재전송을 감지하기 위해 서버는

- 할당 데이터로 요청을 생성한 트랜잭션 ID이며 이를 동일한 5-튜플에서 들어오는 Allocate 요청과 비교합니다. 이러한 요청이 감지되면 서버는 요청 구문 분석을 중지하고 즉시 성공 응답을 생성할 수 있습니다. 이 응답을 작성할 때 이 값이 원래 반환된 LIFETIME 값과 약간 다를 수 있더라도 할당 상태 데이터의 만료 시간 필드에서 LIFETIME 속성 값을 가져올 수 있습니다. 또한 서버는 원래 응답에서 반환된 예약 토큰 표시를 저장하여 재전송된 응답에서 반환될 수 있도록 해야 할 수도 있습니다.

- 원래 요청이 할당 생성에 실패한 경우 서버는 특별한 작업을 수행하지 않도록 선택할 수 있습니다. 그러나 서버가 원래 요청을 거부하고 재전송된 요청을 수락하는 경우가 드물다는 점에 유의하세요\(짧은 중간 시간 동안 조건이 변경되었기 때문\). 클라이언트가 첫 번째 실패 응답을 받으면 두 번째\(성공\) 응답을 무시하고 할당이 생성되지 않았다고 믿습니다. 이 문제에서 생성된 할당은 클라이언트가 이를 새로 고치지 않으므로 결국 시간 초과됩니다. 또한 클라이언트가 나중에 동일한 5-튜플을 사용하여 다른 트랜잭션 ID로 재시도하는 경우 437\(할당 불일치\)을 수신하게 되어 다른 5-튜플로 재시도하게 됩니다. 서버는 이러한 방식으로 "분리된" 할당의 수명을 최소화하기 위해 더 작은 최대 수명 값을 사용할 수 있습니다.

---
### **6.3.  Receiving an Allocate Success Response**

클라이언트가 할당 성공 응답을 수신하면 매핑된 주소와 중계된 전송 주소가 클라이언트가 이해하고 처리할 준비가 된 주소 계열에 있는지 확인해야 합니다. 이 사양은 이 두 주소가 IPv4 주소인 경우에만 적용됩니다. 이 두 주소가 클라이언트가 처리할 준비가 된 주소 계열에 속하지 않는 경우 클라이언트는 할당을 삭제해야 하며\(섹션 7\) 불일치가 수정되었다고 믿을 때까지 해당 서버에서 다른 할당을 생성하려고 시도해서는 안 됩니다.\(MUST, MUST NOT\)

- IETF는 현재 클라이언트가 IPv6를 통해 할당 요청을 시작하지만 요청이 IPv4를 통해 서버에 도착하거나 그 반대의 결과를 초래할 수 있는 IPv4와 IPv6 간의 전환 메커니즘을 고려하고 있습니다.

그렇지 않으면 클라이언트는 할당 데이터 구조의 자체 복사본을 만들어 서버에서 발생하는 상황을 추적합니다. 특히, 클라이언트는 요청 시 서버에 전송된 값이 아니라 서버에서 다시 받은 실제 수명을 기억해야 합니다.

또한 클라이언트는 요청에 사용된 5-튜플과 요청을 인증하는 데 사용한 사용자 이름 및 비밀번호를 기억하여 후속 메시지에 재사용할 수 있도록 해야 합니다. 클라이언트는 또한 서버에 설정된 채널과 권한을 추적해야 합니다.

클라이언트는 피어가 통신할 수 있도록 릴레이된 전송 주소를 피어\(여기에 지정되지 않은 일부 방법을 사용하여\)에 보내려고 할 것입니다. 클라이언트는 ICE 처리 시 XOR-MAPPED-ADDRESS 속성에서 수신한 서버 반사 주소를 사용하기를 원할 수도 있습니다.

---
### **6.4.  Receiving an Allocate Error Response**

클라이언트가 할당 오류 응답을 받으면 처리는 반환된 실제 오류 코드에 따라 달라집니다.

o \(요청 시간 초과\): 서버에 문제가 있거나 선택한 전송으로 서버에 도달하는 데 문제가 있습니다. 클라이언트는 현재 트랜잭션이 실패한 것으로 간주하지만 다른 전송\(예: UDP 대신 TCP\)을 사용하여 할당 요청을 재시도하도록 선택할 수 있습니다.\(MAY\)

o 300\(대체 시도\): 서버는 클라이언트가 ALTERNATE-SERVER 속성에 지정된 서버를 대신 사용하기를 원합니다. 클라이언트는 현재 트랜잭션이 실패한 것으로 간주하지만 다른 서버\(예: SRV 절차를 사용하여 검색된 다른 서버\)를 시도하기 전에 대체 서버로 할당 요청을 시도해야 합니다. 대체 서버로 할당 요청을 시도할 때 클라이언트는 \[RFC5389\]에 지정된 ALTERNATE-SERVER 절차를 따릅니다.\(SHOULD\)

o 400\(잘못된 요청\): 서버는 클라이언트의 요청이 어떤 이유로 인해 잘못되었다고 믿습니다. 클라이언트는 현재 트랜잭션이 실패한 것으로 간주합니다. 클라이언트는 사용자나 운영자에게 알릴 수 있으며 문제가 해결되었다고 믿을 때까지 이 서버로 요청을 재시도해서는 안 됩니다.\(SHOULD NOT\)

o 401\(권한 없음\): 클라이언트가 장기 자격 증명 메커니즘의 절차를 따랐는데도 여전히 이 오류가 발생하는 경우 서버가 클라이언트의 자격 증명을 수락하지 않는 것입니다. 이 경우 클라이언트는 현재 트랜잭션이 실패한 것으로 간주하고 사용자나 운영자에게 알려야 합니다. 클라이언트는 문제가 해결되었다고 믿을 때까지 이 서버에 추가 요청을 보내서는 안 됩니다.\(SHOULD, SHOULD NOT\)

o 403\(금지됨\): 요청은 유효하지만 관리 제한으로 인해 서버가 요청 수행을 거부하고 있습니다. 클라이언트는 현재 트랜잭션이 실패한 것으로 간주합니다. 클라이언트는 사용자나 운영자에게 알릴 수 있으며 문제가 해결되었다고 믿을 때까지 이 서버로 동일한 요청을 재시도해서는 안 됩니다.\(SHOULD NOT\)

o 420\(알 수 없는 속성\): 클라이언트가 요청에 DONT-FRAGMENT 속성을 포함하고 서버가 420 오류 코드로 요청을 거부하고 오류 응답의 UNKNOWN-ATTRIBUTES 속성에 DONT-FRAGMENT 속성을 나열한 경우 클라이언트는 이제 서버가 DONT-FRAGMENT 속성을 지원하지 않는다는 것을 알고 있습니다. 클라이언트는 현재 트랜잭션이 실패한 것으로 간주하지만 DONT-FRAGMENT 속성 없이 할당 요청을 재시도하도록 선택할 수 있습니다.\(MAY\)

o 437\(할당 불일치\): 이는 서버가 이미 사용 중인 것으로 간주하는 5-튜플을 클라이언트가 선택했음을 나타냅니다. 이런 일이 발생할 수 있는 한 가지 방법은 개입 NAT가 최근에 충돌이 발생한 다른 클라이언트에서 사용했던 매핑된 전송 주소를 할당한 경우입니다. 클라이언트는 현재 트랜잭션이 실패한 것으로 간주합니다. 클라이언트는 다른 클라이언트 전송 주소를 선택하고 \(다른 트랜잭션 ID를 사용하여\) 할당 요청을 재시도해야 합니다. 클라이언트는 이 서버를 포기하기 전에 세 가지 다른 클라이언트 전송 주소를 시도해야 합니다. 클라이언트가 서버를 포기하면 2분 동안 서버에 다른 할당을 생성하려고 시도해서는 안 됩니다.\(SHOULD, SHOULD, SHOULD NOT\)

o 438\(Stale Nonce\): 장기 자격 증명 메커니즘 \[RFC5389\]에 대한 절차를 참조하세요.

o 441\(잘못된 자격 증명\): 클라이언트는 할당 요청에 대한 응답으로 이 오류를 수신해서는 안 됩니다. 클라이언트는 사용자나 운영자에게 알릴 수 있으며 문제가 해결되었다고 믿을 때까지 이 서버로 동일한 요청을 재시도해서는 안 됩니다.\(SHOULD NOT\)

o 442\(지원되지 않는 전송 주소\): 클라이언트는 UDP 할당 요청에 대한 응답으로 이 오류를 수신해서는 안 됩니다. 클라이언트는 사용자나 운영자에게 알릴 수 있으며 문제가 해결되었다고 믿을 때까지 이 서버로 요청을 다시 시도해서는 안 됩니다.\(SHOULD NOT\)

o 486\(할당 할당량 도달\): 서버는 현재 이 사용자 이름으로 더 이상 할당을 생성할 수 없습니다. 클라이언트는 현재 트랜잭션이 실패한 것으로 간주합니다. 클라이언트는 서버에 추가 할당을 생성하기 전에 최소 1분을 기다려야 합니다.\(SHOULD\)

o 508\(용량 부족\): 서버에 더 이상 사용 가능한 릴레이 전송 주소가 없거나, 요청한 속성이 없거나, 예약된 전송 주소를 더 이상 사용할 수 없습니다. 클라이언트는 현재 작업이 실패한 것으로 간주합니다. 클라이언트가 EVEN-PORT 또는 RESERVATION-TOKEN 속성을 사용하는 경우 클라이언트는 이 속성을 제거하거나 수정하고 즉시 다시 시도하도록 선택할 수 있습니다. 그렇지 않으면 클라이언트는 이 서버에 추가 할당을 생성하기 전에 최소 1분을 기다려야 합니다.\(MAY, SHOULD\)

알 수 없는 오류 응답은 \[RFC5389\]에 설명된 대로 처리되어야 합니다.\(MUST\)

---
## **7.  Refreshing an Allocation**

새로 고침 트랜잭션은 \(a\) 기존 할당을 새로 고치고 만료 시간을 업데이트하거나 \(b\) 기존 할당을 삭제하는 데 사용할 수 있습니다.

클라이언트가 할당을 계속 사용하려면 만료되기 전에 할당을 새로 고쳐야 합니다. 클라이언트는 만료되기 약 1분 전에 할당을 새로 고치는 것이 좋습니다. 클라이언트가 더 이상 할당을 사용하지 않으려면 할당을 명시적으로 삭제해야 합니다. 클라이언트는 다른 이유로 언제든지 할당을 새로 고칠 수 있습니다.\(MUST, SHOULD, MAY\)

---
### **7.1.  Sending a Refresh Request**

클라이언트가 기존 할당을 즉시 삭제하려는 경우 값이 0인 LIFETIME 속성이 포함됩니다. 요청의 다른 모든 형식은 할당을 새로 고칩니다.

새로 고침 트랜잭션은 할당의 만료 시간 타이머를 업데이트합니다. 클라이언트가 서버가 만료 시간 타이머를 기본 수명이 아닌 다른 것으로 설정하기를 원하는 경우 요청된 값이 있는 LIFETIME 속성이 포함됩니다. 그런 다음 서버는 요청된 수명이 0인 경우 서버가 할당을 즉시 삭제한다는 점을 제외하고 Allocate 트랜잭션과 동일한 방식으로 새로운 만료 시간 값을 계산합니다.

---
### **7.2.  Receiving a Refresh Request**

서버가 새로 고침 요청을 받으면 섹션 4와 여기에 언급된 특정 규칙에 따라 처리합니다.

서버는 다음과 같이 "원하는 수명"이라는 값을 계산합니다. 요청에 LIFETIME 속성이 포함되어 있고 속성 값이 0이면 "원하는 수명"은 0입니다. 그렇지 않고 요청에 LIFETIME 속성이 포함된 경우 서버는 최소값을 계산합니다

클라이언트가 요청한 수명과 서버의 최대 허용 수명입니다. 이 계산된 값이 기본 수명보다 큰 경우 "원하는 수명"이 계산된 값입니다. 그렇지 않으면 "원하는 수명"이 기본 수명입니다.

후속 처리는 "원하는 수명" 값에 따라 달라집니다.

o "원하는 수명"이 0이면 요청이 성공하고 할당이 삭제됩니다.

o "원하는 수명"이 0이 아닌 경우 요청은 성공하고 할당 만료 시간은 "원하는 수명"으로 설정됩니다.

요청이 성공하면 서버는 다음을 포함하는 성공 응답을 보냅니다.

o 만료 시간 타이머의 현재 값을 포함하는 LIFETIME 속성.

참고: 서버는 구현을 위해 특별한 작업을 수행할 필요가 없습니다.

- "상태 비저장 스택 접근 방식"을 사용하여 UDP를 통한 새로 고침 요청의 멱등성. "원하는 수명"이 0이 아닌 재전송된 새로 고침 요청은 단순히 할당을 새로 고치게 됩니다. "원하는 수명"이 0인 재전송된 새로 고침 요청은 할당이 이미 삭제된 경우 437\(할당 불일치\) 응답을 유발하지만 클라이언트는 이를 성공 응답과 동일하게 처리합니다\(아래 참조\).

---
### **7.3.  Receiving a Refresh Response**

클라이언트가 수명이 0이 아닌 새로 고침 요청에 대한 성공 응답을 받으면 응답에 포함된 만료 시간 값으로 할당 데이터 구조의 복사본을 업데이트합니다.

클라이언트가 할당 삭제 요청에 대해 437\(할당 불일치\) 오류 응답을 받으면 할당이 더 이상 존재하지 않으며 해당 요청이 사실상 성공한 것으로 간주해야 합니다.

---
## **8.  Permissions**

각 할당에 대해 서버는 0개 이상의 권한 목록을 유지합니다. 각 권한은 IP 주소와 관련 만료 시간으로 구성됩니다. 권한이 존재하는 동안 해당 권한에 있는 IP 주소를 사용하는 모든 피어는 데이터를 보낼 수 있습니다.

클라이언트. 만료 시간은 권한이 만료될 때까지의 시간\(초\)입니다. 할당 컨텍스트 내에서 권한은 연결된 IP 주소로 고유하게 식별됩니다.

CreatePermission 요청 또는 ChannelBind 요청을 보내면 클라이언트는 서버가 지정된 IP 주소에 대한 권한을 설치하거나 새로 고치도록 할 수 있습니다. 이로 인해 다음 두 가지 중 하나가 발생합니다.

o 해당 IP 주소에 대한 권한이 없으면 지정된 IP 주소와 권한 수명과 동일한 만료 시간을 사용하여 권한이 생성됩니다.

o 해당 IP 주소에 대한 권한이 이미 존재하는 경우 해당 권한의 만료 시간은 권한 수명으로 재설정됩니다.

권한 수명은 300초\(= 5분\)여야 합니다.\(MUST\)

각 권한의 만료 시간은 0에 도달할 때까지 초당 한 번씩 감소합니다. 이 시점에서 권한은 만료되고 삭제됩니다.

CreatePermission 및 ChannelBind 요청은 권한에 자유롭게 혼합될 수 있습니다. 지정된 권한은 처음에 CreatePermission 요청으로 설치 및/또는 새로 고침된 다음 나중에 ChannelBind 요청으로 새로 고쳐지거나 그 반대일 수 있습니다.

UDP 데이터그램이 할당을 위해 중계된 전송 주소에 도착하면 서버는 IP 헤더에서 소스 IP 주소를 추출합니다. 그런 다음 서버는 이 주소를 할당 권한 목록의 각 권한과 연결된 IP 주소와 비교합니다. 일치하는 항목이 없으면 중계가 허용되지 않으며 서버는 UDP 데이터그램을 자동으로 삭제합니다. 정확히 일치하는 항목이 발견되면 권한 확인이 성공한 것으로 간주되고 서버는 다른 곳에 지정된 대로 UDP 데이터그램을 계속 처리합니다\(10.3절\). 주소만 비교되고 포트 번호는 고려되지 않습니다.

한 할당에 대한 권한은 다른 할당에 대한 권한과 전혀 관련이 없습니다. 할당이 만료되면 모든 권한도 함께 만료됩니다.

- 참고: TURN 권한은 5분 후에 만료되지만 게시 당시 배포된 많은 NAT는 UDP 바인딩을 훨씬 더 빠르게 만료합니다. 따라서 TURN을 사용하는 애플리케이션은 일종의 연결 유지 트래픽을 훨씬 더 빠른 속도로 전송하기를 원할 것입니다. ICE를 사용하는 애플리케이션은 ICE \[RFC5245\]의 연결 유지 지침을 따라야 하며, ICE를 사용하지 않는 애플리케이션은 유사한 작업을 수행하는 것이 좋습니다.

---
## **9.  CreatePermission**

TURN은 클라이언트가 서버에 권한을 설치하거나 새로 고치는 두 가지 방법을 지원합니다. 이 섹션에서는 CreatePermission 요청이라는 한 가지 방법을 설명합니다.

CreatePermission 요청은 섹션 10의 보내기 메커니즘 또는 섹션 11의 채널 메커니즘과 함께 사용될 수 있습니다.

---
### **9.1.  Forming a CreatePermission Request**

하나 이상의 권한을 설치하거나 새로 고치려는 클라이언트는 서버에 CreatePermission 요청을 보낼 수 있습니다.

CreatePermission 요청을 구성할 때 클라이언트는 최소한 하나의 XOR-PEER-ADDRESS 속성을 포함해야 하며 이러한 속성을 두 개 이상 포함할 수 있습니다. 각 XOR-PEER-ADDRESS 속성의 IP 주소 부분에는 권한을 설치하거나 새로 고쳐야 하는 IP 주소가 포함되어 있습니다. 각 XOR-PEER-ADDRESS 속성의 포트 부분은 무시되며 임의의 값이 될 수 있습니다. 다양한 XOR-PEER-ADDRESS 속성은 어떤 순서로도 나타날 수 있습니다.\(MUST\)

---
### **9.2.  Receiving a CreatePermission Request**

서버가 CreatePermission 요청을 받으면 섹션 4와 여기에 언급된 특정 규칙에 따라 처리합니다.

메시지의 유효성이 검사됩니다. CreatePermission 요청은 최소한 하나의 XOR-PEER-ADDRESS 속성을 포함해야 하며 이러한 속성을 여러 개 포함할 수 있습니다. 해당 속성이 존재하지 않거나 이러한 속성 중 하나라도 유효하지 않은 경우 400\(잘못된 요청\) 오류가 반환됩니다. 요청이 유효하지만 일부 용량 제한 등으로 인해 서버가 요청을 충족할 수 없는 경우 508\(용량 부족\) 오류가 반환됩니다.\(MUST\)

서버는 XOR-PEER-ADDRESS 속성에 허용된 IP 주소에 제한을 가할 수 있습니다. 값이 허용되지 않으면 서버는 403\(금지됨\) 오류와 함께 요청을 거부합니다.\(MAY\)

메시지가 유효하고 서버가 요청을 수행할 수 있는 경우 서버는 섹션 8에 설명된 대로 각 XOR-PEER-ADDRESS 속성에 포함된 IP 주소에 대한 권한을 설치하거나 새로 고칩니다. 각 속성의 포트 부분은 다음과 같습니다. 무시되며 임의의 값일 수 있습니다.

그런 다음 서버는 CreatePermission 성공 응답으로 응답합니다. 성공 응답에는 필수 속성이 없습니다.

참고: 서버는 구현을 위해 특별한 작업을 수행할 필요가 없습니다.

- "상태 비저장 스택 접근 방식"을 사용하여 UDP를 통한 CreatePermission 요청의 멱등성. 재전송된 CreatePermission 요청은 권한을 새로 고치기만 합니다.

---
### **9.3.  Receiving a CreatePermission Response**

클라이언트가 유효한 CreatePermission 성공 응답을 받으면 클라이언트는 해당 데이터 구조를 업데이트하여 권한이 설치되었거나 새로 고쳐졌음을 나타냅니다.

---
## **10.  Send and Data Methods**

TURN은 피어로부터 데이터를 보내고 받는 두 가지 메커니즘을 지원합니다. 이 섹션에서는 전송 및 데이터 메커니즘의 사용을 설명하고 섹션 11에서는 채널 메커니즘의 사용을 설명합니다.

---
### **10.1.  Forming a Send Indication**

클라이언트는 피어에 중계하기 위해 보내기 표시를 사용하여 데이터를 서버에 전달할 수 있습니다. 클라이언트는 채널이 해당 피어에 바인딩된 경우에도 보내기 표시를 사용할 수 있습니다. 그러나 클라이언트는 보내기 표시가 전송되는 피어의 IP 주소에 대해 설치된 권한이 있는지 확인해야 합니다. 이는 제3자가 TURN 서버를 사용하여 임의의 대상으로 데이터를 보내는 것을 방지합니다.\(MUST\)

Send 표시를 구성할 때 클라이언트는 XOR-PEER-ADDRESS 속성과 DATA 속성을 포함해야 합니다. XOR-PEER-ADDRESS 속성에는 데이터를 보낼 피어의 전송 주소가 포함되고, DATA 속성에는 해당 피어에 보낼 실제 애플리케이션 데이터가 포함됩니다.\(MUST\)

클라이언트는 서버가 피어에게 전송된 UDP 데이터그램에 DF 비트를 설정하기를 원하는 경우 보내기 표시에 DONT-FRAGMENT 속성을 포함할 수 있습니다.\(MAY\)

---
### **10.2.  Receiving a Send Indication**

서버가 보내기 표시를 받으면 섹션 4와 여기에 언급된 특정 규칙에 따라 처리합니다.

먼저 메시지의 유효성을 확인합니다. 보내기 표시에는 XOR-PEER-ADDRESS 속성과 DATA 속성이 모두 포함되어야 합니다. 이러한 속성 중 하나가 누락되거나 유효하지 않은 경우 메시지가 삭제됩니다. DATA 속성에는 0바이트의 데이터가 포함될 수 있습니다.\(MUST\)

보내기 표시에는 DONT-FRAGMENT 속성이 포함될 수도 있습니다. 이 속성이 존재할 때 서버가 나가는 UDP 데이터그램에 DF 비트를 설정할 수 없는 경우 서버는 DONT-FRAGMENT 속성이 알 수 없는 이해 필수 속성인 것처럼 작동합니다\(따라서 보내기 표시가 삭제됩니다\).

또한 서버는 XOR-PEER-ADDRESS 속성에 포함된 IP 주소에 대해 설치된 권한이 있는지 확인합니다. 해당 권한이 없으면 메시지가 삭제됩니다. 보내기 표시로 인해 서버가 권한을 새로 고치는 일은 결코 발생하지 않습니다.

서버는 XOR-PEER-ADDRESS 속성에서 허용되는 IP 주소 및 포트 값에 제한을 가할 수 있습니다. 값이 허용되지 않으면 서버는 자동으로 보내기 표시를 삭제합니다.\(MAY\)

모든 것이 정상이면 서버는 다음과 같이 UDP 데이터그램을 형성합니다.

```text
   o  the source transport address is the relayed transport address of
      the allocation, where the allocation is determined by the 5-tuple
      on which the Send indication arrived;

   o  the destination transport address is taken from the XOR-PEER-
      ADDRESS attribute;
```

o UDP 헤더 뒤의 데이터는 DATA 속성의 값 필드 내용입니다.

DONT-FRAGMENT 속성\(있는 경우\)의 처리는 섹션 12에 설명되어 있습니다.

그런 다음 결과 UDP 데이터그램이 피어로 전송됩니다.

---
### **10.3.  Receiving a UDP Datagram**

서버가 현재 할당된 중계 전송 주소에서 UDP 데이터그램을 수신하면 서버는 중계된 전송 주소와 연관된 할당을 조회합니다. 그런 다음 서버는 섹션 8에 설명된 대로 할당에 대한 권한 집합이 UDP 데이터그램 중계를 허용하는지 확인합니다.

중계가 허용되면 서버는 UDP 데이터그램을 보낸 피어에 바인딩된 채널이 있는지 확인합니다\(섹션 11 참조\). 채널이 바인딩된 경우 섹션 11.7에 설명된 대로 처리가 진행됩니다.

중계가 허용되지만 피어에 바인딩된 채널이 없으면 서버는 데이터 표시를 형성하고 보냅니다. 데이터 표시에는 XOR-PEER-ADDRESS와 DATA 속성이 모두 포함되어야 합니다. 자료\(MUST\)

속성은 데이터그램의 '데이터 옥텟' 필드 값으로 설정되고 XOR-PEER-ADDRESS 속성은 수신된 UDP 데이터그램의 소스 전송 주소로 설정됩니다. 그런 다음 데이터 표시는 할당과 관련된 5-튜플로 전송됩니다.

---
### **10.4.  Receiving a Data Indication**

클라이언트가 데이터 표시를 수신하면 데이터 표시에 XOR-PEER-ADDRESS와 DATA 속성이 모두 포함되어 있는지 확인하고, 포함되어 있지 않으면 해당 표시를 삭제합니다. 클라이언트는 또한 XOR-PEER-ADDRESS 속성 값에 클라이언트가 활성 권한이 있다고 믿는 IP 주소가 포함되어 있는지 확인하고 그렇지 않은 경우 데이터 표시를 폐기해야 합니다. DATA 속성에는 0바이트의 데이터가 포함될 수 있습니다.\(SHOULD\)

- 참고: 후자의 검사는 클라이언트가 원하지 않는 권한을 설치하도록 서버를 속이는 공격자로부터 클라이언트를 보호합니다.

데이터 표시가 위의 검사를 통과하면 클라이언트는 XOR-PEER-ADDRESS 속성에 의해 전송 주소가 제공되는 피어로부터 수신되었다는 표시와 함께 DATA 속성 내의 데이터 옥텟을 애플리케이션에 전달합니다.

---
## **11.  Channels**

채널은 클라이언트와 서버가 Send 및 Data 표시보다 오버헤드가 적은 ChannelData 메시지를 사용하여 애플리케이션 데이터를 보내는 방법을 제공합니다.

ChannelData 메시지\(11.4절 참조\)는 채널 번호를 전달하는 2바이트 필드로 시작합니다. 이 필드의 값은 다음과 같이 할당됩니다.

- 0x0000 \~ 0x3FFF: 이 값은 채널 번호에 사용할 수 없습니다.

- 0x4000 \~ 0x7FFF: 허용되는 채널 번호\(16,383개 가능 값\)입니다.

- 0x8000\~0xFFFF: 이 값은 향후 사용을 위해 예약되어 있습니다.

이러한 구분으로 인해 ChannelData 메시지는 메시지의 처음 두 비트를 검사하여 STUN 형식의 메시지\(예: 할당 요청, 전송 표시 등\)와 구별될 수 있습니다.

- 0b00: STUN 형식 메시지\(STUN 형식 메시지의 처음 두 비트는 항상 0이므로\).

- 0b01: ChannelData 메시지\(채널 번호는 ChannelData 메시지의 첫 번째 필드이고 채널 번호는 0x4000 - 0x7FFF 범위에 속하므로\).

```text
      0b10: Reserved

      0b11: Reserved
```

예약된 값은 향후 채널 번호 범위를 확장하는 데 사용될 수 있습니다. 따라서 구현에서는 TURN 메시지가 항상 0비트로 시작한다고 가정해서는 안 됩니다.\(MUST NOT\)

채널 바인딩은 항상 클라이언트에 의해 시작됩니다. 클라이언트는 할당 수명 동안 언제든지 채널을 피어에 바인딩할 수 있습니다. 클라이언트는 데이터를 교환하기 전이나 일정 시간 동안 데이터를 교환한 후\(전송 및 데이터 표시 사용\) 채널을 피어에 바인딩할 수 있으며 채널을 바인딩하지 않도록 선택할 수도 있습니다. 클라이언트는 채널을 다른 피어에 바인딩하지 않고 일부 피어에 채널을 바인딩할 수도 있습니다.

채널 바인딩은 할당에 따라 다르므로 한 할당의 채널 바인딩에서 채널 번호나 피어 전송 주소를 사용해도 다른 할당에서의 사용에는 영향을 주지 않습니다. 할당이 만료되면 모든 채널 바인딩도 함께 만료됩니다.

채널 바인딩은 다음으로 구성됩니다.

```text
   o  a channel number;
```

o \(피어의\) 전송 주소; 그리고

o 만료 시간 타이머.

할당 컨텍스트 내에서 채널 바인딩은 채널 번호나 피어의 전송 주소로 고유하게 식별됩니다. 따라서 동일한 채널이 두 개의 다른 전송 주소에 바인딩될 수 없으며 동일한 전송 주소가 두 개의 다른 채널에 바인딩될 수 없습니다.

채널 바인딩은 새로 고치지 않는 한 10분 동안 지속됩니다. 바인딩을 새로 고치면\(ChannelBind 요청을 수신하는 서버가 채널을 동일한 피어에 다시 바인딩하여\) 만료 시간 타이머가 다시 10분으로 재설정됩니다.

채널 바인딩이 만료되면 채널 바인딩이 해제됩니다. 바인딩이 해제되면 채널 번호는 다른 전송 주소에 바인딩될 수 있고 전송 주소는 다른 채널 번호에 바인딩될 수 있습니다. 경쟁 조건을 방지하려면 클라이언트는 5분을 기다려야 합니다.\(MUST\)

채널 바인딩이 만료된 후 몇 분 후에 채널 번호를 다른 전송 주소에 바인딩하거나 전송 주소를 다른 채널 번호에 바인딩하려고 시도합니다.

채널을 피어에 바인딩할 때 클라이언트는 ChannelBind 요청을 전송하자마자 서버로부터 채널의 ChannelData 메시지를 수신할 준비를 해야 합니다. UDP를 통해 클라이언트는 ChannelBind 성공 응답을 받기 전에 서버로부터 ChannelData 메시지를 받을 수 있습니다.\(SHOULD\)

다른 방향에서는 클라이언트가 ChannelBind 성공 응답을 받기 전에 ChannelData 메시지를 보내도록 선택할 수도 있습니다. 그러나 이렇게 하면 어떤 이유로 ChannelBind 요청이 성공하지 못하는 경우\(예: 요청이 UDP를 통해 전송되는 경우 패킷이 손실되거나 서버가 요청을 이행할 수 없는 경우\) 서버에서 ChannelData 메시지를 삭제할 위험이 있습니다. . 안전을 원하는 클라이언트는 채널 바인딩이 확인될 때까지 데이터를 대기열에 넣거나 보내기 표시를 사용해야 합니다.\(MAY\)

---
### **11.1.  Sending a ChannelBind Request**

채널 바인딩은 ChannelBind 트랜잭션을 사용하여 생성되거나 새로 고쳐집니다. ChannelBind 트랜잭션은 또한 피어에 대한 권한을 생성하거나 새로 고칩니다\(섹션 8 참조\).

ChannelBind 트랜잭션을 시작하기 위해 클라이언트는 ChannelBind 요청을 구성합니다. 바인딩할 채널은 CHANNEL-NUMBER 속성에 지정되며, 피어의 전송 주소는 XOR-PEER-ADDRESS 속성에 지정됩니다. 섹션 11.2에서는 이러한 속성에 대한 제한 사항을 설명합니다.

이미 바인딩된 동일한 전송 주소에 채널을 리바인딩하면 데이터를 피어에 전송하지 않고도 채널 바인딩과 해당 권한을 새로 고치는 방법을 제공합니다. 그러나 권한은 채널보다 더 자주 새로 고쳐야 합니다.

---
### **11.2.  Receiving a ChannelBind Request**

서버가 ChannelBind 요청을 받으면 섹션 4와 여기에 언급된 특정 규칙에 따라 처리합니다.

서버는 다음을 확인합니다.

```text
   o  The request contains both a CHANNEL-NUMBER and an XOR-PEER-ADDRESS
      attribute;

   o  The channel number is in the range 0x4000 through 0x7FFE
      (inclusive);

   o  The channel number is not currently bound to a different transport
      address (same transport address is OK);
```

o 전송 주소는 현재 다른 채널 번호에 바인딩되어 있지 않습니다.

이러한 테스트 중 하나라도 실패하면 서버는 400\(잘못된 요청\) 오류로 응답합니다.

서버는 XOR-PEER-ADDRESS 속성에서 허용되는 IP 주소 및 포트 값에 제한을 가할 수 있습니다. 값이 허용되지 않으면 서버는 403\(금지됨\) 오류와 함께 요청을 거부합니다.\(MAY\)

요청이 유효하지만 일부 용량 제한 등으로 인해 서버가 요청을 이행할 수 없는 경우 서버는 508\(용량 부족\) 오류로 응답합니다.

그렇지 않으면 서버는 ChannelBind 성공 응답으로 응답합니다. 성공적인 ChannelBind 응답에는 필수 속성이 없습니다.

서버가 요청을 만족할 수 있으면 서버는 CHANNEL-NUMBER 속성의 채널 번호와 XOR-PEER-ADDRESS 속성의 전송 주소를 사용하여 채널 바인딩을 생성하거나 새로 고칩니다. 또한 서버는 섹션 8에 설명된 대로 XOR-PEER-ADDRESS 속성의 IP 주소에 대한 권한을 설치하거나 새로 고칩니다.

참고: 서버는 구현을 위해 특별한 작업을 수행할 필요가 없습니다.

- "상태 비저장 스택 접근 방식"을 사용하여 UDP를 통한 ChannelBind 요청의 멱등성. 재전송된 ChannelBind 요청은 단순히 채널 바인딩과 해당 권한을 새로 고칩니다. 또한 클라이언트는 이전에 바인딩된 채널 번호 또는 피어 주소를 다른 채널에 바인딩하기 전에 5분을 기다려야 하므로 트랜잭션이 처음에는 실패했지만 재전송에 성공할 가능성이 제거됩니다.

---
### **11.3.  Receiving a ChannelBind Response**

클라이언트가 ChannelBind 성공 응답을 받으면 데이터 구조를 업데이트하여 채널 바인딩이 현재 활성화되었음을 기록합니다. 또한 해당 권한이 설치되었거나 새로 고쳐졌음을 기록하기 위해 데이터 구조를 업데이트합니다.

클라이언트가 클라이언트와 서버 사이의 채널 정보가 동기화되지 않았음을 나타내는 ChannelBind 실패 응답\(예: 예상치 못한 400 "잘못된 요청" 응답\)을 수신하는 경우 클라이언트가 즉시 할당을 삭제하는 것이 좋습니다\(RECOMMENDED\) 새로운 할당으로 새롭게 시작하세요.\(SHOULD\)

---
### **11.4.  The ChannelData Message**

ChannelData 메시지는 클라이언트와 서버 간에 애플리케이션 데이터를 전달하는 데 사용됩니다. 다음과 같은 형식을 갖습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Channel Number        |            Length             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                       Application Data                        /
   /                                                               /
   |                                                               |
   |                               +-------------------------------+
   |                               |
   +-------------------------------+
```

채널 번호 필드는 데이터가 이동하는 채널 번호와 데이터를 보내거나 받을 피어의 주소를 지정합니다.

길이 필드는 애플리케이션 데이터 필드의 길이\(즉, ChannelData 헤더의 크기를 포함하지 않음\)를 바이트 단위로 지정합니다. 0은 유효한 길이입니다.

애플리케이션 데이터 필드는 클라이언트가 피어에게 보내려고 하는 데이터 또는 피어가 클라이언트에게 보내는 데이터를 전달합니다.

---
### **11.5.  Sending a ChannelData Message**

클라이언트가 채널을 피어에 바인딩하면 클라이언트가 해당 피어에 보낼 데이터가 있으면 ChannelData 메시지 또는 보내기 표시를 사용할 수 있습니다. 즉, 클라이언트는 채널이 존재할 때 채널을 사용할 의무가 없으며 피어에게 데이터를 보낼 때 두 메시지 유형을 자유롭게 혼합할 수 있습니다. 반면에 서버는 채널이 피어에 바인딩된 경우 ChannelData 메시지를 사용해야 합니다.\(MUST\)

ChannelData 메시지의 필드는 섹션 11.4에 설명된 대로 채워집니다.

TCP 및 TLS-over-TCP를 통해 ChannelData 메시지는 후속 메시지의 정렬을 보장하기 위해 4바이트의 배수로 채워져야 합니다. 패딩은 ChannelData 메시지의 길이 필드에 반영되지 않으므로 ChannelData 메시지의 실제 크기\(패딩 포함\)는 가장 가까운 4의 배수로 반올림된 \(4 + 길이\)입니다. UDP에서는 패딩이 필요하지 않지만, 포함될 수 있습니다.\(MUST, MAY\)

그런 다음 ChannelData 메시지는 할당과 관련된 5-튜플을 통해 전송됩니다.

---
### **11.6.  Receiving a ChannelData Message**

위에서 설명한 대로 ChannelData 메시지의 수신자는 처음 두 비트를 사용하여 STUN 형식의 메시지와 구별합니다. 메시지가 예약된 범위\(0x8000 - 0xFFFF\)의 값을 사용하는 경우 메시지는 자동으로 삭제됩니다.

ChannelData 메시지가 UDP 데이터그램으로 수신되고 UDP 데이터그램이 너무 짧아서 ChannelData 메시지의 요청된 길이를 포함할 수 없는 경우\(즉, UDP 헤더 길이 필드 값이 ChannelData 헤더 길이 필드 값 + 4 + 8보다 작은 경우\) \), 메시지는 자동으로 삭제됩니다.

ChannelData 메시지가 TCP 또는 TLS-over-TCP를 통해 수신된 경우 ChannelData 메시지의 실제 길이는 섹션 11.5에 설명되어 있습니다.

어떤 피어에도 바인딩되지 않은 채널에서 ChannelData 메시지가 수신되면 메시지는 자동으로 삭제됩니다.

클라이언트에서는 피어에 대한 활성 권한이 없다고 판단하는 경우 ChannelData 메시지를 삭제하는 것이 좋습니다. 서버에서 ChannelData 메시지 수신은 채널 바인딩이나 피어에 대한 권한을 새로 고쳐서는 안 됩니다.\(SHOULD, MUST NOT\)

서버에서 오류가 감지되지 않으면 서버는 다음과 같이 UDP 데이터그램을 구성하여 애플리케이션 데이터를 피어에 중계합니다.

```text
   o  the source transport address is the relayed transport address of
      the allocation, where the allocation is determined by the 5-tuple
      on which the ChannelData message arrived;

   o  the destination transport address is the transport address to
      which the channel is bound;
```

o UDP 헤더 뒤의 데이터는 ChannelData 메시지의 데이터 필드 내용입니다.

그런 다음 결과 UDP 데이터그램이 피어로 전송됩니다. ChannelData 메시지의 길이 필드가 0이면 UDP 데이터그램에는 데이터가 없지만 UDP 데이터그램은 여전히 ​​형성되어 전송됩니다.

---
### **11.7.  Relaying Data from the Peer**

서버가 할당과 관련된 중계된 전송 주소에서 UDP 데이터그램을 수신하면 서버는 섹션 10.3에 설명된 대로 이를 처리합니다. 해당 섹션에서 ChannelData 메시지를 보내야 한다고 표시하는 경우\(UDP 데이터그램으로 보낸 피어에 바인딩된 채널이 있기 때문에\) 서버는 섹션 11.5에 설명된 대로 ChannelData 메시지를 구성하고 보냅니다.

---
## **12.  IP Header Fields**

이 섹션에서는 클라이언트와 피어 간 또는 그 반대로 중계할 때 서버가 IP 헤더의 다양한 필드를 설정하는 방법을 설명합니다. 이 섹션의 설명은 \(a\) 서버가 UDP 데이터그램을 피어에 보낼 때 또는 \(b\) 서버가 UDP 전송을 통해 클라이언트에 데이터 표시 또는 ChannelData 메시지를 보낼 때 적용됩니다. 이 섹션의 설명은 서버에서 클라이언트로 TCP 또는 TLS 전송을 통해 전송되는 TURN 메시지에는 적용되지 않습니다.

아래 설명은 기본 동작과 대체 동작의 두 부분으로 구성됩니다. 서버는 선호하는 동작을 구현해야 하지만, 특정 필드에 대해 이것이 가능하지 않은 경우 대체 동작을 구현해야 합니다.\(SHOULD\)

TTL\(Time to Live\) 필드

- 선호하는 동작: 들어오는 값이 0이면 들어오는 패킷을 삭제합니다. 그렇지 않으면 나가는 Time to Live/Hop Count를 들어오는 값보다 작은 값으로 설정합니다.

- 대체 동작: 나가는 값을 나가는 패킷의 기본값으로 설정합니다.

```text
   Differentiated Services Code Point (DSCP) field [RFC2474]
```

- 선호 동작: 서버에 차별화된 서비스 분류자 및 표시자\[RFC2474\]가 포함되어 있지 않은 경우 나가는 값을 들어오는 값으로 설정합니다.

- 대체 동작: 나가는 값을 고정된 값으로 설정합니다. 이 값은 달리 구성하지 않는 한 기본적으로 최선의 노력입니다.

두 경우 모두 서버가 서버에 바로 인접해 있는 경우

- 차별화된 서비스 분류자 및 마커인 경우 DSCP는 분류자 방향으로 임의의 값으로 설정될 수 있습니다.\(MAY\)

```text
   Explicit Congestion Notification (ECN) field [RFC3168]
```

- 선호 동작: 나가는 값을 들어오는 값으로 설정합니다. 서버가 활성 대기열 관리를 수행하지 않는 한 들어오는 ECN 필드는 ECT\(1\) \(=0b01\) 또는 ECT\(0\) \(=0b10\)이고 서버는 다음을 원합니다. 혼잡이 발생했음을 나타내며, 이 경우 나가는 값을 CE\(=0b11\)로 설정합니다.

- 대체 동작: 나가는 값을 Not-ECT\(=0b00\)로 설정합니다.

```text
   IPv4 Fragmentation fields
```

- 선호 동작: 서버가 DONT-FRAGMENT 속성이 포함된 보내기 표시에 대한 응답으로 피어에게 패킷을 보낼 때 나가는 IP 헤더의 DF 비트를 1로 설정합니다. 다른 모든 경우에는 응용 프로그램이 포함된 나가는 패킷을 보낼 때 데이터\(예: 데이터 표시, ChannelData 메시지 또는 보내기 표시에 포함되지 않은 DONT-FRAGMENT 속성\), 애플리케이션 데이터가 포함된 수신 패킷의 DF 비트에서 DF 비트를 복사합니다.

다른 조각화 필드 설정\(식별, 더보기

- 조각, 조각 오프셋\)은 서버에서 발생하는 패킷에 적합합니다.

- 대체 동작: 기본 동작에 설명된 대로 항상 들어오는 DF 비트가 0이라고 가정합니다.

- 기본 동작과 대체 동작 모두에서 결과 패킷이 나가는 링크에 비해 너무 클 수 있습니다. 이 경우 일반적인 조각화 규칙 \[RFC1122\]이 적용됩니다.

```text
   IPv4 Options
```

- 선호하는 동작: 나가는 패킷은 IPv4 옵션 없이 전송됩니다.

- 대체 동작: 기본 동작과 동일합니다.

---
## **13.  New STUN Methods**

이 섹션에는 이 사양에 정의된 새로운 STUN 메서드에 대한 코드 포인트가 나열되어 있습니다. 이러한 새로운 메서드의 의미는 이 문서의 다른 곳을 참조하세요.

```text
   0x003  :  Allocate          (only request/response semantics defined)
   0x004  :  Refresh           (only request/response semantics defined)
   0x006  :  Send              (only indication semantics defined)
   0x007  :  Data              (only indication semantics defined)
   0x008  :  CreatePermission  (only request/response semantics defined
   0x009  :  ChannelBind       (only request/response semantics defined)
```

---
## **14.  New STUN Attributes**

이 STUN 확장은 다음과 같은 새로운 속성을 정의합니다.

```text
     0x000C: CHANNEL-NUMBER
     0x000D: LIFETIME
     0x0010: Reserved (was BANDWIDTH)
     0x0012: XOR-PEER-ADDRESS
     0x0013: DATA
     0x0016: XOR-RELAYED-ADDRESS
     0x0018: EVEN-PORT
     0x0019: REQUESTED-TRANSPORT
     0x001A: DONT-FRAGMENT
     0x0021: Reserved (was TIMER-VAL)
     0x0022: RESERVATION-TOKEN
```

이러한 속성 중 일부는 4의 배수가 아닌 길이를 갖습니다. STUN의 규칙에 따라 길이가 4바이트의 배수가 아닌 모든 속성은 다음 속성\(있는 경우\)이 다음 속성을 보장하도록 즉시 1\~3개의 패딩 바이트가 와야 합니다. 4바이트 경계에서 시작합니다\(\[RFC5389\] 참조\).\(MUST\)

---
### **14.1.  CHANNEL-NUMBER**

CHANNEL-NUMBER 속성에는 채널 번호가 포함됩니다. 이 속성의 값 부분은 길이가 4바이트이고 16비트 부호 없는 정수와 그 뒤에 오는 2옥텟 RFFU\(향후 사용을 위해 예약됨\) 필드로 구성됩니다. 이 필드는 전송 시 0으로 설정되어야 하고 수신 시 무시되어야 합니다.\(MUST\)

```text
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |        Channel Number         |         RFFU = 0              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **14.2.  LIFETIME**

LIFETIME 속성은 새로 고침이 없을 때 서버가 할당을 유지하는 기간을 나타냅니다. 이 속성의 값 부분은 길이가 4바이트이고 만료까지 남은 시간\(초\)을 나타내는 32비트 부호 없는 정수 값으로 구성됩니다.

---
### **14.3.  XOR-PEER-ADDRESS**

XOR-PEER-ADDRESS는 TURN 서버에서 보이는 피어의 주소와 포트를 지정합니다. \(예를 들어 피어가 NAT 뒤에 있는 경우 피어의 서버 재귀 전송 주소입니다.\) XOR-MAPPED-ADDRESS \[RFC5389\]와 동일한 방식으로 인코딩됩니다.

---
### **14.4.  DATA**

DATA 속성은 모든 Send 및 Data 표시에 나타납니다. 이 속성의 값 부분은 가변 길이이며 애플리케이션 데이터\(즉, 데이터가 클라이언트와 피어 간에 직접 전송된 경우 UDP 헤더 바로 뒤에 오는 데이터\)로 구성됩니다. 이 속성의 길이가 4의 배수가 아닌 경우 이 속성 뒤에 패딩을 추가해야 합니다.

---
### **14.5.  XOR-RELAYED-ADDRESS**

XOR-RELAYED-ADDRESS는 할당 응답에 있습니다. 서버가 클라이언트에 할당한 주소와 포트를 지정합니다. XOR-MAPPED-ADDRESS \[RFC5389\]와 같은 방식으로 인코딩됩니다.

---
### **14.6.  EVEN-PORT**

이 속성을 사용하면 클라이언트는 릴레이된 전송 주소의 포트가 짝수가 되도록 요청할 수 있으며 \(선택적으로\) 서버가 다음으로 높은 포트 번호를 예약하도록 할 수 있습니다. 이 속성의 값 부분은 길이가 1바이트입니다. 형식은 다음과 같습니다.

```text
      0
      0 1 2 3 4 5 6 7
     +-+-+-+-+-+-+-+-+
     |R|    RFFU     |
     +-+-+-+-+-+-+-+-+
```

값에는 단일 1비트 플래그가 포함됩니다.

R: 1인 경우 서버는 후속 할당을 위해 다음으로 높은 포트 번호\(동일한 IP 주소\)를 예약하도록 요청됩니다. 0이면 해당 예약이 요청되지 않습니다.

속성 값의 다른 7비트는 전송 시 0으로 설정되고 수신 시 무시됩니다.

이 속성의 길이는 4의 배수가 아니므로 패딩은 이 속성 바로 뒤에 있어야 합니다.

---
### **14.7.  REQUESTED-TRANSPORT**

```text
   This attribute is used by the client to request a specific transport
   protocol for the allocated transport address.  The value of this
   attribute is 4 bytes with the following format:
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |    Protocol   |                    RFFU                       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

프로토콜 필드는 원하는 프로토콜을 지정합니다. 이 필드에 사용되는 코드 포인트는 IPv4 헤더의 프로토콜 필드와 IPv6 헤더 \[Protocol-Numbers\]의 NextHeader 필드에서 허용되는 코드 포인트에서 가져옵니다. 이 사양에서는 코드 포인트 17\(사용자 데이터그램 프로토콜\)만 사용할 수 있습니다.

RFFU 필드는 전송 시 0으로 설정되어야 하며 수신 시 무시되어야 합니다. 향후 사용을 위해 예약되어 있습니다.\(MUST\)

---
### **14.8.  DONT-FRAGMENT**

이 속성은 클라이언트가 애플리케이션 데이터를 피어에게 전달할 때 서버가 IP 헤더에 DF\(Don't Fragment\) 비트를 설정하도록 요청하는 데 사용됩니다. 이 속성에는 값 부분이 없으므로 속성 길이 필드는 0입니다.

---
### **14.9.  RESERVATION-TOKEN**

RESERVATION-TOKEN 속성에는 서버가 예약한 중계 전송 주소를 고유하게 식별하는 토큰이 포함되어 있습니다. 서버는 클라이언트에 토큰에 대해 알리기 위해 성공 응답에 이 속성을 포함하고, 클라이언트는 할당을 위해 중계된 전송 주소를 서버에 사용하도록 요청하기 위해 후속 Allocate 요청에 이 속성을 포함합니다.

속성 값은 8바이트이며 토큰 값을 포함합니다.

---
## **15.  New STUN Error Response Codes**

이 문서는 다음과 같은 새로운 오류 응답 코드를 정의합니다.

403\(금지됨\): 요청이 유효했지만 관리 또는 유사한 제한으로 인해 수행할 수 없습니다.

437\(할당 불일치\): 서버에서 할당이 필요한 요청을 받았지만 할당이 없거나, 할당이 필요하지 않은 요청을 받았지만 할당이 있습니다.

441\(잘못된 자격 증명\): \(비할당\) 요청의 자격 증명이 할당을 생성하는 데 사용된 자격 증명과 일치하지 않습니다.

442\(지원되지 않는 전송 프로토콜\): 할당 요청은 서버와 서버가 지원하지 않는 피어 간의 전송 프로토콜을 사용하도록 서버에 요청했습니다. 참고: 이는 5-튜플에 사용되는 전송 프로토콜을 참조하지 않습니다.

486\(할당 할당량 도달\): 현재 이 사용자 이름을 사용하는 할당을 더 이상 생성할 수 없습니다.

508\(용량 부족\): 일부 용량 제한에 도달하여 서버가 요청을 수행할 수 없습니다. 할당 응답에서 이는 서버에 해당 시점에 더 이상 사용 가능한 릴레이 전송 주소가 없거나, 요청된 속성이 없거나, 지정된 예약 토큰에 해당하는 주소를 사용할 수 없기 때문일 수 있습니다.

---
## **16.  Detailed Example**

이 섹션에서는 교환된 메시지의 내용을 자세히 보여주는 TURN 사용 예를 제공합니다. 이 예에서는 개요\(그림 1\)에 표시된 네트워크 다이어그램을 사용합니다.

각 메시지에 대해 메시지에 포함된 속성과 해당 값이 표시됩니다. 편의를 위해 값은 실제 옥텟을 표시하는 대신 사람이 읽을 수 있는 형식으로 표시됩니다. 예를 들어, "XOR-RELAYED-ADDRESS=192.0.2.15:9000"은 XOR-RELAYED-ADDRESS 속성이 주소 192.0.2.15 및 포트 9000에 포함되어 있음을 보여줍니다. 여기서 주소와 포트는 xor 앞에 표시됩니다. -ing이 완료되었습니다. 문자열과 같은 값이 있는 속성\(예: SOFTWARE="Example client, version 1.03" 및 NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"\)의 경우 가독성을 위해 속성 값이 따옴표로 표시되지만 실제 값에는 이러한 따옴표가 표시되지 않습니다.

```text
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |--- Allocate request -------------->|             |             |
    |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
    |    SOFTWARE="Example client, version 1.03"       |             |
    |    LIFETIME=3600 (1 hour)          |             |             |
    |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
    |    DONT-FRAGMENT                   |             |             |
    |                                    |             |             |
    |<-- Allocate error response --------|             |             |
    |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    ERROR-CODE=401 (Unauthorized)   |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |                                    |             |             |
    |--- Allocate request -------------->|             |             |
    |    Transaction-Id=0xC271E932AD7446A32C234492     |             |
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    LIFETIME=3600 (1 hour)          |             |             |
    |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
    |    DONT-FRAGMENT                   |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- Allocate success response ------|             |             |
    |    Transaction-Id=0xC271E932AD7446A32C234492     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    LIFETIME=1200 (20 minutes)      |             |             |
    |    XOR-RELAYED-ADDRESS=192.0.2.15:50000          |             |
    |    XOR-MAPPED-ADDRESS=192.0.2.1:7000             |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
```

클라이언트는 TURN 세션에 사용할 호스트 전송 주소를 선택하는 것부터 시작합니다. 이 예에서 클라이언트는 그림 1과 같이 10.1.1.2:49721을 선택했습니다. 그런 다음 클라이언트는 서버 전송 주소의 서버에 할당 요청을 보냅니다. 클라이언트는 이 트랜잭션에 대해 0xA56250D3F17ABE679422DE85의 96비트 트랜잭션 ID를 무작위로 선택합니다. 이는 고정 헤더의 트랜잭션 ID 필드에 인코딩됩니다. 클라이언트에는 클라이언트 소프트웨어에 대한 정보를 제공하는 SOFTWARE 속성이 포함되어 있습니다. 여기서 값은 "Example client, version 1.03"이며 이는 이것이 예제 클라이언트라는 버전 1.03임을 나타냅니다. 클라이언트는 할당의 수명이 기본값인 10분보다 길기를 원하기 때문에 LIFETIME 속성을 포함합니다. 이 속성의 값은 3600초이며 이는 1시간에 해당합니다. 클라이언트는 항상 할당 요청에 REQUESTED-TRANSPORT 속성을 포함해야 하며 이 사양에서 허용되는 유일한 값은 서버와 피어 간의 UDP 전송을 나타내는 17입니다. 클라이언트는 나중에 보내기 표시에서 DONT-FRAGMENT 속성을 사용하기를 원하기 때문에 DONT-FRAGMENT 속성도 포함합니다. 이 속성은 속성 헤더로만 구성되며 값 부분은 없습니다. 클라이언트가 최근에 서버와 상호작용한 적이 없다고 가정합니다. 따라서 클라이언트에는 USERNAME, REALM, NONCE 또는 MESSAGE-INTEGRITY 속성이 포함되어 있지 않습니다. 마지막으로 메시지의 속성 순서는 임의적이며\(MESSAGE-INTEGRITY 및 FINGERPRINT 속성 제외\) 클라이언트가 다른 순서를 사용할 수도 있습니다.

서버에서는 모든 요청을 인증해야 합니다. 따라서 서버가 초기 할당 요청을 수신하면 요청에 인증 속성이 포함되어 있지 않기 때문에 요청을 거부합니다. STUN \[RFC5389\]의 장기 자격 증명 메커니즘 절차에 따라 서버는 서버가 사용하는 인증 영역을 지정하는 REALM 속성인 401\(Unauthorized\) 값을 갖는 ERROR-CODE 속성을 포함합니다. 서버의 도메인 "example.com"\) 및 NONCE 속성의 nonce 값입니다. 서버에는 서버의 소프트웨어에 대한 정보를 제공하는 SOFTWARE 속성도 포함되어 있습니다.

클라이언트는 401 오류를 수신하면 이번에는 인증 속성을 포함하여 할당 요청을 다시 시도합니다. 클라이언트는 새 트랜잭션 ID를 선택한 다음 이전과 동일한 속성으로 새 Allocate 요청을 채웁니다. 클라이언트는 USERNAME 속성을 포함하고 서버에서 받은 영역 값을 사용하여 사용할 값을 결정하는 데 도움을 줍니다. 여기서 클라이언트는 "example.com" 영역에 대해 사용자 이름 "George"를 사용하도록 구성되었습니다. 클라이언트에는 401 오류 응답에서 복사된 REALM 및 NONCE 속성도 포함되어 있습니다. 마지막으로 클라이언트는 메시지의 마지막 속성으로 MESSAGE-INTEGRITY 속성을 포함합니다. 해당 속성의 값은 해시된 메시지입니다.

인증 코드 - HMAC-SHA1\(Secure Hash Algorithm 1\)이 메시지 내용을 해시합니다\(위에서 "..."로 표시됨\). 이 HMAC-SHA1 계산에는 비밀번호 값이 포함됩니다. 따라서 공격자는 비밀 암호를 알지 못하면 메시지 무결성 값을 계산할 수 없습니다.

서버는 인증된 할당 요청을 받으면 모든 것이 정상인지 확인한 다음 할당을 생성합니다. 서버는 할당 성공 응답으로 응답합니다. 서버에는 할당 수명을 제공하는 LIFETIME 속성이 포함되어 있습니다. 여기서 서버는 클라이언트가 요청한 1시간 수명을 단 20분으로 줄였습니다. 왜냐하면 이 특정 서버는 20분보다 긴 수명을 허용하지 않기 때문입니다. 서버에는 값이 할당의 중계된 전송 주소인 XOR-RELAYED-ADDRESS 속성이 포함되어 있습니다. 서버에는 값이 클라이언트의 서버 반사 주소인 XOR-MAPPED-ADDRESS 속성이 포함되어 있습니다. 이 값은 TURN에서 다른 방법으로 사용되지 않지만 편의를 위해 클라이언트에 반환됩니다. 서버에는 응답을 인증하고 무결성을 보장하기 위한 MESSAGE-INTEGRITY 속성이 포함되어 있습니다. 응답에는 USERNAME, REALM 및 NONCE 속성이 포함되어 있지 않습니다. 서버에는 SOFTWARE 속성도 포함되어 있습니다.

```text
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- CreatePermission request ------>|             |             |
    |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:0  |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- CreatePermission success resp.--|             |             |
    |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
```

그런 다음 클라이언트는 일부 애플리케이션 데이터를 보내기 위한 준비로 피어 A에 대한 권한을 생성합니다. 이는 CreatePermission 요청을 통해 수행됩니다. XOR-PEER-ADDRESS 속성에는 권한이 설정된 IP 주소\(피어 A의 IP 주소\)가 포함됩니다. CreatePermission 요청에 사용될 때 속성의 포트 번호는 무시되며 여기서는 0으로 설정되었습니다. 또한 클라이언트가 \(개인\) 호스트 주소가 아닌 피어 A의 서버 반사 IP 주소를 사용하는 방법에 유의하십시오. 클라이언트는 할당에 대한 이전 요청과 동일한 사용자 이름, 영역 및 nonce 값을 사용합니다. 그렇게 하는 것이 허용되기는 하지만 클라이언트는 이 요청에 SOFTWARE 속성을 포함하지 않기로 선택했습니다.

서버는 CreatePermission 요청을 수신하고 해당 권한을 생성한 다음 CreatePermission 성공 응답으로 응답합니다. 클라이언트와 마찬가지로 서버는 응답에 SOFTWARE 속성을 포함하지 않기로 선택합니다. 다시 한 번, 성공 응답에 MESSAGE-INTEGRITY 속성\(서버가 장기 자격 증명 메커니즘을 사용한다고 가정\)이 포함되지만 USERNAME, REALM 및 NONCE 속성은 포함되지 않는다는 점에 유의하세요.

```text
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- Send indication --------------->|             |             |
    |    Transaction-Id=0x1278E9ACA2711637EF7D3328     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |
    |    DONT-FRAGMENT                   |             |             |
    |    DATA=...                        |             |             |
    |                                    |-- UDP dgm ->|             |
    |                                    |  data=...   |             |
    |                                    |             |             |
    |                                    |<- UDP dgm --|             |
    |                                    |  data=...   |             |
    |<-- Data indication ----------------|             |             |
    |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |
    |    DATA=...                        |             |             |
```

이제 클라이언트는 보내기 표시를 사용하여 피어 A에 애플리케이션 데이터를 보냅니다. 피어 A의 서버 재귀 전송 주소는 XOR-PEER-ADDRESS 속성에 지정되고 애플리케이션 데이터\(여기서는 "..."으로 표시됨\)가 DATA 속성에 지정됩니다. 클라이언트는 애플리케이션 계층에서 경로 MTU 검색 형식을 수행하므로 서버가 피어에게 보내기 위해 UDP 데이터그램에 DF 비트를 설정해야 함을 지정합니다\(DONT-FRAGMENT 특성 포함\). STUN의 장기 자격 증명 메커니즘을 사용하여 표시를 인증할 수 없으므로 메시지에 MESSAGE-INTEGRITY 속성이 포함되지 않습니다. 데이터가 변경되거나 위조되지 않도록 하려는 애플리케이션은 애플리케이션 수준에서 데이터의 무결성을 보호해야 합니다.

보내기 표시를 수신하면 서버는 애플리케이션 데이터를 추출하여 이를 UDP 데이터그램으로 피어 A에 보냅니다. 이때 릴레이된 전송 주소는 데이터그램의 소스 전송 주소로, DF 비트는 요청된 대로 설정됩니다. 클라이언트가 이전에 피어 A의 서버 반사 IP 주소에 대한 권한을 설정하지 않았다면 서버는 대신 보내기 표시를 자동으로 폐기했을 것입니다.

그런 다음 피어 A는 애플리케이션 데이터가 포함된 자체 UDP 데이터그램으로 응답합니다. 데이터그램은 서버의 중계된 전송 주소로 전송됩니다. 이것이 도착하면 서버는 XOR-PEER-ADDRESS 속성에 UDP 데이터그램의 소스와 DATA 속성에 UDP 데이터그램의 데이터를 포함하는 데이터 표시를 생성합니다. 그런 다음 결과 데이터 표시가 클라이언트로 전송됩니다.

```text
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- ChannelBind request ----------->|             |             |
    |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
    |    CHANNEL-NUMBER=0x4000           |             |             |
    |    XOR-PEER-ADDRESS=192.0.2.210:49191            |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- ChannelBind success response ---|             |             |
    |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
```

이제 클라이언트는 CHANNEL-NUMBER 속성에 사용 가능한 채널 번호\(0x4000\)를 지정하고 XOR-PEER-ADDRESS 속성에 피어 B의 전송 주소를 지정하여 채널을 피어 B에 바인딩합니다. 이전과 마찬가지로 클라이언트는 메시지의 마지막 요청에서 사용자 이름, 영역 및 nonce를 재사용합니다.

요청을 받으면 서버는 채널 번호를 피어에 바인딩하고 피어 B의 IP 주소에 대한 권한을 설치한 다음 ChannelBind 성공 응답으로 응답합니다.

```text
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- ChannelData ------------------->|             |             |
    |    Channel-number=0x4000           |--- UDP datagram --------->|
    |    Data=...                        |    Data=...               |
    |                                    |             |             |
    |                                    |<-- UDP datagram ----------|
    |                                    |    Data=... |             |
    |<-- ChannelData --------------------|             |             |
    |    Channel-number=0x4000           |             |             |
    |    Data=...                        |             |             |
```

이제 클라이언트는 피어 B로 향하는 데이터와 함께 ChannelData 메시지를 서버에 보냅니다. ChannelData 메시지는 STUN 메시지가 아니므로 트랜잭션 ID가 없습니다. 대신 채널 번호, 데이터 및 데이터 길이의 세 가지 필드만 있습니다. 여기 채널 번호 필드가 있습니다.

0x4000\(클라이언트가 방금 피어 B에 바인딩한 채널\)입니다. 서버가 ChannelData 메시지를 받으면 채널이 현재 바인딩되어 있는지 확인한 다음 중계된 전송 주소를 소스 전송 주소 및 192.0.2.210으로 사용하여 UDP 데이터그램으로 피어 B로 데이터를 보냅니다. 49191\(ChannelBind 요청의 XOR-PEER-ADDRESS 속성 값\)을 대상 전송 주소로 사용합니다.

나중에 피어 B는 UDP 데이터그램을 중계된 전송 주소로 다시 보냅니다. 이로 인해 서버는 UDP 데이터그램의 데이터가 포함된 ChannelData 메시지를 클라이언트에 보냅니다. 서버는 UDP 데이터그램이 도착한 중계된 전송 주소로 인해 어느 클라이언트에게 ChannelData 메시지를 보낼지 알고 있으며 채널 0x4000이 192.0.2.210:49191에 바인딩된 채널이기 때문에 이를 사용하는 것을 알고 있습니다. 해당 주소에 바인딩된 채널 번호가 없다면 서버는 대신 데이터 표시를 사용했을 것입니다.

```text
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- Refresh request --------------->|             |             |
    |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- Refresh error response ---------|             |             |
    |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    ERROR-CODE=438 (Stale Nonce)    |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="npSw1Xw239bBwGYhjNWgz2yH47sxB2j"       |             |
    |                                    |             |             |
    |--- Refresh request --------------->|             |             |
    |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="npSw1Xw239bBwGYhjNWgz2yH47sxB2j"       |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- Refresh success response -------|             |             |
    |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    LIFETIME=600 (10 minutes)       |             |             |
```

20분 수명이 끝나기 전에 클라이언트는 할당을 새로 고칩니다. 이는 새로 고침 요청을 사용하여 수행됩니다. 이전과 마찬가지로 클라이언트는 요청에 최신 사용자 이름, 영역 및 nonce 값을 포함합니다. 클라이언트에는 항상 할당 및 새로 고침 메시지에 이 속성을 포함하는 권장 방식에 따라 SOFTWARE 속성도 포함됩니다. 서버는 새로 고침 요청을 받으면 nonce 값이 만료되었음을 확인하고 새로운 nonce 값이 주어지면 438\(Stale Nonce\) 오류로 응답합니다. 그런 다음 클라이언트는 이번에는 새 nonce 값을 사용하여 요청을 다시 시도합니다. 이 두 번째 시도가 승인되고 서버는 성공 응답으로 응답합니다. 클라이언트는 요청에 LIFETIME 속성을 포함하지 않았으므로 서버는 기본 수명인 10분에 대한 할당을 새로 고칩니다\(성공 응답의 LIFETIME 속성에서 볼 수 있음\).

---
## **17.  Security Considerations**

이 섹션에서는 TURN 배포에서 가능한 공격을 고려하고 프로토콜의 메커니즘이나 구현 시 권장되는 방식으로 공격을 완화하는 방법에 대해 논의합니다.

TURN에 대한 대부분의 공격은 요청 인증을 요구하는 서버에 의해 완화됩니다. 따라서 이 사양에는 인증 사용이 필요합니다. 필수 구현 메커니즘은 STUN의 장기 자격 증명 메커니즘입니다. 동일하거나 더 강력한 보안 속성을 가진 다른 인증 메커니즘을 사용할 수도 있습니다. 그러나 상호 운용 가능한 방식으로 호출할 수 있는지 확인하는 것이 중요합니다.

---
### **17.1.  Outsider Attacks**

외부 공격은 공격자가 시스템에 자격 증명이 없고 클라이언트나 서버에 표시되는 서비스를 방해하려고 시도하는 공격입니다.

---
#### **17.1.1.  Obtaining Unauthorized Allocations**

공격자는 여러 가지 악의적인 목적으로 TURN 서버에서 할당을 얻으려고 할 수 있습니다. TURN 서버는 클라이언트의 실제 IP 주소를 숨기는 동안 패킷을 보내고 받는 메커니즘을 제공합니다. 이로 인해 TURN 서버는 자신의 실제 신원을 가리기 위해 이를 사용하려는 공격자에게 매력적인 표적이 됩니다.

공격자는 비용을 지불하지 않고 단순히 TURN 서버의 서비스를 활용하기를 원할 수도 있습니다. TURN 서비스에는 공급자의 리소스가 필요하므로 사용에는 비용이 발생할 것으로 예상됩니다.

이러한 공격은 TURN 서버가 요청자의 신원을 확인하고 요청자가 할당을 얻을 수 있는지 여부를 확인할 수 있는 장기 자격 증명 메커니즘을 사용하여 방지됩니다.

---
#### **17.1.2.  Offline Dictionary Attacks**

TURN에서 사용하는 장기 자격 증명 메커니즘은 오프라인 사전 공격을 받기 쉽습니다. 클라이언트와 서버 사이의 메시지 교환을 도청할 수 있는 공격자는 여러 가지 후보 비밀번호를 시도하고 그 중 하나가 올바른지 확인하여 비밀번호를 알아낼 수 있습니다. 이 공격은 사전의 단어와 같이 암호의 엔트로피가 낮을 때 작동합니다. 이 공격은 엔트로피가 큰 강력한 비밀번호를 사용하여 완화할 수 있습니다. 더욱 강력한 완화가 필요한 상황에서는 클라이언트와 서버 간의 TLS 전송을 사용할 수 있습니다.

---
#### **17.1.3.  Faked Refreshes and Permissions**

공격자는 활성 할당을 삭제하고 클라이언트에 대한 서비스를 중단시키기 위해 즉시 만료되는 새로 고침 요청을 보내 활성 할당을 공격하려고 할 수 있습니다. 이는 새로 고침 인증을 통해 방지됩니다. 마찬가지로, 바람직하지 않은 대상에 대한 권한을 생성하기 위해 CreatePermission 요청을 보내려는 공격자는 인증을 통해 이를 수행할 수 없습니다. 그러한 공격의 동기는 섹션 17.2에 설명되어 있습니다.

---
#### **17.1.4.  Fake Data**

공격자는 데이터가 각각 피어나 클라이언트에서 온 것처럼 클라이언트나 피어에 데이터를 보내려고 할 수 있습니다. 이를 위해 공격자는 클라이언트에 가짜 데이터 표시 또는 ChannelData 메시지를 보내거나 TURN 서버에 가짜 보내기 표시 또는 ChannelData 메시지를 보낼 수 있습니다.

인디케이션과 ChannelData 메시지는 인증되지 않기 때문에 이 공격은 TURN에 의해 ​​방지되지 않습니다. 그러나 이 공격은 일반적으로 IP 기반 통신에 존재하며 TURN에 의해 ​​크게 악화되지는 않습니다. 호스트 A와 B 사이의 일반적인 TURN이 아닌 IP 세션을 생각해 보십시오. 공격자는 스푸핑된 IP 주소 B를 사용하여 A를 향해 패킷을 전송함으로써 패킷이 A에서 온 것처럼 B로 패킷을 보낼 수 있습니다. 이 공격을 수행하려면 공격자가 IP를 알아야 합니다. TURN을 사용하면 데이터 표시를 사용하여 클라이언트를 향해 패킷을 보내려는 공격자는 해당 IP 주소\(및 포트\), TURN 서버의 IP 주소 및 포트, TURN 서버의 IP 주소 및 포트를 알아야 합니다. 피어\(XOR-PEER-ADDRESS 속성에 포함\) 가짜 ChannelData 메시지를 클라이언트에 보내려면 공격자가 클라이언트의 IP 주소와 포트, IP 주소와 포트를 알아야 합니다.

TURN 서버의 채널 번호입니다. 이 특정 조합은 TURN이 아닌 경우보다 약간 더 추측 가능합니다.

이러한 공격은 애플리케이션 계층 인증 기술을 통해 더욱 적절하게 완화됩니다. 실시간 트래픽의 경우 SRTP \[RFC3711\]를 사용하면 이러한 공격을 방지할 수 있습니다.

어떤 상황에서는 TURN 서버가 클라이언트가 직접 보낼 수 없는 호스트에 보낼 수 있도록 네트워크에 위치할 수도 있습니다. 예를 들어, 서버가 방화벽 뒤에 위치하여 방화벽 외부의 패킷이 서버로 전달되지만 방화벽 뒤의 다른 호스트로는 전달되지 않는 경우 이런 일이 발생할 수 있습니다. 이러한 상황에서 공격자는 방화벽 뒤의 다른 호스트 중 하나의 전송 주소가 포함된 XOR-PEER-ADDRESS 속성과 함께 보내기 표시를 서버에 보낼 수 있습니다. 서버가 임의의 피어에 대한 트래픽 릴레이를 허용하는 경우 이는 공격자가 방화벽 뒤에 있는 임의의 호스트를 공격할 수 있는 방법을 제공합니다.

이 공격을 완화하기 위해 TURN에서는 클라이언트가 호스트에 데이터를 보내기 전에 호스트에 대한 권한을 설정하도록 요구합니다. 따라서 공격자는 인증된 요청을 생성할 수 없는 한 클라이언트가 이미 통신하고 있는 호스트만 공격할 수 있습니다. 또한 서버 관리자는 데이터를 중계할 IP 주소와 포트의 범위를 제한하도록 서버를 구성할 수 있습니다. 더욱 강력한 보안을 제공하기 위해 서버 관리자는 클라이언트와 서버 간의 모든 통신에 TLS를 사용하도록 클라이언트에 요구할 수 있습니다.

---
#### **17.1.5.  Impersonating a Server**

클라이언트가 TURN 서버에서 중계된 주소를 알게 되면 애플리케이션 프로토콜에서 해당 중계된 주소를 사용하여 트래픽을 수신합니다. 따라서 해당 트래픽을 가로채거나 리디렉션하려는 공격자는 TURN 서버를 가장하고 클라이언트에 위조된 중계 주소를 제공하려고 시도할 수 있습니다.

이 공격은 응답이 서버에서 왔는지 확인하는 것 외에도 응답에 대한 메시지 무결성을 제공하는 장기 자격 증명 메커니즘을 통해 방지됩니다. 또한 STUN 헤더의 트랜잭션 ID가 이를 방지하므로 공격자는 이전 서버 응답을 재생할 수 없습니다. Nonce 값을 자주 변경하면 재생 공격이 더욱 저지됩니다.

---
#### **17.1.6.  Eavesdropping Traffic**

TURN은 주로 인증 및 메시지 무결성에 관심이 있습니다. TURN 제어 메시지에는 특히 민감한 정보가 포함되지 않으므로 기밀성은 부차적인 관심사일 뿐입니다. 메시지의 기본 프로토콜 내용은 피어의 IP 주소입니다. TURN 연결의 도청자가 이를 학습하는 것을 방지하는 것이 중요한 경우 TURN은 TLS를 통해 실행될 수 있습니다.

TURN이 중계하는 애플리케이션 데이터의 기밀성은 애플리케이션 프로토콜 자체에서 가장 잘 제공됩니다. TLS를 통해 TURN을 실행하면 서버와 피어 간의 애플리케이션 데이터가 보호되지 않기 때문입니다. 애플리케이션 데이터의 기밀성이 중요한 경우 애플리케이션은 해당 데이터를 암호화하거나 다른 방식으로 보호해야 합니다. 예를 들어 실시간 미디어의 경우 SRTP를 사용하여 기밀성을 제공할 수 있습니다.

---
#### **17.1.7.  TURN Loop Attack**

공격자는 데이터 패킷이 두 TURN 서버 사이에서 무기한 루프되도록 시도할 수 있습니다. 공격은 다음과 같이 진행됩니다. 먼저, 공격자는 서버 B의 소스 주소를 사용하여 서버 A에 Allocate 요청을 보냅니다. 서버 A는 서버 B에 응답을 보내고, 공격이 성공하려면 공격자는 내용을 보거나 추측할 수 있는 능력이 있어야 합니다. 이를 통해 공격자는 할당된 중계 전송 주소를 알 수 있습니다. 그런 다음 공격자는 서버 A의 소스 주소를 사용하여 서버 B에 Allocate 요청을 보냅니다. 공격자는 응답 내용을 보거나 추측할 수 있어야 할당된 중계 전송 주소를 알아볼 수 있습니다. 동일한 스푸핑된 소스 주소 기술을 사용하여 공격자는 서버 A의 채널 번호를 서버 B의 중계된 전송 주소에 바인딩하고, 마찬가지로 서버 B의 동일한 채널 번호를 서버 A의 중계된 전송 주소에 바인딩합니다. 마지막으로 공격자는 ChannelData 메시지를 서버 A로 보냅니다.

결과는 서버 A의 중계된 전송 주소에서 서버 B의 중계된 전송 주소로, 그런 다음 서버 B의 전송 주소에서 서버 A의 전송 주소로, 그리고 다시 루프를 순환하는 데이터 패킷입니다.

이 공격은 다음과 같이 완화됩니다. 모든 요청을 인증하도록 요구하거나 릴레이된 전송 주소에 할당된 포트 번호를 무작위로 지정함으로써 서버는 공격자가 제3자\(이 경우 다른 서버\)로 전송된 응답을 가로채거나 보도록 강제합니다. 공격자는 요청을 인증하고 중계된 전송 주소를 알아낼 수 있습니다. 이 두 가지 측정값 중 하나가 없으면 공격자는 아무런 조치 없이 응답 내용을 추측할 수 있습니다.

이를 볼 필요가 있으므로 공격을 수행하기가 훨씬 쉬워집니다. 또한, 인증된 요청을 요구함으로써 서버는 공격자에게 서버에서 허용되는 자격 증명을 갖도록 강제하여 이를 외부 공격에서 내부 공격으로 바꾸고 공격을 시작한 클라이언트를 추적할 수 있게 합니다.

해당 사용자 이름이 소유한 할당으로 데이터를 중계하는 데 사용되는 대역폭에 사용자 이름별 제한을 적용하여 이 공격이 다른 할당에 미치는 영향을 제한함으로써 공격을 더욱 완화할 수 있습니다. 데이터 패킷을 중계할 때 TTL을 줄임으로써 더 많은 완화를 달성할 수 있습니다\(기본 OS에서 이를 허용하는 경우\).

---
### **17.2.  Firewall Considerations**

TURN의 주요 보안 고려 사항은 TURN이 클라이언트와 TURN 서버 사이에 배포된 방화벽이 제공하는 보호를 약화해서는 안 된다는 것입니다. TURN 서버는 공용 인터넷에 존재하는 경우가 많으며 클라이언트는 기업 방화벽이 있는 기업 네트워크 내부에 있는 경우가 많습니다. TURN 서버가 기업에 접근하기 위한 '백도어'를 제공하는 경우 TURN은 이러한 방화벽에 의해 차단됩니다.

따라서 TURN 서버는 많은 방화벽에서도 공통적으로 사용되는 속성인 주소 종속 필터링\[RFC4787\]을 구현하는 NAT 장치의 동작을 에뮬레이트합니다. NAT 또는 방화벽이 이 동작을 구현하면 내부 IP 주소 및 포트가 최근에 외부 IP 주소로 패킷을 보낸 경우 외부 IP 주소의 패킷은 내부 IP 주소 및 포트로만 전송될 수 있습니다. TURN 서버는 TURN 서버에서 이와 동일한 동작을 제공하는 권한 개념을 도입합니다. 공격자는 클라이언트가 먼저 공격자에게 연락을 시도하지 않는 한 TURN 서버에 패킷을 보낼 수 없으며 해당 패킷이 클라이언트를 향해 중계되기를 기대할 수 없습니다.

일부 방화벽에는 주소 종속 필터링보다 훨씬 더 제한적인 정책이 있다는 점에 유의하는 것이 중요합니다. 방화벽은 주소 및 포트 종속 필터링으로 구성하거나 인바운드 트래픽을 완전히 허용하지 않도록 구성할 수도 있습니다. 이러한 경우 클라이언트가 TURN 서버에 연결하도록 허용되면 클라이언트와의 통신은 방화벽이 일반적으로 허용하는 것보다 덜 제한적입니다.

---
#### **17.2.1.  Faked Permissions**

방화벽 및 NAT 장치에서는 네트워크 내부에서 외부 피어를 향한 패킷 통과를 통해 권한이 암시적으로 부여됩니다. 따라서 정의에 따라 방화벽이나 NAT 내부의 엔터티를 제외한 어떤 엔터티에서도 권한을 생성할 수 없습니다. TURN을 사용하면 이 제한이 더 이상 적용되지 않습니다. TURN 서버가 앉아 있기 때문에

방화벽 외부의 공격자는 이제 TURN 서버에 메시지를 보내고 자체적으로 권한을 생성하려고 시도할 수 있습니다.

이 공격은 권한을 생성하는 모든 메시지\(예: ChannelBind 및 CreatePermission\)가 인증되기 때문에 방지됩니다.

---
#### **17.2.2.  Blacklisted IP Addresses**

많은 방화벽은 방화벽 뒤의 클라이언트가 블랙리스트에 등록된 IP 주소 범위로 패킷을 보내거나 패킷을 수신하지 못하도록 차단하는 블랙리스트로 구성될 수 있습니다. 이는 방화벽에 들어오고 나가는 패킷의 소스 및 대상 주소를 각각 검사하여 수행됩니다.

TURN 서버는 릴레이할 피어의 주소 범위를 임의로 제한할 수 있으므로 이 기능은 TURN에도 있습니다.

---
#### **17.2.3.  Running Servers on Well-Known Ports**

방화벽 뒤에 있는 악의적인 클라이언트는 TURN 서버에 연결을 시도하고 서버를 실행하는 데 사용하는 할당을 얻으려고 시도할 수 있습니다. 예를 들어 클라이언트는 DNS 서버나 FTP 서버를 실행하려고 시도할 수 있습니다.

TURN에서는 불가능합니다. TURN 서버는 클라이언트가 권한을 설치하지 않은 피어로부터의 트래픽을 절대 수락하지 않습니다. 따라서 피어는 서비스를 얻기 위해 할당된 포트에 연결할 수 없습니다.

---
### **17.3.  Insider Attacks**

내부자 공격에서 클라이언트는 합법적인 자격 증명을 가지고 있지만 해당 자격 증명과 관련된 신뢰 관계를 무시합니다. 이러한 공격은 암호화 수단으로 예방할 수 없지만 프로토콜 설계 시 고려해야 합니다.

---
#### **17.3.1.  DoS against TURN Server**

다른 클라이언트에 대한 서비스를 중단하려는 클라이언트는 할당을 얻은 다음 서버를 휩쓸고 다른 합법적인 클라이언트에 서비스를 제공하지 못하도록 트래픽을 넘치게 할 수 있습니다. 이는 서버가 특정 사용자 이름에 대해 릴레이할 대역폭의 양을 제한하도록 권장함으로써 완화됩니다. 이렇게 하면 클라이언트가 대량의 트래픽을 보내는 것을 막을 수는 없지만 서버가 초과하는 트래픽을 즉시 삭제할 수 있습니다.

각 할당은 TURN 서버의 IP 주소에 있는 포트 번호를 사용하므로 서버의 할당 수는 유한합니다. 안

공격자는 대량의 할당을 요청하여 이를 모두 소비하려고 시도할 수 있습니다. 이는 서버가 특정 사용자 이름에 대해 한 번에 활성화되는 할당 수에 제한을 두는 권장 사항에 의해 방지됩니다.

---
#### **17.3.2.  Anonymous Relaying of Malicious Traffic**

TURN 서버는 어느 정도 익명성을 제공합니다. 클라이언트는 자신의 IP 주소를 공개하지 않고도 피어에게 데이터를 보낼 수 있습니다. 따라서 TURN 서버는 공격자가 탐지에 대한 두려움 없이 대상에 대해 공격을 시작할 수 있는 매력적인 수단이 될 수 있습니다. 실제로 클라이언트가 여러 TURN 서버를 함께 연결하여 대상이 패킷을 수신하기 전에 원하는 수의 릴레이를 사용할 수 있습니다.

이 공격을 걱정하는 관리자는 클라이언트의 실제 소스 IP와 포트는 물론 클라이언트가 설치하는 모든 권한까지 캡처하는 로그를 유지 관리할 수 있습니다. 이를 통해 공격이 TURN 서버를 통해 전달되고 있음이 발견된 경우 포렌식 추적을 통해 원본 소스를 확인할 수 있습니다.

---
#### **17.3.3.  Manipulating Other Allocations**

공격자는 소스 주소 스푸핑을 통해 TURN 서버의 다른 사용자로부터 오는 것처럼 보이는 새로 고침 요청 또는 CreatePermission 요청을 전송하여 TURN 서버의 다른 사용자에게 서비스를 방해하려고 시도할 수 있습니다. TURN은 CreatePermission, Refresh 및 ChannelBind 메시지에 사용된 자격 증명이 초기 할당을 생성하는 데 사용된 자격 증명과 일치하도록 요구하여 이를 방지합니다. 따라서 공격자의 가짜 요청은 거부됩니다.

---
### **17.4.  Other Considerations**

할당 요청을 통해 학습된 릴레이 주소는 전송 또는 터널 모드에서 IPsec 인증 헤더\(AH\) \[RFC4302\]와 함께 제대로 작동하지 않습니다. 그러나 터널 모드 IPsec ESP\(Encapsulated Security Payload\) \[RFC4303\]는 계속 작동해야 합니다.

---
## **18.  IANA Considerations**

TURN은 STUN \[RFC5389\]의 확장이므로 본 사양에 정의된 메서드, 속성 및 오류 코드는 STUN의 새로운 메서드, 속성 및 오류 코드입니다. IANA는 STUN 프로토콜 요소의 IANA 레지스트리에 이러한 새로운 프로토콜 요소를 추가했습니다.

이 사양에 정의된 새로운 STUN 방법에 대한 코드 포인트는 섹션 13에 나열되어 있습니다.

본 사양에 정의된 새로운 STUN 속성에 대한 코드 포인트는 섹션 14에 나열되어 있습니다.

이 사양에 정의된 새로운 STUN 오류 코드에 대한 코드 포인트는 섹션 15에 나열되어 있습니다.

IANA는 UDP 또는 TCP를 통한 TURN에 대해 "turn"이라는 SRV 서비스 이름을 할당하고 TLS를 통한 TURN에 대해 "turns"라는 서비스 이름을 할당했습니다.

IANA는 처음에 다음과 같이 채워지는 TURN 채널 번호에 대한 레지스트리를 만들었습니다.

- 0x0000 \~ 0x3FFF: 예약되어 있으며 STUN 헤더와 충돌하므로 사용할 수 없습니다.

- 0x4000 \~ 0x7FFF: TURN 구현은 이 범위의 채널 번호를 자유롭게 사용할 수 있습니다.

- 0x8000\~0xFFFF: 할당되지 않음.

이 레지스트리에 대한 모든 변경은 IETF 표준 조치를 통해 이루어져야 합니다.

---
## **19.  IAB Considerations**

IAB는 클라이언트가 협력적 프로토콜 반영 메커니즘을 통해 NAT 반대편의 다른 영역에서 자신의 주소를 확인하려고 시도하는 일반적인 프로세스인 "일방적 자체 주소 수정"\(UNSAF\) 문제를 연구했습니다. \[RFC3424 \]. TURN 확장은 이러한 유형의 기능을 수행하는 프로토콜의 예입니다. IAB는 이 목적을 위해 개발된 모든 프로토콜에 특정 고려 사항을 문서화하도록 의무화했습니다. TURN에 대한 이러한 고려 사항과 응답은 이 섹션에 문서화되어 있습니다.

고려 사항 1: UNSAF 제안으로 해결해야 할 구체적이고 제한된 범위의 문제에 대한 정확한 정의. 다른 문제를 해결하기 위해 단기적인 수정을 일반화해서는 안 됩니다. 이러한 일반화는 가정된 단기 수정에 대한 장기적인 의존과 사용으로 이어집니다. 즉, 이를 "단기"라고 부르는 것이 더 이상 정확하지 않음을 의미합니다.

응답: TURN은 릴레이\(= TURN 서버\)와 해당 클라이언트 간의 통신을 위한 프로토콜입니다. 이 프로토콜을 사용하면 NAT 뒤에 있는 클라이언트가 릴레이에서 공용 IP 주소를 얻고 사용할 수 있습니다. 클라이언트의 편의를 위해 TURN을 사용하면 클라이언트가 서버 반사 전송 주소를 결정할 수도 있습니다.

고려 사항 2: 출구 전략/전환 계획에 대한 설명. 더 나은 단기 수정은 적절한 기술이 배포됨에 따라 자연스럽게 사용이 점점 줄어들게 되는 수정입니다.

응답: 더 이상 NAT가 없으면 TURN이 더 이상 필요하지 않습니다. 불행하게도 이 문서의 발행일 현재 NAT가 조만간 사라질 가능성은 더 이상 없어 보입니다. 그러나 Endpoint-Independent Mapping \[RFC4787\]의 매핑 속성을 가진 NAT 수가 증가함에 따라 TURN의 필요성도 감소합니다.

고려사항 3: 시스템을 더욱 "취약하게" 만들 수 있는 특정 문제에 대한 논의. 예를 들어, 여러 네트워크 계층에서 데이터를 사용하는 접근 방식은 더 많은 종속성을 생성하고 디버깅 문제를 증가시키며 전환을 더 어렵게 만듭니다.

응답: TURN은 클라이언트와 서버 간의 NAT 바인딩이 할당 수명 동안 변경되지 않고 유지되어야 한다는 점에서 "취약"합니다. 이는 일반적으로 Keep-Alive를 사용하여 수행됩니다. 이것이 완료되지 않으면 클라이언트는 할당을 잃게 되며 더 이상 동료와 데이터를 교환할 수 없습니다.

고려 사항 4: 장기적이고 건전한 기술 솔루션에 대한 요구 사항을 식별합니다. 올바른 장기적 솔루션을 찾는 과정에 기여합니다.

응답: NAT가 \[RFC4787\]에 문서화된 NAT UDP 동작에 대한 권장 사항을 구현하면 TURN의 필요성이 줄어들 것입니다. 또한 애플리케이션은 ICE \[RFC5245\]를 사용하여 동료와 통신할 것을 강력히 권장합니다. ICE는 TURN을 사용하지만 최후의 수단으로만 사용하며 통제된 방식으로 사용합니다.

고려 사항 5: 기존에 배포된 NAT 및 경험 보고서에 대해 언급된 실제 문제의 영향에 대한 논의.

응답: 현재 배포된 일부 NAT는 엔드포인트 독립 매핑 이외의 매핑 동작을 나타냅니다. 이러한 NAT는 ICE와 같은 프로토콜이 해당 NAT에서 서버 반사 전송 주소를 사용하는 것을 어렵거나 불가능하게 만들기 때문에 작업하기가 어렵습니다. 이러한 NAT 뒤에 있는 클라이언트는 "UDP 홀 펀칭" 기술\[RFC5128\]이 작동하지 않기 때문에 종종 TURN과 같은 릴레이 프로토콜을 사용해야 합니다.

---
## **20.  Acknowledgements**

저자는 이 문서에 대해 많은 의견을 주신 BEHAVE 작업 그룹의 다양한 참가자에게 감사의 말씀을 전하고 싶습니다. 마크 프티-위게닌, 레미 데니스-쿠르몽, 제이슨 피슐, 데릭 맥도날드, 스콧 고딘, 컬렌 제닝스, 라스 에거트, 매그너스 웨스터런드, 베니

Prijono와 Eric Rescorla는 특히 도움이 되었습니다. Eric은 채널 할당 메커니즘을 제안했고, Cullen은 EVEN-PORT 메커니즘의 이전 버전을 제안했으며, Marc는 문제를 찾기 위해 예비 버전을 구현하는 데 많은 시간을 보냈습니다. Christian Huitema는 이 문서의 초기 기여자였으며 처음 몇 버전의 공동 저자였습니다. 마지막으로, 저자들은 본문 작성에 기여하고 작업이 중단된 후 이 문서의 진행을 다시 시작하는 데 큰 도움을 준 Dan Wing에게 감사의 말씀을 전하고 싶습니다.

---
## **21.  References**
---
### **21.1.  Normative References**

\[RFC5389\] Rosenberg, J., Mahy, R., Matthews, P. 및 D. Wing, "STUN\(NAT용 세션 탐색 유틸리티\)", RFC 5389, 2008년 10월.

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타 내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC2474\] Nichols, K., Blake, S., Baker, F. 및 D. Black, "IPv4 및 IPv6 헤더의 차별화된 서비스 필드\(DS 필드\) 정의", RFC 2474, 1998년 12월.

\[RFC3168\] Ramakrishnan, K., Floyd, S. 및 D. Black, "IP에 명시적 혼잡 알림\(ECN\) 추가", RFC 3168, 2001년 9월.

\[RFC1122\] Braden, R., "인터넷 호스트에 대한 요구 사항 - 통신 계층", STD 3, RFC 1122, 1989년 10월.

---
### **21.2.  Informative References**

\[RFC1191\] Mogul, J. 및 S. Deering, "경로 MTU 검색", RFC 1191, 1990년 11월.

```text
   [RFC0791]            Postel, J., "Internet Protocol", STD 5, RFC 791,
                        September 1981.
```

\[RFC1918\] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G. 및 E. Lear, "개인 인터넷에 대한 주소 할당", BCP 5, RFC 1918, 1996년 2월.

\[RFC3424\] Daigle, L. 및 IAB, "네트워크 주소 변환 전반에 걸친 UNSAF\(단방향 자체 주소 수정\)에 대한 IAB 고려 사항", RFC 3424, 2002년 11월.

\[RFC4787\] Audet, F. 및 C. Jennings, "유니캐스트 UDP에 대한 NAT\(네트워크 주소 변환\) 동작 요구 사항", BCP 127, RFC 4787, 2007년 1월.

\[RFC5245\] Rosenberg, J., "ICE\(대화형 연결 설정\): 제안/응답 프로토콜을 위한 NAT\(Network Address Translator\) 통과를 위한 프로토콜", RFC 5245, 2010년 4월.

\[TURN-TCP\] Perreault, S. 및 J. Rosenberg, "TCP 할당을 위한 NAT\(TURN\) 확장 주변의 릴레이를 사용한 탐색", 진행 중인 작업, 2010년 3월.

\[TURN-IPv6\] Perreault, S., Camarillo, G. 및 O. Novo, "IPv6용 NAT\(TURN\) 확장 주변 릴레이를 사용한 탐색", 진행 중인 작업, 2010년 3월.

\[TSVWG-PORT\] Larsen, M. 및 F. Gont, "포트 무작위화", 진행 중인 작업, 2010년 4월.

\[RFC5128\] Srisuresh, P., Ford, B. 및 D. Kegel, "NAT\(네트워크 주소 변환기\)를 통한 P2P\(피어 투 피어\) 통신 상태", RFC 5128, 2008년 3월.

\[RFC1928\] Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D. 및 L. Jones, "SOCKS 프로토콜 버전 5", RFC 1928, 1996년 3월.

\[RFC3550\] Schulzrinne, H., Casner, S., Frederick, R. 및 V. Jacobson, "RTP: 실시간 애플리케이션을 위한 전송 프로토콜", STD 64, RFC 3550, 2003년 7월.

\[RFC3711\] Baugher, M., McGrew, D., Naslund, M., Carrara, E. 및 K. Norrman, "SRTP\(보안 실시간 전송 프로토콜\)", RFC 3711, 2004년 3월.

```text
   [RFC4302]            Kent, S., "IP Authentication Header", RFC 4302,
                        December 2005.

   [RFC4303]            Kent, S., "IP Encapsulating Security Payload
                        (ESP)", RFC 4303, December 2005.
```

\[RFC4821\] Mathis, M. 및 J. Heffner, "패킷화 계층 경로 MTU 검색", RFC 4821, 2007년 3월.

\[RFC3261\] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M. 및 E. Schooler, "SIP: 세션 시작 프로토콜" , RFC 3261, 2002년 6월.

\[MMUSIC-ICE-NONSIP\] Rosenberg, J., "사용 지침

- 비 SIP\(Session Initiation Protocol\) 프로토콜에 의한 ICE\(대화형 연결 설정\)", 진행 중인 작업, 2008년 7월.

\[RFC4086\] Eastlake, D., Schiller, J. 및 S. Crocker, "보안을 위한 무작위성 요구 사항", BCP 106, RFC 4086, 2005년 6월.

\[Frag-Harmful\] Kent와 Mogul, "해로운 것으로 간주되는 조각화". 진행 SIGCOMM '87, vol. 1987년 10월 17일 5호

```text
   [Port-Numbers]       "IANA Port Numbers Registry",
                        <http://www.iana.org>.

   [Protocol-Numbers]   "IANA Protocol Numbers Registry", 2005,
                        <http://www.iana.org>.
```

---
# **Authors' Addresses**

```text
   Rohan Mahy
   Unaffiliated

   EMail: rohan@ekabal.com

   Philip Matthews
   Alcatel-Lucent
   600 March Road
   Ottawa, Ontario
   Canada

   EMail: philip_matthews@magma.ca

   Jonathan Rosenberg
   jdrosen.net
   Monmouth, NJ
   USA

   EMail: jdrosen@jdrosen.net
   URI:   http://www.jdrosen.net
```


```text
﻿

Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 9111                                         Adobe
STD: 98                                               M. Nottingham, Ed.
Obsoletes: 7234                                                   Fastly
Category: Standards Track                                J. Reschke, Ed.
ISSN: 2070-1721                                               greenbytes
                                                               June 2022

                              HTTP Caching
```

---
# **Abstract**

HTTP\(Hypertext Transfer Protocol\)는 분산, 협업, 하이퍼텍스트 정보 시스템을 위한 상태 비저장 애플리케이션 수준 프로토콜입니다. 이 문서는 캐시 동작을 제어하거나 캐시 가능한 응답 메시지를 나타내는 HTTP 캐시 및 관련 헤더 필드를 정의합니다.

이 문서는 RFC 7234를 폐기합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9111에서 확인할 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2022 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1.  Introduction
     1.1.  Requirements Notation
     1.2.  Syntax Notation
       1.2.1.  Imported Rules
       1.2.2.  Delta Seconds
   2.  Overview of Cache Operation
   3.  Storing Responses in Caches
     3.1.  Storing Header and Trailer Fields
     3.2.  Updating Stored Header Fields
     3.3.  Storing Incomplete Responses
     3.4.  Combining Partial Content
     3.5.  Storing Responses to Authenticated Requests
   4.  Constructing Responses from Caches
     4.1.  Calculating Cache Keys with the Vary Header Field
     4.2.  Freshness
       4.2.1.  Calculating Freshness Lifetime
       4.2.2.  Calculating Heuristic Freshness
       4.2.3.  Calculating Age
       4.2.4.  Serving Stale Responses
     4.3.  Validation
       4.3.1.  Sending a Validation Request
       4.3.2.  Handling a Received Validation Request
       4.3.3.  Handling a Validation Response
       4.3.4.  Freshening Stored Responses upon Validation
       4.3.5.  Freshening Responses with HEAD
     4.4.  Invalidating Stored Responses
   5.  Field Definitions
     5.1.  Age
     5.2.  Cache-Control
       5.2.1.  Request Directives
         5.2.1.1.  max-age
         5.2.1.2.  max-stale
         5.2.1.3.  min-fresh
         5.2.1.4.  no-cache
         5.2.1.5.  no-store
         5.2.1.6.  no-transform
         5.2.1.7.  only-if-cached
       5.2.2.  Response Directives
         5.2.2.1.  max-age
         5.2.2.2.  must-revalidate
         5.2.2.3.  must-understand
         5.2.2.4.  no-cache
         5.2.2.5.  no-store
         5.2.2.6.  no-transform
         5.2.2.7.  private
         5.2.2.8.  proxy-revalidate
         5.2.2.9.  public
         5.2.2.10. s-maxage
       5.2.3.  Extension Directives
       5.2.4.  Cache Directive Registry
     5.3.  Expires
     5.4.  Pragma
     5.5.  Warning
   6.  Relationship to Applications and Other Caches
   7.  Security Considerations
     7.1.  Cache Poisoning
     7.2.  Timing Attacks
     7.3.  Caching of Sensitive Information
   8.  IANA Considerations
     8.1.  Field Name Registration
     8.2.  Cache Directive Registration
     8.3.  Warn Code Registry
   9.  References
     9.1.  Normative References
     9.2.  Informative References
   Appendix A.  Collected ABNF
   Appendix B.  Changes from RFC 7234
   Acknowledgements
   Index
   Authors' Addresses
```

---
## **1.  Introduction**

HTTP\(Hypertext Transfer Protocol\)는 네트워크 기반 하이퍼텍스트 정보 시스템과의 유연한 상호 작용을 위해 확장 가능한 의미 체계와 자체 설명 메시지를 사용하는 상태 비저장 애플리케이션 수준 요청/응답 프로토콜입니다. 이는 일반적으로 응답 캐시를 사용하여 성능을 향상시킬 수 있는 분산 정보 시스템에 사용됩니다. 이 문서는 응답 메시지 캐싱 및 재사용과 관련된 HTTP의 측면을 정의합니다.

HTTP "캐시"는 응답 메시지의 로컬 저장소이자 메시지 저장, 검색 및 삭제를 제어하는 ​​하위 시스템입니다. 캐시는 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄이기 위해 캐시 가능한 응답을 저장합니다. 모든 클라이언트나 서버는 캐시를 사용할 수 있지만 터널 역할을 할 때는 그렇지 않습니다\(\[HTTP\]의 섹션 3.7\).\(MAY\)

"공유 캐시"는 둘 이상의 사용자가 재사용할 수 있도록 응답을 저장하는 캐시입니다. 공유 캐시는 일반적으로\(항상은 아니지만\) 중개자의 일부로 배포됩니다. 이와 대조적으로 "개인 캐시"는 단일 사용자 전용입니다. 종종 사용자 에이전트의 구성 요소로 배포됩니다.

HTTP 캐싱의 목표는 현재 요청을 충족하기 위해 이전 응답 메시지를 재사용하여 성능을 크게 향상시키는 것입니다. 캐시는 "검증" 없이 재사용할 수 있는 경우 섹션 4.2에 정의된 대로 저장된 응답을 "신선한" 것으로 간주합니다\(원본 서버를 통해 캐시된 응답이 이 요청에 대해 유효한지 확인\). 따라서 새로운 응답은 캐시가 재사용할 때마다 대기 시간과 네트워크 오버헤드를 모두 줄일 수 있습니다. 캐시된 응답이 최신이 아닌 경우 유효성 검사를 통해 새로 고치거나\(섹션 4.3\) 원본을 사용할 수 없는 경우\(섹션 4.2.4\) 여전히 재사용이 가능할 수 있습니다.

이 문서는 RFC 7234를 폐기했으며 변경 사항은 부록 B에 요약되어 있습니다.

---
### **1.1.  Requirements Notation**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

\[HTTP\]의 섹션 2는 적합성 기준을 정의하고 오류 처리에 관한 고려 사항을 포함합니다.

---
### **1.2.  Syntax Notation**

이 사양은 \[RFC7405\]에 정의된 문자열의 대소문자 구분 표기법으로 확장된 \[RFC5234\]의 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다.

또한 \[HTTP\]의 섹션 5.6.1에 정의된 목록 확장을 사용하여 "#" 연산자를 사용하여 쉼표로 구분된 목록을 간결하게 정의할 수 있습니다\("\*" 연산자가 반복을 나타내는 방식과 유사\). 부록 A는 표준 ABNF 표기법으로 확장된 모든 목록 연산자와 함께 수집된 문법을 보여줍니다.

---
#### **1.2.1.  Imported Rules**

다음 핵심 규칙은 \[RFC5234\], 부록 B.1: DIGIT\(십진수 0-9\)에 정의된 대로 참조로 포함됩니다.

\[HTTP\]는 다음 규칙을 정의합니다.

```text
     HTTP-date     = <HTTP-date, see [HTTP], Section 5.6.7>
     OWS           = <OWS, see [HTTP], Section 5.6.3>
     field-name    = <field-name, see [HTTP], Section 5.1>
     quoted-string = <quoted-string, see [HTTP], Section 5.6.4>
     token         = <token, see [HTTP], Section 5.6.2>
```

---
#### **1.2.2.  Delta Seconds**

델타-초 규칙은 시간\(초\)을 나타내는 음수가 아닌 정수를 지정합니다.

```text
     delta-seconds  = 1*DIGIT
```

델타초 값을 구문 분석하고 이를 이진 형식으로 변환하는 수신자는 음수가 아닌 정수 범위의 최소 31비트의 산술 유형을 사용해야 합니다. 캐시가 표현할 수 있는 가장 큰 정수보다 큰 델타-초 값을 수신하거나 후속 계산이 오버플로되는 경우 캐시는 값을 2147483648\(2^31\) 또는 편리하게 표현할 수 있는 가장 큰 양의 정수로 간주해야 합니다. .\(MUST\)

- | \*참고:\* 역사적인 이유로 2147483648 값이 여기에 있습니다. | 무한대\(68년 이상\)를 나타내며 |일 필요는 없습니다. 바이너리 형식으로 저장됩니다. 구현은 |로 생성할 수 있습니다. 오버플로가 발생하면 계산이 | 직접 수행할 수 없는 산술 유형으로 수행 | 그 숫자를 나타냅니다. 여기서 중요한 것은 | 오버플로가 감지되고 |에서 음수 값으로 처리되지 않습니다. 나중에 계산.

---
## **2.  Overview of Cache Operation**

적절한 캐시 작업은 HTTP 전송의 의미를 보존하는 동시에 캐시에 이미 보관된 정보의 전송을 줄입니다. HTTP의 일반적인 용어와 핵심 개념은 \[HTTP\]의 섹션 3을 참조하세요.

캐싱은 HTTP의 전적으로 선택적인 기능이지만 캐시된 응답을 재사용하는 것이 바람직하며 요구 사항이나 로컬 구성이 이를 방지하지 않는 경우 이러한 재사용이 기본 동작이라고 가정할 수 있습니다. 따라서 HTTP 캐시 요구 사항은 캐시가 항상 특정 응답을 저장하고 재사용하도록 요구하기보다는 캐시가 재사용할 수 없는 응답을 저장하거나 저장된 응답을 부적절하게 재사용하는 것을 방지하는 데 중점을 두고 있습니다.\(MAY\)

"캐시 키"는 캐시가 응답을 선택하는 데 사용하는 정보이며, 최소한 저장된 응답을 검색하는 데 사용되는 요청 메서드와 대상 URI로 구성됩니다. 메서드는 후속 요청을 충족하기 위해 해당 응답을 사용할 수 있는 상황을 결정합니다. 그러나 오늘날 일반적으로 사용되는 많은 HTTP 캐시는 GET 응답만 캐시하므로 URI를 캐시 키로만 사용합니다.

캐시는 콘텐츠 협상이 적용되는 요청 대상에 대한 여러 응답을 저장할 수 있습니다. 캐시는 섹션 4.1에 따라 Vary 응답 헤더 필드의 정보를 사용하여 원래 요청의 헤더 필드 중 일부를 캐시 키에 통합함으로써 이러한 응답을 구별합니다.

캐시는 캐시 키에 추가 자료를 통합할 수 있습니다. 예를 들어, 사용자 에이전트 캐시에는 참조 사이트의 ID가 포함될 수 있으므로 일부 개인 정보 보호 위험을 피하기 위해 캐시를 "이중 키로 설정"할 수 있습니다\(섹션 7.2 참조\).

가장 일반적으로 캐시는 검색 요청의 성공적인 결과, 즉 대상 리소스의 표현을 포함하는 GET 요청에 대한 200\(OK\) 응답을 저장합니다\(\[HTTP\]의 섹션 9.3.1\). 그러나 메서드 정의가 이러한 캐싱을 허용하고 정의된 경우 리디렉션, 부정적인 결과\(예: 404\(찾을 수 없음\)\), 불완전한 결과\(예: 206\(부분 콘텐츠\)\) 및 GET 이외의 메서드에 대한 응답을 저장할 수도 있습니다. 캐시 키로 사용하기에 적합한 것.

캐시가 원본 서버에 접속할 수 없거나 요청에 대한 전달 경로를 찾을 수 없으면 "연결이 끊어집니다". 연결이 끊어진 캐시는 일부 상황에서 오래된 응답을 제공할 수 있습니다\(섹션 4.2.4\).

---
## **3.  Storing Responses in Caches**

캐시는 다음과 같은 경우를 제외하고는 요청에 대한 응답을 저장해서는 안 됩니다.\(MUST NOT\)

```text
   *  the request method is understood by the cache;

   *  the response status code is final (see Section 15 of [HTTP]);

   *  if the response status code is 206 or 304, or the must-understand
      cache directive (see Section 5.2.2.3) is present: the cache
      understands the response status code;

   *  the no-store cache directive is not present in the response (see
      Section 5.2.2.5);

   *  if the cache is shared: the private response directive is either
      not present or allows a shared cache to store a modified response;
      see Section 5.2.2.7);
```

\* 캐시가 공유되는 경우: Authorization 헤더 필드가 요청에 존재하지 않거나\(\[HTTP\]의 섹션 11.6.2 참조\) 공유 캐싱을 명시적으로 허용하는 응답 지시문이 존재합니다\(섹션 3.5 참조\). 그리고

\* 응답에는 다음 중 하나 이상이 포함됩니다.

```text
      -  a public response directive (see Section 5.2.2.9);

      -  a private response directive, if the cache is not shared (see
         Section 5.2.2.7);

      -  an Expires header field (see Section 5.3);

      -  a max-age response directive (see Section 5.2.2.1);

      -  if the cache is shared: an s-maxage response directive (see
         Section 5.2.2.10);
```

- 캐시를 허용하는 캐시 확장\(참조:

- 섹션 5.2.3\); 또는

- - 경험적으로 캐시할 수 있는 것으로 정의된 상태 코드입니다\(섹션 4.2.2 참조\).

캐시 확장은 나열된 요구 사항을 재정의할 수 있습니다. 섹션 5.2.3을 참조하세요.

이러한 맥락에서 캐시는 요청 메서드나 응답 상태 코드를 인식하고 지정된 모든 캐싱 관련 동작을 구현하는 경우 이를 "이해"한 것입니다.

정상적인 작동에서 일부 캐시는 캐시 유효성 검사기나 명시적인 만료 시간이 없는 응답을 저장하지 않습니다. 이러한 응답은 일반적으로 저장하는 데 유용하지 않기 때문입니다. 그러나 캐시는 그러한 응답을 저장하는 것이 금지되지 않습니다.

---
### **3.1.  Storing Header and Trailer Fields**

캐시는 응답을 저장할 때 인식할 수 없는 항목을 포함하여 수신된 모든 응답 헤더 필드를 포함해야 합니다. 이렇게 하면 새 HTTP 헤더 필드가 성공적으로 배포될 수 있습니다. 다만, 다음의 경우는 예외로 합니다.\(MUST\)

\* 연결 헤더 필드와 이름이 나열된 필드는 메시지를 전달하기 전에 \[HTTP\]의 섹션 7.6.1에서 제거해야 합니다. 이는 저장 전에 구현함으로써 구현될 수 있습니다.\(MAY\)

\* 마찬가지로 일부 필드의 의미 체계에서는 메시지를 전달하기 전에 해당 필드를 제거해야 하며 이는 저장 전에 그렇게 하여 구현할 수 있습니다. 몇 가지 예를 보려면 \[HTTP\]의 섹션 7.6.1을 참조하세요.\(MAY\)

\* no-cache\(Section 5.2.2.4\) 및 private\(Section 5.2.2.7\) 캐시 지시문에는 각각 모든 캐시 및 공유 캐시에 의한 헤더 필드 저장을 방지하는 인수가 있을 수 있습니다.

\* 캐시가 요청을 전달할 때 캐시가 사용하는 프록시에 특정한 헤더 필드는 캐시가 캐시 키에 프록시의 ID를 통합하지 않는 한 저장되어서는 안 됩니다. 사실상 이는 Proxy-Authenticate\(\[HTTP\]의 섹션 11.7.1\), Proxy-Authentication-Info\(\[HTTP\]의 섹션 11.7.3\) 및 Proxy-Authorization\(\[HTTP\]의 섹션 11.7.2\)으로 제한됩니다. .\(MUST NOT\)

캐시는 헤더 필드와 별도로 트레일러 필드를 저장하거나 삭제할 수 있습니다. 캐시는 트레일러 필드와 헤더 필드를 결합해서는 안 됩니다.\(MAY, MUST NOT\)

---
### **3.2.  Updating Stored Header Fields**

여러 상황에서 다른\(일반적으로 최신\) 응답에서 저장된 응답의 헤더 필드를 업데이트하려면 캐시가 필요합니다. 예를 들어 섹션 3.4, 4.3.4 및 4.3.5를 참조하십시오.

그렇게 할 때 캐시는 제공된 응답의 각 헤더 필드를 저장된 응답에 추가해야 하며 다음 예외를 제외하고 이미 존재하는 필드 값을 대체해야 합니다.\(MUST\)

\* 섹션 3.1의 저장에서 제외된 헤더 필드,

\* 캐시의 저장된 응답이 의존하는 헤더 필드는 아래 설명과 같습니다.

\* 아래 설명과 같이 수신자가 자동으로 처리하고 제거하는 헤더 필드

\* Content-Length 헤더 필드.

경우에 따라 캐시\(특히 사용자 에이전트\)는 응답 자체가 아닌 수신된 응답 처리 결과를 저장하며 해당 처리에 영향을 미치는 헤더 필드를 업데이트하면 일관되지 않은 동작 및 보안 문제가 발생할 수 있습니다. 이 상황의 캐시는 예외적으로 저장된 응답을 업데이트할 때 이러한 헤더 필드를 생략할 수 있지만, 저장된 응답의 무결성을 보장하는 데 필요한 필드에 대한 생략을 제한해야 합니다\(SHOULD\).\(SHOULD\)

예를 들어, 브라우저는 응답을 수신하는 동안 응답의 콘텐츠 코딩을 디코딩하여 저장된 데이터와 응답의 원래 메타데이터 간의 연결을 끊을 수 있습니다. 저장된 메타데이터를 다른 Content-Encoding 헤더 필드로 업데이트하는 것은 문제가 될 수 있습니다. 마찬가지로 브라우저는 응답으로 수신된 콘텐츠 대신 구문 분석 후 HTML 트리를 저장할 수 있습니다. 이 경우 구문 분석에서 수행된 형식에 대한 가정이 이제 유효하지 않기 때문에 Content-Type 헤더 필드를 업데이트할 수 없습니다.

또한 Content-Range 헤더 필드와 같은 일부 필드는 HTTP 구현에 의해 자동으로 처리되고 제거됩니다. 구현에서는 처리가 실제로 발생하지 않는 경우에도 업데이트에서 이러한 헤더 필드를 자동으로 생략할 수 있습니다.\(MAY\)

Content-\* 접두사는 업데이트에서 헤더 필드가 생략되었다는 신호가 아닙니다. 이는 HTTP가 아닌 MIME 헤더 필드에 대한 규칙입니다.

---
### **3.3.  Storing Incomplete Responses**

요청 방법이 GET이고 응답 상태 코드가 200\(OK\)이고 전체 응답 헤더 섹션이 수신된 경우 저장된 응답이 제공된다면 캐시는 완료되지 않은 응답\(\[HTTP\]의 섹션 6.1\)을 저장할 수 있습니다. 불완전한 것으로 기록됩니다. 마찬가지로 206\(부분 콘텐츠\) 응답은 불완전한 200\(OK\) 응답인 것처럼 저장될 수 있습니다. 그러나 캐시가 Range 및 Content-Range 헤더 필드를 지원하지 않거나 해당 필드에 사용된 범위 단위를 이해하지 못하는 경우 캐시는 불완전하거나 부분 콘텐츠 응답을 저장해서는 안 됩니다.\(MAY, MAY, MUST NOT\)

캐시는 섹션 3.4에 정의된 대로 후속 범위 요청\(\[HTTP\]의 섹션 14.2\)을 만들고 성공적인 응답을 저장된 응답과 결합하여 저장된 불완전한 응답을 완료할 수 있습니다. 캐시는 응답이 완료되었거나 요청이 부분적이고 불완전한 응답 내의 범위를 완전히 지정하지 않는 한 요청에 응답하기 위해 불완전한 응답을 사용해서는 안 됩니다. 캐시는 206\(부분 콘텐츠\) 상태 코드를 사용하여 명시적으로 표시하지 않고 클라이언트에 부분 응답을 보내서는 안 됩니다.\(MAY, MUST NOT, MUST NOT\)

---
### **3.4.  Combining Partial Content**

연결이 조기에 종료되거나 요청이 하나 이상의 범위 지정자를 사용한 경우\(\[HTTP\]의 섹션 14.2\) 응답은 부분 표현만 전송할 수 있습니다. 그러한 전송을 여러 번 한 후에 캐시는 동일한 표현의 여러 범위를 수신했을 수 있습니다. 캐시는 이러한 범위를 단일 저장된 응답으로 결합할 수 있으며, 모두 동일한 강력한 유효성 검사기를 공유하고 캐시가 \[HTTP\] 섹션 15.3.7.3의 클라이언트 요구 사항을 준수하는 경우 이후 요청을 충족하기 위해 해당 응답을 재사용할 수 있습니다.\(MAY\)

새로운 응답을 하나 이상의 저장된 응답과 결합할 때 캐시는 섹션 3.2에 따라 새 응답에 제공된 헤더 필드를 사용하여 저장된 응답 헤더 필드를 업데이트해야 합니다.\(MUST\)

---
### **3.5.  Storing Responses to Authenticated Requests**

공유 캐시는 응답에 응답 지시어\(섹션 5.2.2\)가 있는 Cache-Control 필드가 포함되어 있지 않은 한 후속 요청을 만족시키기 위해 Authorization 헤더 필드\(\[HTTP\]의 섹션 11.6.2\)가 있는 요청에 대해 캐시된 응답을 사용해서는 안 됩니다\(MUST NOT\). \) 공유 캐시에 저장할 수 있으며 캐시는 해당 응답에 대한 해당 지시문의 요구 사항을 준수합니다.\(MUST NOT\)

이 사양에서 다음 응답 지시문은 must-revalidate\(섹션 5.2.2.2\), public\(섹션 5.2.2.9\) 및 s-maxage\(섹션 5.2.2.10\)와 같은 효과를 갖습니다.

---
## **4.  Constructing Responses from Caches**

요청이 제시될 때 캐시는 다음을 제외하고는 저장된 응답을 재사용해서는 안 됩니다.\(MUST NOT\)

\* 제시된 대상 URI\(\[HTTP\]의 섹션 7.1\)와 저장된 응답의 일치, 그리고

\* 저장된 응답과 관련된 요청 메소드를 사용하면 제시된 요청에 사용할 수 있습니다.

\* 저장된 응답\(있는 경우\)에 의해 지정된 요청 헤더 필드가 제시된 것과 일치합니다\(섹션 4.1 참조\).

\* 성공적으로 검증되지 않는 한\(섹션 4.3\) 저장된 응답에는 no-cache 지시문\(섹션 5.2.2.4\)이 포함되어 있지 않습니다.

\* 저장된 응답은 다음 중 하나입니다.

```text
      -  fresh (see Section 4.2), or
```

- - 오래된 서비스 제공이 허용됨\(섹션 4.2.4 참조\), 또는

```text
      -  successfully validated (see Section 4.3).
```

캐시 확장은 나열된 요구 사항을 재정의할 수 있습니다. 섹션 5.2.3을 참조하세요.

검증 없이 요청을 충족하기 위해 저장된 응답이 사용되는 경우 캐시는 Age 헤더 필드\(5.1절\)를 생성해야 하며, 응답에 있는 모든 항목을 저장된 응답의 current\_age와 동일한 값으로 바꿔야 합니다. 섹션 4.2.3을 참조하세요.\(MUST\)

캐시는 안전하지 않은 메서드\(\[HTTP\]의 섹션 9.2.1\)를 사용하여 요청을 통해 원본 서버에 써야 합니다. 즉, 캐시는 요청을 전달하고 해당 응답을 수신하기 전에 그러한 요청에 대한 응답을 생성하는 것이 허용되지 않습니다.\(MUST\)

또한 안전하지 않은 요청은 이미 저장된 응답을 무효화할 수 있습니다. 섹션 4.4를 참조하세요.

캐시는 문제의 요청에 대해 해당 응답을 재사용할 수 있는 경우 여러 요청을 충족하기 위해 저장되거나 저장 가능한 응답을 사용할 수 있습니다. 이를 통해 캐시는 "요청을 축소"하거나 캐시 누락 시 여러 수신 요청을 단일 전달 요청으로 결합하여 원본 서버와 네트워크의 부하를 줄일 수 있습니다. 그러나 캐시가 축소된 요청 중 일부 또는 전부에 대해 반환된 응답을 사용할 수 없는 경우 이를 충족하기 위해 요청을 전달해야 하며 잠재적으로 추가 대기 시간이 발생할 수 있습니다.

둘 이상의 적절한 응답이 저장되면 캐시는 가장 최근 응답을 사용해야 합니다\(Date 헤더 필드에 의해 결정됨\). 또한 사용할 응답을 명확하게 하기 위해 "Cache-Control: max-age=0" 또는 "Cache-Control: no-cache"를 사용하여 요청을 전달할 수도 있습니다.\(MUST\)

시계가 없는 캐시\(\[HTTP\]의 섹션 5.6.7\)는 사용할 때마다 저장된 응답을 재검증해야 합니다.\(MUST\)

---
### **4.1.  Calculating Cache Keys with the Vary Header Field**

캐시가 저장된 응답으로 충족될 수 있는 요청을 수신하고 저장된 응답에 Vary 헤더 필드\(\[HTTP\]의 섹션 12.5.5\)가 포함된 경우, 캐시는 제시된 모든 요청 헤더가 그렇지 않은 한 재검증 없이 저장된 응답을 사용해서는 안 됩니다. 해당 Vary 필드 값으로 지정된 필드는 원래 요청\(즉, 캐시된 응답을 저장하게 만든 요청\)의 해당 필드와 일치합니다.\(MUST NOT\)

두 요청의 헤더 필드는 다음 중 하나를 적용하여 첫 번째 요청의 헤더 필드가 두 번째 요청의 헤더 필드로 변환될 수 있는 경우에만 일치하도록 정의됩니다.

\* 헤더 필드의 구문에서 허용되는 경우 공백 추가 또는 제거

```text
   *  combining multiple header field lines with the same field name
      (see Section 5.2 of [HTTP])

   *  normalizing both header field values in a way that is known to
      have identical semantics, according to the header field's
      specification (e.g., reordering field values when order is not
      significant; case-normalization, where values are defined to be
      case-insensitive)
```

\(일어날 수 있는 정규화 이후\) 요청에 헤더 필드가 없는 경우 헤더 필드도 거기에 없는 경우에만 다른 요청과 일치할 수 있습니다.

멤버 "\*"가 포함된 Vary 헤더 필드 값이 있는 저장된 응답은 항상 일치하지 않습니다.

저장된 응답이 여러 개 일치하는 경우 캐시는 사용할 응답을 선택해야 합니다. 지정된 요청 헤더 필드에 선호도 순위를 매기는 알려진 메커니즘\(예: Accept의 qvalues ​​및 유사한 요청 헤더 필드\)이 있는 경우 해당 메커니즘을 사용하여 선호하는 응답을 선택할 수 있습니다. 그러한 메커니즘을 사용할 수 없거나 똑같이 선호하는 응답으로 이어지는 경우 섹션 4에 따라 가장 최근 응답\(날짜 헤더 필드에 의해 결정됨\)이 선택됩니다.\(MAY\)

일부 리소스는 실수로 기본 응답\(예: 요청이 어떤 기본 설정도 표현하지 않을 때 전송되는 헤더\)에서 Vary 헤더 필드를 생략하여 더 선호하는 응답이 있을 때에도 해당 리소스에 대한 후속 요청에 대해 이를 선택하는 결과를 낳습니다. 캐시에 대상 URI에 대한 여러 개의 저장된 응답이 있고 하나 이상이 Vary 헤더 필드를 생략한 경우 캐시는 유효한 Vary 필드 값이 있는 가장 최근의 저장된 응답\(섹션 4.2.3 참조\)을 선택해야 합니다.\(SHOULD\)

저장된 응답이 일치하지 않으면 캐시는 제시된 요청을 충족할 수 없습니다. 일반적으로 요청은 캐시에 이미 저장된 응답을 설명하기 위해 사전 조건이 추가되어 원본 서버로 전달됩니다\(섹션 4.3\).

---
### **4.2.  Freshness**

"신선한" 반응은 연령이 아직 신선도 수명을 초과하지 않은 반응입니다. 반대로, "오래된" 응답은 존재하는 응답입니다.

응답의 "최신 수명"은 원본 서버에 의한 응답 생성과 만료 시간 사이의 시간입니다. "명시적 만료 시간"은 원서버가 추가 검증 없이 저장된 응답을 더 이상 캐시에서 사용할 수 없도록 의도하는 시간인 반면, "경험적 만료 시간"은 명시적 만료 시간을 사용할 수 없을 때 캐시에 의해 할당됩니다. .

응답의 "기간"은 원본 서버에서 생성되었거나 성공적으로 검증된 이후 경과한 시간입니다.

응답이 신선하면 원본 서버에 접속하지 않고도 후속 요청을 충족하는 데 사용할 수 있으므로 효율성이 향상됩니다.

신선도를 결정하는 주요 메커니즘은 원서버가 Expires 헤더 필드\(Section 5.3\) 또는 max-age 응답 지시문\(Section 5.2.2.1\)을 사용하여 향후 명시적인 만료 시간을 제공하는 것입니다. 일반적으로 원서버는 만료 시간에 도달하기 전에 표현이 의미상 중요한 방식으로 변경될 가능성이 없다는 믿음으로 응답에 미래의 명시적 만료 시간을 할당합니다.

원서버가 캐시가 모든 요청을 검증하도록 하려는 경우, 응답이 이미 오래되었음을 나타내기 위해 과거의 명시적인 만료 시간을 할당할 수 있습니다. 호환 캐시는 일반적으로 후속 요청에 재사용하기 전에 오래된 캐시 응답을 검증합니다\(섹션 4.2.4 참조\).

원본 서버가 항상 명시적인 만료 시간을 제공하는 것은 아니기 때문에 캐시는 특정 상황에서 만료 시간을 결정하기 위해 경험적 방법을 사용할 수도 있습니다\(섹션 4.2.2 참조\).

응답이 최신인지 확인하는 계산은 다음과 같습니다.

```text
      response_is_fresh = (freshness_lifetime > current_age)
```

freshness\_lifetime은 섹션 4.2.1에 정의되어 있습니다. current\_age는 섹션 4.2.3에 정의되어 있습니다.

클라이언트는 max-age 또는 min-fresh 요청 지시문\(섹션 5.2.1\)을 보내 해당 응답에 대한 신선도 계산에 대한 제한을 제안할 수 있습니다. 그러나 캐시는 이를 존중할 필요가 없습니다.

최신성을 계산할 때 날짜 구문 분석에서 흔히 발생하는 문제를 방지하려면 다음을 수행하세요.

\* 모든 날짜 형식은 대소문자를 구분하도록 지정되어 있지만 캐시 수신자는 필드 값과 대소문자를 구분하지 않고 일치해야 합니다.\(SHOULD\)

\* 캐시 수신자의 내부 시간 구현이 HTTP 날짜 값보다 해상도가 낮은 경우 수신자는 구문 분석된 만료 날짜를 수신된 값과 같거나 이전인 가장 가까운 시간으로 내부적으로 나타내야 합니다.\(MUST\)

\* 캐시 수신자는 현지 시간대가 연령 또는 만료 시간의 계산이나 비교에 영향을 미치도록 허용해서는 안 됩니다.\(MUST NOT\)

\* 캐시 수신자는 만료 계산에 유효하지 않은 "GMT" 이외의 영역 약어가 있는 날짜를 고려해야 합니다.\(SHOULD\)

신선도는 캐시 작업에만 적용됩니다. 사용자 에이전트가 디스플레이를 새로 고치거나 리소스를 다시 로드하도록 강제하는 데 사용할 수 없습니다. 캐시와 히스토리 메커니즘의 차이점에 대한 설명은 섹션 6을 참조하세요.

---
#### **4.2.1.  Calculating Freshness Lifetime**

캐시는 다음 규칙을 평가하고 첫 번째 일치 항목을 사용하여 응답의 신선도 수명\(freshness\_lifetime으로 표시됨\)을 계산할 수 있습니다.

\* 캐시가 공유되고 s-maxage 응답 지시문\(섹션 5.2.2.10\)이 있는 경우 해당 값을 사용하거나

\* max-age 응답 지시문\(섹션 5.2.2.1\)이 있는 경우 해당 값을 사용하거나

\* Expires 응답 헤더 필드\(Section 5.3\)가 있는 경우 해당 값에서 Date 응답 헤더 필드의 값을 뺀 값을 사용합니다\(\[HTTP\]의 섹션 6.6.1에 따라 메시지가 없으면 메시지를 수신한 시간 사용\). \), 또는

\* 그렇지 않으면 응답에 명시적인 만료 시간이 없습니다. 경험적 신선도 수명이 적용될 수 있습니다. 섹션 4.2.2를 참조하세요.

이 계산은 가능할 때마다 원본 서버에서 제공하는 시계 정보를 사용하여 시계 왜곡을 줄이기 위한 것입니다.

주어진 지시문에 대해 둘 이상의 값이 있는 경우\(예: 두 개의 Expires 헤더 필드 행 또는 여러 Cache-Control: max-age 지시문\) 첫 번째 발생을 사용하거나 응답이 오래된 것으로 간주되어야 합니다. 지시어가 충돌하는 경우\(예: max-age 및 no-cache가 모두 존재하는 경우\) 가장 제한적인 지시어를 준수해야 합니다. 캐시는 유효하지 않은 최신 정보\(예: 정수가 아닌 콘텐츠가 있는 max-age 지시문\)가 있는 응답을 오래된 것으로 간주하는 것이 좋습니다.

---
#### **4.2.2.  Calculating Heuristic Freshness**

원서버가 항상 명시적인 만료 시간을 제공하는 것은 아니기 때문에 캐시는 명시적인 시간이 지정되지 않은 경우 타당한 만료 시간을 추정하기 위해 다른 필드 값\(예: Last-Modified 시간\)을 사용하는 알고리즘을 사용하여 경험적 만료 시간을 할당할 수 있습니다. 이 사양은 특정 알고리즘을 제공하지 않지만 결과에 최악의 제약 조건을 부과합니다.\(MAY\)

캐시는 저장된 응답에 명시적인 만료 시간이 존재할 때 신선도를 결정하기 위해 경험적 방법을 사용해서는 안 됩니다. 섹션 3의 요구 사항으로 인해 휴리스틱은 상태 코드가 "경험적으로 캐시 가능"\(예: \[HTTP\]의 섹션 15.1 참조\)으로 정의된 명시적인 신선도가 없는 응답과 다음과 같이 표시된 명시적인 신선도가 없는 응답에만 사용할 수 있습니다. 명시적으로 캐시 가능합니다\(예: 공개 응답 지시문 사용\).\(MUST NOT\)

이전 사양에서는 경험적으로 캐시 가능한 응답 상태 코드를 "기본적으로 캐시 가능"이라고 불렀습니다.

```text
   If the response has a Last-Modified header field (Section 8.8.2 of
   [HTTP]), caches are encouraged to use a heuristic expiration value
   that is no more than some fraction of the interval since that time.
   A typical setting of this fraction might be 10%.
```

| \*참고:\* HTTP 사양의 이전 버전

- | \(\[RFC2616\]의 섹션 13.9\) 캐시 계산이 금지되었습니다 | 쿼리 구성 요소\(예: "?"를 포함하는 |\)가 있는 URI에 대한 경험적 신선도. 실제로 이것은 널리 사용되지 않았습니다 | 구현되었습니다. 따라서 원본 서버는 | 명시적 지시문\(예: Cache-Control: no-cache\) | 캐싱을 방지하고 싶습니다.

---
#### **4.2.3.  Calculating Age**

Age 헤더 필드는 캐시에서 얻은 응답 메시지의 추정 수명을 전달하는 데 사용됩니다. Age 필드 값은 원본 서버가 응답을 생성하거나 검증한 이후의 캐시 추정 시간\(초\)입니다. 따라서 Age 값은 응답이 원본 서버의 경로를 따라 각 캐시에 상주한 시간과 응답이 네트워크 경로를 따라 전송된 시간의 합입니다.

연령 계산에는 다음 데이터가 사용됩니다.

"연령\_값"

- "age\_value"라는 용어는 Age 헤더 필드\(Section 5.1\)의 값을 산술 연산에 적합한 형식으로 나타냅니다. 또는 사용할 수 없는 경우 0입니다.

"날짜\_값"

- "date\_value"라는 용어는 Date 헤더 필드의 값을 산술 연산에 적합한 형태로 나타냅니다. Date 헤더 필드의 정의와 그것이 없는 응답에 관한 요구 사항은 \[HTTP\]의 섹션 6.6.1을 참조하세요.

"지금"

- "지금"이라는 용어는 이 구현 시계의 현재 값을 의미합니다\(\[HTTP\]의 섹션 5.6.7\).

"요청\_시간"

- 저장된 응답을 가져온 요청 당시의 시계 값입니다.

"응답 시간"

- 응답을 받은 당시의 시계 값입니다.

응답의 수명은 완전히 독립적인 두 가지 방법으로 계산할 수 있습니다.

1. "apparent\_age": response\_time에서 date\_value를 뺀 값\(구현의 시계가 원본 서버의 시계와 합리적으로 잘 동기화된 경우\). 결과가 음수이면 결과는 0으로 대체됩니다.

2. 응답 경로를 따라 모든 캐시가 HTTP/1.1 이상을 구현하는 경우 "수정된\_나이\_값". 캐시는 응답이 수신된 시간이 아니라 요청이 시작된 시간을 기준으로 이 값을 해석해야 합니다.\(MUST\)

```text
     apparent_age = max(0, response_time - date_value);

     response_delay = response_time - request_time;
     corrected_age_value = age_value + response_delay;
```

Corrected\_age\_value는 Corrected\_initial\_age로 사용될 수 있습니다. Age를 올바르게 삽입하지 못할 수 있는 아주 오래된 캐시 구현이 존재하는 상황에서는 Corrected\_initial\_age를 다음과 같이 더 보수적으로 계산할 수 있습니다.\(MAY\)

```text
     corrected_initial_age = max(apparent_age, corrected_age_value);
```

저장된 응답의 current\_age는 저장된 응답이 원본 서버에 의해 마지막으로 검증된 이후의 시간\(초\)을 Corrected\_initial\_age에 추가하여 계산할 수 있습니다.

```text
     resident_time = now - response_time;
     current_age = corrected_initial_age + resident_time;
```

---
#### **4.2.4.  Serving Stale Responses**

"오래된" 응답은 명시적인 만료 정보가 있거나 경험적 만료 계산이 허용되지만 섹션 4.2의 계산에 따르면 최신이 아닌 응답입니다.

캐시는 명시적인 프로토콜 내 지시문\(예: no-cache 응답 지시문, must-revalidate 응답 지시문 또는 해당 s-maxage 또는 프록시 재검증 응답 지시문\)에 의해 금지된 경우 오래된 응답을 생성해서는 안 됩니다. 섹션 5.2.2 참조\).\(MUST NOT\)

캐시는 연결이 끊어지거나 클라이언트 또는 원서버에서 명시적으로 허용하지 않는 한 오래된 응답을 생성해서는 안 됩니다\(예: 섹션 5.2.1의 max-stale 요청 지시어, \[RFC5861\]에 정의된 것과 같은 확장 지시어\) 또는 대역 외 계약에 따른 구성\).\(MUST NOT\)

---
### **4.3.  Validation**

캐시에 요청된 URI에 대해 하나 이상의 저장된 응답이 있지만 그 중 어떤 것도 제공할 수 없는 경우\(예: 최신이 아니거나 하나를 선택할 수 없기 때문에 섹션 4.1 참조\) 조건부 요청 메커니즘\(섹션 13 참조\)을 사용할 수 있습니다. 다음 인바운드 서버에 사용할 유효한 저장된 응답을 선택하거나, 프로세스에서 저장된 메타데이터를 업데이트하거나, 저장된 응답을 새 응답으로 바꿀 수 있는 기회를 제공하기 위해 전달된 요청의 \[HTTP\]\). 이 프로세스를 저장된 응답의 "검증" 또는 "재검증"이라고 합니다.

---
#### **4.3.1.  Sending a Validation Request**

유효성 검사를 위한 조건부 요청을 생성할 때 캐시는 충족하려는 요청으로 시작하거나, 요청을 독립적으로 시작하는 경우 메서드, 대상 URI 및 요청 헤더를 복사하여 저장된 응답을 사용하여 요청을 합성합니다. Vary 헤더 필드\(섹션 4.1\)로 식별되는 필드입니다.

그런 다음 하나 이상의 전제 조건 헤더 필드로 해당 요청을 업데이트합니다. 여기에는 동일한 URI를 가진 저장된 응답에서 가져온 유효성 검사기 메타데이터가 포함됩니다. 일반적으로 여기에는 동일한 캐시 키를 가진 저장된 응답만 포함되지만, 캐시는 보내는 요청 헤더 필드로 선택할 수 없는 응답의 유효성을 검사할 수 있습니다\(섹션 4.1 참조\).

그런 다음 수신자는 전제 조건 헤더 필드를 비교하여 저장된 응답이 리소스의 현재 표현과 동일한지 여부를 결정합니다.

그러한 검증기 중 하나는 응답 검증을 위한 If-Modified-Since 헤더 필드 또는 If-Unmodified-Since 헤더 필드에서 사용될 수 있는 Last-Modified 헤더 필드\(\[HTTP\]의 섹션 8.8.2\)에 제공된 타임스탬프입니다. 또는 표현 선택을 위한 If-Range 헤더 필드\(즉, 클라이언트는 해당 타임스탬프를 사용하여 이전에 얻은 표현을 구체적으로 참조합니다\).

또 다른 유효성 검사기는 ETag 필드에 제공된 엔터티 태그입니다\(\[HTTP\]의 섹션 8.8.3\). 하나 이상의 저장된 응답을 나타내는 하나 이상의 엔터티 태그는 응답 검증을 위해 If-None-Match 헤더 필드에서 사용될 수 있고, 표현 선택을 위해 If-Match 또는 If-Range 헤더 필드에서 사용될 수 있습니다\(즉, 클라이언트는 나열된 엔터티 태그를 사용하여 이전에 얻은 하나 이상의 표현을 구체적으로 참조\).

유효성 검사를 위한 조건부 요청을 생성할 때 캐시는 다음을 수행합니다.

\* 검증 중인 저장된 응답에 엔터티 태그가 제공된 경우 관련 엔터티 태그\(If-Match, If-None-Match 또는 If-Range 사용\)를 보내야 합니다.\(MUST\)

\* 요청이 하위 범위에 대한 것이 아니고 저장된 단일 응답이 검증되고 해당 응답에 Last-Modified 값이 포함되어 있는 경우 Last-Modified 값\(If-Modified-Since 사용\)을 보내야 합니다.\(SHOULD\)

\* 요청이 하위 범위에 대한 것이고 저장된 단일 응답이 검증되고 해당 응답에 Last-Modified 값만 포함된 경우\(If-Unmodified-Since 또는 If-Range 사용\) Last-Modified 값을 보낼 수 있습니다\(엔티티가 아님\). 꼬리표\).\(MAY\)

대부분의 경우 두 유효성 검사기는 엔터티 태그가 확실히 우수하더라도 엔터티 태그 전제 조건을 이해하지 못하는 오래된 중개자가 적절하게 응답할 수 있도록 캐시 유효성 검사 요청에서 생성됩니다.

---
#### **4.3.2.  Handling a Received Validation Request**

요청 체인의 각 클라이언트는 자체 캐시를 가질 수 있으므로 중개자의 캐시가 다른\(아웃바운드\) 캐시로부터 조건부 요청을 받는 것이 일반적입니다. 마찬가지로 일부 사용자 에이전트는 조건부 요청을 사용하여 최근 수정된 표현으로 데이터 전송을 제한하거나 부분적으로 검색된 표현의 전송을 완료합니다.

섹션 4에 따라 캐시가 저장된 200\(OK\) 또는 206\(부분 콘텐츠\) 응답을 재사용하여 충족될 수 있는 요청을 수신하는 경우 캐시는 해당 요청과 관련하여 해당 요청에서 수신된 적용 가능한 조건부 헤더 필드 전제 조건을 평가해야 합니다. 저장된 응답 내에 포함된 유효성 검사기.\(SHOULD\)

캐시는 원서버에만 적용되거나, 캐시된 응답으로 만족할 수 없는 의미를 가진 요청에서 발생하거나, 저장된 응답이 없는 대상 리소스가 있는 요청에서 발생하는 조건부 헤더 필드를 평가해서는 안 됩니다. 이러한 전제 조건은 다른 \(인바운드\) 서버를 위한 것일 수 있습니다.\(MUST NOT\)

캐시에 의한 조건부 요청의 적절한 평가는 수신된 전제조건 헤더 필드와 해당 우선순위에 따라 달라집니다. 요약하면 If-Match 및 If-Unmodified-Since 조건부 헤더 필드는 캐시에 적용되지 않으며 If-None-Match가 If-Modified-Since보다 우선합니다. 전제 조건 우선 순위에 대한 전체 사양은 \[HTTP\]의 섹션 13.2.2를 참조하세요.

If-None-Match 헤더 필드\(\[HTTP\]의 섹션 13.1.2\)를 포함하는 요청은 클라이언트가 캐시에 의해 선택된 저장된 응답과 비교하여 자체 저장된 응답 중 하나 이상을 검증하기를 원함을 나타냅니다\(섹션에 따라\). 4\).

If-None-Match 헤더 필드가 존재하지 않는 경우 If-Modified-Since 헤더 필드\(\[HTTP\]의 섹션 13.1.3\)를 포함하는 요청은 클라이언트가 다음을 통해 자체 저장된 응답 중 하나 이상을 검증하기를 원함을 나타냅니다. 수정일.

요청에 If-Modified-Since 헤더 필드가 포함되어 있고 Last-Modified 헤더 필드가 저장된 응답에 없는 경우 캐시는 저장된 응답의 날짜 필드 값\(또는 날짜 필드가 없는 경우 응답이 발생한 시간\)을 사용해야 합니다. 저장된 응답이 수신됨\) 조건을 평가합니다.\(SHOULD\)

\[HTTP\]의 섹션 14.2에 정의된 대로 범위 요청에 대한 부분 응답을 구현하는 캐시는 캐시가 선택한 응답과 관련하여 수신된 If-Range 헤더 필드\(\[HTTP\]의 섹션 13.1.5\)도 평가해야 합니다.

캐시가 엔터티 태그의 If-None-Match 목록을 포함하는 요청에 대해 자체 저장된 응답을 재검증하기 위해 요청을 전달하기로 결정하면 캐시는 수신된 목록을 자체 저장된 응답 세트의 엔터티 태그 목록과 결합할 수 있습니다. \(신선하거나 오래됨\) 두 목록의 합집합을 전달된 요청의 대체 If-None-Match 헤더 필드 값으로 보냅니다. 저장된 응답에 부분 콘텐츠만 포함된 경우 캐시는 해당 부분 저장된 응답으로 완전히 충족되는 범위에 대한 요청이 아닌 한 통합체에 엔터티 태그를 포함해서는 안 됩니다. 전달된 요청에 대한 응답이 304\(수정되지 않음\)이고 클라이언트 목록에 없는 엔터티 태그가 있는 ETag 필드 값이 있는 경우 캐시는 해당 저장된 응답을 재사용하여 클라이언트에 대해 200\(OK\) 응답을 생성해야 합니다. , 304 응답 메타데이터\(섹션 4.3.4\)에 의해 업데이트되었습니다.\(MAY, MUST NOT, MUST\)

---
#### **4.3.3.  Handling a Validation Response**

조건부 요청에 대한 응답의 캐시 처리는 상태 코드에 따라 다릅니다.

\* 304\(수정되지 않음\) 응답 상태 코드는 저장된 응답을 업데이트하고 재사용할 수 있음을 나타냅니다. 섹션 4.3.4를 참조하세요.

\* 전체 응답\(즉, 콘텐츠가 포함된 응답\)은 조건부 요청에 지정된 저장된 응답 중 어느 것도 적합하지 않음을 나타냅니다. 대신, 캐시는 요청을 만족시키기 위해 전체 응답을 사용해야 합니다. 캐시는 제약 조건에 따라 전체 응답을 저장할 수 있습니다\(섹션 3 참조\).\(MUST, MAY\)

\* 그러나 캐시가 응답의 유효성을 검사하는 동안 5xx\(서버 오류\) 응답을 받으면 이 응답을 요청 클라이언트에 전달하거나 서버가 응답하지 못한 것처럼 작동할 수 있습니다. 후자의 경우 캐시는 제한 사항에 따라 이전에 저장된 응답을 보내거나\(섹션 4.2.4 참조\) 유효성 검사 요청을 다시 시도할 수 있습니다.

---
#### **4.3.4.  Freshening Stored Responses upon Validation**

캐시가 304\(수정되지 않음\) 응답을 받으면 제공된 새 정보로 업데이트하는 데 적합한 저장된 응답을 식별한 다음 이를 수행해야 합니다.

업데이트할 저장된 응답의 초기 세트는 해당 요청에 대해 선택되었을 수 있는 응답입니다. 즉, 최신 요구사항을 제외하고 섹션 4의 요구사항을 충족하는 응답, 오래된 서비스를 제공할 수 있거나 검증된 응답입니다.

그런 다음 저장된 응답의 초기 세트는 다음의 첫 번째 일치 항목을 기준으로 추가로 필터링됩니다.

\* 새 응답에 하나 이상의 "강력한 유효성 검사기"\(\[HTTP\] 섹션 8.8.1 참조\)가 포함된 경우 해당 강력한 유효성 검사기 각각은 업데이트를 위해 선택된 표현을 식별합니다. 동일한 강력한 유효성 검사기 중 하나를 사용하여 초기 세트에 저장된 모든 응답은 업데이트를 위해 식별됩니다. 초기 세트에 동일한 강력한 유효성 검사기가 하나 이상 포함되어 있지 않으면 캐시는 저장된 응답을 업데이트하기 위해 새 응답을 사용해서는 안 됩니다.\(MUST NOT\)

\* 새 응답에 강력한 유효성 검사기가 포함되어 있지 않지만 하나 이상의 "약한 유효성 검사기"가 포함되어 있고 해당 유효성 검사기가 초기 세트의 저장된 응답 중 하나에 해당하는 경우 일치하는 저장된 응답 중 가장 최근이 업데이트를 위해 식별됩니다.

\* 새 응답에 어떤 형태의 유효성 검사기도 포함되지 않고\(예: 클라이언트가 Last-Modified 응답 헤더 필드가 아닌 소스에서 If-Modified-Since 요청을 생성하는 경우\) 초기에 저장된 응답이 하나만 있는 경우 설정되어 있고 저장된 응답에도 유효성 검사기가 없으면 업데이트를 위해 저장된 응답이 식별됩니다.

식별된 각 저장된 응답에 대해 캐시는 섹션 3.2에 따라 304\(수정되지 않음\) 응답에 제공된 헤더 필드로 헤더 필드를 업데이트해야 합니다.\(MUST\)

---
#### **4.3.5.  Freshening Responses with HEAD**

HEAD 메서드에 대한 응답은 콘텐츠를 전송하지 않고 GET으로 수행한 동등한 요청과 동일합니다. HEAD 응답의 이 속성은 더 효율적인 조건부 GET 요청 메커니즘을 사용할 수 없거나\(저장된 응답에 유효성 검사기가 없기 때문에\) 캐시된 GET 응답을 무효화하거나 업데이트하는 데 사용할 수 있습니다. 그것은 바뀌었다.

캐시가 대상 URI에 대한 인바운드 HEAD 요청을 하고 200\(OK\) 응답을 수신하면 캐시는 해당 요청에 대해 선택되었을 수 있는 저장된 각 GET 응답을 업데이트하거나 무효화해야 합니다\(섹션 4.1 참조\).\(SHOULD\)

선택될 수 있는 저장된 응답 각각에 대해 저장된 응답과 HEAD 응답에 수신된 유효성 검사기 필드\(ETag 및 Last-Modified\)에 대해 일치하는 값이 있고 HEAD 응답에 Content-Length 헤더 필드가 있는 경우 값 Content-Length가 저장된 응답의 길이와 일치하는 경우 캐시는 아래 설명된 대로 저장된 응답을 업데이트해야 합니다. 그렇지 않으면 캐시는 저장된 응답을 오래된 것으로 간주해야 합니다.\(SHOULD\)

캐시가 HEAD 응답에 제공된 메타데이터로 저장된 응답을 업데이트하는 경우 캐시는 저장된 응답을 업데이트하기 위해 HEAD 응답에 제공된 헤더 필드를 사용해야 합니다\(섹션 3.2 참조\).\(MUST\)

---
### **4.4.  Invalidating Stored Responses**

PUT, POST 또는 DELETE와 같은 안전하지 않은 요청 방법\(\[HTTP\]의 섹션 9.2.1\)은 원본 서버의 상태를 변경할 가능성이 있으므로 중간 캐시는 저장된 응답을 무효화하여 콘텐츠를 최신 상태로 유지해야 합니다.

캐시는 안전하지 않은 요청 메서드\(안전성이 알려지지 않은 메서드 포함\)에 대한 응답으로 오류가 아닌 상태 코드를 수신할 때 대상 URI\(\[HTTP\]의 섹션 7.1\)를 무효화해야 합니다\(MUST\).\(MUST\)

캐시는 안전하지 않은 요청 메서드\(안전성이 알려지지 않은 메서드 포함\)에 대한 응답으로 오류가 아닌 상태 코드를 수신하면 다른 URI를 무효화할 수 있습니다. 특히 Location 및 Content-Location 응답 헤더 필드\(있는 경우\)의 URI는 무효화 후보입니다. 다른 URI는 이 문서에 지정되지 않은 메커니즘을 통해 검색될 수 있습니다. 그러나 무효화될 URI의 출처\(\[HTTP\]의 섹션 4.3.1\)가 대상 URI\(\[HTTP\]의 섹션 7.1\)의 출처와 다른 경우 캐시는 이러한 조건에서 무효화를 트리거해서는 안 됩니다. 이는 서비스 거부 공격을 방지하는 데 도움이 됩니다.\(MAY, MUST NOT\)

"무효화"는 캐시가 대상 URI가 지정된 URI와 일치하는 저장된 모든 응답을 제거하거나 "유효하지 않음"으로 표시하고 후속 요청에 대한 응답으로 전송되기 전에 필수 유효성 검사가 필요함을 의미합니다.

"오류가 아닌 응답"은 2xx\(성공\) 또는 3xx\(리디렉션\) 상태 코드를 갖는 응답입니다.

이는 모든 적절한 응답이 전역적으로 무효화된다는 것을 보장하지 않습니다. 상태 변경 요청은 이동하는 캐시의 응답만 무효화합니다.

---
## **5.  Field Definitions**

이 섹션에서는 캐싱과 관련된 HTTP 필드의 구문과 의미를 정의합니다.

---
### **5.1.  Age**

"Age" 응답 헤더 필드는 응답이 생성되었거나 원본 서버에서 성공적으로 검증된 이후 보낸 사람의 추정 시간을 전달합니다. 연령 값은 섹션 4.2.3에 지정된 대로 계산됩니다.

```text
     Age = delta-seconds
```

Age 필드 값은 음수가 아닌 정수이며 시간\(초\)을 나타냅니다\(섹션 1.2.2 참조\).

싱글톤 헤더 필드로 정의되었지만 목록 기반 Age 필드 값이 있는 메시지를 발견한 캐시는 필드 값의 첫 번째 멤버를 사용해야 하며 후속 멤버는 삭제해야 합니다.\(SHOULD\)

필드 값\(위에 따라 추가 멤버를 삭제한 후\)이 유효하지 않은 경우\(예: 음수가 아닌 정수 이외의 값이 포함된 경우\) 캐시는 해당 필드를 무시해야 합니다\(SHOULD\).\(SHOULD\)

Age 헤더 필드가 존재한다는 것은 이 요청에 대해 원본 서버에서 응답이 생성되거나 검증되지 않았음을 의미합니다. 그러나 Age 헤더 필드가 없다고 해서 원본이 연결되었음을 의미하지는 않습니다.

---
### **5.2.  Cache-Control**

"Cache-Control" 헤더 필드는 요청/응답 체인을 따라 캐시에 대한 지시어를 나열하는 데 사용됩니다. 캐시 지시문은 단방향입니다. 요청에 지시문이 있다고 해서 응답에 동일한 지시문이 있거나 복사되었다는 의미는 아닙니다.

다른 곳에서 정의된 Cache-Control 지시어를 처리하는 방법에 대한 자세한 내용은 섹션 5.2.3을 참조하세요.

프록시는 캐시 구현 여부에 관계없이 해당 애플리케이션에 대한 중요성에 관계없이 전달된 메시지에서 캐시 지시문을 전달해야 합니다. 지시문은 요청/응답 체인을 따라 모든 수신자에게 적용될 수 있기 때문입니다. 특정 캐시에 대한 지시문을 대상으로 지정하는 것은 불가능합니다.\(MUST\)

캐시 지시문은 토큰으로 식별되어 대소문자를 구분하지 않고 비교되며 토큰 및 인용 문자열 구문을 모두 사용할 수 있는 선택적 인수를 갖습니다. 인수를 정의하는 아래 정의된 지시문의 경우 수신자는 생성을 위해 특정 형식이 필요한 경우에도 두 형식을 모두 수락해야 합니다.

```text
     Cache-Control   = #cache-directive

     cache-directive = token [ "=" ( token / quoted-string ) ]
```

아래에 정의된 캐시 지시문의 경우 달리 명시하지 않는 한 인수가 정의되거나 허용되지 않습니다.

---
#### **5.2.1.  Request Directives**

이 섹션에서는 캐시 요청 지시문을 정의합니다. 그들은 자문입니다. 캐시는 이를 구현할 수 있지만 필수는 아닙니다.\(MAY\)

---
##### **5.2.1.1.  max-age**

```text
   Argument syntax:

      delta-seconds (see Section 1.2.2)
```

max-age 요청 지시문은 클라이언트가 지정된 시간\(초\)보다 작거나 같은 응답을 선호함을 나타냅니다. max-stale 요청 지시문도 존재하지 않는 한 클라이언트는 오래된 응답을 받기를 원하지 않습니다.

이 지시문은 인수 구문의 토큰 형식을 사용합니다\(예: 'max-age="5"'가 아니라 'max-age=5'\). 발신자는 인용 문자열 형식을 생성해서는 안 됩니다.\(MUST NOT\)

---
##### **5.2.1.2.  max-stale**

```text
   Argument syntax:

      delta-seconds (see Section 1.2.2)
```

max-stale 요청 지시어는 클라이언트가 신선도 수명을 초과한 응답을 수락함을 나타냅니다. 값이 있으면 클라이언트는 지정된 시간\(초\) 이하로 신선도 수명을 초과한 응답을 기꺼이 수락합니다. max-stale에 값이 할당되지 않으면 클라이언트는 모든 연령의 오래된 응답을 수락합니다.

이 지시문은 인수 구문의 토큰 형식을 사용합니다\(예: 'max-stale="10"'이 아니라 'max-stale=10'\). 발신자는 인용 문자열 형식을 생성해서는 안 됩니다.\(MUST NOT\)

---
##### **5.2.1.3.  min-fresh**

```text
   Argument syntax:

      delta-seconds (see Section 1.2.2)
```

min-fresh 요청 지시어는 클라이언트가 현재 수명에 지정된 시간\(초\)을 더한 것 이상의 신선도 수명을 갖는 응답을 선호함을 나타냅니다. 즉, 클라이언트는 최소한 지정된 시간\(초\) 동안 여전히 신선한 응답을 원합니다.

이 지시문은 인수 구문의 토큰 형식을 사용합니다\(예: 'min-fresh="20"'이 아닌 'min-fresh=20'\). 발신자는 인용 문자열 형식을 생성해서는 안 됩니다.\(MUST NOT\)

---
##### **5.2.1.4.  no-cache**

no-cache 요청 지시문은 클라이언트가 원본 서버에서 성공적인 검증 없이 요청을 충족하는 데 저장된 응답을 사용하지 않기를 원함을 나타냅니다.

---
##### **5.2.1.5.  no-store**

no-store 요청 지시문은 캐시가 이 요청이나 이에 대한 응답의 일부를 저장해서는 안 된다는 것을 나타냅니다. 이 지시문은 개인 캐시와 공유 캐시 모두에 적용됩니다. 이 맥락에서 "저장해서는 안 된다"는 것은 캐시가 의도적으로 비휘발성 저장소에 정보를 저장해서는 안 되며 정보를 전달한 후 가능한 한 즉시 휘발성 저장소에서 정보를 제거하기 위해 최선을 다해야 한다는 것을 의미합니다.\(MUST NOT, MUST NOT\)

이 지시문은 개인 정보 보호를 보장하기 위한 신뢰할 수 있거나 충분한 메커니즘이 아닙니다. 특히, 악의적이거나 손상된 캐시는 이 지시문을 인식하거나 따르지 않을 수 있으며 통신 네트워크는 도청에 취약할 수 있습니다.

이 지시문이 포함된 요청이 캐시에서 충족되면 no-store 요청 지시문은 이미 저장된 응답에 적용되지 않습니다.

---
##### **5.2.1.6.  no-transform**

no-transform 요청 지시문은 \[HTTP\]의 섹션 7.7에 정의된 대로 클라이언트가 콘텐츠 변환을 피하기 위해 중개자를 요청하고 있음을 나타냅니다.

---
##### **5.2.1.7.  only-if-cached**

only-if-cached 요청 지시문은 클라이언트가 저장된 응답만 얻기를 원한다는 것을 나타냅니다. 이 요청 지시문을 준수하는 캐시는 이를 수신하자마자 요청의 다른 제약 조건과 일치하는 저장된 응답 또는 504\(Gateway Timeout\) 상태 코드로 응답해야 합니다.\(SHOULD\)

---
#### **5.2.2.  Response Directives**

이 섹션에서는 캐시 응답 지시문을 정의합니다. 캐시는 이 섹션에 정의된 Cache-Control 지시어를 준수해야 합니다.\(MUST\)

---
##### **5.2.2.1.  max-age**

```text
   Argument syntax:

      delta-seconds (see Section 1.2.2)
```

max-age 응답 지시어는 응답의 수명이 지정된 시간\(초\)을 초과하면 오래된 것으로 간주된다는 것을 나타냅니다.

이 지시문은 인수 구문의 토큰 형식을 사용합니다\(예: 'max-age="5"'가 아니라 'max-age=5'\). 발신자는 인용 문자열 형식을 생성해서는 안 됩니다.\(MUST NOT\)

---
##### **5.2.2.2.  must-revalidate**

must-revalidate 응답 지시문은 응답이 오래되면 캐시가 섹션 4.3에 정의된 대로 원본에 의해 성공적으로 검증될 때까지 다른 요청을 충족하기 위해 해당 응답을 재사용해서는 안 된다는 것을 나타냅니다.\(MUST NOT\)

특정 프로토콜 기능에 대한 안정적인 작동을 지원하려면 must-revalidate 지시어가 필요합니다. 모든 상황에서 캐시는 must-revalidate 지시어를 무시해서는 안 됩니다. 특히, 캐시 연결이 끊어지면 캐시는 오래된 응답을 재사용하는 대신 오류 응답을 생성해야 합니다. 다른 오류 상태 코드가 더 적합하지 않은 한 생성된 상태 코드는 504\(Gateway Timeout\)여야 합니다.\(MUST NOT, SHOULD\)

must-revalidate 지시어는 요청의 유효성을 검사하지 못해 자동으로 실행되지 않는 금융 거래와 같이 잘못된 작업이 발생할 수 있는 경우에만 서버에서 사용해야 합니다.

must-revalidate 지시문은 또한 위의 재검증 요구 사항\(섹션 3.5\)에 따라 공유 캐시가 Authorization 헤더 필드\(\[HTTP\]의 섹션 11.6.2\)를 포함하는 요청에 대한 응답을 재사용하도록 허용합니다.

---
##### **5.2.2.3.  must-understand**

must-understand 응답 지시문은 해당 응답의 상태 코드에 대한 요구 사항을 이해하고 준수하는 캐시로 응답 캐싱을 제한합니다.

must-understand 지시문을 포함하는 응답은 no-store 지시문도 포함해야 합니다. must-understand 지시문을 구현하는 캐시가 이를 포함하는 응답을 수신할 때 상태 코드의 캐싱 요구 사항을 이해하고 구현하는 경우 캐시는 no-store 지시문을 무시해야 합니다.\(SHOULD, SHOULD\)

---
##### **5.2.2.4.  no-cache**

```text
   Argument syntax:

      #field-name
```

no-cache 응답 지시문은 비한정 형식\(인수 없음\)으로 응답을 유효성 검사를 위해 전달하고 성공적인 응답을 수신하지 않고 다른 요청을 충족하는 데 사용해서는 안 된다는 것을 나타냅니다. 섹션 4.3을 참조하세요.\(MUST NOT\)

이를 통해 원본 서버는 오래된 응답을 보내도록 구성된 캐시에 의해서도 캐시가 요청에 접속하지 않고 응답을 사용하여 요청을 충족시키는 것을 방지할 수 있습니다.

하나 이상의 필드 이름을 나열하는 인수가 포함된 no-cache 응답 지시문의 한정된 형식은 나열된 헤더 필드가 다음과 같은 경우 캐싱에 대한 다른 제한 사항에 따라 캐시가 후속 요청을 충족하기 위해 응답을 사용할 수 있음을 나타냅니다. 후속 응답에서 제외되었거나 후속 응답이 원본 서버에서 성공적으로 재검증되었습니다\(해당 필드 업데이트 또는 제거\). 이를 통해 원본 서버는 응답에서 특정 헤더 필드의 재사용을 방지하는 동시에 나머지 응답의 캐싱을 허용할 수 있습니다.\(MAY\)

주어진 필드 이름은 이 사양에서 정의한 헤더 필드 집합으로 제한되지 않습니다. 필드 이름은 대소문자를 구분합니다.

이 지시문은 인수 구문의 따옴표 붙은 문자열 형식을 사용합니다. 발신자는 토큰 양식을 생성해서는 안 됩니다\(단일 항목 목록에 인용이 필요하지 않은 것처럼 보이는 경우에도\).\(SHOULD NOT\)

- | \*참고:\* 지시문의 정규화된 형식은 |에 의해 처리되는 경우가 많습니다. 규정되지 않은 no-cache 지시문이 수신된 것처럼 캐시합니다. | 즉, 한정된 형식에 대한 특별한 처리는 | 널리 시행됩니다.

---
##### **5.2.2.5.  no-store**

no-store 응답 지시어는 캐시가 즉각적인 요청이나 응답의 어떤 부분도 저장해서는 안 되며 다른 요청을 만족시키기 위해 응답을 사용해서는 안 된다는 것을 나타냅니다.\(MUST NOT\)

이 지시문은 개인 캐시와 공유 캐시 모두에 적용됩니다. 이 맥락에서 "저장해서는 안 된다"는 것은 캐시가 의도적으로 비휘발성 저장소에 정보를 저장해서는 안 되며 정보를 전달한 후 가능한 한 즉시 휘발성 저장소에서 정보를 제거하기 위해 최선을 다해야 한다는 것을 의미합니다.\(MUST NOT\)

이 지시문은 개인 정보 보호를 보장하기 위한 신뢰할 수 있거나 충분한 메커니즘이 아닙니다. 특히, 악의적이거나 손상된 캐시는 이 지시문을 인식하거나 따르지 않을 수 있으며 통신 네트워크는 도청에 취약할 수 있습니다.

must-understand 캐시 지시문은 특정 상황에서 no-store를 무시합니다. 섹션 5.2.2.3을 참조하십시오.

---
##### **5.2.2.6.  no-transform**

no-transform 응답 지시문은 \[HTTP\]의 7.7절에 정의된 대로 중개자가\(캐시 구현 여부에 관계없이\) 콘텐츠를 변환해서는 안 된다는 것을 나타냅니다.\(MUST NOT\)

---
##### **5.2.2.7.  private**

```text
   Argument syntax:

      #field-name
```

unqualified private response 지시문은 공유 캐시가 응답을 저장해서는 안 된다는 것을 나타냅니다\(즉, 응답은 단일 사용자를 위한 것입니다\). 이는 또한 응답이 개인 캐시에 의해 발견적으로 캐시될 수 없는 경우에도 섹션 3에 정의된 제약 조건에 따라 개인 캐시가 응답을 저장할 수 있음을 나타냅니다.\(MUST NOT, MAY\)

하나 이상의 필드 이름을 나열하는 인수와 함께 정규화된 개인 응답 지시문이 있는 경우 나열된 헤더 필드만 단일 사용자로 제한됩니다. 공유 캐시는 나열된 헤더 필드가 원본에 있는 경우 이를 저장해서는 안 됩니다. 그러나 섹션 3에 정의된 제약 조건에 따라 해당 헤더 필드 없이 응답 메시지의 나머지 부분을 저장할 수 있습니다.\(MUST NOT\)

주어진 필드 이름은 이 사양에서 정의한 헤더 필드 집합으로 제한되지 않습니다. 필드 이름은 대소문자를 구분합니다.

이 지시문은 인수 구문의 따옴표 붙은 문자열 형식을 사용합니다. 발신자는 토큰 양식을 생성해서는 안 됩니다\(단일 항목 목록에 인용이 필요하지 않은 것처럼 보이는 경우에도\).\(SHOULD NOT\)

- | \*참고:\* "비공개"라는 단어의 사용은 | 응답을 저장할 수 있습니다. 개인 정보 보호를 보장할 수 없습니다 | 메시지 내용. 또한 지시문의 정규화된 형식은 | 정규화되지 않은 개인 지시문인 것처럼 캐시에 의해 처리되는 경우가 많습니다 | 받았어요; 즉, 자격을 갖춘 | 양식이 널리 구현되지 않았습니다.

---
##### **5.2.2.8.  proxy-revalidate**

Proxy-revalidate 응답 지시문은 응답이 오래되면 공유 캐시가 섹션 4.3에 정의된 대로 원본에 의해 성공적으로 검증될 때까지 다른 요청을 충족하기 위해 해당 응답을 재사용해서는 안 된다는 것을 나타냅니다. 이는 프록시 재검증이 개인 캐시에 적용되지 않는다는 점을 제외하면 필수 재검증\(섹션 5.2.2.2\)과 유사합니다.\(MUST NOT\)

프록시 재검증 자체가 응답이 캐시 가능하다는 것을 의미하지는 않습니다. 예를 들어, public 지시문\(섹션 5.2.2.9\)과 결합하여 응답이 캐시되도록 허용하면서 오래된 경우 재검증을 위해 공유 캐시만 요구할 수 있습니다.

---
##### **5.2.2.9.  public**

public 응답 지시문은 섹션 3에 정의된 제약 조건에 따라 응답이 금지되는 경우에도 캐시가 응답을 저장할 수 있음을 나타냅니다. 즉, public은 응답을 캐시 가능한 것으로 명시적으로 표시합니다. 예를 들어, public은 공유 캐시가 Authorization 헤더 필드\(섹션 3.5\)가 포함된 요청에 대한 응답을 재사용하도록 허용합니다.\(MAY\)

섹션 3에 따라 이미 캐시 가능한 응답에는 public 지시문을 추가할 필요가 없습니다.

public 지시어가 포함된 응답에 명시적인 신선도 정보가 없으면 경험적으로 캐시할 수 있습니다\(섹션 4.2.2\).

---
##### **5.2.2.10.  s-maxage**

```text
   Argument syntax:

      delta-seconds (see Section 1.2.2)
```

s-maxage 응답 지시문은 공유 캐시의 경우 이 지시문에 지정된 최대 수명이 max-age 지시문 또는 Expires 헤더 필드에 지정된 최대 수명보다 우선함을 나타냅니다.

s-maxage 지시문은 공유 캐시에 대한 프록시 재검증 응답 지시문\(섹션 5.2.2.8\)의 의미를 통합합니다. 공유 캐시는 섹션 4.3에 정의된 대로 원본에 의해 성공적으로 검증될 때까지 다른 요청을 충족하기 위해 s-maxage와 함께 오래된 응답을 재사용해서는 안 됩니다. 또한 이 지시어는 공유 캐시가 Authorization 헤더 필드가 포함된 요청에 대한 응답을 재사용할 수 있도록 허용하며, 위의 최대 수명 및 재검증 요구 사항\(섹션 3.5\)을 따릅니다.\(MUST NOT\)

이 지시문은 인수 구문의 토큰 형식을 사용합니다\(예: 's-maxage="10"'이 아니라 's-maxage=10'\). 발신자는 인용 문자열 형식을 생성해서는 안 됩니다.\(MUST NOT\)

---
#### **5.2.3.  Extension Directives**

Cache-Control 헤더 필드는 하나 이상의 확장 캐시 지시어를 사용하여 확장될 수 있습니다. 캐시는 인식할 수 없는 캐시 지시어를 무시해야 합니다.\(MUST\)

정보 확장\(캐시 동작 변경이 필요하지 않은 확장\)은 다른 지시어의 의미를 변경하지 않고도 추가할 수 있습니다.

동작 확장은 기존 캐시 지시어 기반에 대한 수정자 역할을 하여 작동하도록 설계되었습니다. 새 지시문과 이전 지시문이 모두 제공되므로 새 지시문을 이해하지 못하는 응용 프로그램은 기본적으로 이전 지시문에 지정된 동작을 수행하고 새 지시문을 이해하는 응용 프로그램은 이를 이전 지시문과 관련된 요구 사항을 수정하는 것으로 인식합니다. 지령. 이러한 방식으로 배포된 캐시를 손상시키지 않고 기존 캐시 지시문을 확장할 수 있습니다.

예를 들어, 개인 지시문에 대한 수정자 역할을 하는 "커뮤니티"라는 가상의 새 응답 지시문을 생각해 보십시오. 개인 캐시 외에도 명명된 커뮤니티의 구성원이 공유하는 캐시만 응답을 캐시하도록 허용됩니다. UCI 커뮤니티가 공유 캐시에서 비공개 응답을 사용하도록 허용하려는 원본 서버는 다음을 포함하여 그렇게 할 수 있습니다.

```text
   Cache-Control: private, community="UCI"
```

이러한 커뮤니티 캐시 지시문을 인식하는 캐시는 해당 확장에 따라 동작을 확장할 수 있습니다. 커뮤니티 캐시 지시어를 인식하지 못하는 캐시는 이를 무시하고 private 지시어를 따릅니다.

새로운 확장 지시문은 다음을 정의하는 것을 고려해야 합니다.

\* 지시문이 여러 번 지정된다는 것은 무엇을 의미합니까?

\* 지시문이 인수를 취하지 않을 때 인수가 있을 때의 의미는 무엇입니까?

\* 지시문에 인수가 필요한 경우 인수가 누락된 경우의 의미

\* 지시문이 요청에 특정한지, 응답에 특정한지, 아니면 둘 중 하나에 사용될 수 있는지 여부.

---
#### **5.2.4.  Cache Directive Registry**

```text
   The "Hypertext Transfer Protocol (HTTP) Cache Directive Registry"
   defines the namespace for the cache directives.  It has been created
   and is now maintained at <https://www.iana.org/assignments/http-
   cache-directives>.
```

등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

```text
   *  Cache Directive Name
```

\* 사양 텍스트에 대한 포인터

이 네임스페이스에 추가할 값에는 IETF 검토가 필요합니다\(\[RFC8126\], 섹션 4.8 참조\).

---
### **5.3.  Expires**

"Expires" 응답 헤더 필드는 응답이 오래된 것으로 간주되는 날짜/시간을 제공합니다. 신선도 모델에 대한 추가 논의는 섹션 4.2를 참조하십시오.

Expires 헤더 필드가 존재한다고 해서 원래 리소스가 해당 시점, 이전 또는 이후에 변경되거나 존재하지 않게 된다는 의미는 아닙니다.

Expires 필드 값은 \[HTTP\]의 섹션 5.6.7에 정의된 HTTP 날짜 타임스탬프입니다. 캐시와 관련된 구문 분석 요구 사항은 섹션 4.2를 참조하세요.

```text
     Expires = HTTP-date
```

예를 들어

```text
   Expires: Thu, 01 Dec 1994 16:00:00 GMT
```

캐시 수신자는 잘못된 날짜 형식, 특히 "0" 값을 과거 시간\(예: "이미 만료됨"\)을 나타내는 것으로 해석해야 합니다.\(MUST\)

응답에 max-age 지시어\(섹션 5.2.2.1\)와 함께 Cache-Control 헤더 필드가 포함된 경우 수신자는 Expires 헤더 필드를 무시해야 합니다. 마찬가지로 응답에 s-maxage 지시문\(5.2.2.10절\)이 포함된 경우 공유 캐시 수신자는 Expires 헤더 필드를 무시해야 합니다. 두 경우 모두 Expires의 값은 Cache-Control 헤더 필드를 아직 구현하지 않은 수신자에게만 사용됩니다.\(MUST, MUST\)

시계가 없는 원서버\(\[HTTP\]의 섹션 5.6.7\)는 해당 값이 과거의 고정 시간\(항상 만료됨\)을 나타내거나 해당 값이 다음과 같은 시스템에 의해 리소스와 연결되지 않는 한 Expires 헤더 필드를 생성해서는 안 됩니다. 시계.\(MUST NOT\)

역사적으로 HTTP에서는 Expires 필드 값이 향후 1년 이내여야 했습니다. 더 긴 신선도 수명은 더 이상 금지되지 않지만 매우 큰 값은 문제를 일으키는 것으로 입증되었으며\(예: 시간 값에 32비트 정수 사용으로 인한 클럭 오버플로\) 많은 캐시가 그보다 훨씬 빨리 응답을 제거합니다.

---
### **5.4.  Pragma**

"Pragma" 요청 헤더 필드는 HTTP/1.0 캐시에 대해 정의되었으므로 클라이언트는 "no-cache" 요청을 지정할 수 있습니다\(Cache-Control은 HTTP/1.1까지 정의되지 않았기 때문입니다\).

그러나 이제 Cache-Control에 대한 지원이 널리 보급되었습니다. 결과적으로 이 사양에서는 Pragma를 더 이상 사용하지 않습니다.

- | \*참고:\* 응답에서 "Pragma: no-cache"의 의미 | 지정되지 않았으며 안정적인 대체를 제공하지 않습니다 | "Cache-Control: no-cache"에 대한 것입니다.

---
### **5.5.  Warning**

"경고" 헤더 필드는 상태 코드에 반영되지 않을 수 있는 메시지의 상태 또는 변환에 대한 추가 정보를 전달하는 데 사용되었습니다. 이 사양은 널리 생성되거나 사용자에게 표시되지 않으므로 더 이상 사용되지 않습니다. 전달되는 정보는 Age와 같은 다른 헤더 필드를 조사하여 수집할 수 있습니다.

---
## **6.  Relationship to Applications and Other Caches**

HTTP를 사용하는 애플리케이션은 추가 캐싱 형식을 지정하는 경우가 많습니다. 예를 들어, 웹 브라우저에는 이전 세션에서 검색된 표현을 다시 표시하는 데 사용할 수 있는 "뒤로" 버튼과 같은 기록 메커니즘이 있는 경우가 많습니다.

마찬가지로 일부 웹 브라우저는 페이지 보기 내에서 이미지 및 기타 자산의 캐싱을 구현합니다. HTTP 캐싱 의미론을 존중할 수도 있고 그렇지 않을 수도 있습니다.

이 사양의 요구 사항은 HTTP 캐시에서 데이터를 검색한 후 애플리케이션이 데이터를 사용하는 방법에 반드시 적용되는 것은 아닙니다. 예를 들어, 기록 메커니즘은 만료된 경우에도 이전 표현을 표시할 수 있으며, 애플리케이션은 캐시된 데이터를 최신 상태 수명을 넘어 다른 방식으로 사용할 수 있습니다.

이 사양은 애플리케이션이 HTTP 캐싱을 고려하는 것을 금지하지 않습니다. 예를 들어 기록 메커니즘은 사용자에게 뷰가 오래되었다고 알려주거나 캐시 지시어\(예: Cache-Control: no-store\)를 따를 수 있습니다.

그러나 애플리케이션이 데이터를 캐시하고 이를 사용자에게 명백하게 나타내지 않거나 쉽게 제어할 수 없는 경우, 캐싱 의미가 존중되기를 기대하는 작성자를 놀라게 하지 않도록 HTTP 캐시 지시어와 관련하여 해당 작업을 정의하는 것이 좋습니다. 예를 들어, Cache-Control: no-store가 포함된 응답을 가져온 요청과 직접 관련된 요청\(예: 도중에 생성된 요청\)에 재사용할 수 있도록 HTTP "위"에 애플리케이션 캐시를 정의하는 것이 합리적일 수 있습니다. 동일한 페이지 로드\), 얻은 요청과 어떤 방식으로든 관련되지 않은 요청에 대해 재사용이 허용된다면 사용자와 작성자에게는 놀랍고 혼란스러울 수 있습니다.

---
## **7.  Security Considerations**

이 섹션은 개발자, 정보 제공자 및 사용자에게 HTTP 캐싱과 관련된 알려진 보안 문제를 알리기 위한 것입니다. 보다 일반적인 보안 고려사항은 "HTTP/1.1"\(\[HTTP/1.1\]의 섹션 11\) 및 "HTTP 의미론"\(\[HTTP\]의 섹션 17\)에서 다루어집니다.

캐시의 콘텐츠는 악의적인 악용의 대상이 되기 때문에 캐시는 추가적인 공격 표면을 노출시킵니다. HTTP 요청이 완료된 후에도 캐시 콘텐츠가 지속되므로 캐시에 대한 공격은 사용자가 정보가 네트워크에서 제거되었다고 믿은 후에도 오랫동안 정보를 공개할 수 있습니다. 따라서 캐시 내용은 민감한 정보로 보호되어야 합니다.

특히, 개인 캐시는 단일 사용자로 제한되므로 사용자 활동을 재구성하는 데 사용될 수 있습니다. 결과적으로 사용자 에이전트는 최종 사용자가 이를 제어할 수 있도록 허용하는 것이 중요합니다. 예를 들어 일부 또는 모든 원본 서버에 대해 저장된 응답을 제거할 수 있도록 허용합니다.

---
### **7.1.  Cache Poisoning**

악성 콘텐츠를 캐시에 저장하면 공격자의 범위가 확장되어 여러 사용자에게 영향을 미칠 수 있습니다. 이러한 "캐시 중독" 공격은 공격자가 구현 결함, 상승된 권한 또는 기타 기술을 사용하여 캐시에 응답을 삽입할 때 발생합니다. 이는 공유 캐시를 사용하여 악성 콘텐츠를 여러 클라이언트에 배포할 때 특히 효과적입니다.

캐시 중독에 대한 일반적인 공격 벡터 중 하나는 프록시와 사용자 에이전트의 메시지 구문 분석 차이를 이용하는 것입니다. HTTP/1.1에 관한 관련 요구 사항은 \[HTTP/1.1\]의 섹션 6.3을 참조하세요.

---
### **7.2.  Timing Attacks**

캐시의 주요 용도 중 하나는 성능을 최적화하는 것이므로 이전에 요청한 리소스에 대한 정보를 "누출"할 수 있습니다.

예를 들어, 사용자가 사이트를 방문하고 브라우저가 응답 중 일부를 캐시한 다음 두 번째 사이트로 이동하는 경우 해당 사이트는 첫 번째 사이트에 존재한다는 것을 알고 있는 응답을 로드하려고 시도할 수 있습니다. 빠르게 로드된다면 사용자가 해당 사이트를 방문했거나 심지어 그 사이트의 특정 페이지를 방문한 것으로 가정할 수 있습니다.

이러한 "타이밍 공격"은 참조 사이트의 ID와 같은 추가 정보를 캐시 키에 추가하여 완화할 수 있습니다\(위에서 설명한 공격을 방지하기 위해\). 이를 "이중 키잉"이라고도 합니다.

---
### **7.3.  Caching of Sensitive Information**

구현 및 배포 결함\(종종 캐시 작업에 대한 오해로 인해 발생\)으로 인해 비공개로 간주되는 민감한 정보\(예: 인증 자격 증명\)가 캐싱되어 승인되지 않은 당사자에게 노출될 수 있습니다.

Set-Cookie 응답 헤더 필드 \[COOKIE\]는 캐싱을 금지하지 않습니다. Set-Cookie 헤더 필드가 있는 캐시 가능한 응답은 캐시에 대한 후속 요청을 충족하는 데 사용될 수 있으며 종종 사용됩니다. 이러한 응답의 캐싱을 제어하려는 서버는 적절한 Cache-Control 응답 헤더 필드를 내보내는 것이 좋습니다.

---
## **8.  IANA Considerations**

다음 등록에 대한 변경 컨트롤러는 "IETF\(iesg@ietf.org\) - Internet Engineering Task Force"입니다.

---
### **8.1.  Field Name Registration**

IANA는 \[HTTP\]의 섹션 18.4에 설명된 대로 <https://www.iana.org/locationments/http-fields\>에서 "HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리"를 업데이트했습니다. 아래 표:

```text
   +===============+============+=========+==========+
   | Field Name    | Status     | Section | Comments |
   +===============+============+=========+==========+
   | Age           | permanent  | 5.1     |          |
   +---------------+------------+---------+----------+
   | Cache-Control | permanent  | 5.2     |          |
   +---------------+------------+---------+----------+
   | Expires       | permanent  | 5.3     |          |
   +---------------+------------+---------+----------+
   | Pragma        | deprecated | 5.4     |          |
   +---------------+------------+---------+----------+
   | Warning       | obsoleted  | 5.5     |          |
   +---------------+------------+---------+----------+

                         Table 1
```

---
### **8.2.  Cache Directive Registration**

IANA는 섹션 5.2.4에 따른 등록 절차와 요약된 캐시 지시문 이름을 사용하여 <https://www.iana.org/locationments/http-cache-directives\>에서 "HTTP\(Hypertext Transfer Protocol\) 캐시 지시문 레지스트리"를 업데이트했습니다. 아래 표에서.

```text
   +==================+==================+
   | Cache Directive  | Section          |
   +==================+==================+
   | max-age          | 5.2.1.1, 5.2.2.1 |
   +------------------+------------------+
   | max-stale        | 5.2.1.2          |
   +------------------+------------------+
   | min-fresh        | 5.2.1.3          |
   +------------------+------------------+
   | must-revalidate  | 5.2.2.2          |
   +------------------+------------------+
   | must-understand  | 5.2.2.3          |
   +------------------+------------------+
   | no-cache         | 5.2.1.4, 5.2.2.4 |
   +------------------+------------------+
   | no-store         | 5.2.1.5, 5.2.2.5 |
   +------------------+------------------+
   | no-transform     | 5.2.1.6, 5.2.2.6 |
   +------------------+------------------+
   | only-if-cached   | 5.2.1.7          |
   +------------------+------------------+
   | private          | 5.2.2.7          |
   +------------------+------------------+
   | proxy-revalidate | 5.2.2.8          |
   +------------------+------------------+
   | public           | 5.2.2.9          |
   +------------------+------------------+
   | s-maxage         | 5.2.2.10         |
   +------------------+------------------+

                   Table 2
```

---
### **8.3.  Warn Code Registry**

IANA는 "경고"가 폐기되었음을 알리는 "HTTP\(Hypertext Transfer Protocol\) 경고 코드" 레지스트리\(<https://www.iana.org/locationments/ http-warn-codes\>\)에 다음 메모를 추가했습니다.

| 경고 헤더 필드\(및 여기에 사용되는 경고 코드\)에는 | \[RFC9111\]에 따라 HTTP에서는 더 이상 사용되지 않습니다.

---
## **9.  References**
---
### **9.1.  Normative References**

```text
   [HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/info/rfc9110>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <https://www.rfc-editor.org/info/rfc5234>.

   [RFC7405]  Kyzivat, P., "Case-Sensitive String Support in ABNF",
              RFC 7405, DOI 10.17487/RFC7405, December 2014,
              <https://www.rfc-editor.org/info/rfc7405>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.
```

---
### **9.2.  Informative References**

```text
   [COOKIE]   Barth, A., "HTTP State Management Mechanism", RFC 6265,
              DOI 10.17487/RFC6265, April 2011,
              <https://www.rfc-editor.org/info/rfc6265>.

   [HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112,
              June 2022, <https://www.rfc-editor.org/info/rfc9112>.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616,
              DOI 10.17487/RFC2616, June 1999,
              <https://www.rfc-editor.org/info/rfc2616>.

   [RFC5861]  Nottingham, M., "HTTP Cache-Control Extensions for Stale
              Content", RFC 5861, DOI 10.17487/RFC5861, May 2010,
              <https://www.rfc-editor.org/info/rfc5861>.

   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
              RFC 7234, DOI 10.17487/RFC7234, June 2014,
              <https://www.rfc-editor.org/info/rfc7234>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.
```

---
# **Appendix A.  Collected ABNF**

아래 수집된 ABNF에서는 \[HTTP\]의 섹션 5.6.1에 따라 목록 규칙이 확장됩니다.

```text
   Age = delta-seconds

   Cache-Control = [ cache-directive *( OWS "," OWS cache-directive ) ]

   Expires = HTTP-date

   HTTP-date = <HTTP-date, see [HTTP], Section 5.6.7>

   OWS = <OWS, see [HTTP], Section 5.6.3>

   cache-directive = token [ "=" ( token / quoted-string ) ]

   delta-seconds = 1*DIGIT

   field-name = <field-name, see [HTTP], Section 5.1>

   quoted-string = <quoted-string, see [HTTP], Section 5.6.4>

   token = <token, see [HTTP], Section 5.6.2>
```

---
# **Appendix B.  Changes from RFC 7234**

```text
   Handling of duplicate and conflicting cache directives has been
   clarified.  (Section 4.2.1)

   Cache invalidation of the URIs in the Location and Content-Location
   header fields is no longer required but is still allowed.
   (Section 4.4)

   Cache invalidation of the URIs in the Location and Content-Location
   header fields is disallowed when the origin is different; previously,
   it was the host.  (Section 4.4)

   Handling invalid and multiple Age header field values has been
   clarified.  (Section 5.1)

   Some cache directives defined by this specification now have stronger
   prohibitions against generating the quoted form of their values,
   since this has been found to create interoperability problems.
   Consumers of extension cache directives are no longer required to
   accept both token and quoted-string forms, but they still need to
   parse them properly for unknown extensions.  (Section 5.2)

   The public and private cache directives were clarified, so that they
   do not make responses reusable under any condition.  (Section 5.2.2)

   The must-understand cache directive was introduced; caches are no
   longer required to understand the semantics of new response status
   codes unless it is present.  (Section 5.2.2.3)

   The Warning response header was obsoleted.  Much of the information
   supported by Warning could be gleaned by examining the response, and
   the remaining information -- although potentially useful -- was
   entirely advisory.  In practice, Warning was not added by caches or
   intermediaries.  (Section 5.5)
```

---
# **Acknowledgements**

이 문서에도 적용되는 \[HTTP\]의 부록 "감사의 말씀"을 참조하세요.

---
# **Index**

A C E F G H M N O P S V W

```text
      A

         age  Section 4.2
         Age header field  *_Section 5.1_*

      C

         cache  Section 1
         cache key  Section 2; Section 2
         Cache-Control header field  *_Section 5.2_*
         collapsed requests  Section 4

      E

         Expires header field  *_Section 5.3_*
         explicit expiration time  Section 4.2

      F

         Fields
            Age  *_Section 5.1_*; *_Section 5.1_*
            Cache-Control  *_Section 5.2_*
            Expires  *_Section 5.3_*; *_Section 5.3_*
            Pragma  *_Section 5.4_*; *_Section 5.4_*
            Warning  *_Section 5.5_*
         fresh  Section 4.2
         freshness lifetime  Section 4.2

      G

         Grammar
            Age  *_Section 5.1_*
            Cache-Control  *_Section 5.2_*
            DIGIT  *_Section 1.2_*
            Expires  *_Section 5.3_*
            cache-directive  *_Section 5.2_*
            delta-seconds  *_Section 1.2.2_*

      H

         Header Fields
            Age  *_Section 5.1_*; *_Section 5.1_*
            Cache-Control  *_Section 5.2_*
            Expires  *_Section 5.3_*; *_Section 5.3_*
            Pragma  *_Section 5.4_*; *_Section 5.4_*
            Warning  *_Section 5.5_*
         heuristic expiration time  Section 4.2
         heuristically cacheable  Section 4.2.2

      M

         max-age (cache directive)  *_Section 5.2.1.1_*;
            *_Section 5.2.2.1_*
         max-stale (cache directive)  *_Section 5.2.1.2_*
         min-fresh (cache directive)  *_Section 5.2.1.3_*
         must-revalidate (cache directive)  *_Section 5.2.2.2_*
         must-understand (cache directive)  *_Section 5.2.2.3_*

      N

         no-cache (cache directive)  *_Section 5.2.1.4_*;
            *_Section 5.2.2.4_*
         no-store (cache directive)  *_Section 5.2.1.5_*;
            *_Section 5.2.2.5_*
         no-transform (cache directive)  *_Section 5.2.1.6_*;
            *_Section 5.2.2.6_*

      O

         only-if-cached (cache directive)  *_Section 5.2.1.7_*

      P

         Pragma header field  *_Section 5.4_*
         private (cache directive)  *_Section 5.2.2.7_*
         private cache  Section 1
         proxy-revalidate (cache directive)  *_Section 5.2.2.8_*
         public (cache directive)  *_Section 5.2.2.9_*

      S

         s-maxage (cache directive)  *_Section 5.2.2.10_*
         shared cache  Section 1
         stale  Section 4.2

      V

         validator  Section 4.3.1

      W

         Warning header field  *_Section 5.5_*
```

---
# **Authors' Addresses**

```text
   Roy T. Fielding (editor)
   Adobe
   345 Park Ave
   San Jose, CA 95110
   United States of America
   Email: fielding@gbiv.com
   URI:   https://roy.gbiv.com/

   Mark Nottingham (editor)
   Fastly
   Prahran
   Australia
   Email: mnot@mnot.net
   URI:   https://www.mnot.net/

   Julian Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   48155 Münster
   Germany
   Email: julian.reschke@greenbytes.de
   URI:   https://greenbytes.de/tech/webdav/
```
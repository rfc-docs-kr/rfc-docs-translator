

```text
Network Working Group                                      J. Oikarinen
Request for Comments: 1459                                      D. Reed
                                                               May 1993

                      Internet Relay Chat Protocol
```

---
# **Status of This Memo**

이 메모는 인터넷 커뮤니티를 위한 실험 프로토콜을 정의합니다. 개선을 위한 논의와 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "IAB 공식 프로토콜 표준" 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Abstract**

IRC 프로토콜은 BBS 사용자가 서로 채팅할 수 있는 수단으로 처음 구현된 이후 지난 4년에 걸쳐 개발되었습니다. 이제는 전세계적인 서버와 클라이언트 네트워크를 지원하며 성장에 부응하기 위해 안간힘을 쓰고 있습니다. 지난 2년 동안 기본 IRC 네트워크에 연결된 평균 사용자 수가 10배 증가했습니다.

IRC 프로토콜은 텍스트 기반 프로토콜로, 가장 간단한 클라이언트는 서버에 연결할 수 있는 소켓 프로그램입니다.

---
# **Table of Contents**

```text
   1.  INTRODUCTION ...............................................    4
      1.1  Servers ................................................    4
      1.2  Clients ................................................    5
         1.2.1 Operators ..........................................    5
      1.3 Channels ................................................    5
      1.3.1  Channel Operators ....................................    6
   2. THE IRC SPECIFICATION .......................................    7
      2.1 Overview ................................................    7
      2.2 Character codes .........................................    7
      2.3 Messages ................................................    7
         2.3.1  Message format in 'pseudo' BNF ....................    8
      2.4 Numeric replies .........................................   10
   3. IRC Concepts ................................................   10
      3.1 One-to-one communication ................................   10
      3.2 One-to-many .............................................   11
         3.2.1 To a list ..........................................   11
         3.2.2 To a group (channel) ...............................   11
         3.2.3 To a host/server mask ..............................   12
      3.3 One to all ..............................................   12
         3.3.1 Client to Client ...................................   12
         3.3.2 Clients to Server ..................................   12
         3.3.3 Server to Server ...................................   12
   4. MESSAGE DETAILS .............................................   13
      4.1 Connection Registration .................................   13
         4.1.1 Password message ...................................   14
         4.1.2 Nickname message ...................................   14
         4.1.3 User message .......................................   15
         4.1.4 Server message .....................................   16
         4.1.5 Operator message ...................................   17
         4.1.6 Quit message .......................................   17
         4.1.7 Server Quit message ................................   18
      4.2 Channel operations ......................................   19
         4.2.1 Join message .......................................   19
         4.2.2 Part message .......................................   20
         4.2.3 Mode message .......................................   21
            4.2.3.1 Channel modes .................................   21
            4.2.3.2 User modes ....................................   22
         4.2.4 Topic message ......................................   23
         4.2.5 Names message ......................................   24
         4.2.6 List message .......................................   24
         4.2.7 Invite message .....................................   25
         4.2.8 Kick message .......................................   25
      4.3 Server queries and commands .............................   26
         4.3.1 Version message ....................................   26
         4.3.2 Stats message ......................................   27
         4.3.3 Links message ......................................   28
         4.3.4 Time message .......................................   29
         4.3.5 Connect message ....................................   29
         4.3.6 Trace message ......................................   30
         4.3.7 Admin message ......................................   31
         4.3.8 Info message .......................................   31
      4.4 Sending messages ........................................   32
         4.4.1 Private messages ...................................   32
         4.4.2 Notice messages ....................................   33
      4.5 User-based queries ......................................   33
         4.5.1 Who query ..........................................   33
         4.5.2 Whois query ........................................   34
         4.5.3 Whowas message .....................................   35
      4.6 Miscellaneous messages ..................................   35
         4.6.1 Kill message .......................................   36
         4.6.2 Ping message .......................................   37
         4.6.3 Pong message .......................................   37
         4.6.4 Error message ......................................   38
   5. OPTIONAL MESSAGES ...........................................   38
      5.1 Away message ............................................   38
      5.2 Rehash command ..........................................   39
      5.3 Restart command .........................................   39
      5.4 Summon message ..........................................   40
      5.5 Users message ...........................................   40
      5.6 Operwall command ........................................   41
      5.7 Userhost message ........................................   42
      5.8 Ison message ............................................   42
   6. REPLIES .....................................................   43
      6.1 Error Replies ...........................................   43
      6.2 Command responses .......................................   48
      6.3 Reserved numerics .......................................   56
   7. Client and server authentication ............................   56
   8. Current Implementations Details .............................   56
      8.1 Network protocol: TCP ...................................   57
         8.1.1 Support of Unix sockets ............................   57
      8.2 Command Parsing .........................................   57
      8.3 Message delivery ........................................   57
      8.4 Connection 'Liveness' ...................................   58
      8.5 Establishing a server-client connection .................   58
      8.6 Establishing a server-server connection .................   58
         8.6.1 State information exchange when connecting .........   59
      8.7 Terminating server-client connections ...................   59
      8.8 Terminating server-server connections ...................   59
      8.9 Tracking nickname changes ...............................   60
      8.10 Flood control of clients ...............................   60
      8.11 Non-blocking lookups ...................................   61
         8.11.1 Hostname (DNS) lookups ............................   61
         8.11.2 Username (Ident) lookups ..........................   61
      8.12 Configuration file .....................................   61
         8.12.1 Allowing clients to connect .......................   62
         8.12.2 Operators .........................................   62
         8.12.3 Allowing servers to connect .......................   62
         8.12.4 Administrivia .....................................   63
      8.13 Channel membership .....................................   63
   9. Current problems ............................................   63
      9.1 Scalability .............................................   63
      9.2 Labels ..................................................   63
         9.2.1 Nicknames ..........................................   63
         9.2.2 Channels ...........................................   64
         9.2.3 Servers ............................................   64
      9.3 Algorithms ..............................................   64
   10. Support and availability ...................................   64
   11. Security Considerations ....................................   65
   12. Authors' Addresses .........................................   65
```

---
## **1.  INTRODUCTION**

IRC\(인터넷 릴레이 채팅\) 프로토콜은 텍스트 기반 회의에 사용하기 위해 수년에 걸쳐 설계되었습니다. 이 문서는 현재 IRC 프로토콜을 설명합니다.

IRC 프로토콜은 TCP/IP 네트워크 프로토콜을 사용하는 시스템에서 개발되었지만 이것이 작동하는 유일한 영역으로 남아 있어야 한다는 요구 사항은 없습니다.

IRC 자체는 \(클라이언트-서버 모델을 사용하여\) 많은 시스템에서 분산 방식으로 실행하는 데 적합한 원격 회의 시스템입니다. 일반적인 설정에는 클라이언트\(또는 다른 서버\)가 연결할 중앙 지점을 형성하고 필요한 메시지 전달/다중화 및 기타 기능을 수행하는 단일 프로세스\(서버\)가 포함됩니다.

---
## **1.1 Servers**

서버는 IRC의 백본을 형성하여 클라이언트가 서로 대화하기 위해 연결할 수 있는 지점과 다른 서버가 연결할 수 있는 지점을 제공하여 IRC 네트워크를 형성합니다. IRC 서버에 허용되는 유일한 네트워크 구성은 각 서버가 보는 나머지 네트워크에 대한 중앙 노드 역할을 하는 스패닝 트리\(그림 1 참조\)의 구성입니다.

```text
                           [ Server 15 ]  [ Server 13 ] [ Server 14]
                                 /                \         /
                                /                  \       /
        [ Server 11 ] ------ [ Server 1 ]       [ Server 12]
                              /        \          /
                             /          \        /
                  [ Server 2 ]          [ Server 3 ]
                    /       \                      \
                   /         \                      \
           [ Server 4 ]    [ Server 5 ]         [ Server 6 ]
            /    |    \                           /
           /     |     \                         /
          /      |      \____                   /
         /       |           \                 /
 [ Server 7 ] [ Server 8 ] [ Server 9 ]   [ Server 10 ]

                                  :
                               [ etc. ]
                                  :
```

- \[ 그림 1. IRC 서버 네트워크 구성 \]

---
## **1.2 Clients**

클라이언트는 다른 서버가 아닌 서버에 연결되는 모든 것입니다. 각 클라이언트는 최대 9자의 고유한 별명으로 다른 클라이언트와 구별됩니다. 닉네임에 사용할 수 있는 것과 사용하지 않을 수 있는 것에 대한 프로토콜 문법 규칙을 참조하세요. 별명 외에도 모든 서버에는 모든 클라이언트에 대한 다음 정보가 있어야 합니다. 즉, 클라이언트가 실행 중인 호스트의 실제 이름, 해당 호스트에 있는 클라이언트의 사용자 이름, 클라이언트가 연결된 서버입니다.

---
### **1.2.1 Operators**

IRC 네트워크 내에서 합리적인 양의 주문을 유지하기 위해 특별한 클래스의 클라이언트\(운영자\)가 네트워크에서 일반적인 유지 관리 기능을 수행하도록 허용됩니다. 운영자에게 부여된 권한은 '위험'하다고 간주될 수 있지만 그럼에도 불구하고 필수입니다. 운영자는 잘못된 네트워크 라우팅의 장기간 사용을 방지하기 위해 필요에 따라 서버 연결을 끊고 다시 연결하는 등 기본적인 네트워크 작업을 수행할 수 있어야 합니다. 이러한 필요성을 인식하여, 여기에 논의된 프로토콜은 운영자가 그러한 기능을 수행할 수만 있도록 제공합니다. 섹션 4.1.7\(SQUIT\) 및 4.3.5\(CONNECT\)를 참조하세요.

더 논란이 되는 운영자의 권한은 '강제로' 연결된 네트워크에서 사용자를 제거할 수 있는 능력입니다. 즉, 운영자는 클라이언트와 서버 간의 연결을 닫을 수 있습니다. 남용은 파괴적이고 성가시기 때문에 이에 대한 정당화는 미묘합니다. 이러한 유형의 작업에 대한 자세한 내용은 섹션 4.6.1\(KILL\)을 참조하세요.

---
## **1.3 Channels**

채널은 해당 채널로 주소가 지정된 메시지를 모두 수신하는 하나 이상의 클라이언트로 구성된 명명된 그룹입니다. 채널은 첫 번째 클라이언트가 참여할 때 암시적으로 생성되고, 마지막 클라이언트가 채널을 떠날 때 채널은 더 이상 존재하지 않습니다. 채널이 존재하는 동안 모든 클라이언트는 채널 이름을 사용하여 채널을 참조할 수 있습니다.

채널 이름은 최대 200자 길이의 문자열\('&' 또는 '#' 문자로 시작\)입니다. 첫 번째 문자가 '&' 또는 '#'이어야 한다는 요구 사항을 제외하고; 채널 이름에 대한 유일한 제한은 공백\(' '\), 컨트롤 G\(^G 또는 ASCII 7\) 또는 프로토콜에서 목록 항목 구분 기호로 사용되는 쉼표\(','\)를 포함할 수 없다는 것입니다. .

이 프로토콜에서는 두 가지 유형의 채널이 허용됩니다. 하나는 모든 서버에 알려진 분산 채널입니다.

네트워크에 연결되었습니다. 이러한 채널은 채널이 존재하는 서버의 유일한 클라이언트가 채널에 참여할 수 있다는 첫 번째 문자로 표시됩니다. 이는 선행 '&' 문자로 구별됩니다. 이 두 가지 유형 외에도 개별 채널의 특성을 변경하는 데 사용할 수 있는 다양한 채널 모드가 있습니다. 이에 대한 자세한 내용은 섹션 4.2.3\(MODE 명령\)을 참조하십시오.

새 채널을 만들거나 기존 채널의 일부가 되려면 사용자는 채널에 가입해야 합니다. 가입하기 전에 채널이 존재하지 않으면 채널이 생성되고 생성한 사용자가 채널 운영자가 됩니다. 채널이 이미 존재하는 경우 해당 채널에 대한 JOIN 요청이 수락되는지 여부는 채널의 현재 모드에 따라 다릅니다. 예를 들어 채널이 초대 전용인 경우\(+i\) 초대를 받은 경우에만 참여할 수 있습니다. 프로토콜의 일부로 사용자는 동시에 여러 채널의 일부가 될 수 있지만 숙련된 사용자와 초보 사용자 모두에게 충분한 채널 수는 10개로 제한되는 것이 좋습니다. 이에 대한 자세한 내용은 섹션 8.13을 참조하십시오.

두 서버 간의 분할로 인해 IRC 네트워크가 분리되면 각 측면의 채널은 분할된 각 측면의 서버에 연결된 클라이언트로만 구성되며 분할된 한쪽에서는 더 이상 존재하지 않을 수도 있습니다. 분할이 치유되면 연결 서버는 각 채널에 있다고 생각되는 사람과 해당 채널의 모드를 서로에게 알립니다. 채널이 양쪽에 존재하는 경우 JOIN 및 MODE는 포괄적인 방식으로 해석되어 새 연결의 양쪽이 채널에 있는 클라이언트와 채널의 모드에 대해 동의하게 됩니다.

---
### **1.3.1 Channel Operators**

특정 채널의 채널 운영자\("chop" 또는 "chanop"라고도 함\)는 해당 채널을 '소유'하는 것으로 간주됩니다. 이러한 상태를 인식하여 채널 운영자에게는 채널에 대한 통제력과 일종의 건전성을 유지할 수 있는 특정 권한이 부여됩니다. 채널 소유자로서 채널 운영자는 자신의 행동에 대한 이유를 요구하지 않습니다. 하지만 그들의 행동이 일반적으로 반사회적이거나 기타 폭력적인 경우 IRC 운영자에게 개입을 요청하거나 사용자가 그냥 나가고 가는 것이 합리적일 수 있습니다. 다른 곳에서 자신의 채널을 형성합니다.

채널 운영자만 사용할 수 있는 명령은 다음과 같습니다.

```text
        KICK    - Eject a client from the channel
        MODE    - Change the channel's mode
        INVITE  - Invite a client to an invite-only channel (mode +i)
        TOPIC   - Change the channel topic in a mode +t channel
```

채널 운영자는 채널과 연결될 때마다\(예: NAMES, WHO 및 WHOIS 명령에 응답\) 별명 옆에 '@' 기호로 식별됩니다.

---
## **2. The IRC Specification**
---
## **2.1 Overview**

여기에 설명된 프로토콜은 서버 대 서버 연결과 클라이언트 대 서버 연결 모두에 사용됩니다. 그러나 클라이언트 연결\(신뢰할 수 없는 것으로 간주됨\)에는 서버 연결보다 더 많은 제한이 있습니다.

---
## **2.2 Character codes**

특정 문자 집합이 지정되지 않았습니다. 프로토콜은 옥텟을 구성하는 8비트로 구성된 코드 세트를 기반으로 합니다. 각 메시지는 이러한 옥텟으로 구성될 수 있습니다. 그러나 일부 옥텟 값은 메시지 구분 기호 역할을 하는 제어 코드에 사용됩니다.

8비트 프로토콜임에도 불구하고 구분 기호와 키워드는 USASCII 터미널과 텔넷 연결에서 프로토콜을 대부분 사용할 수 있도록 되어 있습니다.

IRC는 스칸디나비아 출신이기 때문에 문자 {}| 각각 \[\]\ 문자에 해당하는 소문자로 간주됩니다. 이는 두 별명의 동등성을 결정할 때 중요한 문제입니다.

---
## **2.3 Messages**

서버와 클라이언트는 응답을 생성할 수도 있고 생성하지 않을 수도 있는 메시지를 서로 보냅니다. 이후 섹션에 설명된 대로 메시지에 유효한 명령이 포함된 경우 클라이언트는 지정된 대로 응답을 기대해야 하지만 응답을 영원히 기다리는 것은 권장되지 않습니다. 클라이언트에서 서버로, 서버에서 서버로의 통신은 본질적으로 비동기적입니다.

각 IRC 메시지는 접두사\(선택 사항\), 명령 및 명령 매개 변수\(최대 15개\)의 세 가지 주요 부분으로 구성될 수 있습니다. 접두사, 명령 및 모든 매개변수는 하나 이상의 ASCII 공백 문자\(0x20\)로 구분됩니다.

접두어의 존재는 메시지 자체의 첫 번째 문자여야 하는 단일 선행 ASCII 콜론 문자\(':', 0x3b\)로 표시됩니다. 콜론과 접두사 사이에는 공백\(공백\)이 없어야 합니다. 접두사는 서버에서 실제 내용을 나타내는 데 사용됩니다.

메시지의 출처. 접두사가 메시지에 누락된 경우 접두사는 수신된 연결에서 시작된 것으로 간주됩니다. 클라이언트는 자신에게서 메시지를 보낼 때 접두사를 사용해서는 안 됩니다. 접두사를 사용하는 경우 유일한 유효한 접두사는 클라이언트와 연결된 등록된 별명입니다. 접두어로 식별된 소스를 서버의 내부 데이터베이스에서 찾을 수 없거나 소스가 메시지가 도착한 링크와 다른 링크에서 등록된 경우 서버는 메시지를 자동으로 무시해야 합니다.

명령은 유효한 IRC 명령이거나 ASCII 텍스트로 표시되는 3자리 숫자여야 합니다.

IRC 메시지는 항상 CR-LF\(캐리지 리턴 - 라인 피드\) 쌍으로 끝나는 문자 라인이며, 이러한 메시지 길이는 후행 CR-LF를 포함한 모든 문자를 포함하여 512자를 초과할 수 없습니다. 따라서 명령과 해당 매개변수에 허용되는 최대 문자 수는 510자입니다. 연속 메시지 라인에 대한 규정은 없습니다. 현재 구현에 대한 자세한 내용은 섹션 7을 참조하세요.

---
### **2.3.1 Message format in 'pseudo' BNF**

프로토콜 메시지는 연속적인 옥텟 스트림에서 추출되어야 합니다. 현재 해결 방법은 CR과 LF라는 두 문자를 메시지 구분 기호로 지정하는 것입니다. 빈 메시지는 자동으로 무시되므로 추가 문제 없이 메시지 사이에 CR-LF 시퀀스를 사용할 수 있습니다.

추출된 메시지는 <prefix\>, <command\> 구성 요소와 <middle\> 또는 <trailing\> 구성 요소와 일치하는 매개 변수 목록으로 구문 분석됩니다.

이에 대한 BNF 표현은 다음과 같습니다.

```text
<message>  ::= [':' <prefix> <SPACE> ] <command> <params> <crlf>
<prefix>   ::= <servername> | <nick> [ '!' <user> ] [ '@' <host> ]
<command>  ::= <letter> { <letter> } | <number> <number> <number>
<SPACE>    ::= ' ' { ' ' }
<params>   ::= <SPACE> [ ':' <trailing> | <middle> <params> ]
```

<middle\> ::= <SPACE, NUL, CR 또는 LF를 포함하지 않는 \*비어 있지 않은\* 옥텟 시퀀스, 첫 번째는 ':'이 될 수 없음\>
<후행\> ::= <NUL, CR 또는 LF를 포함하지 않는 모든, 아마도 \*비어\* 있는 옥텟 시퀀스\>

```text
<crlf>     ::= CR LF
```

---
# **NOTES:**

1\) <SPACE\>는 SPACE 문자\(0x20\)로만 구성됩니다. 특히 TABULATION 및 기타 모든 제어 문자는 NON-WHITE-SPACE로 간주됩니다.

2\) 매개변수 목록을 추출한 후 <middle\> 또는 <trailing\>과 일치하는지 여부에 관계없이 모든 매개변수가 동일합니다. <Trailing\>은 매개변수 내에 SPACE를 허용하는 구문적 트릭일 뿐입니다.

3\) CR 및 LF가 매개변수 문자열에 나타날 수 없다는 사실은 메시지 프레이밍의 인공물일 뿐입니다. 이는 나중에 변경될 수 있습니다.

4\) NUL 문자는 메시지 프레이밍에서 특별하지 않으며 기본적으로 매개변수 내부에 포함될 수 있지만 일반적인 C 문자열 처리에서는 추가적인 복잡성을 야기합니다. 따라서 메시지 내에서는 NUL이 허용되지 않습니다.

5\) 마지막 매개변수는 빈 문자열일 수 있습니다.

6\) 확장 접두사\(\['!' <user\> \] \['@' <host\> \]\)의 사용은 서버 간 통신에 사용되어서는 안 되며 클라이언트에게 더 많은 정보를 제공하기 위해 서버 간 메시지에만 사용됩니다. 추가 쿼리 없이도 메시지가 누구에게서 왔는지에 대한 유용한 정보를 제공합니다.

대부분의 프로토콜 메시지는 목록에서의 위치에 따라 추출된 매개변수 문자열에 대한 추가 의미 및 구문을 지정합니다. 예를 들어, 많은 서버 명령은 명령 뒤의 첫 번째 매개변수가 대상 목록이라고 가정합니다. 이는 다음으로 설명할 수 있습니다.

<대상\> ::= <대상\> \[ "," <대상\> \] <대상\> ::= <채널\> | <사용자\> '@' <서버 이름\> | <닉네임\> | <mask\> <channel\> ::= \('#' | '&'\) <chstring\> <servername\> ::= <host\> <host\> ::= 허용되는 호스트 이름에 대한 자세한 내용은 RFC 952 \[DNS:4\]를 참조하세요. < 닉\> ::= <문자\> { <문자\> | <번호\> | <special\> } <mask\> ::= \('#' | '$'\) <chstring\> <chstring\> ::= <SPACE, BELL, NUL, CR, LF 및 쉼표\(','\)를 제외한 모든 8비트 코드\>

```text
   Other parameter syntaxes are:

   <user>       ::= <nonwhite> { <nonwhite> }
   <letter>     ::= 'a' ... 'z' | 'A' ... 'Z'
   <number>     ::= '0' ... '9'
   <special>    ::= '-' | '[' | ']' | '\' | '`' | '^' | '{' | '}'
```

<nonwhite\> ::= <SPACE\(0x20\), NUL\(0x0\), CR\(0xd\), LF\(0xa\)를 제외한 모든 8비트 코드\>

---
## **2.4 Numeric replies**

서버로 전송되는 대부분의 메시지는 일종의 응답을 생성합니다. 가장 일반적인 응답은 오류 및 일반 응답 모두에 사용되는 숫자 응답입니다. 숫자 응답은 보낸 사람 접두사, 세 자리 숫자 및 응답 대상으로 구성된 하나의 메시지로 전송되어야 합니다. 숫자 응답은 클라이언트에서 시작될 수 없습니다. 서버에서 수신한 모든 메시지는 자동으로 삭제됩니다. 다른 모든 측면에서 숫자 응답은 키워드가 일련의 문자가 아닌 3자리 숫자로 구성된다는 점을 제외하면 일반 메시지와 같습니다. 다양한 답변 목록은 섹션 6에 나와 있습니다.

---
## **3. IRC Concepts.**

이 섹션에서는 IRC 프로토콜 구성의 실제 개념과 현재 구현이 다양한 메시지 클래스를 전달하는 방법을 설명합니다.

```text
                          1--\
                              A        D---4
                          2--/ \      /
                                B----C
                               /      \
                              3        E

   Servers: A, B, C, D, E         Clients: 1, 2, 3, 4

                    [ Fig. 2. Sample small IRC network ]
```

---
## **3.1 One-to-one communication**

일대일 통신은 일반적으로 클라이언트에 의해서만 수행됩니다. 왜냐하면 대부분의 서버 간 트래픽은 서버가 서로 통신한 결과가 아니기 때문입니다. 클라이언트가 서로 통신할 수 있는 안전한 수단을 제공하려면 모든 서버가 클라이언트에 도달하기 위해 스패닝 트리를 따라 정확히 한 방향으로 메시지를 보낼 수 있어야 합니다. 전달되는 메시지의 경로는 스패닝 트리의 두 지점 사이의 최단 경로입니다.

다음 예는 모두 위의 그림 2를 참조합니다.

예 1: 클라이언트 1과 2 사이의 메시지는 서버 A에서만 볼 수 있으며 서버 A는 이를 클라이언트 2로 직접 보냅니다.

예 2: 클라이언트 1과 3 사이의 메시지는 서버 A & B와 클라이언트 3에 표시됩니다. 다른 클라이언트나 서버는 메시지를 볼 수 없습니다.

예제 3: 클라이언트 2와 4 사이의 메시지는 서버 A, B, C, D와 클라이언트 4에서만 볼 수 있습니다.

---
## **3.2 One-to-many**

IRC의 주요 목표는 쉽고 효율적인 회의\(일대다 대화\)가 가능한 포럼을 제공하는 것입니다. IRC는 이를 달성하기 위한 여러 가지 수단을 제공하며 각각은 고유한 목적을 달성합니다.

---
### **3.2.1 To a list**

일대다 대화의 가장 효율적인 스타일은 클라이언트가 사용자 '목록'과 대화하는 것입니다. 이 작업이 수행되는 방법은 거의 자명합니다. 클라이언트는 메시지가 전달될 대상 목록을 제공하고 서버는 이를 분할하여 지정된 각 대상에 별도의 메시지 복사본을 전달합니다. 이는 대상 목록이 분할되고 중복 항목이 각 경로로 전송되지 않는지 확인하지 않고 발송되기 때문에 그룹을 사용하는 것만큼 효율적이지 않습니다.

---
### **3.2.2 To a group (channel)**

IRC에서 채널은 멀티캐스트 그룹과 동일한 역할을 갖습니다. 이들의 존재는 동적\(사람들이 채널에 가입하고 탈퇴함에 따라 왔다 갔다 함\)이며 채널에서 수행되는 실제 대화는 특정 채널에서 사용자를 지원하는 서버로만 전송됩니다. 동일한 채널의 서버에 여러 사용자가 있는 경우 메시지 텍스트는 해당 서버로 한 번만 전송된 다음 채널의 각 클라이언트로 전송됩니다. 그런 다음 원본 메시지가 펼쳐져 채널의 각 구성원에 도달할 때까지 각 클라이언트-서버 조합에 대해 이 작업이 반복됩니다.

다음 예는 모두 그림 2를 참조합니다.

예 4: 클라이언트가 1개인 모든 채널. 채널에 대한 메시지는 서버로 이동한 후 다른 곳으로 이동하지 않습니다.

예시 5: 채널에 2개의 클라이언트가 있습니다. 모든 메시지는 마치 채널 외부의 두 클라이언트 사이의 비공개 메시지인 것처럼 경로를 통과합니다.

예 6: 채널의 클라이언트 1, 2, 3. 채널에 대한 모든 메시지는 모든 클라이언트로 전송되며, 단일 클라이언트에 대한 개인 메시지인 경우 메시지가 통과해야 하는 서버에만 전송됩니다. 클라이언트 1이 메시지를 보내면 클라이언트 2로 돌아가고 서버 B를 통해 클라이언트 3으로 돌아갑니다.

---
### **3.2.3 To a host/server mask**

IRC 운영자에게 대규모 관련 사용자에게 메시지를 보내는 메커니즘을 제공하기 위해 호스트 및 서버 마스크 메시지가 제공됩니다. 이 메시지는 마스크의 호스트 또는 서버 정보와 일치하는 사용자에게 전송됩니다. 메시지는 채널과 유사한 방식으로 사용자가 있는 위치로만 전송됩니다.

---
## **3.3 One-to-all**

일대다 유형의 메시지는 모든 클라이언트나 서버 또는 둘 다에 전송되는 브로드캐스트 메시지로 더 잘 설명됩니다. 사용자와 서버로 구성된 대규모 네트워크에서는 단일 메시지로 인해 원하는 모든 대상에 도달하기 위해 네트워크를 통해 많은 트래픽이 전송될 수 있습니다.

일부 메시지의 경우 각 서버가 보유한 상태 정보가 서버 간에 합리적으로 일관되도록 모든 서버에 브로드캐스트하는 것 외에는 옵션이 없습니다.

---
### **3.3.1 Client-to-Client**

단일 메시지에서 다른 모든 클라이언트로 메시지가 전송되는 메시지 클래스는 없습니다.

---
### **3.3.2 Client-to-Server**

상태 정보\(예: 채널 멤버십, 채널 모드, 사용자 상태 등\)를 변경하는 대부분의 명령은 기본적으로 모든 서버에 전송되어야 하며 이 배포는 클라이언트에 의해 변경될 수 없습니다.

---
### **3.3.3 Server-to-Server.**

서버 간 대부분의 메시지는 모든 '다른' 서버에 배포되지만 이는 사용자, 채널 또는 서버에 영향을 미치는 모든 메시지에만 필요합니다. 기본적으로 들어있는 아이템들이기 때문에

IRC, 서버에서 발생하는 거의 모든 메시지는 연결된 다른 모든 서버로 브로드캐스트됩니다.

---
## **4. Message details**

다음 페이지에는 IRC 서버와 클라이언트가 인식하는 각 메시지에 대한 설명이 있습니다. 이 섹션에 설명된 모든 명령은 이 프로토콜에 대한 모든 서버에서 구현되어야 합니다.

ERR\_NOSUCHSERVER 응답이 나열된 경우 이는 <server\> 매개변수를 찾을 수 없음을 의미합니다. 서버는 해당 명령에 대해 이후에 다른 응답을 보내서는 안 됩니다.

클라이언트가 연결된 서버는 전체 메시지를 구문 분석하여 적절한 오류를 반환해야 합니다. 서버가 메시지를 구문 분석하는 동안 치명적인 오류가 발생하면 오류를 클라이언트로 다시 전송하고 구문 분석을 종료해야 합니다. 치명적인 오류는 잘못된 명령, 서버에 알려지지 않은 대상\(서버, 별명 또는 채널 이름이 이 범주에 해당\), 매개변수가 충분하지 않거나 잘못된 권한으로 간주될 수 있습니다.

전체 매개변수 세트가 제공되면 각 매개변수의 유효성을 확인하고 적절한 응답을 클라이언트로 다시 보내야 합니다. 쉼표를 항목 구분 기호로 사용하는 매개변수 목록을 사용하는 메시지의 경우 항목별로 응답을 보내야 합니다.

아래 예에서 일부 메시지는 전체 형식을 사용하여 표시됩니다.

```text
   :Name COMMAND parameter list
```

이러한 예는 서버 간에 전송되는 "이름"의 메시지를 나타내며, 원격 서버가 올바른 경로를 따라 응답을 다시 보낼 수 있도록 메시지의 원래 보낸 사람의 이름을 포함하는 것이 중요합니다.

---
## **4.1 Connection Registration**

여기에 설명된 명령은 IRC 서버와의 연결을 사용자 또는 서버로 등록하고 올바르게 연결을 끊는 데 사용됩니다.

"PASS" 명령은 클라이언트 또는 서버 연결을 등록하는 데 필요하지 않지만 서버 메시지 또는 NICK/USER 조합의 후자 앞에 와야 합니다. 실제 연결에 일정 수준의 보안을 제공하려면 모든 서버 연결에 비밀번호를 사용하는 것이 좋습니다. 클라이언트의 권장 등록 순서는 다음과 같습니다.

```text
           1. Pass message
           2. Nick message
           3. User message
```

---
### **4.1.1 Password message**

```text
      Command: PASS
   Parameters: <password>
```

PASS 명령은 '연결 비밀번호'를 설정하는 데 사용됩니다. 연결 등록을 시도하기 전에 비밀번호를 설정할 수 있으며 설정해야 합니다. 현재 이를 위해서는 클라이언트가 NICK/USER 조합을 보내기 전에 PASS 명령을 보내야 하며 서버는 \*반드시\* SERVER 명령 전에 PASS 명령을 보내야 합니다. 제공된 비밀번호는 C/N 라인\(서버의 경우\) 또는 I 라인\(클라이언트의 경우\)에 포함된 비밀번호와 일치해야 합니다. 등록하기 전에 여러 개의 PASS 명령을 보낼 수 있지만 마지막에 보낸 명령만 확인에 사용되며 등록 후에는 변경할 수 없습니다. 숫자 답장:

```text
           ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED

   Example:

           PASS secretpasswordhere
```

---
### **4.1.2 Nick message**

```text
      Command: NICK
   Parameters: <nickname> [ <hopcount> ]
```

NICK 메시지는 사용자에게 닉네임을 부여하거나 이전 닉네임을 변경할 때 사용됩니다. <hopcount\> 매개변수는 홈 서버에서 닉이 얼마나 멀리 떨어져 있는지를 나타내기 위해 서버에서만 사용됩니다. 로컬 연결의 홉 수는 0입니다. 클라이언트가 제공한 경우 무시해야 합니다.

다른 클라이언트의 동일한 닉네임을 이미 알고 있는 서버에 NICK 메시지가 도착하면 닉네임 충돌이 발생합니다. 별명 충돌의 결과로 별명의 모든 인스턴스가 서버의 데이터베이스에서 제거되고 KILL 명령이 실행되어 다른 모든 서버의 데이터베이스에서 별명을 제거합니다. 충돌을 일으키는 NICK 메시지가 닉네임 변경인 경우 원래\(이전\) 닉도 제거해야 합니다.

서버가 직접 연결된 클라이언트로부터 동일한 NICK를 수신하면 로컬 클라이언트에 ERR\_NICKCOLLISION을 발행하고 NICK 명령을 삭제하고 종료를 생성하지 않을 수 있습니다.

```text
   Numeric Replies:

           ERR_NONICKNAMEGIVEN             ERR_ERRONEUSNICKNAME
           ERR_NICKNAMEINUSE               ERR_NICKCOLLISION

   Example:

   NICK Wiz                        ; Introducing new nick "Wiz".
```

:WIZ NICK 킬로이 ; WiZ는 별명을 Kilroy로 바꿨습니다.

---
### **4.1.3 User message**

```text
      Command: USER
   Parameters: <username> <hostname> <servername> <realname>
```

USER 메시지는 연결 시작 시 새 사용자의 사용자 이름, 호스트 이름, 서버 이름 및 실제 이름을 지정하는 데 사용됩니다. 또한 USER와 NICK가 클라이언트로부터 수신된 후에만 사용자가 등록되기 때문에 IRC에 도착하는 새 사용자를 나타내기 위해 서버 간 통신에도 사용됩니다.

서버 간 USER 앞에는 클라이언트의 NICKname이 붙어야 합니다. USER 명령이 직접 연결된 클라이언트에서 올 때\(보안상의 이유로\) 호스트 이름과 서버 이름은 일반적으로 IRC 서버에 의해 무시되지만 서버 간 통신에는 사용됩니다. 이는 새로운 사용자가 네트워크의 나머지 부분에 소개될 때 동행하는 USER가 전송되기 전에 NICK가 항상 원격 서버로 전송되어야 함을 의미합니다.

realname 매개변수는 공백 문자를 포함할 수 있고 이것이 인식되도록 하려면 콜론\(':'\) 접두어를 붙여야 하기 때문에 마지막 매개변수여야 한다는 점에 유의해야 합니다.

클라이언트가 USER 메시지에만 의존하여 사용자 이름에 대해 거짓말을 하기가 쉽기 때문에 "Identity Server"를 사용하는 것이 좋습니다. 사용자가 연결하는 호스트에 이러한 서버가 활성화되어 있으면 사용자 이름은 "Identity Server"의 응답에서와 같이 설정됩니다.

```text
   Numeric Replies:

           ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED

   Examples:

   USER guest tolmoon tolsun :Ronnie Reagan
```

- ; 사용자 이름은 "guest"이고 실명은 "Ronnie Reagan"으로 등록된 사용자입니다.

:testnick USER 게스트 tolmoon tolsun :Ronnie Reagan

- ; USER 명령이 속한 별명을 가진 서버 간 메시지

---
### **4.1.4 Server message**

```text
      Command: SERVER
   Parameters: <servername> <hopcount> <info>
```

서버 메시지는 새 연결의 다른 쪽 끝이 서버임을 서버에 알리는 데 사용됩니다. 이 메시지는 전체 네트워크를 통해 서버 데이터를 전달하는 데에도 사용됩니다. 새로운 서버가 네트워크에 연결되면 해당 서버에 대한 정보가 전체 네트워크에 방송됩니다. <hopcount\>는 모든 서버가 얼마나 멀리 떨어져 있는지에 대한 내부 정보를 모든 서버에 제공하는 데 사용됩니다. 전체 서버 목록을 사용하면 전체 서버 트리의 맵을 구성할 수 있지만 호스트 마스크로 인해 이 작업이 수행되지 않습니다.

SERVER 메시지는 \(a\) 아직 등록되지 않았으며 서버로 등록을 시도 중인 연결 또는 \(b\) 다른 서버에 대한 기존 연결에서만 허용되어야 합니다. 이 경우 SERVER 메시지는 새로운 연결을 도입합니다. 그 서버 뒤에 있는 서버.

SERVER 명령을 수신할 때 발생하는 대부분의 오류는 대상 호스트\(대상 SERVER\)에 의해 연결이 종료되는 결과를 낳습니다. 오류 응답은 일반적으로 숫자 대신 "ERROR" 명령을 사용하여 전송됩니다. ERROR 명령에는 여기에서 유용하게 사용되는 몇 가지 유용한 속성이 있기 때문입니다.

SERVER 메시지가 구문 분석되어 수신 서버에 이미 알려진 서버를 도입하려고 시도하는 경우 서버에 대한 중복 경로가 형성되고 비순환적 특성이 있으므로 해당 메시지의 연결을 닫아야 합니다\(올바른 절차에 따라\). IRC 트리가 깨졌습니다.

```text
   Numeric Replies:

           ERR_ALREADYREGISTRED

   Example:
```

SERVER test.oulu.fi 1 :\[tolsun.oulu.fi\] 실험용 서버 ; 새로운 서버 test.oulu.fi가 자신을 소개하고 등록을 시도하고 있습니다. \[\] 안의 이름은 test.oulu.fi를 실행하는 호스트의 호스트 이름입니다.

:tolsun.oulu.fi 서버 csd.bu.edu 5 :BU 중앙 서버 ; 서버 tolsun.oulu.fi는 5홉 거리에 있는 csd.bu.edu에 대한 업링크입니다.

---
### **4.1.5 Oper**

```text
      Command: OPER
   Parameters: <user> <password>
```

OPER 메시지는 일반 사용자가 운영자 권한을 얻기 위해 사용됩니다. 운영자 권한을 얻으려면 <user\>와 <password\>의 조합이 필요합니다.

OPER 명령을 보내는 클라이언트가 지정된 사용자에 대한 올바른 비밀번호를 제공하면 서버는 클라이언트 별명에 대해 "MODE +o"를 발행하여 나머지 네트워크에 새 운영자를 알립니다.

OPER 메시지는 클라이언트-서버 전용입니다.

```text
   Numeric Replies:

           ERR_NEEDMOREPARAMS              RPL_YOUREOPER
           ERR_NOOPERHOST                  ERR_PASSWDMISMATCH

   Example:
```

OPER 푸 바 ; 사용자 이름 "foo"와 "bar"를 비밀번호로 사용하여 운영자 등록을 시도합니다.

---
### **4.1.6 Quit**

```text
      Command: QUIT
   Parameters: [<Quit message>]
```

클라이언트 세션은 종료 메시지와 함께 종료됩니다. 서버는 QUIT 메시지를 보내는 클라이언트에 대한 연결을 닫아야 합니다. "종료 메시지"가 제공되면 기본 메시지인 닉네임 대신 이것이 전송됩니다.

netsplit\(두 서버의 연결 끊김\)이 발생하면 종료 메시지가 나타납니다.

관련된 두 서버의 이름으로 구성되며 공백으로 구분됩니다. 첫 번째 이름은 아직 연결되어 있는 서버의 이름이고 두 번째 이름은 연결이 끊어진 서버의 이름입니다.

다른 이유로 인해 클라이언트가 QUIT 명령을 실행하지 않고 클라이언트 연결이 닫히면\(예: 클라이언트가 종료되고 소켓에서 EOF가 발생함\) 서버는 종료 메시지를 클라이언트 연결의 성격을 반영하는 일종의 메시지로 채워야 합니다. 그 일이 일어나게 만든 사건.

```text
   Numeric Replies:

           None.

   Examples:
```

종료:점심을 먹으러 갔습니다. 선호하는 메시지 형식.

---
### **4.1.7 Server quit message**

```text
      Command: SQUIT
   Parameters: <server> <comment>
```

SQUIT 메시지는 종료되거나 죽은 서버에 대해 알려주는 데 필요합니다. 서버가 다른 서버에 대한 연결을 끊고 싶다면 다른 서버의 이름을 서버 매개변수로 사용하여 SQUIT 메시지를 다른 서버에 보내야 합니다. 그런 다음 종료하는 서버에 대한 연결을 닫습니다.

이 명령은 IRC 서버 네트워크를 질서정연하게 연결하는 데 도움이 되는 연산자로도 사용할 수 있습니다. 운영자는 원격 서버 연결에 대해 SQUIT 메시지를 발행할 수도 있습니다. 이 경우 SQUIT는 운영자와 원격 서버 사이의 각 서버에서 구문 분석되어 아래 설명과 같이 각 서버가 보유한 네트워크 보기를 업데이트해야 합니다.

<comment\>는 다른 운영자가 이 작업의 이유를 알 수 있도록 원격 서버\(현재 있는 서버에 연결되지 않은\)에 대해 SQUIT를 실행하는 모든 운영자가 제공해야 합니다. <comment\>는 서버에 의해 채워지므로 여기에 오류나 유사한 메시지가 표시될 수 있습니다.

닫히는 연결의 양쪽에 있는 두 서버는 해당 링크 뒤에 있는 것으로 간주되는 다른 모든 서버에 대해 \(다른 모든 서버 연결에\) SQUIT 메시지를 보내야 합니다.

마찬가지로 해당 링크 뒤에 있는 모든 클라이언트를 대신하여 네트워크의 나머지 연결된 다른 서버로 QUIT 메시지를 보내야 합니다. 또한, 분할로 인해 멤버를 잃은 채널의 모든 채널 멤버에게는 QUIT 메시지를 보내야 합니다.

서버 연결이 조기에 종료된 경우\(예: 링크의 다른 쪽 끝에 있는 서버가 종료된 경우\), 이 연결 끊김을 감지한 서버는 나머지 네트워크에 연결이 종료되었음을 알리고 주석 필드에 적절한 내용을 채워야 합니다. .

```text
   Numeric replies:

           ERR_NOPRIVILEGES                ERR_NOSUCHSERVER

   Example:
```

SQUIT tolsun.oulu.fi :잘못된 링크 ? ; "잘못된 링크"로 인해 서버 링크 tolson.oulu.fi가 종료되었습니다.

:Trillian SQUIT cm22.eng.umd.edu :서버 통제 불능

- ; "Server out of control" 때문에 "cm22.eng.umd.edu"를 네트워크에서 연결 해제하라는 Trillian의 메시지입니다.

---
## **4.2 Channel operations**

이 메시지 그룹은 채널, 해당 속성\(채널 모드\) 및 해당 콘텐츠\(일반적으로 클라이언트\) 조작과 관련됩니다. 이를 구현하는 데 있어서 네트워크의 반대편 끝에 있는 클라이언트가 궁극적으로 충돌하게 될 명령을 보낼 때 여러 가지 경쟁 조건이 불가피합니다. 또한 <nick\> 매개변수가 제공될 때마다 서버가 최근에 변경된 경우 해당 기록을 확인할 수 있도록 닉네임 기록을 유지해야 합니다.

---
### **4.2.1 Join message**

```text
      Command: JOIN
   Parameters: <channel>{,<channel>} [<key>{,<key>}]
```

JOIN 명령은 클라이언트가 특정 채널 청취를 시작하는 데 사용됩니다. 클라이언트의 채널 가입 허용 여부는 클라이언트가 연결된 서버에서만 확인됩니다. 다른 모든 서버는 다른 서버로부터 사용자가 수신되면 자동으로 채널에 사용자를 추가합니다. 이에 영향을 미치는 조건은 다음과 같습니다.

```text
           1.  the user must be invited if the channel is invite-only;

           2.  the user's nick/username/hostname must not match any
               active bans;
```

- 3. 설정된 경우 올바른 키\(비밀번호\)를 입력해야 합니다.

이에 대해서는 MODE 명령에서 자세히 설명합니다\(자세한 내용은 섹션 4.2.3 참조\).

사용자가 채널에 가입하면 서버가 수신하여 채널에 영향을 미치는 모든 명령에 대한 알림을 받습니다. 여기에는 MODE, KICK, PART, QUIT 및 PRIVMSG/NOTICE가 포함됩니다. JOIN 명령은 각 서버가 채널에 있는 사용자를 찾을 수 있는 위치를 알 수 있도록 모든 서버에 브로드캐스트되어야 합니다. 이를 통해 PRIVMSG/NOTICE 메시지를 채널에 최적으로 전달할 수 있습니다.

JOIN이 성공하면 사용자에게 채널의 주제\(RPL\_TOPIC 사용\)와 채널에 있는 사용자 목록\(RPL\_NAMREPLY 사용\)이 전송됩니다. 여기에는 참여하는 사용자가 포함되어야 합니다.

```text
   Numeric Replies:

           ERR_NEEDMOREPARAMS              ERR_BANNEDFROMCHAN
           ERR_INVITEONLYCHAN              ERR_BADCHANNELKEY
           ERR_CHANNELISFULL               ERR_BADCHANMASK
           ERR_NOSUCHCHANNEL               ERR_TOOMANYCHANNELS
           RPL_TOPIC

   Examples:

   JOIN #foobar                    ; join channel #foobar.

   JOIN &foo fubar                 ; join channel &foo using key "fubar".
```

JOIN #foo,&bar fubar ; "fubar" 키를 사용하여 채널 #foo에 가입하고 키 없이 &bar에 가입하세요.

JOIN #foo,#bar ​​fubar,foobar ; "fubar" 키를 사용하여 채널 #foo에 가입하세요. "foobar" 키를 사용하여 채널 #bar를 사용합니다.

조인 #foo,#bar ​​; 채널 #foo 및 #bar에 가입하세요.

```text
   :WiZ JOIN #Twilight_zone        ; JOIN message from WiZ
```

---
### **4.2.2 Part message**

```text
      Command: PART
   Parameters: <channel>{,<channel>}
```

PART 메시지는 메시지를 보내는 클라이언트가 매개변수 문자열에 나열된 모든 특정 채널의 활성 사용자 목록에서 제거되도록 합니다.

```text
   Numeric Replies:

           ERR_NEEDMOREPARAMS              ERR_NOSUCHCHANNEL
           ERR_NOTONCHANNEL

   Examples:

   PART #twilight_zone             ; leave channel "#twilight_zone"
```

부품 #oz-ops,&group5 ; 채널 "&group5" 및 "#oz-ops"를 모두 그대로 둡니다.

---
### **4.2.3 Mode message**

```text
      Command: MODE
```

MODE 명령은 IRC의 이중 목적 명령입니다. 사용자 이름과 채널 모두 모드를 변경할 수 있습니다. 이 선택의 근거는 언젠가는 닉네임이 더 이상 사용되지 않고 이에 상응하는 속성이 채널이 될 것이라는 것입니다.

MODE 메시지를 구문 분석할 때 전체 메시지를 먼저 구문 분석한 다음 그 결과로 발생한 변경 사항을 전달하는 것이 좋습니다.

---
#### **4.2.3.1 Channel modes**

```text
   Parameters: <channel> {[+|-]|o|p|s|i|t|n|b|v} [<limit>] [<user>]
               [<ban mask>]
```

MODE 명령은 채널 운영자가 '자신의' 채널의 특성을 변경할 수 있도록 제공됩니다. 또한 채널 운영자가 생성될 수 있도록 서버에서 채널 모드를 변경할 수 있어야 합니다.

채널에 사용할 수 있는 다양한 모드는 다음과 같습니다.

```text
           o - give/take channel operator privileges;
           p - private channel flag;
           s - secret channel flag;
           i - invite-only channel flag;
           t - topic settable by channel operator only flag;
           n - no messages to channel from clients on the outside;
           m - moderated channel;
           l - set the user limit to channel;
```

b - 사용자를 차단하기 위해 금지 마스크를 설정합니다.

- v - 조정된 채널에서 말할 수 있는 능력을 부여/취합니다. k - 채널 키\(비밀번호\)를 설정합니다.

'o' 및 'b' 옵션을 사용할 때 모드 명령당 총 3개로 제한되었습니다. 즉, 'o'와

---
#### **4.2.3.2 User modes**

```text
   Parameters: <nickname> {[+|-]|i|w|s|o}
```

사용자 모드는 일반적으로 다른 사람이 클라이언트를 보는 방식이나 클라이언트가 보내는 '추가' 메시지에 영향을 미치는 변경 사항입니다. 사용자 MODE 명령은 메시지를 보낸 사람과 매개변수로 제공된 별명이 모두 동일한 경우에만 허용됩니다.

사용 가능한 모드는 다음과 같습니다.

i - 사용자를 보이지 않는 것으로 표시합니다.

- s - 사용자에게 서버 알림 수신을 표시합니다. w - 사용자가 벽랍을 받습니다. o - 연산자 플래그.

나중에 추가 모드를 사용할 수 있습니다.

사용자가 "+o" 플래그를 사용하여 자신을 운영자로 만들려고 시도하면 해당 시도를 무시해야 합니다. 그러나 누구든지 스스로 '더핑'\("-o" 사용\)하는 데에는 제한이 없습니다. 숫자 답장:

```text
           ERR_NEEDMOREPARAMS              RPL_CHANNELMODEIS
           ERR_CHANOPRIVSNEEDED            ERR_NOSUCHNICK
           ERR_NOTONCHANNEL                ERR_KEYSET
           RPL_BANLIST                     RPL_ENDOFBANLIST
           ERR_UNKNOWNMODE                 ERR_NOSUCHCHANNEL

           ERR_USERSDONTMATCH              RPL_UMODEIS
           ERR_UMODEUNKNOWNFLAG

   Examples:
```

- 채널 모드 사용:

```text
MODE #Finnish +im               ; Makes #Finnish channel moderated and
                                'invite-only'.
```

---
# **MODE #Finnish +o Kilroy         ; Gives 'chanop' privileges to Kilroy on**

```text
                                channel #Finnish.
```

---
# **MODE #Finnish +v Wiz            ; Allow WiZ to speak on #Finnish.**

MODE #Fins -s ; 채널 #Fins에서 '비밀' 플래그를 제거합니다.

---
# **MODE #42 +k oulu                ; Set the channel key to "oulu".**

MODE #eu-opers +l 10 ; 채널의 사용자 수 제한을 10으로 설정합니다.

---
# **MODE &oulu +b                   ; list ban masks set for channel.**
---
# **MODE &oulu +b *!*@*             ; prevent all users from joining.**

MODE &oulu +b \*!\*@\*.edu ; \*.edu와 일치하는 호스트 이름을 가진 사용자가 참여하는 것을 방지합니다.

- 사용자 모드 사용:

:모드 WiZ -w ; WiZ에 대한 WALLOPS 메시지 수신을 끕니다.

:엔젤 모드 엔젤 +i ; 자신을 투명하게 만들라는 천사의 메시지.

모드 마법사 -o ; WiZ '더핑'\(운영자 상태 제거\). 이 명령의 일반 역방향\("MODE WiZ +o"\)은 OPER 명령을 우회하므로 사용자가 허용해서는 안 됩니다.

---
### **4.2.4 Topic message**

```text
      Command: TOPIC
   Parameters: <channel> [<topic>]
```

TOPIC 메시지는 채널의 주제를 변경하거나 보는 데 사용됩니다. <topic\>이 지정되지 않은 경우 <channel\> 채널의 주제가 반환됩니다. <topic\> 매개변수가 있는 경우 채널 모드에서 이 작업을 허용하면 해당 채널의 주제가 변경됩니다.

```text
   Numeric Replies:

           ERR_NEEDMOREPARAMS              ERR_NOTONCHANNEL
           RPL_NOTOPIC                     RPL_TOPIC
           ERR_CHANOPRIVSNEEDED

   Examples:
```

:Wiz TOPIC #테스트 :새 주제 ;사용자 Wiz가 주제를 설정합니다.

TOPIC #test :another topic ; #test의 주제를 "다른 주제"로 설정합니다.

주제 #테스트 ; #test 주제를 확인하세요.

---
### **4.2.5 Names message**

```text
      Command: NAMES
   Parameters: [<channel>{,<channel>}]
```

NAMES 명령을 사용하면 사용자는 자신이 볼 수 있는 모든 채널에서 볼 수 있는 모든 별명을 나열할 수 있습니다. 그들이 볼 수 있는 채널 이름은 비공개\(+p\) 또는 비밀\(+s\)이 아니거나 실제로 사용 중인 이름입니다. <channel\> 매개변수는 유효한 경우 정보를 반환할 채널을 지정합니다. 잘못된 채널 이름에 대한 오류 응답은 없습니다.

<channel\> 매개변수가 제공되지 않으면 모든 채널과 해당 점유자의 목록이 반환됩니다. 이 목록의 끝에는 표시되지만 어떤 채널에도 없거나 표시되는 채널에 없는 사용자 목록이 \`채널' "\*"에 있는 것으로 나열됩니다.

```text
   Numerics:

           RPL_NAMREPLY                    RPL_ENDOFNAMES

   Examples:
```

이름 #twilight\_zone,#42 ; 채널이 표시되는 경우 #twilight\_zone 및 #42에 표시되는 사용자를 나열합니다.

```text
   NAMES                           ; list all visible channels and users
```

---
### **4.2.6 List message**

```text
      Command: LIST
   Parameters: [<channel>{,<channel>} [<server>]]
```

목록 메시지는 채널과 해당 주제를 나열하는 데 사용됩니다. <channel\> 매개변수를 사용하면 해당 채널의 상태만 표시됩니다. 쿼리를 생성하는 클라이언트가 실제로 해당 채널에 있지 않는 한 비공개 채널은 주제 없이 채널 "Prv"로 나열됩니다. 마찬가지로 비밀 채널은 나열되지 않습니다.

클라이언트가 해당 채널의 회원이 아닌 이상 전혀 그렇지 않습니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER                RPL_LISTSTART
           RPL_LIST                        RPL_LISTEND

   Examples:

   LIST                            ; List all channels.

   LIST #twilight_zone,#42         ; List channels #twilight_zone and #42
```

---
### **4.2.7 Invite message**

```text
      Command: INVITE
   Parameters: <nickname> <channel>
```

INVITE 메시지는 사용자를 채널에 초대하는 데 사용됩니다. <nickname\> 매개변수는 대상 채널 <channel\>에 초대될 사람의 별명입니다. 대상 사용자가 초대되는 채널이 존재하거나 유효한 채널이어야 한다는 요구 사항은 없습니다. 초대 전용\(MODE +i\) 채널에 사용자를 초대하려면 초대를 보내는 클라이언트가 해당 채널의 채널 운영자로 인식되어야 합니다.

```text
   Numeric Replies:

           ERR_NEEDMOREPARAMS              ERR_NOSUCHNICK
           ERR_NOTONCHANNEL                ERR_USERONCHANNEL
           ERR_CHANOPRIVSNEEDED
           RPL_INVITING                    RPL_AWAY

   Examples:

   :Angel INVITE Wiz #Dust         ; User Angel inviting WiZ to channel
                                   #Dust

   INVITE Wiz #Twilight_Zone       ; Command to invite WiZ to
                                   #Twilight_zone
```

---
### **4.2.8 Kick command**

```text
      Command: KICK
   Parameters: <channel> <user> [<comment>]
```

KICK 명령을 사용하여 채널에서 사용자를 강제로 제거할 수 있습니다. 채널에서 '쫓겨납니다'\(강제 부분\).

채널 운영자만이 다른 사용자를 채널에서 쫓아낼 수 있습니다. KICK 메시지를 받은 각 서버는 피해자를 채널에서 제거하기 전에 메시지가 유효한지\(즉 보낸 사람이 실제로 채널 운영자인지\) 확인합니다.

```text
   Numeric Replies:

           ERR_NEEDMOREPARAMS              ERR_NOSUCHCHANNEL
           ERR_BADCHANMASK                 ERR_CHANOPRIVSNEEDED
           ERR_NOTONCHANNEL

   Examples:
```

---
# **KICK &Melbourne Matthew         ; Kick Matthew from &Melbourne**

KICK #Finnish John :영어 말하기 ; "Speaking English"를 이유\(댓글\)로 사용하여 #Finnish에서 John을 쫓아냅니다.

```text
:WiZ KICK #Finnish John         ; KICK message from WiZ to remove John
                                from channel #Finnish
```

참고: KICK 명령 매개변수를 다음으로 확장할 수 있습니다.
수행원:

```text
<channel>{,<channel>} <user>{,<user>} [<comment>]
```

---
## **4.3 Server queries and commands**

서버 쿼리 명령 그룹은 네트워크에 연결된 모든 서버에 대한 정보를 반환하도록 설계되었습니다. 연결된 모든 서버는 이러한 쿼리에 응답하고 올바르게 응답해야 합니다. 유효하지 않은 응답\(또는 응답 없음\)은 서버가 손상되었다는 신호로 간주되어야 하며 상황이 해결될 때까지 가능한 한 빨리 연결을 끊거나 비활성화해야 합니다.

이러한 쿼리에서 매개변수가 "<server\>"로 나타나는 경우 이는 일반적으로 별명, 서버 또는 일종의 와일드카드 이름일 수 있음을 의미합니다. 그러나 각 매개변수에 대해 하나의 쿼리와 응답 세트만 생성됩니다.

---
### **4.3.1 Version message**

```text
      Command: VERSION
   Parameters: [<server>]
```

VERSION 메시지는 서버 프로그램의 버전을 쿼리하는 데 사용됩니다. 선택적 매개변수 <server\>는 클라이언트가 직접 연결되지 않은 서버 프로그램의 버전을 쿼리하는 데 사용됩니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER                RPL_VERSION

   Examples:

   :Wiz VERSION *.se               ; message from Wiz to check the version
                                   of a server matching "*.se"
```

버전 tolsun.oulu.fi; "tolsun.oulu.fi" 서버 버전을 확인하세요.

---
### **4.3.2 Stats message**

```text
      Command: STATS
   Parameters: [<query> [<server>]]
```

통계 메시지는 특정 서버의 통계를 조회하는 데 사용됩니다. <server\> 파라미터를 생략하면 통계 응답의 끝 부분만 다시 보냅니다. 이 명령의 구현은 응답하는 서버에 따라 크게 달라집니다. 하지만 서버는 아래 쿼리에 설명된 대로\(또는 이와 유사한\) 정보를 제공할 수 있어야 합니다.

쿼리는 대상 서버\(<server\> 매개변수로 제공되는 경우\)에서만 확인하고 그렇지 않으면 무시되고 변경되지 않은 채 중간 서버에 전달되는 단일 문자로 제공될 수 있습니다. 다음 쿼리는 현재 IRC 구현에서 발견되는 쿼리이며 해당 서버에 대한 설정 정보의 상당 부분을 제공합니다. 다른 버전에서는 동일한 방식으로 지원되지 않을 수 있지만 모든 서버는 현재 사용되는 응답 형식 및 쿼리 목적과 일치하는 STATS 쿼리에 유효한 응답을 제공할 수 있어야 합니다.

현재 지원되는 쿼리는 다음과 같습니다.

```text
           c - returns a list of servers which the server may connect
               to or allow connections from;
           h - returns a list of servers which are either forced to be
               treated as leaves or allowed to act as hubs;
           i - returns a list of hosts which the server allows a client
               to connect from;
           k - returns a list of banned username/hostname combinations
               for that server;
           l - returns a list of the server's connections, showing how
```

- 각 연결이 설정된 기간과 각 방향에 대한 바이트 및 메시지 단위의 해당 연결을 통한 트래픽입니다. m - 서버에서 지원하는 명령 목록과 사용 횟수가 0이 아닌 경우 각각의 사용 횟수를 반환합니다. o - 일반 클라이언트가 운영자가 될 수 있는 호스트 목록을 반환합니다. y - 서버 구성 파일의 Y\(클래스\) 행을 표시합니다. u - 서버가 가동된 시간을 표시하는 문자열을 반환합니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER
           RPL_STATSCLINE                  RPL_STATSNLINE
           RPL_STATSILINE                  RPL_STATSKLINE
           RPL_STATSQLINE                  RPL_STATSLLINE
           RPL_STATSLINKINFO               RPL_STATSUPTIME
           RPL_STATSCOMMANDS               RPL_STATSOLINE
           RPL_STATSHLINE                  RPL_ENDOFSTATS

   Examples:

STATS m                         ; check the command usage for the server
                                you are connected to

:Wiz STATS c eff.org            ; request by WiZ for C/N line
                                information from server eff.org
```

---
### **4.3.3 Links message**

```text
      Command: LINKS
   Parameters: [[<remote server>] <server mask>]
```

LINKS를 ​​사용하면 사용자는 쿼리에 응답하는 서버에서 알려진 모든 서버를 나열할 수 있습니다. 반환된 서버 목록은 마스크와 일치해야 하며, 마스크가 제공되지 않으면 전체 목록이 반환됩니다.

<서버 마스크\> 외에 <원격 서버\>가 제공되면 해당 이름\(있는 경우\)과 일치하는 첫 번째 서버로 LINKS 명령이 전달되고 해당 서버는 쿼리에 응답해야 합니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER
           RPL_LINKS                       RPL_ENDOFLINKS

   Examples:

LINKS *.au                      ; list all servers which have a name
                                that matches *.au;
```

:WiZ 링크 \*.bu.edu \*.edu ; \*.bu.edu와 일치하는 서버 목록에 대해 WiZ에서 \*.edu와 일치하는 첫 번째 서버로 메시지를 연결합니다.

---
### **4.3.4 Time message**

```text
      Command: TIME
   Parameters: [<server>]
```

시간 메시지는 지정된 서버에서 현지 시간을 쿼리하는 데 사용됩니다. 서버 매개변수가 제공되지 않으면 명령을 처리하는 서버가 쿼리에 응답해야 합니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER                RPL_TIME

   Examples:

   TIME tolsun.oulu.fi             ; check the time on the server
                                   "tolson.oulu.fi"

   Angel TIME *.au                 ; user angel checking the time on a
                                   server matching "*.au"
```

---
### **4.3.5 Connect message**

```text
      Command: CONNECT
   Parameters: <target server> [<port> [<remote server>]]

   The CONNECT command can be used to force a server to try to establish
   a new connection to another server immediately.  CONNECT is a
   privileged command and is to be available only to IRC Operators.  If
   a remote server is given then the CONNECT attempt is made by that
   server to <target server> and <port>.

   Numeric Replies:

           ERR_NOSUCHSERVER                ERR_NOPRIVILEGES
           ERR_NEEDMOREPARAMS

   Examples:

CONNECT tolsun.oulu.fi          ; Attempt to connect a server to
                                tolsun.oulu.fi
```

:WiZ CONNECT eff.org 6667 csd.bu.edu ; CONNECT는 WiZ가 eff.org 및 csd.bu.edu 서버를 포트 6667에 연결하도록 시도합니다.

---
### **4.3.6 Trace message**

```text
      Command: TRACE
   Parameters: [<server>]
```

TRACE 명령은 특정 서버에 대한 경로를 찾는 데 사용됩니다. 이 메시지를 처리하는 각 서버는 "traceroute"를 사용하여 얻은 것과 유사한 응답 체인을 형성하는 통과 링크임을 나타내는 응답을 보내 보낸 사람에게 이에 대해 알려야 합니다. 이 응답을 다시 보낸 후 해당 서버에 도달할 때까지 다음 서버로 TRACE 메시지를 보내야 합니다. <server\> 매개변수가 생략된 경우 TRACE 명령은 현재 서버가 어떤 서버에 직접 연결되어 있는지 알려주는 메시지를 보낸 사람에게 보내는 것이 좋습니다.

"<서버\>"가 제공한 대상이 실제 서버인 경우 대상 서버는 연결된 모든 서버와 사용자를 보고해야 하지만 운영자만 현재 사용자를 볼 수 있습니다. <server\>가 제공한 대상이 닉네임인 경우 해당 닉네임에 대한 응답만 제공됩니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER
```

TRACE 메시지가 다른 서버로 향하는 경우 모든 중간 서버는 RPL\_TRACELINK 응답을 반환하여 TRACE가 해당 서버를 통과했으며 다음 위치로 이동함을 나타내야 합니다.

- RPL\_TRACELINK TRACE 응답은 다음 숫자 응답으로 구성될 수 있습니다.

```text
           RPL_TRACECONNECTING             RPL_TRACEHANDSHAKE
           RPL_TRACEUNKNOWN                RPL_TRACEOPERATOR
           RPL_TRACEUSER                   RPL_TRACESERVER
           RPL_TRACESERVICE                RPL_TRACENEWTYPE
           RPL_TRACECLASS

   Examples:
```

---
# **TRACE *.oulu.fi                 ; TRACE to a server matching *.oulu.fi**

```text
:WiZ TRACE AngelDust            ; TRACE issued by WiZ to nick AngelDust
```

---
### **4.3.7 Admin command**

```text
      Command: ADMIN
   Parameters: [<server>]
```

admin 메시지는 해당 서버의 관리자 이름을 찾는 데 사용되며, <server\> 매개변수가 생략된 경우 현재 서버의 이름을 찾는 데 사용됩니다. 각 서버에는 ADMIN 메시지를 다른 서버로 전달할 수 있는 기능이 있어야 합니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER
           RPL_ADMINME                     RPL_ADMINLOC1
           RPL_ADMINLOC2                   RPL_ADMINEMAIL

   Examples:

   ADMIN tolsun.oulu.fi            ; request an ADMIN reply from
                                   tolsun.oulu.fi
```

:WiZ 관리자 \*.edu ; \*.edu와 일치하는 것으로 밝혀진 첫 번째 서버에 대한 WiZ의 ADMIN 요청입니다.

---
### **4.3.8 Info command**

```text
      Command: INFO
   Parameters: [<server>]
```

INFO 명령은 서버를 설명하는 정보\(서버 버전, 컴파일 시기, 패치 수준, 시작 시기 및 관련 있다고 간주될 수 있는 기타 정보\)를 반환하는 데 필요합니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER
           RPL_INFO                        RPL_ENDOFINFO

   Examples:

   INFO csd.bu.edu                 ; request an INFO reply from
   csd.bu.edu
```

:아발론 정보 \*.fi ; \*.fi와 일치하는 첫 번째 서버에 대한 Avalon의 INFO 요청입니다.

정보 천사 ; Angel이 연결된 서버에 정보를 요청합니다.

---
## **4.4 Sending messages**

IRC 프로토콜의 주요 목적은 클라이언트가 서로 통신할 수 있는 기반을 제공하는 것입니다. PRIVMSG 및 NOTICE는 실제로 한 클라이언트에서 다른 클라이언트로 문자 메시지를 전달하는 데 사용할 수 있는 유일한 메시지입니다. 나머지는 이를 가능하게 하고 안정적이고 구조화된 방식으로 발생하도록 합니다.

---
### **4.4.1 Private messages**

- 명령어 : PRIVMSG 파라미터 : <수신자\>{,<수신자\>} <전송할 텍스트\>

PRIVMSG는 사용자 간에 비공개 메시지를 보내는 데 사용됩니다. <수신자\>는 메시지 수신자의 별명입니다. <receiver\>는 쉼표로 구분된 이름 또는 채널 목록일 수도 있습니다.

<receiver\> 매개변수는 호스트 마스크\(#mask\) 또는 서버 마스크\($mask\)일 수도 있습니다. 두 경우 모두 서버는 마스크와 일치하는 서버나 호스트가 있는 사람에게만 PRIVMSG를 보냅니다. 마스크에는 "."이 하나 이상 있어야 합니다. 마지막 "." 뒤에는 와일드카드가 없습니다. 이 요구 사항은 사람들이 모든 사용자에게 브로드캐스팅되는 "#\*" 또는 "$\*"로 메시지를 보내는 것을 방지하기 위해 존재합니다. 경험상 이것은 책임감 있고 적절하게 사용되는 것보다 더 많이 남용됩니다. 와일드카드는 '\*' 및 '?'입니다. 문자. PRIVMSG 명령에 대한 이 확장은 운영자만 사용할 수 있습니다.

```text
   Numeric Replies:

           ERR_NORECIPIENT                 ERR_NOTEXTTOSEND
           ERR_CANNOTSENDTOCHAN            ERR_NOTOPLEVEL
           ERR_WILDTOPLEVEL                ERR_TOOMANYTARGETS
           ERR_NOSUCHNICK
           RPL_AWAY

   Examples:
```

:Angel PRIVMSG Wiz :안녕하세요 이 메시지를 받으셨나요? ; 엔젤이 위즈에게 보내는 메시지.

PRIVMSG Angel :네, 받고 있어요 !받고 있어요 !'u\>\(768u+1n\) .br ; 천사에게 보내는 메시지.

PRIVMSG jto@tolsun.oulu.fi :안녕하세요! ; 서버의 클라이언트에게 보내는 메시지

- 사용자 이름이 "jto"인 tolsun.oulu.fi.

PRIVMSG $\*.fi :서버 tolsun.oulu.fi 재부팅 중입니다. ; 이름이 \*.fi와 일치하는 서버의 모든 사람에게 메시지를 보냅니다.

PRIVMSG #\*.edu :NSFNet이 작업 중입니다. 중단될 것으로 예상됩니다. 이름이 \*.edu와 일치하는 호스트에서 온 모든 사용자에게 보내는 메시지입니다.

---
### **4.4.2 Notice**

```text
      Command: NOTICE
   Parameters: <nickname> <text>
```

NOTICE 메시지는 PRIVMSG와 유사하게 사용됩니다. NOTICE와 PRIVMSG의 차이점은 NOTICE 메시지에 대한 응답으로 자동 회신을 보내서는 안 된다는 것입니다. 이 규칙은 서버에도 적용됩니다. 알림을 받은 경우 클라이언트에 오류 응답을 다시 보내서는 안 됩니다. 이 규칙의 목적은 수신된 항목에 대한 응답으로 클라이언트가 자동으로 무언가를 보내는 간의 루프를 방지하는 것입니다. 이는 일반적으로 다른 자동 장치와 루프에 빠지지 않도록 항상 응답하는 것으로 보이는 자동 장치\(AI 또는 자신의 작업을 제어하는 ​​다른 대화형 프로그램을 사용하는 클라이언트\)에 의해 사용됩니다.

답변과 예시에 대한 자세한 내용은 PRIVMSG를 참조하세요.

---
## **4.5 User based queries**

사용자 쿼리는 주로 특정 사용자 또는 그룹 사용자에 대한 세부 정보를 찾는 데 관련된 명령 그룹입니다. 이러한 명령에 와일드카드를 사용할 때 일치하는 경우 '표시'되는 사용자에 대한 정보만 반환합니다. 사용자의 가시성은 사용자 모드와 둘 다 사용 중인 공통 채널 세트의 조합으로 결정됩니다.

---
### **4.5.1 Who query**

- 명령: WHO 매개변수: \[<이름\> \[<o\>\]\]

WHO 메시지는 클라이언트가 제공한 <name\> 매개변수와 '일치'하는 정보 목록을 반환하는 쿼리를 생성하기 위해 클라이언트에서 사용됩니다. <name\> 매개변수가 없으면 표시되는 모든 사용자\(보이지 않는 사용자\(사용자 모드 +i\) 및 요청 클라이언트와 공통 채널이 없는 사용자\)가 나열됩니다. <name\>에 "0"을 사용하거나 와일드카드를 사용하여 동일한 결과를 얻을 수 있습니다.

가능한 모든 항목과 일치하게 됩니다.

채널 <name\>을 찾을 수 없는 경우 WHO에 전달된 <name\>은 사용자의 호스트, 서버, 실제 이름 및 별명과 일치됩니다.

"o" 매개변수가 전달되면 제공된 이름 마스크에 따라 연산자만 반환됩니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER
           RPL_WHOREPLY                    RPL_ENDOFWHO

   Examples:
```

누구 \*.fi ; "\*.fi"와 일치하는 모든 사용자를 나열합니다.

WHO jto\* o ; 운영자인 경우 "jto\*"와 일치하는 모든 사용자를 나열합니다.

---
### **4.5.2 Whois query**

```text
      Command: WHOIS
   Parameters: [<server>] <nickmask>[,<nickmask>[,...]]
```

이 메시지는 특정 사용자에 대한 정보를 쿼리하는 데 사용됩니다. 서버는 닉마스크와 일치하는 각 사용자의 다양한 상태를 나타내는 여러 숫자 메시지로 이 메시지에 응답합니다\(귀하가 이를 볼 수 있는 자격이 있는 경우\). <nickmask\>에 와일드카드가 없으면 볼 수 있는 해당 닉네임에 대한 정보가 표시됩니다. 쉼표\(','\)로 구분된 별명 목록이 제공될 수 있습니다.

후자 버전은 쿼리를 특정 서버로 보냅니다. 로컬 서버\(예: 사용자가 직접 연결된 서버\)만이 해당 정보를 알고 있고 다른 모든 내용은 전역적으로 알려져 있으므로 문제의 사용자가 얼마나 오랫동안 유휴 상태였는지 알고 싶은 경우 유용합니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER                ERR_NONICKNAMEGIVEN
           RPL_WHOISUSER                   RPL_WHOISCHANNELS
           RPL_WHOISCHANNELS               RPL_WHOISSERVER
           RPL_AWAY                        RPL_WHOISOPERATOR
           RPL_WHOISIDLE                   ERR_NOSUCHNICK
           RPL_ENDOFWHOIS

   Examples:

   WHOIS wiz                       ; return available user information
                                   about nick WiZ

   WHOIS eff.org trillian          ; ask server eff.org for user
                                   information about trillian
```

---
### **4.5.3 Whowas**

```text
      Command: WHOWAS
   Parameters: <nickname> [<count> [<server>]]
```

Whowas는 더 이상 존재하지 않는 별명에 대한 정보를 요청합니다. 이는 닉네임 변경이나 사용자가 IRC를 떠나기 때문일 수 있습니다. 이 쿼리에 대한 응답으로 서버는 닉네임 기록을 검색하여 어휘적으로 동일한 닉네임을 찾습니다\(여기서는 일치하는 와일드카드 없음\). 기록을 뒤로 검색하여 가장 최근 항목을 먼저 반환합니다. 항목이 여러 개인 경우 최대 <count\>개 응답이 반환됩니다\(또는 <count\> 매개변수가 제공되지 않은 경우 전체 응답\). 양수가 아닌 숫자가 <count\>로 전달되면 전체 검색이 수행됩니다.

```text
   Numeric Replies:

           ERR_NONICKNAMEGIVEN             ERR_WASNOSUCHNICK
           RPL_WHOWASUSER                  RPL_WHOISSERVER
           RPL_ENDOFWHOWAS

   Examples:

   WHOWAS Wiz                      ; return all information in the nick
                                   history about nick "WiZ";

   WHOWAS Mermaid 9                ; return at most, the 9 most recent
                                   entries in the nick history for
                                   "Mermaid";
```

누가 Trillian 1 \*.edu ; "\*.edu"와 일치하는 것으로 발견된 첫 번째 서버에서 "Trillian"에 대한 가장 최근 기록을 반환합니다.

---
## **4.6 Miscellaneous messages**

이 카테고리의 메시지는 위 카테고리에 속하지 않지만 그럼에도 불구하고 여전히 프로토콜의 일부이며 프로토콜에서 요구됩니다.

---
### **4.6.1 Kill message**

```text
      Command: KILL
   Parameters: <nickname> <comment>
```

KILL 메시지는 실제 연결이 있는 서버에 의해 클라이언트-서버 연결이 닫히도록 하는 데 사용됩니다. KILL은 유효한 별명 목록에서 중복된 항목을 발견할 때 서버에서 사용되며 두 항목을 모두 제거하는 데 사용됩니다. 운영자도 이용 가능합니다.

자동 재연결 알고리즘을 갖춘 클라이언트는 연결 끊김이 매우 짧기 때문에 이 명령을 효과적으로 쓸모 없게 만듭니다. 그러나 이는 데이터 흐름을 중단하고 대량의 남용을 막는 데 사용될 수 있습니다. 모든 사용자는 다른 사용자가 '감시'할 수 있도록 생성된 KILL 메시지를 수신하도록 선택할 수 있습니다.

닉네임은 항상 전역적으로 고유해야 하는 분야에서는 '중복'이 감지될 때마다\(즉, 동일한 닉네임으로 두 명의 사용자를 등록하려는 시도\) KILL 메시지가 전송됩니다. 1이 다시 나타납니다.

제공된 설명은 KILL의 실제 이유를 반영해야 합니다. 서버에서 생성된 KILL의 경우 일반적으로 두 개의 충돌하는 별명의 출처에 관한 세부 정보로 구성됩니다. 이를 보는 다른 사람들을 만족시킬 수 있는 적절한 이유를 제공하는 것은 사용자의 몫입니다. KILLer의 신원을 숨기기 위해 가짜 KILL이 생성되는 것을 방지/단념시키기 위해 댓글에는 통과하는 각 서버에서 업데이트되는 'kill-path'도 표시되며, 각각의 이름은 경로 앞에 추가됩니다.

```text
   Numeric Replies:

           ERR_NOPRIVILEGES                ERR_NEEDMOREPARAMS
           ERR_NOSUCHNICK                  ERR_CANTKILLSERVER
```

데이비드를 죽여라\(csd.bu.edu <- tolsun.oulu.fi\)

- ; csd.bu.edu와 tolson.oulu.fi 간의 닉네임 충돌

참고: 운영자만 KILL 메시지로 다른 사용자를 죽일 수 있도록 허용하는 것이 좋습니다. 이상적인 세계에서는 운영자도 이 작업을 수행할 필요가 없으며 서버에서 처리하도록 남겨집니다.

---
### **4.6.2 Ping message**

```text
      Command: PING
   Parameters: <server1> [<server2>]
```

PING 메시지는 연결의 다른 쪽 끝에 활성 클라이언트가 있는지 테스트하는 데 사용됩니다. 연결에서 다른 활동이 감지되지 않으면 PING 메시지가 정기적으로 전송됩니다. 연결이 설정된 시간 내에 PING 명령에 응답하지 않으면 해당 연결이 닫힙니다.

PING 메시지를 수신하는 모든 클라이언트는 <server1\>\(PING 메시지를 보낸 서버\)에 가능한 한 빨리 적절한 PONG 메시지로 응답하여 해당 클라이언트가 아직 거기에 있고 살아 있음을 나타내야 합니다. 서버는 PING 명령에 응답해서는 안 되며 연결의 다른 쪽 끝에서 PING을 사용하여 연결이 활성 상태임을 나타냅니다. <server2\> 매개변수가 지정된 경우 PING 메시지가 해당 위치로 전달됩니다.

```text
   Numeric Replies:

           ERR_NOORIGIN                    ERR_NOSUCHSERVER

   Examples:
```

PING tolsun.oulu.fi ; 서버가 다른 서버에 PING 메시지를 보내 아직 살아 있음을 나타냅니다.

```text
   PING WiZ                        ; PING message being sent to nick WiZ
```

---
### **4.6.3 Pong message**

```text
      Command: PONG
   Parameters: <daemon> [<daemon2>]
```

PONG 메시지는 ping 메시지에 대한 응답입니다. <daemon2\> 매개변수가 제공되면 이 메시지는 지정된 데몬으로 전달되어야 합니다. <daemon\> 매개변수는 PING 메시지에 응답하고 이 메시지를 생성한 데몬의 이름입니다.

```text
   Numeric Replies:

           ERR_NOORIGIN                    ERR_NOSUCHSERVER

   Examples:
```

PONG csd.bu.edu tolsun.oulu.fi ; csd.bu.edu에서 다음으로 보내는 PONG 메시지

```text
                                   tolsun.oulu.fi
```

---
### **4.6.4 Error**

```text
      Command: ERROR
   Parameters: <error message>
```

ERROR 명령은 심각하거나 치명적인 오류를 운영자에게 보고할 때 서버에서 사용됩니다. 또한 한 서버에서 다른 서버로 전송될 수도 있지만 알 수 없는 일반 클라이언트에서는 허용되어서는 안 됩니다.

ERROR 메시지는 서버 간 링크에서만 발생하는 오류를 보고하는 데 사용됩니다. ERROR 메시지는 상대방 서버\(연결된 모든 운영자에게 전송\)와 현재 연결된 모든 운영자에게 전송됩니다. 서버에서 받은 경우 서버에서 다른 서버로 전달되지 않습니다.

서버가 수신된 ERROR 메시지를 운영자에게 보낼 때 해당 메시지는 클라이언트가 오류에 대한 책임이 없음을 나타내는 NOTICE 메시지 내에 캡슐화되어야 합니다.

```text
   Numerics:

           None.

   Examples:
```

오류: 서버 \*.fi가 이미 존재합니다. 이 오류를 발생시킨 다른 서버에 ERROR 메시지가 전송되었습니다.

참고 WiZ: csd.bu.edu의 오류 - \*.fi 서버가 이미 존재합니다. 위와 동일한 ERROR 메시지가 다른 서버의 WiZ 사용자에게 전송되었습니다.

---
## **5. OPTIONALS**

이 섹션에서는 OPTIONAL 메시지에 대해 설명합니다. 여기에 설명된 프로토콜의 작업 서버 구현에는 필요하지 않습니다. 옵션이 없으면 오류 응답 메시지가 생성되거나 알 수 없는 명령 오류가 발생해야 합니다. 메시지가 다른 서버가 응답하도록 되어 있는 경우 전달되어야 합니다\(기본 구문 분석 필요\). 이에 대해 할당된 숫자는 아래 메시지와 함께 나열됩니다.\(MAY\)

---
## **5.1 Away**

```text
      Command: AWAY
   Parameters: [message]
```

AWAY 메시지를 사용하면 클라이언트는 자신에게 전달된 모든 PRIVMSG 명령에 대해 자동 응답 문자열을 설정할 수 있습니다\(자신이 있는 채널이 아님\). 자동 응답은 서버에서 PRIVMSG 명령을 보내는 클라이언트로 전송됩니다. 유일한 응답 서버는 보내는 클라이언트가 연결된 서버입니다.

AWAY 메시지는 하나의 매개변수\(AWAY 메시지 설정\) 또는 매개변수 없이\(AWAY 메시지 제거\) 사용됩니다.

```text
   Numeric Replies:

           RPL_UNAWAY                      RPL_NOWAWAY

   Examples:
```

AWAY : 점심 먹으러 갔어요. 5로 돌아옴; "점심 먹으러 갔어요. 5시에 돌아오세요"라는 메시지를 설정하세요.

:위즈 어웨이 ; WiZ의 부재중 표시를 해제하세요.

---
## **5.2 Rehash message**

```text
      Command: REHASH
   Parameters: None
```

운영자는 재해시 메시지를 사용하여 서버가 구성 파일을 다시 읽고 처리하도록 할 수 있습니다.

```text
   Numeric Replies:

        RPL_REHASHING                   ERR_NOPRIVILEGES
```

---
# **Examples:**

재해시; 운영자 상태의 클라이언트에서 서버로 구성 파일을 다시 읽도록 요청하는 메시지입니다.

---
## **5.3 Restart message**

```text
      Command: RESTART
   Parameters: None
```

다시 시작 메시지는 운영자가 서버 자체를 강제로 다시 시작하는 데만 사용할 수 있습니다. 이 메시지는 임의의 사람이 운영자로서 서버에 연결하고 이 명령을 실행하도록 허용하여 \(적어도\) 서비스를 중단시키는 위험으로 간주될 수 있으므로 선택 사항입니다.

RESTART 명령은 항상 송신 클라이언트가 연결된 서버에서 완전히 처리되어야 하며 연결된 다른 서버로 전달되어서는 안 됩니다.

```text
   Numeric Replies:

           ERR_NOPRIVILEGES

   Examples:

   RESTART                         ; no parameters required.
```

---
## **5.4 Summon message**

```text
      Command: SUMMON
   Parameters: <user> [<server>]
```

SUMMON 명령은 IRC 서버를 실행하는 호스트에 있는 사용자에게 IRC에 가입하라는 메시지를 보내는 데 사용할 수 있습니다. 이 메시지는 대상 서버가 \(a\) SUMMON을 활성화하고, \(b\) 사용자가 로그인하고, \(c\) 서버 프로세스가 사용자의 tty\(또는 유사한\)에 쓸 수 있는 경우에만 전송됩니다.

<server\> 매개변수가 제공되지 않으면 클라이언트가 연결된 서버에서 <user\>를 소환하려고 시도하며 대상으로 간주됩니다.

서버에서 소환이 활성화되지 않은 경우 ERR\_SUMMONDISABLED 숫자를 반환하고 소환 메시지를 계속 전달해야 합니다.

```text
   Numeric Replies:

           ERR_NORECIPIENT                 ERR_FILEERROR
           ERR_NOLOGIN                     ERR_NOSUCHSERVER
           RPL_SUMMONING

   Examples:

   SUMMON jto                      ; summon user jto on the server's host
```

jto tolsun.oulu.fi 소환; "tolsun.oulu.fi"라는 ​​서버가 실행 중인 호스트에 사용자 jto를 소환합니다.

---
## **5.5 Users**

```text
      Command: USERS
   Parameters: [<server>]
```

USERS 명령은 who\(1\), rusers\(1\) 및 Finger\(1\)와 유사한 형식으로 서버에 로그인한 사용자 목록을 반환합니다. 일부 사람들은 보안 관련 이유로 자신의 서버에서 이 명령을 비활성화할 수 있습니다. 비활성화된 경우 이를 나타내기 위해 올바른 숫자가 반환되어야 합니다.

```text
   Numeric Replies:

           ERR_NOSUCHSERVER                ERR_FILEERROR
           RPL_USERSSTART                  RPL_USERS
           RPL_NOUSERS                     RPL_ENDOFUSERS
           ERR_USERSDISABLED

   Disabled Reply:

           ERR_USERSDISABLED

   Examples:

USERS eff.org                   ; request a list of users logged in on
                                server eff.org

:John USERS tolsun.oulu.fi      ; request from John for a list of users
                                logged in on server tolsun.oulu.fi
```

---
## **5.6 Operwall message**

- 명령: WALLOPS 매개변수: 현재 온라인인 모든 운영자에게 전송될 텍스트

현재 온라인인 모든 운영자에게 메시지를 보냅니다. WALLOPS를 사용자 명령으로 구현한 후에는 WALLOPS가 많은 사람들에게 메시지를 보내는 수단\(WALL과 매우 유사함\)으로 자주 악용되는 것으로 나타났습니다. 이로 인해 서버만 WALLOPS의 발신자로 허용하고 인식하여 WALLOPS의 현재 구현을 예로 사용하는 것이 좋습니다.

```text
   Numeric Replies:

           ERR_NEEDMOREPARAMS

   Examples:
```

:csd.bu.edu WALLOPS :Joshua의 '\*.uiuc.edu 6667'을 연결합니다. Joshua로부터 수신되어 실행된 CONNECT 메시지를 알리는 csd.bu.edu의 WALLOPS 메시지입니다.

---
## **5.7 Userhost message**

```text
      Command: USERHOST
   Parameters: <nickname>{<space><nickname>}
```

USERHOST 명령은 각각 공백 문자로 구분된 최대 5개의 별명 ​​목록을 가져와 찾은 각 별명에 대한 정보 목록을 리턴합니다. 반환된 목록에는 공백으로 구분된 각 응답이 있습니다.

```text
   Numeric Replies:

           RPL_USERHOST                    ERR_NEEDMOREPARAMS

   Examples:

   USERHOST Wiz Michael Marty p    ;USERHOST request for information on
                                   nicks "Wiz", "Michael", "Marty" and "p"
```

---
## **5.8 Ison message**

```text
      Command: ISON
   Parameters: <nickname>{<space><nickname>}
```

ISON 명령은 주어진 별명이 현재 IRC에 있는지 여부에 대한 응답을 얻는 빠르고 효율적인 수단을 제공하기 위해 구현되었습니다. ISON은 하나의 매개변수\(공백으로 구분된 닉네임 목록\)만 사용합니다. 존재하는 목록의 각 별명에 대해 서버는 이를 응답 문자열에 추가합니다. 따라서 응답 문자열은 빈 문자열\(주어진 별명이 하나도 없음\), 매개변수 문자열의 정확한 복사본\(모두 존재함\) 또는 매개변수에 제공된 별명 집합의 다른 하위 집합을 반환할 수 있습니다. 확인할 수 있는 닉 수에 대한 유일한 제한은 결합된 길이가 서버에서 잘려 512자에 맞도록 너무 커서는 안 된다는 것입니다.

ISON은 명령을 보내는 클라이언트의 로컬 서버에서만 처리되므로 추가 처리를 위해 다른 서버로 전달되지 않습니다.

```text
   Numeric Replies:

           RPL_ISON                ERR_NEEDMOREPARAMS

   Examples:
```

ISON 전화 trillian WiZ jarlek Avalon Angel Monstah

- ; 7개 닉에 대한 샘플 ISON 요청입니다.

---
## **6. REPLIES**

다음은 위에 제공된 명령에 대한 응답으로 생성된 숫자 응답 목록입니다. 각 숫자에는 해당 번호, 이름 및 응답 문자열이 제공됩니다.

---
## **6.1 Error Replies.**

```text
        401     ERR_NOSUCHNICK
                        "<nickname> :No such nick/channel"
```

- - 명령에 제공된 별명 매개변수가 현재 사용되지 않음을 나타내는 데 사용됩니다.

```text
        402     ERR_NOSUCHSERVER
                        "<server name> :No such server"
```

- - 제공된 서버 이름이 현재 존재하지 않음을 나타내는 데 사용됩니다.

```text
        403     ERR_NOSUCHCHANNEL
                        "<channel name> :No such channel"
```

- - 주어진 채널 이름이 유효하지 않음을 나타내는 데 사용됩니다.

```text
        404     ERR_CANNOTSENDTOCHAN
                        "<channel name> :Cannot send to channel"
```

- - \(a\) 모드 +n인 채널에 있지 않거나 \(b\) 모드 +m이 설정된 채널에 있는 채널\(또는 모드 +v\)이 아니고 PRIVMSG를 보내려고 하는 사용자에게 전송됩니다. 해당 채널에 메시지를 보냅니다.

405 ERR\_너무 많은 채널

- "<채널 이름\> :너무 많은 채널에 가입했습니다." - 사용자가 허용된 최대 채널 수에 가입하고 다른 채널에 가입하려고 할 때 사용자에게 전송됩니다.

```text
        406     ERR_WASNOSUCHNICK
                        "<nickname> :There was no such nickname"
```

- - 해당 닉네임에 대한 기록 정보가 없음을 나타내기 위해 WHOWAS에서 반환했습니다.

```text
        407     ERR_TOOMANYTARGETS
                        "<target> :Duplicate recipients. No message \

                         delivered"
```

- - user@host 대상 형식을 사용하고 여러 번 발생하는 user@host에 대해 PRIVMSG/NOTICE를 보내려고 시도하는 클라이언트로 반환됩니다.

```text
        409     ERR_NOORIGIN
                        ":No origin specified"
```

- - 이러한 명령은 유효한 접두사 없이 작동해야 하기 때문에 필요한 발생자 매개변수가 누락된 PING 또는 PONG 메시지입니다.

```text
        411     ERR_NORECIPIENT
                        ":No recipient given (<command>)"
        412     ERR_NOTEXTTOSEND
                        ":No text to send"
        413     ERR_NOTOPLEVEL
                        "<mask> :No toplevel domain specified"
        414     ERR_WILDTOPLEVEL
                        "<mask> :Wildcard in toplevel domain"
```

- - 412 - 414는 PRIVMSG에서 반환되어 어떤 이유로 메시지가 전달되지 않았음을 나타냅니다. ERR\_NOTOPLEVEL 및 ERR\_WILDTOPLEVEL은 "PRIVMSG $<server\>" 또는 "PRIVMSG #<host\>"를 잘못 사용하려고 시도할 때 반환되는 오류입니다.

```text
        421     ERR_UNKNOWNCOMMAND
                        "<command> :Unknown command"
```

- - 전송된 명령을 서버에서 알 수 없음을 나타내기 위해 등록된 클라이언트로 반환됩니다.

```text
        422     ERR_NOMOTD
                        ":MOTD File is missing"
```

- - 서버의 MOTD 파일을 서버에서 열 수 없습니다.

```text
        423     ERR_NOADMININFO
                        "<server> :No administrative info available"
```

- - 해당 정보를 찾는 데 오류가 있는 경우 ADMIN 메시지에 대한 응답으로 서버에서 반환합니다.

```text
        424     ERR_FILEERROR
                ":File error doing <file op> on <file>"
```

- - 메시지 처리 중 실패한 파일 작업을 보고하는 데 사용되는 일반 오류 메시지입니다.

```text
        431     ERR_NONICKNAMEGIVEN
                        ":No nickname given"
```

- - 명령에 필요한 별명 매개변수를 찾을 수 없는 경우 반환됩니다.

```text
        432     ERR_ERRONEUSNICKNAME
                        "<nick> :Erroneus nickname"
```

- - 정의된 집합에 속하지 않는 문자가 포함된 NICK 메시지를 수신한 후 반환됩니다. 유효한 별명에 대한 자세한 내용은 x.x.x 섹션을 참조하세요.

```text
        433     ERR_NICKNAMEINUSE
                        "<nick> :Nickname is already in use"
```

- - 현재 존재하는 별명으로 변경을 시도하는 NICK 메시지가 처리될 때 반환됩니다.

```text
        436     ERR_NICKCOLLISION
                        "<nick> :Nickname collision KILL"
```

- - 닉네임 충돌\(다른 서버에 의해 이미 존재하는 NICK에 등록됨\)이 감지되면 서버가 클라이언트에 반환합니다.

```text
        441     ERR_USERNOTINCHANNEL
                        "<nick> <channel> :They aren't on that channel"
```

- - 명령의 대상 사용자가 지정된 채널에 없음을 나타내기 위해 서버에서 반환됩니다.

```text
        442     ERR_NOTONCHANNEL
                        "<channel> :You're not on that channel"
```

- - 클라이언트가 구성원이 아닌 명령에 영향을 미치는 채널을 클라이언트가 수행하려고 할 때마다 서버에서 반환됩니다.

```text
        443     ERR_USERONCHANNEL
                        "<user> <channel> :is already on channel"
```

- - 클라이언트가 이미 참여 중인 채널에 사용자를 초대하려고 할 때 반환됩니다.

```text
        444     ERR_NOLOGIN
                        "<user> :User not logged in"
```

- - 사용자가 로그인하지 않아 SUMMON 명령을 수행할 수 없는 후 소환에 의해 반환됩니다.

```text
        445     ERR_SUMMONDISABLED
                        ":SUMMON has been disabled"
```

- - SUMMON 명령에 대한 응답으로 반환됩니다. 이를 구현하지 않는 서버에서 반환해야 합니다.

```text
        446     ERR_USERSDISABLED
                        ":USERS has been disabled"
```

- - USERS 명령에 대한 응답으로 반환됩니다. 이를 구현하지 않는 서버에서 반환해야 합니다.

```text
        451     ERR_NOTREGISTERED
                        ":You have not registered"
```

- - 서버가 클라이언트를 자세히 구문 분석하기 전에 클라이언트를 등록해야 함을 나타내기 위해 서버에 의해 반환됩니다.

```text
        461     ERR_NEEDMOREPARAMS
                        "<command> :Not enough parameters"
```

- - 충분한 매개변수를 제공하지 않았음을 클라이언트에 나타내기 위해 수많은 명령을 통해 서버에서 반환됩니다.

```text
        462     ERR_ALREADYREGISTRED
                        ":You may not reregister"
```

- - 등록된 세부 정보\(예: 두 번째 USER 메시지의 비밀번호 또는 사용자 세부 정보\)의 일부를 변경하려고 시도하는 링크로 서버에서 반환됩니다.

```text
        463     ERR_NOPERMFORHOST
                        ":Your host isn't among the privileged"
```

- - 시도된 연결이 시도된 호스트로부터의 연결을 허용하도록 설정되지 않은 서버에 등록을 시도하는 클라이언트로 반환됩니다.

```text
        464     ERR_PASSWDMISMATCH
                        ":Password incorrect"
```

- - 비밀번호가 필요한 연결 등록 시도가 실패했지만 제공되지 않았거나 올바르지 않음을 나타내기 위해 반환되었습니다.

```text
        465     ERR_YOUREBANNEDCREEP
                        ":You are banned from this server"
```

- - 귀하에 대한 연결을 명시적으로 거부하도록 설정된 서버에 연결하고 등록하려는 시도 후에 반환되었습니다.

```text
        467     ERR_KEYSET
                        "<channel> :Channel key already set"
        471     ERR_CHANNELISFULL
                        "<channel> :Cannot join channel (+l)"
        472     ERR_UNKNOWNMODE
                        "<char> :is unknown mode char to me"
        473     ERR_INVITEONLYCHAN
                        "<channel> :Cannot join channel (+i)"
        474     ERR_BANNEDFROMCHAN
                        "<channel> :Cannot join channel (+b)"
        475     ERR_BADCHANNELKEY
                        "<channel> :Cannot join channel (+k)"
        481     ERR_NOPRIVILEGES
                        ":Permission Denied- You're not an IRC operator"
```

- - 작동을 위해 운영자 권한이 필요한 모든 명령은 시도가 실패했음을 나타내기 위해 이 오류를 반환해야 합니다.

```text
        482     ERR_CHANOPRIVSNEEDED
                        "<channel> :You're not channel operator"
```

- - 'chanop' 권한이 필요한 명령\(예: MODE 메시지\)은 시도하는 클라이언트가 지정된 채널의 chanop가 아닌 경우 이 오류를 반환해야 합니다.

```text
        483     ERR_CANTKILLSERVER
                        ":You cant kill a server!"
```

- - 서버에서 KILL 명령을 사용하려는 모든 시도는 거부되며 이 오류는 클라이언트에 직접 반환됩니다.

```text
        491     ERR_NOOPERHOST
                        ":No O-lines for your host"
```

- - 클라이언트가 OPER 메시지를 보내고 서버가 운영자로서 클라이언트 호스트의 연결을 허용하도록 구성되지 않은 경우 이 오류가 반환되어야 합니다.

```text
        501     ERR_UMODEUNKNOWNFLAG
                        ":Unknown MODE flag"
```

- - MODE 메시지가 별명 매개변수와 함께 전송되었으며 전송된 모드 플래그가 인식되지 않았음을 나타내기 위해 서버에 의해 반환됩니다.

```text
        502     ERR_USERSDONTMATCH
                        ":Cant change mode for other users"
```

- - 자신이 아닌 사용자의 사용자 모드를 보거나 변경하려는 사용자에게 오류가 전송되었습니다.

---
## **6.2 Command responses.**

```text
        300     RPL_NONE
                        Dummy reply number. Not used.

        302     RPL_USERHOST
                        ":[<reply>{<space><reply>}]"
```

- - 쿼리 목록에 대한 응답을 나열하기 위해 USERHOST에서 사용하는 응답 형식입니다. 응답 문자열은 다음과 같이 구성됩니다.

```text
                  <reply> ::= <nick>['*'] '=' <'+'|'-'><hostname>
```

- '\*'는 클라이언트가 운영자로 등록되었는지 여부를 나타냅니다. '-' 또는 '+' 문자는 각각 클라이언트가 AWAY 메시지를 설정했는지 여부를 나타냅니다.

```text
        303     RPL_ISON
                        ":[<nick> {<space><nick>}]"
```

- - ISON이 쿼리 목록에 대한 응답을 나열하는 데 사용하는 응답 형식입니다.

```text
        301     RPL_AWAY
                        "<nick> :<away message>"

        305     RPL_UNAWAY
                        ":You are no longer marked as being away"
        306     RPL_NOWAWAY
                        ":You have been marked as being away"
```

- - 이러한 응답은 AWAY 명령과 함께 사용됩니다\(허용되는 경우\). RPL\_AWAY는 자리를 비운 클라이언트에게 PRIVMSG를 보내는 모든 클라이언트에게 전송됩니다. RPL\_AWAY는 클라이언트가 연결된 서버에서만 전송됩니다. 클라이언트가 AWAY 메시지를 제거하고 설정할 때 응답 RPL\_UNAWAY 및 RPL\_NOWAWAY가 전송됩니다.

```text
        311     RPL_WHOISUSER
                        "<nick> <user> <host> * :<real name>"
        312     RPL_WHOISSERVER
                        "<nick> <server> :<server info>"
        313     RPL_WHOISOPERATOR
                        "<nick> :is an IRC operator"
        317     RPL_WHOISIDLE
                        "<nick> <integer> :seconds idle"
        318     RPL_ENDOFWHOIS
                        "<nick> :End of /WHOIS list"
        319     RPL_WHOISCHANNELS
                        "<nick> :{[@|+]<channel><space>}"
```

- 답글 311\~313, 317\~319는 모두 답글입니다.

- WHOIS 메시지에 대한 응답으로 생성됩니다. 매개변수가 충분하다면 응답 서버는 위의 숫자로 응답을 공식화하거나\(쿼리 닉네임을 찾은 경우\) 오류 응답을 반환해야 합니다. RPL\_WHOISUSER의 '\*'는 와일드카드가 아닌 리터럴 문자로 존재합니다. 각 응답 세트에 대해 RPL\_WHOISCHANNELS만 두 번 이상 나타날 수 있습니다\(긴 채널 이름 목록의 경우\). 채널 이름 옆의 '@' 및 '+' 문자는 클라이언트가 채널 운영자인지 또는 중재되는 채널에서 말할 수 있는 권한이 부여되었는지 여부를 나타냅니다. RPL\_ENDOFWHOIS 응답은 WHOIS 메시지 처리 종료를 표시하는 데 사용됩니다.

```text
        314     RPL_WHOWASUSER
                        "<nick> <user> <host> * :<real name>"
        369     RPL_ENDOFWHOWAS
                        "<nick> :End of WHOWAS"
```

- - WHOWAS 메시지에 응답할 때 서버는 제시된 각 별명에 대해 RPL\_WHOWASUSER, RPL\_WHOISSERVER 또는 ERR\_WASNOSUCHNICK 응답을 사용해야 합니다.

-              목록. 모든 회신 일괄 처리가 끝나면 RPL\_ENDOFWHOWAS가 있어야 합니다\(회신이 하나만 있고 오류인 경우에도 마찬가지입니다\).

```text
        321     RPL_LISTSTART
                        "Channel :Users  Name"
        322     RPL_LIST
                        "<channel> <# visible> :<topic>"
        323     RPL_LISTEND
                        ":End of /LIST"
```

- - RPL\_LISTSTART, RPL\_LIST, RPL\_LISTEND 응답은 LIST 명령에 대한 서버 응답의 시작, 실제 데이터 응답 및 끝을 표시합니다. 반환할 수 있는 채널이 없으면 시작 및 끝 응답만 전송되어야 합니다.

```text
        324     RPL_CHANNELMODEIS
                        "<channel> <mode> <mode params>"

        331     RPL_NOTOPIC
                        "<channel> :No topic is set"
        332     RPL_TOPIC
                        "<channel> :<topic>"
```

- TOPIC 메시지를 보내어 결정하는 경우

- 채널 주제에 대한 답변은 2개 중 1개가 전송됩니다. 주제가 설정되면 RPL\_TOPIC이 다시 RPL\_NOTOPIC으로 전송됩니다.

```text
        341     RPL_INVITING
                        "<channel> <nick>"
```

- 서버가 반환한 내용은 다음과 같습니다.

- 시도된 INVITE 메시지가 성공하여 최종 클라이언트로 전달되는 중입니다.

```text
        342     RPL_SUMMONING
                        "<user> :Summoning user to IRC"
```

- - 해당 사용자를 소환하고 있음을 나타내기 위해 SUMMON 메시지에 응답하는 서버에 의해 반환됩니다.

```text
        351     RPL_VERSION
                        "<version>.<debuglevel> <server> :<comments>"
```

- - 버전 세부정보를 표시하는 서버의 응답입니다. <version\>은 현재 소프트웨어의 버전입니다.

- 사용되며\(모든 패치 수준 개정 포함\) <debuglevel\>은 서버가 "디버그 모드"에서 실행 중인지 나타내는 데 사용됩니다.

- "설명" 필드에는 버전에 대한 설명이나 추가 버전 세부 정보가 포함될 수 있습니다.

```text
        352     RPL_WHOREPLY
                        "<channel> <user> <host> <server> <nick> \
                         <H|G>[*][@|+] :<hopcount> <real name>"
        315     RPL_ENDOFWHO
                        "<name> :End of /WHO list"
```

- - RPL\_WHOREPLY 및 RPL\_ENDOFWHO 쌍은 WHO 메시지에 응답하는 데 사용됩니다. RPL\_WHOREPLY는 WHO 쿼리와 적절하게 일치하는 경우에만 전송됩니다. WHO 메시지와 함께 제공된 매개변수 목록이 있는 경우 <name\>이 항목인 각 목록 항목을 처리한 후 RPL\_ENDOFWHO를 전송해야 합니다.

```text
        353     RPL_NAMREPLY
                        "<channel> :[[@|+]<nick> [[@|+]<nick> [...]]]"
        366     RPL_ENDOFNAMES
                        "<channel> :End of /NAMES list"
```

- - NAMES 메시지에 응답하기 위해 RPL\_NAMREPLY 및 RPL\_ENDOFNAMES로 구성된 응답 쌍이 서버에서 클라이언트로 다시 전송됩니다. 쿼리에서와 같이 채널이 발견되지 않으면 RPL\_ENDOFNAMES만 반환됩니다. 이에 대한 예외는 NAMES 메시지가 매개변수 없이 전송되고 모든 표시 채널과 콘텐츠가 끝을 표시하기 위해 RPL\_ENDOFNAMES와 함께 일련의 RPL\_NAMEREPLY 메시지로 다시 전송되는 경우입니다.

```text
        364     RPL_LINKS
                        "<mask> <server> :<hopcount> <server info>"
        365     RPL_ENDOFLINKS
                        "<mask> :End of /LINKS list"
```

- - LINKS 메시지에 응답할 때 서버는 RPL\_LINKS 숫자를 사용하여 응답을 다시 보내고 RPL\_ENDOFLINKS 응답을 사용하여 목록의 끝을 표시해야 합니다.

```text
        367     RPL_BANLIST
                        "<channel> <banid>"
        368     RPL_ENDOFBANLIST

                        "<channel> :End of channel ban list"
```

- - 특정 채널에 대한 활성 '금지' 목록을 나열할 때 서버는 RPL\_BANLIST 및 RPL\_ENDOFBANLIST 메시지를 사용하여 목록을 다시 보내야 합니다. 각 활성 banid에 대해 별도의 RPL\_BANLIST가 전송됩니다. banid가 나열된 후\(또는 아무것도 없는 경우\) RPL\_ENDOFBANLIST를 보내야 합니다.

```text
        371     RPL_INFO
                        ":<string>"
        374     RPL_ENDOFINFO
                        ":End of /INFO list"
```

- - INFO 메시지에 응답하는 서버는 응답의 끝을 나타내기 위해 RPL\_ENDOFINFO 응답과 함께 일련의 RPL\_INFO 메시지로 모든 '정보'를 보내야 합니다.

```text
        375     RPL_MOTDSTART
                        ":- <server> Message of the day - "
        372     RPL_MOTD
                        ":- <text>"
        376     RPL_ENDOFMOTD
                        ":End of /MOTD command"
```

- - MOTD 메시지에 응답하고 MOTD 파일을 찾으면 파일은 RPL\_MOTD 형식 응답을 사용하여 각 줄이 80자 이하로 한 줄씩 표시됩니다. 이는 RPL\_MOTDSTART\(RPL\_MOTD 앞\) 및 RPL\_ENDOFMOTD\(뒤\)로 둘러싸여야 합니다.

```text
        381     RPL_YOUREOPER
                        ":You are now an IRC operator"
```

- - RPL\_YOUREOPER는 OPER 메시지를 성공적으로 발행하고 운영자 상태를 얻은 클라이언트로 다시 전송됩니다.

```text
        382     RPL_REHASHING
                        "<config file> :Rehashing"
```

- - REHASH 옵션이 사용되고 운영자가 REHASH 메시지를 보내는 경우 RPL\_REHASHING이 운영자에게 다시 전송됩니다.

```text
        391     RPL_TIME

                        "<server> :<string showing server's local time>"
```

- - TIME 메시지에 응답할 때 서버는 위의 RPL\_TIME 형식을 사용하여 응답을 보내야 합니다. 시간을 표시하는 문자열에는 정확한 날짜와 시간만 포함하면 됩니다. 시간 문자열에 대한 추가 요구 사항은 없습니다.

```text
        392     RPL_USERSSTART
                        ":UserID   Terminal  Host"
        393     RPL_USERS
                        ":%-8s %-9s %-8s"
        394     RPL_ENDOFUSERS
                        ":End of users"
        395     RPL_NOUSERS
                        ":Nobody logged in"
```

- - USERS 메시지가 서버에 의해 처리되는 경우 RPL\_USERSTART, RPL\_USERS, RPL\_ENDOFUSERS 및 RPL\_NOUSERS 응답이 사용됩니다. RPL\_USERSSTART가 먼저 전송되어야 하며, 이어서 RPL\_USERS 시퀀스 또는 단일 RPL\_NOUSER가 전송되어야 합니다. 다음은 RPL\_ENDOFUSERS입니다.

```text
        200     RPL_TRACELINK
                        "Link <version & debug level> <destination> \
                         <next server>"
        201     RPL_TRACECONNECTING
                        "Try. <class> <server>"
        202     RPL_TRACEHANDSHAKE
                        "H.S. <class> <server>"
        203     RPL_TRACEUNKNOWN
                        "???? <class> [<client IP address in dot form>]"
        204     RPL_TRACEOPERATOR
                        "Oper <class> <nick>"
        205     RPL_TRACEUSER
                        "User <class> <nick>"
        206     RPL_TRACESERVER
                        "Serv <class> <int>S <int>C <server> \
                         <nick!user|*!*>@<host|server>"
        208     RPL_TRACENEWTYPE
                        "<newtype> 0 <client name>"
        261     RPL_TRACELOG
                        "File <logfile> <debug level>"
```

- - RPL\_TRACE\*는 모두 TRACE 메시지에 대한 응답으로 서버에서 반환됩니다. 반환되는 개수는 TRACE 메시지와

- 교환원이 보낸 것인지 아닌지. 먼저 발생하는 사전 정의된 순서는 없습니다. 응답 RPL\_TRACEUNKNOWN, RPL\_TRACECONNECTING 및 RPL\_TRACEHANDSHAKE는 모두 완전히 설정되지 않았거나 알 수 없거나 아직 연결을 시도하거나 '서버 핸드셰이크'를 완료하는 과정에 있는 연결에 사용됩니다. RPL\_TRACELINK는 TRACE 메시지를 처리하는 모든 서버에서 전송되며 이를 다른 서버로 전달해야 합니다. IRC 네트워크를 통과하는 TRACE 명령에 대한 응답으로 전송된 RPL\_TRACELINK 목록은 해당 경로를 따라 서버 자체의 실제 연결을 반영해야 합니다. RPL\_TRACENEWTYPE은 다른 범주에 맞지 않지만 어쨌든 표시되는 모든 연결에 사용됩니다.

```text
        211     RPL_STATSLINKINFO
                        "<linkname> <sendq> <sent messages> \
                         <sent bytes> <received messages> \
                         <received bytes> <time open>"
        212     RPL_STATSCOMMANDS
                        "<command> <count>"
        213     RPL_STATSCLINE
                        "C <host> * <name> <port> <class>"
        214     RPL_STATSNLINE
                        "N <host> * <name> <port> <class>"
        215     RPL_STATSILINE
                        "I <host> * <host> <port> <class>"
        216     RPL_STATSKLINE
                        "K <host> * <username> <port> <class>"
        218     RPL_STATSYLINE
                        "Y <class> <ping frequency> <connect \
                         frequency> <max sendq>"
        219     RPL_ENDOFSTATS
                        "<stats letter> :End of /STATS report"
        241     RPL_STATSLLINE
                        "L <hostmask> * <servername> <maxdepth>"
        242     RPL_STATSUPTIME
                        ":Server Up %d days %d:%02d:%02d"
        243     RPL_STATSOLINE
                        "O <hostmask> * <name>"
        244     RPL_STATSHLINE
                        "H <hostmask> * <servername>"

        221     RPL_UMODEIS
                        "<user mode string>"
```

- - 클라이언트 자체 모드에 대한 쿼리에 응답하기 위해 RPL\_UMODEIS가 다시 전송됩니다.

```text
        251     RPL_LUSERCLIENT
                        ":There are <integer> users and <integer> \
                         invisible on <integer> servers"
        252     RPL_LUSEROP
                        "<integer> :operator(s) online"
        253     RPL_LUSERUNKNOWN
                        "<integer> :unknown connection(s)"
        254     RPL_LUSERCHANNELS
                        "<integer> :channels formed"
        255     RPL_LUSERME
                        ":I have <integer> clients and <integer> \
                          servers"
```

- - LUSERS 메시지를 처리할 때 서버는 RPL\_LUSERCLIENT, RPL\_LUSEROP, RPL\_USERUNKNOWN, RPL\_LUSERCHANNELS 및 RPL\_LUSERME에서 일련의 응답을 보냅니다. 응답할 때 서버는 RPL\_LUSERCLIENT 및 RPL\_LUSERME를 다시 보내야 합니다. 다른 응답은 0이 아닌 개수가 발견된 경우에만 다시 전송됩니다.

```text
        256     RPL_ADMINME
                        "<server> :Administrative info"
        257     RPL_ADMINLOC1
                        ":<admin info>"
        258     RPL_ADMINLOC2
                        ":<admin info>"
        259     RPL_ADMINEMAIL
                        ":<admin info>"
```

- - ADMIN 메시지에 응답할 때 서버는 RPL\_ADMINEMAIL을 통해 RLP\_ADMINME를 사용하고 각각에 대해 텍스트 메시지를 제공해야 합니다. RPL\_ADMINLOC1의 경우 서버가 있는 도시, 주 및 국가에 대한 설명이 필요하며 대학 및 학과\(RPL\_ADMINLOC2\)에 대한 세부 정보, 마지막으로 RPL\_ADMINEMAIL의 서버 관리 연락처\(여기에 이메일 주소가 필요함\)가 표시됩니다.

---
## **6.3 Reserved numerics.**

이러한 숫자는 다음 범주 중 하나에 속하므로 위에서 설명하지 않습니다.

```text
        1. no longer in use;

        2. reserved for future planned use;
```

- 3. 현재 사용 중이지만 현재 IRC 서버의 일반적이지 않은 '기능'의 일부입니다.

```text
        209     RPL_TRACECLASS          217     RPL_STATSQLINE
        231     RPL_SERVICEINFO         232     RPL_ENDOFSERVICES
        233     RPL_SERVICE             234     RPL_SERVLIST
        235     RPL_SERVLISTEND
        316     RPL_WHOISCHANOP         361     RPL_KILLDONE
        362     RPL_CLOSING             363     RPL_CLOSEEND
        373     RPL_INFOSTART           384     RPL_MYPORTIS
        466     ERR_YOUWILLBEBANNED     476     ERR_BADCHANMASK
        492     ERR_NOSERVICEHOST
```

---
## **7. Client and server authentication**

클라이언트와 서버는 모두 동일한 수준의 인증을 받습니다. 두 경우 모두 서버에 대한 모든 연결에 대해 호스트 이름 조회\(및 이에 대한 역방향 확인\)에 대한 IP 번호가 수행됩니다. 그러면 두 연결 모두 비밀번호 확인을 받게 됩니다\(해당 연결에 비밀번호가 설정된 경우\). 비밀번호 확인은 서버에서만 일반적으로 사용되지만 이러한 확인은 모든 연결에서 가능합니다.

점점 더 일반화되고 있는 추가 확인은 연결을 담당하는 사용자 이름에 대한 확인입니다. 연결의 다른 쪽 끝의 사용자 이름을 찾으려면 일반적으로 RFC 1413에 설명된 대로 IDENT와 같은 인증 서버에 연결해야 합니다.

비밀번호가 없으면 네트워크 연결의 상대방이 누구인지 확실하게 판단하기가 쉽지 않으므로 서버 간 연결에서는 ID 서버 사용과 같은 다른 조치 외에도 비밀번호를 사용하는 것이 좋습니다.

---
## **8. Current implementations**

이 프로토콜의 현재 구현은 IRC 서버 버전 2.8뿐입니다. 이전 버전에서는 이 문서에 설명된 명령 중 일부 또는 전부를 NOTICE 메시지로 대체하여 구현할 수 있습니다.

숫자로 답하는 경우가 많습니다. 불행하게도 이전 버전과의 호환성 요구 사항으로 인해 이 문서의 일부 구현은 설명된 내용에 따라 다릅니다. 주목할만한 차이점은 다음과 같습니다.

```text
        * recognition that any LF or CR anywhere in a message marks the
          end of that message (instead of requiring CR-LF);
```

이 섹션의 나머지 부분에서는 서버를 구현하려는 사람들에게 가장 중요한 문제를 다루지만 일부 부분은 클라이언트에도 직접 적용됩니다.

---
## **8.1 Network protocol: TCP - why it is best used here.**

IRC는 TCP가 이러한 규모의 회의에 매우 적합한 안정적인 네트워크 프로토콜을 제공하기 때문에 TCP 위에 구현되었습니다. 멀티캐스트 IP를 사용하는 것도 대안이지만 현재로서는 광범위하게 사용 가능하거나 지원되지 않습니다.

---
### **8.1.1 Support of Unix sockets**

```text
   Given that Unix domain sockets allow listen/connect operations, the
   current implementation can be configured to listen and accept both
   client and server connections on a Unix domain socket.  These are
   recognized as sockets where the hostname starts with a '/'.
```

Unix 도메인 소켓의 연결에 대한 정보를 제공할 때 서버는 실제 소켓 이름을 요청하지 않는 한 경로 이름 대신 실제 호스트 이름을 대체해야 합니다.

---
## **8.2 Command Parsing**

```text
   To provide useful 'non-buffered' network IO for clients and servers,
   each connection is given its own private 'input buffer' in which the
   results of the most recent read and parsing are kept.  A buffer size
   of 512 bytes is used so as to hold 1 full message, although, this
   will usually hold several commands.  The private buffer is parsed
   after every read operation for valid messages.  When dealing with
   multiple messages from one client in the buffer, care should be taken
   in case one happens to cause the client to be 'removed'.
```

---
## **8.3 Message delivery**

네트워크 링크가 포화되었거나 데이터를 보낼 수 없는 호스트나 데이터를 보내는 호스트를 찾는 것이 일반적입니다. Unix는 일반적으로 TCP 창과 내부 버퍼를 통해 이를 처리하지만 서버에는 전송할 데이터 양이 많은 경우가 많습니다\(특히 새 서버 간 링크가 형성되는 경우\).

나가는 대기열에 커널이 충분하지 않습니다. 이 문제를 완화하기 위해 전송될 데이터에 대한 FIFO 대기열로 "전송 대기열"이 사용됩니다. 일반적인 "전송 대기열"은 새 서버가 연결될 때 네트워크 연결이 느린 대규모 IRC 네트워크에서 200KB까지 커질 수 있습니다.

연결을 폴링할 때 서버는 먼저 들어오는 모든 데이터를 읽고 구문 분석하여 전송할 데이터를 대기열에 넣습니다. 사용 가능한 모든 입력이 처리되면 대기 중인 데이터가 전송됩니다. 이렇게 하면 write\(\) 시스템 호출 수가 줄어들고 TCP가 더 큰 패킷을 만드는 데 도움이 됩니다.

---
## **8.4 Connection 'Liveness'**

연결이 끊기거나 응답하지 않는 시기를 감지하려면 서버는 지정된 시간 내에 응답을 받지 못하는 각 연결을 ping해야 합니다.

연결이 시간 내에 응답하지 않으면 적절한 절차를 사용하여 연결을 닫습니다. 서버 프로세스 블록을 두는 것보다 느린 연결을 닫는 것이 더 낫기 때문에 sendq가 허용된 최대값을 초과하는 경우에도 연결이 삭제됩니다.

---
## **8.5 Establishing a server to client connection**

IRC 서버에 연결되면 클라이언트는 MOTD\(있는 경우\)와 현재 사용자/서버 수\(LUSER 명령에 따라\)를 보냅니다. 서버는 또한 이름과 버전을 명시하는 명확한 메시지와 적절하다고 간주되는 기타 소개 메시지를 클라이언트에게 제공해야 합니다.

이 문제를 처리한 후 서버는 자체적으로 제공되고\(USER 명령\) 서버가 검색할 수 있는 대로\(DNS/인증 서버에서\) 새 사용자의 별명과 기타 정보를 보내야 합니다. 서버는 이 정보를 먼저 NICK, 그 다음 USER로 보내야 합니다.

---
## **8.6 Establishing a server-server connection.**

서버 간 연결을 설정하는 프로세스에는 문제가 발생할 수 있는 영역이 많이 있기 때문에 위험이 따릅니다. 그 중 경쟁 조건은 가장 적습니다.

서버가 유효한 것으로 인식된 PASS/SERVER 쌍에 따른 연결을 수신한 후, 서버는 설명된 대로 알고 있는 다른 모든 상태 정보뿐만 아니라 해당 연결에 대한 자체 PASS/SERVER 정보로 응답해야 합니다. 아래에.

시작 서버가 PASS/SERVER 쌍을 수신하면 서버도 마찬가지입니다.

해당 서버에 대한 연결을 수락하기 전에 응답하는 서버가 올바르게 인증되었는지 확인합니다.

---
### **8.6.1 Server exchange of state information when connecting**

서버 간에 교환되는 상태 정보의 순서는 필수적입니다. 필수 순서는 다음과 같습니다.

```text
        * all known other servers;

        * all known user information;

        * all known channel information.
```

서버 관련 정보는 추가 SERVER 메시지, 사용자 정보는 NICK/USER/MODE/JOIN 메시지, 채널은 MODE 메시지를 통해 전송됩니다.

참고: TOPIC 명령이 이전 주제 정보를 덮어쓰기 때문에 채널 주제는 여기에서 교환되지 \*않습니다\*. 따라서 기껏해야 연결의 양측이 주제를 교환합니다.

서버에 대한 상태 정보를 먼저 전달함으로써 특정 닉네임을 도입한 두 번째 서버로 인해 닉네임 충돌이 발생하기 전에 이미 존재하는 서버와의 충돌이 먼저 발생합니다. IRC 네트워크는 비순환 그래프로만 존재할 수 있기 때문에 네트워크가 이미 다른 위치, 즉 충돌이 발생하는 곳에서 네트워크가 분할되어야 하는 위치에 다시 연결되었을 수도 있습니다.

---
## **8.7 Terminating server-client connections**

클라이언트 연결이 닫히면 클라이언트가 연결된 서버가 클라이언트를 대신하여 QUIT 메시지를 생성합니다. 다른 메시지는 생성되거나 사용되지 않습니다.

---
## **8.8 Terminating server-server connections**

서버 간 연결이 원격으로 생성된 SQUIT 또는 '자연스러운' 원인을 통해 닫히면 연결된 IRC 네트워크의 나머지 부분은 닫힘을 감지한 서버에 의해 업데이트된 정보를 가져야 합니다. 그런 다음 서버는 SQUIT 목록\(해당 연결 뒤에 있는 각 서버에 하나씩\)과 QUIT 목록\(다시 말하면 해당 연결 뒤에 있는 각 클라이언트에 하나씩\)을 보냅니다.

---
## **8.9 Tracking nickname changes**

모든 IRC 서버는 최근 닉네임 변경 내역을 보관해야 합니다. 이는 닉네임 변경 경쟁 조건이 해당 항목을 조작하는 명령으로 발생할 때 서버가 해당 항목에 계속 연락할 수 있도록 하는 데 필요합니다. 닉 변경을 추적해야 하는 명령은 다음과 같습니다.

```text
        * KILL (the nick being killed)

        * MODE (+/- o,v)

        * KICK (the nick being kicked)
```

다른 명령에서는 닉네임 변경 사항을 확인할 수 없습니다.

위의 경우 서버는 먼저 닉네임이 있는지 확인한 다음 해당 닉네임이 현재 누구에게 속해 있는지\(누구인지!\) 기록을 확인해야 합니다. 이렇게 하면 경쟁 조건이 발생할 가능성이 줄어들지만 서버가 잘못된 클라이언트에 영향을 미치면서 여전히 발생할 수 있습니다. 위 명령에 대한 변경 추적을 수행할 때 시간 범위를 지정하고 너무 오래된 항목은 무시하는 것이 좋습니다.

합리적인 기록을 위해 서버는 모든 클라이언트가 변경하기로 결정했는지 알고 있는 모든 클라이언트에 대해 이전 별명을 유지할 수 있어야 합니다. 이 크기는 다른 요인\(예: 메모리 등\)에 의해 제한됩니다.

---
## **8.10 Flood control of clients**

상호 연결된 IRC 서버의 대규모 네트워크를 사용하면 네트워크에 연결된 단일 클라이언트가 연속적인 메시지 스트림을 제공하기가 매우 쉽습니다. 이로 인해 네트워크가 넘칠 뿐만 아니라 다른 사용자에게 제공되는 서비스 수준이 저하됩니다. 모든 '피해자'에게 자신의 보호 기능을 제공하도록 요구하는 대신 홍수 방지 기능이 서버에 기록되어 서비스를 제외한 모든 클라이언트에 적용됩니다. 현재 알고리즘은 다음과 같습니다.

```text
        * check to see if client's `message timer' is less than
          current time (set to be equal if it is);

        * read any data present from the client;

        * while the timer is less than ten seconds ahead of the current
          time, parse any present messages and penalize the client by
          2 seconds for each message;
```

이는 본질적으로 클라이언트가 2분마다 1개의 메시지를 보낼 수 있음을 의미합니다.

부정적인 영향을 받지 않고 초.

---
## **8.11 Non-blocking lookups**

실시간 환경에서는 모든 클라이언트가 공평하게 서비스를 받을 수 있도록 서버 프로세스가 가능한 한 대기 시간을 최소화하는 것이 중요합니다. 분명히 이를 위해서는 모든 네트워크 읽기/쓰기 작업에 대한 비차단 IO가 필요합니다. 일반적인 서버 연결의 경우 어렵지 않았지만 서버를 차단할 수 있는 다른 지원 작업\(예: 디스크 읽기\)이 있습니다. 가능하다면 그러한 활동은 짧은 시간 초과로 수행되어야 합니다.

---
### **8.11.1 Hostname (DNS) lookups**

Berkeley 및 다른 곳의 표준 확인자 라이브러리를 사용하면 응답 시간이 초과되는 경우에 큰 지연이 발생했습니다. 이를 방지하기 위해 비차단 IO 작업을 위해 설정된 다음 기본 서버 IO 루프 내에서 폴링되는 별도의 DNS 루틴 세트가 작성되었습니다.

---
### **8.11.2 Username (Ident) lookups**

다른 프로그램에 사용하고 포함할 수 있는 ID 라이브러리가 많지만 동기식으로 작동하고 빈번한 지연이 발생하므로 문제가 발생했습니다. 이번에도 해결책은 서버의 나머지 부분과 협력하고 비차단 IO를 사용하여 작동하는 일련의 루틴을 작성하는 것이었습니다.

---
## **8.12 Configuration File**

서버를 설정하고 실행하는 유연한 방법을 제공하려면 다음 사항에 대한 서버 지침이 포함된 구성 파일을 사용하는 것이 좋습니다.

```text
        * which hosts to accept client connections from;

        * which hosts to allow to connect as servers;

        * which hosts to connect to (both actively and
          passively);

        * information about where the server is (university,
          city/state, company are examples of this);

        * who is responsible for the server and an email address
          at which they can be contacted;
```

- \* 제공을 원하는 클라이언트의 호스트 이름과 비밀번호

- 제한된 운영자 명령에 대한 액세스.

호스트 이름을 지정할 때 도메인 이름과 '점' 표기법\(127.0.0.1\) 사용이 모두 허용되어야 합니다. 나가고 들어오는 모든 연결에 대해 사용/수락할 비밀번호를 지정할 수 있어야 합니다\(나가는 연결만 다른 서버에 대한 연결임에도 불구하고\).

위 목록은 다른 서버와 연결을 원하는 서버의 최소 요구 사항입니다. 사용할 수 있는 기타 항목은 다음과 같습니다.

```text
        * specifying which servers other server may introduce;

        * how deep a server branch is allowed to become;
```

- \* 클라이언트가 연결할 수 있는 시간.

---
### **8.12.1 Allowing clients to connect**

서버는 시작 시 읽고 클라이언트가 서버에 연결하는 데 사용할 수 있는 호스트를 결정하는 데 사용되는 일종의 '액세스 제어 목록'\(구성 파일이나 다른 곳에 있음\)을 사용해야 합니다.

호스트 액세스 제어에 필요한 유연성을 제공하려면 '거부'와 '허용'을 모두 구현해야 합니다.

---
### **8.12.2 Operators**

파괴적인 사람에게 운영자 권한을 부여하는 것은 그들에게 부여된 권한으로 인해 일반적으로 IRC 넷의 안녕에 심각한 결과를 초래할 수 있습니다. 따라서 그러한 권한을 획득하는 것이 그리 쉽지는 않습니다. 현재 설정에서는 두 개의 '비밀번호'를 사용해야 하지만 그 중 하나는 일반적으로 쉽게 추측할 수 있습니다. 구성 파일에 운영자 비밀번호를 저장하는 것이 하드 코딩하는 것보다 바람직하며 쉽게 도난당하지 않도록 암호화된 형식\(예: Unix의 crypt\(3\) 사용\)으로 저장해야 합니다.

---
### **8.12.3 Allowing servers to connect**

서버의 상호 연결은 사소한 문제가 아닙니다. 잘못된 연결은 IRC의 유용성에 큰 영향을 미칠 수 있습니다. 따라서 각 서버에는 연결할 수 있는 서버 목록과 연결할 수 있는 서버 목록이 있어야 합니다. 어떤 상황에서도 서버는 임의의 호스트가 서버로 연결되는 것을 허용해서는 안 됩니다. 어떤 서버가 연결될 수 있고 연결되지 않을 수 있는지 외에도 구성 파일은 해당 링크의 비밀번호와 기타 특성도 저장해야 합니다.

---
### **8.12.4 Administrivia**

ADMIN 명령\(섹션 4.3.7 참조\)에 정확하고 유효한 응답을 제공하려면 서버가 구성에서 관련 세부 정보를 찾아야 합니다.

---
## **8.13 Channel membership**

현재 서버에서는 등록된 로컬 사용자가 최대 10개의 다른 채널에 참여할 수 있습니다. 서버가 채널 멤버십 기반으로 다른 모든 사용자와 \(합리적으로\) 일관성을 유지하도록 로컬이 아닌 사용자에게 제한이 없습니다.

---
## **9. Current problems**

이 프로토콜에는 여러 가지 인식된 문제가 있으며, 모두 재작성 중에 가까운 시일 내에 해결될 수 있기를 바랍니다. 현재 이러한 문제에 대한 효과적인 해결책을 찾기 위한 작업이 진행 중입니다.

---
## **9.1 Scalability**

이 프로토콜은 대규모 경기장에서 사용될 때 충분히 확장되지 않는다는 것이 널리 알려져 있습니다. 주요 문제는 모든 서버가 다른 모든 서버와 사용자에 대해 알고 있어야 하고 이들에 관한 정보가 변경되는 즉시 업데이트되어야 한다는 요구 사항에서 비롯됩니다. 또한 두 지점 사이의 경로 길이를 최소화하고 스패닝 트리가 최대한 강력하게 분기되도록 서버 수를 낮게 유지하는 것이 바람직합니다.

---
## **9.2 Labels**

현재 IRC 프로토콜에는 닉네임, 채널 이름, 서버 이름의 세 가지 유형의 레이블이 있습니다. 세 가지 유형 각각에는 자체 도메인이 있으며 해당 도메인 내에서는 중복이 허용되지 않습니다. 현재는 사용자가 세 가지 중 하나의 라벨을 선택하여 충돌이 발생할 수 있습니다. 순환 트리를 허용하는 솔루션뿐만 아니라 충돌하지 않는 채널 및 닉에 대한 고유한 이름에 대한 계획을 세우는 등 재작업이 필요하다는 것이 널리 알려져 있습니다.

---
### **9.2.1 Nicknames**

IRC의 닉네임 아이디어는 사용자가 채널 외부에서 서로 대화할 때 사용하기 매우 편리하지만 닉네임 공간은 한정되어 있고 그대로 사용하기 때문에 여러 사람이 동일한 것을 사용하는 경우가 많습니다. 건강 상태. 이 프로토콜을 사용하여 두 사람이 닉네임을 선택하면 둘 중 하나가 성공하지 못하거나

둘 다 KILL\(4.6.1\)을 사용하여 제거됩니다.

---
### **9.2.2 Channels**

현재 채널 레이아웃에서는 모든 서버가 모든 채널, 해당 채널의 거주자 및 속성에 대해 알아야 합니다. 확장성이 좋지 않은 것 외에도 개인 정보 보호 문제도 우려됩니다. 채널 충돌은 닉네임 충돌을 해결하는 데 사용되는 것과 같은 단독 이벤트가 아닌 포괄적 이벤트\(새 채널을 생성하는 두 사람 모두 해당 채널의 구성원으로 간주됨\)로 처리됩니다.

---
### **9.2.3 Servers**

일반적으로 서버 수는 사용자 및 채널 수에 비해 적지만 현재는 두 서버를 각각 별도로 또는 마스크 뒤에 숨겨 전역적으로 알려야 합니다.

---
## **9.3 Algorithms**

서버 코드 내의 일부 위치에서는 클라이언트 집합의 채널 목록을 확인하는 것과 같은 N^2 알고리즘을 피하는 것이 불가능했습니다.

현재 서버 버전에는 데이터베이스 일관성 검사가 없으며 각 서버는 인접 서버가 올바른 것으로 가정합니다. 연결 서버에 버그가 있거나 기존 네트워크에 모순이 발생하려고 하면 큰 문제가 발생할 수 있습니다.

현재 고유한 내부 및 글로벌 레이블이 없기 때문에 다양한 경쟁 조건이 존재합니다. 이러한 경쟁 조건은 일반적으로 메시지가 IRC 네트워크를 통과하여 영향을 미치는 데 시간이 걸리는 문제로 인해 발생합니다. 고유한 라벨로 변경하더라도 채널 관련 명령이 중단되는 문제가 있습니다.

---
## **10. Current support and availability**

```text
           Mailing lists for IRC related discussion:
                Future protocol: ircd-three-request@eff.org
                General discussion: operlist-request@eff.org

           Software implemenations
                cs.bu.edu:/irc
                nic.funet.fi:/pub/irc
                coombs.anu.edu.au:/pub/irc

           Newsgroup: alt.irc
```

---
# **Security Considerations**

보안 문제는 섹션 4.1, 4.1.1, 4.1.3, 5.5 및 7에서 논의됩니다.

---
## **12. Authors' Addresses**

Jarkko Oikarinen Tuirantie 17 as 9 90500 OULU 핀란드

```text
   Email: jto@tolsun.oulu.fi

   Darren Reed
   4 Pateman Street
   Watsonia, Victoria 3087
   Australia

   Email: avalon@coombs.anu.edu.au
```


```text
Network Working Group                                        A. Shoshani
Request for Comments: 44                                         R. Long
                                                            A. Landsberg
                                          System Development Corporation
                                                           10 April 1970
```

- NWG/RFC 33 및 36에 대한 의견

일반적으로 우리는 새로운 호스트 간 프로토콜에 대한 제안에 만족합니다. 그러나 몇 가지 개선 사항이 도움이 될 수 있다고 생각합니다.

I. 다시 연결되는 경우는 두 가지인 것 같습니다.

1. 로컬 호스트의 소켓에서 로컬 호스트의 다른 소켓으로 다시 연결합니다. 이는 RFC #33에서 "스위치"로 참조되었습니다. 로컬 소켓은 다른 프로세스\(예: 방금 생성된 다른 프로세스로 연결을 전환하는 "로그인" 프로세스\)에 속하거나 동일한 프로세스\(예: 특정 소켓에 대한 연결 호출을 수락하는 프로세스\)에 속할 수 있습니다. 연결이 설정되면 다른 소켓으로 전환됩니다.

2. 로컬 호스트의 소켓에서 외부 호스트의 소켓으로 다시 연결합니다.

우리는 다음과 같은 이유로 이 두 가지 사례를 분리할 것을 제안합니다. a\) 사례 1의 재연결은 필요하고 유용하지만 사례 2의 유용성은 여전히 ​​의구심이 듭니다.

b\) 사례 1은 구현하기가 간단하지만\(적어도 개념적으로는\) 사례 2는 네트워크의 비동기 특성으로 인해 정교한 명령 메커니즘을 포함합니다\(RFC #36에서는 사례 2를 처리하기 위해 9개의 명령 중 4개가 제안되었습니다\).

```text
     Thus we think that at least in the first usage of the Host-to-Host
     protocol reconnection in Case 2 should be left out.  An additional
     system call (not a command) is therefore needed to permit Case 1,
     which is SWITCH <socket 1> <socket 2>.
```

II. RFC #36에서 제안된 CLOSE 명령은 연결을 차단하고 연결을 중단하는 두 가지 목적으로 사용되는 것으로 보입니다. 모호함을 피하기 위해 BLOCK과 CLOSE라는 두 가지 명령을 사용하는 것이 바람직합니다. RFC #36에서 제안된 대로 두 명령에 대한 응답은 BLOCK 또는 CLOSE 명령의 수신을 확인하는 SUSPEND 명령일 수 있습니다.

III. 연결이 설정된 후에는 로컬 연결 테이블에 "외부 소켓"을 유지할 이유가 없습니다. 외부 호스트의 링크 번호와 외부 소켓 번호 사이에는 일대일 대응이 있으므로 명령에 링크 번호를 사용할 수 있습니다. 따라서 RFC 명령을 제외한 모든 명령은 링크 번호를 사용할 수 있으므로 연결 테이블의 모든 항목에서 40비트 외부 소켓 번호를 제거합니다\(일부 호스트에서는 크기가 중요함\). RFC #38에서 제안한 대로 연결이 링크를 통해 다중화되는 경우 연결 테이블에 외부 소켓이 필요합니다.

IV. RFC#33에서는 PORT라는 용어가 도입되었습니다. 이는 모든 호스트에게 비공개이지만 의견이 있습니다. 일부 사용자의 포트와 소켓 사이에 일대일 대응이 있도록 포트가 사용되는 경우 포트는 완전히 중복됩니다. 그러나 호스트는 연결을 통해 포트를 다중화하기를 원할 수 있으며, 이 경우 추가 메커니즘이 필요합니다.

마지막 네 가지 의견을 요약하면 초기 버전에서는 다음 시스템 호출과 명령이 사용될 것을 제안합니다\(대부분 RFC 33 및 36에 있음\).

```text
   System Calls:
   1) INITIATE <my socket> <your socket>
   2) ACCEPT  <my socket>
   3) SWITCH <socket 1> <socket 2>
   4) LISTEN <my socket>
   5) CLOSE <my socket>
   6) TRANSMIT <my socket> <address>
```

명령: RFC #36\(5페이지\)의 명령 0, 1, 3, 4 및 추가: 1\) BLOCK: BLK <link\> 2\) CLOSE: CLS <link\>

V. 위의 내용 외에도 프로토콜의 첫 번째 버전과 함께 다음 문제를 어떤 방식으로든 결정하는 것이 필요해 보입니다\(아마도 사람들이 자신의 선호도를 표현하고 그에 따라 결정하는 날짜를 설정함으로써\). 이 모든 문제는 1970년 3월 17일 UCLA 회의에서 언급되었으나 무시되었습니다.

- 1. "Double padding" - 메시지가 단어 경계에서 끝나지 않는 경우. 두 가지 가능한 솔루션이 언급되었습니다.

- a\) 호스트는 IMP의 패딩\(이중 패딩\)에 추가로 패딩을 제공합니다.

- b\) 호스트는 메시지를 이동하고\(필요한 경우\) 그에 따라 "표시"를 조정하여 모든 메시지가 단어 경계에서 끝나는지 확인합니다.

2. "반향" - 세 가지 가능성이 있습니다.

- a\) 에코 b\) 에코 없음 c\) 선택적 에코 - "리더"의 비트를 사용하여 이 옵션을 지정할 수 있습니다.

- 3. "코드 변환" - 원래 BB&N은 ASCII-8을 공통 코드로 사용하여 IMP에서 변환을 수행할 것을 제안했습니다. 이는 주로 ASCII-8이 그래픽과 같은 일부 용도에 비해 충분히 크지 않다는 주장 때문에 거부되었습니다. 또한 IMP의 변환으로 인해 속도가 느려지고 버퍼에 사용될 수 있는 공간을 차지할 수 있습니다. 우리는 들어오는 모든 문자 메시지가 동일한 코드에 있고 단 하나의 변환 테이블만 필요하도록 공통 코드를 갖는 것이 매우 바람직하다고 생각합니다\(IMP에 의해 변환이 수행되지 않는 경우에도\). 보내는 문자 메시지는 이 공통 코드로 변환되어야 합니다. 당연히 바이너리 데이터나 공통 코드에서 표현할 수 없는 데이터의 경우에는 "번역 없음" 옵션이 가능해야 합니다. 알려진 모든 코드는 일부 목적에 비해 너무 제한적인 것으로 간주될 수 있으므로 NCC\(네트워크 공통 코드\)를 채택하고 가능한 256개 문자\(8비트 코드의 경우\)를 모두 사용하여 코드의 "중요" 부분을 포함하는 것이 좋습니다. 네트워크 전체에서 사용되는 코드의 통합.

6. 위의 문제에 대한 우리의 선호 사항은 다음과 같습니다.

- a\) "이중 패딩" - 데이터 대신 메시지의 리더를 이동하고 이에 따라 "마킹"을 조정하여 메시지가 단어 경계에서 전송되도록 하는 것이 쉬운 것으로 나타났습니다. 따라서 우리는 솔루션 V.1.b를 선호합니다. b\) "반향" - 반향이 없는 것을 선호합니다. 우리는 문자 반향이 로컬에서 관리되어야 한다고 생각합니다. c\) "코드 변환"에서는 네트워크 공통 코드를 선호합니다. 처음에는 ASCII-8을 사용할 수 있으며 이후 네트워크 필요에 따라 확장할 수 있습니다.

- \[ 이 RFC는 입력을 위해 기계 판독 가능한 형식으로 작성되었습니다. \] \[ Alison De La Cruz의 온라인 RFC 아카이브에 12/00 \]


```text
Network Working Group                                         D. M'Raihi
Request for Comments: 4226                                      VeriSign
Category: Informational                                       M. Bellare
                                                                    UCSD
                                                            F. Hoornaert
                                                                   Vasco
                                                             D. Naccache
                                                                 Gemplus
                                                                O. Ranen
                                                                 Aladdin
                                                           December 2005

           HOTP: An HMAC-Based One-Time Password Algorithm
```

---
# **Status of This Memo**

이 메모는 인터넷 커뮤니티에 대한 정보를 제공합니다. 어떤 종류의 인터넷 표준도 지정하지 않습니다. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(2005\).

---
# **Abstract**

이 문서에서는 해시된 메시지 인증 코드\(HMAC\)를 기반으로 일회용 비밀번호 값을 생성하는 알고리즘을 설명합니다. 알고리즘의 보안 분석이 제시되고, 알고리즘의 보안 배포와 관련된 중요한 매개변수가 논의됩니다. 제안된 알고리즘은 원격 VPN\(가상 사설망\) 액세스, Wi-Fi 네트워크 로그온부터 트랜잭션 지향 웹 애플리케이션에 이르는 광범위한 네트워크 애플리케이션에서 사용할 수 있습니다.

이 작업은 기술 커뮤니티에 자유롭게 배포할 수 있는 알고리즘을 지정하기 위한 OATH\(Open AuTHentication\) 멤버십의 공동 노력입니다. 저자는 공통의 공유 알고리즘이 상용 및 오픈 소스 구현 전반에 걸쳐 상호 운용성을 가능하게 함으로써 인터넷에서 2단계 인증 채택을 촉진할 것이라고 믿습니다.

---
# **Table of Contents**

```text
   1. Overview ........................................................3
   2. Introduction ....................................................3
   3. Requirements Terminology ........................................4
   4. Algorithm Requirements ..........................................4
   5. HOTP Algorithm ..................................................5
      5.1. Notation and Symbols .......................................5
      5.2. Description ................................................6
      5.3. Generating an HOTP Value ...................................6
      5.4. Example of HOTP Computation for Digit = 6 ..................7
   6. Security Considerations .........................................8
   7. Security Requirements ...........................................9
      7.1. Authentication Protocol Requirements .......................9
      7.2. Validation of HOTP Values .................................10
      7.3. Throttling at the Server ..................................10
      7.4. Resynchronization of the Counter ..........................11
      7.5. Management of Shared Secrets ..............................11
   8. Composite Shared Secrets .......................................14
   9. Bi-Directional Authentication ..................................14
   10. Conclusion ....................................................15
   11. Acknowledgements ..............................................15
   12. Contributors ..................................................15
   13. References ....................................................15
      13.1. Normative References .....................................15
      13.2. Informative References ...................................16
   Appendix A - HOTP Algorithm Security: Detailed Analysis ...........17
      A.1. Definitions and Notations .................................17
      A.2. The Idealized Algorithm: HOTP-IDEAL .......................17
      A.3. Model of Security .........................................18
      A.4. Security of the Ideal Authentication Algorithm ............19
           A.4.1. From Bits to Digits ................................19
           A.4.2. Brute Force Attacks ................................21
           A.4.3. Brute force attacks are the best possible attacks ..22
      A.5. Security Analysis of HOTP .................................23
   Appendix B - SHA-1 Attacks ........................................25
      B.1. SHA-1 Status ..............................................25
      B.2. HMAC-SHA-1 Status .........................................26
      B.3. HOTP Status ...............................................26
   Appendix C - HOTP Algorithm: Reference Implementation .............27
   Appendix D - HOTP Algorithm: Test Values ..........................32
   Appendix E - Extensions ...........................................33
      E.1. Number of Digits ..........................................33
      E.2. Alphanumeric Values .......................................33
      E.3. Sequence of HOTP values ...................................34
      E.4. A Counter-Based Resynchronization Method ..................34
      E.5. Data Field ................................................35
```

---
## **1.  Overview**

이 문서에서는 먼저 HMAC \[BCK1\]을 기반으로 일회용 비밀번호 값을 생성하는 알고리즘에 대한 컨텍스트를 소개하므로 이를 HMAC 기반 일회용 비밀번호\(HOTP\) 알고리즘이라고 합니다. 4장에서는 알고리즘 요구 사항을 나열하고 5장에서는 HOTP 알고리즘을 설명합니다. 섹션 6과 7에서는 알고리즘 보안에 중점을 둡니다. 섹션 8에서는 일부 확장 및 개선 사항을 제안하고 섹션 10에서는 이 문서를 마무리합니다. 관심 있는 독자는 부록 A에서 알고리즘 보안에 대한 자세하고 본격적인 분석을 찾을 수 있습니다. 즉, 이상적인 버전의 알고리즘을 평가한 다음 HOTP 알고리즘 보안을 분석합니다.

---
## **2.  Introduction**

오늘날 이중 인증 배포는 범위와 규모가 극도로 제한되어 있습니다. 점점 더 높은 수준의 위협과 공격에도 불구하고 대부분의 인터넷 애플리케이션은 여전히 ​​사용자 액세스를 감시하기 위해 취약한 인증 체계에 의존하고 있습니다. 하드웨어 및 소프트웨어 기술 공급업체 간의 상호 운용성 부족은 이중 인증 기술 채택을 제한하는 요인이었습니다. 특히 개방형 사양이 없기 때문에 독점 기술을 통해 하드웨어와 소프트웨어 구성 요소가 긴밀하게 결합되는 솔루션이 생겨 솔루션 비용이 많이 들고 채택률이 낮으며 혁신이 제한되었습니다.

지난 2년 동안 네트워크 위협이 급증하면서 인터넷에서 기본 인증 수단으로 사용되는 정적 비밀번호의 부적절함이 드러났습니다. 동시에 최종 사용자가 네트워크 인증에만 사용되는 고가의 단일 기능 장치를 휴대해야 하는 현재 접근 방식은 확실히 정답이 아닙니다. 이중 인증이 인터넷에 전파되려면 다양한 애플리케이션에서 작동할 수 있는 보다 유연한 장치에 내장되어야 합니다.

광범위한 상호 운용성을 보장하면서 이 기본 기술을 내장하려면 하드웨어 및 소프트웨어 개발자로 구성된 광범위한 기술 커뮤니티에서 이를 무료로 사용할 수 있어야 합니다. 개방형 시스템 접근 방식만이 기본적인 2단계 인증 기본 요소를 USB 대용량 저장 장치, IP 전화, 개인 휴대 단말기 등 차세대 소비자 장치에 내장할 수 있도록 보장합니다.

일회용 비밀번호는 확실히 네트워크 액세스 보안을 위한 2단계 인증 중 가장 간단하고 널리 사용되는 형태 중 하나입니다. 예를 들어 대기업에서는 가상 사설망\(Virtual Private Network\)에 액세스하려면 원격 사용자 인증을 위해 일회용 암호 토큰을 사용해야 하는 경우가 많습니다. 더 강력한 비밀번호보다 일회용 비밀번호를 선호하는 경우가 많습니다.

공개 키 인프라\(PKI\) 또는 생체 인식과 같은 인증 형식을 사용하는 에어 갭 장치는 사용자 컴퓨터에 클라이언트 데스크톱 소프트웨어를 설치할 필요가 없으므로 가정용 컴퓨터, 키오스크 및 컴퓨터를 포함한 여러 컴퓨터 간에 로밍할 수 있습니다. 개인 디지털 비서.

이 문서에서는 하드웨어 제조업체나 소프트웨어 개발자가 구현하여 상호 운용 가능한 인증 장치 및 소프트웨어 에이전트를 만들 수 있는 간단한 일회용 비밀번호 알고리즘을 제안합니다. 알고리즘은 이벤트 기반이므로 Java 스마트 카드, USB 동글 및 GSM SIM 카드와 같은 대용량 장치에 내장될 수 있습니다. 제시된 알고리즘은 IETF 지적 재산권 \[RFC3979\]의 약관에 따라 개발자 커뮤니티에서 무료로 사용할 수 있습니다.

이 문서의 작성자는 Open AuTHentication 이니셔티브 \[OATH\]의 회원입니다. 이 계획은 강력한 인증 기술 제공업체 간의 협력을 촉진하기 위해 2004년에 만들어졌습니다.

---
## **3.  Requirements Terminology**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
## **4.  Algorithm Requirements**

이 섹션에서는 이 알고리즘 설계를 주도한 주요 요구 사항을 제시합니다. 최종 소비자의 유용성과 최소한의 사용자 인터페이스 기능을 제공할 수 있는 저가형 하드웨어로 알고리즘을 구현할 수 있는 능력이 많이 강조되었습니다. 특히, 대용량 SIM 및 Java 카드에 알고리즘을 내장하는 기능은 기본적인 전제 조건이었습니다.

R1 - 알고리즘은 반드시 시퀀스 기반 또는 카운터 기반이어야 합니다. 목표 중 하나는 Java 스마트 카드, USB 동글 및 GSM SIM 카드와 같은 대용량 장치에 HOTP 알고리즘을 내장하는 것입니다.\(MUST\)

R2 - 알고리즘은 배터리, 버튼 수, 계산 마력 및 LCD 디스플레이 크기에 대한 요구 사항을 최소화하여 하드웨어에서 구현하는 것이 경제적이어야 합니다.\(SHOULD\)

R3 - 알고리즘은 숫자 입력을 지원하지 않는 토큰과 함께 작동해야 하지만 보안 PIN 패드와 같은 보다 정교한 장치와 함께 사용할 수도 있습니다.\(MUST\)

R4 - 토큰에 표시된 값은 사용자가 쉽게 읽고 입력해야 합니다. 이를 위해서는 HOTP 값이 합리적인 길이여야 합니다.\(MUST\)

HOTP 값은 6자리 이상의 값이어야 합니다. 또한 HOTP 값은 휴대폰 등 제한된 기기에서 쉽게 입력할 수 있도록 '숫자만'으로 설정하는 것이 바람직하다.

R5 - 카운터를 재동기화하는 데 사용할 수 있는 사용자 친화적인 메커니즘이 있어야 합니다. 섹션 7.4 및 부록 E.4에서는 이 문서에서 제안된 재동기화 메커니즘을 자세히 설명합니다.\(MUST\)

R6 - 알고리즘은 강력한 공유 비밀을 사용해야 합니다. 공유 비밀의 길이는 128비트 이상이어야 합니다. 이 문서에서는 160비트의 공유 비밀 길이를 권장합니다.\(MUST, MUST\)

---
## **5.  HOTP Algorithm**

이 섹션에서는 표기법을 소개하고 HOTP 알고리즘 기본 블록, 즉 HMAC-SHA-1 값을 계산하는 기본 함수와 HOTP 값을 추출하는 절단 방법을 설명합니다.

---
### **5.1.  Notation and Symbols**

문자열은 항상 0과 1의 시퀀스를 의미하는 이진 문자열을 의미합니다.

s가 문자열이면 |s| 그 길이를 나타냅니다.

n이 숫자이면 |n| 절대값을 나타냅니다.

s가 문자열이면 s\[i\]는 i번째 비트를 나타냅니다. 비트 번호는 0부터 시작하므로 s = s\[0\]s\[1\]...s\[n-1\] 여기서 n = |s| s의 길이입니다.

StToNum\(문자열을 숫자로\)은 입력으로 문자열 s가 이진 표현이 s인 숫자를 반환하는 함수를 나타냅니다. \(예를 들어 StToNum\(110\) = 6입니다.\)

다음은 이 문서에 사용된 기호 목록입니다.

```text
   Symbol  Represents
   -------------------------------------------------------------------
   C       8-byte counter value, the moving factor.  This counter
           MUST be synchronized between the HOTP generator (client)
           and the HOTP validator (server).
```

K 클라이언트와 서버 간의 공유 비밀; 각 HOTP

- 발전기에는 독특하고 독특한 비밀 K가 있습니다.

T 제한 매개변수: T개의 인증 시도가 실패하면 서버는 사용자의 연결을 거부합니다.

s 재동기화 매개변수: 서버는 s 연속 카운터 값에 걸쳐 수신된 인증자를 확인하려고 시도합니다.

숫자 HOTP 값의 자릿수입니다. 시스템 매개변수.

---
### **5.2.  Description**

HOTP 알고리즘은 증가하는 카운터 값과 토큰 및 유효성 검사 서비스에만 알려진 정적 대칭 키를 기반으로 합니다. HOTP 값을 생성하기 위해 RFC 2104 \[BCK2\]에 정의된 HMAC-SHA-1 알고리즘을 사용합니다.

HMAC-SHA-1 계산의 출력은 160비트이므로 이 값을 사용자가 쉽게 입력할 수 있는 값으로 잘라야 합니다.

```text
                   HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))

   Where:
```

- Truncate는 5.3절에서 정의한 바와 같이 HMAC-SHA-1 값을 HOTP 값으로 변환하는 함수를 나타낸다.

키\(K\), 카운터\(C\) 및 데이터 값은 상위 바이트부터 해시됩니다.

HOTP 생성기에서 생성된 HOTP 값은 빅 엔디안으로 처리됩니다.

---
### **5.3.  Generating an HOTP Value**

작업을 3가지 단계로 설명할 수 있습니다.

1단계: HMAC-SHA-1 값 생성 Let HS = HMAC-SHA-1\(K,C\) // HS는 20바이트 문자열입니다.

2단계: 4바이트 문자열 생성\(동적 잘림\) Let Sbits = DT\(HS\) // 아래 정의된 DT는 // 31비트 문자열을 반환합니다.

3단계: HOTP 값 계산 Let Snum = StToNum\(Sbits\) // S를 0...2^{31}-1의 숫자로 변환 Return D = Snum mod 10^Digit // D는 범위의 숫자입니다. 0...10^{숫자}-1

Truncate 함수는 2단계와 3단계, 즉 동적 잘라내기와 10^Digit 모듈로 감소를 수행합니다. 동적 오프셋 잘림 기술의 목적은 160비트\(20바이트\) HMAC-SHA-1 결과에서 4바이트 동적 이진 코드를 추출하는 것입니다.

```text
    DT(String) // String = String[0]...String[19]
     Let OffsetBits be the low-order 4 bits of String[19]
     Offset = StToNum(OffsetBits) // 0 <= OffSet <= 15
     Let P = String[OffSet]...String[OffSet+3]
     Return the Last 31 bits of P
```

P의 가장 중요한 비트를 마스크하는 이유는 부호 있는 모듈로 계산과 부호 없는 모듈로 계산에 대한 혼동을 피하기 위한 것입니다. 서로 다른 프로세서는 이러한 작업을 다르게 수행하며 부호 있는 비트를 마스킹하면 모든 모호성이 제거됩니다.

구현 시 최소 7자리 및 8자리 코드에서 6자리 코드를 추출해야 합니다\(MUST\). 보안 요구 사항에 따라 더 긴 HOTP 값을 추출하려면 Digit = 7 이상을 고려해야 합니다.\(MUST, SHOULD\)

다음 단락은 Digit = 6에 대해 이 기술을 사용하는 예입니다. 즉, HMAC 값에서 6자리 HOTP 값이 계산됩니다.

---
### **5.4.  Example of HOTP Computation for Digit = 6**

다음 코드 예제에서는 hmac\_result가 HMAC-SHA-1 결과가 포함된 바이트 배열인 경우 동적 이진 코드 추출을 설명합니다.

```text
        int offset   =  hmac_result[19] & 0xf ;
        int bin_code = (hmac_result[offset]  & 0x7f) << 24
           | (hmac_result[offset+1] & 0xff) << 16
           | (hmac_result[offset+2] & 0xff) <<  8
           | (hmac_result[offset+3] & 0xff) ;

   SHA-1 HMAC Bytes (Example)

   -------------------------------------------------------------
   | Byte Number                                               |
   -------------------------------------------------------------
   |00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|
   -------------------------------------------------------------
   | Byte Value                                                |
   -------------------------------------------------------------
   |1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|
   -------------------------------***********----------------++|
```

\* 마지막 바이트\(바이트 19\)는 16진수 값 0x5a를 갖습니다. \* 하위 4비트의 값은 0xa\(오프셋 값\)이다. \* 오프셋 값은 바이트 10\(0xa\)입니다. \* 10바이트부터 시작하는 4바이트의 값은 0x50ef7f19이며, 이는 동적 바이너리 코드 DBC1이다. \* DBC1의 MSB는 0x50이므로 DBC2 = DBC1 = 0x50ef7f19 입니다. \* HOTP = DBC2 모듈로 10^6 = 872921.

우리는 동적 바이너리 코드를 31비트, 부호 없는 빅엔디안 정수로 취급합니다. 첫 번째 바이트는 0x7f로 마스크됩니다.

그런 다음 이 숫자를 모듈로 1,000,000\(10^6\)으로 사용하여 6자리 HOTP 값 872921 십진수를 생성합니다.

---
## **6.  Security Considerations**

부록에 자세히 설명된 보안 분석의 결론은 모든 실제 목적을 위해 개별 카운터 입력에 대한 DT\(Dynamic Truncation\)의 출력이 균일하고 독립적으로 분산된 31비트 문자열이라는 것입니다.

그런 다음 보안 분석에서는 문자열에서 정수로의 변환과 최종 감소 모듈로 10^Digit의 영향을 자세히 설명합니다. 여기서 Digit은 HOTP 값의 자릿수입니다.

분석은 이러한 최종 단계가 HOTP 기능에 대한 최선의 공격이 무차별 대입 공격이라는 의미에서 HOTP 알고리즘의 보안에 영향을 주지 않는 무시할 수 있는 편향을 도입한다는 것을 보여줍니다.

공격자가 수많은 프로토콜 교환을 관찰하고 성공적인 인증 값의 시퀀스를 수집할 수 있다고 가정합니다. 자신의 관찰을 바탕으로 HOTP 값을 생성하기 위해 함수 F를 구축하려는 이 공격자는 무작위 추측에 비해 큰 이점을 갖지 못할 것입니다.

논리적인 결론은 다시 한 번 무차별 대입 공격을 수행하여 가능한 모든 값을 열거하고 시도하는 것이 최선의 전략이라는 것입니다.

이 문서의 부록에 있는 보안 분석을 고려하면 일반성을 잃지 않고 다음 공식을 통해 HOTP 알고리즘의 보안을 대략적으로 추정할 수 있습니다.

```text
                            Sec = sv/10^Digit
```

여기서: - Sec는 적의 성공 확률입니다. - s는 미리보기 동기화 창 크기입니다. - v는 검증 시도 횟수입니다. - 숫자는 HOTP 값의 자릿수입니다.

분명히 우리는 시스템 유용성을 유지하면서 일정 수준의 보안을 달성할 때까지 s, T\(공격자의 시도 횟수를 제한하는 Throttling 매개 변수\) 및 Digit를 사용할 수 있습니다.

---
## **7.  Security Requirements**

모든 일회용 비밀번호 알고리즘은 애플리케이션과 이를 구현하는 인증 프로토콜만큼만 안전합니다. 따라서 이 섹션에서는 우리가 선택한 알고리즘이 인증 프로토콜 및 검증 소프트웨어에 부과하는 중요한 보안 요구 사항에 대해 설명합니다.

이 섹션에서 논의된 매개변수 T와 s는 보안에 중요한 영향을 미칩니다. 섹션 6의 자세한 내용은 이러한 매개변수 간의 관계와 시스템 보안에 미치는 영향에 대해 자세히 설명합니다.

HOTP 알고리즘은 암호화를 대체하지 않으며 데이터 전송의 개인 정보 보호를 제공하지 않는다는 점을 언급하는 것도 중요합니다. 거래의 기밀성과 프라이버시를 침해하려는 공격을 방어하려면 다른 메커니즘을 사용해야 합니다.

---
### **7.1.  Authentication Protocol Requirements**

이 섹션에서는 증명자와 검증자 간의 인증 방법으로 HOTP를 구현하는 프로토콜 P에 대한 몇 가지 요구 사항을 소개합니다.

RP1 - P는 2단계 인증, 즉 귀하가 알고 있는 것\(비밀번호, 암호 구문, PIN 코드 등과 같은 비밀 코드\)과 귀하가 가지고 있는 것\(토큰\)에 대한 통신 및 확인을 지원해야 합니다. 비밀번호는 본인만 알고 있으며 일반적으로 인증\(2단계 인증\)을 위해 일회용 비밀번호 값으로 입력됩니다.\(MUST\)

RP2 - P는 무차별 대입 공격에 취약해서는 안 됩니다. 이는 유효성 검사 서버 측에서 제한/잠금 체계가 권장됨을 의미합니다.\(SHOULD NOT, SHOULD\)

RP3 - P는 사용자의 개인정보를 보호하고 재생 공격을 방지하기 위해 보안 채널을 통해 구현되어야 합니다.\(SHOULD\)

---
### **7.2.  Validation of HOTP Values**

HOTP 클라이언트\(하드웨어 또는 소프트웨어 토큰\)는 카운터를 증가시킨 후 다음 HOTP 값을 계산합니다. HOTP 클라이언트. 인증 서버에서 받은 값이 클라이언트에서 계산한 값과 일치하면 HOTP 값의 유효성이 검사됩니다. 이 경우 서버는 카운터 값을 1씩 증가시킵니다.

서버가 받은 값이 클라이언트가 계산한 값과 일치하지 않으면 서버는 다른 패스를 요청하기 전에 재동기화 프로토콜\(예측 창\)을 시작합니다.

재동기화에 실패하면 서버는 인증된 최대 시도 횟수에 도달할 때까지 프로토콜의 또 다른 인증 패스가 발생하도록 요청합니다.

승인된 최대 시도 횟수에 도달하면 서버는 계정을 잠그고 사용자에게 알리는 절차를 시작해야 합니다.\(SHOULD\)

---
### **7.3.  Throttling at the Server**

HMAC-SHA-1 값을 더 짧은 값으로 자르면 무차별 대입 공격이 가능해집니다. 따라서 인증 서버는 무차별 대입 공격을 탐지하고 차단해야 합니다.

일회용 비밀번호 검증에 가능한 최대 시도 횟수를 정의하는 조절 매개변수 T를 설정하는 것이 좋습니다. 검증 서버는 실패한 시도를 기록하기 위해 HOTP 장치별로 개별 카운터를 관리합니다. 특히 서버에서 사용되는 재동기화 방법이 창 기반이고 창 크기가 큰 경우에는 T를 너무 크게 설정하지 않는 것이 좋습니다. T는 사용성에 큰 영향을 미치지 않도록 하면서 가능한 한 낮게 설정해야 합니다.\(SHOULD\)

또 다른 옵션은 무차별 대입 공격을 피하기 위해 지연 방식을 구현하는 것입니다. 시도 A가 실패할 때마다 인증 서버는 증가된 T\*A 시간\(예: T = 5\) 동안 대기한 다음, 1회 시도 후 서버는 5초 동안 대기하고, 두 번째 시도 실패 시 5초 동안 대기합니다. \*2 = 10초 등

지연 또는 잠금 체계는 여러 병렬 추측 기술을 기반으로 한 공격을 방지하기 위해 로그인 세션 전반에 걸쳐 이루어져야 합니다.\(MUST\)

---
### **7.4.  Resynchronization of the Counter**

서버의 카운터 값은 HOTP 인증이 성공한 후에만 증가하지만, 토큰의 카운터는 사용자가 새로운 HOTP를 요청할 때마다 증가합니다. 이로 인해 서버와 토큰의 카운터 값이 동기화되지 않을 수 있습니다.

미리보기 창의 크기를 정의하는 미리보기 매개변수를 서버에 설정하는 것이 좋습니다. 간단히 말해서 서버는 다음 s HOTP 서버 값을 다시 계산하고 수신된 HOTP 클라이언트와 비교하여 확인할 수 있습니다.

이 시나리오에서 카운터를 동기화하려면 서버가 다음 HOTP 값을 계산하고 일치하는 항목이 있는지 확인하면 됩니다. 선택적으로 시스템은 사용자에게 재동기화 목적으로 HOTP 값 시퀀스\(예: 2, 3\)를 보내도록 요구할 수 있습니다. 연속적인 HOTP 값 시퀀스를 위조하는 것은 단일 HOTP 값을 추측하는 것보다 훨씬 어렵기 때문입니다.\(MAY\)

매개변수 s에 의해 설정된 상한은 서버가 HOTP 값을 영원히 검사하지 않도록 보장하고\(서비스 거부 공격 유발\) HOTP 값을 제조하려는 공격자가 가능한 솔루션 공간을 제한합니다. s 유용성이 영향을 받지 않도록 보장하면서 가능한 한 낮게 설정해야 합니다.\(SHOULD\)

---
### **7.5.  Management of Shared Secrets**

OTP 값을 생성하고 확인하는 데 사용되는 공유 비밀을 처리하는 작업은 민감한 정보 유출 위험을 완화하기 위해 안전하게 수행되어야 합니다. 이 섹션에서는 데이터 보안의 최신 기술과 관련하여 이러한 다양한 작업을 수행하는 다양한 작업 모드와 기술을 설명합니다.

유효성 검사 시스템에서 공유 비밀을 \(안전하게\) 생성하고 저장하기 위한 두 가지 방법을 고려할 수 있습니다.

- \* 결정론적 생성: 비밀은 프로비저닝 및 확인 단계 모두에서 마스터 시드에서 파생되며 필요할 때마다 즉시 생성됩니다. \* 무작위 생성: 비밀은 프로비저닝 단계에서 무작위로 생성되므로 즉시 저장하고 수명 주기 동안 안전하게 유지해야 합니다.

```text
   Deterministic Generation
   ------------------------
```

가능한 전략은 마스터 비밀에서 공유 비밀을 파생시키는 것입니다. 마스터 시크릿은 서버에만 저장됩니다. 마스터 키를 저장하고 마스터 키와 일부 공개 정보에서 공유 비밀을 파생하려면 변조 방지 장치를 사용해야 합니다. 주요 이점은 언제든지 공유 비밀의 노출을 방지하고 스토리지에 대한 특정 요구 사항도 피할 수 있다는 점입니다. 공유 비밀은 프로비저닝 및 검증 시 필요할 때 온디맨드 방식으로 생성될 수 있기 때문입니다.\(MUST\)

```text
   We distinguish two different cases:
```

- - 단일 마스터 키 MK가 공유 비밀을 파생하는 데 사용됩니다. 각 HOTP 장치에는 서로 다른 비밀이 있습니다. K\_i = SHA-1 \(MK,i\) 여기서 i는 일련 번호, 토큰 ID 등과 같이 HOTP 장치를 고유하게 식별하는 공개 정보를 나타냅니다. 애플리케이션이나 서비스의 컨텍스트 - 애플리케이션이나 서비스 제공자마다 비밀과 설정이 다릅니다. - 여러 마스터 키 MK\_i가 사용되고 각 HOTP 장치는 서로 다른 파생된 비밀 세트, {K\_i,j = SHA-1\(MK\_i,j\)}를 저장합니다. 여기서 j는 장치를 식별하는 공개 정보를 나타냅니다. 유효성 검사 서버인 HSM\(하드웨어 보안 모듈\)에 활성 마스터 키만 저장하고 \[Shamir\]와 같은 비밀 공유 방법을 사용하여 안전한 장소에 보관하는 것이 아이디어입니다. 이 경우 마스터 비밀 MK\_i가 손상되면 모든 장치를 교체하지 않고도 다른 비밀로 전환할 수 있습니다.

결정론적 사례의 단점은 마스터 비밀이 노출되면 공격자가 올바른 공개 정보를 기반으로 공유 비밀을 재구성할 수 있다는 것입니다. 모든 비밀을 취소해야 하거나 마스터 키가 여러 개인 경우 새로운 비밀 세트로 전환해야 합니다.

반면, 마스터 키를 저장하고 공유 비밀을 생성하는 데 사용되는 장치는 변조 방지 기능이 있어야 합니다. 또한 HSM은 검증 시스템의 보안 경계 외부에 노출되지 않으므로 누출 위험이 줄어듭니다.\(MUST\)

```text
   Random Generation
   -----------------
```

공유 비밀은 무작위로 생성됩니다. \[RFC4086\]의 권장 사항을 따르고 이러한 비밀을 생성하기 위한 안전하고 안전한 임의 소스를 선택할 것을 권장합니다. \(진짜\) 무작위 생성기에는 자연적으로 발생하는 무작위성 소스가 필요합니다. 실제로 공유 비밀 생성을 위해 고려해야 할 두 가지 방법이 있습니다.

- \* 하드웨어 기반 생성기: 물리적 현상에서 발생하는 임의성을 활용합니다. 좋은 구현은 오실레이터를 기반으로 하고 적극적인 공격을 수행하기 더 어렵게 만드는 방식으로 구축될 수 있습니다.

- \* 소프트웨어 기반 생성기: 좋은 소프트웨어 랜덤 생성기를 설계하는 것은 쉬운 작업이 아닙니다. 간단하지만 효율적인 구현은 다양한 소스를 기반으로 하고 SHA-1과 같은 단방향 기능을 샘플링된 시퀀스에 적용해야 합니다.

공유 비밀 계산을 위해 하드웨어 또는 소프트웨어 생성기 등 검증된 제품을 선택할 것을 권장합니다.

또한 공유 비밀을 안전하게 저장할 것을 권장하며, 특히 변조 방지 하드웨어 암호화를 사용하여 공유 비밀을 암호화하고 필요할 때만 노출하는 것을 권장합니다. 예를 들어, 공유 비밀은 HOTP 값을 확인해야 할 때 해독되고 다시 짧은 시간 동안 RAM에 노출되는 것을 제한하기 위해 즉시 암호화됩니다. 검증 시스템과 비밀 데이터베이스에 대한 직접적인 공격을 최대한 피하기 위해 공유 비밀을 보관하는 데이터 저장소는 보안 영역에 있어야 합니다.\(MUST\)

특히, 공유 비밀에 대한 접근은 검증 시스템에서만 요구되는 프로그램과 프로세스로 제한되어야 합니다. 구현해야 할 다양한 보안 메커니즘에 대해 자세히 설명하지는 않겠지만 공유 비밀을 보호하는 것이 가장 중요하다는 점은 분명합니다.

---
## **8.  Composite Shared Secrets**

공유 비밀 K에 추가 인증 요소를 포함하는 것이 바람직할 수 있습니다. 이러한 추가 요소는 토큰에 알려져 있지만 다른 사람이 쉽게 얻을 수 없는 모든 데이터로 구성될 수 있습니다. 그러한 데이터의 예는 다음과 같습니다.

\* 토큰에서 사용자 입력으로 얻은 PIN 또는 비밀번호

- \* 전화번호 \* 토큰에서 프로그래밍 방식으로 사용할 수 있는 고유 식별자

이 시나리오에서 복합 공유 비밀 K는 프로비저닝 프로세스 중에 하나 이상의 추가 인증 요소와 결합된 임의 시드 값으로 구성됩니다. 서버는 주문형으로 구축하거나 복합 비밀을 저장할 수 있습니다. 어떤 경우든 구현 선택에 따라 토큰은 시드 값만 저장합니다. 토큰은 HOTP 계산을 수행할 때 시드 값과 다른 인증 요소의 로컬 파생 또는 입력 값에서 K를 계산합니다.

복합 공유 비밀을 사용하면 토큰에 추가 인증 요소를 포함시켜 HOTP 기반 인증 시스템을 강화할 수 있습니다. 토큰이 신뢰할 수 있는 장치인 경우 이 접근 방식은 인증 요소\(예: 사용자 입력 PIN\)를 다른 장치에 노출할 필요가 없다는 추가 이점이 있습니다.

---
## **9.  Bi-Directional Authentication**

흥미롭게도 HOTP 클라이언트는 공유 비밀을 알고 있는 진짜 엔터티라고 주장하면서 유효성 검사 서버를 인증하는 데 사용될 수도 있습니다.

HOTP 클라이언트와 서버가 동기화되고 동일한 비밀\(또는 이를 다시 계산하는 방법\)을 공유하므로 간단한 3단계 프로토콜을 적용할 수 있습니다. 1- 최종 사용자가 TokenID와 첫 번째 OTP 값 OTP1을 입력합니다. 2- 서버는 OTP1을 확인하고 올바른 경우 OTP2를 다시 보냅니다. 3- 최종 사용자는 HOTP 장치를 사용하여 OTP2를 확인하고 정확하면 웹 사이트를 사용합니다.

앞서 설명한 것처럼 모든 OTP 통신은 SSL/TLS, IPsec 연결과 같은 보안 채널을 통해 이루어져야 합니다.

---
## **10.  Conclusion**

본 문서에서는 HMAC 기반 일회용 비밀번호 알고리즘인 HOTP에 대해 설명합니다. 또한 알고리즘 배포를 위해 선호하는 구현 및 관련 작업 모드를 권장합니다.

이 문서는 또한 보안 요소를 보여주고 HOTP 알고리즘이 실용적이고 건전하다는 것을 보여줍니다. 가능한 최선의 공격은 검증 서버에서 신중한 대응 조치를 구현하여 예방할 수 있는 무차별 대입 공격입니다.

결국 특정 애플리케이션에 필요한 경우 보안을 향상시키기 위해 몇 가지 향상된 기능이 제안되었습니다.

---
## **11.  Acknowledgements**

저자는 이 문서의 개념과 편집 과정에서 도움을 준 Siddharth Bajaj, Alex Deacon, Loren Hart 및 Nico Popp에게 감사를 표하고 싶습니다.

---
## **12.  Contributors**

이 문서의 저자는 이 문서에 핵심적인 기여를 한 세 사람의 역할을 강조하고 싶습니다.

- Laszlo Elteto는 SafeNet, Inc.의 시스템 설계자입니다.

- Ernesto Frutos는 Authenex, Inc.의 엔지니어링 이사입니다.

- Fred McClain은 Boojum Mobile, Inc.의 창립자이자 CTO입니다.

그들의 조언과 소중한 의견이 없었다면 이 문서는 지금과 같지 않았을 것입니다.

---
## **13.  References**
---
### **13.1.  Normative References**

\[BCK1\] M. Bellare, R. Canetti 및 H. Krawczyk, "키 해시 함수 및 메시지 인증", Proceedings of Crypto'96, LNCS Vol. 1109, 1-15페이지.

\[BCK2\] Krawczyk, H., Bellare, M. 및 R. Canetti, "HMAC: 메시지 인증을 위한 키 해싱", RFC 2104, 1997년 2월.

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC3979\] Bradner, S., "IETF 기술의 지적 재산권", BCP 79, RFC 3979, 2005년 3월.

\[RFC4086\] Eastlake, D., 3rd, Schiller, J. 및 S. Crocker,

- "보안을 위한 무작위성 요구 사항", BCP 106, RFC 4086, 2005년 6월.

---
### **13.2.  Informative References**

\[OATH\] 공개 인증을 위한 이니셔티브

- http://www.openauthentication.org

\[PrOo\] B. Preneel 및 P. van Oorschot, "MD-x MAC 및 해시 함수에서 빠른 MAC 구축", Advances in Cryptology CRYPTO '95, 컴퓨터 과학 강의 노트 Vol. 963, D. Coppersmith 에디션, Springer-Verlag, 1995.

\[크랙\] SHA-1 코드의 크랙으로 인해 보안 전문가가 '기절'함

- http://www.eetimes.com/showArticle.jhtml? 기사ID=60402150

```text
   [Sha1]     Bruce Schneier.  SHA-1 broken.  February 15, 2005.
              http://www.schneier.com/blog/archives/2005/02/
              sha1_broken.html

   [Res]      Researchers: Digital encryption standard flawed
              http://news.com.com/
              Researchers+Digital+encryption+standard+flawed/
              2100-1002-5579881.html?part=dht&tag=ntop&tag=nl.e703
```

\[Shamir\] 비밀을 공유하는 방법, 작성자: Adi Shamir. ACM의 커뮤니케이션, Vol. 22, No. 11, pp. 612-613, 1979년 11월.

---
# **Appendix A - HOTP Algorithm Security: Detailed Analysis**

이 섹션에는 HOTP 알고리즘의 보안 분석이 요약되어 있습니다. 먼저 최선의 공격 전략을 자세히 설명한 다음 다양한 가정 하의 보안과 잘림의 영향을 자세히 설명하고 자릿수에 관한 몇 가지 권장 사항을 제시합니다.

이 분석은 Digit = 6인 경우, 즉 이 문서에서 권장하는 최소값인 6자리 값을 생성하는 HOTP 함수에 중점을 둡니다.

---
### **A.1.  Definitions and Notations**

길이가 l인 모든 문자열의 집합을 {0,1}^l로 표시합니다.

```text
   Let Z_{n} = {0,.., n - 1}.

   Let IntDiv(a,b) denote the integer division algorithm that takes
   input integers a, b where a >= b >= 1 and returns integers (q,r)
```

a를 b로 나눈 몫과 나머지. \(따라서 a = bq + r이고 0 <= r < b입니다.\)

```text
   Let H: {0,1}^k x {0,1}^c --> {0,1}^n be the base function that takes
   a k-bit key K and c-bit counter C and returns an n-bit output H(K,C).
   (In the case of HOTP, H is HMAC-SHA-1; we use this formal definition
   for generalizing our proof of security.)
```

---
### **A.2.  The Idealized Algorithm: HOTP-IDEAL**

이제 HOTP 알고리즘의 이상적인 대응물을 정의합니다. 이 알고리즘에서 H의 역할은 키를 구성하는 무작위 함수에 의해 수행됩니다.

더 정확하게 말하면 Maps\(c,n\)은 {0,1}^c에서 {0,1}^n으로 매핑되는 모든 함수 집합을 나타냅니다. 이상적인 알고리즘에는 키 공간 Maps\(c,n\)이 있으므로 이러한 알고리즘의 "키"는 {0,1}^c에서 {0,1}^n까지의 함수 h입니다. 우리는 이 키\(기능\)가 무작위로 추출된다고 상상합니다. {0,1}^c에서 {0,1}^n까지의 함수인 키가 저장하기에는 너무 크기 때문에 이 이상적인 알고리즘을 구현하는 것은 불가능합니다. 그렇다면 왜 그것을 고려합니까?

우리의 보안 분석은 H가 잘 받아들여지는 특정 가정을 만족하는 한 실제 알고리즘과 이상적인 알고리즘의 보안이 모든 실제 목적에 대해 동일하다는 것을 보여줍니다. 그렇다면 실제로 우리가 직면한 과제는 이상적인 알고리즘의 보안을 평가하는 것입니다.

이상화된 알고리즘을 분석함에 있어 HMAC-SHA-1과 독립적으로 알고리즘 자체의 설계 품질을 평가하는 데 집중하고 있습니다. 사실 이것이 중요한 문제이다.

---
### **A.3.  Model of Security**

이 모델은 고려 중인 위협이나 공격의 유형을 나타내며 HOTP 및 HOTP-IDEAL의 보안을 평가할 수 있습니다. 이 보안 분석의 목적을 위해 ALG를 HOTP 또는 HOTP-IDEAL로 표시합니다.

우리가 고려하고 있는 시나리오는 사용자와 서버가 ALG에 대한 키 K를 공유한다는 것입니다. 둘 다 처음에는 0인 카운터 C를 유지하며 사용자는 ALG\(K,C\)를 서버에 전송하여 자신을 인증합니다. 후자는 이 값이 올바른지 승인합니다.

실수로 사용자 카운터가 증가하는 것을 방지하기 위해 서버는 z 값을 수신하면 C,...,C + s- 범위의 일부 i에 대해 z가 ALG\(K,i\)와 동일한 한 허용합니다. 1, 여기서 s는 재동기화 매개변수이고 C는 서버 카운터입니다. i 값을 수락하면 카운터를 i+1로 증가시킵니다. 수락하지 않으면 카운터 값을 변경하지 않습니다.

우리가 지정하는 모델은 적이 무엇을 할 수 있는지, 그리고 "승리"하기 위해 무엇을 달성해야 하는지를 포착합니다. 첫째, 공격자는 도청, 즉 사용자가 전송한 인증자를 볼 수 있다고 가정합니다. 둘째, 사용자가 인증자를 전송한 적이 없는 카운터 값과 관련하여 서버가 인증자를 수락하도록 할 수 있으면 공격자가 승리합니다.

B로 표시되는 공식적인 상대는 ALG가 사용되는 알고리즘, 시스템 설계 및 모든 시스템 매개변수를 아는 것부터 시작합니다. 선험적으로 제공되지 않는 유일한 것은 사용자와 서버 간에 공유되는 키 K입니다.

이 모델은 B에게 이벤트 일정 관리에 대한 모든 권한을 부여합니다. 사용자를 나타내는 인증자 Oracle에 액세스할 수 있습니다. 이 오라클을 호출함으로써 공격자는 사용자에게 자신을 인증하도록 요청하고 그 대가로 인증자를 돌려받을 수 있습니다. 원하는 만큼 자주, 원할 때 이 오라클을 호출할 수 있으며, 축적된 인증자를 사용하여 인증자 자체를 만드는 방법을 "학습"할 수 있습니다. 언제든지 검증 오라클을 호출하여 선택한 후보 인증자를 제공할 수도 있습니다. 서버가 이 누산기를 수락하면 승리합니다.

```text
   Consider the following game involving an adversary B that is
   attempting to compromise the security of an authentication algorithm
   ALG: K x {0,1}^c --> R.
```

초기화 - 키 K는 K에서 무작위로 선택되고, 카운터 C는 0으로 초기화되며, 부울 값 win은 false로 설정됩니다.

게임 실행 - 적 B에는 다음 두 가지 오라클이 제공됩니다.

```text
   Oracle AuthO()
   --------------
      A = ALG(K,C)
      C = C + 1
      Return O to B

   Oracle VerO(A)
   --------------
      i = C
      While (i <= C + s - 1 and Win == FALSE) do
         If A == ALG(K,i) then Win = TRUE; C = i + 1
         Else i = i + 1
      Return Win to B
```

AuthO\(\)는 인증자 오라클이고 VerO\(A\)는 검증 오라클입니다.

실행 시 B는 두 오라클에 마음대로 쿼리합니다. Adv\(B\)를 위 게임에서 승리가 참으로 설정될 확률이라고 하자. 이는 공격자가 사용자를 성공적으로 사칭할 확률입니다.

우리의 목표는 B가 수행한 검증 쿼리 수 v, B가 수행한 인증자 oracle 쿼리 수 a, B의 실행 시간 t의 함수로 이 값이 얼마나 클 수 있는지 평가하는 것입니다. 이를 통해 방법을 알 수 있습니다. 효과적으로 상한 v를 설정하는 스로틀을 설정합니다.

---
### **A.4.  Security of the Ideal Authentication Algorithm**

이 섹션에서는 10^Digit 모듈로 변환의 영향부터 시작하여 가능한 다양한 공격에 초점을 맞춰 HOTP-IDEAL의 보안 분석을 요약합니다.

---
#### **A.4.1.  From Bits to Digits**

무작위 n비트 문자열의 동적 오프셋 잘림은 무작위 31비트 문자열을 생성합니다. HOTP에서와 같이 모듈로 m = 10^Digit을 취하면 분포는 어떻게 되나요?

다음 정리는 이 경우 출력의 편향을 추정합니다.

```text
   Lemma 1
   -------
   Let N >= m >= 1 be integers, and let (q,r) = IntDiv(N,m).  For z in
   Z_{m} let:

          P_{N,m}(z) = Pr [x mod m = z : x randomly pick in Z_{n}]

   Then for any z in Z_{m}

   P_{N,m}(z) =   (q + 1) / N    if 0 <= z < r
                  q / N          if r <= z < m

   Proof of Lemma 1
   ----------------
   Let the random variable X be uniformly distributed over Z_{N}.  Then:

   P_{N,m}(z)  = Pr [X mod m = z]

                = Pr [X < mq] * Pr [X mod m = z| X < mq]
                + Pr [mq <= X < N] * Pr [X mod m = z| mq <= X < N]

                = mq/N * 1/m +
                   (N - mq)/N * 1 / (N - mq)     if 0 <= z < N - mq
                   0                             if N - mq <= z <= m

                = q/N +
                   r/N * 1 / r                   if 0 <= z < N - mq
                   0                             if r <= z <= m
```

단순화하면 청구된 방정식이 생성됩니다.

N = 2^31, d = 6, m = 10^d라고 가정합니다. x가 Z\_{N}에서 임의로 선택되면\(즉, 임의의 31비트 문자열임\) x mod m을 취하여 x를 6자리 숫자로 줄이면 임의의 6자리 숫자가 생성되지 않습니다.

오히려 x mod m은 다음 표와 같이 배포됩니다.

```text
   Values               Probability that each appears as output
   ----------------------------------------------------------------
   0,1,...,483647       2148/2^31 roughly equals to 1.00024045/10^6
   483648,...,999999    2147/2^31 roughly equals to 0.99977478/10^6
```

X가 Z\_{2^31}\(즉, 임의의 31비트 문자열\)에 균일하게 분포된 경우 위의 내용은 X mod 10^6의 다양한 출력에 대한 확률을 보여줍니다. 첫 번째 값 세트는

확률은 10^-6보다 약간 크고 나머지는 확률이 약간 낮습니다. 이는 분포가 약간 불균일하다는 것을 의미합니다.

그러나 위의 표에서 알 수 있듯이 편향은 작으며 나중에 살펴보겠지만 확률은 10^-6에 매우 가깝습니다.

---
#### **A.4.2.  Brute Force Attacks**

인증자가 d 개의 무작위 숫자로 구성된 경우 v 개의 확인 시도를 사용한 무차별 대입 공격은 확률 sv/10^Digit로 성공합니다.

그러나 공격자는 Lemma 1에서 예측한 HOTP-IDEAL 출력의 편향을 이용하여 약간 더 나은 공격을 수행할 수 있습니다.

즉, 가장 가능성이 높은 값, 즉 0,...,r - 1 범위에 있는 인증자를 사용하여 인증을 시도합니다. 여기서 \(q,r\) = IntDiv\(2^31,10^Digit\)입니다.

다음은 공격을 가하는 보안 모델의 공격자를 지정합니다. 검증 쿼리 수에 따라 성공 확률을 추정합니다.

단순화를 위해 검증 쿼리의 수가 최대 r개라고 가정합니다. N = 2^31 및 m = 10^6인 경우 r = 483,648이고 스로틀 값은 확실히 이보다 작으므로 이 가정은 큰 제한이 아닙니다.

```text
   Proposition 1
   -------------
```

m = 10^Digit < 2^31이고 \(q,r\) = IntDiv\(2^31,m\)이라고 가정합니다. s <= m이라고 가정합니다. 무차별 대입 공격 상대인 B-bf는 v <= r 검증 오라클 쿼리를 사용하여 HOTP를 공격합니다. 이 공격자는 인증자 오라클 쿼리를 수행하지 않으며 확률적으로 성공합니다.

```text
                    Adv(B-bf) = 1 - (1 - v(q+1)/2^31)^s
```

이는 대략 다음과 같습니다.

```text
                             sv * (q+1)/2^31
```

m = 10^6이면 q = 2,147이 됩니다. 이 경우 v 검증 시도를 사용한 무차별 대입 공격은 확률적으로 성공합니다.

```text
         Adv(B-bf) roughly = sv * 2148/2^31 = sv * 1.00024045/10^6
```

이 방정식에서 알 수 있듯이 재동기화 매개변수 s는 적의 성공 확률이 s에 비례한다는 점에서 중요한 영향을 미칩니다. 이는 보안을 손상시키지 않으면서 s를 너무 크게 만들 수 없음을 의미합니다.

---
#### **A.4.3.  Brute force attacks are the best possible attacks.**

핵심 질문은 무차별 공격보다 더 나은 공격이 있는지 여부입니다. 특히, 무차별 공격은 인증자를 더 잘 구성하는 방법을 배우기 위해 사용자가 보낸 인증자를 수집하고 이를 암호화하려고 시도하지 않았습니다. 이렇게 하면 도움이 될까요? 무차별 대입 공격보다 더 높은 성공률을 가져오는 인증자를 구축하는 방법을 "학습"할 수 있는 방법이 있습니까?

다음은 이러한 질문에 대한 대답이 '아니요'라고 말합니다. 공격자가 어떤 전략을 사용하든, 사용자의 인증 시도에서 인증자를 보고 악용하려고 시도하더라도 성공 확률은 무차별 대입 공격보다 높지 않습니다. 관찰되는 인증 수는 엄청나게 크지 않습니다. 이는 계획의 보안과 관련된 귀중한 정보입니다.

```text
   Proposition 2 ------------- Suppose m = 10^Digit < 2^31, and let
   (q,r) = IntDiv(2^31,m).  Let B be any adversary attacking HOTP-IDEAL
   using v verification oracle queries and a <= 2^c - s authenticator
   oracle queries.  Then

                        Adv(B) < = sv * (q+1)/ 2^31
```

참고: 이 결과는 공격자가 사용자가 수행한 인증을 2^c - s 이상 보지 않는다는 조건에 따른 것이며, 이는 c가 충분히 큰 한 거의 제한적이지 않습니다.

m = 10^6이면 q = 2,147이 됩니다. 이 경우 명제 2는 HOTP-IDEAL을 공격하고 v 검증 시도를 하는 모든 적 B가 최대 확률로 성공한다고 말합니다.

```text
   Equation 1
   ----------
              sv * 2148/2^31 roughly = sv * 1.00024045/10^6
```

즉, B의 성공률은 무차별 대입 공격으로 달성한 성공률보다 높지 않습니다.

---
### **A.5.  Security Analysis of HOTP**

우리는 이전 섹션에서 실제 인증 알고리즘 HOTP의 이상적인 대응인 HOTP-IDEAL의 보안을 분석했습니다. 이제 우리는 H에 대한 적절하고 잘 믿어지는 가정 하에서 실제 알고리즘의 보안이 이상적인 대응의 보안과 본질적으로 동일하다는 것을 보여줍니다.

문제의 가정은 H가 안전한 의사 난수 함수\(PRF\)라는 것인데, 이는 H의 입력-출력 값이 실제로 무작위 함수의 값과 구별할 수 없음을 의미합니다.

```text
   Consider an adversary A that is given an oracle for a function f:
   {0,1}^c --> {0, 1}^n and eventually outputs a bit.  We denote Adv(A)
   as the prf-advantage of A, which represents how well the adversary
   does at distinguishing the case where its oracle is H(K,.) from the
   case where its oracle is a random function of {0,1}^c to {0,1}^n.
```

한 가지 가능한 공격은 키 K에 대한 철저한 검색을 기반으로 합니다. A가 t 단계 동안 실행되고 T가 H의 한 계산을 수행하는 시간을 나타내는 경우 이 공격의 prf-이점은 \(t/T\)2^-입니다. 케이. 또 다른 가능한 공격은 생일 공격\[PrOo\]으로, A는 pT에 대한 실행 시간과 오라클 쿼리에서 p^2/2^n 이점을 얻을 수 있습니다.

우리는 이것이 가능한 최선의 공격이라고 가정합니다. 이는 다음과 같이 해석됩니다.

```text
   Assumption 1
   ------------
```

T가 H의 한 계산을 수행하는 데 걸리는 시간을 나타낸다고 가정합니다. 그런 다음 A가 최대 t의 실행 시간을 갖고 최대 t개의 오라클 쿼리를 수행하는 적이라면,

```text
                       Adv(A) <= (t/T)/2^k + p^2/2^n
```

실제로 이 가정은 H가 PRF로서 매우 안전하다는 것을 의미합니다. 예를 들어 k = n = 160인 경우 실행 시간이 2^60이고 2^40개의 Oracle 쿼리를 수행하는 공격자는 최대 2^-80의 이점을 갖습니다.

```text
   Theorem 1
   ---------
```

m = 10^Digit < 2^31이고 \(q,r\) = IntDiv\(2^31,m\)이라고 가정합니다. B는 v 검증 오라클 쿼리를 사용하여 HOTP를 공격하는 모든 공격자라고 가정합니다.

a <= 2^c - s 인증자 oracle 쿼리 및 실행 시간 t. T를 H의 한 계산을 수행하는 시간을 나타냅니다. 가정 1이 참이면

```text
         Adv(B) <= sv * (q + 1)/2^31 + (t/T)/2^k + ((sv + a)^2)/2^n
```

실제로 \(t/T\)2^-k + \(\(sv + a\)^2\)2^-n 항은 sv\(q + 1\)/2^n 항보다 훨씬 작으므로 위의 내용은 다음과 같습니다. 모든 실제적인 목적을 위해 HOTP를 공격하는 적의 성공률은 HOTP-IDEAL과 마찬가지로 sv\(q + 1\)/2^n입니다. 즉, HOTP 알고리즘이 실제로 이상적인 알고리즘만큼 우수하다는 의미입니다.

m = 6자리 출력의 10^6인 경우 이는 v 인증 시도를 하는 공격자가 최대 방정식 1의 성공률을 갖게 된다는 것을 의미합니다.

예를 들어 실행 시간이 최대 2^60이고 사용자의 인증 시도가 최대 2^40회인 공격자를 생각해 보세요. 이 두 가지 선택 모두 일반적으로 이러한 리소스가 없는 적에게는 매우 관대하지만, 그러한 강력한 적조차도 방정식 1에서 표시된 것보다 더 많은 성공을 거두지는 못할 것입니다.

s에 대한 조절 및 경계로 인해 sv <= 2^40이라고 안전하게 가정할 수 있습니다. 그래서:

```text
       (t/T)/2^k + ((sv + a)^2)/2^n  <= 2^60/2^160 + (2^41)^2/2^160
                                    roughly <= 2^-78
```

이는 수학식 1의 성공 확률보다 훨씬 작고 그에 비해 무시할 수 있는 수준입니다.

---
# **Appendix B - SHA-1 Attacks**

이 섹션에서는 최근 SHA-1 공격이 HMAC-SHA-1 기반 HOTP의 보안에 미치는 영향을 설명합니다. SHA-1의 상황에 대한 논의로 시작한 다음 HMAC-SHA-1 및 HOTP와의 관련성을 논의합니다. 인용된 참고문헌은 섹션 13에 있습니다.

---
### **B.1.  SHA-1 Status**

해시 함수 h에 대한 충돌은 h\(x\)=h\(y\)와 같은 서로 다른 입력의 x,y 쌍을 의미합니다. SHA-1은 160비트를 출력하므로 생일 공격은 2^{80} 시도에서 충돌을 발견합니다. \(시행은 함수의 한 계산을 의미합니다.\) 이는 Wang, Yin 및 Yu가 2005년 2월 15일에 2^{69} 시도에서 충돌을 찾는 공격이 있다고 발표할 때까지 가능한 최선이라고 생각되었습니다.

SHA-1이 고장났나요? 대부분의 실제적인 목적에서는 공격을 수행하는 데 필요한 리소스가 엄청나기 때문에 아마도 그렇지 않을 것이라고 말할 수 있습니다. 이를 이해하는 한 가지 방법은 다음과 같습니다. 760비트 RSA 모듈러스를 인수분해하는 데 필요한 시간과 거의 동일하다고 추정할 수 있으며 현재는 도달할 수 없는 것으로 간주됩니다.

NIST의 Burr는 \[Crack\]에서 "대형 국가 정보 기관은 수백만 달러의 컴퓨터 시간을 사용하여 합리적인 시간 내에 이 작업을 수행할 수 있습니다"라고 말한 것으로 인용되었습니다. 그러나 자금이 충분한 기관을 제외하고는 계산이 불가능할 수도 있습니다.

또한 SHA-1 충돌을 찾는 것이 실제로 서명과 같은 실제 애플리케이션의 보안에 어떤 영향을 미치는지 물어봐야 합니다. x,y 충돌을 이용하여 서명을 위조하려면 어떻게든 x의 서명을 얻은 다음 y의 서명을 위조할 수 있습니다. 이것이 얼마나 피해를 주는지는 y의 내용에 따라 다릅니다. 즉, 공격으로 생성된 y는 애플리케이션 컨텍스트에서 의미가 없을 수 있습니다. 또한 x의 서명을 얻으려면 선택 메시지 공격이 필요합니다. 이는 일부 상황에서는 가능해 보이지만 다른 상황에서는 그렇지 않습니다. 전반적으로 서명 보안에 미치는 영향이 중요한지는 확실하지 않습니다.

실제로 언론에서는 SHA-1이 "깨졌다"고 \[Sha1\] 암호화와 SSL이 "깨졌다"고 읽을 수 있습니다 \[Res\]. 언론은 사건을 확대하는 경향이 있습니다. 암호 분석가 팀이 SHA-1 공격에서 매우 흥미로운 이론적 작업을 수행했다는 소식을 뉴스에 발표하는 것은 거의 흥미롭지 않습니다.

암호학자들도 흥분하고 있습니다. 그러나 주로 이것이 중요한 이론적 돌파구이기 때문입니다. 공격은 시간이 지날수록 좋아질 수 있습니다. 따라서 해시 함수 암호화 분석의 진행 상황을 모니터링하고 미래를 위한 건전한 마이그레이션 계획을 통해 실질적인 휴식을 준비하는 것이 중요합니다.

---
### **B.2.  HMAC-SHA-1 Status**

SHA-1에 대한 새로운 공격은 HMAC-SHA-1의 보안에 영향을 미치지 않습니다. 후자에 대한 최선의 공격은 상대방이 위조를 생성하기 전에 발신자가 2^{80} 메시지를 인증해야 하는 것입니다. 왜?

HMAC는 해시 함수가 아닙니다. 내부적으로 해시 함수를 사용하는 메시지 인증 코드\(MAC\)입니다. MAC은 비밀 키에 의존하지만 해시 기능은 그렇지 않습니다. MAC에서 걱정해야 할 것은 충돌이 아니라 위조입니다. HMAC는 해시 함수\(여기서는 SHA-1\)의 충돌로 인해 HMAC에 대한 위조가 발생하지 않도록 설계되었습니다.

HMAC-SHA-1\(K,x\) = SHA-1\(K\_o,SHA-1\(K\_i,x\)\) 여기서 키 K\_o,K\_i는 K에서 파생됩니다. 공격자가 다음과 같은 쌍 x,y를 찾았다고 가정합니다. SHA-1\(K\_i,x\) = SHA-1\(K\_i,y\). \(이를 숨겨진 키 충돌이라고 부릅니다.\) 그런 다음 x의 MAC\(그 자체는 큰 순서\)을 얻을 수 있으면 y의 MAC을 위조할 수 있습니다. \(이 값은 동일합니다.\) 그러나 숨겨진 키 충돌을 찾는 것은 충돌을 찾는 것보다 어렵습니다. 공격자가 숨겨진 키 K\_i를 모르기 때문입니다. 가질 수 있는 것은 키 K가 포함된 HMAC-SHA-1의 일부 출력뿐입니다. 현재까지 SHA-1에 대한 최근 공격이 숨겨진 키 충돌을 찾아낸다는 주장이나 증거는 없습니다.

역사적으로 HMAC 설계는 이와 관련하여 이미 입증되었습니다. MD5는 이 해시 함수의 충돌을 비교적 쉽게 찾을 수 있다는 점에서 깨진 것으로 간주됩니다. 그러나 HMAC-MD5에 대한 사소한 2^{64} 생일 공격보다 더 나은 공격은 아직 없습니다. \(MD5는 160비트가 아닌 128비트를 출력합니다.\) 우리는 SHA-1 맥락에서 HMAC의 이러한 강점이 다시 발휘되는 것을 보고 있습니다.

---
### **B.3.  HOTP Status**

HMAC-SHA-1에는 새로운 약점이 나타나지 않았으므로 HOTP에는 영향이 없습니다. HOTP에 대한 가장 좋은 공격은 문서에 설명된 공격, 즉 출력 값을 추측하는 것입니다.

HOTP의 보안 증명을 위해서는 HMAC-SHA-1이 의사 난수 함수처럼 동작해야 합니다. 의사 난수 함수로서의 HMAC-SHA-1의 품질은 SHA-1에 대한 새로운 공격의 영향을 받지 않으므로 이 입증된 보증도 마찬가지입니다.

---
# **Appendix C - HOTP Algorithm: Reference Implementation**

```text
   /*
    * OneTimePasswordAlgorithm.java
    * OATH Initiative,
    * HOTP one-time password algorithm
    *
    */

   /* Copyright (C) 2004, OATH.  All rights reserved.
    *
    * License to copy and use this software is granted provided that it
    * is identified as the "OATH HOTP Algorithm" in all material
    * mentioning or referencing this software or this function.
    *
    * License is also granted to make and use derivative works provided
    * that such works are identified as
    *  "derived from OATH HOTP algorithm"
    * in all material mentioning or referencing the derived work.
    *
    * OATH (Open AuTHentication) and its members make no
    * representations concerning either the merchantability of this
    * software or the suitability of this software for any particular
    * purpose.
    *
    * It is provided "as is" without express or implied warranty
    * of any kind and OATH AND ITS MEMBERS EXPRESSaLY DISCLAIMS
    * ANY WARRANTY OR LIABILITY OF ANY KIND relating to this software.
    *
    * These notices must be retained in any copies of any part of this
    * documentation and/or software.
    */

   package org.openauthentication.otp;

   import java.io.IOException;
   import java.io.File;
   import java.io.DataInputStream;
   import java.io.FileInputStream ;
   import java.lang.reflect.UndeclaredThrowableException;

   import java.security.GeneralSecurityException;
   import java.security.NoSuchAlgorithmException;
   import java.security.InvalidKeyException;

   import javax.crypto.Mac;
   import javax.crypto.spec.SecretKeySpec;

   /**
    * This class contains static methods that are used to calculate the
    * One-Time Password (OTP) using
    * JCE to provide the HMAC-SHA-1.
    *
    * @author Loren Hart
    * @version 1.0
    */
   public class OneTimePasswordAlgorithm {
       private OneTimePasswordAlgorithm() {}

       // These are used to calculate the check-sum digits.
       //                                0  1  2  3  4  5  6  7  8  9
       private static final int[] doubleDigits =
                       { 0, 2, 4, 6, 8, 1, 3, 5, 7, 9 };

       /**
        * Calculates the checksum using the credit card algorithm.
        * This algorithm has the advantage that it detects any single
        * mistyped digit and any single transposition of
        * adjacent digits.
        *
        * @param num the number to calculate the checksum for
        * @param digits number of significant places in the number
        *
        * @return the checksum of num
        */
       public static int calcChecksum(long num, int digits) {
           boolean doubleDigit = true;
           int     total = 0;
           while (0 < digits--) {
               int digit = (int) (num % 10);
               num /= 10;
               if (doubleDigit) {
                   digit = doubleDigits[digit];
               }
               total += digit;
               doubleDigit = !doubleDigit;
           }
           int result = total % 10;
           if (result > 0) {
               result = 10 - result;
           }
           return result;
       }
```

/\*\*

- \* 이 방법은 JCE를 사용하여 HMAC-SHA-1을 제공합니다.

```text
        * algorithm.
        * HMAC computes a Hashed Message Authentication Code and
        * in this case SHA1 is the hash algorithm used.
        *
        * @param keyBytes   the bytes to use for the HMAC-SHA-1 key
        * @param text       the message or text to be authenticated.
        *
        * @throws NoSuchAlgorithmException if no provider makes
        *       either HmacSHA1 or HMAC-SHA-1
        *       digest algorithms available.
        * @throws InvalidKeyException
        *       The secret provided was not a valid HMAC-SHA-1 key.
        *
        */

       public static byte[] hmac_sha1(byte[] keyBytes, byte[] text)
           throws NoSuchAlgorithmException, InvalidKeyException
       {
   //        try {
               Mac hmacSha1;
               try {
                   hmacSha1 = Mac.getInstance("HmacSHA1");
               } catch (NoSuchAlgorithmException nsae) {
                   hmacSha1 = Mac.getInstance("HMAC-SHA-1");
               }
               SecretKeySpec macKey =
           new SecretKeySpec(keyBytes, "RAW");
               hmacSha1.init(macKey);
               return hmacSha1.doFinal(text);
   //        } catch (GeneralSecurityException gse) {
   //            throw new UndeclaredThrowableException(gse);
   //        }
       }

       private static final int[] DIGITS_POWER
     // 0 1  2   3    4     5      6       7        8
     = {1,10,100,1000,10000,100000,1000000,10000000,100000000};

       /**
        * This method generates an OTP value for the given
        * set of parameters.
        *
        * @param secret       the shared secret
        * @param movingFactor the counter, time, or other value that
        *                     changes on a per use basis.
        * @param codeDigits   the number of digits in the OTP, not
        *                     including the checksum, if any.
        * @param addChecksum  a flag that indicates if a checksum digit

        *                     should be appended to the OTP.
        * @param truncationOffset the offset into the MAC result to
        *                     begin truncation.  If this value is out of
        *                     the range of 0 ... 15, then dynamic
        *                     truncation  will be used.
        *                     Dynamic truncation is when the last 4
        *                     bits of the last byte of the MAC are
        *                     used to determine the start offset.
        * @throws NoSuchAlgorithmException if no provider makes
        *                     either HmacSHA1 or HMAC-SHA-1
        *                     digest algorithms available.
        * @throws InvalidKeyException
        *                     The secret provided was not
        *                     a valid HMAC-SHA-1 key.
        *
        * @return A numeric String in base 10 that includes
        * {@link codeDigits} digits plus the optional checksum
        * digit if requested.
        */
       static public String generateOTP(byte[] secret,
                  long movingFactor,
             int codeDigits,
                  boolean addChecksum,
             int truncationOffset)
           throws NoSuchAlgorithmException, InvalidKeyException
       {
           // put movingFactor value into text byte array
     String result = null;
     int digits = addChecksum ? (codeDigits + 1) : codeDigits;
           byte[] text = new byte[8];
           for (int i = text.length - 1; i >= 0; i--) {
               text[i] = (byte) (movingFactor & 0xff);
               movingFactor >>= 8;
           }

           // compute hmac hash
           byte[] hash = hmac_sha1(secret, text);

           // put selected bytes into result int
           int offset = hash[hash.length - 1] & 0xf;
     if ( (0<=truncationOffset) &&
            (truncationOffset<(hash.length-4)) ) {
         offset = truncationOffset;
     }
           int binary =
               ((hash[offset] & 0x7f) << 24)
               | ((hash[offset + 1] & 0xff) << 16)
               | ((hash[offset + 2] & 0xff) << 8)

               | (hash[offset + 3] & 0xff);

           int otp = binary % DIGITS_POWER[codeDigits];
     if (addChecksum) {
         otp =  (otp * 10) + calcChecksum(otp, codeDigits);
     }
     result = Integer.toString(otp);
     while (result.length() < digits) {
         result = "0" + result;
     }
     return result;
       }
   }
```

---
# **Appendix D - HOTP Algorithm: Test Values**

다음 테스트 데이터는 보안 비밀에 ASCII 문자열 "12345678901234567890"을 사용합니다.

```text
   Secret = 0x3132333435363738393031323334353637383930
```

표 1은 각 카운트에 대한 세부정보인 중간 HMAC 값을 나타냅니다.

```text
   Count    Hexadecimal HMAC-SHA-1(secret, count)
   0        cc93cf18508d94934c64b65d8ba7667fb7cde4b0
   1        75a48a19d4cbe100644e8ac1397eea747a2d33ab
   2        0bacb7fa082fef30782211938bc1c5e70416ff44
   3        66c28227d03a2d5529262ff016a1e6ef76557ece
   4        a904c900a64b35909874b33e61c5938a8e15ed1c
   5        a37e783d7b7233c083d4f62926c7a25f238d0316
   6        bc9cd28561042c83f219324d3c607256c03272ae
   7        a4fb960c0bc06e1eabb804e5b397cdc4b45596fa
   8        1b3c89f65e6c9e883012052823443f048b4332db
   9        1637409809a679dc698207310c8c7fc07290d9e5
```

표 2에서는 잘린 값\(16진수와 10진수 모두\)과 HOTP 값을 각 개수에 대해 자세히 설명합니다.

```text
                     Truncated
   Count    Hexadecimal    Decimal        HOTP
   0        4c93cf18       1284755224     755224
   1        41397eea       1094287082     287082
   2         82fef30        137359152     359152
   3        66ef7655       1726969429     969429
   4        61c5938a       1640338314     338314
   5        33c083d4        868254676     254676
   6        7256c032       1918287922     287922
   7         4e5b397         82162583     162583
   8        2823443f        673399871     399871
   9        2679dc69        645520489     520489
```

---
# **Appendix E - Extensions**

이 섹션에서는 HOTP 알고리즘에 대한 몇 가지 향상된 기능을 소개합니다. 이는 권장되는 확장이나 표준 알고리즘의 일부가 아니라 사용자 정의 구현에 사용할 수 있는 변형일 뿐입니다.

---
### **E.1.  Number of Digits**

보안 측면에서 간단한 향상은 HMAC-SHA-1 값에서 더 많은 숫자를 추출하는 것입니다.

예를 들어, 10^8 모듈로 HOTP 값을 계산하여 8자리 HOTP 값을 구축하면 공격자의 성공 확률이 sv/10^6에서 sv/10^8로 줄어듭니다.

이는 예를 들어 T 및/또는 s를 증가시켜 유용성을 향상시키는 동시에 전반적으로 더 나은 보안을 달성할 수 있는 기회를 제공할 수 있습니다. 예를 들어, s = 10이고 10v/10^8 = v/10^7 < v/10^6은 s = 1일 때 6자리 코드에 대한 이론적 최적값입니다.

---
### **E.2.  Alphanumeric Values**

또 다른 옵션은 A-Z 및 0-9 값을 사용하는 것입니다. 또는 문자 간의 혼동을 피하기 위해 영숫자 알파벳에서 가져온 32개 기호의 하위 집합입니다. 0, O, Q와 l, 1, I는 매우 유사하며 작은 디스플레이에서도 동일하게 보일 수 있습니다.

즉각적인 결과는 보안이 이제 6자리 HOTP 값의 경우 sv/32^6, 8자리 HOTP 값의 경우 sv/32^8 순서라는 것입니다.

32^6 \> 10^9이므로 6자리 영숫자 HOTP 코드의 보안은 제안된 알고리즘에서 지원하는 HOTP 코드의 최대 길이인 9자리 HOTP 값보다 약간 더 좋습니다.

32^8 \> 10^12이므로 8자리 영숫자 HOTP 코드의 보안은 9자리 HOTP 값보다 훨씬 더 좋습니다.

HOTP 값을 표시하고 입력하는 데 사용되는 애플리케이션 및 토큰/인터페이스에 따라 영숫자 값을 선택하면 비용과 사용자에 대한 영향을 줄이면서 보안을 향상시킬 수 있는 간단하고 효율적인 방법이 될 수 있습니다.

---
### **E.3.  Sequence of HOTP Values**

HOTP 값의 짧은 시퀀스\(예: 2 또는 3\)를 입력하기 위한 재동기화를 제안한 것처럼 이 개념을 프로토콜에 일반화하고 입력할 HOTP 시퀀스의 길이를 정의하는 매개변수 L을 추가할 수 있습니다.

기본적으로 L 값은 1로 설정되어야 하지만 보안을 강화해야 하는 경우 사용자에게 L HOTP 값을 입력하라는 메시지가 표시될 수 있습니다\(단기간 또는 특정 작업의 경우\).\(SHOULD\)

이는 보안을 강화하기 위해 HOTP 길이를 늘리거나 영숫자 값을 사용하지 않는 또 다른 방법입니다.

참고: 시스템은 정기적으로\(예: 매일 밤, 일주일에 두 번 등\) 동기화를 요청하고 이 목적을 달성하기 위해 일련의 L HOTP 값을 요청하도록 프로그래밍할 수도 있습니다.\(MAY\)

---
### **E.4.  A Counter-Based Resynchronization Method**

이 경우 클라이언트는 HOTP 값뿐만 아니라 다른 정보, 구체적으로는 카운터 값까지 접근하여 전송할 수 있다고 가정한다.

이 경우 보다 효율적이고 안전한 재동기화 방법이 가능합니다. 클라이언트 응용 프로그램에서는 HOTP-client 값만 보내는 것이 아니라 HOTP-client 및 관련 C-client 카운터 값, 즉 HOTP 값이 카운터의 메시지 인증 코드 역할을 합니다.

```text
   Resynchronization Counter-based Protocol (RCP)
   ----------------------------------------------
```

서버는 다음 사항이 모두 참인 경우 수락합니다. 여기서 C 서버는 자체 현재 카운터 값입니다.

1\) C-client \>= C-server 2\) C-client - C-server <= s 3\) HOTP 클라이언트가 유효한지 확인 HOTP\(K,C-Client\) 4\) true인 경우 서버는 C를 C-로 설정합니다. 클라이언트 + 1 및 클라이언트가 인증됨

이 경우 더 이상 미리보기 창을 관리할 필요가 없습니다. 적의 성공 확률은 v/10^6 또는 대략 100만 분의 1입니다. 부수적인 이점은 분명히 s를 "무한히" 늘릴 수 있어 보안에 영향을 주지 않고 시스템 유용성을 향상시킬 수 있다는 것입니다.

이 재동기화 프로토콜은 클라이언트 및 서버 애플리케이션에 대한 관련 영향이 허용 가능한 것으로 간주될 때마다 사용해야 합니다.\(SHOULD\)

---
### **E.5. Data Field**

또 다른 흥미로운 옵션은 일회용 비밀번호 값을 생성하는 데 사용되는 데이터 필드의 도입입니다. HOTP\(K, C, \[데이터\]\) 여기서 데이터는 다양한 ID 조각을 연결할 수 있는 선택적 필드입니다. 관련 정보\(예: 데이터 = 주소 | 핀.

유일한 이동 요소로 또는 카운터와 결합하여 타이머를 사용할 수도 있습니다. 이 경우 예를 들어 데이터 = 타이머, 여기서 타이머는 UNIX 시간\(1970년 1월 1일 이후 GMT 초\)을 나눈 값일 수 있습니다. 특정 시간 간격을 제공하기 위해 몇 가지 요소\(8, 16, 32 등\)를 기준으로 합니다. 그러면 일회용 비밀번호의 시간 창은 이전에 정의한 재동기화 매개변수를 곱한 시간 단계와 같습니다. 예를 들어, 시간 단계로 64초를 사용하고 재동기화 매개변수로 7초를 사용하면 +/- 3분의 승인 기간을 얻습니다.

데이터 필드를 명확하게 지정하면 데이터 필드를 사용하면 알고리즘 구현에 더 많은 유연성이 제공됩니다.

---
# **Authors' Addresses**

David M'Raihi\(의견 및 질문 전송을 위한 기본 연락처\) VeriSign, Inc. 685 E. Middlefield Road Mountain View, CA 94043 USA

```text
   Phone: 1-650-426-3832
   EMail: dmraihi@verisign.com
```

Mihir Bellare 컴퓨터 공학부, 우편번호 0114 University of California at San Diego 9500 Gilman Drive La Jolla, CA 92093, USA

```text
   EMail: mihir@cs.ucsd.edu

   Frank Hoornaert
   VASCO Data Security, Inc.
   Koningin Astridlaan 164
   1780 Wemmel, Belgium

   EMail: frh@vasco.com
```

David Naccache Gemplus Innovation 34 rue Guynemer, 92447, Issy les Moulineaux, France 및 Information Security Group, Royal Holloway, University of London, Egham, Surrey TW20 0EX, UK

```text
   EMail: david.naccache@gemplus.com, david.naccache@rhul.ac.uk

   Ohad Ranen
   Aladdin Knowledge Systems Ltd.
   15 Beit Oved Street
   Tel Aviv, Israel 61110

   EMail: Ohad.Ranen@ealaddin.com
```

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(2005\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회 및 인터넷 공학 태스크포스는 모든 명시적 또는 묵시적 보증을 부인합니다. 여기에서 구성은 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않습니다.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
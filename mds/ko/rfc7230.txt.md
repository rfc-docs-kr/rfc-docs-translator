

```text
Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7230                                         Adobe
Obsoletes: 2145, 2616                                    J. Reschke, Ed.
Updates: 2817, 2818                                           greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721
```

하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 메시지 구문 및 라우팅

---
# **Abstract**

HTTP\(Hypertext Transfer Protocol\)는 분산, 협업, 하이퍼텍스트 정보 시스템을 위한 상태 비저장 애플리케이션 수준 프로토콜입니다. 이 문서는 HTTP 아키텍처 및 관련 용어에 대한 개요를 제공하고, "http" 및 "https" URI\(Uniform Resource Identifier\) ​​체계를 정의하고, HTTP/1.1 메시지 구문 및 구문 분석 요구 사항을 정의하고, 구현에 대한 관련 보안 문제를 설명합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7230에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2014 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................5
      1.1. Requirements Notation ......................................6
      1.2. Syntax Notation ............................................6
   2. Architecture ....................................................6
      2.1. Client/Server Messaging ....................................7
      2.2. Implementation Diversity ...................................8
      2.3. Intermediaries .............................................9
      2.4. Caches ....................................................11
      2.5. Conformance and Error Handling ............................12
      2.6. Protocol Versioning .......................................13
      2.7. Uniform Resource Identifiers ..............................16
           2.7.1. http URI Scheme ....................................17
           2.7.2. https URI Scheme ...................................18
           2.7.3. http and https URI Normalization and Comparison ....19
   3. Message Format .................................................19
      3.1. Start Line ................................................20
           3.1.1. Request Line .......................................21
           3.1.2. Status Line ........................................22
      3.2. Header Fields .............................................22
           3.2.1. Field Extensibility ................................23
           3.2.2. Field Order ........................................23
           3.2.3. Whitespace .........................................24
           3.2.4. Field Parsing ......................................25
           3.2.5. Field Limits .......................................26
           3.2.6. Field Value Components .............................27
      3.3. Message Body ..............................................28
           3.3.1. Transfer-Encoding ..................................28
           3.3.2. Content-Length .....................................30
           3.3.3. Message Body Length ................................32
      3.4. Handling Incomplete Messages ..............................34
      3.5. Message Parsing Robustness ................................34
   4. Transfer Codings ...............................................35
      4.1. Chunked Transfer Coding ...................................36
           4.1.1. Chunk Extensions ...................................36
           4.1.2. Chunked Trailer Part ...............................37
           4.1.3. Decoding Chunked ...................................38
      4.2. Compression Codings .......................................38
           4.2.1. Compress Coding ....................................38
           4.2.2. Deflate Coding .....................................38
           4.2.3. Gzip Coding ........................................39
      4.3. TE ........................................................39
      4.4. Trailer ...................................................40
   5. Message Routing ................................................40
      5.1. Identifying a Target Resource .............................40
      5.2. Connecting Inbound ........................................41
      5.3. Request Target ............................................41
           5.3.1. origin-form ........................................42
           5.3.2. absolute-form ......................................42
           5.3.3. authority-form .....................................43
           5.3.4. asterisk-form ......................................43
      5.4. Host ......................................................44
      5.5. Effective Request URI .....................................45
      5.6. Associating a Response to a Request .......................46
      5.7. Message Forwarding ........................................47
           5.7.1. Via ................................................47
           5.7.2. Transformations ....................................49
   6. Connection Management ..........................................50
      6.1. Connection ................................................51
      6.2. Establishment .............................................52
      6.3. Persistence ...............................................52
           6.3.1. Retrying Requests ..................................53
           6.3.2. Pipelining .........................................54
      6.4. Concurrency ...............................................55
      6.5. Failures and Timeouts .....................................55
      6.6. Tear-down .................................................56
      6.7. Upgrade ...................................................57
   7. ABNF List Extension: #rule .....................................59
   8. IANA Considerations ............................................61
      8.1. Header Field Registration .................................61
      8.2. URI Scheme Registration ...................................62
      8.3. Internet Media Type Registration ..........................62
           8.3.1. Internet Media Type message/http ...................62
           8.3.2. Internet Media Type application/http ...............63
      8.4. Transfer Coding Registry ..................................64
           8.4.1. Procedure ..........................................65
           8.4.2. Registration .......................................65
      8.5. Content Coding Registration ...............................66
      8.6. Upgrade Token Registry ....................................66
           8.6.1. Procedure ..........................................66
           8.6.2. Upgrade Token Registration .........................67
   9. Security Considerations ........................................67
      9.1. Establishing Authority ....................................67
      9.2. Risks of Intermediaries ...................................68
      9.3. Attacks via Protocol Element Length .......................69
      9.4. Response Splitting ........................................69
      9.5. Request Smuggling .........................................70
      9.6. Message Integrity .........................................70
      9.7. Message Confidentiality ...................................71
      9.8. Privacy of Server Log Information .........................71
   10. Acknowledgments ...............................................72
   11. References ....................................................74
      11.1. Normative References .....................................74
      11.2. Informative References ...................................75
   Appendix A. HTTP Version History ..................................78
      A.1. Changes from HTTP/1.0  ....................................78
           A.1.1.  Multihomed Web Servers ............................78
           A.1.2.  Keep-Alive Connections ............................79
           A.1.3.  Introduction of Transfer-Encoding .................79
      A.2.  Changes from RFC 2616 ....................................80
   Appendix B. Collected ABNF ........................................82
   Index .............................................................85
```

---
## **1.  Introduction**

HTTP\(Hypertext Transfer Protocol\)는 네트워크 기반 하이퍼텍스트 정보 시스템과의 유연한 상호 작용을 위해 확장 가능한 의미 체계와 자체 설명 메시지 페이로드를 사용하는 상태 비저장 애플리케이션 수준 요청/응답 프로토콜입니다. 이 문서는 HTTP/1.1 사양을 집합적으로 구성하는 일련의 문서 중 첫 번째 문서입니다.

```text
   1.  "Message Syntax and Routing" (this document)
```

2. "의미론 및 내용" \[RFC7231\]

```text
   3.  "Conditional Requests" [RFC7232]

   4.  "Range Requests" [RFC7233]

   5.  "Caching" [RFC7234]

   6.  "Authentication" [RFC7235]
```

이 HTTP/1.1 사양은 RFC 2616 및 RFC 2145\(HTTP 버전 관리에서\)를 더 이상 사용하지 않습니다. 또한 이 사양은 이전에 RFC 2817에 정의된 터널 설정을 위한 CONNECT 사용을 업데이트하고 RFC 2818에 비공식적으로 설명된 "https" URI 체계를 정의합니다.

HTTP는 정보 시스템을 위한 일반적인 인터페이스 프로토콜입니다. 제공된 리소스 유형에 관계없이 클라이언트에 균일한 인터페이스를 제공하여 서비스 구현 방법에 대한 세부 정보를 숨기도록 설계되었습니다. 마찬가지로, 서버는 각 클라이언트의 목적을 알 필요가 없습니다. HTTP 요청은 특정 유형의 클라이언트 또는 미리 결정된 애플리케이션 단계 순서와 연관되기보다는 별도로 고려될 수 있습니다. 그 결과 다양한 상황에서 효과적으로 사용할 수 있고 시간이 지남에 따라 구현이 독립적으로 발전할 수 있는 프로토콜이 탄생했습니다.

HTTP는 또한 HTTP가 아닌 정보 시스템과의 통신을 변환하기 위한 중개 프로토콜로 사용하도록 설계되었습니다. HTTP 프록시와 게이트웨이는 다양한 프로토콜을 HTTP 서비스와 동일한 방식으로 클라이언트가 보고 조작할 수 있는 하이퍼텍스트 형식으로 변환하여 대체 정보 서비스에 대한 액세스를 제공할 수 있습니다.

이러한 유연성의 한 가지 결과는 프로토콜이 인터페이스 뒤에서 발생하는 측면에서 정의될 수 없다는 것입니다. 대신, 우리는 통신 구문, 수신된 통신의 의도 및 수신자의 예상되는 동작을 정의하는 것으로 제한됩니다. 의사소통이 독립적으로 고려된다면 성공적인 조치입니다.

서버에서 제공하는 관찰 가능한 인터페이스에 대한 해당 변경 사항에 반영되어야 합니다. 그러나 여러 클라이언트가 병렬로 작동하고 아마도 교차 목적으로 작동할 수 있으므로 이러한 변경 사항이 단일 응답 범위를 넘어 관찰 가능하도록 요구할 수는 없습니다.

이 문서에서는 HTTP에서 사용되거나 참조되는 아키텍처 요소를 설명하고, "http" 및 "https" URI 체계를 정의하고, 전반적인 네트워크 운영 및 연결 관리를 설명하고, HTTP 메시지 프레이밍 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미론에 독립적인 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 구문 분석기와 메시지 전달 중개자를 위한 전체 요구 사항 세트를 정의하는 것입니다.

---
### **1.1.  Requirements Notation**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

오류 처리에 관한 적합성 기준 및 고려 사항은 섹션 2.5에 정의되어 있습니다.

---
### **1.2.  Syntax Notation**

이 사양은 섹션 7에 정의된 목록 확장과 함께 \[RFC5234\]의 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다. 이는 '#' 연산자를 사용하여 쉼표로 구분된 목록의 간결한 정의를 허용합니다\('\* ' 연산자는 반복을 나타냅니다\). 부록 B는 표준 ABNF 표기법으로 확장된 모든 목록 연산자와 함께 수집된 문법을 보여줍니다.

\[RFC5234\], 부록 B.1에 정의된 대로 다음 핵심 규칙이 참조로 포함됩니다. ALPHA\(문자\), CR\(캐리지 리턴\), CRLF\(CR LF\), CTL\(컨트롤\), DIGIT\(십진수 0-9\) , DQUOTE\(큰따옴표\), HEXDIG\(16진수 0-9/A-F/a-f\), HTAB\(가로 탭\), LF\(줄 바꿈\), OCTET\(8비트 데이터 시퀀스\), SP\(공백\) 및 VCHAR\( 보이는 모든 \[USASCII\] 문자\).

관례적으로 "obs-" 접두사가 붙은 ABNF 규칙 이름은 역사적인 이유로 나타나는 "구식" 문법 규칙을 나타냅니다.

---
## **2.  Architecture**

HTTP는 월드 와이드 웹\(WWW\) 아키텍처를 위해 만들어졌으며 전 세계 하이퍼텍스트 시스템의 확장성 요구를 지원하기 위해 시간이 지남에 따라 발전해 왔습니다. 해당 아키텍처의 대부분은 HTTP를 정의하는 데 사용되는 용어 및 구문 생성에 반영됩니다.

---
### **2.1.  Client/Server Messaging**

HTTP는 안정적인 전송 또는 세션 계층 "연결"\(섹션 6\)을 통해 메시지\(섹션 3\)를 교환하여 작동하는 상태 비저장 요청/응답 프로토콜입니다. HTTP "클라이언트"는 하나 이상의 HTTP 요청을 보내기 위해 서버에 연결을 설정하는 프로그램입니다. HTTP "서버"는 HTTP 응답을 전송하여 HTTP 요청을 서비스하기 위해 연결을 수락하는 프로그램입니다.

"클라이언트" 및 "서버"라는 용어는 이러한 프로그램이 특정 연결에 대해 수행하는 역할만을 나타냅니다. 동일한 프로그램이 일부 연결에서는 클라이언트 역할을 하고 다른 연결에서는 서버 역할을 할 수 있습니다. "사용자 에이전트"라는 용어는 브라우저, 스파이더\(웹 기반 로봇\), 명령줄 도구, 사용자 정의 애플리케이션 및 모바일 앱을 포함하되 이에 국한되지 않고 요청을 시작하는 다양한 클라이언트 프로그램을 의미합니다. "원본 서버"라는 용어는 주어진 대상 리소스에 대해 신뢰할 수 있는 응답을 생성할 수 있는 프로그램을 나타냅니다. "발신자" 및 "수신자"라는 용어는 각각 주어진 메시지를 보내거나 받는 모든 구현을 나타냅니다.

HTTP는 URI\(Uniform Resource Identifier\) ​​표준 \[RFC3986\]을 사용하여 대상 리소스\(섹션 5.1\)와 리소스 간의 관계를 나타냅니다. 메시지는 인터넷 메일 \[RFC5322\] 및 다목적 인터넷 메일 확장\(MIME\) \[RFC2045\]에서 사용되는 것과 유사한 형식으로 전달됩니다\(HTTP와 MIME 메시지 간의 차이점은 \[RFC7231\]의 부록 A 참조\).

대부분의 HTTP 통신은 URI로 식별되는 일부 리소스 표현에 대한 검색 요청\(GET\)으로 구성됩니다. 가장 간단한 경우 이는 사용자 에이전트\(UA\)와 원본 서버\(O\) 간의 단일 양방향 연결\(===\)을 통해 수행될 수 있습니다.

```text
            request   >
       UA ======================================= O
                                   <   response
```

클라이언트는 메서드, URI 및 프로토콜 버전\(섹션 3.1.1\)을 포함하는 요청 라인으로 시작하여 요청 수정자, 클라이언트 정보가 포함된 헤더 필드가 뒤따르는 요청 메시지 형식으로 서버에 HTTP 요청을 보냅니다. , 표현 메타데이터\(섹션 3.2\), 헤더 섹션의 끝을 나타내는 빈 줄, 마지막으로 페이로드 본문이 포함된 메시지 본문\(있는 경우 섹션 3.3\)입니다.

서버는 하나 이상의 HTTP 응답 메시지를 보내 클라이언트의 요청에 응답합니다. 각 메시지는 프로토콜 버전, 성공 또는 오류 코드, 텍스트 이유 문구\(섹션 3.1.2\)를 포함하는 상태 줄로 시작하고 헤더 필드가 뒤따를 수도 있습니다. 서버 정보, 리소스 메타데이터 및 표현 메타데이터\(섹션 3.2\), 헤더 섹션의 끝을 나타내는 빈 줄, 마지막으로 페이로드 본문이 포함된 메시지 본문\(있는 경우 섹션 3.3\)을 포함합니다.

섹션 6.3에 정의된 대로 연결은 여러 요청/응답 교환에 사용될 수 있습니다.

다음 예는 URI "http://www.example.com/hello.txt"의 GET 요청\(\[RFC7231\]의 섹션 4.3.1\)에 대한 일반적인 메시지 교환을 보여줍니다.

```text
   Client request:

     GET /hello.txt HTTP/1.1
     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
     Host: www.example.com
     Accept-Language: en, mi

   Server response:

     HTTP/1.1 200 OK
     Date: Mon, 27 Jul 2009 12:28:53 GMT
     Server: Apache
     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
     ETag: "34aa387-d-1568eb00"
     Accept-Ranges: bytes
     Content-Length: 51
     Vary: Accept-Encoding
     Content-Type: text/plain
```

안녕하세요 월드! 내 페이로드에는 후행 CRLF가 포함되어 있습니다.

---
### **2.2.  Implementation Diversity**

HTTP의 설계를 고려할 때 모든 사용자 에이전트는 범용 브라우저이고 모든 원본 서버는 대규모 공개 웹사이트라고 생각하는 함정에 빠지기 쉽습니다. 실제로는 그렇지 않습니다. 일반적인 HTTP 사용자 에이전트에는 가전제품, 스테레오, 저울, 펌웨어 업데이트 스크립트, 명령줄 프로그램, 모바일 앱 및 다양한 모양과 크기의 통신 장치가 포함됩니다. 마찬가지로 일반적인 HTTP 원본 서버에는 홈 자동화가 포함됩니다.

장치, 구성 가능한 네트워킹 구성 요소, 사무용 기계, 자율 로봇, 뉴스 피드, 교통 카메라, 광고 선택기 및 비디오 전달 플랫폼.

"사용자 에이전트"라는 용어는 요청 시 소프트웨어 에이전트와 직접 상호 작용하는 인간 사용자가 있음을 의미하지 않습니다. 많은 경우 사용자 에이전트는 백그라운드에서 실행되고 나중에 검사를 위해 결과를 저장하도록 설치되거나 구성됩니다\(또는 흥미롭거나 오류가 있을 수 있는 결과의 하위 집합만 저장\). 예를 들어, 스파이더에는 일반적으로 시작 URI가 제공되며 웹을 하이퍼텍스트 그래프로 크롤링하는 동안 특정 동작을 따르도록 구성됩니다.

HTTP의 구현 다양성은 모든 사용자 에이전트가 사용자에게 대화형 제안을 제공하거나 보안 또는 개인 정보 보호 문제에 대해 적절한 경고를 제공할 수는 없음을 의미합니다. 이 사양에서 사용자에게 오류를 보고해야 하는 소수의 경우 이러한 보고는 오류 콘솔이나 로그 파일에서만 관찰할 수 있습니다. 마찬가지로, 진행하기 전에 사용자가 자동 ​​작업을 확인해야 한다는 요구 사항은 고급 구성 선택, 런타임 옵션 또는 안전하지 않은 작업의 간단한 회피를 통해 충족될 수 있습니다. 확인은 사용자가 이미 해당 선택을 한 경우 특정 사용자 인터페이스나 일반 처리 중단을 의미하지 않습니다.

---
### **2.3.  Intermediaries**

HTTP를 사용하면 중개자를 사용하여 연결 체인을 통해 요청을 충족할 수 있습니다. HTTP 중개자에는 프록시, 게이트웨이, 터널의 세 가지 일반적인 형태가 있습니다. 어떤 경우에는 단일 중개자가 원본 서버, 프록시, 게이트웨이 또는 터널 역할을 하여 각 요청의 특성에 따라 동작을 전환할 수 있습니다.

```text
            >             >             >             >
       UA =========== A =========== B =========== C =========== O
                  <             <             <             <
```

위 그림은 사용자 에이전트와 원본 서버 사이의 세 가지 중개자\(A, B, C\)를 보여줍니다. 전체 체인을 이동하는 요청 또는 응답 메시지는 4개의 개별 연결을 통과합니다. 일부 HTTP 통신 옵션은 가장 가까운 터널이 아닌 이웃과의 연결에만 적용되거나 체인의 끝점에만 적용되거나 체인을 따른 모든 연결에 적용될 수 있습니다. 다이어그램은 선형이지만 각 참가자는 여러 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 이외의 많은 클라이언트로부터 요청을 수신하거나 C 이외의 서버로 요청을 전달하는 동시에 A의 클라이언트를 처리할 수 있습니다.

요구. 마찬가지로 나중에 요청은 로드 밸런싱을 위한 동적 구성을 기반으로 하는 다른 연결 경로를 통해 전송될 수 있습니다.

"업스트림" 및 "다운스트림"이라는 용어는 메시지 흐름과 관련된 방향 요구 사항을 설명하는 데 사용됩니다. 모든 메시지는 업스트림에서 다운스트림으로 흐릅니다. "인바운드" 및 "아웃바운드"라는 용어는 요청 경로와 관련된 방향 요구 사항을 설명하는 데 사용됩니다. "인바운드"는 원본 서버를 향하는 것을 의미하고 "아웃바운드"는 사용자 에이전트를 향하는 것을 의미합니다.

"프록시"는 특정 유형의 절대 URI에 대한 요청을 수신하고 HTTP 인터페이스를 통한 변환을 통해 해당 요청을 충족시키려고 클라이언트가 일반적으로 로컬 구성 규칙을 통해 선택하는 메시지 전달 에이전트입니다. "http" URI에 대한 프록시 요청과 같은 일부 번역은 최소한이지만, 다른 요청은 완전히 다른 애플리케이션 수준 프로토콜로의 번역이 필요할 수 있습니다. 프록시는 보안, 주석 서비스 또는 공유 캐싱을 위해 공통 중개자를 통해 조직의 HTTP 요청을 그룹화하는 데 자주 사용됩니다. 일부 프록시는 섹션 5.7.2에 설명된 대로 전달되는 동안 선택한 메시지 또는 페이로드에 변환을 적용하도록 설계되었습니다.

"게이트웨이"\(일명 "역방향 프록시"\)는 아웃바운드 연결을 위한 원본 서버 역할을 하지만 수신된 요청을 변환하여 인바운드로 다른 서버로 전달하는 중개자입니다. 게이트웨이는 레거시 또는 신뢰할 수 없는 정보 서비스를 캡슐화하고, "가속기" 캐싱을 통해 서버 성능을 향상시키며, 여러 시스템에 걸쳐 HTTP 서비스의 분할 또는 로드 균형 조정을 활성화하는 데 종종 사용됩니다.

원본 서버에 적용되는 모든 HTTP 요구 사항은 게이트웨이의 아웃바운드 통신에도 적용됩니다. 게이트웨이는 이 사양의 범위를 벗어나는 HTTP에 대한 개인 확장을 포함하여 원하는 프로토콜을 사용하여 인바운드 서버와 통신합니다. 그러나 타사 HTTP 서버와 상호 운용하려는 HTTP-HTTP 게이트웨이는 게이트웨이의 인바운드 연결에 대한 사용자 에이전트 요구 사항을 준수해야 합니다.

"터널"은 메시지를 변경하지 않고 두 연결 간의 블라인드 릴레이 역할을 합니다. 일단 활성화되면 터널은 HTTP 요청에 의해 시작되었을 수 있지만 HTTP 통신의 당사자로 간주되지 않습니다. 중계된 연결의 양쪽 끝이 닫히면 터널은 더 이상 존재하지 않습니다. 터널은 전송 계층 보안\(TLS, \[RFC5246\]\)을 사용하여 공유 방화벽 프록시를 통해 기밀 통신을 설정하는 경우와 같이 중개자를 통해 가상 연결을 확장하는 데 사용됩니다.

중개자에 대한 위의 범주는 HTTP 통신의 참가자 역할만 고려합니다. 네트워크 프로토콜 스택의 하위 계층에서 작동하여 메시지 보낸 사람이 알지 못하거나 허가를 받지 않고도 HTTP 트래픽을 필터링하거나 리디렉션할 수 있는 중개자도 있습니다. 네트워크 중개자는 \(프로토콜 수준에서\) 중간자 공격과 구별할 수 없으며 실수로 HTTP 의미 체계를 위반하여 보안 결함이나 상호 운용성 문제를 일으키는 경우가 많습니다.

예를 들어, "가로채기 프록시"\[RFC3040\]\(일반적으로 "투명 프록시"\[RFC1919\] 또는 "종속 포털"이라고도 함\)는 클라이언트가 선택하지 않는다는 점에서 HTTP 프록시와 다릅니다. 대신, 차단 프록시는 나가는 TCP 포트 80 패킷\(때때로 기타 일반 포트 트래픽\)을 필터링하거나 리디렉션합니다. 차단 프록시는 로컬이 아닌 인터넷 서비스 사용을 허용하기 전에 계정 가입을 시행하는 수단으로, 그리고 네트워크 사용 정책을 시행하기 위해 회사 방화벽 내에서 공용 네트워크 액세스 포인트에서 흔히 발견됩니다.

HTTP는 상태 비저장 프로토콜로 정의됩니다. 즉, 각 요청 메시지를 개별적으로 이해할 수 있습니다. 많은 구현은 프록시 연결을 재사용하거나 여러 서버에 걸쳐 요청을 동적으로 로드 밸런싱하기 위해 HTTP의 상태 비저장 설계에 의존합니다. 따라서 서버는 연결이 보안되고 해당 에이전트에 특정되지 않는 한 동일한 연결에 대한 두 요청이 동일한 사용자 에이전트에서 왔다고 가정해서는 안 됩니다. 일부 비표준 HTTP 확장\(예: \[RFC4559\]\)은 이 요구 사항을 위반하여 보안 및 상호 운용성 문제를 일으키는 것으로 알려져 있습니다.\(MUST NOT\)

---
### **2.4.  Caches**

"캐시"는 이전 응답 메시지의 로컬 저장소이자 메시지 저장, 검색 및 삭제를 제어하는 ​​하위 시스템입니다. 캐시는 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄이기 위해 캐시 가능한 응답을 저장합니다. 모든 클라이언트나 서버는 캐시를 사용할 수 있지만 캐시는 터널 역할을 하는 동안 서버에서 사용할 수 없습니다.\(MAY\)

캐시의 효과는 체인에 있는 참가자 중 하나가 해당 요청에 적용할 수 있는 캐시된 응답을 가지고 있는 경우 요청/응답 체인이 단축된다는 것입니다. 다음은 UA 또는 A에 의해 캐시되지 않은 요청에 대해 \(C를 통해\) O로부터의 이전 응답의 캐시된 복사본이 B에 있는 경우 결과 체인을 보여줍니다.

```text
               >             >
          UA =========== A =========== B - - - - - - C - - - - - - O
                     <             <
```

캐시가 후속 요청에 응답하는 데 사용하기 위해 응답 메시지의 복사본을 저장할 수 있는 경우 응답은 "캐시 가능"합니다. 응답을 캐시할 수 있는 경우에도 캐시된 응답을 특정 요청에 사용할 수 있는 시기에 대해 클라이언트나 원본 서버에서 추가 제약 조건을 적용할 수 있습니다. 캐시 동작 및 캐시 가능한 응답에 대한 HTTP 요구 사항은 \[RFC7234\]의 섹션 2에 정의되어 있습니다.

World Wide Web과 대규모 조직 내부에는 매우 다양한 아키텍처와 캐시 구성이 배포되어 있습니다. 여기에는 대양 횡단 대역폭을 절약하기 위한 프록시 캐시의 국가 계층 구조, 캐시 항목을 브로드캐스트 또는 멀티캐스트하는 협업 시스템, 오프라인 또는 대기 시간이 긴 환경에서 사용하기 위해 미리 가져온 캐시 항목 아카이브 등이 포함됩니다.

---
### **2.5.  Conformance and Error Handling**

이 사양은 HTTP 통신 참가자의 역할에 따른 적합성 기준을 목표로 합니다. 따라서 HTTP 요구 사항은 요구 사항에 의해 제한되는 동작에 따라 발신자, 수신자, 클라이언트, 서버, 사용자 에이전트, 중개자, 원본 서버, 프록시, 게이트웨이 또는 캐시에 적용됩니다. 단일 통신의 범위를 넘어서 적용되는 경우 구현, 리소스 소유자 및 프로토콜 요소 등록에 추가\(사회적\) 요구 사항이 적용됩니다.

요구사항에 따라 프로토콜 요소 생성과 단순히 수신된 요소를 다운스트림으로 전달하는 것이 구분되는 경우 "보내기" 대신 "생성"이라는 동사가 사용됩니다.

구현은 HTTP에서 참여하는 역할과 관련된 모든 요구 사항을 준수하는 경우 준수로 간주됩니다.

적합성은 프로토콜 요소의 구문과 의미를 모두 포함합니다. 발신자는 자신이 거짓이라고 알고 있는 의미를 전달하는 프로토콜 요소를 생성해서는 안 됩니다. 발신자는 해당 ABNF 규칙에 의해 정의된 문법과 일치하지 않는 프로토콜 요소를 생성해서는 안 됩니다. 주어진 메시지 내에서 발신자는 다른 역할\(즉, 발신자가 해당 메시지에 대해 갖고 있지 않은 역할\)의 참가자에 의해서만 생성되도록 허용된 프로토콜 요소 또는 구문 대안을 생성해서는 안 됩니다.\(MUST NOT, MUST NOT, MUST NOT\)

수신된 프로토콜 요소가 구문 분석될 때 수신자는 수신자의 역할에 적용 가능하고 해당 ABNF 규칙에 의해 정의된 문법과 일치하는 합리적인 길이의 값을 구문 분석할 수 있어야 합니다. 그러나 일부 수신된 프로토콜 요소는 구문 분석되지 않을 수 있습니다. 예를 들어, 중개인\(MUST\)

메시지를 전달하면 헤더 필드를 일반 필드 이름 및 필드 값 구성 요소로 구문 분석할 수 있지만 필드 값 내부를 추가로 구문 분석하지 않고 헤더 필드를 전달할 수 있습니다.

HTTP에는 배포 컨텍스트와 구현 목적에 따라 적절한 길이가 크게 달라지기 때문에 많은 프로토콜 요소에 대한 특정 길이 제한이 없습니다. 따라서 발신자와 수신자 간의 상호 운용성은 각 프로토콜 요소의 합리적인 길이에 관한 공유된 기대에 따라 달라집니다. 또한, 일부 프로토콜 요소의 합리적인 길이로 일반적으로 이해되는 길이는 지난 20년 동안 HTTP를 사용하면서 변경되었으며 앞으로도 계속 변경될 것으로 예상됩니다.

최소한 수신자는 다른 메시지의 동일한 프로토콜 요소에 대해 생성하는 값만큼 긴 프로토콜 요소 길이를 구문 분석하고 처리할 수 있어야 합니다. 예를 들어, 자체 리소스에 대한 매우 긴 URI 참조를 게시하는 원본 서버는 요청 대상으로 수신될 때 동일한 참조를 구문 분석하고 처리할 수 있어야 합니다.\(MUST\)

수신자가 \(경험이나 구성을 통해\) 발신자가 해당 의미에 의해 암시된 내용을 잘못 구현했다고 판단하지 않는 한, 수신자는 이 사양에 대한 확장을 포함하여 이 사양에 의해 정의된 의미에 따라 수신된 프로토콜 요소를 해석해야 합니다. 예를 들어, User-Agent 헤더 필드를 조사한 결과 특정 콘텐츠 코딩 수신 시 실패하는 것으로 알려진 특정 구현 버전이 표시되는 경우 원본 서버는 수신된 Accept-Encoding 헤더 필드의 콘텐츠를 무시할 수 있습니다.\(MUST\)

달리 명시하지 않는 한, 수신자는 유효하지 않은 구성으로부터 사용 가능한 프로토콜 요소를 복구하려고 시도할 수 있습니다. HTTP는 보안에 직접적인 영향을 미치는 경우를 제외하고 특정 오류 처리 메커니즘을 정의하지 않습니다. 프로토콜의 다양한 응용 프로그램에는 서로 다른 오류 처리 전략이 필요하기 때문입니다. 예를 들어, 웹 브라우저는 Location 헤더 필드가 ABNF에 따라 구문 분석되지 않는 응답에서 투명하게 복구하기를 원하는 반면, 시스템 제어 클라이언트는 모든 형태의 오류 복구를 위험하다고 간주할 수 있습니다.\(MAY\)

---
### **2.6.  Protocol Versioning**

HTTP는 "<major\>.<minor\>" 번호 지정 체계를 사용하여 프로토콜 버전을 나타냅니다. 이 사양은 버전 "1.1"을 정의합니다. 프로토콜 버전 전체는 해당 버전의 해당 HTTP 사양에 제시된 요구 사항 집합에 대한 보낸 사람의 준수를 나타냅니다.

HTTP 메시지의 버전은 메시지의 첫 번째 줄에 있는 HTTP 버전 필드로 표시됩니다. HTTP 버전은 대소문자를 구분합니다.

```text
     HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
     HTTP-name     = %x48.54.54.50 ; "HTTP", case-sensitive
```

HTTP 버전 번호는 "."로 구분된 두 개의 십진수로 구성됩니다. \(마침표 또는 소수점\). 첫 번째 숫자\("주 버전"\)는 HTTP 메시징 구문을 나타내는 반면, 두 번째 숫자\("부 버전"\)는 보낸 사람이 준수하고 향후 통신을 이해할 수 있는 주요 버전 내에서 가장 높은 부 버전을 나타냅니다. 마이너 버전은 발신자가 이전 버전과 호환되는 프로토콜 하위 집합만 사용하는 경우에도 발신자의 통신 기능을 광고하여 수신자에게 응답\(서버\) 또는 향후 요청\(클라이언트\)에서 더 고급 기능을 사용할 수 있음을 알립니다. .

HTTP/1.1 메시지가 HTTP/1.0 수신자\[RFC1945\] 또는 버전을 알 수 없는 수신자에게 전송될 때, HTTP/1.1 메시지는 최신 버전이 모두 있는 경우 유효한 HTTP/1.0 메시지로 해석될 수 있도록 구성됩니다. 기능은 무시됩니다. 이 사양은 일부 새로운 기능에 대한 수신자 버전 요구 사항을 지정하므로 준수하는 발신자는 구성이나 메시지 수신을 통해 수신자가 HTTP/1.1을 지원한다고 확인할 때까지 호환되는 기능만 사용하게 됩니다.

헤더 필드의 해석은 동일한 주요 HTTP 버전의 부 버전 간에 변경되지 않습니다. 하지만 해당 필드가 없는 경우 수신자의 기본 동작은 변경될 수 있습니다. 별도로 지정하지 않는 한, HTTP/1.1에 정의된 헤더 필드는 모든 버전의 HTTP/1.x에 대해 정의됩니다. 특히 Host 및 Connection 헤더 필드는 HTTP/1.1 준수 광고 여부에 관계없이 모든 HTTP/1.x 구현에서 구현되어야 합니다.

정의된 의미 체계를 통해 이를 인식하지 못하는 수신자가 안전하게 무시할 수 있는 경우 프로토콜 버전을 변경하지 않고도 새 헤더 필드를 도입할 수 있습니다. 헤더 필드 확장성은 섹션 3.2.1에서 논의됩니다.

HTTP 메시지를 처리하는 중개자\(즉, 터널 역할을 제외한 모든 중개자\)는 전달된 메시지에 자체 HTTP 버전을 보내야 합니다. 즉, 해당 메시지의 프로토콜 버전이 해당 중개자가 메시지 수신 및 전송에 적합한 버전과 일치하는지 확인하지 않고 HTTP 메시지의 첫 번째 줄을 맹목적으로 전달할 수 없습니다. 다시 작성하지 않고 HTTP 메시지 전달\(MUST\)

HTTP 버전은 다운스트림 수신자가 메시지 발신자의 버전을 사용하여 나중에 해당 발신자와의 통신에 사용하기에 안전한 기능을 결정할 때 통신 오류를 초래할 수 있습니다.

클라이언트는 클라이언트가 준수하는 가장 높은 버전과 동일한 요청 버전을 전송해야 하며, 해당 버전의 주요 버전은 서버가 지원하는 가장 높은 버전보다 높지 않은 경우\(알려진 경우\) 클라이언트는 자신이 준수하지 않는 버전을 보내서는 안 됩니다.\(SHOULD, MUST NOT\)

서버가 HTTP 사양을 잘못 구현한 것으로 알려진 경우 클라이언트는 더 낮은 요청 버전을 보낼 수 있지만, 클라이언트가 적어도 하나의 정상적인 요청을 시도하고 응답 상태 코드 또는 헤더 필드\(예: 서버\)에서 결정한 후에만 가능합니다. 서버가 더 높은 요청 버전을 부적절하게 처리합니다.\(MAY\)

서버는 요청에서 수신된 버전보다 낮거나 같은 주요 버전을 포함하는 서버가 준수하는 가장 높은 버전과 동일한 응답 버전을 보내야 합니다\(SHOULD\). 서버는 자신이 준수하지 않는 버전을 보내서는 안 됩니다. 서버는 어떤 이유로든 클라이언트의 주요 프로토콜 버전 서비스를 거부하려는 경우 505\(HTTP 버전은 지원되지 않음\) 응답을 보낼 수 있습니다.\(SHOULD, MUST NOT\)

클라이언트가 HTTP 사양을 잘못 구현하고 이후 버전 응답을 올바르게 처리할 수 없는 것으로 알려지거나 의심되는 경우\(예: 클라이언트가 버전 번호를 올바르게 구문 분석하지 못하는 경우\) 서버는 요청에 대한 HTTP/1.0 응답을 보낼 수 있습니다. 중개자는 주어진 프로토콜의 마이너 버전을 따르지 않는 경우에도 HTTP 버전을 맹목적으로 전달하는 것으로 알려져 있습니다. 이러한 프로토콜 다운그레이드는 하나 이상의 요청 헤더 필드\(예: User-Agent\)가 오류가 있는 것으로 알려진 클라이언트가 전송한 값과 고유하게 일치하는 경우와 같이 특정 클라이언트 속성에 의해 트리거되지 않는 한 수행되어서는 안 됩니다.\(MAY, SHOULD NOT\)

HTTP 버전 관리 설계의 의도는 호환되지 않는 메시지 구문이 도입된 경우에만 메이저 번호가 증가하고 프로토콜 변경으로 인해 메시지 의미가 추가되거나 추가 의미가 암시될 때만 마이너 번호가 증가하도록 하는 것입니다. 발신자의 능력. 그러나 \[RFC2068\]과 \[RFC2616\] 사이에 도입된 변경 사항에 대해 부 버전이 증가되지 않았으며 이번 개정판에서는 프로토콜에 대한 그러한 변경 사항을 특별히 방지했습니다.

수신자가 구현하는 메이저 버전 번호가 있지만 수신자가 구현하는 것보다 더 높은 마이너 버전 번호로 HTTP 메시지가 수신되면 수신자는 해당 메시지가 해당 메이저 버전 내에서 가장 높은 마이너 버전에 있는 것처럼 메시지를 처리해야 합니다. 수신자가 준수합니다. 수신자는 다음을 가정할 수 있습니다.\(SHOULD\)

더 높은 마이너 버전이 포함된 메시지를 아직 상위 버전에 대한 지원을 표시하지 않은 수신자에게 전송하면 동일한 메이저 버전의 구현에서 안전하게 처리할 수 있을 정도로 이전 버전과 충분히 호환됩니다.

---
### **2.7.  Uniform Resource Identifiers**

URI\(Uniform Resource Identifier\) ​​\[RFC3986\]는 HTTP 전체에서 리소스를 식별하는 수단으로 사용됩니다\(\[RFC7231\]의 섹션 2\). URI 참조는 요청 대상 지정, 리디렉션 표시 및 관계 정의에 사용됩니다.

"URI-참조", "절대-URI", "상대 부분", "구성표", "권한", "포트", "호스트", "경로 비빈", "세그먼트", "쿼리"의 정의 , "fragment"는 URI 일반 구문에서 채택되었습니다. 비어 있지 않은 경로 구성 요소를 포함할 수 있는 프로토콜 요소에 대해 "절대 경로" 규칙이 정의됩니다. \(이 규칙은 참조에 빈 경로를 사용할 수 있도록 허용하는 RFC 3986의 경로-절대 규칙 및 "//"로 시작하는 경로를 허용하지 않는 경로 절대 규칙과 약간 다릅니다.\) -URI" 규칙은 상대 URI를 포함할 수 있지만 조각 구성 요소는 포함할 수 없는 프로토콜 요소에 대해 정의됩니다.

```text
     URI-reference = <URI-reference, see [RFC3986], Section 4.1>
     absolute-URI  = <absolute-URI, see [RFC3986], Section 4.3>
     relative-part = <relative-part, see [RFC3986], Section 4.2>
     scheme        = <scheme, see [RFC3986], Section 3.1>
     authority     = <authority, see [RFC3986], Section 3.2>
     uri-host      = <host, see [RFC3986], Section 3.2.2>
     port          = <port, see [RFC3986], Section 3.2.3>
     path-abempty  = <path-abempty, see [RFC3986], Section 3.3>
     segment       = <segment, see [RFC3986], Section 3.3>
     query         = <query, see [RFC3986], Section 3.4>
     fragment      = <fragment, see [RFC3986], Section 3.5>

     absolute-path = 1*( "/" segment )
     partial-URI   = relative-part [ "?" query ]
```

URI 참조를 허용하는 HTTP의 각 프로토콜 요소는 해당 요소가 모든 참조 형식\(URI 참조\)을 허용하는지, 절대 형식의 URI\(absolute-URI\)만 허용하는지, 경로 및 선택적 쿼리 구성 요소만 허용하는지 여부를 ABNF 생성에서 나타냅니다. 또는 위의 내용을 조합한 것입니다. 달리 명시하지 않는 한, URI 참조는 유효한 요청 URI\(섹션 5.5\)를 기준으로 구문 분석됩니다.

---
#### **2.7.1.  http URI Scheme**

"http" URI 체계는 주어진 포트에서 TCP\(\[RFC0793\]\) 연결을 수신하는 잠재적인 HTTP 원본 서버에 의해 관리되는 계층적 네임스페이스와의 연관성에 따라 식별자를 생성하기 위한 목적으로 정의됩니다.

```text
     http-URI = "http:" "//" authority path-abempty [ "?" query ]
                [ "#" fragment ]
```

"http" URI에 대한 원본 서버는 호스트 식별자와 선택적 TCP 포트\(\[RFC3986\], 섹션 3.2.2\)를 포함하는 권한 구성 요소로 식별됩니다. 계층적 경로 구성 요소와 선택적 쿼리 구성 요소는 원본 서버의 이름 공간 내에서 잠재적인 대상 리소스에 대한 식별자 역할을 합니다. 선택적 조각 구성 요소는 \[RFC3986\]의 섹션 3.5에 정의된 대로 URI 체계와 관계없이 보조 리소스의 간접적인 식별을 허용합니다.

발신자는 빈 호스트 식별자를 사용하여 "http" URI를 생성해서는 안 됩니다. 그러한 URI 참조를 처리하는 수신자는 이를 유효하지 않은 것으로 거부해야 합니다.\(MUST NOT, MUST\)

호스트 식별자가 IP 주소로 제공되는 경우 원본 서버는 해당 IP 주소에 표시된 TCP 포트의 수신기\(있는 경우\)입니다. 호스트가 등록된 이름인 경우 등록된 이름은 해당 원본 서버의 주소를 찾기 위해 DNS와 같은 이름 확인 서비스와 함께 사용하기 위한 간접 식별자입니다. 포트 하위 구성 요소가 비어 있거나 지정되지 않은 경우 TCP 포트 80\(WWW 서비스용으로 예약된 포트\)이 기본값입니다.

주어진 권한 구성 요소가 있는 URI가 있다고 해서 항상 해당 호스트와 포트에서 연결을 수신하는 HTTP 서버가 있다는 의미는 아닙니다. 누구나 URI를 만들 수 있습니다. 권한 구성 요소가 결정하는 것은 식별된 리소스를 대상으로 하는 요청에 권위 있게 응답할 권리가 있는 사람입니다. 등록된 이름과 IP 주소의 위임된 특성은 HTTP 서버의 존재 여부에 관계없이 표시된 호스트 및 포트에 대한 제어를 기반으로 페더레이션된 네임스페이스를 생성합니다. 권한 설정과 관련된 보안 고려 사항은 섹션 9.1을 참조하세요.

표시된 리소스에 대한 액세스를 요구하는 컨텍스트 내에서 "http" URI가 사용되면 클라이언트는 호스트를 IP 주소로 확인하고 표시된 포트에서 해당 주소에 대한 TCP 연결을 설정한 다음 HTTP를 전송하여 액세스를 시도할 수 있습니다. URI의 식별 데이터\(섹션 5\)가 포함된 요청 메시지\(섹션 3\)를 서버에 보냅니다. 서버가 임시가 아닌 요청에 응답하는 경우\(MAY\)

\[RFC7231\]의 섹션 6에 설명된 대로 HTTP 응답 메시지는 해당 응답이 클라이언트 요청에 대한 신뢰할 수 있는 응답으로 간주됩니다.

HTTP는 전송 프로토콜과 독립적이지만 이름 위임 프로세스는 권한 설정을 위해 TCP에 의존하기 때문에 "http" 체계는 TCP 기반 서비스에만 적용됩니다. 다른 기본 연결 프로토콜을 기반으로 하는 HTTP 서비스는 종단 간 보안 연결이 필요한 리소스에 "https" 체계\(아래\)가 사용되는 것처럼 다른 URI 체계를 사용하여 식별될 수 있습니다. 다른 프로토콜을 사용하여 "http" 식별된 리소스에 대한 액세스를 제공할 수도 있습니다. 이는 TCP에만 해당되는 권한 있는 인터페이스입니다.

권한에 대한 URI 일반 구문에는 URI에 사용자 인증 정보를 포함하기 위한 더 이상 사용되지 않는 userinfo 하위 구성 요소\(\[RFC3986\], 섹션 3.2.1\)도 포함되어 있습니다. 일부 구현에서는 명령 호출 옵션, 구성 파일 또는 책갈피 목록과 같은 인증 정보의 내부 구성을 위해 userinfo 구성 요소를 사용합니다. 이러한 사용으로 인해 사용자 식별자나 비밀번호가 노출될 수 있습니다. "http" URI 참조가 메시지 내에서 요청 대상 또는 헤더 필드 값으로 생성될 때 발신자는 userinfo 하위 구성 요소\(및 해당 "@" 구분 기호\)를 생성해서는 안 됩니다. 신뢰할 수 없는 소스로부터 수신된 "http" URI 참조를 사용하기 전에 수신자는 사용자 정보를 구문 분석하고 그 존재를 오류로 처리해야 합니다. 피싱 공격을 위해 권한을 모호하게 하는 데 사용될 가능성이 높습니다.\(MUST NOT, SHOULD\)

---
#### **2.7.2.  https URI Scheme**

"https" URI 체계는 TLS 보안 연결\(\[RFC5246\]\)을 위해 주어진 TCP 포트를 수신하는 잠재적인 HTTP 원본 서버에 의해 관리되는 계층적 네임스페이스와의 연관성에 따라 식별자를 생성할 목적으로 정의됩니다.

"http" 구성표에 대해 위에 나열된 모든 요구 사항은 "https" 구성표에 대한 요구 사항이기도 합니다. 단, 포트 하위 구성 요소가 비어 있거나 제공되지 않은 경우 TCP 포트 443이 기본값이며 사용자 에이전트는 해당 연결을 보장해야 합니다. 원본 서버는 첫 번째 HTTP 요청을 보내기 전에 강력한 암호화를 사용하여 종단 간 보안을 유지합니다.\(MUST\)

```text
     https-URI = "https:" "//" authority path-abempty [ "?" query ]
                 [ "#" fragment ]
```

"https" URI 체계는 권한 설정을 위해 TLS와 TCP 모두에 의존합니다. "https" 구성표를 통해 사용할 수 있는 리소스는 "http" 구성표와 공유되는 ID가 없습니다.

리소스 식별자는 동일한 권한\(동일한 TCP 포트를 수신하는 동일한 호스트\)을 나타냅니다. 이들은 별개의 네임스페이스이며 별개의 원본 서버로 간주됩니다. 그러나 쿠키 프로토콜 \[RFC6265\]과 같이 전체 호스트 도메인에 적용되도록 정의된 HTTP 확장을 사용하면 한 서비스에서 설정한 정보가 일치하는 호스트 도메인 그룹 내의 다른 서비스와의 통신에 영향을 줄 수 있습니다.

"https"로 식별된 리소스에 대한 권한 있는 액세스 프로세스는 \[RFC2818\]에 정의되어 있습니다.

---
#### **2.7.3.  http and https URI Normalization and Comparison**

"http" 및 "https" 체계는 URI 일반 구문을 따르기 때문에 이러한 URI는 각 체계에 대해 위에서 설명한 기본값을 사용하여 \[RFC3986\]의 섹션 6에 정의된 알고리즘에 따라 정규화되고 비교됩니다.

포트가 구성표의 기본 포트와 동일한 경우 일반적인 형식은 포트 하위 구성 요소를 생략하는 것입니다. OPTIONS 요청의 요청 대상으로 절대 형식으로 사용되지 않는 경우 빈 경로 구성 요소는 "/"의 절대 경로와 동일하므로 대신 "/"의 경로를 제공하는 것이 일반 형식입니다. 구성표와 호스트는 대소문자를 구분하지 않으며 일반적으로 소문자로 제공됩니다. 다른 모든 구성요소는 대소문자를 구분하여 비교됩니다. "예약된" 집합에 있는 문자 이외의 문자는 백분율로 인코딩된 옥텟과 동일합니다. 일반적인 형식은 이를 인코딩하지 않는 것입니다\(\[RFC3986\]의 섹션 2.1 및 2.2 참조\).

예를 들어 다음 세 개의 URI는 동일합니다.

```text
      http://example.com:80/~smith/home.html
      http://EXAMPLE.com/%7Esmith/home.html
      http://EXAMPLE.com:/%7esmith/home.html
```

---
## **3.  Message Format**

모든 HTTP/1.1 메시지는 시작줄과 인터넷 메시지 형식 \[RFC5322\]과 유사한 형식의 옥텟 시퀀스로 구성됩니다. 0개 이상의 헤더 필드\(통칭하여 "헤더" 또는 "헤더 섹션"이라고 함\) \), 헤더 섹션의 끝을 나타내는 빈 줄 및 선택적 메시지 본문입니다.

```text
     HTTP-message   = start-line
                      *( header-field CRLF )
                      CRLF
                      [ message-body ]
```

HTTP 메시지를 구문 분석하는 일반적인 절차는 시작 줄을 구조로 읽고, 각 헤더 필드를 빈 줄까지 필드 이름별로 해시 테이블로 읽은 다음 구문 분석된 데이터를 사용하여 메시지 본문이 필요한지 확인하는 것입니다. 메시지 본문이 표시된 경우 메시지 본문 길이와 동일한 옥텟 수를 읽거나 연결이 닫힐 때까지 스트림으로 읽혀집니다.

수신자는 HTTP 메시지를 US-ASCII\[USASCII\]의 상위 집합인 인코딩의 옥텟 시퀀스로 구문 분석해야 합니다. 특정 인코딩에 관계없이 HTTP 메시지를 유니코드 문자 스트림으로 구문 분석하면 문자열 처리 라이브러리가 옥텟 LF\(%x0A\)가 포함된 잘못된 멀티바이트 문자 시퀀스를 처리하는 다양한 방식으로 인해 보안 취약점이 발생합니다. 문자열 기반 파서는 메시지 구문 분석이 개별 필드를 기술한 후 헤더 필드 값 내와 같이 메시지에서 요소가 추출된 후 프로토콜 요소 내에서만 안전하게 사용할 수 있습니다.\(MUST\)

HTTP 메시지는 증분 처리 또는 다운스트림 전달을 위한 스트림으로 구문 분석될 수 있습니다. 그러나 일부 구현에서는 네트워크 효율성, 보안 검사 또는 페이로드 변환을 위해 메시지 전달을 버퍼링하거나 지연하므로 수신자는 부분 메시지의 증분 전달에 의존할 수 없습니다.

발신자는 시작 줄과 첫 번째 헤더 필드 사이에 공백을 보내서는 안 됩니다. 시작 줄과 첫 번째 헤더 필드 사이에 공백을 수신하는 수신자는 메시지를 유효하지 않은 것으로 거부하거나 추가 처리 없이 공백 앞에 오는 각 줄을 사용해야 합니다\(즉, 공백이 앞에 오는 모든 후속 줄과 함께 전체 줄을 무시해야 합니다\). , 적절하게 구성된 헤더 필드가 수신되거나 헤더 섹션이 종료될 때까지\).\(MUST NOT, MUST\)

요청에 이러한 공백이 있으면 서버를 속여 해당 필드를 무시하거나 그 뒤의 행을 새 요청으로 처리하려는 시도일 수 있습니다. 요청 체인 내의 다른 구현이 동일하게 해석하면 보안 취약점이 발생할 수 있습니다. 메시지를 다르게 보내세요. 마찬가지로, 응답에 공백이 있으면 일부 클라이언트는 이를 무시하거나 다른 클라이언트는 구문 분석을 중단할 수 있습니다.

---
### **3.1.  Start Line**

HTTP 메시지는 클라이언트에서 서버로의 요청일 수도 있고 서버에서 클라이언트로의 응답일 수도 있습니다. 구문론적으로 두 가지 유형의 메시지는 요청 라인\(요청의 경우\) 또는 상태 라인\(응답의 경우\)인 시작 라인과 메시지 본문의 길이를 결정하는 알고리즘\(섹션\)에서만 다릅니다. 3.3\).

이론적으로 클라이언트는 요청을 수신하고 서버는 응답을 수신하여 서로 다른 시작줄 형식으로 구별할 수 있지만 실제로는 서버가 요청만 예상하도록 구현됩니다\(응답은 알 수 없거나 유효하지 않은 요청 방법으로 해석됨\). \) 및 클라이언트는 응답만 기대하도록 구현됩니다.

```text
     start-line     = request-line / status-line
```

---
#### **3.1.1.  Request Line**

요청 라인은 메소드 토큰으로 시작하고 이어서 단일 공백\(SP\), 요청 대상, 또 다른 단일 공백\(SP\), 프로토콜 버전이 이어지고 CRLF로 끝납니다.

```text
     request-line   = method SP request-target SP HTTP-version CRLF
```

메소드 토큰은 대상 자원에서 수행될 요청 메소드를 나타냅니다. 요청 방법은 대소문자를 구분합니다.

```text
     method         = token
```

이 사양에 의해 정의된 요청 메서드는 HTTP 메서드 레지스트리에 관한 정보 및 새 메서드 정의에 대한 고려 사항과 함께 \[RFC7231\]의 섹션 4에서 찾을 수 있습니다.

request-target은 섹션 5.3에 정의된 대로 요청을 적용할 대상 리소스를 식별합니다.

수신자는 일반적으로 공백을 분할하여 요청 라인을 해당 구성 요소 부분으로 구문 분석합니다\(섹션 3.5 참조\). 세 구성 요소에는 공백이 허용되지 않기 때문입니다. 불행하게도 일부 사용자 에이전트는 하이퍼텍스트 참조에서 발견된 공백을 적절하게 인코딩하거나 제외하지 못하여 허용되지 않는 문자가 요청 대상으로 전송되는 결과를 낳습니다.

유효하지 않은 요청 라인의 수신자는 400\(잘못된 요청\) 오류 또는 301\(영구적으로 이동됨\) 리디렉션으로 응답해야 하며 요청 대상이 올바르게 인코딩되어야 합니다. 수신자는 자동 수정을 시도한 다음 리디렉션 없이 요청을 처리해서는 안 됩니다. 잘못된 요청 라인이 요청 체인을 따라 보안 필터를 우회하도록 의도적으로 제작될 수 있기 때문입니다.\(SHOULD, SHOULD NOT\)

HTTP는 섹션 2.5에 설명된 대로 요청 라인 길이에 미리 정의된 제한을 두지 않습니다. 구현하는 것보다 긴 메소드를 수신하는 서버는 501\(구현되지 않음\) 상태 코드로 응답해야 합니다. 을 수신하는 서버\(SHOULD\)

구문 분석하려는 URI보다 긴 request-target은 414\(URI가 너무 김\) 상태 코드로 응답해야 합니다\(\[RFC7231\]의 섹션 6.5.12 참조\).\(MUST\)

실제로 요청 라인 길이에 대한 다양한 임시 제한이 있습니다. 모든 HTTP 발신자와 수신자는 최소 8000옥텟의 요청 라인 길이를 지원하는 것이 좋습니다.\(SHOULD\)

---
#### **3.1.2.  Status Line**

응답 메시지의 첫 번째 줄은 프로토콜 버전, 공백\(SP\), 상태 코드, 다른 공백, 상태 코드를 설명하는 빈 텍스트 문구로 구성되고 CRLF로 끝나는 상태 줄입니다.

```text
     status-line = HTTP-version SP status-code SP reason-phrase CRLF
```

상태 코드 요소는 클라이언트의 해당 요청을 이해하고 만족시키려는 서버의 시도 결과를 설명하는 3자리 정수 코드입니다. 응답 메시지의 나머지 부분은 해당 상태 코드에 정의된 의미에 따라 해석됩니다. 상태 코드 클래스\(첫 번째 숫자로 표시됨\), 이 사양에서 정의한 상태 코드, 새 상태 코드 정의에 대한 고려 사항 및 IANA를 포함하여 상태 코드의 의미에 대한 정보는 \[RFC7231\]의 섹션 6을 참조하세요. 기재.

```text
     status-code    = 3DIGIT
```

이유 문구 요소는 숫자 상태 코드와 관련된 텍스트 설명을 제공하기 위한 목적으로만 존재하며, 대부분 대화형 텍스트 클라이언트에서 더 자주 사용되었던 이전 인터넷 응용 프로그램 프로토콜을 따릅니다. 클라이언트는 이유 문구 내용을 무시해야 합니다\(SHOULD\).\(SHOULD\)

```text
     reason-phrase  = *( HTAB / SP / VCHAR / obs-text )
```

---
### **3.2.  Header Fields**

각 헤더 필드는 대소문자를 구분하지 않는 필드 이름과 콜론\(":"\), 선택적 선행 공백, 필드 값 및 선택적 후행 공백으로 구성됩니다.

```text
     header-field   = field-name ":" OWS field-value OWS

     field-name     = token
     field-value    = *( field-content / obs-fold )
     field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     field-vchar    = VCHAR / obs-text

     obs-fold       = CRLF 1*( SP / HTAB )
                    ; obsolete line folding
                    ; see Section 3.2.4
```

필드 이름 토큰은 해당 필드 값에 해당 헤더 필드에 의해 정의된 의미를 갖는 것으로 레이블을 지정합니다. 예를 들어 Date 헤더 필드는 \[RFC7231\]의 섹션 7.1.1.2에 그것이 나타나는 메시지의 발신 타임스탬프를 포함하는 것으로 정의되어 있습니다.

---
#### **3.2.1.  Field Extensibility**

헤더 필드는 완전히 확장 가능합니다. 각각 새로운 의미를 정의하는 새 필드 이름의 도입이나 주어진 메시지에 사용되는 헤더 필드의 수에 제한이 없습니다. 기존 필드는 이 사양의 각 부분과 이 문서 세트 외부의 다른 많은 사양에 정의되어 있습니다.

새로운 헤더 필드는 수신자가 이해할 때 이전에 정의된 헤더 필드의 해석을 재정의하거나 향상시키거나, 요청 평가에 대한 전제 조건을 정의하거나, 응답의 의미를 구체화하도록 정의할 수 있습니다.

field-name이 연결 헤더 필드\(섹션 6.1\)에 나열되어 있지 않거나 프록시가 그러한 필드를 차단하거나 변환하도록 특별히 구성되지 않은 한 프록시는 인식되지 않는 헤더 필드를 전달해야 합니다\(MUST\). 다른 수신자는 인식되지 않는 헤더 필드를 무시해야 합니다\(SHOULD\). 이러한 요구 사항을 통해 배포된 중개자를 사전 업데이트하지 않고도 HTTP 기능을 향상할 수 있습니다.\(MUST, SHOULD\)

정의된 모든 헤더 필드는 \[RFC7231\]의 섹션 8.3에 설명된 대로 "메시지 헤더" 레지스트리의 IANA에 등록되어야 합니다.

---
#### **3.2.2.  Field Order**

필드 이름이 다른 헤더 필드가 수신되는 순서는 중요하지 않습니다. 그러나 요청 시 호스트, 응답 시 날짜 등 제어 데이터가 포함된 헤더 필드를 먼저 보내는 것이 좋습니다. 그러면 구현에서 메시지를 최대한 빨리 처리하지 않을 시기를 결정할 수 있습니다. 서버는 전체 요청이 완료될 때까지 대상 리소스에 요청을 적용해서는 안 됩니다.\(MUST NOT\)

이후 헤더 필드에는 조건부, 인증 자격 증명 또는 요청 처리에 영향을 줄 수 있는 의도적으로 잘못된 중복 헤더 필드가 포함될 수 있으므로 헤더 섹션이 수신됩니다.

발신자는 해당 헤더 필드의 전체 필드 값이 쉼표로 구분된 목록\[즉, #\(값\)\]으로 정의되거나 헤더 필드가 잘 정의되지 않는 한 메시지에서 동일한 필드 이름을 가진 여러 헤더 필드를 생성해서는 안 됩니다. 알려진 예외\(아래 설명 참조\)\(MUST NOT\)

수신자는 동일한 필드 이름을 가진 여러 헤더 필드를 하나의 "필드-이름: 필드-값" 쌍으로 결합할 수 있습니다. 이는 메시지의 의미를 변경하지 않고 각 후속 필드 값을 결합된 필드 값에 순서대로 추가하고 반점. 따라서 동일한 필드 이름을 가진 헤더 필드가 수신되는 순서는 결합된 필드 값의 해석에 중요합니다. 프록시는 메시지를 전달할 때 이러한 필드 값의 순서를 변경해서는 안 됩니다.\(MAY, MUST NOT\)

- 참고: 실제로 "Set-Cookie" 헤더 필드\(\[RFC6265\]\)는 응답 메시지에 여러 번 나타나는 경우가 많으며 목록 구문을 사용하지 않으므로 동일한 이름을 가진 여러 헤더 필드에 대해 위의 요구 사항을 위반합니다. 단일 필드 값으로 결합될 수 없으므로 수신자는 헤더 필드를 처리하는 동안 "Set-Cookie"를 특별한 경우로 처리해야 합니다. \(자세한 내용은 \[Kri2001\]의 부록 A.2.3을 참조한다.\)

---
#### **3.2.3.  Whitespace**

이 사양에서는 선형 공백의 사용을 나타내기 위해 OWS\(선택적 공백\), RWS\(필수 공백\) 및 BWS\("잘못된" 공백\)의 세 가지 규칙을 사용합니다.

OWS 규칙은 0개 이상의 선형 공백 옥텟이 나타날 수 있는 경우에 사용됩니다. 가독성을 높이기 위해 선택적 공백을 선호하는 프로토콜 요소의 경우 발신자는 선택적 공백을 단일 SP로 생성해야 합니다. 그렇지 않으면 발신자는 내부 메시지 필터링 중에 유효하지 않거나 원치 않는 프로토콜 요소를 제거하는 데 필요한 경우를 제외하고 선택적 공백을 생성해서는 안 됩니다.\(SHOULD NOT\)

RWS 규칙은 필드 토큰을 구분하기 위해 하나 이상의 선형 공백 옥텟이 필요할 때 사용됩니다. 발신자는 RWS를 단일 SP로 생성해야 합니다.\(SHOULD\)

BWS 규칙은 문법이 역사적인 이유로 선택적 공백을 허용하는 경우에만 사용됩니다. 발신자는 메시지에서 BWS를 생성해서는 안 됩니다. 수신자는 프로토콜 요소를 해석하기 전에 잘못된 공백을 구문 분석하고 제거해야 합니다.\(MUST NOT, MUST\)

```text
     OWS            = *( SP / HTAB )
                    ; optional whitespace
     RWS            = 1*( SP / HTAB )
                    ; required whitespace
     BWS            = OWS
                    ; "bad" whitespace
```

---
#### **3.2.4.  Field Parsing**

메시지는 개별 헤더 필드 이름과 관계없이 일반 알고리즘을 사용하여 구문 분석됩니다. 지정된 필드 값 내의 콘텐츠는 메시지 해석의 나중 단계\(일반적으로 메시지의 전체 헤더 섹션이 처리된 후\)까지 구문 분석되지 않습니다. 결과적으로 이 사양은 이전 버전에서 수행된 것처럼 각 "필드 이름: 필드 값" 쌍을 정의하기 위해 ABNF 규칙을 사용하지 않습니다. 대신, 이 사양은 등록된 각 필드 이름에 따라 이름이 지정된 ABNF 규칙을 사용합니다. 여기서 규칙은 해당 필드의 해당 필드 값에 대한 유효한 문법을 ​​정의합니다\(즉, 필드 값이 일반 필드 파서에 의해 헤더 섹션에서 추출된 후\). \).

헤더 필드 이름과 콜론 사이에는 공백이 허용되지 않습니다. 과거에는 이러한 공백 처리의 차이로 인해 요청 라우팅 및 응답 처리의 보안 취약점이 발생했습니다. 서버는 응답 코드 400\(잘못된 요청\)과 함께 헤더 필드 이름과 콜론 사이에 공백이 포함된 수신된 요청 메시지를 거부해야 합니다. 프록시는 메시지를 다운스트림으로 전달하기 전에 응답 메시지에서 이러한 공백을 제거해야 합니다.\(MUST, MUST\)

필드 값 앞 및/또는 뒤에 선택적 공백\(OWS\)이 올 수 있습니다. 사람이 일관적으로 가독성을 유지하려면 필드 값 앞에 단일 SP를 사용하는 것이 좋습니다. 필드 값에는 선행 또는 후행 공백이 포함되지 않습니다. 필드 값의 공백이 아닌 첫 번째 옥텟 이전 또는 필드 값의 공백이 아닌 마지막 옥텟 이후에 발생하는 OWS는 필드 값을 추출할 때 파서에서 제외되어야 합니다. 헤더 필드.

역사적으로 HTTP 헤더 필드 값은 각 추가 줄 앞에 최소한 하나의 공백이나 가로 탭\(obs-fold\)을 추가하여 여러 줄로 확장할 수 있었습니다. 이 사양은 message/http 미디어 유형\(섹션 8.3.1\) 내를 제외하고 이러한 줄 접기를 더 이상 사용하지 않습니다. 발신자는 메시지가 message/http 미디어 유형 내에서 패키징되도록 의도되지 않은 한 줄 접기를 포함하는 메시지\(즉, obs-fold 규칙과 일치하는 필드 값이 있는 메시지\)를 생성해서는 안 됩니다.\(MUST NOT\)

메시지/http 컨테이너 내에 없는 요청 메시지에서 obs-fold를 수신하는 서버는 반드시 400\(잘못된 요청\)을 전송하여 메시지를 거부해야 하며, 바람직하게는 더 이상 사용되지 않는 줄 접기가 허용되지 않음을 설명하는 표현을 포함하거나 각 항목을 교체해야 합니다. 필드 값을 해석하거나 메시지 다운스트림을 전달하기 전에 하나 이상의 SP 옥텟으로 obs-fold를 수신했습니다.\(MUST\)

메시지/http 컨테이너 내에 없는 응답 메시지에서 obs-fold를 수신하는 프록시 또는 게이트웨이는 메시지를 삭제하고 이를 502\(잘못된 게이트웨이\) 응답으로 대체해야 합니다. 바람직하게는 허용되지 않는 줄 접기가 발생했음을 설명하는 표현으로 대체해야 합니다. 또는 필드 값을 해석하거나 메시지 다운스트림을 전달하기 전에 수신된 각 obs-fold를 하나 이상의 SP 옥텟으로 대체합니다.\(MUST\)

메시지/http 컨테이너 내에 있지 않은 응답 메시지에서 obs-fold를 수신하는 사용자 에이전트는 필드 값을 해석하기 전에 수신된 각 obs-fold를 하나 이상의 SP 옥텟으로 대체해야 합니다.\(MUST\)

역사적으로 HTTP는 ISO-8859-1 문자 집합 \[ISO-8859-1\]의 텍스트가 포함된 필드 콘텐츠를 허용했으며 \[RFC2047\] 인코딩을 통해서만 다른 문자 집합을 지원했습니다. 실제로 대부분의 HTTP 헤더 필드 값은 US-ASCII 문자 집합 \[USASCII\]의 하위 집합만 사용합니다. 새로 정의된 헤더 필드는 해당 필드 값을 US-ASCII 옥텟으로 제한해야 합니다\(SHOULD\). 수신자는 필드 콘텐츠\(obs-text\)의 다른 옥텟을 불투명 데이터로 처리해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

---
#### **3.2.5.  Field Limits**

HTTP는 섹션 2.5에 설명된 대로 각 헤더 필드의 길이 또는 헤더 섹션 전체의 길이에 미리 정의된 제한을 두지 않습니다. 개별 헤더 필드 길이에 대한 다양한 임시 제한은 실제로 특정 필드 의미에 따라 발견됩니다.

처리하려는 것보다 더 큰 요청 헤더 필드 또는 필드 세트를 수신하는 서버는 적절한 4xx\(클라이언트 오류\) 상태 코드로 응답해야 합니다. 이러한 헤더 필드를 무시하면 밀수 공격을 요청하는 서버의 취약성이 증가합니다\(섹션 9.5\).\(MUST\)

필드 의미가 메시지 프레임이나 응답 의미를 변경하지 않고 삭제된 값을 안전하게 무시할 수 있는 경우 클라이언트는 클라이언트가 처리하기를 원하는 것보다 큰 수신 헤더 필드를 삭제하거나 잘라낼 수 있습니다.\(MAY\)

---
#### **3.2.6.  Field Value Components**

대부분의 HTTP 헤더 필드 값은 공백이나 특정 구분 문자로 구분된 일반 구문 구성 요소\(토큰, 인용 문자열 및 주석\)를 사용하여 정의됩니다. 구분 기호는 토큰에 허용되지 않는 US-ASCII 시각적 문자 집합\(DQUOTE 및 "\(\),/:;<=\>?@\[\]{}"\)에서 선택됩니다.

```text
     token          = 1*tchar

     tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
                    / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
                    / DIGIT / ALPHA
                    ; any VCHAR, except delimiters
```

텍스트 문자열이 큰따옴표를 사용하여 인용된 경우 단일 값으로 구문 분석됩니다.

```text
     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
     qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
     obs-text       = %x80-FF
```

주석 텍스트를 괄호로 묶어 일부 HTTP 헤더 필드에 주석을 포함할 수 있습니다. 설명은 필드 값 정의의 일부로 "설명"을 포함하는 필드에서만 허용됩니다.

```text
     comment        = "(" *( ctext / quoted-pair / comment ) ")"
     ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
```

백슬래시 옥텟\("\"\)은 인용 문자열 및 주석 구성 내에서 단일 옥텟 인용 메커니즘으로 사용될 수 있습니다. 인용 문자열의 값을 처리하는 수신자는 마치 백슬래시 뒤의 옥텟으로 대체된 것처럼 인용 쌍을 처리해야 합니다.\(MUST\)

```text
     quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )
```

발신자는 해당 문자열 내에서 발생하는 DQUOTE 및 백슬래시 옥텟을 인용하는 데 필요한 경우를 제외하고는 인용 문자열에서 인용 쌍을 생성해서는 안 됩니다. 발신자는 괄호\["\(" 및 "\)"\]와 해당 주석 내에서 발생하는 백슬래시 옥텟을 인용하는 데 필요한 경우를 제외하고 주석에서 인용 쌍을 생성해서는 안 됩니다.\(SHOULD NOT, SHOULD NOT\)

---
### **3.3.  Message Body**

HTTP 메시지의 메시지 본문\(있는 경우\)은 해당 요청 또는 응답의 페이로드 본문을 전달하는 데 사용됩니다. 섹션 3.3.1에 설명된 대로 전송 코딩이 적용되지 않은 경우 메시지 본문은 페이로드 본문과 동일합니다.

```text
     message-body = *OCTET
```

메시지에서 메시지 본문이 허용되는 경우에 대한 규칙은 요청과 응답에 따라 다릅니다.

요청에 메시지 본문이 있으면 Content-Length 또는 Transfer-Encoding 헤더 필드를 통해 알립니다. 요청 메시지 프레이밍은 메서드가 메시지 본문에 대한 용도를 정의하지 않은 경우에도 메서드 의미 체계와 무관합니다.

응답에 메시지 본문이 있는지 여부는 응답하는 요청 메서드와 응답 상태 코드\(섹션 3.1.2\)에 따라 달라집니다. HEAD 요청 메서드\(\[RFC7231\]의 섹션 4.3.2\)에 대한 응답에는 관련 응답 헤더 필드\(예: Transfer-Encoding, Content-Length 등\)가 있는 경우 해당 값만 나타내기 때문에 메시지 본문이 포함되지 않습니다. 요청 메서드가 GET\(\[RFC7231\]의 섹션 4.3.1\)이었다면 그랬을 것입니다. CONNECT 요청 메서드\(\[RFC7231\]의 섹션 4.3.6\)에 대한 2xx\(성공\) 응답은 메시지 본문을 갖는 대신 터널 모드로 전환됩니다. 모든 1xx\(정보\), 204\(콘텐츠 없음\) 및 304\(수정되지 않음\) 응답에는 메시지 본문이 포함되지 않습니다. 다른 모든 응답에는 메시지 본문이 포함되지만 본문의 길이는 0일 수 있습니다.

---
#### **3.3.1.  Transfer-Encoding**

Transfer-Encoding 헤더 필드에는 메시지 본문을 형성하기 위해 페이로드 본문에 적용된\(또는 적용될\) 전송 코딩 시퀀스에 해당하는 전송 코딩 이름이 나열됩니다. 전송 코딩은 섹션 4에 정의되어 있습니다.

```text
     Transfer-Encoding = 1#transfer-coding
```

Transfer-Encoding은 7비트 전송 서비스\(\[RFC2045\], 섹션 6\)를 통해 바이너리 데이터를 안전하게 전송할 수 있도록 설계된 MIME의 Content-Transfer-Encoding 필드와 유사합니다. 그러나 안전한 전송은 8비트 클린 전송 프로토콜의 초점이 다릅니다. HTTP의 경우 Transfer-Encoding은 주로 동적으로 생성된 페이로드를 정확하게 구분하고 전송 효율성이나 보안을 위해서만 적용되는 페이로드 인코딩을 선택한 리소스의 특성인 페이로드 인코딩과 구별하기 위한 것입니다.

수신자는 페이로드 본문 크기를 미리 알 수 없는 경우 메시지 프레이밍에 중요한 역할을 하기 때문에 청크 분할 전송 코딩\(섹션 4.1\)을 구문 분석할 수 있어야 합니다. 발신자는 메시지 본문에 청크를 두 번 이상 적용해서는 안 됩니다\(즉, 이미 청크된 메시지를 청크하는 것은 허용되지 않습니다\). 요청 페이로드 본문에 청크 분할 이외의 전송 코딩이 적용되는 경우 보낸 사람은 메시지가 올바르게 구성되었는지 확인하기 위해 최종 전송 코딩으로 청크 분할을 적용해야 합니다. 청크 이외의 전송 코딩이 응답 페이로드 본문에 적용되는 경우 발신자는 청크를 최종 전송 코딩으로 적용하거나 연결을 닫아 메시지를 종료해야 합니다.\(MUST, MUST NOT, MUST, MUST\)

예를 들어,

```text
     Transfer-Encoding: gzip, chunked
```

페이로드 본문이 gzip 코딩을 사용하여 압축된 후 청크 코딩을 사용하여 메시지 본문을 구성함을 나타냅니다.

Content-Encoding\(\[RFC7231\]의 섹션 3.1.2.1\)과 달리 Transfer-Encoding은 표현이 아닌 메시지의 속성이며 요청/응답 체인을 따르는 모든 수신자는 수신된 전송 코딩을 디코딩하거나 적용할 수 있습니다. Transfer-Encoding 필드 값에 해당 변경 사항이 적용된다고 가정하여 메시지 본문에 추가 전송 코딩을 추가합니다. 인코딩 매개변수에 대한 추가 정보는 이 사양에 정의되지 않은 다른 헤더 필드에서 제공될 수 있습니다.\(MAY\)

Transfer-Encoding은 HEAD 요청에 대한 응답이나 GET 요청에 대한 304\(수정되지 않음\) 응답\(\[RFC7232\]의 섹션 4.1\)으로 전송될 수 있으며 둘 다 메시지 본문을 포함하지 않아 원서버가 요청이 무조건 GET인 경우 메시지 본문에 전송 코딩을 적용했습니다. 그러나 응답 체인\(원본 서버 포함\)의 모든 수신자는 필요하지 않은 경우 전송 코딩을 제거할 수 있으므로 이 표시는 필요하지 않습니다.\(MAY\)

서버는 상태 코드가 1xx\(정보\) 또는 204\(콘텐츠 없음\)인 응답으로 Transfer-Encoding 헤더 필드를 전송해서는 안 됩니다. 서버는 CONNECT 요청에 대한 2xx\(성공\) 응답에서 Transfer-Encoding 헤더 필드를 전송해서는 안 됩니다\(\[RFC7231\]의 섹션 4.3.6\).\(MUST NOT, MUST NOT\)

전송 인코딩이 HTTP/1.1에 추가되었습니다. 일반적으로 HTTP/1.0 지원만을 광고하는 구현은 전송 인코딩된 페이로드를 처리하는 방법을 이해하지 못할 것이라고 가정합니다. 클라이언트는 전송 인코딩이 포함된 요청을 보내면 안 됩니다.\(MUST NOT\)

서버는 HTTP/1.1\(또는 그 이상\) 요청을 처리합니다. 그러한 지식은 특정 사용자 구성의 형태이거나 이전에 수신된 응답의 버전을 기억함으로써 얻을 수 있습니다. 해당 요청이 HTTP/1.1\(또는 그 이상\)을 나타내지 않는 한 서버는 Transfer-Encoding이 포함된 응답을 보내면 안 됩니다.\(MUST NOT\)

이해하지 못하는 전송 코딩이 포함된 요청 메시지를 수신한 서버는 501\(구현되지 않음\)로 응답해야 합니다.\(SHOULD\)

---
#### **3.3.2.  Content-Length**

메시지에 Transfer-Encoding 헤더 필드가 없는 경우 Content-Length 헤더 필드는 잠재적인 페이로드 본문에 대해 예상 크기를 십진수 옥텟으로 제공할 수 있습니다. 페이로드 본문이 포함된 메시지의 경우 Content-Length 필드 값은 본문\(및 메시지\)이 끝나는 위치를 결정하는 데 필요한 프레이밍 정보를 제공합니다. 페이로드 본문을 포함하지 않는 메시지의 경우 Content-Length는 선택한 표현의 크기를 나타냅니다\(\[RFC7231\]의 섹션 3\).

```text
     Content-Length = 1*DIGIT
```

예는 다음과 같습니다

```text
     Content-Length: 3495
```

발신자는 Transfer-Encoding 헤더 필드가 포함된 메시지에 Content-Length 헤더 필드를 보내면 안 됩니다.\(MUST NOT\)

사용자 에이전트는 전송 인코딩이 전송되지 않고 요청 메소드가 동봉된 페이로드 본문에 대한 의미를 정의하는 경우 요청 메시지에 Content-Length를 전송해야 합니다. 예를 들어, Content-Length 헤더 필드는 일반적으로 값이 0\(빈 페이로드 본문을 나타냄\)인 경우에도 POST 요청으로 전송됩니다. 사용자 에이전트는 요청 메시지에 페이로드 본문이 포함되어 있지 않고 메서드 의미론이 그러한 본문을 예상하지 않는 경우 Content-Length 헤더 필드를 전송해서는 안 됩니다.\(SHOULD, SHOULD NOT\)

서버는 HEAD 요청에 대한 응답으로 Content-Length 헤더 필드를 보낼 수 있습니다\(\[RFC7231\]의 섹션 4.3.2\). 서버는 해당 필드 값이 동일한 요청이 GET 메서드를 사용한 경우 응답의 페이로드 본문에 전송되었을 옥텟의 십진수와 동일하지 않는 한 그러한 응답에서 Content-Length를 전송해서는 안 됩니다.\(MUST NOT\)

서버는 조건부 GET 요청\(\[RFC7232\]의 섹션 4.1\)에 대한 304\(수정되지 않음\) 응답으로 Content-Length 헤더 필드를 보낼 수 있습니다. 서버는 그러한 응답으로 Content-Length를 보내면 안 됩니다.\(MUST NOT\)

필드 값이 동일한 요청에 대한 200\(OK\) 응답의 페이로드 본문으로 전송된 옥텟의 10진수와 동일하지 않은 경우.

서버는 상태 코드가 1xx\(정보\) 또는 204\(콘텐츠 없음\)인 응답으로 Content-Length 헤더 필드를 전송해서는 안 됩니다. 서버는 CONNECT 요청에 대한 2xx\(성공\) 응답에서 Content-Length 헤더 필드를 전송해서는 안 됩니다\(\[RFC7231\]의 섹션 4.3.6\).\(MUST NOT, MUST NOT\)

위에 정의된 경우를 제외하고 Transfer-Encoding이 없는 경우 원서버는 전체 헤더 섹션을 전송하기 전에 페이로드 본문 크기가 알려진 경우 Content-Length 헤더 필드를 전송해야 합니다. 이를 통해 다운스트림 수신자는 전송 진행 상황을 측정하고, 수신된 메시지가 완료된 시기를 알 수 있으며, 잠재적으로 추가 요청에 대한 연결을 재사용할 수 있습니다.\(SHOULD\)

0보다 크거나 같은 모든 Content-Length 필드 값이 유효합니다. 페이로드 길이에 미리 정의된 제한이 없기 때문에 수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야 합니다\(섹션 9.3\).\(MUST\)

동일한 십진수 값으로 구성된 필드 값이 있는 여러 Content-Length 헤더 필드가 있거나 동일한 십진수 값 목록이 포함된 필드 값이 있는 단일 Content-Length 헤더 필드가 있는 메시지가 수신된 경우\(예: "Content-Length" : 42, 42"\), 중복 Content-Length 헤더 필드가 업스트림 메시지 프로세서에 의해 생성되거나 결합되었음을 나타내는 경우 수신자는 메시지를 유효하지 않은 것으로 거부하거나 중복된 필드 값을 하나의 유효한 Content-Length로 대체해야 합니다. 메시지 본문 길이를 결정하거나 메시지를 전달하기 전에 해당 십진수 값을 포함하는 필드입니다.\(MUST\)

- 참고: 메시지 프레이밍을 위한 HTTP의 Content-Length 사용은 "message/external-body" 미디어 유형 내에서만 사용되는 선택적 필드인 MIME의 동일한 필드 사용과 크게 다릅니다.

---
#### **3.3.3.  Message Body Length**

메시지 본문의 길이는 다음 중 하나에 따라 결정됩니다\(우선순위에 따라\).

1. HEAD 요청에 대한 모든 응답과 1xx\(정보\), 204\(콘텐츠 없음\) 또는 304\(수정되지 않음\) 상태 코드가 있는 응답은 헤더 필드에 관계없이 항상 헤더 필드 뒤의 첫 번째 빈 줄로 종료됩니다. 메시지에 존재하므로 메시지 본문을 포함할 수 없습니다.

2. CONNECT 요청에 대한 2xx\(성공\) 응답은 헤더 필드를 마무리하는 빈 줄 바로 뒤에 연결이 터널이 된다는 것을 의미합니다. 클라이언트는 그러한 메시지에서 수신된 모든 Content-Length 또는 Transfer-Encoding 헤더 필드를 무시해야 합니다.\(MUST\)

3. Transfer-Encoding 헤더 필드가 있고 청크 전송 코딩\(섹션 4.1\)이 최종 인코딩인 경우 전송 코딩이 데이터가 완료되었음을 나타낼 때까지 청크 데이터를 읽고 디코딩하여 메시지 본문 길이가 결정됩니다.

- 응답에 Transfer-Encoding 헤더 필드가 있고 청크 전송 코딩이 최종 인코딩이 아닌 경우 메시지 본문 길이는 서버에서 연결을 닫을 때까지 연결을 읽어 결정됩니다. 요청에 Transfer-Encoding 헤더 필드가 있고 청크 전송 코딩이 최종 인코딩이 아닌 경우 메시지 본문 길이를 안정적으로 결정할 수 없습니다. 서버는 400\(잘못된 요청\) 상태 코드로 응답한 다음 연결을 닫아야 합니다.\(MUST\)

- Transfer-Encoding 및 Content-Length 헤더 필드가 모두 포함된 메시지가 수신되면 Transfer-Encoding이 Content-Length를 재정의합니다. 이러한 메시지는 요청 밀수\(섹션 9.5\) 또는 응답 분할\(섹션 9.4\)을 수행하려는 시도를 나타낼 수 있으며 오류로 처리되어야 합니다. 발신자는 그러한 메시지를 다운스트림으로 전달하기 전에 수신된 Content-Length 필드를 제거해야 합니다.\(MUST\)

4. 전송 인코딩 없이 메시지가 수신되고 서로 다른 필드 값을 갖는 여러 Content-Length 헤더 필드 또는 잘못된 값을 갖는 단일 Content-Length 헤더 필드가 있는 경우 메시지 프레이밍이 유효하지 않으며 수신자는 이를 처리해야 합니다. 복구할 수 없는 오류로 표시됩니다. 이것이 요청 메시지인 경우 서버는 400\(잘못된 요청\) 상태 코드로 응답한 다음 연결을 닫아야 합니다. 이것이 프록시에 의해 수신된 응답 메시지인 경우 프록시는 서버에 대한 연결을 닫고 수신된 응답을 폐기한 다음 502\(Bad\)를 보내야 합니다.\(MUST, MUST, MUST\)

- 게이트웨이\) 클라이언트에 대한 응답입니다. 이것이 사용자 에이전트에 의해 수신된 응답 메시지인 경우, 사용자 에이전트는 서버에 대한 연결을 닫고 수신된 응답을 폐기해야 합니다.\(MUST\)

5. 유효한 Content-Length 헤더 필드가 Transfer-Encoding 없이 존재하는 경우 해당 필드의 10진수 값은 예상되는 메시지 본문 길이\(옥텟\)를 정의합니다. 보낸 사람이 연결을 닫거나 표시된 옥텟 수를 수신하기 전에 받는 사람이 시간 초과되면 받는 사람은 메시지가 불완전한 것으로 간주하고 연결을 닫아야 합니다.\(MUST\)

6. 이것이 요청 메시지이고 위 사항 중 어느 것도 사실이 아닌 경우 메시지 본문 길이는 0입니다\(메시지 본문이 없음\).

7. 그렇지 않은 경우 선언된 메시지 본문 길이가 없는 응답 메시지이므로 메시지 본문 길이는 서버가 연결을 닫기 전에 수신한 옥텟 수에 따라 결정됩니다.

성공적으로 완료되고 가깝게 구분된 메시지와 네트워크 오류로 인해 중단된 부분적으로 수신된 메시지를 구별할 수 있는 방법이 없기 때문에 서버는 가능할 때마다 인코딩 또는 길이로 구분된 메시지를 생성해야 합니다. 닫기 구분 기능은 주로 HTTP/1.0과의 이전 버전과의 호환성을 위해 존재합니다.\(SHOULD\)

서버는 411\(길이 필요\)로 응답하여 메시지 본문은 포함하지만 Content-Length는 포함하지 않는 요청을 거부할 수 있습니다.\(MAY\)

청크 분할 이외의 전송 코딩이 적용되지 않는 한, 메시지 본문이 포함된 요청을 보내는 클라이언트는 메시지 본문 길이가 미리 알려진 경우 청크 분할 전송 코딩 대신 유효한 Content-Length 헤더 필드를 사용해야 합니다. 서비스는 청크 전송 코딩을 이해하더라도 411\(길이 필요\) 상태 코드로 청크에 응답합니다. 이는 일반적으로 이러한 서비스가 호출되기 전에 콘텐츠 길이를 요구하는 게이트웨이를 통해 구현되고 서버가 처리하기 전에 전체 요청을 버퍼링할 수 없거나 버퍼링할 의사가 없기 때문입니다.\(SHOULD\)

메시지 본문이 포함된 요청을 보내는 사용자 에이전트는 서버가 HTTP/1.1\(또는 그 이상\) 요청을 처리할지 모르는 경우 유효한 Content-Length 헤더 필드를 보내야 합니다. 그러한 정보는 특정 사용자 구성의 형태로 제공되거나 이전에 수신된 응답의 버전을 기억함으로써 얻을 수 있습니다.\(MUST\)

연결의 마지막 요청에 대한 최종 응답이 완전히 수신되었고 읽을 추가 데이터가 남아 있는 경우, 사용자 에이전트는 남은 데이터를 삭제하거나 해당 데이터가 있는지 확인하려고 시도할 수 있습니다.\(MAY\)

데이터는 이전 응답 본문의 일부로 속하며, 이는 이전 메시지의 Content-Length 값이 잘못된 경우일 수 있습니다. 클라이언트는 이러한 추가 데이터를 별도의 응답으로 처리, 캐시 또는 전달해서는 안 됩니다. 이러한 동작은 캐시 중독에 취약하기 때문입니다.\(MUST NOT\)

---
### **3.4.  Handling Incomplete Messages**

일반적으로 취소된 요청이나 트리거된 시간 초과 예외로 인해 불완전한 요청 메시지를 수신한 서버는 연결을 닫기 전에 오류 응답을 보낼 수 있습니다.\(MAY\)

연결이 조기에 닫히거나 청크 전송 코딩 디코딩이 실패할 때 발생할 수 있는 불완전한 응답 메시지를 수신한 클라이언트는 메시지를 불완전한 것으로 기록해야 합니다. 불완전한 응답에 대한 캐시 요구 사항은 \[RFC7234\]의 섹션 3에 정의되어 있습니다.\(MUST\)

응답이 헤더 섹션 중간\(빈 줄이 수신되기 전\)에서 종료되고 상태 코드가 응답의 전체 의미를 전달하기 위해 헤더 필드에 의존할 수 있는 경우 클라이언트는 의미가 전달되었다고 가정할 수 없습니다. 클라이언트는 다음에 수행할 작업을 결정하기 위해 요청을 반복해야 할 수도 있습니다.

인코딩을 종료하는 크기가 0인 청크가 수신되지 않은 경우 청크 분할 전송 코딩을 사용하는 메시지 본문은 불완전합니다. 수신된 메시지 본문의 크기\(옥텟 단위\)가 Content-Length에서 지정한 값보다 작은 경우 유효한 Content-Length를 사용하는 메시지는 불완전합니다. 청크 전송 코딩이나 Content-Length가 없는 응답은 연결 종료로 종료되므로 헤더 섹션이 그대로 수신된 경우 수신된 메시지 본문 옥텟 수에 관계없이 완료된 것으로 간주됩니다.

---
### **3.5.  Message Parsing Robustness**

이전 HTTP/1.0 사용자 에이전트 구현에서는 줄 끝으로 종료되지 않은 메시지 본문 콘텐츠를 읽지 못한 일부 초기 서버 응용 프로그램에 대한 해결 방법으로 POST 요청 후에 추가 CRLF를 보낼 수 있습니다. HTTP/1.1 사용자 에이전트는 요청 앞에 추가 CRLF를 추가하거나 뒤에 붙여서는 안 됩니다. 줄 끝으로 요청 메시지 본문을 종료하려는 경우 사용자 에이전트는 종료 CRLF 옥텟을 메시지 본문 길이의 일부로 계산해야 합니다.\(MUST NOT, MUST\)

견고성을 위해 요청 라인을 수신하고 구문 분석할 것으로 예상되는 서버는 요청 라인 이전에 수신된 적어도 하나의 빈 라인\(CRLF\)을 무시해야 합니다.\(SHOULD\)

시작 줄과 헤더 필드의 줄 종결자는 시퀀스 CRLF이지만 수신자는 단일 LF를 줄 종결자로 인식하고 이전 CR을 무시할 수 있습니다.\(MAY\)

요청 라인 및 상태 라인 문법 규칙에 따라 각 구성 요소 요소가 단일 SP 옥텟으로 구분되어야 하지만 수신자는 대신 공백으로 구분된 단어 경계를 구문 분석하고 CRLF 종결자를 제외하고 모든 형태의 공백을 다음과 같이 처리할 수 있습니다. 선행 또는 후행 공백을 무시하는 동안 SP 구분 기호; 이러한 공백에는 SP, HTAB, VT\(%x0B\), FF\(%x0C\) 또는 베어 CR 중 하나 이상의 옥텟이 포함됩니다. 그러나 관대한 구문 분석은 메시지 수신자가 여러 명이고 각각 ​​견고성에 대한 고유한 해석이 있는 경우 보안 취약성을 초래할 수 있습니다\(섹션 9.5 참조\).\(MAY\)

HTTP 요청 메시지만 수신하는 서버 또는 시작줄에서 HTTP 요청 메시지로 나타나는 것을 처리하는 서버가 위에 나열된 견고성 예외를 제외하고 HTTP 메시지 문법과 일치하지 않는 일련의 옥텟을 수신하는 경우, 서버는 400\(잘못된 요청\) 응답으로 응답해야 합니다\(SHOULD\).\(SHOULD\)

---
## **4.  Transfer Codings**

전송 코딩 이름은 네트워크를 통한 "안전한 전송"을 보장하기 위해 페이로드 본문에 적용되었거나 적용될 수 있거나 적용될 필요가 있는 인코딩 변환을 나타내는 데 사용됩니다. 이는 전송 코딩이 전송되는 표현의 속성이 아니라 메시지의 속성이라는 점에서 콘텐츠 코딩과 다릅니다.

```text
     transfer-coding    = "chunked" ; Section 4.1
                        / "compress" ; Section 4.2.1
                        / "deflate" ; Section 4.2.2
                        / "gzip" ; Section 4.2.3
                        / transfer-extension
     transfer-extension = token *( OWS ";" OWS transfer-parameter )
```

매개변수는 이름 또는 이름=값 쌍의 형식입니다.

```text
     transfer-parameter = token BWS "=" BWS ( token / quoted-string )
```

모든 전송 코딩 이름은 대소문자를 구분하지 않으며 섹션 8.4에 정의된 대로 HTTP 전송 코딩 레지스트리 내에 등록되어야 합니다. 이는 TE\(섹션 4.3\) 및 Transfer-Encoding\(섹션 3.3.1\) 헤더 필드에 사용됩니다.

---
### **4.1.  Chunked Transfer Coding**

청크 분할 전송 코딩은 페이로드 본문을 일련의 청크로 전송하기 위해 각각 고유한 크기 표시기와 헤더 필드가 포함된 선택적 트레일러로 전송되도록 래핑합니다. 청크를 사용하면 크기를 알 수 없는 콘텐츠 스트림을 길이로 구분된 버퍼 시퀀스로 전송할 수 있습니다. 이를 통해 발신자는 연결 지속성을 유지하고 수신자는 전체 메시지를 수신한 시기를 알 수 있습니다.\(MAY\)

```text
     chunked-body   = *chunk
                      last-chunk
                      trailer-part
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*("0") [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets
```

청크 크기 필드는 옥텟 단위로 청크 데이터의 크기를 나타내는 16진수 문자열입니다. 청크 크기가 0인 청크가 수신되면 청크 전송 코딩이 완료되고, 그 뒤에 트레일러가 올 수 있으며 마지막으로 빈 줄로 종료됩니다.

수신자는 청크 전송 코딩을 구문 분석하고 디코딩할 수 있어야 합니다.\(MUST\)

---
#### **4.1.1.  Chunk Extensions**

청크 인코딩을 사용하면 청크당 메타데이터\(예: 서명 또는 해시\), 메시지 중간 제어 정보 또는 메시지 본문 무작위화를 제공하기 위해 각 청크가 청크 크기 바로 뒤에 0개 이상의 청크 확장을 포함할 수 있습니다. 크기.

```text
     chunk-ext      = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string
```

청크 인코딩은 각 연결마다 다르며 상위 수준 애플리케이션이 확장을 검사하기 전에 각 수신자\(중개자 포함\)가 제거하거나 다시 코딩할 가능성이 높습니다. 따라서 청크 확장의 사용은 일반적으로 제한됩니다.

"긴 폴링"\(클라이언트와 서버가 청크 확장 사용에 관해 공유 기대를 가질 수 있는 경우\) 또는 종단 간 보안 연결 내 패딩과 같은 특수 HTTP 서비스에 적용됩니다.

수신자는 인식할 수 없는 청크 확장을 무시해야 합니다. 서버는 메시지의 다른 부분에 대해 길이 제한 및 시간 초과를 적용하는 것과 동일한 방식으로 요청에서 수신된 청크 확장의 총 길이를 제공된 서비스에 대해 합리적인 양으로 제한해야 하며 적절한 4xx\(클라이언트 오류\)를 생성해야 합니다. \) 해당 금액을 초과하면 응답합니다.\(MUST\)

---
#### **4.1.2.  Chunked Trailer Part**

트레일러를 사용하면 메시지 무결성 검사, 디지털 서명 또는 사후 처리 상태와 같이 메시지 본문이 전송되는 동안 동적으로 생성될 수 있는 메타데이터를 제공하기 위해 보낸 사람이 청크 메시지 끝에 추가 필드를 포함할 수 있습니다. 트레일러 필드는 메시지의 헤더 섹션 대신 청크 분할 트레일러로 전송된다는 점을 제외하면 헤더 필드와 동일합니다.

```text
     trailer-part   = *( header-field CRLF )
```

발신자는 메시지 프레이밍\(예: 전송 인코딩 및 콘텐츠 길이\), 라우팅\(예: 호스트\), 요청 수정자\(예: \[RFC7231\] 섹션 5의 제어 및 조건\)에 필요한 필드를 포함하는 트레일러를 생성해서는 안 됩니다. , 인증\(예: \[RFC7235\] 및 \[RFC6265\] 참조\), 응답 제어 데이터\(예: \[RFC7231\]의 섹션 7.1 참조\) 또는 페이로드 처리 방법 결정\(예: Content-Encoding, Content-Type, Content- 범위 및 예고편\).\(MUST NOT\)

비어 있지 않은 트레일러가 포함된 청크 메시지를 수신하면 수신자는 마치 메시지 헤더 섹션에 추가된 것처럼 필드\(위에서 금지된 필드 제외\)를 처리할 수 있습니다. 수신자는 트레일러에서 전송이 금지된 모든 필드를 무시\(또는 오류로 간주\)해야 합니다. 헤더 섹션에 있는 것처럼 처리하면 외부 보안 필터를 우회할 수 있기 때문입니다.\(MAY, MUST\)

요청에 "트레일러"가 허용됨을 나타내는 TE 헤더 필드가 포함되어 있지 않은 한, 섹션 4.3에 설명된 대로 서버는 사용자 에이전트가 수신하는 데 필요하다고 생각되는 트레일러 필드를 생성해서는 안 됩니다. "트레일러"를 포함하는 TE가 없으면 서버는 사용자 에이전트에 대한 경로를 따라 트레일러 필드가 자동으로 삭제될 수 있다고 가정해야 합니다. 이 요구 사항을 통해 중개자는 전체 응답을 버퍼링하지 않고도 청크 해제된 메시지를 HTTP/1.0 수신자에게 전달할 수 있습니다.\(SHOULD NOT\)

---
#### **4.1.3.  Decoding Chunked**

청크 전송 코딩을 디코딩하는 프로세스는 다음과 같이 의사 코드로 표현될 수 있습니다.

```text
     length := 0
     read chunk-size, chunk-ext (if any), and CRLF
     while (chunk-size > 0) {
        read chunk-data and CRLF
        append chunk-data to decoded-body
        length := length + chunk-size
        read chunk-size, chunk-ext (if any), and CRLF
     }
     read trailer field
     while (trailer field is not empty) {
        if (trailer field is allowed to be sent in a trailer) {
            append trailer field to existing header fields
        }
        read trailer-field
     }
     Content-Length := length
     Remove "chunked" from Transfer-Encoding
     Remove Trailer from existing header fields
```

---
### **4.2.  Compression Codings**

아래에 정의된 코딩은 메시지의 페이로드를 압축하는 데 사용될 수 있습니다.

---
#### **4.2.1.  Compress Coding**

"압축" 코딩은 UNIX 파일 압축 프로그램 "compress"에 의해 일반적으로 생성되는 적응형 Lempel-Ziv-Welch\(LZW\) 코딩\[Welch\]입니다. 수신자는 "x-compress"를 "압축"과 동일하다고 간주해야 합니다.\(SHOULD\)

---
#### **4.2.2.  Deflate Coding**

"deflate" 코딩은 Lempel-Ziv\(LZ77\) 압축 알고리즘과 Huffman 코딩의 조합을 사용하는 "deflate" 압축 데이터 스트림\[RFC1951\]을 포함하는 "zlib" 데이터 형식\[RFC1950\]입니다.

- 참고: 일부 비준수 구현은 zlib 래퍼 없이 "수축" 압축 데이터를 보냅니다.

---
#### **4.2.3.  Gzip Coding**

"gzip" 코딩은 gzip 파일 압축 프로그램\[RFC1952\]에 의해 일반적으로 생성되는 32비트 CRC\(Cyclic Redundancy Check\)를 사용하는 LZ77 코딩입니다. 수신자는 "x-gzip"이 "gzip"과 동일하다고 간주해야 합니다.\(SHOULD\)

---
### **4.3.  TE**

요청의 "TE" 헤더 필드는 청크 분할 외에 클라이언트가 응답으로 수락할 의사가 있는 전송 코딩과 클라이언트가 청크 분할 전송 코딩의 트레일러 필드를 수락할 의사가 있는지 여부를 나타냅니다.

TE 필드 값은 쉼표로 구분된 전송 코딩 이름 목록으로 구성되며, 각각은 선택적 매개변수\(섹션 4에 설명된 대로\) 및/또는 키워드 "트레일러"를 허용합니다. 클라이언트는 TE로 청크된 전송 코딩 이름을 전송해서는 안 됩니다. 청크 분할은 HTTP/1.1 수신자에게 항상 허용됩니다.\(MUST NOT\)

```text
     TE        = #t-codings
     t-codings = "trailers" / ( transfer-coding [ t-ranking ] )
     t-ranking = OWS ";" OWS "q=" rank
     rank      = ( "0" [ "." 0*3DIGIT ] )
                / ( "1" [ "." 0*3("0") ] )
```

TE 사용의 세 가지 예는 다음과 같습니다.

```text
     TE: deflate
     TE:
     TE: trailers, deflate;q=0.5
```

"트레일러"라는 키워드가 있다는 것은 클라이언트가 자신과 모든 다운스트림 클라이언트를 대신하여 섹션 4.1.2에 정의된 대로 청크 분할 전송 코딩의 트레일러 필드를 기꺼이 받아들인다는 것을 나타냅니다. 중개자로부터의 요청의 경우 이는 다음 중 하나를 의미합니다. \(a\) 모든 다운스트림 클라이언트가 전달된 응답에서 트레일러 필드를 기꺼이 수락합니다. 또는 \(b\) 중개자가 다운스트림 수신자를 대신하여 응답을 버퍼링하려고 시도합니다. HTTP/1.1은 중개자가 전체 응답을 버퍼링할 수 있도록 청크된 응답의 크기를 제한하는 수단을 정의하지 않습니다.

다중 전송 코딩이 허용되는 경우 클라이언트는 대소문자를 구분하지 않는 "q" 매개변수\(콘텐츠 협상 필드에 사용되는 q값과 유사\)를 사용하여 선호도에 따라 코딩 순위를 매길 수 있습니다.\(MAY\)

\[RFC7231\]의 5.3.1\). 순위 값은 0에서 1 사이의 실수입니다. 여기서 0.001은 가장 선호되지 않고 1은 가장 선호됩니다. 값 0은 "허용되지 않음"을 의미합니다.

TE field-value가 비어 있거나 TE 필드가 없으면 허용되는 유일한 전송 코딩이 청크됩니다. 전송 코딩이 없는 메시지는 항상 허용됩니다.

TE 헤더 필드는 즉시 연결에만 적용되므로 TE의 발신자는 TE 필드가 지원하지 않는 중개자에 의해 전달되는 것을 방지하기 위해 Connection 헤더 필드\(Section 6.1\) 내에 "TE" 연결 옵션도 보내야 합니다. 그 의미론.\(MUST\)

---
### **4.4.  Trailer**

메시지에 청크 분할 전송 코딩으로 인코딩된 메시지 본문이 포함되어 있고 발신자가 메시지 끝 부분에 트레일러 필드 형식으로 메타데이터를 전송하려는 경우 발신자는 메시지 본문 앞에 트레일러 헤더 필드를 생성하여 어떤 필드를 표시해야 하는지 표시해야 합니다. 예고편에 출연하세요. 이를 통해 수신자는 본문 처리를 시작하기 전에 해당 메타데이터 수신을 준비할 수 있습니다. 이는 메시지가 스트리밍되고 수신자가 즉시 무결성 검사를 확인하려는 경우에 유용합니다.\(SHOULD\)

```text
     Trailer = 1#field-name
```

---
## **5.  Message Routing**

HTTP 요청 메시지 라우팅은 대상 리소스, 클라이언트의 프록시 구성, 인바운드 연결 설정 또는 재사용을 기반으로 각 클라이언트에 의해 결정됩니다. 해당 응답 라우팅은 동일한 연결 체인을 따라 클라이언트로 돌아갑니다.

---
### **5.1.  Identifying a Target Resource**

HTTP는 범용 컴퓨터부터 가전제품에 이르기까지 다양한 애플리케이션에서 사용됩니다. 어떤 경우에는 통신 옵션이 클라이언트 구성에 하드 코딩되어 있습니다. 그러나 대부분의 HTTP 클라이언트는 범용 웹 브라우저와 동일한 리소스 식별 메커니즘 및 구성 기술을 사용합니다.

HTTP 통신은 어떤 목적으로 사용자 에이전트에 의해 시작됩니다. 목적은 \[RFC7231\]에 정의된 요청 의미론과 해당 의미론을 적용할 대상 리소스의 조합입니다. URI 참조\(섹션 2.7\)는 일반적으로

사용자 에이전트가 "대상 URI"를 얻기 위해 절대 형식으로 확인하는 "대상 리소스"에 대한 식별자입니다. 조각 식별자는 클라이언트 측 처리를 위해 예약되어 있으므로 대상 URI는 참조의 조각 구성 요소를 제외합니다\(\[RFC3986\], 섹션 3.5\).

---
### **5.2.  Connecting Inbound**

대상 URI가 결정되면 클라이언트는 원하는 의미를 달성하기 위해 네트워크 요청이 필요한지 여부와 필요한 경우 해당 요청을 어디로 보낼지 결정해야 합니다.

클라이언트에 캐시 \[RFC7234\]가 있고 이를 통해 요청이 충족될 수 있는 경우 일반적으로 요청이 먼저 해당 캐시로 전달됩니다.

요청이 캐시에 의해 충족되지 않으면 일반 클라이언트는 해당 구성을 확인하여 요청을 충족하기 위해 프록시를 사용할지 여부를 결정합니다. 프록시 구성은 구현에 따라 다르지만 종종 URI 접두사 일치, 선택적 권한 일치 또는 둘 다를 기반으로 하며 프록시 자체는 일반적으로 "http" 또는 "https" URI로 식별됩니다. 프록시가 적용 가능한 경우 클라이언트는 해당 프록시에 대한 연결을 설정\(또는 재사용\)하여 인바운드에 연결합니다.

적용 가능한 프록시가 없으면 일반적인 클라이언트는 일반적으로 대상 URI의 체계에 특정한 처리기 루틴을 호출하여 대상 리소스에 대한 기관에 직접 연결합니다. 이것이 수행되는 방법은 대상 URI 체계에 따라 달라지며 관련 사양에 의해 정의됩니다. 이는 이 사양이 "http"\(섹션 2.7.1\) 및 "https"\(섹션 2.7.2\) 확인을 위해 원본 서버 액세스를 정의하는 방법과 유사합니다. 계획.

연결 관리에 관한 HTTP 요구 사항은 섹션 6에 정의되어 있습니다.

---
### **5.3.  Request Target**

인바운드 연결이 획득되면 클라이언트는 대상 URI에서 파생된 요청 대상과 함께 HTTP 요청 메시지\(섹션 3\)를 보냅니다. 요청되는 방법과 요청이 프록시에 대한 것인지 여부에 따라 요청 대상에 대한 네 가지 고유한 형식이 있습니다.

```text
     request-target = origin-form
                    / absolute-form
                    / authority-form
                    / asterisk-form
```

---
#### **5.3.1.  origin-form**

요청 대상의 가장 일반적인 형식은 원본 형식입니다.

```text
     origin-form    = absolute-path [ "?" query ]
```

CONNECT 또는 서버 전체 OPTIONS 요청\(아래 설명 참조\) 이외의 원본 서버에 직접 요청할 때 클라이언트는 대상 URI의 절대 경로 및 쿼리 구성 요소만 요청 대상으로 보내야 합니다. 대상 URI의 경로 구성 요소가 비어 있는 경우 클라이언트는 요청 대상의 원본 형식 내에서 경로로 "/"를 보내야 합니다. 섹션 5.4에 정의된 대로 Host 헤더 필드도 전송됩니다.\(MUST, MUST\)

예를 들어, 다음과 같이 식별된 리소스의 표현을 검색하려는 클라이언트가 있습니다.

```text
     http://www.example.org/where?q=now
```

원본 서버에서 직접 호스트 "www.example.org"의 포트 80에 대한 TCP 연결을 열고\(또는 재사용\) 다음 행을 보냅니다.

```text
     GET /where?q=now HTTP/1.1
     Host: www.example.org
```

요청 메시지의 나머지 부분이 이어집니다.

---
#### **5.3.2.  absolute-form**

CONNECT 또는 서버 전체 OPTIONS 요청\(아래 설명 참조\) 이외의 프록시에 요청할 때 클라이언트는 요청 대상으로 절대 형식의 대상 URI를 보내야 합니다.\(MUST\)

```text
     absolute-form  = absolute-URI
```

프록시는 가능한 경우 유효한 캐시에서 요청하는 서비스를 제공하거나 클라이언트를 대신하여 다음 인바운드 프록시 서버 또는 요청 대상에 표시된 원본 서버에 직접 동일한 요청을 수행하도록 요청됩니다. 이러한 메시지 "전달"에 대한 요구 사항은 섹션 5.7에 정의되어 있습니다.

요청 라인의 절대 형식의 예는 다음과 같습니다.

```text
     GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
```

HTTP의 향후 버전에서 모든 요청에 ​​대해 절대 형식으로의 전환을 허용하려면 HTTP/1.1 클라이언트가 프록시에 대한 요청으로만 요청을 보내더라도 서버는 요청에서 절대 형식을 수락해야 합니다.\(MUST\)

---
#### **5.3.3.  authority-form**

request-target의 권한 형식은 CONNECT 요청에만 사용됩니다\(\[RFC7231\]의 섹션 4.3.6\).

```text
     authority-form = authority
```

하나 이상의 프록시를 통해 터널을 설정하기 위해 CONNECT 요청을 할 때 클라이언트는 요청 대상으로 대상 URI의 권한 구성 요소\(사용자 정보 및 해당 "@" 구분 기호 제외\)만 보내야 합니다. 예를 들어,\(MUST\)

```text
     CONNECT www.example.com:80 HTTP/1.1
```

---
#### **5.3.4.  asterisk-form**

request-target의 별표 형식은 서버 전체 OPTIONS 요청\(\[RFC7231\]의 섹션 4.3.7\)에만 사용됩니다.

```text
     asterisk-form  = "*"
```

클라이언트가 해당 서버의 특정 명명된 리소스와 달리 서버 전체에 대한 OPTIONS를 요청하려는 경우 클라이언트는 요청 대상으로 "\*"\(%x2A\)만 보내야 합니다. 예를 들어,\(MUST\)

```text
     OPTIONS * HTTP/1.1
```

프록시가 URI에 빈 경로가 있고 쿼리 구성 요소가 없는 절대 형식의 요청 대상으로 OPTIONS 요청을 수신하는 경우 요청 체인의 마지막 프록시는 전달할 때 "\*"의 요청 대상을 보내야 합니다. 지정된 원본 서버에 대한 요청입니다.\(MUST\)

예를 들어, 요청

```text
     OPTIONS http://www.example.org:8001 HTTP/1.1
```

최종 프록시에 의해 다음과 같이 전달됩니다.

```text
     OPTIONS * HTTP/1.1
     Host: www.example.org:8001
```

호스트 "www.example.org"의 포트 8001에 연결한 후.

---
### **5.4.  Host**

요청의 "Host" 헤더 필드는 대상 URI의 호스트 및 포트 정보를 제공하므로 원본 서버가 단일 IP 주소에서 여러 호스트 이름에 대한 요청을 처리하는 동안 리소스를 구별할 수 있습니다.

```text
     Host = uri-host [ ":" port ] ; Section 2.7.1
```

클라이언트는 모든 HTTP/1.1 요청 메시지에 Host 헤더 필드를 보내야 합니다. 대상 URI에 권한 구성 요소가 포함된 경우 클라이언트는 userinfo 하위 구성 요소 및 해당 "@" 구분 기호\(섹션 2.7.1\)를 제외하고 해당 권한 구성 요소와 동일한 Host에 대한 필드 값을 보내야 합니다. 대상 URI에 대한 권한 구성 요소가 없거나 정의되지 않은 경우 클라이언트는 빈 필드 값이 있는 Host 헤더 필드를 보내야 합니다.\(MUST, MUST, MUST\)

Host 필드 값은 요청을 처리하는 데 중요한 정보이므로 사용자 에이전트는 요청 라인 다음의 첫 번째 헤더 필드로 Host를 생성해야 합니다.\(SHOULD\)

예를 들어 <http://www.example.org/pub/WWW/\>에 대한 원본 서버에 대한 GET 요청은 다음으로 시작됩니다.

```text
     GET /pub/WWW/ HTTP/1.1
     Host: www.example.org
```

클라이언트는 요청 대상이 절대 형식인 경우에도 HTTP/1.1 요청에서 Host 헤더 필드를 보내야 합니다. 이를 통해 Host 정보가 Host를 구현하지 않았을 수 있는 고대 HTTP/1.0 프록시를 통해 전달될 수 있기 때문입니다.\(MUST\)

프록시가 request-target의 절대 형식으로 요청을 수신하면 프록시는 수신된 Host 헤더 필드\(있는 경우\)를 무시하고 대신 이를 요청 대상의 호스트 정보로 바꿔야 합니다. 그러한 요청을 전달하는 프록시는 수신된 Host 필드 값을 전달하는 대신 수신된 요청 대상을 기반으로 새로운 Host 필드 값을 생성해야 합니다.\(MUST, MUST\)

Host 헤더 필드는 애플리케이션 수준 라우팅 메커니즘으로 작동하므로 공유 캐시를 손상시키거나 요청을 의도하지 않은 서버로 리디렉션하려는 악성 프로그램의 빈번한 대상입니다. 가로채기 프록시는 가로채는 연결이 해당 호스트의 유효한 IP 주소를 대상으로 하는지 먼저 확인하지 않고 요청을 내부 서버로 리디렉션하거나 공유 캐시에서 캐시 키로 사용하기 위해 Host 필드 값에 의존하는 경우 특히 취약합니다. .

서버는 Host 헤더 필드가 없는 모든 HTTP/1.1 요청 메시지와 둘 이상의 Host 헤더 필드 또는 유효하지 않은 필드 값이 있는 Host 헤더 필드를 포함하는 요청 메시지에 400\(잘못된 요청\) 상태 코드로 응답해야 합니다. .\(MUST\)

---
### **5.5.  Effective Request URI**

요청 대상에는 사용자 에이전트 대상 URI의 일부만 포함되는 경우가 많기 때문에 서버는 요청을 적절하게 서비스하기 위해 의도된 대상을 "유효한 요청 URI"로 재구성합니다. 이 재구성에는 서버의 로컬 구성과 요청 대상, 호스트 헤더 필드 및 연결 컨텍스트에서 전달되는 정보가 모두 포함됩니다.

사용자 에이전트의 경우 유효한 요청 URI는 대상 URI입니다.

요청 대상이 절대 형식인 경우 유효한 요청 URI는 요청 대상과 동일합니다. 그렇지 않은 경우 유효한 요청 URI는 다음과 같이 구성됩니다.

- 서버의 구성\(또는 아웃바운드 게이트웨이\)이 고정된 URI 체계를 제공하는 경우 해당 체계가 유효한 요청 URI에 사용됩니다. 그렇지 않고 TLS 보안 TCP 연결을 통해 요청이 수신되면 유효한 요청 URI의 체계는 "https"입니다. 그렇지 않은 경우 구성표는 "http"입니다.

- 서버의 구성\(또는 아웃바운드 게이트웨이\)이 고정된 URI 권한 구성 요소를 제공하는 경우 해당 권한은 유효한 요청 URI에 사용됩니다. 그렇지 않은 경우 요청 대상이 권한 형식이면 유효한 요청 URI의 권한 구성 요소는 요청 대상과 동일합니다. 그렇지 않은 경우 Host 헤더 필드에 비어 있지 않은 필드 값이 제공되면 권한 구성 요소는 Host 필드 값과 동일합니다. 그렇지 않은 경우 권한 구성 요소에는 서버에 대해 구성된 기본 이름이 할당되고 연결의 수신 TCP 포트 번호가 유효한 요청 URI 체계의 기본 포트와 다른 경우 콜론\(":"\) 및 수신 포트 번호\( 십진수 형식\)은 권한 구성 요소에 추가됩니다.

- 요청 대상이 권한 형식 또는 별표 형식인 경우 유효한 요청 URI의 결합된 경로와 쿼리 구성 요소는 비어 있습니다. 그렇지 않으면 결합된 경로와 쿼리 구성 요소가 요청 대상과 동일합니다.

- 위와 같이 결정된 유효 요청 URI의 구성 요소는 스키마, "://", 권한, 결합된 경로 및 쿼리 구성 요소를 연결하여 절대 URI 형식으로 결합될 수 있습니다.

예시 1: 안전하지 않은 TCP 연결을 통해 수신된 다음 메시지

```text
     GET /pub/WWW/TheProject.html HTTP/1.1
     Host: www.example.org:8080
```

유효한 요청 URI는 다음과 같습니다.

```text
     http://www.example.org:8080/pub/WWW/TheProject.html
```

예시 2: TLS 보안 TCP 연결을 통해 수신된 다음 메시지

```text
     OPTIONS * HTTP/1.1
     Host: www.example.org
```

유효한 요청 URI는 다음과 같습니다.

```text
     https://www.example.org
```

Host 헤더 필드가 없는 HTTP/1.0 요청의 수신자는 효과적인 요청 URI의 권한 구성 요소를 추측하기 위해 경험적 방법\(예: 특정 호스트에 고유한 항목에 대한 URI 경로 검사\)을 사용해야 할 수 있습니다.

유효한 요청 URI가 구성되면 원서버는 요청이 수신된 연결을 통해 해당 URI에 대한 서비스를 제공할지 여부를 결정해야 합니다. 예를 들어, 요청이 의도적으로 또는 실수로 잘못 전달되어 수신된 요청 대상 또는 Host 헤더 필드 내의 정보가 연결이 이루어진 호스트 또는 포트와 다를 수 있습니다. 신뢰할 수 있는 게이트웨이에서 연결되는 경우 불일치가 예상될 수 있습니다. 그렇지 않으면 보안 필터를 우회하거나 서버를 속여 비공개 콘텐츠를 전달하거나 캐시를 손상시키려는 시도를 나타낼 수 있습니다. 메시지 라우팅에 관한 보안 고려 사항은 섹션 9를 참조하세요.

---
### **5.6.  Associating a Response to a Request**

HTTP에는 주어진 요청 메시지를 해당하는 하나 이상의 응답 메시지와 연결하기 위한 요청 식별자가 포함되어 있지 않습니다. 따라서 동일한 연결에서 요청이 이루어진 순서와 정확히 일치하도록 응답 도착 순서에 의존합니다. 요청당 둘 이상의 응답 메시지는 하나 이상의 정보 응답\(1xx, \[RFC7231\]의 섹션 6.2 참조\)이 동일한 요청에 대한 최종 응답 앞에 올 때만 발생합니다.

연결에 대해 하나 이상의 미해결 요청이 있는 클라이언트는 전송된 순서대로 미해결 요청 목록을 유지해야 하며 해당 연결에서 수신된 각 응답 메시지를 아직 최종\(비-1xx\)을 수신하지 않은 가장 높은 순서의 요청과 연결해야 합니다. 응답.\(MUST\)

---
### **5.7.  Message Forwarding**

섹션 2.3에 설명된 대로 중개자는 HTTP 요청 및 응답 처리에서 다양한 역할을 수행할 수 있습니다. 일부 중개자는 성능이나 가용성을 향상시키는 데 사용됩니다. 다른 것들은 액세스 제어나 콘텐츠 필터링에 사용됩니다. HTTP 스트림은 파이프 및 필터 아키텍처와 유사한 특성을 가지므로 중개자가 스트림의 어느 방향이든 향상\(또는 간섭\)할 수 있는 정도에는 본질적인 제한이 없습니다.

터널 역할을 하지 않는 중개자는 섹션 6.1에 지정된 대로 연결 헤더 필드를 구현해야 하며, 들어오는 연결에만 사용되는 필드를 전달에서 제외해야 합니다.\(MUST\)

중개자는 무한 요청 루프로부터 보호되지 않는 한 메시지를 자신에게 전달해서는 안 됩니다. 일반적으로 중개자는 별칭, 로컬 변형 또는 문자 그대로의 IP 주소를 포함하여 자체 서버 이름을 인식하고 그러한 요청에 직접 응답해야 합니다.\(MUST NOT\)

---
#### **5.7.1.  Via**

"Via" 헤더 필드는 이메일의 "Received" 헤더 필드와 유사하게 사용자 에이전트와 서버\(요청 시\) 또는 원본 서버와 클라이언트 사이\(응답 시\) 사이에 중간 프로토콜과 수신자의 존재를 나타냅니다\(섹션 \[RFC5322\]의 3.6.7\). Via는 메시지 전달을 추적하고, 요청 루프를 방지하고, 요청/응답 체인을 따라 보낸 사람의 프로토콜 기능을 식별하는 데 사용할 수 있습니다.

```text
     Via = 1#( received-protocol RWS received-by [ RWS comment ] )

     received-protocol = [ protocol-name "/" ] protocol-version
                         ; see Section 6.7
     received-by       = ( uri-host [ ":" port ] ) / pseudonym
     pseudonym         = token
```

여러 Via 필드 값은 메시지를 전달한 각 프록시 또는 게이트웨이를 나타냅니다. 각 중개자는 메시지 수신 방법에 대한 자체 정보를 추가하므로 최종 결과는 전달 받는 사람의 순서에 따라 정렬됩니다.

프록시는 전달하는 각 메시지에 아래 설명된 대로 적절한 Via 헤더 필드를 보내야 합니다. HTTP-to-HTTP 게이트웨이는 각 인바운드 요청 메시지에 적절한 Via 헤더 필드를 보내야 하며 전달된 응답 메시지에 Via 헤더 필드를 보낼 수 있습니다.\(MUST, MUST\)

각 중개자에 대해 received-protocol은 메시지의 업스트림 발신자가 사용하는 프로토콜 및 프로토콜 버전을 나타냅니다. 따라서 Via 필드 값은 다운스트림 수신자에게 계속 표시되도록 요청/응답 체인의 광고된 프로토콜 기능을 기록합니다. 이는 섹션 2.6에 설명된 대로 응답으로 또는 이후 요청 내에서 사용하기에 안전한 이전 버전과 호환되지 않는 기능을 결정하는 데 유용할 수 있습니다. 간결하게 하기 위해 수신된 프로토콜이 HTTP인 경우 프로토콜 이름은 생략됩니다.

필드 값의 수신자 부분은 일반적으로 이후에 메시지를 전달한 수신자 서버 또는 클라이언트의 호스트 및 선택적 포트 번호입니다. 그러나 실제 호스트가 민감한 정보로 간주되는 경우 발신자는 이를 가명으로 대체할 수 있습니다. 포트가 제공되지 않으면 수신자는 수신 프로토콜에 대한 기본 TCP 포트\(있는 경우\)에서 수신되었음을 의미하는 것으로 해석할 수 있습니다.\(MAY, MAY\)

발신자는 User-Agent 및 Server 헤더 필드와 유사하게 각 수신자의 소프트웨어를 식별하기 위해 Via 헤더 필드에 주석을 생성할 수 있습니다. 그러나 Via 필드의 모든 설명은 선택 사항이며 수신자는 메시지를 전달하기 전에 이를 제거할 수 있습니다.\(MAY, MAY\)

예를 들어, 요청 메시지는 HTTP/1.0 사용자 에이전트에서 "fred"라는 내부 프록시 코드명으로 전송될 수 있습니다. 이 프록시는 HTTP/1.1을 사용하여 요청을 p.example.net의 공개 프록시로 전달합니다. www.example.com의 원본 서버로 전달하여 요청합니다. www.example.com에서 수신한 요청에는 다음과 같은 Via 헤더 필드가 있습니다.

```text
     Via: 1.0 fred, 1.1 p.example.net
```

네트워크 방화벽을 통해 포털로 사용되는 중개자는 명시적으로 활성화되지 않는 한 방화벽 영역 내 호스트의 이름과 포트를 전달해서는 안 됩니다. 활성화되지 않은 경우 이러한 중개자는 방화벽 뒤의 호스트에서 수신한 각 호스트를 해당 호스트에 대한 적절한 가명으로 대체해야 합니다.\(SHOULD NOT, SHOULD\)

중개자는 항목이 동일한 수신 프로토콜 값을 갖는 경우 Via 헤더 필드 항목의 순서가 지정된 하위 시퀀스를 단일 항목으로 결합할 수 있습니다. 예를 들어,\(MAY\)

```text
     Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
```

으로 축소될 수 있음

```text
     Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```

발신자는 여러 항목이 모두 동일한 조직의 통제하에 있고 호스트가 이미 가명으로 대체되지 않은 한 여러 항목을 결합해서는 안 됩니다. 발신자는 서로 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안 됩니다.\(SHOULD NOT, MUST NOT\)

---
#### **5.7.2.  Transformations**

일부 중개자에는 메시지와 해당 페이로드를 변환하는 기능이 포함되어 있습니다. 예를 들어 프록시는 캐시 공간을 절약하거나 느린 링크의 트래픽 양을 줄이기 위해 이미지 형식을 변환할 수 있습니다. 그러나 이러한 변환이 의료 영상 또는 과학 데이터 분석과 같은 중요한 애플리케이션을 위한 페이로드에 적용될 때, 특히 무결성 검사 또는 디지털 서명을 사용하여 수신된 페이로드가 원본과 동일한지 확인하는 경우 운영 문제가 발생할 수 있습니다.

의미상 의미 있는 방식으로 메시지를 수정하도록 설계되거나 구성된 경우 HTTP-HTTP 프록시를 "변환 프록시"라고 합니다\(즉, 일반적인 HTTP 처리에 필요한 것 이상의 수정으로 메시지를 변경하는 방식\). 원래 보낸 사람에게 중요하거나 다운스트림 수신자에게 잠재적으로 중요할 수 있음\) 예를 들어, 변환 프록시는 공유 주석 서버\(로컬 주석 데이터베이스에 대한 참조를 포함하도록 응답 수정\), 악성 코드 필터, 형식 트랜스코더 또는 개인 정보 보호 필터 역할을 할 수 있습니다. 이러한 변환은 프록시를 선택한 클라이언트\(또는 클라이언트 조직\)가 원하는 것으로 추정됩니다.

프록시가 정규화된 도메인 이름이 아닌 호스트 이름을 가진 요청 대상을 수신하는 경우 요청을 전달할 때 수신한 호스트 이름에 자체 도메인을 추가할 수 있습니다. 요청 대상에 정규화된 도메인 이름이 포함된 경우 프록시는 호스트 이름을 변경해서는 안 됩니다.\(MAY, MUST NOT\)

프록시는 빈 경로를 "/" 또는 "\*"로 대체하기 위해 위에서 언급한 경우를 제외하고는 수신된 요청 대상을 다음 인바운드 서버로 전달할 때 수신된 요청 대상의 "절대 경로" 및 "쿼리" 부분을 수정해서는 안 됩니다.\(MUST NOT\)

프록시는 전송 코딩의 적용 또는 제거를 통해 메시지 본문을 수정할 수 있습니다\(섹션 4\).\(MAY\)

프록시는 변환 불가 캐시 제어 지시문\(\[RFC7234\]의 섹션 5.2\)을 포함하는 메시지의 페이로드\(\[RFC7231\]의 섹션 3.3\)를 변환해서는 안 됩니다.\(MUST NOT\)

프록시는 변환 불가 캐시 제어 지시문을 포함하지 않는 메시지의 페이로드를 변환할 수 있습니다. 페이로드를 변환하는 프록시는 경고 헤더 필드가 메시지에 아직 없는 경우 경고 코드 214\("변환 적용"\)가 있는 경고 헤더 필드를 추가해야 합니다\(\[RFC7234\]의 섹션 5.5 참조\). 200\(OK\) 응답의 페이로드를 변환하는 프록시는 응답 상태 코드를 203\(Non-Authoritative Information\)\(\[RFC7231\]의 섹션 6.3.4\)으로 변경하여 변환이 적용되었음을 다운스트림 수신자에게 추가로 알릴 수 있습니다.\(MAY, MUST\)

프록시는 필드의 정의가 그러한 수정을 구체적으로 허용하거나 수정이 개인 정보 보호 또는 보안을 위해 필요하다고 간주되지 않는 한 통신 체인의 끝점, 리소스 상태 또는 선택된 표현\(페이로드 제외\)에 대한 정보를 제공하는 헤더 필드를 수정해서는 안 됩니다. .\(SHOULD NOT\)

---
## **6.  Connection Management**

HTTP 메시징은 기본 전송 또는 세션 계층 연결 프로토콜과 독립적입니다. HTTP는 요청을 순차적으로 전달하고 응답을 순차적으로 전달하는 안정적인 전송만을 가정합니다. 기본 전송 프로토콜의 데이터 단위에 대한 HTTP 요청 및 응답 구조의 매핑은 이 사양의 범위를 벗어납니다.

섹션 5.2에 설명된 대로 HTTP 상호 작용에 사용되는 특정 연결 프로토콜은 클라이언트 구성 및 대상 URI에 의해 결정됩니다. 예를 들어, "http" URI 체계\(섹션 2.7.1\)는 기본 TCP 포트 80을 사용하는 IP를 통한 TCP의 기본 연결을 나타내지만 클라이언트는 다른 연결, 포트 또는 다른 연결을 통해 프록시를 사용하도록 구성될 수 있습니다. 규약.

HTTP 구현은 현재 연결 상태 유지, 새 연결 설정 또는 기존 연결 재사용, 연결에서 수신된 메시지 처리, 연결 실패 감지 및 각 연결 닫기를 포함하는 연결 관리에 참여할 것으로 예상됩니다. 대부분의 클라이언트는 서버 끝점당 둘 이상의 연결을 포함하여 여러 연결을 병렬로 유지합니다. 대부분의 서버는 수천 개의 동시 연결을 유지하는 동시에 요청 대기열을 제어하여 공정한 사용을 활성화하고 서비스 거부 공격을 감지하도록 설계되었습니다.

---
### **6.1.  Connection**

"Connection" 헤더 필드를 통해 발신자는 현재 연결에 대해 원하는 제어 옵션을 나타낼 수 있습니다. 다운스트림 수신자의 혼란을 피하기 위해 프록시 또는 게이트웨이는 메시지를 전달하기 전에 수신된 연결 옵션을 제거하거나 교체해야 합니다.\(MUST\)

Connection 이외의 헤더 필드가 현재 연결에 대한 제어 정보를 제공하는 데 사용되는 경우 발신자는 Connection 헤더 필드 내에 해당 필드 이름을 나열해야 합니다. 프록시 또는 게이트웨이는 메시지가 전달되기 전에 수신된 연결 헤더 필드를 구문 분석해야 하며, 이 필드의 각 연결 옵션에 대해 연결 옵션과 동일한 이름을 가진 메시지에서 헤더 필드를 제거한 다음 제거해야 합니다. Connection 헤더 필드 자체\(또는 전달된 메시지에 대한 중개자의 자체 연결 옵션으로 대체\)\(MUST, MUST\)

따라서 연결 헤더 필드는 체인의 모든 수신자를 대상으로 하는 필드\("종단 간"\)와 직접 수신자만을 대상으로 하는 헤더 필드\("홉별"\)를 구별하는 선언적 방법을 제공합니다. "\)를 사용하면 메시지가 자기 설명적일 수 있고 향후 연결별 확장이 이전 중개자에 의해 맹목적으로 전달될 것이라는 두려움 없이 배포될 수 있습니다.

Connection 헤더 필드의 값에는 다음과 같은 문법이 있습니다.

```text
     Connection        = 1#connection-option
     connection-option = token
```

연결 옵션은 대소문자를 구분하지 않습니다.

발신자는 페이로드의 모든 수신자를 대상으로 하는 헤더 필드에 해당하는 연결 옵션을 보내서는 안 됩니다. 예를 들어 Cache-Control은 연결 옵션으로 적합하지 않습니다\(\[RFC7234\]의 섹션 5.2\).\(MUST NOT\)

연결 옵션과 연관된 매개변수가 없으면 연결별 헤더 필드가 필요하지 않을 수 있으므로 연결 옵션이 항상 메시지에 있는 헤더 필드와 일치하는 것은 아닙니다. 반면, 해당 연결 옵션 없이 수신된 연결별 헤더 필드는 일반적으로 해당 필드가 중개자에 의해 부적절하게 전달되었으므로 수신자가 무시해야 함을 나타냅니다.

새로운 연결 옵션을 정의할 때 사양 작성자는 기존 헤더 필드 이름을 조사하고 새 연결 옵션이 이미 배포된 헤더 필드와 동일한 이름을 공유하지 않는지 확인해야 합니다. 새로운 연결 옵션을 정의하면 본질적으로 연결 옵션과 관련된 추가 정보를 전달하기 위해 잠재적인 필드 이름이 예약됩니다. 왜냐하면 발신자가 해당 필드 이름을 다른 용도로 사용하는 것은 현명하지 않기 때문입니다.

"close" 연결 옵션은 보낸 사람이 응답이 완료된 후 이 연결이 닫힐 것이라는 신호를 보내기 위해 정의됩니다. 예를 들어,

```text
     Connection: close
```

요청 또는 응답 헤더 필드는 현재 요청/응답이 완료된 후 발신자가 연결을 닫을 것임을 나타냅니다\(섹션 6.6\).

지속적인 연결을 지원하지 않는 클라이언트는 모든 요청 메시지에 "close" 연결 옵션을 보내야 합니다.\(MUST\)

지속적인 연결을 지원하지 않는 서버는 1xx\(정보\) 상태 코드가 없는 모든 응답 메시지에 "close" 연결 옵션을 보내야 합니다.\(MUST\)

---
### **6.2.  Establishment**

다양한 전송 또는 세션 계층 프로토콜을 통해 연결이 설정되는 방법을 설명하는 것은 이 사양의 범위를 벗어납니다. 각 연결은 하나의 전송 링크에만 적용됩니다.

---
### **6.3.  Persistence**

HTTP/1.1은 기본적으로 "영구 연결"을 사용하므로 단일 연결을 통해 여러 요청과 응답을 전달할 수 있습니다. "닫기" 연결 옵션은 현재 요청/응답 후에 연결이 지속되지 않음을 알리는 데 사용됩니다. HTTP 구현은 지속적인 연결을 지원해야 합니다\(SHOULD\).\(SHOULD\)

수신자는 가장 최근에 수신한 메시지의 프로토콜 버전과 연결 헤더 필드\(있는 경우\)를 기반으로 연결이 지속되는지 여부를 결정합니다.

o "닫기" 연결 옵션이 있는 경우 현재 응답 이후에는 연결이 지속되지 않습니다. 또 다른,

o 수신된 프로토콜이 HTTP/1.1\(또는 그 이상\)인 경우 현재 응답 후에도 연결이 유지됩니다. 또 다른,

o 수신된 프로토콜이 HTTP/1.0이고 "연결 유지" 연결 옵션이 있고 수신자가 프록시가 아니며 수신자가 HTTP/1.0 "연결 유지" 메커니즘을 따르기를 원하는 경우 연결은 이후에도 지속됩니다. 현재 응답; 그렇지 않으면,

o 현재 응답 후에 연결이 닫힙니다.

클라이언트는 "닫기" 연결 옵션을 보내거나 받을 때까지 또는 "연결 유지" 연결 옵션 없이 HTTP/1.0 응답을 받을 때까지 지속적인 연결에 대한 추가 요청을 보낼 수 있습니다.\(MAY\)

지속성을 유지하려면 섹션 3.3에 설명된 대로 연결의 모든 메시지는 자체 정의된 메시지 길이\(즉, 연결 종료로 정의되지 않은 메시지 길이\)를 가져야 합니다. 서버는 전체 요청 메시지 본문을 읽거나 응답을 보낸 후 연결을 닫아야 합니다. 그렇지 않으면 영구 연결의 나머지 데이터가 다음 요청으로 잘못 해석될 수 있기 때문입니다. 마찬가지로 클라이언트는 후속 요청에 대해 동일한 연결을 재사용하려는 경우 전체 응답 메시지 본문을 읽어야 합니다.\(MUST, MUST\)

프록시 서버는 HTTP/1.0 클라이언트와의 지속적인 연결을 유지해서는 안 됩니다\(많은 HTTP/1.0 클라이언트에 의해 구현된 Keep-Alive 헤더 필드 관련 문제에 대한 정보 및 논의는 \[RFC2068\]의 섹션 19.7.1 참조\).\(MUST NOT\)

HTTP/1.0 클라이언트와의 하위 호환성에 대한 자세한 내용은 부록 A.1.2를 참조하세요.

---
#### **6.3.1.  Retrying Requests**

의도 여부에 관계없이 언제든지 연결을 닫을 수 있습니다. 구현에서는 비동기 닫기 이벤트에서 복구해야 할 필요성을 예상해야 합니다.

인바운드 연결이 조기에 닫히면 클라이언트는 새 연결을 열고 모든 요청에 ​​멱등성 메서드가 있는 경우 중단된 요청 시퀀스를 자동으로 재전송할 수 있습니다\(\[RFC7231\]의 섹션 4.2.2\). 프록시는 멱등성이 아닌 요청을 자동으로 재시도해서는 안 됩니다.\(MAY, MUST NOT\)

사용자 에이전트는 메소드에 관계없이 요청 의미론이 실제로 멱등성을 갖는다는 것을 알 수 있는 수단이 없거나 원래 요청이 전혀 적용되지 않았음을 감지하는 수단이 없는 한 비멱등성 메소드로 요청을 자동으로 재시도해서는 안 됩니다. 예를 들어, 주어진 리소스에 대한 POST 요청이 안전하다는 것을 \(설계 또는 구성을 통해\) 알고 있는 사용자 에이전트는 해당 요청을 자동으로 반복할 수 있습니다. 마찬가지로, 버전 제어 저장소에서 작동하도록 특별히 설계된 사용자 에이전트는 연결 실패 후 대상 리소스 개정을 확인하고 부분적으로 적용된 변경 사항을 되돌리거나 수정한 다음 자동으로 부분 실패 조건에서 복구할 수 있습니다. 실패한 요청을 다시 시도합니다.\(MUST NOT\)

클라이언트는 실패한 자동 재시도를 자동으로 재시도해서는 안 됩니다.\(SHOULD NOT\)

---
#### **6.3.2.  Pipelining**

지속적인 연결을 지원하는 클라이언트는 요청을 "파이프라인"할 수 있습니다\(즉, 각 응답을 기다리지 않고 여러 요청을 보낼 수 있습니다\). 서버는 모두 안전한 메서드\(\[RFC7231\]의 섹션 4.2.1\)를 가지고 있는 경우 일련의 파이프라인 요청을 병렬로 처리할 수 있지만 요청이 수신된 것과 동일한 순서로 해당 응답을 보내야 합니다.\(MAY, MUST\)

요청을 파이프라인으로 처리하는 클라이언트는 해당 응답을 모두 받기 전에 연결이 닫히면 응답되지 않은 요청을 재시도해야 합니다. 연결 실패\(마지막 완전한 응답에서 서버에 의해 명시적으로 닫히지 않은 연결\) 후 파이프라인 요청을 재시도할 때 클라이언트는 연결 설정 직후 파이프라인을 사용해서는 안 됩니다. 이전 파이프라인의 첫 번째 남은 요청이 다음과 같은 오류 응답을 발생시켰을 수 있기 때문입니다. 조기에 닫힌 연결에서 여러 요청이 전송되면 다시 손실될 수 있습니다\(섹션 6.6에 설명된 TCP 재설정 문제 참조\).\(SHOULD, MUST NOT\)

멱등성 메서드\(\[RFC7231\]의 섹션 4.2.2\)는 연결 실패 후 자동으로 재시도될 수 있기 때문에 파이프라인에 중요합니다. 사용자 에이전트는 파이프라인 시퀀스와 관련된 부분 실패 조건을 감지하고 복구할 수 있는 수단이 없는 한, 해당 메서드에 대한 최종 응답 상태 코드가 수신될 때까지 비멱등 메서드 이후에 파이프라인 요청을 해서는 안 됩니다.\(SHOULD NOT\)

파이프라인 요청을 수신하는 중개자는 인바운드로 전달할 때 해당 요청을 파이프라인할 수 있습니다. 이는 어떤 요청이 안전하게 파이프라인될 수 있는지 결정하기 위해 아웃바운드 사용자 에이전트에 의존할 수 있기 때문입니다. 응답을 받기 전에 인바운드 연결이 실패하는 경우 파이프라이닝 중개자는 요청에 모두 멱등성 메서드가 있는 경우 아직 응답을 받지 못한 일련의 요청을 재시도할 수 있습니다. 그렇지 않은 경우 파이프라이닝 중개자는 수신된 모든 응답을 전달한 다음 아웃바운드 사용자 에이전트가 그에 따라 복구할 수 있도록 해당 아웃바운드 연결을 닫아야 합니다.\(MAY, SHOULD\)

---
### **6.4.  Concurrency**

클라이언트는 특정 서버에 대해 유지 관리하는 동시에 열려 있는 연결 수를 제한해야 합니다.

이전 HTTP 개정판에서는 특정 수의 연결을 한도로 제공했지만 이는 많은 애플리케이션에서 실용적이지 않은 것으로 나타났습니다. 결과적으로 이 사양은 특정 최대 연결 수를 요구하지 않지만 대신 클라이언트가 여러 연결을 열 때 보수적이 되도록 권장합니다.

다중 연결은 일반적으로 "헤드 오브 라인 차단" 문제를 피하기 위해 사용됩니다. 여기서 상당한 서버 측 처리가 필요하거나 페이로드가 큰 요청이 동일한 연결에 대한 후속 요청을 차단합니다. 그러나 각 연결은 서버 리소스를 소비합니다. 또한 여러 연결을 사용하면 혼잡한 네트워크에서 바람직하지 않은 부작용이 발생할 수 있습니다.

서버는 단일 클라이언트에서 과도한 수의 열린 연결과 같이 악의적이거나 서비스 거부 공격의 특징으로 간주되는 트래픽을 거부할 수 있습니다.

---
### **6.5.  Failures and Timeouts**

서버에는 일반적으로 더 이상 비활성 연결을 유지하지 않는 시간 초과 값이 있습니다. 클라이언트가 동일한 프록시 서버를 통해 더 많은 연결을 만들 가능성이 높으므로 프록시 서버는 이 값을 더 높게 설정할 수 있습니다. 영구 연결을 사용하면 클라이언트나 서버에 대한 이 제한 시간의 길이\(또는 존재 여부\)에 대한 요구 사항이 없습니다.

시간 초과를 원하는 클라이언트나 서버는 연결을 정상적으로 종료해야 합니다. 구현에서는 수신된 종료 신호에 대해 열려 있는 연결을 지속적으로 모니터링하고 적절하게 응답해야 합니다. 연결 양쪽을 즉시 종료하면 할당된 시스템 리소스를 회수할 수 있기 때문입니다.\(SHOULD, SHOULD\)

클라이언트, 서버 또는 프록시는 언제든지 전송 연결을 닫을 수 있습니다. 예를 들어, 서버가 "유휴" 연결을 종료하기로 결정한 동시에 클라이언트가 새 요청을 보내기 시작했을 수 있습니다. 서버 입장에서는 유휴 상태에서 연결이 종료되고 있지만 클라이언트 입장에서는 요청이 진행 중인 상태입니다.\(MAY\)

서버는 가능한 경우 지속적인 연결을 유지해야 하며, 클라이언트가 재시도할 것으로 예상하여 연결을 종료하는 대신 기본 전송의 흐름 제어 메커니즘이 일시적인 과부하를 해결하도록 허용해야 합니다. 후자의 기술은 네트워크 정체를 악화시킬 수 있습니다.\(SHOULD\)

메시지 본문을 보내는 클라이언트는 요청을 전송하는 동안 네트워크 연결에서 오류 응답을 모니터링해야 합니다. 서버가 메시지 본문 수신을 원하지 않고 연결을 닫고 있음을 나타내는 응답을 클라이언트가 본 경우 클라이언트는 즉시 본문 전송을 중단하고 연결 쪽을 닫아야 합니다.\(SHOULD, SHOULD\)

---
### **6.6.  Tear-down**

Connection 헤더 필드\(Section 6.1\)는 발신자가 현재 요청/응답 쌍 이후에 연결을 닫으려고 할 때 전송해야 하는 "닫기" 연결 옵션을 제공합니다.\(SHOULD\)

"close" 연결 옵션을 전송하는 클라이언트는 해당 연결에 대한 추가 요청\("close"가 포함된 요청 이후\)을 전송해서는 안 되며\(MUST\) 이 요청에 해당하는 최종 응답 메시지를 읽은 후 연결을 닫아야 합니다\(MUST\).\(MUST NOT\)

"닫기" 연결 옵션을 수신한 서버는 "닫기"가 포함된 요청에 대한 최종 응답을 보낸 후 연결 닫기\(아래 참조\)를 시작해야 합니다. 서버는 해당 연결에 대한 최종 응답으로 "닫기" 연결 옵션을 보내야 합니다\(SHOULD\). 서버는 해당 연결에서 수신된 추가 요청을 처리해서는 안 됩니다.\(MUST, SHOULD, MUST NOT\)

"닫기" 연결 옵션을 보내는 서버는 "닫기"가 포함된 응답을 보낸 후 연결 닫기\(아래 참조\)를 시작해야 합니다. 서버는 해당 연결에서 수신된 추가 요청을 처리해서는 안 됩니다.\(MUST, MUST NOT\)

"닫기" 연결 옵션을 수신한 클라이언트는 반드시 해당 연결에 대한 요청 전송을 중단하고 "닫기"가 포함된 응답 메시지를 읽은 후 연결을 닫아야 합니다. 추가 파이프라인 요청이 연결에서 전송된 경우 클라이언트는 해당 요청이 서버에 의해 처리될 것이라고 가정해서는 안 됩니다.\(MUST\)

서버가 TCP 연결을 즉시 닫는 경우 클라이언트가 마지막 HTTP 응답을 읽지 못할 위험이 있습니다. 서버가 완전히 닫힌 연결에서 클라이언트로부터 추가 데이터\(예: 서버의 응답을 받기 전에 클라이언트가 보낸 다른 요청\)를 받으면 서버의 TCP 스택은 클라이언트에 재설정 패킷을 보냅니다. 불행하게도 재설정 패킷은 클라이언트의 HTTP 구문 분석기가 읽고 해석하기 전에 클라이언트의 확인되지 않은 입력 버퍼를 지울 수 있습니다.

TCP 재설정 문제를 방지하기 위해 서버는 일반적으로 단계적으로 연결을 닫습니다. 먼저, 서버는 읽기/쓰기 연결의 쓰기 측만 닫아 절반 닫기를 수행합니다. 그런 다음 서버는 클라이언트가 해당 닫기를 수신할 때까지 또는 자체 TCP 스택이 서버의 마지막 응답이 포함된 패킷에 대한 클라이언트의 승인을 받았다고 서버가 합리적으로 확신할 때까지 연결에서 계속해서 읽습니다. 마지막으로 서버는 연결을 완전히 종료합니다.

재설정 문제가 TCP에만 국한된 것인지, 아니면 다른 전송 연결 프로토콜에서도 발견될 수 있는지는 알 수 없습니다.

---
### **6.7.  Upgrade**

"Upgrade" 헤더 필드는 동일한 연결에서 HTTP/1.1에서 다른 프로토콜로 전환하기 위한 간단한 메커니즘을 제공하기 위한 것입니다. 클라이언트는 최종 응답을 보내기 전에 우선 순위에 따라 하나 이상의 프로토콜로 전환하도록 서버를 초대하기 위해 요청의 업그레이드 헤더 필드에 프로토콜 목록을 보낼 수 있습니다. 서버는 해당 연결에서 현재 프로토콜을 계속 사용하려는 경우 수신된 업그레이드 헤더 필드를 무시할 수 있습니다. 업그레이드는 프로토콜 변경을 요구하는 데 사용할 수 없습니다.\(MAY, MAY\)

```text
     Upgrade          = 1#protocol

     protocol         = protocol-name ["/" protocol-version]
     protocol-name    = token
     protocol-version = token
```

101\(Switching Protocols\) 응답을 보내는 서버는 연결이 전환되는 새로운 프로토콜을 나타내기 위해 업그레이드 헤더 필드를 보내야 합니다. 여러 프로토콜 계층이 전환되는 경우 발신자는 프로토콜을 계층 오름차순으로 나열해야 합니다. 서버는 클라이언트가 해당 요청의 업그레이드 헤더 필드에 표시하지 않은 프로토콜로 전환해서는 안 됩니다. ㅏ\(MUST, MUST NOT\)

서버는 클라이언트가 지정한 우선 순위를 무시하고 요청의 성격이나 서버의 현재 로드와 같은 다른 요소를 기반으로 새 프로토콜을 선택할 수 있습니다.\(MAY\)

426\(업그레이드 필요\) 응답을 보내는 서버는 선호도 내림차순으로 허용 가능한 프로토콜을 나타내기 위해 업그레이드 헤더 필드를 보내야 합니다.\(MUST\)

서버는 향후 요청에 적합한 경우 선호도 내림차순으로 나열된 프로토콜로 업그레이드하기 위한 지원을 구현한다는 것을 알리기 위해 다른 응답에 업그레이드 헤더 필드를 보낼 수 있습니다.\(MAY\)

다음은 클라이언트가 보낸 가상의 예입니다.

```text
     GET /hello.txt HTTP/1.1
     Host: www.example.com
     Connection: upgrade
     Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
```

프로토콜 변경 후 애플리케이션 수준 통신의 기능과 특성은 전적으로 선택한 새 프로토콜에 따라 달라집니다. 그러나 101\(스위칭 프로토콜\) 응답을 보낸 직후 서버는 마치 새 프로토콜 내에서 해당 요청을 수신한 것처럼 원래 요청에 계속 응답할 것으로 예상됩니다. 즉, 서버에는 프로토콜 이후에 충족해야 할 미해결 요청이 여전히 남아 있습니다. 변경되었으며 요청을 반복할 필요 없이 변경될 것으로 예상됩니다\).

예를 들어 업그레이드 헤더 필드가 GET 요청에서 수신되고 서버가 프로토콜을 전환하기로 결정한 경우 먼저 HTTP/1.1의 101\(스위칭 프로토콜\) 메시지로 응답한 다음 즉시 새 프로토콜의 해당 응답으로 이어집니다. 대상 리소스에 대한 GET입니다. 이를 통해 추가 왕복으로 인한 대기 시간 비용 없이 HTTP와 동일한 의미를 갖는 프로토콜로 연결을 업그레이드할 수 있습니다. 서버는 수신된 메시지 의미가 새로운 프로토콜에 의해 존중되지 않는 한 프로토콜을 전환해서는 안 됩니다. OPTIONS 요청은 모든 프로토콜에서 수락될 수 있습니다.\(MUST NOT\)

다음은 위의 가상 요청에 대한 응답 예시입니다.

```text
     HTTP/1.1 101 Switching Protocols
     Connection: upgrade
     Upgrade: HTTP/2.0
```

\[... 데이터 스트림은 "GET /hello.txt" 요청에 대한 적절한 응답\(새 프로토콜에 정의된 대로\)과 함께 HTTP/2.0으로 전환됩니다...\]

업그레이드가 전송되면 발신자는 나열된 프로토콜을 구현하지 않을 수 있는 중개자에 의해 실수로 업그레이드가 전달되는 것을 방지하기 위해 "업그레이드" 연결 옵션이 포함된 연결 헤더 필드\(6.1절\)도 전송해야 합니다. 서버는 HTTP/1.0 요청에서 수신된 업그레이드 헤더 필드를 무시해야 합니다.\(MUST, MUST\)

클라이언트는 요청 메시지를 완전히 보낼 때까지 연결에서 업그레이드된 프로토콜을 사용하기 시작할 수 없습니다. 즉, 클라이언트는 메시지 중간에 보내는 프로토콜을 변경할 수 없습니다. 서버가 "100-continue" 예상\(\[RFC7231\]의 섹션 5.1.1\)을 포함하는 Upgrade 및 Expect 헤더 필드를 모두 수신하는 경우 서버는 101\(스위칭 프로토콜\) 응답을 보내기 전에 100\(계속\) 응답을 보내야 합니다. .\(MUST\)

업그레이드 헤더 필드는 기존 연결 위에 있는 프로토콜 전환에만 적용됩니다. 기본 연결\(전송\) 프로토콜을 전환하거나 기존 통신을 다른 연결로 전환하는 데 사용할 수 없습니다. 이러한 목적을 위해서는 3xx\(리디렉션\) 응답\(\[RFC7231\]의 섹션 6.4\)을 사용하는 것이 더 적절합니다.

이 사양은 섹션 2.6의 HTTP 버전 규칙과 이 사양에 대한 향후 업데이트에 정의된 대로 하이퍼텍스트 전송 프로토콜 제품군에서 사용하기 위한 프로토콜 이름 "HTTP"만 정의합니다. 추가 토큰은 섹션 8.6에 정의된 등록 절차를 사용하여 IANA에 등록되어야 합니다.

---
## **7.  ABNF List Extension: #rule**

\[RFC5234\]의 ABNF 규칙에 대한 #rule 확장은 일부 헤더 필드 값 정의의 가독성을 향상시키는 데 사용됩니다.

쉼표로 구분된 요소 목록을 정의하기 위해 "\*"와 유사한 구성 "#"이 정의됩니다. 전체 형식은 "<n\>#<m\>element"로, 각각 단일 쉼표\(","\)와 선택적 공백\(OWS\)으로 구분된 최소 <n\>개 및 최대 <m\>개의 요소를 나타냅니다.

목록 구성을 사용하는 모든 제작에서 발신자는 빈 목록 요소를 생성해서는 안 됩니다. 즉, 발신자는 다음 구문을 충족하는 목록을 생성해야 합니다.\(MUST NOT, MUST\)

```text
     1#element => element *( OWS "," OWS element )

   and:

     #element => [ 1#element ]
```

n \>= 1이고 m \> 1인 경우:

```text
     <n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )
```

레거시 목록 규칙과의 호환성을 위해 수신자는 합리적인 수의 빈 목록 요소를 구문 분석하고 무시해야 합니다. 값을 병합하는 발신자의 일반적인 실수를 처리하기에 충분하지만 서비스 거부 메커니즘으로 사용될 수 있을 만큼 많지는 않습니다. 즉, 수신자는 다음 구문을 충족하는 목록을 수락해야 합니다.\(MUST, MUST\)

```text
     #element => [ ( "," / element ) *( OWS "," [ OWS element ] ) ]

     1#element => *( "," OWS ) element *( OWS "," [ OWS element ] )
```

빈 요소는 존재하는 요소 수에 영향을 주지 않습니다. 예를 들어 다음과 같은 ABNF 프로덕션이 있다고 가정해 보겠습니다.

```text
     example-list      = 1#example-list-elmt
     example-list-elmt = token ; see Section 3.2.6
```

다음은 example-list에 유효한 값입니다\(구분용으로만 사용되는 큰따옴표는 포함되지 않음\).

```text
     "foo,bar"
     "foo ,bar,"
     "foo , ,bar,charlie   "
```

반면, 예제 목록 생성에는 비어 있지 않은 요소가 하나 이상 필요하므로 다음 값은 유효하지 않습니다.

```text
     ""
     ","
     ",   ,"
```

부록 B는 목록 구성이 확장된 후 수신자에 대해 수집된 ABNF를 보여줍니다.

---
## **8.  IANA Considerations**
---
### **8.1.  Header Field Registration**

```text
   HTTP header fields are registered within the "Message Headers"
   registry maintained at
   <http://www.iana.org/assignments/message-headers/>.
```

이 문서는 다음 HTTP 헤더 필드를 정의하므로 "영구 메시지 헤더 필드 이름" 레지스트리가 이에 따라 업데이트되었습니다\(\[BCP90\] 참조\).

```text
   +-------------------+----------+----------+---------------+
   | Header Field Name | Protocol | Status   | Reference     |
   +-------------------+----------+----------+---------------+
   | Connection        | http     | standard | Section 6.1   |
   | Content-Length    | http     | standard | Section 3.3.2 |
   | Host              | http     | standard | Section 5.4   |
   | TE                | http     | standard | Section 4.3   |
   | Trailer           | http     | standard | Section 4.4   |
   | Transfer-Encoding | http     | standard | Section 3.3.1 |
   | Upgrade           | http     | standard | Section 6.7   |
   | Via               | http     | standard | Section 5.7.1 |
   +-------------------+----------+----------+---------------+
```

또한 헤더 필드 이름 "Close"는 "예약됨"으로 등록되었습니다. 해당 이름을 HTTP 헤더 필드로 사용하면 Connection 헤더 필드\(섹션 6.1\)의 "close" 연결 옵션과 충돌할 수 있기 때문입니다.

```text
   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Close             | http     | reserved | Section 8.1 |
   +-------------------+----------+----------+-------------+
```

변경 컨트롤러는 "IETF\(iesg@ietf.org\) - 인터넷 엔지니어링 태스크 포스"입니다.

---
### **8.2.  URI Scheme Registration**

```text
   IANA maintains the registry of URI Schemes [BCP115] at
   <http://www.iana.org/assignments/uri-schemes/>.
```

이 문서에서는 다음과 같은 URI 체계를 정의하므로 이에 따라 "영구 URI 체계" 레지스트리가 업데이트되었습니다.

```text
   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | Section 2.7.1 |
   | https      | Hypertext Transfer Protocol Secure | Section 2.7.2 |
   +------------+------------------------------------+---------------+
```

---
### **8.3.  Internet Media Type Registration**

```text
   IANA maintains the registry of Internet media types [BCP13] at
   <http://www.iana.org/assignments/media-types>.
```

이 문서는 인터넷 미디어 유형 "message/http" 및 "application/http"에 대한 사양 역할을 합니다. IANA에 등록된 내용은 다음과 같습니다.

---
#### **8.3.1.  Internet Media Type message/http**

message/http 유형은 줄 길이 및 인코딩과 관련하여 모든 "메시지" 유형에 대한 MIME 제한 사항을 준수하는 경우 단일 HTTP 요청 또는 응답 메시지를 묶는 데 사용할 수 있습니다.

```text
   Type name:  message

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype
```

- 버전: 포함된 메시지의 HTTP 버전 번호\(예: "1.1"\)입니다. 버전이 없으면 본문의 첫 번째 줄에서 버전을 확인할 수 있습니다.

- msgtype: 메시지 유형 - "요청" 또는 "응답". 존재하지 않는 경우, 본문의 첫 번째 줄에서 유형을 판별할 수 있습니다.

인코딩 고려 사항: "7bit", "8bit" 또는 "binary"만 허용됩니다.

```text
   Security considerations:  see Section 9

   Interoperability considerations:  N/A
```

게시된 사양: 이 사양\(섹션 8.3.1 참조\).

이 미디어 유형을 사용하는 애플리케이션: 해당 없음

```text
   Fragment identifier considerations:  N/A

   Additional information:

      Magic number(s):  N/A
```

- 이 유형에 대해 더 이상 사용되지 않는 별칭 이름: 해당 없음

```text
      File extension(s):  N/A

      Macintosh file type code(s):  N/A
```

추가 정보를 문의할 사람 및 이메일 주소:

- 저자 주소 섹션을 참조하세요.

```text
   Intended usage:  COMMON
```

사용 제한: 해당 없음

```text
   Author:  See Authors' Addresses section.

   Change controller:  IESG
```

---
#### **8.3.2.  Internet Media Type application/http**

application/http 유형은 하나 이상의 HTTP 요청 또는 응답 메시지\(혼합되지 않음\)의 파이프라인을 묶는 데 사용될 수 있습니다.

```text
   Type name:  application

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype
```

- 버전: 포함된 메시지의 HTTP 버전 번호\(예: "1.1"\)입니다. 버전이 없으면 본문의 첫 번째 줄에서 버전을 확인할 수 있습니다.

- msgtype: 메시지 유형 - "요청" 또는 "응답". 존재하지 않는 경우, 본문의 첫 번째 줄에서 유형을 판별할 수 있습니다.

인코딩 고려사항: 이 유형으로 묶인 HTTP 메시지는 "바이너리" 형식입니다. 이메일을 통해 전송할 때는 적절한 콘텐츠 전송 인코딩을 사용해야 합니다.

```text
   Security considerations:  see Section 9

   Interoperability considerations:  N/A
```

게시된 사양: 이 사양\(섹션 8.3.2 참조\)

이 미디어 유형을 사용하는 애플리케이션: 해당 없음

```text
   Fragment identifier considerations:  N/A

   Additional information:
```

- 이 유형에 대해 더 이상 사용되지 않는 별칭 이름: 해당 없음

```text
      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A
```

추가 정보를 문의할 사람 및 이메일 주소:

- 저자 주소 섹션을 참조하세요.

```text
   Intended usage:  COMMON
```

사용 제한: 해당 없음

```text
   Author:  See Authors' Addresses section.

   Change controller:  IESG
```

---
### **8.4.  Transfer Coding Registry**

```text
   The "HTTP Transfer Coding Registry" defines the namespace for
   transfer coding names.  It is maintained at
   <http://www.iana.org/assignments/http-parameters>.
```

---
#### **8.4.1.  Procedure**

등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

```text
   o  Name

   o  Description
```

o 사양 텍스트에 대한 포인터

전송 코딩의 이름은 섹션 4.2에 정의된 압축 코딩의 경우처럼 인코딩 변환이 동일하지 않는 한 콘텐츠 코딩의 이름\(\[RFC7231\]의 섹션 3.1.2.1\)과 겹쳐서는 안 됩니다.\(MUST NOT\)

이 네임스페이스에 추가되는 값은 IETF 검토\(\[RFC5226\]의 섹션 4.1 참조\)가 필요하며 본 사양에 정의된 전송 코딩의 목적을 준수해야 합니다.\(MUST\)

인코딩 형식을 식별하기 위해 프로그램 이름을 사용하는 것은 바람직하지 않으며 향후 인코딩에서는 권장되지 않습니다.

---
#### **8.4.2.  Registration**

"HTTP 전송 코딩 레지스트리"가 아래 등록으로 업데이트되었습니다.

```text
   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | chunked    | Transfer in a series of chunks       | Section 4.1   |
   | compress   | UNIX "compress" data format [Welch]  | Section 4.2.1 |
   | deflate    | "deflate" compressed data            | Section 4.2.2 |
   |            | ([RFC1951]) inside the "zlib" data   |               |
   |            | format ([RFC1950])                   |               |
   | gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |
   | x-compress | Deprecated (alias for compress)      | Section 4.2.1 |
   | x-gzip     | Deprecated (alias for gzip)          | Section 4.2.3 |
   +------------+--------------------------------------+---------------+
```

---
### **8.5.  Content Coding Registration**

```text
   IANA maintains the "HTTP Content Coding Registry" at
   <http://www.iana.org/assignments/http-parameters>.
```

"HTTP 콘텐츠 코딩 레지스트리"가 아래 등록으로 업데이트되었습니다.

```text
   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX "compress" data format [Welch]  | Section 4.2.1 |
   | deflate    | "deflate" compressed data            | Section 4.2.2 |
   |            | ([RFC1951]) inside the "zlib" data   |               |
   |            | format ([RFC1950])                   |               |
   | gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |
   | x-compress | Deprecated (alias for compress)      | Section 4.2.1 |
   | x-gzip     | Deprecated (alias for gzip)          | Section 4.2.3 |
   +------------+--------------------------------------+---------------+
```

---
### **8.6.  Upgrade Token Registry**

```text
   The "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry"
   defines the namespace for protocol-name tokens used to identify
   protocols in the Upgrade header field.  The registry is maintained at
   <http://www.iana.org/assignments/http-upgrade-tokens>.
```

---
#### **8.6.1.  Procedure**

등록된 각 프로토콜 이름은 연락처 정보 및 연결이 업그레이드된 후 연결이 처리되는 방법을 자세히 설명하는 선택적 사양 세트와 연결됩니다.

등록은 "선착순" 방식으로 이루어지며\(\[RFC5226\]의 섹션 4.1 참조\) 다음 규칙이 적용됩니다.

1. 프로토콜 이름 토큰은 한 번 등록되면 영원히 등록된 상태로 유지됩니다.

2. 등록에는 반드시 책임 있는 당사자가 명시되어야 합니다.

-   등록.\(MUST\)

3. 등록에는 연락처가 명시되어야 합니다.\(MUST\)

4. 등록은 해당 토큰과 관련된 일련의 사양을 명명할 수 있습니다. 이러한 사양은 공개적으로 이용 가능해야 할 필요는 없습니다.\(MAY\)

5. 등록 시에는 등록 시 해당 토큰과 관련된 예상 "프로토콜 버전" 토큰 세트의 이름을 지정해야 합니다.\(SHOULD\)

6. 책임 있는 당사자는 언제든지 등록을 변경할 수 있습니다. IANA는 이러한 모든 변경 사항을 기록하고 요청 시 제공합니다.\(MAY\)

7. IESG는 프로토콜 토큰에 대한 책임을 재할당할 수 있습니다. 이는 일반적으로 책임 있는 당사자에게 연락할 수 없는 경우에만 사용됩니다.\(MAY\)

HTTP 업그레이드 토큰에 대한 이 등록 절차는 이전에 \[RFC2817\]의 섹션 7.2에 정의된 절차를 대체합니다.

---
#### **8.6.2.  Upgrade Token Registration**

업그레이드 토큰 레지스트리의 "HTTP" 항목이 아래 등록으로 업데이트되었습니다.

```text
   +-------+----------------------+----------------------+-------------+
   | Value | Description          | Expected Version     | Reference   |
   |       |                      | Tokens               |             |
   +-------+----------------------+----------------------+-------------+
   | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | Section 2.6 |
   |       | Protocol             | (e.g, "2.0")         |             |
   +-------+----------------------+----------------------+-------------+
```

책임 당사자는 "IETF\(iesg@ietf.org\) - 인터넷 엔지니어링 태스크 포스"입니다.

---
## **9.  Security Considerations**

이 섹션은 개발자, 정보 제공자 및 사용자에게 HTTP 메시지 구문, 구문 분석 및 라우팅과 관련된 알려진 보안 고려 사항을 알리기 위한 것입니다. HTTP 의미 체계 및 페이로드에 대한 보안 고려 사항은 \[RFC7231\]에서 다룹니다.

---
### **9.1.  Establishing Authority**

HTTP는 권한 있는 응답이라는 개념에 의존합니다. 즉, 대상 URI 내에서 식별된 권한에 의해\(또는 해당 권한의 지시에 따라\) 결정된 응답은 당시 대상 리소스의 상태를 고려하여 해당 요청에 대한 가장 적절한 응답입니다. 응답 메시지 발생. 공유 캐시와 같이 신뢰할 수 없는 소스에서 응답을 제공하는 것은 성능과 가용성을 향상시키는 데 유용한 경우가 많지만, 소스를 신뢰할 수 있거나 신뢰할 수 없는 응답을 안전하게 사용할 수 있는 경우에만 가능합니다.

불행하게도 권위를 확립하는 것은 어려울 수 있습니다. 예를 들어, 피싱은 사용자의 권위에 대한 인식에 대한 공격으로, 유사한 브랜드를 제시하여 해당 인식을 오도할 수 있습니다.

권한 구성 요소를 난독화하는 userinfo의 도움을 받을 수 있는 하이퍼텍스트\(섹션 2.7.1 참조\) 사용자 에이전트는 사용자가 작업을 수행하기 전에 대상 URI를 쉽게 검사할 수 있도록 하고, 사용자 정보가 있는 경우 눈에 띄게 구별\(또는 거부\)하고, 참조 문서가 문서에서 온 경우 저장된 자격 증명과 쿠키를 보내지 않음으로써 피싱 공격의 영향을 줄일 수 있습니다. 알 수 없거나 신뢰할 수 없는 소스.

등록된 이름이 권한 구성 요소에서 사용되는 경우 "http" URI 체계\(섹션 2.7.1\)는 사용자의 로컬 이름 확인 서비스에 의존하여 신뢰할 수 있는 응답을 찾을 수 있는 위치를 결정합니다. 이는 사용자의 네트워크 호스트 테이블, 캐시된 이름 또는 이름 확인 라이브러리에 대한 모든 공격이 권한 설정에 대한 공격 수단이 된다는 것을 의미합니다. 마찬가지로 사용자가 DNS\(도메인 이름 서비스\)용 서버를 선택하는 것과 확인 결과를 얻는 서버 계층 구조가 주소 매핑의 신뢰성에 영향을 미칠 수 있습니다. DNS 보안 확장\(DNSSEC, \[RFC4033\]\)은 신뢰성을 향상시키는 한 가지 방법입니다.

더욱이, IP 주소를 획득한 후 "http" URI에 대한 권한을 설정하는 것은 인터넷 프로토콜 라우팅에 대한 공격에 취약합니다.

"https" 구성표\(섹션 2.7.2\)는 협상된 TLS 연결이 보안되고 클라이언트가 통신 서버의 ID가 대상 URI의 권한 구성 요소\(\[RFC2818\] 참조\) 이러한 검증을 올바르게 구현하는 것은 어려울 수 있습니다\(\[Georgiev\] 참조\).

---
### **9.2.  Risks of Intermediaries**

본질적으로 HTTP 중개자는 중간자이므로 중간자 공격의 기회를 나타냅니다. 중개자가 실행되는 시스템이 손상되면 심각한 보안 및 개인 정보 보호 문제가 발생할 수 있습니다. 중개자는 보안 관련 정보, 개별 사용자 및 조직에 대한 개인 정보, 사용자 및 콘텐츠 제공자 소유의 독점 정보에 액세스할 수 있습니다. 손상된 중개자 또는 보안 및 개인 정보 보호 고려 사항을 고려하지 않고 구현 또는 구성된 중개자는 광범위한 잠재적 공격을 수행하는 데 사용될 수 있습니다.

공유 캐시를 포함하는 중개자는 \[RFC7234\]의 섹션 8에 설명된 대로 캐시 중독 공격에 특히 취약합니다.

구현자는 설계 및 코딩 결정과 운영자에게 제공하는 구성 옵션\(특히 기본 구성\)이 개인 정보 보호 및 보안에 미치는 영향을 고려해야 합니다.

사용자는 중개자를 운영하는 사람보다 더 신뢰할 수 없다는 점을 인식해야 합니다. HTTP 자체로는 이 문제를 해결할 수 없습니다.

---
### **9.3.  Attacks via Protocol Element Length**

HTTP는 대부분 문자로 구분된 텍스트 필드를 사용하기 때문에 파서는 매우 긴\(또는 매우 느린\) 데이터 스트림 전송을 기반으로 하는 공격에 취약한 경우가 많습니다. 특히 구현 시 미리 정의된 길이가 없는 프로토콜 요소가 필요한 경우 더욱 그렇습니다.

상호 운용성을 촉진하기 위해 요청 라인\(섹션 3.1.1\) 및 헤더 필드\(섹션 3.2\)의 최소 크기 제한에 대한 구체적인 권장 사항이 제공됩니다. 이는 제한된 리소스를 사용한 구현에서도 지원되도록 선택된 최소 권장 사항입니다. 대부분의 구현에서는 훨씬 더 높은 제한을 선택할 것으로 예상됩니다.

서버는 요청 대상이 너무 긴\(\[RFC7231\]의 섹션 6.5.12\) 메시지 또는 너무 큰 요청 페이로드\(\[RFC7231\]의 섹션 6.5.11\)를 거부할 수 있습니다. 용량 제한과 관련된 추가 상태 코드는 HTTP \[RFC6585\] 확장으로 정의되었습니다.

수신자는 요청 방법, 응답 상태 문구, 헤더 필드 이름, 숫자 값 및 본문 청크를 포함하되 이에 국한되지 않는 다른 프로토콜 요소를 처리하는 범위를 신중하게 제한해야 합니다. 이러한 처리를 제한하지 않으면 버퍼 오버플로, 산술 오버플로 또는 서비스 거부 공격에 대한 취약성이 높아질 수 있습니다.

---
### **9.4.  Response Splitting**

응답 분할\(즉, CRLF 주입\)은 웹 사용에 대한 다양한 공격에 사용되는 일반적인 기술로, HTTP 메시지 프레이밍의 라인 기반 특성과 지속적인 연결에 대한 응답에 대한 요청의 정렬된 연결을 활용합니다\[Klein\]. 이 기술은 요청이 공유 캐시를 통과할 때 특히 해로울 수 있습니다.

응답 분할은 공격자가 나중에 디코딩되어 응답의 응답 헤더 필드 내에서 에코되는 요청의 일부 매개변수 내에서 인코딩된 데이터를 보낼 수 있는 서버\(일반적으로 애플리케이션 서버 내\)의 취약점을 악용합니다. 디코딩된 데이터가 응답이 종료된 것처럼 보이도록 조작된 경우

후속 응답이 시작되고 응답이 분할되었으며 명백한 두 번째 응답 내의 콘텐츠가 공격자에 의해 제어됩니다. 그런 다음 공격자는 동일한 영구 연결에 대해 다른 요청을 수행하고 수신자\(중개자 포함\)를 속여 분할의 두 번째 절반이 두 번째 요청에 대한 신뢰할 수 있는 응답이라고 믿도록 할 수 있습니다.

예를 들어, 요청 대상 내의 매개변수는 애플리케이션 서버에서 읽고 리디렉션 내에서 재사용될 수 있으며, 결과적으로 동일한 매개변수가 응답의 Location 헤더 필드에 에코됩니다. 매개 변수가 응용 프로그램에 의해 디코딩되고 응답 필드에 배치될 때 제대로 인코딩되지 않은 경우 공격자는 응용 프로그램의 단일 응답을 두 개 이상의 응답처럼 보이게 만드는 인코딩된 CRLF 옥텟 및 기타 콘텐츠를 보낼 수 있습니다.

응답 분할에 대한 일반적인 방어 방법은 인코딩된 CR 및 LF\(예: "%0D" 및 "%0A"\)처럼 보이는 데이터에 대한 요청을 필터링하는 것입니다. 그러나 이는 애플리케이션 서버가 문자 세트 트랜스코딩, XML 엔터티 변환, base64 디코딩, sprintf 재포맷 등과 같은 보다 모호한 데이터 변환이 아닌 URI 디코딩만 수행한다고 가정합니다. 더 효과적인 완화 방법은 서버의 핵심 프로토콜 라이브러리 이외의 다른 것을 방지하는 것입니다. 헤더 섹션 내에서 CR 또는 LF를 보내지 마십시오. 이는 헤더 필드의 출력을 잘못된 옥텟을 필터링하는 API로 제한하고 애플리케이션 서버가 프로토콜 스트림에 직접 쓰는 것을 허용하지 않음을 의미합니다.

---
### **9.5.  Request Smuggling**

요청 밀수\(\[Linhart\]\)는 명백히 무해한 요청 내에서 추가 요청\(정책에 의해 차단되거나 비활성화될 수 있음\)을 숨기기 위해 다양한 수신자 간의 프로토콜 구문 분석의 차이를 이용하는 기술입니다. 응답 분할과 마찬가지로 요청 밀수는 HTTP 사용에 대한 다양한 공격으로 이어질 수 있습니다.

이 사양에서는 요청 구문 분석, 특히 섹션 3.3.3의 메시지 프레이밍과 관련하여 요청 밀수의 효율성을 줄이기 위해 새로운 요구 사항을 도입했습니다.

---
### **9.6.  Message Integrity**

HTTP는 메시지 무결성을 보장하기 위한 특정 메커니즘을 정의하지 않고, 대신 기본 전송 프로토콜의 오류 감지 기능과 완전성을 감지하기 위한 길이 또는 청크로 구분된 프레이밍 사용에 의존합니다. 콘텐츠에 적용되는 해시 함수 또는 디지털 서명과 같은 추가적인 무결성 메커니즘은 확장 가능한 방식을 통해 선택적으로 메시지에 추가될 수 있습니다.

메타데이터 헤더 필드. 역사적으로 단일 무결성 메커니즘의 부족은 대부분의 HTTP 통신의 비공식적 특성으로 인해 정당화되었습니다. 그러나 정보 액세스 메커니즘으로 HTTP가 널리 보급됨에 따라 메시지 무결성 확인이 중요한 환경에서 HTTP의 사용이 증가했습니다.

사용자 에이전트는 무결성이 필요한 환경 내에서 이러한 수단을 활성화할 수 있도록 메시지 무결성 실패를 감지하고 보고하기 위한 구성 가능한 수단을 구현하는 것이 좋습니다. 예를 들어, 의료 기록이나 약물 상호 작용 정보를 보는 데 사용되는 브라우저는 전송 중에 해당 정보가 프로토콜에 의해 불완전하거나 만료되거나 손상된 것으로 감지되는 경우 사용자에게 이를 알려야 합니다. 이러한 메커니즘은 사용자 에이전트 확장이나 응답에 있는 메시지 무결성 메타데이터의 존재를 통해 선택적으로 활성화될 수 있습니다. 최소한 사용자 에이전트는 검증이 필요할 때 사용자가 완전한 응답 메시지와 불완전한 응답 메시지\(섹션 3.4\)를 구별할 수 있도록 하는 몇 가지 표시를 제공해야 합니다.

---
### **9.7.  Message Confidentiality**

HTTP는 원할 때 메시지 기밀성을 제공하기 위해 기본 전송 프로토콜을 사용합니다. HTTP는 전송 프로토콜과 독립되도록 특별히 설계되었습니다. 따라서 HTTP는 다양한 형태의 암호화된 연결을 통해 사용될 수 있으며, 이러한 전송 선택은 URI 체계 선택이나 사용자 에이전트 구성 내에서 식별됩니다.

섹션 2.7.2에 설명된 대로 "https" 구성표를 사용하여 기밀 연결이 필요한 리소스를 식별할 수 있습니다.

---
### **9.8.  Privacy of Server Log Information**

서버는 시간이 지남에 따라 사용자의 요청에 대한 개인 데이터를 저장할 수 있는 위치에 있으며, 이를 통해 사용자의 독서 패턴이나 관심 주제를 식별할 수 있습니다. 특히 중개자에서 수집된 로그 정보에는 개별 사용자를 추적할 수 있는 다수의 사이트에 걸친 사용자 에이전트 상호 작용 기록이 포함되는 경우가 많습니다.

HTTP 로그 정보는 본질적으로 기밀입니다. 그 취급은 법률과 규정에 의해 제한되는 경우가 많습니다. 로그 정보는 안전하게 저장되어야 하며 분석을 위해서는 적절한 지침을 따라야 합니다. 개별 항목 내의 개인 정보를 익명화하면 도움이 되지만 일반적으로 다른 액세스 특성과의 상관 관계를 기반으로 실제 로그 추적이 재식별되는 것을 방지하는 것만으로는 충분하지 않습니다. 따라서 특정 클라이언트에 대한 액세스 추적은 키가 가명인 경우에도 게시하는 것이 안전하지 않습니다.

도난이나 우발적인 게시의 위험을 최소화하려면 로그 정보에서 사용자 식별자, IP 주소, 사용자 제공 쿼리 매개변수를 포함한 개인 식별 정보를 삭제해야 합니다. 해당 정보가 보안에 대한 운영 요구 사항을 지원하는 데 더 이상 필요하지 않은 경우 , 감사 또는 사기 통제.

---
## **10.  Acknowledgments**

HTTP/1.1의 이번 버전은 이전 저자, 편집자 및 작업 그룹 의장인 Tim Berners-Lee, Ari Luotonen의 상당한 기여를 포함하여 RFC 1945, RFC 2068, RFC 2145 및 RFC 2616에 적용된 많은 기여를 기반으로 합니다. , Roy T. Fielding, Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter 및 Paul J. Leach. Mark Nottingham은 실무 그룹 의장으로서 이러한 노력을 감독했습니다.

1999년부터 다음 기여자들은 버그 보고, 스마트 질문 질문, 텍스트 초안 작성 또는 검토, 미해결 문제 평가를 통해 HTTP 사양을 개선하는 데 도움을 주었습니다.

```text
   Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole,
   Adrien W. de Croy, Alan Ford, Alan Ruttenberg, Albert Lunde, Alek
   Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha
   Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier,
   Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren,
   Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander
   Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin
   Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern
   Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, Brian Kell,
   Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens,
   Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann,
   Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus
   Daboo, Dale Robert Anderson, Dan Wing, Dan Winship, Daniel Stenberg,
   Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave
   Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty,
   Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan
   Adler, Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D.
   Williams, Eric J. Bowman, Eric Lawrence, Eric Rescorla, Erik
   Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian
   Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser,
   Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham,
   Gili Tzabari, Grahame Grieve, Greg Slepak, Greg Wilkins, Grzegorz
   Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik
   Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel,
   Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson, Ido
   Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll,
   James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie
```

Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges\('유효 요청-URI'라는 용어를 생각해낸 사람\), Jeff Pinner, Jeff Walden, Jim Luther, Jitu Padhye, Joe D. Williams, Joe Gregorio, Joe Orton, Joel Jaeggli , 존 C. 클렌신, 존 C. 말러리, 존 코완, 존 켐프, 존 팬저, 존 슈나이더, 존 스트라케, 존 설리번, 조나스 식킹, 조나단 A. 리스, 조나단 빌링턴, 조나단 무어, 조나단 실버라, 조르디 로스, 요리스 Dobbelsteen, Josh Cohen, Julien Pierre, 신정식, Justin Chapweske, Justin Erenkrantz, Justin James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault, Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler, Martin J. Duerst, Martin Musatov, Martin Nilsson, Martin Thomson, Matt Lynch, 매튜 콕스, 매튜 커윈, 맥스 클라크, 메나헴 닷지, 메랄 쉬라지푸르, 마이클 버로우즈, 마이클 하우젠블라스, 마이클 샤프, 마이클 스위트, 마이클 투엑센, 마이클 웰즐, 마이크 아문센, 마이크 벨쉬, 마이크 비숍, 마이크 켈리, 마이크 싱켈, 마일즈 사빈 , 머레이 S. 쿠체로위, 미키타 예브스티페예프, 네이선 릭스햄, 니콜라스 생크스, 니코 윌리엄스, 니콜라스 알바레즈, 니콜라스 메일핫, 노아 슬레이터, 오사마 마자히르, 파블로 카스트로, 팻 헤이즈, 패트릭 R. 맥마누스, 폴 E. 존스, 폴 호프만, 폴 마르케스, 피트 레스닉, 피터 레페스카, 피터 오실, 피터 세인트 앙드레, 피터 왓킨스, 필 아처, 필 헌트, 필립 무긴, 필립 할람-베이커, 피오트르 도브로고스트, 폴 헤닝 캠프, 프리티 나타라잔, 라지브 벡터, 레이 포크, 레토 바흐만-그무어, 리차드 반즈, 리차드 시가니악, 롭 트레이스, 로비 심슨, 로버트 브루어, 로버트 콜린스, 로버트 맷슨, 로버트 오캘라한, 로버트 올로프슨, 로버트 세이어, 로버트 시머, 로버트 드 와일드, 로베르토 하비에르 고도이, 로베르토 피온 , Roland Zink, Ronny Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence\(원래 이슈 목록을 유지한 사람\), Sean B. Palmer, Sean Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin, Stuart Williams, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares, Sylvain Hellegouarch, Tapan Divekar, 쓰지카와 타츠히로, 하야시 타츠야, 테드 하디, 테드 레몬, 토마스 브로이어, 토마스 포사티, 토마스 마슬렌, 토마스 나도, 토마스 노딘, 토마스 로슬러, 팀 브레이, 팀 모건, 팀 올슨, 톰 저우, 트래비스 스누지, 타일러 클로즈, 빈센트 머피 , Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang, Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang, Yuchung Cheng, Yutaka Oiwa, Yves Lafon\(오랜 편집팀 멤버\), Zed A. Shaw, Zhong Yu.

이전 개정에 대한 추가 승인은 \[RFC2616\]의 섹션 16을 참조하세요.

---
## **11.  References**
---
### **11.1.  Normative References**

```text
   [RFC0793]     Postel, J., "Transmission Control Protocol", STD 7,
                 RFC 793, September 1981.
```

\[RFC1950\] Deutsch, L. 및 J-L. Gailly, "ZLIB 압축 데이터 형식 사양 버전 3.3", RFC 1950, 1996년 5월.

```text
   [RFC1951]     Deutsch, P., "DEFLATE Compressed Data Format
                 Specification version 1.3", RFC 1951, May 1996.
```

\[RFC1952\] Deutsch, P., Gailly, J-L., Adler, M., Deutsch, L. 및 G. Randers-Pehrson, "GZIP 파일 형식 사양 버전 4.3", RFC 1952, 1996년 5월.

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타 내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC3986\] Berners-Lee, T., Fielding, R. 및 L. Masinter, "URI\(Uniform Resource Identifier\): 일반 구문", STD 66, RFC 3986, 2005년 1월.

\[RFC5234\] Crocker, D., Ed. 및 P. Overell, "구문 사양을 위한 보강된 BNF: ABNF", STD 68, RFC 5234, 2008년 1월.

\[RFC7231\] Fielding, R., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 의미 및 콘텐츠", RFC 7231, 2014년 6월.

\[RFC7232\] Fielding, R., Ed. 및 J. Reschke, Ed., "Hypertext Transfer Protocol\(HTTP/1.1\): 조건부 요청", RFC 7232, 2014년 6월.

\[RFC7233\] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 범위 요청", RFC 7233, 2014년 6월.

\[RFC7234\] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 캐싱", RFC 7234, 2014년 6월.

\[RFC7235\] Fielding, R., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 인증", RFC 7235, 2014년 6월.

\[USASCII\] 미국 국립 표준 협회\(American National Standards Institute\), "코드화된 문자 집합 - 정보 교환을 위한 7비트 미국 표준 코드", ANSI X3.4, 1986.

\[Welch\] Welch, T., "고성능 데이터 압축 기술", IEEE 컴퓨터 17\(6\), 1984년 6월.

---
### **11.2.  Informative References**

\[BCP115\] Hansen, T., Hardie, T. 및 L. Masinter, "새로운 URI 체계에 대한 지침 및 등록 절차", BCP 115, RFC 4395, 2006년 2월.

\[BCP13\] Freed, N., Klensin, J. 및 T. Hansen, "미디어 유형 사양 및 등록 절차", BCP 13, RFC 6838, 2013년 1월.

\[BCP90\] Klyne, G., Nottingham, M. 및 J. Mogul, "메시지 헤더 필드 등록 절차", BCP 90, RFC 3864, 2004년 9월.

```text
   [Georgiev]    Georgiev, M., Iyengar, S., Jana, S., Anubhai, R.,
                 Boneh, D., and V. Shmatikov, "The Most Dangerous Code
                 in the World: Validating SSL Certificates in Non-
                 browser Software", In Proceedings of the 2012 ACM
                 Conference on Computer and Communications Security (CCS
                 '12), pp. 38-49, October 2012,
                 <http://doi.acm.org/10.1145/2382196.2382204>.
```

\[ISO-8859-1\] 국제 표준화 기구, "정보 기술 - 8비트 단일 바이트 코드 그래픽 문자 세트 - 파트 1: 라틴 알파벳 No. 1", ISO/IEC 8859-1:1998, 1998.

```text
   [Klein]       Klein, A., "Divide and Conquer - HTTP Response
                 Splitting, Web Cache Poisoning Attacks, and Related
                 Topics", March 2004, <http://packetstormsecurity.com/
                 papers/general/whitepaper_httpresponse.pdf>.

   [Kri2001]     Kristol, D., "HTTP Cookies: Standards, Privacy, and
                 Politics", ACM Transactions on Internet
                 Technology 1(2), November 2001,
                 <http://arxiv.org/abs/cs.SE/0105018>.

   [Linhart]     Linhart, C., Klein, A., Heled, R., and S. Orrin, "HTTP
                 Request Smuggling", June 2005,
                 <http://www.watchfire.com/news/whitepapers.aspx>.
```

\[RFC1919\] Chatel, M., "클래식 IP 프록시 대 투명 IP 프록시", RFC 1919, 1996년 3월.

\[RFC1945\] Berners-Lee, T., Fielding, R. 및 H. Nielsen,

- "하이퍼텍스트 전송 프로토콜 - HTTP/1.0", RFC 1945, 1996년 5월.

\[RFC2045\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 1부: 인터넷 메시지 본문 형식", RFC 2045, 1996년 11월.

\[RFC2047\] Moore, K., "MIME\(다목적 인터넷 메일\)

- 확장\) 3부: 비ASCII 텍스트에 대한 메시지 헤더 확장", RFC 2047, 1996년 11월.

\[RFC2068\] Fielding, R., Gettys, J., Mogul, J., Nielsen, H. 및 T. Berners-Lee, "하이퍼텍스트 전송 프로토콜 - HTTP/1.1", RFC 2068, 1997년 1월.

\[RFC2145\] Mogul, J., Fielding, R., Gettys, J. 및 H. Nielsen, "HTTP 버전 번호의 사용 및 해석", RFC 2145, 1997년 5월.

\[RFC2616\] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, "하이퍼텍스트 전송 프로토콜 - HTTP/1.1" , RFC 2616, 1999년 6월.

\[RFC2817\] Khare, R. 및 S. Lawrence, "HTTP/1.1 내에서 TLS로 업그레이드", RFC 2817, 2000년 5월.

\[RFC2818\] Rescorla, E., "TLS를 통한 HTTP", RFC 2818, 2000년 5월.

\[RFC3040\] Cooper, I., Melve, I. 및 G. Tomlinson, "인터넷 웹 복제 및 캐싱 분류법", RFC 3040, 2001년 1월.

\[RFC4033\] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose, "DNS 보안 소개 및 요구 사항", RFC 4033, 2005년 3월.

\[RFC4559\] Jaganathan, K., Zhu, L. 및 J. Brezak, "Microsoft Windows의 SPNEGO 기반 Kerberos 및 NTLM HTTP 인증", RFC 4559, 2006년 6월.

\[RFC5226\] Narten, T. 및 H. Alvestrand, "RFC에서 IANA 고려 사항 섹션 작성 지침", BCP 26, RFC 5226, 2008년 5월.

\[RFC5246\] Dierks, T. 및 E. Rescorla, "TLS\(전송 계층 보안\) 프로토콜 버전 1.2", RFC 5246, 2008년 8월.

```text
   [RFC5322]     Resnick, P., "Internet Message Format", RFC 5322,
                 October 2008.

   [RFC6265]     Barth, A., "HTTP State Management Mechanism", RFC 6265,
                 April 2011.
```

\[RFC6585\] Nottingham, M. 및 R. Fielding, "추가 HTTP 상태 코드", RFC 6585, 2012년 4월.

---
# **Appendix A.  HTTP Version History**

HTTP는 1990년부터 사용되었습니다. 나중에 HTTP/0.9라고 불리는 첫 번째 버전은 메타데이터 없이 단일 요청 방법\(GET\)만 사용하여 인터넷을 통한 하이퍼텍스트 데이터 전송을 위한 간단한 프로토콜이었습니다. \[RFC1945\]에 정의된 대로 HTTP/1.0에는 다양한 요청 방법과 MIME 유사 메시징이 추가되어 메타데이터를 전송할 수 있고 요청/응답 의미 체계에 수정자를 배치할 수 있습니다. 그러나 HTTP/1.0은 계층적 프록시, 캐싱, 지속적인 연결의 필요성 또는 이름 기반 가상 호스트의 영향을 충분히 고려하지 않았습니다. 스스로를 "HTTP/1.0"이라고 부르는 불완전하게 구현된 응용 프로그램이 확산되면서 통신하는 두 응용 프로그램이 서로의 실제 기능을 확인하기 위해서는 프로토콜 버전 변경이 더욱 필요해졌습니다.

HTTP/1.1은 안정적인 구현을 가능하게 하는 보다 엄격한 요구 사항을 포함하고, HTTP/1.0 수신자가 안전하게 무시할 수 있거나 HTTP/1.1 광고 준수를 광고하는 당사자와 통신할 때만 전송될 수 있는 기능만 추가함으로써 HTTP/1.0과의 호환성을 유지합니다. .

HTTP/1.1은 이전 버전을 쉽게 지원할 수 있도록 설계되었습니다. 범용 HTTP/1.1 서버는 HTTP/1.0 형식의 모든 유효한 요청을 이해할 수 있어야 하며, HTTP/1.0 클라이언트가 이해하는\(또는 안전하게 무시하는\) 기능만 사용하는 HTTP/1.1 메시지로 적절하게 응답할 수 있어야 합니다. 마찬가지로, HTTP/1.1 클라이언트는 유효한 HTTP/1.0 응답을 이해할 것으로 예상할 수 있습니다.

HTTP/0.9는 요청의 헤더 필드를 지원하지 않았기 때문에 이름 기반 가상 호스트\(호스트 헤더 필드를 검사하여 리소스 선택\)를 지원하는 메커니즘이 없습니다. 이름 기반 가상 호스트를 구현하는 모든 서버는 HTTP/0.9에 대한 지원을 비활성화해야 합니다. HTTP/0.9로 보이는 대부분의 요청은 실제로 클라이언트가 요청 대상을 적절하게 인코딩하지 못하여 잘못 구성된 HTTP/1.x 요청입니다.

---
### **A.1.  Changes from HTTP/1.0**

이 섹션에서는 HTTP/1.0 버전과 HTTP/1.1 버전 간의 주요 차이점을 요약합니다.

---
#### **A.1.1.  Multihomed Web Servers**

클라이언트와 서버가 Host 헤더 필드\(섹션 5.4\)를 지원하고, HTTP/1.1 요청에서 누락된 경우 오류를 보고하고, 절대 URI를 허용해야 하는 요구 사항\(섹션 5.3\)은 HTTP/1.1에서 정의한 가장 중요한 변경 사항 중 하나입니다.

이전 HTTP/1.0 클라이언트는 IP 주소와 서버의 일대일 관계를 가정했습니다. 해당 요청이 전달된 IP 주소 외에 요청의 의도된 서버를 구별하기 위한 확립된 메커니즘이 없었습니다. Host 헤더 필드는 HTTP/1.1 개발 중에 도입되었으며 대부분의 HTTP/1.0 브라우저에서 신속하게 구현되었지만 완전한 채택을 보장하기 위해 모든 HTTP/1.1 요청에 추가 요구 사항이 적용되었습니다. 이 글을 쓰는 시점에서 대부분의 HTTP 기반 서비스는 요청 대상 지정을 위해 Host 헤더 필드에 의존합니다.

---
#### **A.1.2.  Keep-Alive Connections**

HTTP/1.0에서 각 연결은 요청 전에 클라이언트에 의해 설정되고 응답을 보낸 후 서버에 의해 닫힙니다. 그러나 일부 구현에서는 \[RFC2068\]의 섹션 19.7.1에 설명된 지속 연결의 명시적으로 협상된\("Keep-Alive"\) 버전을 구현합니다.

일부 클라이언트와 서버는 "Connection: keep-alive" 요청 헤더 필드를 사용하여 명시적으로 협상함으로써 지속적인 연결에 대한 이전 접근 방식과 호환되기를 원할 수 있습니다. 그러나 HTTP/1.0 영구 연결의 일부 실험적 구현에는 결함이 있습니다. 예를 들어, HTTP/1.0 프록시 서버가 연결을 이해하지 못하는 경우 해당 헤더 필드를 다음 인바운드 서버로 잘못 전달하여 연결이 중단될 수 있습니다.

시도된 솔루션 중 하나는 특히 프록시를 대상으로 하는 Proxy-Connection 헤더 필드를 도입하는 것이었습니다. 실제로는 프록시가 여러 계층에 배포되어 위에서 설명한 것과 동일한 문제가 발생하는 경우가 많기 때문에 이 작업도 실행 불가능했습니다.

결과적으로 클라이언트는 어떤 요청에서도 Proxy-Connection 헤더 필드를 보내지 않는 것이 좋습니다.

클라이언트는 또한 요청 시 Connection: keep-alive 사용을 신중하게 고려하는 것이 좋습니다. HTTP/1.0 서버와의 지속적인 연결을 활성화할 수 있지만 이를 사용하는 클라이언트는 "정지된" 요청\(클라이언트가 헤더 필드 전송을 중지해야 함을 나타냄\)에 대한 연결을 모니터링해야 하며, 이 메커니즘은 클라이언트에서 사용해서는 안 됩니다. 프록시가 사용되는 경우 모두.

---
#### **A.1.3.  Introduction of Transfer-Encoding**

HTTP/1.1에는 Transfer-Encoding 헤더 필드\(섹션 3.3.1\)가 도입되었습니다. MIME 호환 프로토콜을 통해 HTTP 메시지를 전달하기 전에 전송 코딩을 디코딩해야 합니다.

---
### **A.2.  Changes from RFC 2616**

```text
   HTTP's approach to error handling has been explained.  (Section 2.5)

   The HTTP-version ABNF production has been clarified to be case-
   sensitive.  Additionally, version numbers have been restricted to
   single digits, due to the fact that implementations are known to
   handle multi-digit version numbers incorrectly.  (Section 2.6)

   Userinfo (i.e., username and password) are now disallowed in HTTP and
   HTTPS URIs, because of security issues related to their transmission
   on the wire.  (Section 2.7.1)

   The HTTPS URI scheme is now defined by this specification;
   previously, it was done in Section 2.4 of [RFC2818].  Furthermore, it
   implies end-to-end security.  (Section 2.7.2)

   HTTP messages can be (and often are) buffered by implementations;
   despite it sometimes being available as a stream, HTTP is
   fundamentally a message-oriented protocol.  Minimum supported sizes
   for various protocol elements have been suggested, to improve
   interoperability.  (Section 3)

   Invalid whitespace around field-names is now required to be rejected,
   because accepting it represents a security vulnerability.  The ABNF
   productions defining header fields now only list the field value.
   (Section 3.2)

   Rules about implicit linear whitespace between certain grammar
   productions have been removed; now whitespace is only allowed where
   specifically defined in the ABNF.  (Section 3.2.3)

   Header fields that span multiple lines ("line folding") are
   deprecated.  (Section 3.2.4)

   The NUL octet is no longer allowed in comment and quoted-string text,
   and handling of backslash-escaping in them has been clarified.  The
   quoted-pair rule no longer allows escaping control characters other
   than HTAB.  Non-US-ASCII content in header fields and the reason
   phrase has been obsoleted and made opaque (the TEXT rule was
   removed).  (Section 3.2.6)

   Bogus Content-Length header fields are now required to be handled as
   errors by recipients.  (Section 3.3.2)
```

메시지 본문 길이를 결정하는 알고리즘은 메시지 본문 길이에 영향을 미치는 모든 특수 사례\(예: 메서드 또는 상태 코드에 의해 구동됨\)와 해당 새 프로토콜을 나타내도록 명확해졌습니다.

```text
   elements cannot define such special cases.  CONNECT is a new, special
   case in determining message body length. "multipart/byteranges" is no
   longer a way of determining message body length detection.
   (Section 3.3.3)

   The "identity" transfer coding token has been removed.  (Sections 3.3
   and 4)

   Chunk length does not include the count of the octets in the chunk
   header and trailer.  Line folding in chunk extensions is disallowed.
   (Section 4.1)

   The meaning of the "deflate" content coding has been clarified.
   (Section 4.2.2)

   The segment + query components of RFC 3986 have been used to define
   the request-target, instead of abs_path from RFC 1808.  The
   asterisk-form of the request-target is only allowed with the OPTIONS
   method.  (Section 5.3)

   The term "Effective Request URI" has been introduced.  (Section 5.5)

   Gateways do not need to generate Via header fields anymore.
   (Section 5.7.1)

   Exactly when "close" connection options have to be sent has been
   clarified.  Also, "hop-by-hop" header fields are required to appear
   in the Connection header field; just because they're defined as hop-
   by-hop in this specification doesn't exempt them.  (Section 6.1)

   The limit of two connections per server has been removed.  An
   idempotent sequence of requests is no longer required to be retried.
   The requirement to retry requests under certain circumstances when
   the server prematurely closes the connection has been removed.  Also,
   some extraneous requirements about when servers are allowed to close
   connections prematurely have been removed.  (Section 6.3)

   The semantics of the Upgrade header field is now defined in responses
   other than 101 (this was incorporated from [RFC2817]).  Furthermore,
   the ordering in the field value is now significant.  (Section 6.7)

   Empty list elements in list productions (e.g., a list header field
   containing ", ,") have been deprecated.  (Section 7)

   Registration of Transfer Codings now requires IETF Review
   (Section 8.4)

   This specification now defines the Upgrade Token Registry, previously
   defined in Section 7.2 of [RFC2817].  (Section 8.6)

   The expectation to support HTTP/0.9 requests has been removed.
   (Appendix A)

   Issues with the Keep-Alive and Proxy-Connection header fields in
   requests are pointed out, with use of the latter being discouraged
   altogether.  (Appendix A.1.2)
```

---
# **Appendix B.  Collected ABNF**

```text
   BWS = OWS

   Connection = *( "," OWS ) connection-option *( OWS "," [ OWS
    connection-option ] )

   Content-Length = 1*DIGIT

   HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body
    ]
   HTTP-name = %x48.54.54.50 ; HTTP
   HTTP-version = HTTP-name "/" DIGIT "." DIGIT
   Host = uri-host [ ":" port ]

   OWS = *( SP / HTAB )

   RWS = 1*( SP / HTAB )

   TE = [ ( "," / t-codings ) *( OWS "," [ OWS t-codings ] ) ]
   Trailer = *( "," OWS ) field-name *( OWS "," [ OWS field-name ] )
   Transfer-Encoding = *( "," OWS ) transfer-coding *( OWS "," [ OWS
    transfer-coding ] )

   URI-reference = <URI-reference, see [RFC3986], Section 4.1>
   Upgrade = *( "," OWS ) protocol *( OWS "," [ OWS protocol ] )

   Via = *( "," OWS ) ( received-protocol RWS received-by [ RWS comment
    ] ) *( OWS "," [ OWS ( received-protocol RWS received-by [ RWS
    comment ] ) ] )

   absolute-URI = <absolute-URI, see [RFC3986], Section 4.3>
   absolute-form = absolute-URI
   absolute-path = 1*( "/" segment )
   asterisk-form = "*"
   authority = <authority, see [RFC3986], Section 3.2>
   authority-form = authority

   chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
   chunk-data = 1*OCTET
   chunk-ext = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
   chunk-ext-name = token
   chunk-ext-val = token / quoted-string
   chunk-size = 1*HEXDIG
   chunked-body = *chunk last-chunk trailer-part CRLF
   comment = "(" *( ctext / quoted-pair / comment ) ")"
   connection-option = token
   ctext = HTAB / SP / %x21-27 ; '!'-'''
    / %x2A-5B ; '*'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text

   field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
   field-name = token
   field-value = *( field-content / obs-fold )
   field-vchar = VCHAR / obs-text
   fragment = <fragment, see [RFC3986], Section 3.5>

   header-field = field-name ":" OWS field-value OWS
   http-URI = "http://" authority path-abempty [ "?" query ] [ "#"
    fragment ]
   https-URI = "https://" authority path-abempty [ "?" query ] [ "#"
    fragment ]

   last-chunk = 1*"0" [ chunk-ext ] CRLF

   message-body = *OCTET
   method = token

   obs-fold = CRLF 1*( SP / HTAB )
   obs-text = %x80-FF
   origin-form = absolute-path [ "?" query ]

   partial-URI = relative-part [ "?" query ]
   path-abempty = <path-abempty, see [RFC3986], Section 3.3>
   port = <port, see [RFC3986], Section 3.2.3>
   protocol = protocol-name [ "/" protocol-version ]
   protocol-name = token
   protocol-version = token
   pseudonym = token

   qdtext = HTAB / SP / "!" / %x23-5B ; '#'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text
   query = <query, see [RFC3986], Section 3.4>
   quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )

   quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE

   rank = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )
   reason-phrase = *( HTAB / SP / VCHAR / obs-text )
   received-by = ( uri-host [ ":" port ] ) / pseudonym
   received-protocol = [ protocol-name "/" ] protocol-version
   relative-part = <relative-part, see [RFC3986], Section 4.2>
   request-line = method SP request-target SP HTTP-version CRLF
   request-target = origin-form / absolute-form / authority-form /
    asterisk-form

   scheme = <scheme, see [RFC3986], Section 3.1>
   segment = <segment, see [RFC3986], Section 3.3>
   start-line = request-line / status-line
   status-code = 3DIGIT
   status-line = HTTP-version SP status-code SP reason-phrase CRLF

   t-codings = "trailers" / ( transfer-coding [ t-ranking ] )
   t-ranking = OWS ";" OWS "q=" rank
   tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
    "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
   token = 1*tchar
   trailer-part = *( header-field CRLF )
   transfer-coding = "chunked" / "compress" / "deflate" / "gzip" /
    transfer-extension
   transfer-extension = token *( OWS ";" OWS transfer-parameter )
   transfer-parameter = token BWS "=" BWS ( token / quoted-string )

   uri-host = <host, see [RFC3986], Section 3.2.2>
```

---
# **Index**

ㅏ

- 절대 형식\(요청 대상\) 42 가속기 10 애플리케이션/http 미디어 유형 63 별표 형식\(요청 대상\) 43 권한 있는 응답 67 권한 형식\(요청 대상\) 42-43

```text
   B
      browser  7

   C
      cache  11
      cacheable  12
      captive portal  11
      chunked (Coding Format)  28, 32, 36
      client  7
      close  51, 56
      compress (Coding Format)  38
      connection  7
      Connection header field  51, 56
      Content-Length header field  30

   D
      deflate (Coding Format)  38
      Delimiters  27
      downstream  10

   E
      effective request URI  45

   G
      gateway  10
      Grammar
         absolute-form  42
         absolute-path  16
         absolute-URI  16
         ALPHA  6
         asterisk-form  41, 43
         authority  16
         authority-form  42-43
         BWS  25
         chunk  36
         chunk-data  36
         chunk-ext  36
         chunk-ext-name  36

         chunk-ext-val  36
         chunk-size  36
         chunked-body  36
         comment  27
         Connection  51
         connection-option  51
         Content-Length  30
         CR  6
         CRLF  6
         ctext  27
         CTL  6
         DIGIT  6
         DQUOTE  6
         field-content  23
         field-name  23, 40
         field-value  23
         field-vchar  23
         fragment  16
         header-field  23, 37
         HEXDIG  6
         Host  44
         HTAB  6
         HTTP-message  19
         HTTP-name  14
         http-URI  17
         HTTP-version  14
         https-URI  18
         last-chunk  36
         LF  6
         message-body  28
         method  21
         obs-fold  23
         obs-text  27
         OCTET  6
         origin-form  42
         OWS  25
         partial-URI  16
         port  16
         protocol-name  47
         protocol-version  47
         pseudonym  47
         qdtext  27
         query  16
         quoted-pair  27
         quoted-string  27
         rank  39
         reason-phrase  22
         received-by  47
```

수신 프로토콜 47

- 요청 라인 21 요청 대상 41 RWS 25 구성표 16 세그먼트 16 SP 6 시작 라인 21 상태 코드 22 상태 라인 22 t-코딩 39 t-순위 39 tchar 27 TE 39 토큰 27 트레일러 40 트레일러 부분 37 전송 -coding 35 전송 인코딩 28 전송 확장 35 전송 매개변수 35 업그레이드 57 uri-host 16 URI 참조 16 VCHAR 6 Via 47 gzip\(코딩 형식\) 39

```text
   H
      header field  19
      header section  19
      headers  19
      Host header field  44
      http URI scheme  17
      https URI scheme  17
   I
      inbound  9
      interception proxy  11
      intermediary  9

   M
      Media Type
         application/http  63
         message/http  62
      message  7
      message/http Media Type  62
      method  21

   N
      non-transforming proxy  49

   O
      origin server  7
      origin-form (of request-target)  42
      outbound  10

   P
      phishing  67
      proxy  10

   R
      recipient  7
      request  7
      request-target  21
      resource  16
      response  7
      reverse proxy  10

   S
      sender  7
      server  7
      spider  7

   T
      target resource  40
      target URI  40
      TE header field  39
      Trailer header field  40
      Transfer-Encoding header field  28
      transforming proxy  49
      transparent proxy  11
      tunnel  10

   U
      Upgrade header field  57
      upstream  9
      URI scheme
         http  17
         https  17
      user agent  7
```

V

- 헤더 필드 47을 통해

---
# **Authors' Addresses**

```text
   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   http://roy.gbiv.com/

   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   http://greenbytes.de/tech/webdav/
```
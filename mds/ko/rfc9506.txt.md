

```text
﻿

Internet Engineering Task Force (IETF)                       M. Cociglio
Request for Comments: 9506                          Telecom Italia - TIM
Category: Informational                                      A. Ferrieux
ISSN: 2070-1721                                              Orange Labs
                                                             G. Fioccola
                                                     Huawei Technologies
                                                             I. Lubashev
                                                     Akamai Technologies
                                                           F. Bulgarella
                                                                 M. Nilo
                                                    Telecom Italia - TIM
                                                            I. Hamchaoui
                                                             Orange Labs
                                                                R. Sisto
                                                   Politecnico di Torino
                                                            October 2023

         Explicit Host-to-Network Flow Measurements Techniques
```

---
# **Abstract**

이 문서에서는 클라이언트와 서버 간의 전송 계층 프로토콜에 적용할 수 있는 명시적 호스트-네트워크 흐름 측정 기술이라는 프로토콜 독립적인 방법을 설명합니다. 이러한 방법은 성능 측정을 위해 각 패킷의 헤더 내부에 몇 개의 표시 비트만 사용하며 클라이언트와 서버의 협력이 필요합니다. 두 끝점 모두 패킷을 표시하고 가능하면 왕복 연결의 표시를 미러링하여 협력합니다. 이 기술은 수동 경로 네트워크 장치에 의한 손실 및 지연 측정을 가능하게 하기 때문에 전송 헤더를 암호화하는 프로토콜에 적용할 때 특히 유용합니다. 이 문서에서는 마킹 비트의 가용성, 원하는 측정 및 방법이 적용되는 프로토콜의 속성에 따라 개별적으로 또는 함께 사용할 수 있는 여러 가지 방법을 설명합니다.

---
# **Status of This Memo**

이 문서는 인터넷 표준 추적 사양이 아닙니다. 정보 제공의 목적으로 게시됩니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. IESG에서 승인한 모든 문서가 모든 수준의 인터넷 표준에 적합한 것은 아닙니다. RFC 7841의 섹션 2를 참조하십시오.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9506에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2023 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
   2.  Latency Bits
     2.1.  Spin Bit
     2.2.  Delay Bit
       2.2.1.  Generation Phase
       2.2.2.  Reflection Phase
       2.2.3.  T_Max Selection
       2.2.4.  Delay Measurement Using the Delay Bit
         2.2.4.1.  RTT Measurement
         2.2.4.2.  Half-RTT Measurement
         2.2.4.3.  Intra-domain RTT Measurement
       2.2.5.  Observer's Algorithm
       2.2.6.  Two Bits Delay Measurement: Spin Bit + Delay Bit
   3.  Loss Bits
     3.1.  T Bit -- Round-Trip Loss Bit
       3.1.1.  Round-Trip Loss
       3.1.2.  Setting the Round-Trip Loss Bit on Outgoing Packets
       3.1.3.  Observer's Logic for Round-Trip Loss Signal
       3.1.4.  Loss Coverage and Signal Timing
     3.2.  Q Bit -- sQuare Bit
       3.2.1.  Q Block Length Selection
       3.2.2.  Upstream Loss
       3.2.3.  Identifying Q Block Boundaries
         3.2.3.1.  Improved Resilience to Burst Losses
     3.3.  L Bit -- Loss Event Bit
       3.3.1.  End-To-End Loss
         3.3.1.1.  Loss Profile Characterization
       3.3.2.  L+Q Bits -- Loss Measurement Using L and Q Bits
         3.3.2.1.  Correlating End-to-End and Upstream Loss
         3.3.2.2.  Downstream Loss
         3.3.2.3.  Observer Loss
     3.4.  R Bit -- Reflection Square Bit
       3.4.1.  Enhancement of Reflection Block Length Computation
       3.4.2.  Improved Resilience to Packet Reordering
         3.4.2.1.  Improved Resilience to Burst Losses
       3.4.3.  R+Q Bits -- Loss Measurement Using R and Q Bits
         3.4.3.1.  Three-Quarters Connection Loss
         3.4.3.2.  End-To-End Loss in the Opposite Direction
         3.4.3.3.  Half Round-Trip Loss
         3.4.3.4.  Downstream Loss
     3.5.  E Bit -- ECN-Echo Event Bit
       3.5.1.  Setting the ECN-Echo Event Bit on Outgoing Packets
       3.5.2.  Using E Bit for Passive ECN-Reported Congestion
               Measurement
       3.5.3.  Multiple E Bits
   4.  Summary of Delay and Loss Marking Methods
     4.1.  Implementation Considerations
   5.  Examples of Application
   6.  Protocol Ossification Considerations
   7.  Security Considerations
     7.1.  Optimistic ACK Attack
     7.2.  Delay Bit with RTT Obfuscation
   8.  Privacy Considerations
   9.  IANA Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Acknowledgments
   Contributors
   Authors' Addresses
```

---
## **1.  Introduction**

패킷 손실 및 지연은 일상적인 네트워크 운영에서 어렵고 만연한 문제입니다. 높은 QoS를 유지하고 엔드투엔드 처리량 문제를 적시에 해결하려면 이를 사전에 감지하고 측정하고 찾아내는 것이 중요합니다.

패킷 손실 및 지연을 감지하고 측정하면 네트워크 운영자는 문제 보고서를 독립적으로 확인할 수 있으며 이상적으로는 네트워크에서 발생하는 문제를 사전에 알릴 수 있습니다. 패킷 손실이나 과도한 지연의 원인을 찾는 것이 문제 해결 및 QoS 복원의 첫 번째 단계입니다.

패킷 손실 및 지연을 정량적으로 측정하려는 네트워크 운영자는 전송 계층 헤더에 있는 일반 정보\(예: TCP 시퀀스 및 승인 번호\)에 크게 의존해 왔습니다. 네트워크 내의 여러 지점에서 네트워크 경로를 수동적으로 관찰함으로써 운영자는 네트워크 내에서 문제의 원인을 신속하게 찾거나 문제의 원인을 업스트림 또는 다운스트림 네트워크에 확실하게 돌릴 수 있었습니다.

암호화된 프로토콜을 사용하면 전송 계층 헤더가 암호화되며 \[TRANSPORT-ENCRYPT\]에 명시된 대로 수동 패킷 손실 및 지연 관찰이 불가능합니다. 그럼에도 불구하고 암호화된 전송 계층 프로토콜에서 발생하는 패킷 손실 및 지연을 정확하게 측정하는 것은 특히 클라이언트와 서버 간의 인프라를 소유하거나 제어하는 ​​네트워크 운영자에게 매우 요구됩니다.

암호화된 프로토콜을 사용하는 연결에서 발생하는 손실 및 지연 측정은 암호화되지 않은 프로토콜을 사용하는 동일하거나 유사한 엔드포인트 간의 연결에서 발생하는 손실 및 지연 측정을 기반으로 할 수 없습니다. 네트워크. 따라서 암호화된 프로토콜 사용자가 경험하는 패킷 손실 및 지연을 직접 측정할 필요가 있습니다.

대체 표시 방법\[AltMark\]은 실시간 트래픽에서 패킷 손실, 지연 및 지터 측정을 수행하는 통합 방법을 정의합니다. 그러나 \[IPv6AltMark\]에서 언급한 바와 같이 \[AltMark\]는 주로 NMS\(Network Management System\)로 관리되는 네트워크 계층 제어 도메인에 적용되며, 여기서 CPE\(Customer Premises Equipment\) 또는 PE\(Provider Edge\) 라우터는 시작 또는 끝 노드. \[AltMark\]는 패킷이 표시된 제어된 도메인 내에서 측정을 제공합니다. 따라서 암호화된 전송 계층 헤더\(예: QUIC, TLS가 포함된 TCP\)가 사용되는 경우 네트워크 노드에 의한 패킷 식별 및 표시가 방지되기 때문에 종단 간 전송 계층 연결에 \[AltMark\]를 적용하는 것은 쉽지 않습니다.

이 문서는 암호화된 전송 프로토콜을 위해 특별히 설계된 명시적인 호스트-네트워크 흐름 측정 기술을 정의합니다. 이러한 측정 방법은 \[IPPM-METHODS\]의 정의에 따라 Hybrid로 분류될 수 있습니다. 이는 전송 계층 프로토콜에 내장되며 경로상의 측정 장치에 지연 및 손실률 정보를 노출하기 위한 것입니다. \[AltMark\]와 달리 이러한 방법의 대부분에는 협업 엔드포인트 노드가 필요합니다. 이러한 측정 기술은 성능 정보를 경로에 직접 표시하므로 외부 NMS에 의존하지 않습니다.

이 문서에 설명된 명시적인 호스트-네트워크 흐름 측정 기술은 클라이언트와 서버를 연결하는 모든 전송 계층 프로토콜에 적용 가능합니다. 이 문서에서는 클라이언트와 서버를 전송 계층 프로토콜의 끝점이라고도 합니다.

이 문서에 설명된 다양한 방법을 단독으로 또는 조합하여 사용할 수 있습니다. 각 기술은 몇 개의 비트를 사용하고 특정 측정값을 노출합니다. 측정 측면에서 엔드포인트는 협력적이라고 ​​가정합니다. 실제로 클라이언트와 서버 모두 협력해야 합니다.

경로 신호를 명시적으로 만드는 \[RFC8558\]의 권장 사항에 따라 이 문서에서는 전송 프로토콜 헤더의 명확한 부분에 일부 전용 측정 비트를 추가할 것을 제안합니다. 이러한 비트는 전송 계층 헤더의 암호화되지 않은 부분\(예: UDP 잉여 공간\(\[UDP-OPTIONS\] 및 \[UDP-SURPLUS\] 참조\) 또는 QUIC v1 헤더의 예약된 비트\)에 추가될 수 있습니다. 스핀 비트\(\[QUIC-TRANSPORT\]의 섹션 17.4 참조\). 이 문서에서는 특정 비트의 사용을 권장하지 않습니다. 이는 특정 프로토콜 구현에 따라 선택되어야 하기 때문입니다\(섹션 5 참조\).

이 문서에 설명된 스핀 비트, 지연 비트 및 손실 비트는 \[AltMark\], \[QUIC-MANAGEABILITY\], \[QUIC-SPIN\], \[TSVWG-SPIN\] 및 \[IPPM-SPIN\]에서 영감을 받았습니다.

QUIC의 성능 측정에 대한 자세한 내용은 문서 \[ANRW19-PM-QUIC\]에 설명되어 있습니다.

---
## **2.  Latency Bits**

이 섹션에서는 왕복 대기 시간 측정에 사용할 수 있는 비트를 소개합니다. 사양의 이 섹션에서 패킷을 언급할 때마다 대기 시간 비트를 포함하는 프로토콜 헤더가 있는 패킷만 언급합니다.

\[QUIC-TRANSPORT\]에서 섹션 17.4는 RTT의 하이브리드 측정을 위한 명시적인 흐름별 전송 계층 신호를 소개합니다. 이 신호는 RTT당 한 번씩 토글되는 스핀 비트로 구성됩니다. \[QUIC-SPIN\]의 섹션 4에서는 스핀 비트의 손실 및 재정렬을 보상하고 이상적이지 않은 네트워크 조건에서 신호의 충실도를 높이기 위한 추가 2비트 유효 에지 카운터\(VEC\)에 대해 설명합니다.

이 문서에서는 수동 관찰자가 네트워크 흐름의 RTT를 측정하는 데 사용할 수 있는 독립형 단일 비트 지연 신호를 소개하여 네트워크 상태가 악화되자마자 발생하는 스핀 비트 모호성을 방지합니다.

---
### **2.1.  Spin Bit**

이 섹션은 스핀 비트 작동 메커니즘을 간략히 요약한 것입니다. 알고리즘에 대한 포괄적인 설명은 \[QUIC-MANAGEABILITY\]의 섹션 3.8.2를 참조하세요.

Spin 비트는 Alternate-Marking \[AltMark\]에 의해 생성된 신호로, 교대 크기는 RTT마다 비행 크기에 따라 변경됩니다.

레이턴시 스핀 비트는 RTT당 한 번 토글되는 단일 비트 신호로, 중간 관찰 지점에서 연결 지향 통신의 레이턴시 모니터링을 가능하게 합니다.

"스핀 비트 기간"은 하나의 RTT 시간 간격 동안 전송된 동일한 스핀 비트 값을 갖는 패킷 세트입니다. "스핀 비트 주기 값"은 스핀 비트 주기의 모든 패킷이 공유하는 스핀 비트 값입니다.

클라이언트와 서버는 나가는 패킷에 스핀 비트를 설정하는 데 사용되는 내부 연결별 스핀 값\(예: 0 또는 1\)을 유지 관리합니다. 새 연결이 시작되면 두 끝점 모두 스핀 값을 0으로 초기화합니다. 그 다음에:

\* 클라이언트가 지금까지 본 패킷 번호보다 큰 패킷 번호를 가진 패킷을 수신하면 연결 스핀 값을 수신된 패킷에 포함된 반대 값으로 설정합니다. 그리고

\* 서버가 지금까지 확인된 패킷 번호보다 큰 패킷 번호를 가진 패킷을 수신하면 연결 스핀 값을 수신된 패킷에 포함된 값과 동일하게 설정합니다.

계산된 회전 값은 나가는 패킷에 회전 비트를 설정하기 위해 끝점에서 사용됩니다. 이 메커니즘을 통해 끝점은 동일한 방향에서 관찰된 연속 에지 쌍 사이의 시간 거리를 측정하여 수동 경로 관찰자가 해당 네트워크 흐름의 왕복 네트워크 지연을 계산할 수 있도록 구형파를 생성할 수 있습니다.

스핀 비트는 트래픽 흐름의 단일 방향을 관찰하여 왕복 대기 시간 측정을 가능하게 합니다.

패킷 재정렬로 인해 수정을 위해 휴리스틱이 필요한 허위 에지가 발생할 수 있습니다. 섹션 2.2에 설명된 대로 네트워크 장애가 발생하는 즉시 스핀 비트 성능이 저하됩니다.

---
### **2.2.  Delay Bit**

지연 비트는 어려운 네트워크 조건에서 스핀 비트가 경험하는 정확도 제한을 극복하도록 설계되었습니다.

```text
   *  packet reordering leads to generation of spurious edges and errors
      in delay estimation;
```

\* 에지 손실로 인해 스핀 비트 기간이 잘못 추정되어 잘못된 RTT 측정이 발생합니다. 그리고

\* 애플리케이션이 제한된 발신자는 Spin 비트가 네트워크 지연 대신 애플리케이션 지연을 측정하도록 합니다.

네트워크에서 전송되는 모든 패킷에 설정되는 스핀 비트와 달리 지연 비트는 왕복당 한 번만 설정됩니다.

지연 비트를 사용하면 표시된 비트\(지연 비트\)가 있는 단일 패킷이 전체 연결 수명 동안 클라이언트와 서버 간에 바운스됩니다. 이 단일 패킷을 "지연 샘플"이라고 합니다.

중간 지점에 위치한 관찰자는 트래픽의 단일 방향을 관찰하고 지연 샘플과 상대 타임스탬프를 추적하여 연결의 왕복 지연을 측정할 수 있습니다.

지연 샘플 수명은 초기화와 반사라는 두 단계로 구성됩니다. 초기화는 지연 샘플의 생성이고, 반사는 두 끝점 사이에서 이 단일 패킷의 바운스 동작을 실현합니다.

다음 그림은 기본 지연 비트 메커니즘을 설명합니다.

```text
                 +--------+   -   -   -   -   -   +--------+
                 |        |      ----------->     |        |
                 | Client |                       | Server |
                 |        |     <-----------      |        |
                 +--------+   -   -   -   -   -   +--------+
```

- \(a\) 처음에는 트래픽이 없습니다.

```text
                 +--------+   0   0   1   -   -   +--------+
                 |        |      ----------->     |        |
                 | Client |                       | Server |
                 |        |     <-----------      |        |
                 +--------+   -   -   -   -   -   +--------+
```

\(b\) 클라이언트는 데이터 전송을 시작하고 설정합니다.

- 첫 번째 패킷은 지연 샘플입니다.

```text
                 +--------+   0   0   0   0   0   +--------+
                 |        |      ----------->     |        |
                 | Client |                       | Server |
                 |        |     <-----------      |        |
                 +--------+   -   -   -   1   0   +--------+
```

\(c\) 서버가 데이터 전송을 시작합니다.

- 지연 샘플을 반영합니다.

```text
                 +--------+   0   1   0   0   0   +--------+
                 |        |      ----------->     |        |
                 | Client |                       | Server |
                 |        |     <-----------      |        |
                 +--------+   0   0   0   0   0   +--------+
```

- \(d\) 클라이언트는 지연 샘플을 반영합니다.

```text
                 +--------+   0   0   0   0   0   +--------+
                 |        |      ----------->     |        |
                 | Client |                       | Server |
                 |        |     <-----------      |        |
                 +--------+   0   0   0   1   0   +--------+
```

\(e\) 서버는 지연 샘플을 반영합니다.

-                 등등.

```text
                       Figure 1: Delay Bit Mechanism
```

---
#### **2.2.1.  Generation Phase**

클라이언트만이 생성 단계에 적극적으로 참여합니다. 지연 샘플이 전송될 때마다 업데이트되는 내부 흐름별 타임스탬프 변수\(ds\_time\)를 유지합니다.

연결이 시작되면 클라이언트는 첫 번째 나가는 패킷의 지연 비트를 1로 초기화하는 새로운 지연 샘플을 생성합니다. 그런 다음 전송 타임스탬프로 ds\_time 변수를 업데이트합니다.

서버는 연결 시작 시 지연 비트를 0으로 초기화하며 연결 ​​중 유일한 작업은 섹션 2.2.2에 설명되어 있습니다.

네트워크 장애가 없는 경우 지연 샘플은 전체 연결 기간 동안 클라이언트와 서버 간에 지속적으로 반송되어야 합니다. 그러나 다음 두 가지 이유로 그럴 가능성은 거의 없습니다.

1. 지연 비트를 전달하는 패킷이 손실될 수 있습니다.

2. 애플리케이션이 전송되는 트래픽 양을 제한하고 있기 때문에 엔드포인트는 패킷 전송을 중지하거나 지연할 수 있습니다.

이러한 문제를 해결하기 위해 클라이언트는 마지막 지연 샘플 전송\(반사 포함\) 이후 미리 정해진 시간\(T\_Max\) 이상이 경과한 경우 새로운 지연 샘플을 생성합니다. T\_Max는 네트워크에서 측정 가능한 최대 RTT보다 커야 합니다. 자세한 내용은 섹션 2.2.3을 참조하세요.

---
#### **2.2.2.  Reflection Phase**

리플렉션은 클라이언트와 서버 사이에서 지연 샘플의 바운싱을 가능하게 하는 프로세스입니다. 두 끝점의 동작은 거의 동일합니다.

\* 서버 측 반사: 지연 샘플이 도착하면 서버는 반대 방향의 첫 번째 패킷을 지연 샘플로 표시합니다.

\* 클라이언트 측 반사: 지연 샘플이 도착하면 클라이언트는 반대 방향의 첫 번째 패킷을 지연 샘플로 표시합니다. 또한 나가는 지연 샘플이 실제로 전달될 때 ds\_time 변수를 업데이트합니다.

두 경우 모두, 들어오는 지연 샘플\(기본값은 1ms\)을 수신한 후 나가는 지연 샘플이 미리 정해진 임계값보다 큰 지연으로 전송되는 경우 지연 샘플은 반영되지 않으며 나가는 지연 비트는 다음과 같이 유지됩니다. 0.

이렇게 하면 알고리즘은 엔드포인트의 트래픽 부족으로 인한 지연을 과대평가하는 측정을 거부할 수 있습니다. 따라서 최대 추정 오류는 측정당 임계값\(예: 2ms\)의 두 배에 달합니다.

---
#### **2.2.3.  T_Max Selection**

내부 ds\_time 변수를 사용하면 클라이언트가 지연 샘플 손실을 식별할 수 있습니다. 손실된 지연 샘플이 마지막 생성 이후 명시적 시간\(T\_Max\)이 끝날 때 재생성된다는 점을 고려하면 관찰자는 이 동일한 값을 사용하여 측정을 거부하고 새 측정을 시작할 수 있습니다.

즉, 두 지연 샘플 간의 시간 차이가 T\_Max보다 크거나 같으면 이를 지연 측정을 생성하는 데 사용할 수 없습니다. 따라서 T\_Max 값은 경로상의 네트워크 프로브에도 알려져야 합니다.

클라이언트와 관찰자 모두가 알 수 있도록 T\_Max 값을 선택하는 데는 두 가지 대안이 있습니다. 첫 번째는 T\_Max가 선험적으로 알려져 있어야 하고\(T\_Max\_p\) 마킹 메커니즘을 구현하는 프로토콜 사양 내에서 설정되어야 합니다\(예: 1초는 일반적으로 최대 예상 RTT보다 큽니다\). 두 번째 대안은 T\_Max의 지속 시간을 연결 지연\(T\_Max\_c\)에 적응시킬 수 있는 동적 메커니즘이 필요합니다.

예를 들어, 클라이언트와 관찰자는 연결 RTT를 유효 T\_Max 계산을 위한 기초로 사용할 수 있습니다. T\_Max = T\_Max\_p\(예: 1초\)가 되도록 미리 정해진 초기값을 사용해야 하며, 유효한 RTT가 측정되면 그에 따라 T\_Max = T\_Max\_c가 되도록 T\_Max를 변경해야 합니다. 어떤 경우든 선택한 T\_Max는 연결 지연의 가능한 변화를 흡수할 수 있을 만큼 커야 합니다. 이는 또한 관찰자가 T\_Max를 초과하는 RTT의 갑작스러운 변화를 인식할 수 없을 때 메커니즘이 실패하는 것을 방지하는 데 도움이 됩니다.

T\_Max\_c는 매우 작은 RTT의 경우 낮은 T\_Max 값을 방지하기 위해 측정된 RTT의 2배에 고정된 시간\(100ms\)을 더한 값으로 계산할 수 있습니다. 결과 공식은 T\_Max\_c = 2RTT + 100ms입니다. T\_Max\_c가 T\_Max\_p보다 크면 T\_Max\_c는 T\_Max\_p 값으로 강제 설정됩니다. 100ms 값은 예시로 제공되며 특정 시나리오에 따라 다르게 선택될 수 있습니다. 예를 들어, 구현자는 적절한 경우 기존 프로토콜별 값을 사용하는 것을 고려할 수 있습니다.

실제로 클라이언트의 T\_Max가 무엇인지 유효한 측정으로 간주하지 않으려면 관찰자의 T\_Max는 항상 클라이언트의 T\_Max보다 작거나 같아야 합니다. 이 결과를 얻기 위해 클라이언트는 두 개의 연속 수신 샘플을 기다리고 두 개의 관련 RTT를 계산합니다. 그런 다음 T\_Max\_c 공식의 기초로 가장 큰 값을 사용합니다. 이 시점에서 관찰자는 이미 유효한 RTT를 측정한 다음 T\_Max\_c를 계산했습니다.

---
#### **2.2.4.  Delay Measurement Using the Delay Bit**

지연 비트가 사용되면 수동 관찰자는 지연 샘플을 직접 사용할 수 있으며 스핀 비트 분석에서 볼 수 있듯이 RTT 계산에 내재된 모호성을 피할 수 있습니다.

---
##### **2.2.4.1.  RTT Measurement**

지연 샘플 생성 프로세스에서는 지연 비트가 1로 설정된 하나의 패킷만 왕복 시간당 두 끝점 사이를 오가며 실행되도록 합니다. 흐름의 RTT 측정을 결정하기 위해 경로상의 수동 관찰자는 단일 방향에서 관찰된 두 지연 샘플 간의 시간 차이를 계산합니다.

유효한 측정을 보장하려면 관찰자는 고려된 두 샘플 사이의 시간 거리가 T\_Max보다 작은지 확인해야 합니다.

```text
              =======================|======================>
              = **********     -----Obs---->     ********** =
              = * Client *                       * Server * =
              = **********     <------------     ********** =
              <==============================================

                        (a) client-server RTT

              ==============================================>
              = **********     ------------>     ********** =
              = * Client *                       * Server * =
              = **********     <----Obs-----     ********** =
              <======================|=======================

                        (b) server-client RTT

                Figure 2: Round-Trip Time (Both Directions)
```

---
##### **2.2.4.2.  Half-RTT Measurement**

순방향 및 복귀 트래픽 방향을 모두 관찰할 수 있는 관찰자는 지연 샘플을 사용하여 "업스트림" 및 "다운스트림" RTT 구성요소\(반RTT 측정이라고도 함\)를 측정할 수 있습니다. 한 방향에서 관찰된 지연 샘플과 이전에 반대 방향에서 관찰된 지연 샘플 사이의 시간을 측정하여 이를 수행합니다.

RTT 측정과 마찬가지로 관찰자는 고려된 두 샘플 간의 시간 거리가 T\_Max보다 작은지 확인해야 합니다.

엔드포인트와 관찰자 사이 경로의 업스트림 및 다운스트림 섹션\(즉, 관찰자에서 클라이언트로 vs. 클라이언트에서 관찰자, 관찰자에서 서버로 vs. 서버에서 관찰자\)은 다음으로 인해 지연 특성이 다를 수 있습니다. 네트워크 정체 및 기타 요인의 차이.

```text
              =======================>
              = **********     ------|----->     **********
              = * Client *          Obs          * Server *
              = **********     <-----|------     **********
              <=======================

                     (a) client-observer half-RTT

                                     =======================>
                **********     ------|----->     ********** =
                * Client *          Obs          * Server * =
                **********     <-----|------     ********** =
                                     <=======================

                     (b) observer-server half-RTT

              Figure 3: Half Round-Trip Time (Both Directions)
```

---
##### **2.2.4.3.  Intra-domain RTT Measurement**

도메인 내 RTT는 공급자의 네트워크를 통과하기 위해 흐름에서 사용되는 전체 RTT의 일부입니다. 도메인 내 RTT를 측정하려면 측정할 네트워크의 수신 및 송신 시 양방향 트래픽을 관찰할 수 있는 두 명의 관찰자를 동시에 사용해야 합니다. 도메인 내 RTT는 계산된 두 업스트림\(또는 다운스트림\) RTT 구성 요소 간의 차이입니다.

```text
           =========================================>
           = =====================>
           = = **********      ---|-->           ---|-->      **********
           = = * Client *         Obs               Obs       * Server *
           = = **********      <--|---           <--|---      **********
           = <=====================
           <=========================================

                    (a) client-observer RTT components (half-RTTs)

                                  ==================>
               **********      ---|-->           ---|-->      **********
               * Client *         Obs               Obs       * Server *
               **********      <--|---           <--|---      **********
                                  <==================
```

\(b\) 다음으로 인한 도메인 내 RTT

- 위의 RTT 구성 요소 빼기

```text
     Figure 4: Intra-domain Round-Trip Time (Client-Observer: Upstream)
```

---
#### **2.2.5.  Observer's Algorithm**

경로상 관찰자는 마지막 지연 샘플이 관찰된 시간을 추적하기 위해 내부 흐름별 변수를 유지합니다. 흐름 특성화는 프로토콜의 일부여야 합니다.

관찰자가 단방향이거나 비대칭 라우팅의 경우 지연 샘플을 감지하면 다음이 수행됩니다.

\* 이전에 동일한 방향에서 지연 샘플이 감지되었고 그 사이의 시간 거리가 T\_Max - K보다 작은 경우 두 지연 샘플을 사용하여 RTT 측정을 계산할 수 있습니다. K는 T\_Max 계산의 차이와 두 개의 연속 지연 샘플 간의 지연 변동을 흡수하는 보호 임계값입니다\(예: K = 10% T\_Max\).

관찰자가 순방향 및 반환 트래픽 흐름을 모두 관찰할 수 있고 어느 방향에 클라이언트와 서버가 포함되어 있는지 확인할 수 있는 경우\(예: 연결 핸드셰이크를 관찰하여\) 지연 샘플을 감지하면 다음이 수행됩니다.

\* 반대 방향에서도 지연 샘플이 감지되고 그 사이의 시간 거리가 T\_Max - K보다 작은 경우 두 지연 샘플을 사용하여 관찰자-클라이언트 반 RTT 또는 관찰자-서버 반 RTT를 측정할 수 있습니다. 관찰된 마지막 지연 샘플의 방향에 따른 RTT.

관찰자가 무엇을 관찰할 수 있는지에 따라 정확도가 영향을 받을 수 있다는 점에 유의하세요. 또한 이전 섹션에서 설명한 대로 측정 유형도 다릅니다.

---
#### **2.2.6.  Two Bits Delay Measurement: Spin Bit + Delay Bit**

Spin 및 Delay 비트 알고리즘은 독립적으로 작동합니다. 두 가지 표시 방법이 동일한 연결에서 사용되는 경우 관찰자는 사용 가능한 두 가지 중에서 가장 적합한 측정을 선택할 수 있습니다.

\* 지연 비트를 사용하여 정확한 측정이 가능하면 관찰자는 이를 선택합니다. 그리고

\* 지연 비트 측정을 사용할 수 없는 경우 관찰자는 대략적인 스핀 비트를 선택합니다.

---
## **3.  Loss Bits**

이 섹션에서는 손실 측정에 사용할 수 있는 비트를 소개합니다. 사양의 이 섹션이 패킷을 언급할 때마다 손실 비트를 포함하는 프로토콜 헤더가 있는 패킷, 즉 손실을 측정할 수 있는 유일한 패킷만 언급합니다.

T: "왕복 손실" 비트는 왕복 손실을 측정하기 위해 Spin 비트와 함께 사용됩니다. 섹션 3.1을 참조하세요.

Q: "sQuare" 비트는 업스트림 손실을 측정하는 데 사용됩니다. 보다

- 섹션 3.2.

L: "손실 이벤트" 비트는 종단 간 손실을 측정하는 데 사용됩니다. 섹션 3.3을 참조하세요.

R: "반사 사각형" 비트는 Q 비트와 함께 사용되어 종단 간 손실을 측정합니다. 섹션 3.4를 참조하세요.

T, Q 및 L 비트를 통해 지원되는 손실 측정은 해당 손실 비트만으로 구현할 수 있습니다\(T 비트에는 작동하는 Spin 비트가 필요함\). 2비트 조합 Q+L과 Q+R은 아래에서 설명하는 추가 측정 기회를 가능하게 합니다.

각 엔드포인트는 식별 가능한 각 흐름\(또는 다중 경로 연결의 경우 각 하위 흐름\)에 대해 독립적으로 개별적으로 적절한 카운터를 유지 관리합니다.

손실은 각 흐름에 대해 독립적으로 보고되므로 모든 비트\(L 비트 제외\)에서는 신호를 측정하기 전에 흐름당 교환할 특정 최소 수의 패킷이 필요합니다. 따라서 손실 측정은 최소 양 이상의 데이터를 전송하는 흐름에 가장 적합합니다.

---
### **3.1.  T Bit -- Round-Trip Loss Bit**

왕복 손실 비트는 두 번의 왕복 반사를 실현하는 끝점 간에 두 번 교환되는 다양한 수의 패킷을 표시하는 데 사용됩니다. 어느 방향이든 관찰하는 수동 경로 관찰자는 두 번의 반사 중에 표시된 표시된 패킷 수를 계산하고 비교하여 연결에서 발생하는 손실률을 추정할 수 있습니다. 전체 교환은 다음으로 구성됩니다.

```text
   *  the client selects and consequently sets the T bit to 1 in order
      to identify a first train of packets;

   *  upon receiving each packet included in the first train, the server
      sets the T bit to 1 and reflects to the client a respective second
      train of packets of the same size as the first train received;
```

\* 두 번째 열차에 포함된 각 패킷을 수신하면 클라이언트는 T 비트를 1로 설정하고 수신된 두 번째 열차와 동일한 크기의 각 세 번째 패킷 열차를 서버에 반영합니다. 그리고

\* 세 번째 열차에 포함된 각 패킷을 수신하면 서버는 T 비트를 1로 설정하고 마지막으로 수신된 세 번째 열차와 동일한 크기의 각 네 번째 패킷 열차를 클라이언트에 반영합니다.

첫 번째 왕복\(첫 번째 및 두 번째 열차\)에 속하는 패킷은 생성 단계를 나타내고, 두 번째 왕복\(세 번째 및 네 번째 열차\)에 속하는 패킷은 반사 단계를 나타냅니다.

수동 경로 관찰자는 두 왕복 동안 표시된 표시된 패킷 수\(즉, 관찰된 방향에 따라 첫 번째와 세 번째 또는 두 번째와 네 번째 패킷 열\)를 계산하고 비교하고 손실률을 추정할 수 있습니다. 연결을 통해 경험했습니다. 엔드포인트가 트래픽을 교환하는 한 더 많은 측정값을 얻기 위해 이 프로세스가 지속적으로 반복됩니다. 이러한 측정을 왕복 손실이라고 부를 수 있습니다.

두 방향의 패킷 속도가 다를 수 있으므로 열차에 표시된 패킷 수는 패킷 속도가 가장 낮은 방향에 따라 결정됩니다. 패킷 생성에 대한 자세한 내용은 섹션 3.1.2를 참조하세요.

---
#### **3.1.1.  Round-Trip Loss**

측정은 클라이언트와 서버 간에 교환되는 트래픽의 일부에 대해 수행되므로 관찰자는 통계적으로 연결에서 경험하는 손실률에 해당하는 종단 간 RTPL\(왕복 패킷 손실\)을 계산합니다. 전체 네트워크 경로를 따라.

```text
              =======================|======================>
              = **********     -----Obs---->     ********** =
              = * Client *                       * Server * =
              = **********     <------------     ********** =
              <==============================================

                        (a) client-server RTPL

              ==============================================>
              = **********     ------------>     ********** =
              = * Client *                       * Server * =
              = **********     <----Obs-----     ********** =
              <======================|=======================

                        (b) server-client RTPL

             Figure 5: Round-Trip Packet Loss (Both Directions)
```

이 방법론은 또한 RTT 측정과 유사한 방식으로 Half-RTPL 측정 및 도메인 내 RTPL 측정을 허용합니다.

```text
              =======================>
              = **********     ------|----->     **********
              = * Client *          Obs          * Server *
              = **********     <-----|------     **********
              <=======================

                     (a) client-observer half-RTPL

                                     =======================>
                **********     ------|----->     ********** =
                * Client *          Obs          * Server * =
                **********     <-----|------     ********** =
                                     <=======================

                     (b) observer-server half-RTPL

          Figure 6: Half Round-Trip Packet Loss (Both Directions)

                              =========================================>
                                                =====================> =
           **********      ---|-->           ---|-->      ********** = =
           * Client *         Obs               Obs       * Server * = =
           **********      <--|---           <--|---      ********** = =
                                                <===================== =
                              <=========================================

                (a) observer-server RTPL components (half-RTPLs)

                              ==================>
           **********      ---|-->           ---|-->      **********
           * Client *         Obs               Obs       * Server *
           **********      <--|---           <--|---      **********
                              <==================
```

\(b\) 다음으로 인한 도메인 내 RTPL

- 위의 RTPL 구성 요소 빼기

```text
      Figure 7: Intra-domain Round-Trip Packet Loss (Observer-Server)
```

---
#### **3.1.2.  Setting the Round-Trip Loss Bit on Outgoing Packets**

왕복 손실 신호에는 표시된 패킷\(T 비트가 1로 설정된 패킷\)의 열을 분리하기 위해 작동하는 스핀 비트 신호가 필요합니다. 알고리즘의 각 단계 사이에 적어도 하나의 빈 스핀 비트 기간의 "일시 중지"는 경로 관찰자에 대한 구분 기호 역할을 합니다. T 비트와 Spin 비트 사이의 연결은 관찰자가 패킷 트레인을 연관시키는 데 도움이 됩니다.

클라이언트는 세션 시작 시 0으로 설정되고 패킷이 수신될 때마다\(표시되거나 표시되지 않음\) 증가되는 "생성 토큰" 수를 유지합니다. 클라이언트는 또한 세션 시작 시 0에서 시작하는 "반사 카운터"를 유지 관리합니다.

클라이언트는 표시된 패킷의 열차 실행을 담당하며 알고리즘에 따라 실행합니다.

1. 생성 단계. 클라이언트는 두 개의 연속 스핀 비트 기간 동안 표시된 패킷 생성을 시작합니다. 클라이언트가 패킷을 전송하고 "생성 토큰"을 사용할 수 있는 경우 클라이언트는 패킷을 표시하고 "생성 토큰"을 폐기합니다. 사용할 수 있는 토큰이 없으면 나가는 패킷은 표시되지 않은 상태로 전송됩니다. 생성에 사용된 첫 번째 스핀 비트 기간이 끝나면 반사 카운터가 잠금 해제되어 나중에 반영될 표시된 수신 패킷 계산을 시작합니다.

2. 단계를 일시 중지합니다. 생성이 완료되면 클라이언트는 표시된 패킷 없이 하나의 전체 스핀 비트 기간을 관찰할 때까지 일시 중지됩니다. 해당 스핀 비트 기간은 관찰자가 생성된 패킷과 반사된 패킷 사이의 구분자로 사용됩니다. 이 표시 일시 중지 동안 모든 나가는 패킷은 T 비트가 0으로 설정된 상태로 전송됩니다. 반사 카운터는 표시된 패킷이 도착할 때마다 계속 증가합니다.

3. 반사 단계. 클라이언트는 표시된 패킷 전송을 시작하고 반사 카운터가 0에 도달할 때까지 전송된 표시된 각 패킷에 대한 반사 카운터를 감소시킵니다. 이 단계에서도 생성 단계의 "생성 토큰" 방법이 사용됩니다. 반사에 사용된 첫 번째 스핀 비트 기간이 끝나면 반사 카운터는 들어오는 반사 패킷이 증가하는 것을 방지하기 위해 잠깁니다.

4. Pause Phase 2. Pause Phase는 Reflection Phase 이후에 반복되며 반사된 패킷열과 새로운 패킷열 사이의 구분자 역할을 합니다.

생성 토큰 카운터는 해당 끝점이 수집된 패킷을 반영하지 못하게 할 수 있는 다른 끝점의 패킷 속도가 갑자기 감소하는 결과를 제한하도록 제한되어야 합니다. 한도 값은 1이 권장됩니다.

서버는 0에서 시작하고 표시된 패킷이 도착할 때마다 증가하는 "마킹 카운터"를 유지 관리합니다. 서버가 패킷을 전송하고 "마킹 카운터"가 양수이면 서버는 패킷을 표시하고 "마킹 카운터"를 감소시킵니다. "마킹 카운터"가 0이면 나가는 패킷이 표시되지 않은 채 전송됩니다.

생성 단계에서 2 RTT\(2개의 스핀 비트 기간\)를 선택하면 표시된 패킷 비율\(즉, 모니터링되는 트래픽 비율\)과 측정 지연 간의 균형이 이루어집니다. 이 값을 사용하여 알고리즘은 대략 6 RTT\(2세대, \~2반사, 2회 일시정지\)마다 측정값을 생성하여 느린 방향으로 교환되는 패킷의 \~1/3을 표시합니다\(섹션 3.1.4 참조\). 1 RTT의 생성 단계를 선택하면 4 RTT마다 측정을 생성하여 느린 방향에서 패킷의 \~1/4을 모니터링합니다.

어떤 경우에는 특히 속도가 갑자기 변하는 경우 문제가 발생할 수 있다는 점을 언급할 가치가 있지만 여기에 설명된 메커니즘은 구현 시 일반적인 트래픽 조건에서 잘 작동했습니다.

---
#### **3.1.3.  Observer's Logic for Round-Trip Loss Signal**

경로 상의 관찰자는 표시된 패킷을 계산하고 표시된 패킷이 없는 스핀 비트 기간\(적어도 하나\)을 감지하여 서로 다른 열차를 분리합니다. 왕복 패킷 손실\(RTPL\)은 생성 열차와 반사 열차의 크기 차이입니다.

다음 예에서 패킷은 두 개의 비트로 표시됩니다\(첫 번째 비트는 스핀 비트, 두 번째 비트는 왕복 손실 비트\).

```text
           Generation          Pause           Reflection       Pause
      ____________________ ______________ ____________________ ________
     |                    |              |                    |        |
      01 01 00 01 11 10 11 00 00 10 10 10 01 00 01 01 10 11 10 00 00 10

                  Figure 8: Round-Trip Loss Signal Example
```

5개의 표시된 패킷이 생성되었으며 그 중 4개가 반영되었습니다.

---
#### **3.1.4.  Loss Coverage and Signal Timing**

왕복 손실 신호 알고리즘의 주기에는 생성 단계의 2 RTT, 반사 단계의 2 RTT 및 각각 지속 시간에서 최소 1 RTT의 2개의 일시 중지 단계가 포함됩니다. 따라서 손실 신호는 손실 이벤트 이후 약 6 RTT만큼 지연됩니다.

관찰자는 생성 단계를 처음 관찰한 후 그리고 후속 반사 단계를 관찰하기 전에 발생하는 표시된 패킷의 손실만 감지할 수 있습니다. 따라서 낮은 속도로 패킷을 보내는 경로\(일반적으로 비대칭 시나리오에서는 ACK\)에서 손실이 발생하는 경우 손실 감지를 위해 패킷의 2/6\(1/3\)이 샘플링됩니다.

더 높은 속도로 패킷을 보내는 경로에서 손실이 발생하는 경우 해당 패킷의 lowPacketRate/\(3\*highPacketRate\)를 샘플링하여 손실 감지를 수행합니다. ACK를 사용하는 프로토콜의 경우 단방향 데이터 전송 중 더 높은 속도 방향의 손실을 위해 샘플링된 패킷 부분은 1/\(3\*packetsPerAck\)입니다. 여기서 packetsPerAck의 값은 프로토콜, 구현 및 네트워크 조건에 따라 달라질 수 있습니다.

---
### **3.2.  Q Bit -- sQuare Bit**

sQuare 비트\(Q 비트\)는 해당 신호에 의해 생성된 구형파에서 이름을 따왔습니다. 이 방법은 Alternate-Marking 방법\[AltMark\]을 기반으로 하며, Q 비트는 연속된 패킷 블록을 다른 색상으로 표시하기 위해 0과 1 사이에서 전환할 수 있는 "패킷 색상"을 나타냅니다. 이 방법에는 두 끝점 모두의 협력이 필요하지 않습니다.

\[AltMark\]는 고정된 타이머에 따라 색상이 전환되는지 또는 고정된 패킷 수 후에 색상이 전환되는지에 따라 대체 표시 방법의 두 가지 변형을 도입합니다. 네트워크 세그먼트의 양쪽 끝에 있는 협력 및 동기화된 관찰자는 고정 타이머 방법을 사용하여 동일한 패킷 블록에 대한 패킷 카운터를 비교함으로써 세그먼트의 패킷 손실을 측정할 수 있습니다. 블록의 시간 길이는 원하는 측정 주파수에 따라 선택할 수 있지만 클록 오류 및 네트워크 지연 문제와 관련하여 적절한 작동을 보장할 수 있을 만큼 길어야 합니다.

이 문서에서 설명하는 Q 비트 방법은 각 블록에 대해 고정된 패킷 수를 기반으로 색상 전환 방법을 선택합니다. 이 접근 방식은 협력하거나 동기화된 관찰자 또는 네트워크 요소가 필요하지 않다는 장점이 있습니다. 각 프로브는 외부 NMS에 의존하지 않고 패킷 손실을 자율적으로 측정할 수 있습니다. 패킷 손실 측정을 위해서는 모든 블록이 동일한 수의 패킷을 가지며, 손실 이벤트만 검출하면 되며, 손실이 있는 정확한 블록을 식별하는 것은 필요하지 않습니다.

고정된 수의 패킷을 기반으로 하는 방법에 따라 구형파 신호는 Q 비트의 전환에 의해 생성됩니다. 나가는 모든 패킷에는 Q 비트 값이 포함되어 있으며, 이 값은 0으로 초기화되고 N 패킷\(sQuare Block 또는 간단히 말해서\)을 보낸 후 반전됩니다. Q 블록\). 따라서 Q 기간은 2\*N입니다.

관찰 지점은 섹션 3.2.2에 설명된 대로 트래픽 흐름의 단일 방향을 관찰하고 관찰된 각 Q 블록의 패킷 수를 계산하여 업스트림 손실을 추정할 수 있습니다.

---
#### **3.2.1.  Q Block Length Selection**

블록의 길이는 경로 상의 네트워크 프로브에 알려져야 합니다. Q 블록 길이를 선택하는 데는 두 가지 대안이 있습니다. 첫 번째는 길이가 선험적으로 알려져 있으므로 마킹 메커니즘을 구현하는 프로토콜 사양 내에서 설정되어야 합니다. 두 번째는 발신자가 선택해야 합니다.

후자의 시나리오에서 송신자는 예상되는 손실량과 경로 재정렬을 기반으로 N\(Q 블록 길이\)을 선택할 것으로 예상됩니다. N을 선택하면 절충안이 됩니다. 패킷 재정렬 및/또는 N이 너무 작은 경우 심각한 손실이 발생하는 경우 관찰이 너무 신뢰할 수 없게 될 수 있으며, N이 너무 크면 짧은 흐름이 유용한 업스트림 손실 측정을 제공하지 못할 수 있습니다\(섹션 참조\). 3.2.2\).

N의 값은 64 이상이어야 하고 2의 거듭제곱이어야 합니다. 이 요구 사항을 통해 관찰자는 제곱 신호의 한 주기를 관찰하여 Q 블록 길이를 추론할 수 있습니다. 또한 관찰자는 손실 비트를 임의의 값으로 설정하는 흐름을 식별할 수 있습니다\(섹션 6 참조\).

송신자가 Q 블록 길이에 대해 정보를 바탕으로 결정을 내릴 만큼 충분한 정보가 없는 경우 송신자는 N=64를 사용해야 합니다. 이 값은 대규모 현장 테스트에서 광범위하게 시도되어 좋은 결과를 얻었기 때문입니다. 대안으로, 발신자는 각 흐름에 대해 임의의 2N 전력을 선택하여 일부 흐름에 대해 최상의 신호를 제공하는 Q 블록 길이를 사용할 가능성을 높일 수도 있습니다.

발신자는 주어진 흐름에 대해 N 값을 일정하게 유지해야 합니다.

---
#### **3.2.2.  Upstream Loss**

N\(Q 블록 길이\) 연속 패킷의 블록은 동일한 Q 비트 값을 사용하여 전송되고, 이어서 Q 비트의 반전된 값을 사용하여 N 패킷의 또 다른 블록이 전송됩니다. 따라서 N 값을 알면 경로 관찰자는 최소한 N개의 패킷을 관찰한 후 업스트림 손실량을 추정할 수 있습니다. 업스트림 손실률\(uloss\)은 1에서 동일한 Q 값\(p\)을 갖는 패킷 블록의 평균 패킷 수를 N으로 나눈 값입니다\(uloss=1-avg\(p\)/N\).

관찰자는 섹션 3.2.3에 설명된 대로 정사각형 신호의 가장자리를 흐리게 할 수 있는 패킷 재정렬을 허용할 수 있어야 합니다.

```text
             =====================>
             **********     -----Obs---->     **********
             * Client *                       * Server *
             **********     <------------     **********

               (a) in client-server channel (uloss_up)

             **********     ------------>     **********
             * Client *                       * Server *
             **********     <----Obs-----     **********
                                  <=====================

               (b) in server-client channel (uloss_down)

                          Figure 9: Upstream Loss
```

---
#### **3.2.3.  Identifying Q Block Boundaries**

패킷 재정렬로 인해 정사각형 신호에 허위 에지가 생성될 수 있습니다. 이 문제를 해결하려면 관찰자는 역방향 Q 비트 값을 가진 첫 번째 패킷 이후의 최대 X 패킷까지 현재 Q 비트 값을 가진 패킷을 찾아야 합니다. "마킹 블록 임계값"인 X 값은 N/2보다 작아야 합니다.

X를 선택하는 것은 재정렬에 대한 탄력성과 손실에 대한 탄력성 간의 균형을 나타냅니다. 매우 큰 마킹 블록 임계값은 상당한 양의 재정렬에도 불구하고 Q 블록을 재구성할 수 있지만 일부 Q 블록에 대해 손실이 50%를 초과하는 경우 여러 Q 블록의 패킷을 더 적은 Q 블록으로 잘못 병합할 수 있습니다.

---
##### **3.2.3.1.  Improved Resilience to Burst Losses**

버스트 손실은 Q 측정의 정확도에 영향을 미칠 수 있습니다. 일반적으로 설정된 Q 블록 길이보다 작으면 버스트 손실을 흡수하고 정확하게 측정할 수 있습니다. 그러나 버스트에서 패킷의 전체 Q 블록 길이가 손실되면 관찰자는 손실을 전혀 인식하지 못할 수 있습니다.

버스트 손실 탄력성을 향상시키기 위해 관찰자는 버스트 손실 이벤트의 표시로 선택된 Q 블록 길이보다 큰 수신된 Q 블록을 고려할 수 있습니다. 그런 다음 관찰자는 Q 블록 길이에서 측정된 블록 길이를 뺀 3배로 손실을 계산합니다. 이를 통해 관찰자는 2개 블록 미만\(예: Q 블록 길이가 64개 패킷인 경우 128개 패킷 미만\)의 버스트 손실을 감지할 수 있습니다. 2개 이상의 연속 기간의 버스트 손실은 관찰자가 여전히 인지하지 못한 채 남아 있습니다\(또는 Q 블록 길이보다 긴 기간이 형성된 경우 과소평가됨\).

---
### **3.3.  L Bit -- Loss Event Bit**

손실 이벤트 비트는 표시 메커니즘을 구현하는 프로토콜에 의해 유지되는 보고되지 않은 손실 카운터를 사용합니다. 손실 이벤트 비트를 사용하려면 프로토콜은 발신자가 손실된 패킷을 식별할 수 있도록 허용해야 합니다. 이는 QUIC와 같은 프로토콜의 경우에 해당되며 TCP 및 SCTP\(스트림 제어 전송 프로토콜\)의 경우 부분적으로 해당되며\(순수 ACK 손실은 감지되지 않음\) UDP 및 IPv4/IPv6과 같은 프로토콜의 경우에는 해당되지 않습니다.

보고되지 않은 손실 카운터는 0으로 초기화되고 모든 나가는 패킷의 L 비트는 보고되지 않은 손실 카운터가 양수인지 여부를 나타냅니다\(카운터가 양수인 경우 L=1, 그렇지 않은 경우 L=0\).

Unreported Loss 카운터의 값은 L=1인 패킷이 전송될 때마다 감소됩니다.

보고되지 않은 손실 카운터의 값은 프로토콜이 사용하는 손실 감지 기계를 사용하여 프로토콜이 손실된 것으로 선언하는 모든 패킷에 대해 증가합니다. 프로토콜이 나중에 손실 결정을 취소할 수 있는 경우 취소로 인해 긍정적인 보고되지 않은 손실 카운터가 감소할 수 있습니다. 일반적으로 철회로 인해 음성이 되어서는 안 되지만, 극히 일부의 경우에 발생할 수 있습니다.

이 손실 신호는 손실 이벤트 비트가 손실된 패킷의 정확한 수를 보고하는 반면 \[ConEx\]의 신호 메커니즘은 손실된 바이트의 대략적인 수를 보고한다는 점을 제외하면 \[ConEx\]의 손실 신호와 유사합니다.

네트워크 장치가 데이터 분할을 변경할 수 있도록 허용하는 TCP\[TCP\]와 같은 프로토콜의 경우 패킷의 일부만 손실될 수 있습니다. 이러한 경우 발신자는 손실된 패킷 데이터의 비율만큼 Unreported Loss 카운터를 증가시켜야 합니다. 따라서 부분 패킷이 손실된 후 L=1인 패킷이 전송되면 Unreported Loss 카운터가 음수가 될 수 있습니다.

관찰 지점은 섹션 3.3.1에 설명된 대로 L 비트가 1인 이 방향의 패킷을 계산하여 업스트림 끝점에 의해 결정된 종단 간 손실을 추정할 수 있습니다.

---
#### **3.3.1.  End-To-End Loss**

손실 이벤트 비트를 사용하면 관찰자는 주어진 흐름에 대해 L 비트 값이 0과 1인 패킷을 계산하여 종단 간 손실률을 추정할 수 있습니다. 종단 간 손실 비율은 L=1인 패킷의 비율입니다.

여기서는 업스트림 손실이 L=0 및 L=1인 패킷에 동일하게 영향을 미친다고 가정합니다. 네트워크 장치의 테일 드롭으로 인해 일부 손실이 발생하는 경우 이는 단순화될 수 있습니다. 발신자의 혼잡 컨트롤러가 손실 후 패킷 전송 속도를 줄이는 경우 L=1인 패킷을 전송하기 전에 관찰자에게 도달할 가능성이 더 큰 충분한 지연이 있을 수 있습니다.

---
##### **3.3.1.1.  Loss Profile Characterization**

손실 이벤트 비트를 사용하면 관찰자가 손실 프로필을 특성화할 수 있습니다. L 비트가 1로 설정된 관찰된 패킷의 분포는 이전에 1 RTT와 1 재전송 시간 초과\(RTO\) 사이에서 손실된 패킷 분포와 대략 일치하기 때문입니다\(섹션 3.3. 2.1\). 따라서 1로 설정된 L 비트의 무작위 단일 인스턴스를 관찰하는 것은 무작위 단일 패킷 손실을 나타내는 반면, L 비트가 1로 설정된 패킷 블록을 관찰하는 것은 전체 패킷 블록에 영향을 미치는 손실을 나타냅니다.

---
#### **3.3.2.  L+Q Bits -- Loss Measurement Using L and Q Bits**

L과 Q 비트를 결합하면 트래픽의 단일 방향을 관찰하는 수동 관찰자가 다음을 정확하게 측정할 수 있습니다.

```text
   upstream loss:  sender-to-observer loss (see Section 3.2.2)

   downstream loss:  observer-to-receiver loss (see Section 3.3.2.2)

   end-to-end loss:  sender-to-receiver loss on the observed path (see
      Section 3.3.1) with loss profile characterization (see
      Section 3.3.1.1)
```

---
##### **3.3.2.1.  Correlating End-to-End and Upstream Loss**

업스트림 손실은 업스트림 손실을 겪지 않은 패킷을 관찰하여 계산됩니다\(섹션 3.2.2\). 그러나 엔드투엔드 손실은 보낸 사람의 프로토콜이 손실을 감지한 후 후속 패킷을 관찰하여 계산됩니다. 따라서 엔드 투 엔드 손실은 일반적으로 업스트림 손실에 비해 1 RTT\(여러 중복 승인으로 인해 선언된 손실\)와 1 RTO\(시간 초과로 인해 선언된 손실\) 사이의 지연으로 관찰됩니다.

때때로 프로토콜 핸드셰이크 메시지의 타이밍을 통해 흐름 RTT를 추정할 수 있습니다. 이 RTT 추정치는 스핀 비트\(섹션 2.1 참조\) 또는 지연 비트\(섹션 2.2 참조\)와 같은 RTT 정보 전달을 위한 전용 프로토콜 메커니즘을 관찰함으로써 크게 향상될 수 있습니다.

관찰자가 업스트림 및 엔드투엔드 손실률 측정을 모두 사용하는 계산을 수행해야 할 때마다 엔드투엔드 손실률을 약 1 RTT만큼 앞당기는 업스트림 손실률을 고려해야 합니다. 관찰자가 흐름의 RTT를 추정할 수 없는 경우 관찰된 흐름에 대한 일반적인 RTT의 최소 4배에 달하는 기간 동안 손실 측정값을 누적해야 합니다.

계산된 업스트림 손실률이 섹션 3.3.1에서 계산된 종단 간 손실률을 초과하는 경우 섹션 3.3.2.3에 설명된 대로 Q 기간이 패킷 재정렬 양에 비해 너무 짧거나 관찰자 손실이 있는 것입니다. 이런 일이 발생하면 관찰자는 다음 사항이 적용되지 않는 한 계산된 업스트림 손실률을 엔드투엔드 손실률과 일치하도록 조정해야 합니다.

순수 ACK 패킷의 손실을 추적하지 않는 TCP 또는 SCTP와 같은 프로토콜의 경우 순수 ACK 패킷이 지배하는 트래픽 방향을 관찰하면 측정된 엔드투엔드 손실보다 높은 업스트림 손실이 측정될 수 있습니다. 순수한 ACK 패킷은 업스트림에서 손실됩니다. 따라서 측정이 이러한 프로토콜에 적용되고 관찰자가 순수한 ACK 패킷이 관찰된 트래픽 방향을 지배한다는 것을 확인할 수 있는 경우 관찰자는 계산된 엔드투엔드 손실률을 업스트림 손실률과 일치하도록 조정해야 합니다.

---
##### **3.3.2.2.  Downstream Loss**

다운스트림 손실은 업스트림 손실을 겪지 않은 패킷에만 영향을 미치기 때문에 종단 간 손실률\(eloss\)은 \(1-uloss\)\(1-uloss\)와 같이 업스트림 손실률\(uloss\) 및 다운스트림 손실률\(dloss\)과 관련됩니다. dloss\)=1-eloss. 따라서 dloss=\(eloss-uloss\)/\(1-uloss\)입니다.

---
##### **3.3.2.3.  Observer Loss**

수동 관찰 시스템의 일반적인 배치에는 미러링된 패킷에 대한 분석 및 측정을 수행하는 장치에 관심 있는 네트워크 패킷을 미러링하는 네트워크 탭 장치가 포함됩니다. 관찰자 손실은 미러 경로에서 발생하는 손실입니다.

관찰자 손실은 관찰자가 동일한 Q 비트 값의 블록에서 더 적은 수의 패킷을 설명하도록 하기 때문에 업스트림 손실률 측정에 영향을 미칩니다\(섹션 3.2.2 참조\). 그러나 종단 간 손실률 측정은 L 비트 값이 1인 패킷의 비율을 측정하기 때문에 관찰자 손실의 영향을 받지 않으며 관찰자 손실은 모든 패킷에 동일하게 영향을 미칩니다\(3.3절 참조\). 1\).

섹션 3.3.2.1에 설명된 대로 엔드투엔드 손실률과 일치하도록 업스트림 손실률을 조정해야 할 필요성은 관찰자 손실을 나타냅니다. 그 크기는 그러한 조정 금액과 전체 업스트림 손실 사이에 있습니다. 섹션 3.2.2에서 측정되었습니다. 또는 높은 명백한 업스트림 손실률은 상당한 패킷 재정렬을 나타낼 수 있습니다. 단일 흐름에 속하는 패킷이 서로 다른 대기 시간 특성을 가진 여러 업스트림 경로를 통해 다중화되기 때문일 수 있습니다.

---
### **3.4.  R Bit -- Reflection Square Bit**

R 비트에는 Q 비트와 함께 배포가 필요합니다. 패킷이 고정된 크기의 블록으로 전송되는 정사각형 신호와 달리 반사 정사각형 블록\(대체 표시 신호라고도 함\)의 패킷 수는 다음 규칙에 따라 달라집니다.

\* 새로운 블록의 전송이 시작되면 그 크기는 수신이 완료된 마지막 Q 블록의 크기와 동일하게 설정됩니다. 그리고

\* 블록의 전송이 종료되기 전에 적어도 하나 이상의 추가 Q Block의 수신이 완료되면 블록의 크기는 추가로 수신된 Q Block의 평균 크기로 업데이트됩니다.

반사 제곱 값은 0으로 초기화되며 나가는 모든 패킷의 R 비트에 적용됩니다. 반사 사각형 값은 Q 블록의 완료가 들어오는 사각형 신호\(Q 비트를 사용하여 다른 끝점에서 생성됨\)에서 감지될 때 처음으로 토글됩니다. 이 첫 번째 Q 블록\(p\) 내에서 감지된 패킷 수는 \(처음에는\) 모든 M=p 패킷을 토글하는 반사 사각형 신호를 생성하는 데 사용됩니다. 이 새로운 신호는 M개의 패킷 블록\(R 비트를 사용하여 표시됨\)을 생성하며 각각을 "반사 블록"\(반사 블록\)이라고 합니다.

그러면 M 값은 다음 공식에 따라 들어오는 정사각형 신호에서 완성된 Q 블록이 수신될 때마다 업데이트됩니다: M=round\(avg\(p\)\).

마킹 기간 동안의 평균 패킷 수인 avg\(p\) 매개변수는 현재 Reflection Block이 시작된 이후 수신된 모든 Q Block을 기준으로 계산됩니다.

반사 블록의 전송은 해당 블록에서 전송된 패킷 수가 최소한 최근에 계산된 M 값일 때 완료된 것으로 간주됩니다\(신호가 토글됨\).

M 값의 적절한 계산을 보장하려면 R 비트를 구현하는 엔드포인트가 들어오는 Q 블록의 경계를 식별해야 합니다. 섹션 3.2.3에 설명된 것과 동일한 접근 방식을 사용해야 합니다.

R 비트를 살펴보면 단방향 관찰 지점에는 관찰되지 않은 전체 채널에서 발생한 손실과 보낸 사람에서 해당 채널로의 경로 손실이 표시됩니다.

Q Block은 한 방향으로 전송되고 해당 반사 R Block은 반대 방향으로 전송되므로 반사된 R 신호는 가장 느린 방향의 패킷 속도로 전송됩니다. 즉, 관측 방향이 가장 느린 경우 관측 방향으로 완전한 반사 블록이 전송되기 전에 관측되지 않은 방향으로 여러 개의 Q 블록이 전송될 수 있습니다. 관찰되지 않은 방향이 가장 느린 경우 관찰된 방향은 새로 완성된 Q 블록을 설명하기 위해 신호를 업데이트하기 전에 동일한 크기의 R 블록을 반복적으로 보낼 수 있습니다.

---
#### **3.4.1.  Enhancement of Reflection Block Length Computation**

M 계산에 사용되는 반올림 함수를 사용하면 M을 계산할 때마다 적용되는 반올림을 저장하고 이를 다음 Reflection Block에서 M 값 계산 시 사용함으로써 오류를 최소화할 수 있습니다.

이는 M 계산에 새로운 r\_avg 매개변수를 도입하여 달성할 수 있습니다. 새 공식은 Mr=avg\(p\)+r\_avg입니다. M=라운드\(Mr\); r\_avg=Mr-M 여기서 r\_avg의 초기 값은 0입니다.

---
#### **3.4.2.  Improved Resilience to Packet Reordering**

마킹 메커니즘을 구현하는 프로토콜이 패킷이 잘못된 순서로 수신되는 시기를 감지할 수 있으면 섹션 3.2.3에 설명된 방법을 사용하여 가능한 것 이상으로 패킷 재정렬에 대한 복원력을 향상시킬 수 있습니다.

이는 현재 반사 블록이 전송되는 동안 크기를 업데이트하여 달성할 수 있습니다. 그러면 반사 블록 크기는 이전 Q 블록의 재정렬된 들어오는 패킷이 감지될 때마다 업데이트됩니다. 이는 현재 반사 블록의 전송이 진행 중이고 다음 Q 블록의 패킷이 수신되지 않은 경우에만 수행될 수 있습니다.

---
##### **3.4.2.1.  Improved Resilience to Burst Losses**

버스트 손실은 Q 측정의 정확도에 영향을 미치는 것과 유사하게 R 측정의 정확도에 영향을 미칠 수 있습니다. 따라서 섹션 3.2.3.1의 권장 사항은 R 측정에 대한 버스트 손실 탄력성을 개선하는 데 동일하게 적용됩니다.

---
#### **3.4.3.  R+Q Bits -- Loss Measurement Using R and Q Bits**

sQuare 및 Reflection 정사각형 비트는 모두 최대 N 패킷마다 토글되므로\(앞에서 설명한 R 비트의 첫 번째 전환 제외\) 경로 상의 관찰자는 각 마킹 블록의 패킷 수를 계산할 수 있으며, N은 연결로 인해 발생한 손실량을 추정할 수 있습니다. 관찰자는 교통의 단일 방향 또는 양방향을 관찰할 수 있는지 여부에 따라 다양한 측정값을 계산할 수 있습니다.

```text
   Single directional observer:
      upstream loss in the observed direction:  the loss between the
         sender and the observation point (see Section 3.2.2)
```

- "3/4" 연결 손실: 관찰되지 않은 방향의 수신자와 송신자 사이의 손실과 관찰된 방향의 송신자와 관찰 지점 사이의 손실

- 관찰되지 않은 방향의 end-to-end 손실: 반대 방향의 수신자와 발신자 사이의 손실

양방향 관찰자\(이전에 양방향에 적용된 동일한 메트릭 플러스\): 클라이언트-관찰자 반왕복 손실: 클라이언트와 관찰 지점 간의 양방향 손실

- 관찰자-서버 반왕복 손실: 관찰 지점과 서버 사이의 양방향 손실

```text
      downstream loss:  the loss between the observation point and the
         receiver (applicable to both directions)
```

---
##### **3.4.3.1.  Three-Quarters Connection Loss**

반영할 것이 없는 첫 번째 블록\(완전한 Q 블록이 아직 수신되지 않음\)을 제외하고 패킷은 N보다 작거나 같은 크기의 대체 블록으로 지속적으로 R 비트로 표시됩니다. N 값을 알면, 경로 상의 관찰자는 반대 채널 전체에서 발생한 손실의 양과 관찰 채널에서 송신자까지의 손실을 추정할 수 있습니다. 이전 메트릭의 경우 3/4 연결 손실률\(tqloss\)은 1에서 동일한 R 값\(t\)을 갖는 패킷 블록의 평균 패킷 수를 N으로 나눈 값을 뺀 값입니다\(tqloss=1-avg\(t\)/ N\).

```text
           =======================>
           = **********     -----Obs---->     **********
           = * Client *                       * Server *
           = **********     <------------     **********
           <============================================

               (a) in client-server channel (tqloss_up)

             ============================================>
             **********     ------------>     ********** =
             * Client *                       * Server * =
             **********     <----Obs-----     ********** =
                                  <=======================

               (b) in server-client channel (tqloss_down)

                 Figure 10: Three-Quarters Connection Loss
```

다음 메트릭은 이 마지막 메트릭과 Q 비트에 의해 생성된 업스트림 손실에서 파생됩니다.

---
##### **3.4.3.2.  End-To-End Loss in the Opposite Direction**

관찰되지 않은 방향의 종단 간 손실\(eloss\_unobserved\)은 "3/4" 연결 손실\(tqloss\) 및 관찰된 방향의 업스트림 손실\(uloss\)과 관련됩니다\(1-eloss\_unobserved\)\(1-uloss\)=1- tqloss. 따라서 eloss\_unobserved=\(tqloss-uloss\)/\(1-uloss\)입니다.

```text
             **********     -----Obs---->     **********
             * Client *                       * Server *
             **********     <------------     **********
             <==========================================

               (a) in client-server channel (eloss_down)

             ==========================================>
             **********     ------------>     **********
             * Client *                       * Server *
             **********     <----Obs-----     **********

               (b) in server-client channel (eloss_up)
```

- 그림 11: 반대 방향의 엔드투엔드 손실

---
##### **3.4.3.3.  Half Round-Trip Loss**

관찰자가 트래픽의 양방향을 관찰할 수 있는 경우 두 개의 "반 왕복" 손실 측정을 계산할 수 있습니다. 즉, 관찰자에서 수신기로의 손실\(주어진 방향에서\)과 반대쪽의 관찰자에게 다시 돌아가는 손실입니다. 방향. 양방향의 경우 "반 왕복" 손실\(hrtloss\)은 반대 방향에서 측정된 "3/4" 연결 손실\(tqloss\_opposite\)과 관련되며, 주어진 방향에서 \(1-uloss\)로 측정된 업스트림 손실\(uloss\)과 관련됩니다\( 1-hrtloss\)=1-tqloss\_opposite. 따라서 hrtloss=\(tqloss\_opposite-uloss\)/\(1-uloss\)입니다.

```text
           =======================>
           = **********     ------|----->     **********
           = * Client *          Obs          * Server *
           = **********     <-----|------     **********
           <=======================

         (a) client-observer half round-trip loss (hrtloss_co)

                                  =======================>
             **********     ------|----->     ********** =
             * Client *          Obs          * Server * =
             **********     <-----|------     ********** =
                                  <=======================

         (b) observer-server half round-trip loss (hrtloss_os)

             Figure 12: Half Round-Trip Loss (Both Directions)
```

---
##### **3.4.3.4.  Downstream Loss**

관찰자가 트래픽의 양방향을 모두 관찰할 수 있는 경우 섹션 3.3.2.2의 계산과 유사하게 종단 간 손실과 업스트림 손실 또는 "반 왕복"을 사용하여 두 개의 다운스트림 손실 측정값을 계산할 수 있습니다. 손실과 업스트림 손실은 반대 방향입니다.

후자의 경우 dloss=\(hrtloss-uloss\_opposite\)/\(1-uloss\_opposite\)입니다.

```text
                                  =====================>
             **********     ------|----->     **********
             * Client *          Obs          * Server *
             **********     <-----|------     **********

                (a) in client-server channel (dloss_up)

             **********     ------|----->     **********
             * Client *          Obs          * Server *
             **********     <-----|------     **********
             <=====================

                (b) in server-client channel (dloss_down)

                         Figure 13: Downstream Loss
```

---
### **3.5.  E Bit -- ECN-Echo Event Bit**

이 문서의 주요 초점은 패킷 손실과 지연을 노출하는 것이지만, 현대 네트워크는 \[ECN\]에 설명된 대로 패킷을 강제로 삭제하기 전에 정체를 보고할 수 있습니다. 전송 프로토콜이 ECN-Echo 피드백을 암호화 상태로 유지하는 경우 네트워크 운영자는 이 신호를 관찰할 수 없습니다. 네트워크 성능 문제를 진단할 때 관측 지점 하류의 정체에 대한 지식이 도움이 될 수 있습니다.

다운스트림 혼잡 정보가 필요한 경우 이 정보는 추가 비트를 사용하여 신호를 보낼 수 있습니다.

E: 아래 섹션 3.5.1에 ​​설명된 대로 "ECN-Echo 이벤트" 비트는 보고되지 않은 ECN-Echo 카운터에 따라 0 또는 1로 설정됩니다.

---
#### **3.5.1.  Setting the ECN-Echo Event Bit on Outgoing Packets**

Unreported ECN-Echo 카운터는 수신기의 ECN-Echo 피드백에 따라 CE\(Congestion Experienced\) 표시가 있는 네트워크에서 전달된 패킷을 계산한다는 점을 제외하면 Unreported Loss 카운터\(섹션 3.3\)와 동일하게 작동합니다.

이 ECN-Echo 신호는 \[ConEx\]의 ECN 신호와 유사합니다. QUIC의 ECN-Echo 메커니즘은 CE 마크와 함께 수신된 패킷 수를 제공합니다. TCP와 같은 프로토콜의 경우 \[ConEx-TCP\]에 설명된 방법을 사용할 수 있습니다. 이러한 피드백은 \[ConEx-TCP\]에서 설명한 것처럼 \[ACCURATE-ECN\]에서 설명한 방법을 사용하면 더욱 향상될 수 있다.

---
#### **3.5.2.  Using E Bit for Passive ECN-Reported Congestion Measurement**

네트워크 관찰자는 CE 코드 포인트를 사용하여 패킷을 계산하고 업스트림 CE 표시 속도를 직접 결정할 수 있습니다.

관찰 지점은 또한 E 비트가 1인 이 방향의 패킷을 계산하여 ECN 보고된 종단 간 정체를 추정할 수 있습니다.

업스트림 CE 마킹 속도와 종단 간 ECN 보고 정체는 다운스트림 CE 마킹 속도에 대한 정보를 제공할 수 있습니다. 그러나 L 비트와 함께 E 비트가 존재하면 흐름에 ECN 지원이 불가능한 패킷이 포함된 경우 업스트림 및 다운스트림 CE 표시의 정확한 추정이 다소 혼란스러울 수 있습니다.

---
#### **3.5.3.  Multiple E Bits**

QUIC와 같은 일부 프로토콜은 별도의 ECN-Echo 카운터를 지원합니다. 예를 들어, \[QUIC-TRANSPORT\]의 섹션 13.4.1은 ECT\(0\), ECT\(1\) 및 ECN-CE에 대한 별도의 카운터를 설명합니다. 이러한 프로토콜을 더 잘 지원하기 위해 해당 ECN-Echo 카운터당 하나씩 여러 E 비트를 사용할 수 있습니다.

---
## **4.  Summary of Delay and Loss Marking Methods**

이 섹션에서는 이 문서에 설명된 마킹 방법을 요약하며, 필요에 따라 별도로, 부분적으로 또는 모두 함께 사용할 수 있는 기술 툴킷을 제안합니다.

지연 측정의 경우 Spin 비트 및/또는 지연 비트를 사용할 수 있습니다. 단방향 또는 양방향 관찰자를 사용할 수 있습니다.

```text
   +===============+======+=====================+=============+========+
   | Method        | # of |   Available Delay   | Impairments |  # of  |
   |               | bits |       Metrics       |  Resiliency | meas.  |
   |               |      +==========+==========+             |        |
   |               |      |  UniDir  |  BiDir   |             |        |
   |               |      | Observer | Observer |             |        |
   +===============+======+==========+==========+=============+========+
   | S: Spin Bit   |  1   |   RTT    | x2, Half |     low     |  very  |
   |               |      |          |   RTT    |             |  high  |
   +---------------+------+----------+----------+-------------+--------+
   | D: Delay      |  1   |   RTT    | x2, Half |     high    | medium |
   | Bit           |      |          |   RTT    |             |        |
   +---------------+------+----------+----------+-------------+--------+
   | SD: Spin      |  2   |   RTT    | x2, Half |     high    |  very  |
   | Bit & Delay   |      |          |   RTT    |             |  high  |
   | Bit *         |      |          |          |             |        |
   +---------------+------+----------+----------+-------------+--------+

                         Table 1: Delay Comparison

   x2    Same metric for both directions
```

\* 두 비트 모두 독립적으로 작동합니다. 관찰자는 지연 비트를 사용할 수 없을 때 덜 정확한 스핀 비트 측정을 사용할 수 있습니다.

손실 측정의 경우 표 2의 각 행은 손실 표시 방법을 나타냅니다. 각 방법에 대해 표는 헤더에 필요한 비트 수, 단방향 또는 양방향 관찰자를 사용하여 사용 가능한 메트릭, 적용 가능한 프로토콜, 측정 충실도 및 지연을 지정합니다.

```text
   +============+====+==========================+====+=================+
   | Method     |Bits|  Available Loss Metrics  |Prto|   Measurement   |
   |            |    |                          |    |     Aspects     |
   |            |    +============+=============+    +==========+======+
   |            |    |   UniDir   |    BiDir    |    | Fidelity |Delay |
   |            |    |  Observer  |   Observer  |    |          |      |
   +============+====+============+=============+====+==========+======+
   | T: Round-  | $1 |     RT     | x2, Half RT | *  |Rate by   |~6 RTT|
   | Trip Loss  |    |            |             |    |sampling  |      |
   | Bit        |    |            |             |    |1/3 to    |      |
   |            |    |            |             |    |1/(3*ppa) |      |
   |            |    |            |             |    |of pkts   |      |
   |            |    |            |             |    |over 2    |      |
   |            |    |            |             |    |RTT       |      |
   +------------+----+------------+-------------+----+----------+------+
   | Q: sQuare  | 1  |  Upstream  |      x2     | *  |Rate over |N pkts|
   | Bit        |    |            |             |    |N pkts    |(e.g.,|
   |            |    |            |             |    |(e.g.,    |64)   |
   |            |    |            |             |    |64)       |      |
   +------------+----+------------+-------------+----+----------+------+
   | L: Loss    | 1  |    E2E     |      x2     | #  |Loss      |Min:  |
   | Event Bit  |    |            |             |    |shape     |RTT,  |
   |            |    |            |             |    |(and      |Max:  |
   |            |    |            |             |    |rate)     |RTO   |
   +------------+----+------------+-------------+----+----------+------+
   | QL: sQuare | 2  |  Upstream  |      x2     | #  |see Q     |see Q |
   | + Loss Ev. |    +------------+-------------+----+----------+------+
   | Bits       |    | Downstream |      x2     | #  |see Q|L   |see L |
   |            |    +------------+-------------+----+----------+------+
   |            |    |    E2E     |      x2     | #  |see L     |see L |
   +------------+----+------------+-------------+----+----------+------+
   | QR: sQuare | 2  |  Upstream  |      x2     | *  |Rate over |see Q |
   | + Ref. Sq. |    +------------+-------------+----+N*ppa     +------+
   | Bits       |    |   3/4 RT   |      x2     | *  |pkts (see |N*ppa |
   |            |    +------------+-------------+----+Q bit for |pkts  |
   |            |    |    !E2E    |     E2E,    | *  |N)        |(see Q|
   |            |    |            | Downstream, |    |          |bit   |
   |            |    |            |   Half RT   |    |          |for N)|
   +------------+----+------------+-------------+----+----------+------+

                          Table 2: Loss Comparison

   *     All protocols

   #     Protocols employing loss detection (with or without pure ACK
         loss detection)
```

$ 작동하는 스핀 비트가 필요합니다.

! 반대 채널을 기준으로 한 측정항목

```text
   x2    Same metric for both directions

   ppa   Packets-Per-Ack
```

Q|L 업스트림 손실이 심각한 경우 Q를 참조하세요. 그렇지 않으면 L

E2E 엔드투엔드

---
### **4.1.  Implementation Considerations**

위 두 표의 정보를 결합하면 3비트\(예: QL 또는 QR + S 또는 D\) 또는 4비트\(예: QL 또는 QR + SD\) 솔루션이 더 완전하고 탄력적인 측정을 허용한다는 것을 추론할 수 있습니다. .

이전 섹션에서 설명한 방법론은 전송에 구애받지 않으며 다양한 상황에 적용될 수 있습니다. 방법의 선택은 특정 프로토콜에 따라 달라집니다. 예를 들어 QL은 좋은 조합입니다. 그러나 프로토콜이 L 비트를 지원하지 않거나 설정할 수 없는 경우 QR이 실행 가능한 유일한 솔루션입니다.

---
## **5.  Examples of Application**

이 문서에서는 여러 가지 측정 방법을 설명하지만 모든 방법이 함께 구현될 것으로 예상되는 것은 아닙니다. 예를 들어, \[CORE-COAP-PM\]에서는 본 문서에 설명된 방법 중 일부\(sQuare 비트, Spin 비트\)만 활용됩니다. 또한 QUIC에 대한 지연 신호 바인딩은 \[QUIC-TRANSPORT\]의 섹션 17.4에 부분적으로 설명되어 있습니다. 이는 짧은 패킷 헤더의 첫 번째 바이트에 Spin 비트만 추가하고 향후 사용을 위해 2개의 예약된 비트를 남겨둡니다\(섹션 17.2 참조\). \[QUIC-TRANSPORT\]의 .2\).

이 문서에서 논의된 모든 신호는 QUIC와 TCP 모두에 대한 성공적인 실험에서 구현되었습니다. 고려된 애플리케이션 시나리오를 통해 데이터 센터 내부\(Intra-DC\), 데이터 센터 간\(Inter-DC\) 상호 연결은 물론 엔드투엔드 대규모 데이터 전송을 모니터링할 수 있습니다. 이 문서에 설명된 방법을 적용하려면 모니터링된 흐름이 안정적인 경로를 따르고 동일한 측정 지점을 통과한다고 가정합니다.

QUIC 및 TCP 실험에 사용된 특정 구현 세부 사항과 비트 선택은 이 문서의 범위를 벗어납니다. 특정 프로토콜 애플리케이션을 정의하는 사양에서는 프로토콜에서 어떤 비트가 구현될지에 따라 구현 세부 사항을 논의할 것으로 예상됩니다\(예: \[CORE-COAP-PM\]\). 특정 측정에 사용되는 비트가 프로토콜에 의해 다른 목적으로도 사용될 수 있는 경우, 사양은 경로상의 관찰자가 신호를 명확하게 하는 방법을 다루거나 관찰자가 유효한 신호를 기대할 수 있는 조건에 대한 제한 사항을 논의할 것으로 예상됩니다.

---
## **6.  Protocol Ossification Considerations**

정확한 손실 및 지연 정보는 프로토콜 작동에 필요하지 않지만 충분한 수의 흐름에 대한 정보의 존재는 네트워크 작동에 중요합니다.

지연 및 손실 비트는 프로토콜 설계자가 손실 보고에 사용되는 비트를 이 기능에 전용\(및 골화\)할 준비가 되지 않은 경우 \[RFC8701\]에 설명된 "그리싱"을 적용할 수 있습니다. 윤활은 \[QUIC-TRANSPORT\]의 섹션 17.4의 대기 시간 스핀 비트 윤활과 유사하게 수행될 수 있습니다. 예를 들어, 프로토콜 설계자는 흐름의 일부가 손실 및 지연 정보를 인코딩해서는 안 되며 대신 비트가 임의의 값으로 설정되도록 결정할 수 있습니다. 이 문서에 설명된 비트를 임의의 값으로 설정하면 해당 지연 및 손실 정보가 흐름에 대해 예상되는 신호가 아니라 잡음과 유사하게 되며 관찰자는 이러한 흐름을 무시할 준비가 되어 있어야 합니다.

---
## **7.  Security Considerations**

이 문서에 설명된 방법은 전송에 구애받지 않으며 잠재적으로 모든 전송 계층 프로토콜에 적용 가능하며 특히 암호화된 프로토콜에 유용합니다. 이러한 방법은 특정 프로토콜 응용 프로그램에 따라 제한된 도메인과 인터넷 모두에 적용될 수 있습니다.

수동적 손실 및 지연 관찰은 오랫동안 네트워크 작업의 일부였으므로 손실 및 지연 정보를 네트워크에 노출해도 현재 관찰 가능한 프로토콜에 대한 새로운 보안 문제가 추가되지 않습니다.

패킷 손실이 없는 경우 Q 및 R 비트 신호는 단순히 네트워크 경로를 통과하는 패킷 수를 세는 것만으로는 관찰할 수 없는 정보를 제공하지 않습니다. 패킷 손실이 있는 경우 Q 및 R 비트는 손실을 공개하지만 이는 엔드포인트 상태가 아니라 환경에 대한 정보입니다. L 비트 신호는 프로토콜의 손실 감지 기계의 내부 상태를 공개하지만 이 상태는 패킷 타이밍을 맞추고 혼잡 컨트롤러 응답을 관찰하여 수집할 수 있는 경우가 많습니다.

이 문서에 설명된 측정은 네트워크에 삽입된 새 패킷이 네트워크 자체와 데이터 트래픽에 잠재적인 피해를 줄 수 있음을 의미하지 않습니다. 공격자가 패킷 표시를 변경하거나 인위적인 트래픽을 주입하면 측정값이 손상될 수 있습니다. 이러한 트래픽 공격을 방지하기 위해 적절한 경우 인증 기술을 사용할 수 있습니다.

따라서 손실 비트는 데이터 무결성과 비밀성을 공격하는 실행 가능한 새로운 메커니즘을 제공하지 않습니다.

본 문서에 소개된 측정 필드는 패킷에 포함되도록 고안되었습니다. 하지만 이 정보를 비밀 채널로 활용하는 것이 가능할 수도 있다는 점은 언급할 가치가 있습니다.

이 문서는 특정 애플리케이션을 정의하지 않으며 설명된 기술은 일반적으로 다양한 보안 환경에서 작동하는 다양한 통신 프로토콜에 적용될 수 있습니다. 특정 프로토콜 애플리케이션을 정의하는 사양은 각각의 보안 고려 사항을 다루어야 하며 프로토콜의 세부 사항과 예상 운영 환경을 고려해야 합니다. 예를 들어, \[QUIC-TRANSPORT\]의 섹션 21과 \[QUIC-TLS\]의 섹션 9에서 논의된 QUIC에 대한 보안 고려 사항은 특정 QUIC 메커니즘에 대한 공격뿐만 아니라 네트워크에서 능동 및 수동 공격자의 가능성을 고려합니다.

---
### **7.1.  Optimistic ACK Attack**

\[QUIC-TRANSPORT\]의 21.4절에 설명된 낙관적 ACK 공격에 대한 방어에는 송신자가 패킷 번호를 무작위로 건너뛰어 수신된 적이 없는 패킷 번호를 확인하는 수신자를 감지하는 것이 포함됩니다. Q 비트 신호는 의도적으로 건너뛴 패킷 번호와 실제로 손실된 패킷 번호\(따라서 공격자가 인정할 수 있는 안전한 패킷 번호\)를 공격자에게 알릴 수 있습니다. 이러한 목적으로 Q 비트를 사용하려면 공격자는 먼저 패킷의 전체 Q 블록을 수신해야 하며, 이로 인해 지연에 민감한 혼잡 컨트롤러에 대한 공격이 효과적이지 않게 됩니다.

Q 비트에서 제공되는 손실 신호로 낙관적 ACK 공격에 더 취약하고 손실 기반 혼잡 컨트롤러를 사용하는 프로토콜은 현재 Q 블록을 건너뛴 패킷 수만큼 줄여야 합니다. 예를 들어, 단일 패킷 번호를 건너뛰면 나가는 패킷 하나의 정사각형 신호가 더 빨리 반전됩니다.

비슷한 고려 사항이 R 비트에도 적용됩니다. 그러나 패킷 번호의 일치하는 건너뛰기와 함께 단축된 반사 블록이 반드시 손실된 패킷을 의미하는 것은 아니지만, 이는 의도적으로 건너뛴 패킷과 함께 역방향 경로에서 손실된 패킷으로 인해 발생할 수 있기 때문입니다. 보내는 사람.

---
### **7.2.  Delay Bit with RTT Obfuscation**

이론적으로 지연 측정을 사용하면 서버\(RTT 사용\) 또는 중간 관찰자\(클라이언트-관찰자 half-RTT 사용\)로부터 클라이언트까지의 거리를 대략적으로 평가할 수 있습니다. \[RTT-PRIVACY\]에 설명된 대로 엔드포인트의 위치정보를 찾기 위한 연결 RTT 측정은 일반적으로 가장 기본적인 IP 위치정보 데이터베이스보다 열등합니다. 가장 유용한 것은 RTT 측정 내 가변성\(지터\)입니다. 이는 엔드포인트의 운영 환경은 물론 연결에 사용되는 네트워크 상태\(대기열 지연\)에 대한 통찰력을 제공할 수 있기 때문입니다.

그럼에도 불구하고 연결의 실제 RTT를 추가로 마스크하기 위해 지연 비트 알고리즘을 약간 수정할 수 있습니다. 예를 들어 고정되고 무작위로 선택된 시간 값만큼 지연 샘플의 클라이언트 측 반사를 지연시킵니다. 이로 인해 중간 관찰자가 실제 지연보다 더 큰 지연을 측정하게 됩니다.

이 추가 지연은 클라이언트에 의해 무작위로 선택되어야 하며 여러 연결에서 일정 시간 동안 일정하게 유지되어야 합니다. 이렇게 하면 추가 지연이 삽입되지 않은 것처럼 클라이언트-서버 지터가 동일하게 유지됩니다. 예를 들어 클라이언트의 IP 주소가 변경될 때마다 새로운 추가 지연 값이 생성될 수 있습니다.

추가 지연에도 불구하고 이 숨겨진 지연 기술을 사용하면 여전히 RTT 구성 요소\(관찰자-서버\)의 정확한 측정과 네트워크에서 지연을 분산하는 데 사용되는 모든 도메인 내 측정이 가능합니다. 또한 지연 비트와 달리 숨겨진 지연 비트에는 클라이언트 반사 임계값\(기본적으로 1ms\)을 사용할 필요가 없습니다. 이 임계값을 제거하면 알고리즘에서 생성되는 유효한 측정값 수가 늘어날 수 있습니다.

숨겨진 지연 비트는 연결 설정 중에 교환되는 타이밍 패킷과 같은 다른 수단을 사용하여 정확한 RTT를 측정하는 관찰자의 능력에 영향을 미치지 않습니다.

---
## **8.  Privacy Considerations**

의도하지 않은 정보 노출을 최소화하기 위해 손실 비트는 \[RFC8558\]에 따라 정보를 공유하는 데 선호되는 방법인 명시적인 손실 신호를 제공합니다.

새로운 프로토콜에는 일반적으로 특정한 개인 정보 보호 목표가 있으며, 손실 보고는 손실 정보가 해당 개인 정보 보호 목표를 손상시키지 않도록 보장해야 합니다. 예를 들어, \[QUIC-TRANSPORT\]는 수동 관찰자가 이전 하위 흐름과 새 하위 흐름을 동일한 장치에 연결할 가능성을 줄이기 위해 연결 도중에 연결 ID를 변경할 수 있도록 허용합니다\(\[QUIC-TRANSPORT\]의 섹션 5.1 참조\). QUIC 구현은 대상\(IP 주소 또는 UDP 포트\) 또는 나가는 패킷에 사용되는 연결 ID를 변경할 때 모든 카운터를 재설정해야 합니다. 또한 다른 대상이나 다른 연결 ID로 전송된 패킷의 손실에 대해 보고되지 않은 손실 카운터를 증가시키지 않아야 합니다.

또한 이러한 기술이 널리 배포되지 않으면 이를 사용하는 엔드포인트에서 사용량에 따라 지문이 채취될 수 있다는 점도 강조할 가치가 있습니다. 그러나 사용자 데이터가 공개되지 않기 때문에 해당 기술이 기존 개인 정보 보호 위험을 실질적으로 증가시킬 가능성은 낮아 보입니다.

또한 네트워크에 이러한 비트가 설정된 실험적인 트래픽이 있는 경우 네트워크 운영자는 표시된 트래픽을 우선 순위 대기열에 배치하여 잠재적으로 우선 순위를 지정할 수 있습니다. 이로 인해 더 나은 서비스가 제공될 수 있으며, 이는 네트워크를 벤치마킹하려는 실험을 잠재적으로 오도할 수 있습니다.

---
## **9.  IANA Considerations**

이 문서에는 IANA 작업이 없습니다.

---
## **10.  References**
---
### **10.1.  Normative References**

```text
   [ECN]      Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              RFC 3168, DOI 10.17487/RFC3168, September 2001,
              <https://www.rfc-editor.org/info/rfc3168>.

   [IPPM-METHODS]
              Morton, A., "Active and Passive Metrics and Methods (with
              Hybrid Types In-Between)", RFC 7799, DOI 10.17487/RFC7799,
              May 2016, <https://www.rfc-editor.org/info/rfc7799>.

   [QUIC-TRANSPORT]
              Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [RFC8558]  Hardie, T., Ed., "Transport Protocol Path Signals",
              RFC 8558, DOI 10.17487/RFC8558, April 2019,
              <https://www.rfc-editor.org/info/rfc8558>.

   [TCP]      Eddy, W., Ed., "Transmission Control Protocol (TCP)",
              STD 7, RFC 9293, DOI 10.17487/RFC9293, August 2022,
              <https://www.rfc-editor.org/info/rfc9293>.
```

---
### **10.2.  Informative References**

```text
   [ACCURATE-ECN]
              Briscoe, B., Kühlewind, M., and R. Scheffenegger, "More
              Accurate Explicit Congestion Notification (ECN) Feedback
              in TCP", Work in Progress, Internet-Draft, draft-ietf-
              tcpm-accurate-ecn-26, 24 July 2023,
              <https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-
              accurate-ecn-26>.

   [AltMark]  Fioccola, G., Ed., Cociglio, M., Mirsky, G., Mizrahi, T.,
              and T. Zhou, "Alternate-Marking Method", RFC 9341,
              DOI 10.17487/RFC9341, December 2022,
              <https://www.rfc-editor.org/info/rfc9341>.

   [ANRW19-PM-QUIC]
              Bulgarella, F., Cociglio, M., Fioccola, G., Marchetto, G.,
              and R. Sisto, "Performance measurements of QUIC
              communications", Proceedings of the Applied Networking
              Research Workshop (ANRW '19), Association for Computing
              Machinery, DOI 10.1145/3340301.3341127, July 2019,
              <https://doi.org/10.1145/3340301.3341127>.

   [ConEx]    Mathis, M. and B. Briscoe, "Congestion Exposure (ConEx)
              Concepts, Abstract Mechanism, and Requirements", RFC 7713,
              DOI 10.17487/RFC7713, December 2015,
              <https://www.rfc-editor.org/info/rfc7713>.

   [ConEx-TCP]
              Kuehlewind, M., Ed. and R. Scheffenegger, "TCP
              Modifications for Congestion Exposure (ConEx)", RFC 7786,
              DOI 10.17487/RFC7786, May 2016,
              <https://www.rfc-editor.org/info/rfc7786>.

   [CORE-COAP-PM]
              Fioccola, G., Zhou, T., Nilo, M., Milan, F., and F.
              Bulgarella, "Constrained Application Protocol (CoAP)
              Performance Measurement Option", Work in Progress,
              Internet-Draft, draft-ietf-core-coap-pm-01, 19 October
              2023, <https://datatracker.ietf.org/doc/html/draft-ietf-
              core-coap-pm-01>.

   [IPPM-SPIN]
              Trammell, B., Ed., "An Explicit Transport-Layer Signal for
              Hybrid RTT Measurement", Work in Progress, Internet-Draft,
              draft-trammell-ippm-spin-00, 9 January 2019,
              <https://datatracker.ietf.org/doc/html/draft-trammell-
              ippm-spin-00>.

   [IPv6AltMark]
              Fioccola, G., Zhou, T., Cociglio, M., Qin, F., and R.
              Pang, "IPv6 Application of the Alternate-Marking Method",
              RFC 9343, DOI 10.17487/RFC9343, December 2022,
              <https://www.rfc-editor.org/info/rfc9343>.

   [QUIC-MANAGEABILITY]
              Kühlewind, M. and B. Trammell, "Manageability of the QUIC
              Transport Protocol", RFC 9312, DOI 10.17487/RFC9312,
              September 2022, <https://www.rfc-editor.org/info/rfc9312>.

   [QUIC-SPIN]
              Trammell, B., Ed., De Vaere, P., Even, R., Fioccola, G.,
              Fossati, T., Ihlar, M., Morton, A., and S. Emile, "Adding
              Explicit Passive Measurability of Two-Way Latency to the
              QUIC Transport Protocol", Work in Progress, Internet-
              Draft, draft-trammell-quic-spin-03, 14 May 2018,
              <https://datatracker.ietf.org/doc/html/draft-trammell-
              quic-spin-03>.

   [QUIC-TLS] Thomson, M., Ed. and S. Turner, Ed., "Using TLS to Secure
              QUIC", RFC 9001, DOI 10.17487/RFC9001, May 2021,
              <https://www.rfc-editor.org/info/rfc9001>.

   [RFC8701]  Benjamin, D., "Applying Generate Random Extensions And
              Sustain Extensibility (GREASE) to TLS Extensibility",
              RFC 8701, DOI 10.17487/RFC8701, January 2020,
              <https://www.rfc-editor.org/info/rfc8701>.

   [RTT-PRIVACY]
              Trammell, B. and M. Kühlewind, "Revisiting the Privacy
              Implications of Two-Way Internet Latency Data", Passive
              and Active Measurement, pp. 73-84, Springer International
              Publishing, DOI 10.1007/978-3-319-76481-8_6,
              ISBN 9783319764801, March 2018,
              <https://doi.org/10.1007/978-3-319-76481-8_6>.

   [TRANSPORT-ENCRYPT]
              Fairhurst, G. and C. Perkins, "Considerations around
              Transport Header Confidentiality, Network Operations, and
              the Evolution of Internet Transport Protocols", RFC 9065,
              DOI 10.17487/RFC9065, July 2021,
              <https://www.rfc-editor.org/info/rfc9065>.

   [TSVWG-SPIN]
              Trammell, B., Ed., "A Transport-Independent Explicit
              Signal for Hybrid RTT Measurement", Work in Progress,
              Internet-Draft, draft-trammell-tsvwg-spin-00, 2 July 2018,
              <https://datatracker.ietf.org/doc/html/draft-trammell-
              tsvwg-spin-00>.

   [UDP-OPTIONS]
              Touch, J., "Transport Options for UDP", Work in Progress,
              Internet-Draft, draft-ietf-tsvwg-udp-options-23, 15
              September 2023, <https://datatracker.ietf.org/doc/html/
              draft-ietf-tsvwg-udp-options-23>.

   [UDP-SURPLUS]
              Herbert, T., "UDP Surplus Header", Work in Progress,
              Internet-Draft, draft-herbert-udp-space-hdr-01, 8 July
              2019, <https://datatracker.ietf.org/doc/html/draft-
              herbert-udp-space-hdr-01>.
```

---
# **Acknowledgments**

저자는 기여한 QUIC WG, 피코퀵 스택에 Q 및 L 비트를 구현한 Christian Huitema, 건설적인 리뷰와 유용한 제안을 제공한 Ike Kunze에게 감사의 말씀을 전하고 싶습니다.

---
# **Contributors**

다음 사람들은 이 문서에 귀중한 기여를 했습니다.

```text
   Marcus Ihlar
   Ericsson
   Email: marcus.ihlar@ericsson.com

   Jari Arkko
   Ericsson
   Email: jari.arkko@ericsson.com

   Emile Stephan
   Orange
   Email: emile.stephan@orange.com

   Dmitri Tikhonov
   LiteSpeed Technologies
   Email: dtikhonov@litespeedtech.com
```

---
# **Authors' Addresses**

Mauro Cociglio Telecom Italia - TIM Via Reiss Romoli, 274 10148 Torino Italy 이메일: mauro.cociglio@outlook.com

```text
   Alexandre Ferrieux
   Orange Labs
   Email: alexandre.ferrieux@orange.com

   Giuseppe Fioccola
   Huawei Technologies
   Riesstrasse, 25
   80992 Munich
   Germany
   Email: giuseppe.fioccola@huawei.com

   Igor Lubashev
   Akamai Technologies
   Email: ilubashe@akamai.com
```

Fabio Bulgarella Telecom Italia - TIM Via Reiss Romoli, 274 10148 Torino Italy 이메일: fabio.bulgarella@guest.telecomitalia.it

Massimo Nilo Telecom Italia - TIM Via Reiss Romoli, 274 10148 Torino Italy 이메일: Massimo.nilo@telecomitalia.it

```text
   Isabelle Hamchaoui
   Orange Labs
   Email: isabelle.hamchaoui@orange.com

   Riccardo Sisto
   Politecnico di Torino
   Email: riccardo.sisto@polito.it
```
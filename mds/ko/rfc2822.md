

```text
Network Working Group                                 P. Resnick, Editor
Request for Comments: 2822                         QUALCOMM Incorporated
Obsoletes: 822                                                April 2001
Category: Standards Track

                        Internet Message Format
```

---
# **Status of this Memo**

본 문서는 인터넷 커뮤니티를 위한 인터넷 표준 트랙 프로토콜을 명시하고 개선을 위한 논의와 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "인터넷 공식 프로토콜 표준"\(STD 1\) 최신판을 참조하세요. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2001\). 판권 소유.

---
# **Abstract**

이 표준은 "전자 메일" 메시지 프레임워크 내에서 컴퓨터 사용자 간에 전송되는 텍스트 메시지의 구문을 지정합니다.  이 표준은 RFC\(Request For Comments\) 822, "ARPA 인터넷 텍스트 메시지 형식에 대한 표준"에 지정된 표준을 대체하여 현재 관행을 반영하고 다른 RFC에 지정된 점진적 변경 사항을 통합하도록 업데이트합니다.

---
# **Table of Contents**

```text
   1. Introduction ............................................... 3
   1.1. Scope .................................................... 3
   1.2. Notational conventions ................................... 4
   1.2.1. Requirements notation .................................. 4
   1.2.2. Syntactic notation ..................................... 4
   1.3. Structure of this document ............................... 4
   2. Lexical Analysis of Messages ............................... 5
   2.1. General Description ...................................... 5
   2.1.1. Line Length Limits ..................................... 6
   2.2. Header Fields ............................................ 7
   2.2.1. Unstructured Header Field Bodies ....................... 7
   2.2.2. Structured Header Field Bodies ......................... 7
   2.2.3. Long Header Fields ..................................... 7
   2.3. Body ..................................................... 8
   3. Syntax ..................................................... 9
   3.1. Introduction ............................................. 9
   3.2. Lexical Tokens ........................................... 9
   3.2.1. Primitive Tokens ....................................... 9
   3.2.2. Quoted characters ......................................10
   3.2.3. Folding white space and comments .......................11
   3.2.4. Atom ...................................................12
   3.2.5. Quoted strings .........................................13
   3.2.6. Miscellaneous tokens ...................................13
   3.3. Date and Time Specification ..............................14
   3.4. Address Specification ....................................15
   3.4.1. Addr-spec specification ................................16
   3.5 Overall message syntax ....................................17
   3.6. Field definitions ........................................18
   3.6.1. The origination date field .............................20
   3.6.2. Originator fields ......................................21
   3.6.3. Destination address fields .............................22
   3.6.4. Identification fields ..................................23
   3.6.5. Informational fields ...................................26
   3.6.6. Resent fields ..........................................26
   3.6.7. Trace fields ...........................................28
   3.6.8. Optional fields ........................................29
   4. Obsolete Syntax ............................................29
   4.1. Miscellaneous obsolete tokens ............................30
   4.2. Obsolete folding white space .............................31
   4.3. Obsolete Date and Time ...................................31
   4.4. Obsolete Addressing ......................................33
   4.5. Obsolete header fields ...................................33
   4.5.1. Obsolete origination date field ........................34
   4.5.2. Obsolete originator fields .............................34
   4.5.3. Obsolete destination address fields ....................34
   4.5.4. Obsolete identification fields .........................35
   4.5.5. Obsolete informational fields ..........................35
   4.5.6. Obsolete resent fields .................................35
   4.5.7. Obsolete trace fields ..................................36
   4.5.8. Obsolete optional fields ...............................36
   5. Security Considerations ....................................36
   6. Bibliography ...............................................37
   7. Editor's Address ...........................................38
   8. Acknowledgements ...........................................39
   Appendix A. Example messages ..................................41
   A.1. Addressing examples ......................................41
   A.1.1. A message from one person to another with simple
          addressing .............................................41
   A.1.2. Different types of mailboxes ...........................42
   A.1.3. Group addresses ........................................43
   A.2. Reply messages ...........................................43
   A.3. Resent messages ..........................................44
   A.4. Messages with trace fields ...............................46
   A.5. White space, comments, and other oddities ................47
   A.6. Obsoleted forms ..........................................47
   A.6.1. Obsolete addressing ....................................48
   A.6.2. Obsolete dates .........................................48
   A.6.3. Obsolete white space and comments ......................48
   Appendix B. Differences from earlier standards ................49
   Appendix C. Notices ...........................................50
   Full Copyright Statement ......................................51
```

---
## **1. Introduction**
---
### **1.1. Scope**

이 표준은 "전자 메일" 메시지 프레임워크 내에서 컴퓨터 사용자 간에 전송되는 텍스트 메시지의 구문을 지정합니다.  이 표준은 RFC\(Request For Comments\) 822, "ARPA 인터넷 텍스트 메시지 형식에 대한 표준"\[RFC822\]에 지정된 표준을 대체하며, 현재 관행을 반영하도록 업데이트하고 다른 RFC\[STD3\]에 지정된 점진적 변경 사항을 통합합니다.

이 표준은 문자 메시지에 대해서만 구문을 지정합니다.  특히, 전자 메일 메시지의 이미지, 오디오 또는 기타 종류의 구조화된 데이터 전송에 대한 규정을 제공하지 않습니다. MIME 문서 시리즈 \[RFC2045, RFC2046, RFC2049\]와 같이 여기에 제공된 구문을 확장하거나 해당 메시지를 이 구문에 맞게 구성하여 전자 메일을 통해 해당 데이터를 전송하는 메커니즘을 설명하는 여러 확장이 게시되었습니다. .  이러한 메커니즘은 이 표준의 범위를 벗어납니다.

전자 메일의 경우 메시지는 봉투와 내용을 포함하는 것으로 간주됩니다.  봉투에는 전송 및 전달을 수행하는 데 필요한 모든 정보가 포함되어 있습니다.  \(봉투에 대한 논의는 \[RFC2821\]을 참조하십시오.\) 내용은 수신자에게 전달될 객체를 구성합니다.  이 표준은 메시지 내용의 형식과 일부 의미에만 적용됩니다.  봉투에 담긴 정보에 대한 사양은 포함되어 있지 않습니다.

그러나 일부 메시지 시스템에서는 내용의 정보를 사용하여 봉투를 만들 수 있습니다.  이 표준은 프로그램이 그러한 정보를 쉽게 얻을 수 있도록 하기 위한 것입니다.

이 사양은 시스템 간에 전달되는 메시지 콘텐츠 형식을 정의하기 위한 것입니다.  일부 메시지 시스템은 메시지를 이 형식\(형식 간 변환이 필요 없음\)으로 로컬로 저장하고 다른 시스템은 이 표준에 지정된 것과 다른 형식을 사용하지만 로컬 저장소는 이 표준의 범위를 벗어납니다.

참고: 이 표준은 사이트에서 사용하는 내부 형식, 사이트에서 지원할 것으로 예상되는 특정 메시지 시스템 기능 또는 메시지를 생성하거나 읽는 사용자 인터페이스 프로그램의 특성을 규정하기 위한 것이 아닙니다.  또한 이 표준은 전송이나 저장을 위한 문자 인코딩을 지정하지 않습니다. 즉, 사용된 비트 수나 해당 비트가 유선을 통해 구체적으로 전송되거나 디스크에 저장되는 방법을 지정하지 않습니다.

---
### **1.2. Notational conventions**
---
#### **1.2.1. Requirements notation**

이 문서에서는 대문자로 표시되는 용어를 사용하는 경우가 있습니다. "MUST", "SHOULD", "RECOMMENDED", "MUST NOT", "SHOULD NOT" 및 "MAY"라는 용어가 대문자로 표시되면 이 사양의 특정 요구 사항을 나타내는 데 사용됩니다.  이러한 용어의 의미에 대한 논의는 \[RFC2119\]에 나와 있습니다.

---
#### **1.2.2. Syntactic notation**

이 표준은 메시지 구문의 형식적 정의를 위해 \[RFC2234\]에 지정된 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다.  문자는 10진수 값\(예: 대문자 A의 경우 %d65 값, 소문자 A의 경우 %d97 값\) 또는 따옴표로 묶인 대소문자를 구분하지 않는 리터럴 값\(예: 대문자 또는 소문자 A의 경우 "A"\)으로 지정됩니다. \).  표기법에 대한 전체 설명은 \[RFC2234\]를 참조하세요.

---
### **1.3. Structure of this document**

이 문서는 여러 섹션으로 나누어져 있습니다.

이 섹션, 섹션 1은 문서에 대한 간략한 소개입니다.

섹션 2에서는 메시지와 그 구성 부분에 대한 일반적인 설명을 설명합니다.  이는 독자가 이 문서의 뒷부분에서 사용되는 일반 원칙 중 일부를 이해하는 데 도움이 되는 개요입니다.  이 섹션의 모든 예는 메시지 일부의 형식적 구문 사양으로 간주되어서는 안 됩니다.

섹션 3에서는 메시지의 각 부분 구조\(구문\)에 대한 공식 ABNF 규칙을 지정하고 해당 부분 간의 관계와 메시지 맥락에서의 의미\(의미론\)를 설명합니다.  즉, 메시지의 각 부분 구조에 대한 실제 규칙\(구문\)뿐만 아니라 부분에 대한 설명과 해당 부분이 어떻게 해석되어야 하는지에 대한 지침\(의미론\)도 설명합니다.  여기에는 구문 및 의미 분석이 포함됩니다.

특정 구조를 가진 메시지의 하위 부분.  섹션 3에 포함된 구문은 반드시 생성되어야 하는 메시지를 나타냅니다. 섹션 3에는 구문에 지정된 옵션 중 하나를 다른 옵션보다 사용해야 하는지 여부를 나타내는 참고 사항도 있습니다.

섹션 2와 3 모두 이 표준의 목적에 따라 생성할 수 있는 합법적인 메시지를 설명합니다.

이 문서의 섹션 4에서는 "구식" 구문을 지정합니다.  섹션 3에는 이러한 쓸모없는 구문 요소에 대한 참조가 있습니다.  폐기된 구문의 규칙은 이 표준의 이전 개정판에 나타났거나 이전에 인터넷 메시지에서 널리 사용되었던 요소입니다.  따라서 이러한 요소는 이 표준을 준수하기 위해 메시지 구문 분석기에 의해 해석되어야 합니다.  그러나 이 구문의 항목은 상호 운용이 불가능하거나 메시지 수신자에게 심각한 문제를 일으키는 것으로 결정되었으므로 적합한 메시지의 작성자가 생성해서는 안 됩니다.

섹션 5에서는 이 표준을 구현할 때 고려해야 할 보안 고려 사항을 자세히 설명합니다.

섹션 6은 이 문서의 참고문헌 목록입니다.

섹션 7에는 편집자의 주소가 포함되어 있습니다.

```text
   Section 8 contains acknowledgements.
```

부록 A에는 다양한 종류의 메시지 예가 나열되어 있습니다.  이러한 예는 인터넷에 나타나는 메시지 유형을 모두 망라하지는 않지만 특정 구문 형식에 대한 광범위한 개요를 제공합니다.

부록 B에는 인터넷 메시지에 대한 이 표준과 이전 표준 간의 차이점이 나열되어 있습니다.

부록 C에는 저작권 및 지적 재산권 고지 사항이 있습니다.

---
## **2. Lexical Analysis of Messages**
---
### **2.1. General Description**

가장 기본적인 수준에서 메시지는 일련의 문자입니다.  이 표준을 준수하는 메시지는 1\~127 범위의 값을 갖는 문자로 구성되며 US-ASCII 문자\[ASCII\]로 해석됩니다.  간결하게 하기 위해 이 문서에서는 이 문자 범위를 간단히 "US-ASCII 문자"라고 부르기도 합니다.

참고: 이 표준은 메시지가 1부터 127까지의 US-ASCII 범위의 문자로 구성됨을 지정합니다. 이 표준을 확장하는 다른 문서, 특히 MIME 문서 시리즈 \[RFC2045, RFC2046, RFC2047, RFC2048, RFC2049\]가 있습니다. 해당 범위를 벗어나는 값을 허용합니다.  이러한 메커니즘에 대한 논의는 이 표준의 범위에 포함되지 않습니다.

메시지는 여러 줄의 문자로 구분됩니다.  줄은 캐리지 리턴과 줄 바꿈 두 문자로 구분되는 일련의 문자입니다. 즉, 캐리지 리턴\(CR\) 문자\(ASCII 값 13\) 바로 뒤에 줄 바꿈\(LF\) 문자\(ASCII 값 10\)가 옵니다.  \(캐리지 리턴/줄 바꿈 쌍은 일반적으로 이 문서에서 "CRLF"로 기록됩니다.\)

메시지는 헤더 필드\(총칭하여 "메시지 헤더"라고 함\)와 선택적으로 본문으로 구성됩니다.  헤더는 이 표준에 정의된 특수 구문을 사용하는 일련의 문자 라인입니다. 본문은 단순히 헤더 뒤에 오는 일련의 문자이며 빈 줄\(예: CRLF 앞에 아무것도 없는 줄\)로 헤더와 구분됩니다.

---
#### **2.1.1. Line Length Limits**

이 표준에서는 한 줄의 문자 수에 두 가지 제한을 둡니다. 각 문자 줄은 998자 이하여야 하며 CRLF를 제외하고 78자 이하여야 합니다.

998자 제한은 한 줄에서 998자 이상을 처리할 수 없는 인터넷 메시지 형식 메시지를 전송, 수신 또는 저장하는 많은 구현의 제한으로 인해 발생합니다. 수신 구현은 견고성을 위해 한 줄에 임의로 많은 수의 문자를 처리하는 것이 좋습니다. 그러나 \(\[RFC2821\]의 전송 요구 사항을 준수하여\) 한 줄에 CR 및 LF를 포함하여 1000자 이상의 문자가 포함된 메시지를 허용하지 않는 구현이 너무 많기 때문에 구현에서는 그러한 메시지를 생성하지 않는 것이 중요합니다.

보다 보수적인 78자 권장 사항은 이러한 구현이 표준에 부합하지 않는다는 사실에도 불구하고 한 줄에 78자 이상의 표시를 자르거나 비참하게 래핑할 수 있는 이러한 메시지를 표시하는 사용자 인터페이스의 많은 구현을 수용하는 것입니다. 이 사양의 의도\(실제로 정보가 손실되는 경우 \[RFC2821\]의 의도\). 다시 말하지만, 이 제한이 메시지에 적용되더라도 메시지를 표시하는 구현에 따라 달라집니다.

견고성을 위해 한 줄에서 임의로 많은 수의 문자\(확실히 최소 998자 제한까지\)를 처리합니다.

---
### **2.2. Header Fields**

헤더 필드는 필드 이름, 콜론\(":"\), 필드 본문, CRLF로 끝나는 줄로 구성됩니다.  필드 이름은 콜론을 제외하고 인쇄 가능한 US-ASCII 문자\(즉, 33에서 126 사이의 값을 갖는 문자\)로 구성되어야 합니다.  필드 본문은 CR 및 LF를 제외한 모든 US-ASCII 문자로 구성될 수 있습니다.  그러나 섹션 2.2.3에 설명된 대로 헤더 "접기" 및 "펼치기"에 사용되는 경우 필드 본문에 CRLF가 포함될 수 있습니다.  모든 필드 본문은 이 표준의 섹션 3과 4에 설명된 구문을 준수해야 합니다.

---
#### **2.2.1. Unstructured Header Field Bodies**

이 표준의 일부 필드 본문은 추가 제한 없이 간단히 "구조화되지 않은"\(CR 및 LF를 제외한 모든 US-ASCII 문자로 아래에 지정됨\)로 정의됩니다.  이를 구조화되지 않은 필드 바디라고 합니다.  의미상 구조화되지 않은 필드 본문은 추가 처리 없이 단순히 한 줄의 문자로 처리됩니다\(섹션 2.2.3에 설명된 헤더 "접기" 및 "펼치기" 제외\).

---
#### **2.2.2. Structured Header Field Bodies**

이 표준의 일부 필드 본문은 위에 설명된 구조화되지 않은 필드 본문보다 더 제한적인 특정 구문 구조를 가지고 있습니다. 이를 "구조화된" 필드 본문이라고 합니다. 구조화된 필드 본문은 이 표준의 섹션 3과 4에 설명된 특정 어휘 토큰의 시퀀스입니다.  이러한 토큰 중 다수는 구문에 따라 공백\(SP, ASCII 값 32\) 및 가로 탭\(HTAB, ASCII 값 9\)뿐만 아니라 주석\(섹션 3.2.3에 설명됨\)으로 시작하거나 끝날 수 있습니다. 문자\(공백 문자, WSP라고도 함\)와 해당 WSP 문자에는 섹션 2.2.3에 설명된 대로 헤더 "접기" 및 "펼치기"가 적용됩니다.  구조화된 필드 본문의 의미 분석이 해당 구문과 함께 제공됩니다.

---
#### **2.2.3. Long Header Fields**

각 헤더 필드는 논리적으로 필드 이름, 콜론 및 필드 본문을 구성하는 한 줄의 문자입니다.  그러나 편의를 위해 그리고 줄당 998/78 문자 제한을 처리하기 위해 헤더 필드의 필드 본문 부분을 여러 줄 표현으로 분할할 수 있습니다. 이것을 "접기"라고 합니다.  일반적인 규칙은

이 표준이 공백\(단순히 WSP 문자가 아닌\) 접기를 허용하는 경우 WSP 앞에 CRLF를 삽입할 수 있습니다.  예를 들어 헤더 필드는 다음과 같습니다.

```text
           Subject: This is a test
```

다음과 같이 표현될 수 있습니다:

```text
           Subject: This
            is a test
```

참고: 구조화된 필드 본문은 접기가 많은 어휘 토큰 사이에서\(심지어 일부 어휘 토큰 내에서도\) 발생할 수 있는 방식으로 정의되어 있지만 접기는 더 높은 수준의 구문 구분에 CRLF를 배치하는 것으로 제한되어야 합니다.  예를 들어, 필드 본문이 쉼표로 구분된 값으로 정의된 경우 다른 곳에서 허용되더라도 필드를 접을 수 있는 다른 위치보다 우선적으로 구조화된 항목을 구분하는 쉼표 이후에 접기를 수행하는 것이 좋습니다.

헤더 필드의 접힌 여러 줄 표현에서 한 줄 표현으로 이동하는 프로세스를 "펼침"이라고 합니다. WSP 바로 뒤에 오는 CRLF를 제거하면 전개가 완료됩니다.  각 헤더 필드는 추가 구문 및 의미 평가를 위해 펼쳐진 형식으로 처리되어야 합니다.

---
### **2.3. Body**

메시지 본문은 단순히 US-ASCII 문자 줄입니다.  신체에 대한 유일한 두 가지 제한 사항은 다음과 같습니다.

- CR과 LF는 CRLF로만 함께 발생해야 합니다. 신체에서 독립적으로 나타나서는 안 됩니다.

- 본문의 문자 줄은 998자로 제한되어야 하며, CRLF를 제외하고 78자로 제한되어야 합니다.

참고: 앞서 설명한 대로 다른 표준 문서, 특히 다양한 종류의 메시지 본문을 허용하도록 이 표준을 확장하는 MIME 문서\[RFC2045, RFC2046, RFC2048, RFC2049\]가 있습니다.  다시 말하지만 이러한 메커니즘은 이 문서의 범위를 벗어납니다.

---
## **3. Syntax**
---
### **3.1. Introduction**

이 섹션에 제공된 구문은 인터넷 메시지의 법적 구문을 정의합니다.  이 표준을 준수하는 메시지는 이 섹션의 구문을 준수해야 합니다.  이 섹션에 하나의 옵션을 생성해야 하는 옵션이 있는 경우, 이는 구문 옆의 주석이나 구문에 표시됩니다.

정의된 표현식의 경우 구문 및 용도에 대한 간단한 설명이 제공되고 ABNF의 구문이 이어지며 의미 분석이 이어집니다.  사용되지만 지정되지 않은 기본 토큰은 \[RFC2234\]에서 제공됩니다.

일부 정의에는 이름이 "obs-"로 시작하는 비터미널이 있습니다.  이러한 "obs-" 요소는 섹션 4의 사용되지 않는 구문에 정의된 토큰을 참조합니다. 모든 경우에 이러한 생성은 합법적인 인터넷 메시지를 생성할 목적으로 무시되어야 하며 그러한 메시지의 일부로 사용되어서는 안 됩니다.  그러나 메시지를 해석할 때 이러한 토큰은 법적 구문의 일부로 존중되어야 합니다.  이러한 의미에서 섹션 3에서는 무시해야 하는 "obs-" 요소를 사용하여 메시지 생성을 위한 문법을 ​​정의하고, 섹션 4에서는 메시지 해석을 위한 문법을 ​​추가합니다.

---
### **3.2. Lexical Tokens**

다음 규칙은 상위 수준 파서에 토큰을 제공하는 기본 어휘 분석기를 정의하는 데 사용됩니다.  이 섹션에서는 구조화된 헤더 필드 본문에 사용되는 토큰을 정의합니다.

참고: 이 표준의 독자는 문서 뒷부분의 하위 수준 및 상위 수준 구문 모두에서 이러한 어휘 토큰이 어떻게 사용되는지에 특별한 주의를 기울여야 합니다.  특히, 3.2.3절에 정의된 공백 토큰과 주석 토큰은 여기에서 정의된 하위 수준 토큰에 사용되며, 해당 하위 수준 토큰은 나중에 정의되는 상위 수준 토큰의 일부로 사용됩니다. 따라서 공백과 주석은 특정 정의에 명시적으로 나타나지 않더라도 상위 수준 토큰에서 허용될 수 있습니다.

---
#### **3.2.1. Primitive Tokens**

다음은 이 표준의 다른 곳에서 참조되지만 \[RFC2234\]에서는 달리 정의되지 않은 기본 토큰입니다.  그 중 일부는 구문의 다른 부분에 나타나지 않지만 이 문서의 다른 부분에서 참조하는 것이 편리합니다.

참고: 아래의 "특선"은 그러한 예일 뿐입니다.  특수 토큰은 이 표준의 다른 어디에도 나타나지 않지만 메시지를 어휘적으로 분석하는 도구를 사용하는 구현자에게 유용합니다.  특수 문자의 각 문자는 어휘 분석에서 토큰화 지점을 나타내는 데 사용될 수 있습니다.

```text
NO-WS-CTL       =       %d1-8 /         ; US-ASCII control characters
                        %d11 /          ;  that do not include the
                        %d12 /          ;  carriage return, line feed,
                        %d14-31 /       ;  and white space characters
                        %d127

text            =       %d1-9 /         ; Characters excluding CR and LF
                        %d11 /
                        %d12 /
                        %d14-127 /
                        obs-text

specials        =       "(" / ")" /     ; Special characters used in
                        "<" / ">" /     ;  other parts of the syntax
                        "[" / "]" /
                        ":" / ";" /
                        "@" / "\" /
                        "," / "." /
                        DQUOTE
```

이러한 토큰에는 특별한 의미가 첨부되지 않습니다.  그들은 단순히 단일 문자입니다.

---
#### **3.2.2. Quoted characters**

일부 문자는 어휘 토큰 구분과 같은 특수 해석을 위해 예약되어 있습니다.  이러한 문자를 해석되지 않은 데이터로 사용하도록 허용하기 위해 인용 메커니즘이 제공됩니다.

---
# **quoted-pair     =       ("\" text) / obs-qp**

인용된 쌍이 나타나는 경우 이는 텍스트 문자만으로 해석됩니다.  즉, 인용 쌍의 일부로 나타나는 "\" 문자는 의미상 "보이지 않습니다".

참고: "\" 문자는 인용 쌍의 일부가 아닌 메시지에 나타날 수 있습니다.  인용 쌍에 나타나지 않는 "\" 문자는 의미상 보이지 않습니다.  이 표준에서 현재 인용 쌍이 나타나는 유일한 위치는 ccontent, qcontent, dcontent, no-fold-quote 및 no-fold-literal입니다.

---
#### **3.2.3. Folding white space and comments**

접기에 사용되는 공백\(섹션 2.2.3에 설명됨\)을 포함한 공백 문자는 헤더 필드 본문의 여러 요소 사이에 나타날 수 있습니다.  또한 주석으로 처리되는 문자열은 구조화된 필드 본문에 괄호로 묶인 문자로 포함될 수 있습니다.  다음은 FWS\(접이식 공백\) 및 주석 구성을 정의합니다.

괄호로 묶인 문자열은 섹션 3.2.5에 정의된 대로 "인용 문자열" 내에 나타나지 않는 한 주석으로 간주됩니다.  주석은 중첩될 수 있습니다.

이 표준에는 주석과 FWS를 자유롭게 삽입할 수 있는 여러 위치가 있습니다.  해당 구문을 수용하기 위해 댓글 및/또는 FWS가 발생할 수 있는 위치에 대해 "CFWS"에 대한 추가 토큰이 정의됩니다. 그러나 이 표준에서 CFWS가 발생하는 경우 접힌 헤더 필드의 모든 행이 완전히 WSP 문자로 구성되고 다른 문자로 구성되지 않는 방식으로 삽입되어서는 안 됩니다.

```text
FWS             =       ([*WSP CRLF] 1*WSP) /   ; Folding white space
                        obs-FWS
```

---
# **ctext           =       NO-WS-CTL /     ; Non white space controls**

```text
                        %d33-39 /       ; The rest of the US-ASCII
                        %d42-91 /       ;  characters not including "(",
                        %d93-126        ;  ")", or "\"
```

---
# **ccontent        =       ctext / quoted-pair / comment**
---
# **comment         =       "(" *([FWS] ccontent) [FWS] ")"**
---
# **CFWS            =       *([FWS] comment) (([FWS] comment) / FWS)**

이 표준 전체에서 FWS\(접이식 공백 토큰\)가 나타나는 곳은 섹션 2.2.3에서 설명한 대로 헤더 접기가 발생할 수 있는 위치를 나타냅니다.  메시지에 헤더 접기가 나타날 때마다\(즉, WSP 뒤에 CRLF가 포함된 헤더 필드 본문\) 헤더 전개\(CRLF 제거\)는 이 표준에 따라 해당 헤더 필드에 대한 추가 어휘 분석이 수행되기 전에 수행됩니다.  즉, FWS에 나타나는 모든 CRLF는 의미상 "보이지 않습니다".

주석은 일반적으로 구조화된 필드 본문에서 사람이 읽을 수 있는 정보 텍스트를 제공하는 데 사용됩니다.  댓글에는 FWS가 포함될 수 있으므로 댓글 내에서 접는 것이 허용됩니다.  또한 주석에는 인용 쌍이 허용되므로 괄호와

백슬래시 문자는 따옴표 쌍으로 표시되는 한 주석에 표시될 수 있습니다.  의미상으로 묶는 괄호는 주석의 일부가 아닙니다. 주석은 두 괄호 사이에 포함된 내용입니다.  앞서 설명한 대로 인용된 쌍의 "\"와 주석 내에 나타나는 FWS의 CRLF는 의미상 "보이지 않으므로" 주석의 일부가 아닙니다.

구조화된 필드 헤더의 어휘 토큰 사이에서 발생하는 FWS, 주석 또는 CFWS의 실행은 의미상 단일 공백 ​​문자로 해석됩니다.

---
#### **3.2.4. Atom**

구조화된 헤더 필드 본문의 여러 생성은 단순히 특정 기본 문자의 문자열입니다.  이러한 생산물을 원자라고 합니다.

구조화된 헤더 필드 본문 중 일부는 atext 실행 내에서 마침표 문자\(".", ASCII 값 46\)도 허용합니다.  이러한 목적을 위해 추가 "점 원자" 토큰이 정의됩니다.

```text
atext           =       ALPHA / DIGIT / ; Any character except controls,
                        "!" / "#" /     ;  SP, and specials.
                        "$" / "%" /     ;  Used for atoms
                        "&" / "'" /
                        "*" / "+" /
                        "-" / "/" /
                        "=" / "?" /
                        "^" / "_" /
                        "`" / "{" /
                        "|" / "}" /
                        "~"
```

---
# **atom            =       [CFWS] 1*atext [CFWS]**
---
# **dot-atom        =       [CFWS] dot-atom-text [CFWS]**
---
# **dot-atom-text   =       1*atext *("." 1*atext)**

원자와 도트 원자는 모두 그것을 구성하는 문자열로 구성된 단일 단위로 해석됩니다.  의미상 나머지 문자를 둘러싼 선택적 주석과 FWS는 원자의 일부가 아닙니다. 원자는 원자의 atext 문자 또는 atext와 "."의 연속일 뿐입니다. 도트 원자의 문자.

---
#### **3.2.5. Quoted strings**

Atom에서 허용되는 문자 이외의 문자를 포함하는 문자 문자열은 따옴표\(DQUOTE, ASCII 값 34\) 문자로 묶인 따옴표 붙은 문자열 형식으로 표시될 수 있습니다.

---
# **qtext           =       NO-WS-CTL /     ; Non white space controls**

```text
                        %d33 /          ; The rest of the US-ASCII
                        %d35-91 /       ;  characters not including "\"
                        %d93-126        ;  or the quote character
```

---
# **qcontent        =       qtext / quoted-pair**

```text
quoted-string   =       [CFWS]
                        DQUOTE *([FWS] qcontent) [FWS] DQUOTE
                        [CFWS]
```

인용 문자열은 하나의 단위로 처리됩니다.  즉, quoted-string은 의미상 원자와 동일합니다.  인용 문자열에는 FWS가 포함될 수 있으므로 접는 것이 허용됩니다.  또한 quoted-string에서 quoted-pair가 허용되므로 quoted-string으로 나타나는 한 quote와 backslash 문자가 quoted-string에 나타날 수 있습니다.

의미상으로 인용 문자 외부의 선택적 CFWS나 인용 문자 자체는 인용 문자열의 일부가 아닙니다. 인용 문자열은 두 인용 문자 사이에 포함된 내용입니다.  앞서 설명한 대로 인용된 쌍의 "\"와 인용된 문자열 내에 나타나는 FWS/CFWS의 CRLF는 의미상 "보이지 않으며" 따라서 인용된 문자열의 일부도 아닙니다.

---
#### **3.2.6. Miscellaneous tokens**

원자 및/또는 인용 문자열의 조합을 위한 단어 및 구문, 구조화되지 않은 헤더 필드 및 구조화된 헤더 필드 내의 일부 위치에서 사용하기 위한 구조화되지 않은 세 가지 추가 토큰이 정의됩니다.

---
# **word            =       atom / quoted-string**
---
# **phrase          =       1*word / obs-phrase**

```text
utext           =       NO-WS-CTL /     ; Non white space controls
                        %d33-126 /      ; The rest of US-ASCII
                        obs-utext
```

---
# **unstructured    =       *([FWS] utext) [FWS]**
---
### **3.3. Date and Time Specification**

날짜와 시간은 여러 헤더 필드에 나타납니다.  이 섹션에서는 전체 날짜 및 시간 지정에 대한 구문을 지정합니다.  날짜-시간 사양 전체에서 접는 공백이 허용되지만 FWS가 표시되는 각 위치\(필수 또는 선택 여부\)에 단일 공백을 사용하는 것이 좋습니다. 일부 이전 구현에서는 공백 접기의 다른 발생을 올바르게 해석하지 못할 수 있습니다.

---
# **date-time       =       [ day-of-week "," ] date FWS time [CFWS]**
---
# **day-of-week     =       ([FWS] day-name) / obs-day-of-week**

```text
day-name        =       "Mon" / "Tue" / "Wed" / "Thu" /
                        "Fri" / "Sat" / "Sun"
```

---
# **date            =       day month year**
---
# **year            =       4*DIGIT / obs-year**
---
# **month           =       (FWS month-name FWS) / obs-month**

```text
month-name      =       "Jan" / "Feb" / "Mar" / "Apr" /
                        "May" / "Jun" / "Jul" / "Aug" /
                        "Sep" / "Oct" / "Nov" / "Dec"
```

---
# **day             =       ([FWS] 1*2DIGIT) / obs-day**
---
# **time            =       time-of-day FWS zone**
---
# **time-of-day     =       hour ":" minute [ ":" second ]**
---
# **hour            =       2DIGIT / obs-hour**
---
# **minute          =       2DIGIT / obs-minute**
---
# **second          =       2DIGIT / obs-second**
---
# **zone            =       (( "+" / "-" ) 4DIGIT) / obs-zone**

날짜는 해당 월의 숫자 날짜입니다.  연도는 1900년 이후의 숫자 연도입니다.

시간은 표시된 날짜의 자정 이후의 시간, 분 및 선택적으로 초 수를 지정합니다.

날짜와 시간은 현지 시간을 표현해야 합니다\(SHOULD\).

시간대는 날짜와 시간이 나타내는 협정 세계시\(UTC, 이전에는 "그리니치 표준시"라고 함\)와의 오프셋을 지정합니다.  "+" 또는 "-"는 현재 시간이 세계시보다 앞선\(즉, 동쪽\)지 뒤\(즉, 서쪽\)인지를 나타냅니다.  처음 두 자리는 세계시와의 시차를 나타내고, 마지막 두 자리는 세계시와의 시차를 분 단위로 나타냅니다.  \(따라서 +hhmm은 +\(hh \* 60 + mm\)분을 의미하고 -hhmm은 -\(hh \* 60 + mm\)분을 의미합니다.\)  세계시\(Universal Time\)의 시간대를 표시하려면 "+0000" 형식을 사용해야 합니다.  "-0000"은 세계시를 나타내기도 하지만, 세계시가 아닌 현지 시간대에 있을 수 있는 시스템에서 시간이 생성되었음을 나타내는 데 사용되므로 날짜-시간에 현지 시간에 대한 정보가 포함되어 있지 않음을 나타냅니다. 존.

날짜-시간 사양은 의미상 유효해야 합니다.  즉, 요일\(포함된 경우\)은 날짜가 암시하는 날짜여야 하며, 숫자 날짜는 1과 지정된 달\(지정된 연도\)에 허용되는 일 수 사이여야 합니다. \), 시간은 00:00:00부터 23:59:60\(윤초를 허용하는 초 수, \[STD12\] 참조\) 범위에 있어야 하며 영역은 다음 범위 내에 있어야 합니다. 9959부터 +9959까지.

---
### **3.4. Address Specification**

주소는 여러 메시지 헤더 필드에 나타나 메시지의 보낸 사람과 받는 사람을 나타냅니다.  주소는 개별 사서함일 수도 있고 사서함 그룹일 수도 있습니다.

---
# **address         =       mailbox / group**
---
# **mailbox         =       name-addr / addr-spec**
---
# **name-addr       =       [display-name] angle-addr**
---
# **angle-addr      =       [CFWS] "<" addr-spec ">" [CFWS] / obs-angle-addr**

```text
group           =       display-name ":" [mailbox-list / CFWS] ";"
                        [CFWS]
```

---
# **display-name    =       phrase**
---
# **mailbox-list    =       (mailbox *("," mailbox)) / obs-mbox-list**
---
# **address-list    =       (address *("," address)) / obs-addr-list**

사서함은 메일을 받습니다.  파일 저장과 반드시 ​​관련되지는 않는 개념적 엔터티입니다.  예를 들어, 일부 사이트에서는 메일을 프린터로 인쇄하여 출력물을 수취인의 책상으로 전달하도록 선택할 수 있습니다.  일반적으로 사서함은 \(1\) 메일 응용 프로그램 사용자에게 표시될 수 있는 수신자 이름\(사람 또는 시스템일 수 있음\)을 나타내는 선택적 표시 이름과 \(2\) 두 부분으로 구성됩니다. 꺾쇠 괄호\("<" 및 "\>"\)로 묶인 addr-spec 주소입니다.  또한 수신자의 이름이나 꺾쇠 괄호 없이 addr-spec 주소만 표시되는 간단한 대체 형식의 사서함도 있습니다.  인터넷 addr-spec 주소는 섹션 3.4.1에 설명되어 있습니다.

참고: 일부 레거시 구현에서는 addr-spec이 꺾쇠 괄호 없이 나타나는 간단한 형식을 사용했지만 addr-spec 다음의 주석으로 괄호 안에 수신자 이름을 포함했습니다. 주석에 있는 정보의 의미가 지정되지 않았기 때문에 구현에서는 사서함과 관련된 표시 이름을 지정하기 위해 레거시 형식 대신 사서함의 전체 이름 주소 형식을 사용해야 합니다.  또한 일부 레거시 구현은 주석을 해석하기 때문에 이러한 구현의 혼동을 피하기 위해 일반적으로 주석을 주소 필드에 사용해서는 안 됩니다.

여러 사서함을 단일 단위\(예: 배포 목록\)로 처리하려는 경우 그룹 구성을 사용할 수 있습니다.  그룹 구성을 사용하면 발신자는 명명된 수신자 그룹을 나타낼 수 있습니다. 이는 그룹의 표시 이름을 지정하고 그 뒤에 콜론을 입력한 다음 쉼표로 구분된 사서함 목록\(0과 1 포함\)을 나열하고 세미콜론으로 끝나는 방식으로 수행됩니다. 사서함 목록이 비어 있을 수 있으므로 그룹 구성을 사용하는 것은 각 수신자에 대한 개별 사서함 주소를 실제로 제공하지 않고도 하나 이상의 명명된 수신자 집합에 메시지가 전송되었음을 수신자에게 전달하는 간단한 방법이기도 합니다.

---
#### **3.4.1. Addr-spec specification**

addr-spec은 로컬로 해석된 문자열, at 기호 문자\("@", ASCII 값 64\), 인터넷 도메인을 포함하는 특정 인터넷 식별자입니다.  로컬로 해석된 문자열은 인용 문자열 또는 점 원자입니다.  문자열이 도트-원자로 표현될 수 있는 경우\(즉, atext 문자 또는 atext로 둘러싸인 "." 이외의 문자가 포함되지 않음\)

문자\)인 경우에는 점-원자 형식을 사용해야 하며 따옴표로 묶은 문자열 형식을 사용해서는 안 됩니다. addr-spec의 "@" 주위에 주석과 접는 공백을 사용하면 안 됩니다.

---
# **addr-spec       =       local-part "@" domain**
---
# **local-part      =       dot-atom / quoted-string / obs-local-part**
---
# **domain          =       dot-atom / domain-literal / obs-domain**
---
# **domain-literal  =       [CFWS] "[" *([FWS] dcontent) [FWS] "]" [CFWS]**
---
# **dcontent        =       dtext / quoted-pair**
---
# **dtext           =       NO-WS-CTL /     ; Non white space controls**

```text
                        %d33-90 /       ; The rest of the US-ASCII
                        %d94-126        ;  characters not including "[",
                                        ;  "]", or "\"
```

도메인 부분은 메일이 배달되는 지점을 식별합니다. 도트-원자 형식에서는 \[STD3, STD13, STD14\]에 설명된 대로 인터넷 도메인 이름\(호스트 이름 또는 메일 교환기 이름\)으로 해석됩니다.  도메인 리터럴 형식에서 도메인은 특정 호스트의 리터럴 인터넷 주소로 해석됩니다.  두 경우 모두 주소 지정 방법과 메시지가 특정 호스트로 전송되는 방법은 메일 전송 문서 \[RFC2821\]에서 다룹니다.  이러한 메커니즘은 이 문서의 범위를 벗어납니다.

로컬 부분 부분은 도메인 종속 문자열입니다.  주소에서는 단순히 특정 호스트에서 특정 사서함의 이름으로 해석됩니다.

---
## **3.5 Overall message syntax**

메시지는 헤더 필드로 구성되며 선택적으로 메시지 본문이 뒤따릅니다.  메시지의 줄은 CRLF를 제외하고 최대 998자여야 하지만 CRLF를 제외하고 줄은 78자로 제한하는 것이 좋습니다.  \(설명은 섹션 2.1.1을 참조하십시오.\) 메시지 본문에서는 텍스트 규칙에 나열된 모든 문자를 사용할 수 있지만 US-ASCII 제어 문자\(값 1\~8, 11, 12 및 14\~14\)를 사용할 수 있습니다. 31\) 디스플레이를 위한 수신기의 해석이 보장되지 않으므로 권장되지 않습니다.

```text
message         =       (fields / obs-fields)
                        [CRLF body]
```

---
# **body            =       *(*998text CRLF) *998text**

헤더 필드는 대부분의 의미 정보를 전달하며 섹션 3.6에 정의되어 있습니다.  본문은 이 표준의 목적에 따라 해석되지 않는 일련의 텍스트 줄입니다.

---
### **3.6. Field definitions**

메시지의 헤더 필드는 여기에서 정의됩니다.  모든 헤더 필드는 동일한 일반 구문 구조를 갖습니다. 필드 이름, 콜론, 필드 본문 순입니다.  각 헤더 필드의 특정 구문은 후속 섹션에서 정의됩니다.

참고: 후속 섹션의 각 필드에 대한 ABNF 구문에서 각 필드 이름 뒤에는 필수 콜론이 옵니다.  그러나 간결성을 위해 때로는 구문의 텍스트 설명에서 콜론이 참조되지 않습니다.  그럼에도 불구하고 이는 필수입니다.

헤더 필드가 특정 순서로 되어 있다고 보장되지 않는다는 점에 유의하는 것이 중요합니다.  어떤 순서로든 나타날 수 있으며, 인터넷을 통해 이동할 때 가끔 순서가 바뀌는 것으로 알려져 있습니다.  그러나 이 표준의 목적에 따라 헤더 필드는 메시지가 전송되거나 변환될 때 재정렬되어서는 안 됩니다.  더 중요한 것은 추적 헤더 필드와 재전송 헤더 필드를 재정렬해서는 안 되며 메시지 앞에 추가된 블록에 유지해야 한다는 것입니다.  자세한 내용은 섹션 3.6.6 및 3.6.7을 참조하세요.

유일한 필수 헤더 필드는 발신 날짜 필드와 발신자 주소 필드입니다.  다른 모든 헤더 필드는 구문상 선택 사항입니다.  자세한 내용은 이 정의 다음에 나오는 표에 포함되어 있습니다.

```text
fields          =       *(trace
                          *(resent-date /
                           resent-from /
                           resent-sender /
                           resent-to /
                           resent-cc /
                           resent-bcc /
                           resent-msg-id))
                        *(orig-date /
                        from /
                        sender /
                        reply-to /

                        to /
                        cc /
                        bcc /
                        message-id /
                        in-reply-to /
                        references /
                        subject /
                        comments /
                        keywords /
                        optional-field)
```

다음 표에는 메시지 헤더에 각 필드가 나타날 수 있는 횟수에 대한 제한과 해당 필드 사용에 대한 특별 제한 사항이 나와 있습니다.  최소 또는 최대 열의 값 옆에 있는 별표는 참고 열에 특별한 제한 사항이 나타남을 나타냅니다.

---
# **Field           Min number      Max number      Notes**

```text
trace           0               unlimited       Block prepended - see
                                                3.6.7

resent-date     0*              unlimited*      One per block, required
                                                if other resent fields
                                                present - see 3.6.6

resent-from     0               unlimited*      One per block - see
                                                3.6.6

resent-sender   0*              unlimited*      One per block, MUST
                                                occur with multi-address
                                                resent-from - see 3.6.6

resent-to       0               unlimited*      One per block - see
                                                3.6.6

resent-cc       0               unlimited*      One per block - see
                                                3.6.6

resent-bcc      0               unlimited*      One per block - see
                                                3.6.6

resent-msg-id   0               unlimited*      One per block - see
                                                3.6.6
```

---
# **orig-date       1               1**
---
# **from            1               1               See sender and 3.6.2**

```text
sender          0*              1               MUST occur with multi-
                                                address from - see 3.6.2
```

---
# **reply-to        0               1**
---
# **to              0               1**
---
# **cc              0               1**
---
# **bcc             0               1**

```text
message-id      0*              1               SHOULD be present - see
                                                3.6.4

in-reply-to     0*              1               SHOULD occur in some
                                                replies - see 3.6.4

references      0*              1               SHOULD occur in some
                                                replies - see 3.6.4
```

---
# **subject         0               1**
---
# **comments        0               unlimited**
---
# **keywords        0               unlimited**
---
# **optional-field  0               unlimited**

각 필드의 정확한 해석은 후속 섹션에서 설명됩니다.

---
#### **3.6.1. The origination date field**

발생 날짜 필드는 필드 이름 "Date"와 그 뒤에 오는 날짜-시간 사양으로 구성됩니다.

---
# **orig-date       =       "Date:" date-time CRLF**

발생 날짜는 메시지 작성자가 메시지가 완료되어 메일 전달 시스템에 들어갈 준비가 되었음을 표시한 날짜와 시간을 지정합니다.  예를 들어, 이는 사용자가 응용 프로그램에서 "보내기" 또는 "제출" 버튼을 누르는 시간일 수 있습니다.  어떤 경우든 이는 메시지가 실제로 전송되는 시간을 전달하기 위한 것이 아니라 메시지를 만든 사람이나 다른 작성자가 메시지를 전송 준비가 된 최종 형식으로 만든 시간을 전달하기 위한 것입니다.  \(예를 들어, 네트워크에 연결되지 않은 휴대용 컴퓨터 사용자는 메시지를 대기열에 추가할 수 있습니다.

배달용으로.  발신 날짜에는 사용자가 메시지를 보내기 위해 네트워크에 연결한 시간이 아니라 사용자가 메시지를 대기열에 넣은 날짜와 시간이 포함됩니다.\)

---
#### **3.6.2. Originator fields**

메시지의 보낸 사람 필드는 보낸 사람 필드, 보낸 사람 필드\(해당되는 경우\) 및 선택적으로 회신 필드로 구성됩니다. 보낸 사람 필드는 필드 이름 "From"과 하나 이상의 사서함 사양이 쉼표로 구분된 목록으로 구성됩니다.  from 필드가 메일함 목록에 둘 이상의 메일함 사양을 포함하는 경우 "Sender" 필드 이름과 단일 메일함 사양을 포함하는 보낸 사람 필드가 메시지에 나타나야 합니다.  두 경우 모두 필드 이름 "Reply-To"와 쉼표로 구분된 하나 이상의 주소 목록을 포함하는 선택적 회신 필드도 포함될 수 있습니다.

---
# **from            =       "From:" mailbox-list CRLF**
---
# **sender          =       "Sender:" mailbox CRLF**
---
# **reply-to        =       "Reply-To:" address-list CRLF**

발신자 필드는 메시지 소스의 사서함을 나타냅니다.  "보낸 사람:" 필드는 메시지 작성자, 즉 메시지 작성을 담당하는 사람 또는 시스템의 사서함을 지정합니다.  "발신자:" 필드는 실제 메시지 전송을 담당하는 에이전트의 사서함을 지정합니다.  예를 들어 비서가 다른 사람에게 메시지를 보내면 비서의 사서함이 "보낸 사람:" 필드에 나타나고 실제 작성자의 사서함이 "보낸 사람:" 필드에 나타납니다.  메시지 발신자가 단일 사서함으로 표시될 수 있고 작성자와 전송자가 동일한 경우 "발신자:" 필드를 사용해서는 안 됩니다.  그렇지 않으면 두 필드가 모두 표시되어야 합니다.

보낸 사람 필드는 메시지에 응답할 때 필요한 정보도 제공합니다.  "회신 대상:" 필드가 있으면 메시지 작성자가 회신을 보내도록 제안하는 사서함을 나타냅니다.  "Reply-To:" 필드가 없는 경우, 응답을 작성하는 사람이 별도로 지정하지 않는 한, 응답은 기본적으로 "From:" 필드에 지정된 사서함으로 전송되어야 합니다.

모든 경우에 "보낸 사람:" 필드에는 메시지 작성자에게 속하지 않는 사서함이 포함되어서는 안 됩니다.  응답을 위한 대상 주소 구성에 대한 자세한 내용은 섹션 3.6.3을 참조하세요.

---
#### **3.6.3. Destination address fields**

메시지의 대상 필드는 각각 동일한 형식의 세 가지 가능한 필드로 구성됩니다. 필드 이름은 "받는 사람", "참조" 또는 "숨은 참조"이고 그 뒤에 쉼표로 구분된 하나 이상의 주소 목록이 옵니다. \(사서함 또는 그룹 구문\)

---
# **to              =       "To:" address-list CRLF**
---
# **cc              =       "Cc:" address-list CRLF**
---
# **bcc             =       "Bcc:" (address-list / [CFWS]) CRLF**

대상 필드는 메시지 수신자를 지정합니다.  각 대상 필드에는 하나 이상의 주소가 있을 수 있으며, 각 주소는 메시지의 의도된 수신자를 나타냅니다.  세 필드의 유일한 차이점은 각각이 사용되는 방식입니다.

"받는 사람:" 필드에는 메시지의 기본 수신자의 주소가 포함됩니다.

"Cc:" 필드\(여기서 "Cc"는 카본지를 사용하여 타자기에 복사한다는 의미에서 "카본 복사"를 의미함\)에는 메시지를 받을 다른 사람의 주소가 포함되어 있습니다. 그들에게 지시하지 마십시오.

"숨은 참조:" 필드\(여기서 "숨은 참조"는 "숨은 참조"를 의미\)에는 다른 메시지 수신자에게 주소가 공개되지 않는 메시지 수신자의 주소가 포함됩니다.  '숨은참조:' 필드는 세 가지 방법으로 사용됩니다.  첫 번째 경우, "숨은 참조:" 필드가 포함된 메시지를 보낼 준비가 되면 모든 수신자\("숨은 참조:" 필드에 지정된 사람 포함\)에게 메시지가 전송되더라도 "숨은 참조:" 줄은 제거됩니다. 메시지 사본.  두 번째 경우, "받는 사람:" 및 "참조:" 줄에 지정된 수신자에게는 위와 같이 "숨은 참조:" 줄이 제거된 메시지 사본이 각각 전송되지만, "숨은 참조:" 줄에 있는 수신자는 "Bcc:" 줄이 포함된 별도의 메시지 복사본.  \("Bcc:" 필드에 여러 수신자 주소가 있는 경우 일부 구현에서는 실제로 해당 특정 수신자의 주소만 포함하는 "Bcc:"를 사용하여 각 수신자에게 별도의 메시지 복사본을 보냅니다.\) 마지막으로 "Bcc"는 :" 필드에 주소가 없을 수 있는 경우 "숨은 참조:" 필드는 주소 없이 전송되어 숨은 참조가 누군가에게 전송되었음을 수신자에게 알릴 수 있습니다.  "Bcc:" 필드에 사용할 방법은 구현에 따라 다르지만 각각에 대한 설명은 이 문서의 "보안 고려 사항" 섹션을 참조하세요.

메시지가 다른 메시지에 대한 응답인 경우 원본 메시지 작성자의 사서함\("보낸 사람:" 필드의 사서함\) 또는 "답장:" 필드\(존재하는 경우\)에 지정된 사서함이 나타날 수 있습니다. 일반적으로 회신의 기본 수신자가 되기 때문에 회신의 "받는 사람:" 필드입니다.  대상 필드가 있는 메시지에 회신을 보내는 경우 작성자 외에 메시지 수신자 모두에게 회신 사본을 보내는 것이 바람직한 경우가 많습니다.  이러한 회신이 작성되면 원본 메시지의 "받는 사람:" 및 "참조:" 필드에 있는 주소가 회신의 "참조:" 필드에 나타날 수 있습니다. 이는 일반적으로 회신의 2차 수신자이기 때문입니다.  원본 메시지에 "숨은 참조:" 필드가 있는 경우 해당 필드의 주소는 답장의 "숨은 참조:" 필드에 나타날 수 있지만 "받는 사람:" 또는 "참조:" 필드에는 나타나지 않아야 합니다.

참고: 일부 메일 응용 프로그램에는 회신 대상 주소에 원본 메시지의 대상 주소를 포함하는 자동 회신 명령이 있습니다.  해당 응답 명령의 작동 방식은 구현에 따라 다르며 이 문서의 범위를 벗어납니다. 특히 원본 메시지에 "답장:" 필드가 있을 때 원래 대상 주소를 포함할지 여부는 여기서 다루지 않습니다.

---
#### **3.6.4. Identification fields**

선택사항이지만 모든 메시지에는 "Message-ID:" 필드가 있어야 합니다. 또한 응답 메시지에는 아래 설명된 대로 "In-Reply-To:" 및 "References:" 필드가 적절하게 있어야 합니다.

"Message-ID:" 필드에는 단일 고유 메시지 식별자가 포함됩니다. "참조:" 및 "응답 대상:" 필드에는 각각 선택적으로 CFWS로 구분된 하나 이상의 고유 메시지 식별자가 포함됩니다.

메시지 식별자\(msg-id\)는 내부 CFWS가 없는 angle-addr 구성과 구문이 유사합니다.

---
# **message-id      =       "Message-ID:" msg-id CRLF**
---
# **in-reply-to     =       "In-Reply-To:" 1*msg-id CRLF**
---
# **references      =       "References:" 1*msg-id CRLF**
---
# **msg-id          =       [CFWS] "<" id-left "@" id-right ">" [CFWS]**
---
# **id-left         =       dot-atom-text / no-fold-quote / obs-id-left**
---
# **id-right        =       dot-atom-text / no-fold-literal / obs-id-right**
---
# **no-fold-quote   =       DQUOTE *(qtext / quoted-pair) DQUOTE**
---
# **no-fold-literal =       "[" *(dtext / quoted-pair) "]"**

"Message-ID:" 필드는 특정 메시지의 특정 버전을 참조하는 고유한 메시지 식별자를 제공합니다.  메시지 식별자의 고유성은 이를 생성하는 호스트에 의해 보장됩니다\(아래 참조\).  이 메시지 식별자는 기계가 읽을 수 있도록 고안되었으며 반드시 사람에게 의미가 있는 것은 아닙니다.  메시지 식별자는 특정 메시지의 정확히 하나의 인스턴스화와 관련됩니다. 메시지에 대한 후속 수정본은 각각 새 메시지 식별자를 받습니다.

참고: 메시지가 "변경"되는 경우가 많지만 이러한 변경 사항은 해당 메시지의 새로운 인스턴스화를 구성하지 않으므로 메시지는 새 메시지 식별자를 얻지 못합니다.  예를 들어 메시지가 전송 시스템에 도입되면 추적 필드\(섹션 3.6.7에서 설명\) 및 재전송 필드\(섹션 3.6.6에서 설명\)와 같은 추가 헤더 필드가 앞에 추가되는 경우가 많습니다.  이러한 헤더 필드를 추가해도 메시지의 ID는 변경되지 않으므로 원래 "Message-ID:" 필드가 유지됩니다.  모든 경우에 "Message-ID:" 필드가 변경되는지 여부를 결정하는 것은 특정 구문이 아니라 메시지 발신자가 전달하고자 하는 의미\(즉, 동일한 메시지인지 다른 메시지인지\)에 따라 결정됩니다. 메시지에 나타나는\(또는 나타나지 않는\) 차이점.

"In-Reply-To:" 및 "References:" 필드는 메시지에 대한 답장을 작성할 때 사용됩니다.  여기에는 원본 메시지의 메시지 식별자와 다른 메시지의 메시지 식별자\(예: 메시지 자체가 회신인 경우\)가 포함됩니다.  "In-Reply-To:" 필드는 새 메시지가 응답할 메시지를 식별하는 데 사용될 수 있으며, "References:" 필드는 대화의 "스레드"를 식별하는 데 사용될 수 있습니다.

메시지에 대한 회신을 만들 때 결과 메시지의 "In-Reply-To:" 및 "References:" 필드는 다음과 같이 구성됩니다.

"In-Reply-To:" 필드에는 이 메시지가 응답하는 메시지\("상위 메시지"\)의 "Message-ID:" 필드 내용이 포함됩니다.  상위 메시지가 두 개 이상인 경우 "In-Reply-To:" 필드에는 모든 상위 "Message-ID:" 필드의 내용이 포함됩니다.  상위 메시지에 "Message-ID:" 필드가 없으면 새 메시지에는 "In-Reply-To:" 필드가 없습니다.

"참조:" 필드에는 상위 항목의 "참조:" 필드\(있는 경우\) 내용과 상위 항목의 "메시지 ID:" 필드\(있는 경우\) 내용이 포함됩니다.  상위 메시지에 "참조:" 필드가 없지만 단일 메시지 식별자가 포함된 "응답:" 필드가 있는 경우 "참조:" 필드에는 상위 메시지의 "응답:" 내용이 포함됩니다. -To:" 필드 뒤에 상위의 "Message-ID:" 필드 내용\(있는 경우\)이 옵니다.  상위 항목에 "참조:", "응답 대상:" 또는 "메시지 ID:" 필드가 없으면 새 메시지에는 "참조:" 필드가 없습니다.

참고: 일부 구현에서는 "참조:" 필드를 구문 분석하여 "토론 스레드"를 표시합니다.  이러한 구현에서는 각각의 새 메시지가 단일 상위 메시지에 대한 응답이므로 "참조:" 필드를 통해 거꾸로 이동하여 거기 나열된 각 메시지의 상위를 찾을 수 있다고 가정합니다.  따라서 여러 상위 항목이 있는 응답에 대해 "참조:" 필드를 구성하려는 시도는 권장되지 않으며 이를 수행하는 방법은 이 문서에 정의되어 있지 않습니다.

메시지 식별자\(msg-id\) 자체는 메시지에 대한 전역적으로 고유한 식별자여야 합니다.  메시지 식별자 생성자는 msg-id가 고유함을 보장해야 합니다.  이를 달성하는 데 사용할 수 있는 몇 가지 알고리즘이 있습니다.  msg-id는 angle-addr과 유사한 구문을 갖기 때문에\(주석과 접는 공백이 허용되지 않는다는 점을 제외하면 동일함\) 좋은 방법은 메시지가 있는 호스트의 도메인 이름\(또는 도메인 리터럴 IP 주소\)을 입력하는 것입니다. 메시지 식별자는 "@" 오른쪽에 생성되었으며 현재 절대 날짜 및 시간과 시스템에서 사용할 수 있는 현재 고유한\(순차적\) 다른 식별자\(예: 프로세스 ID 번호\)의 조합을 입력합니다. 왼쪽에.  왼쪽에 날짜를, 오른쪽에 도메인 이름이나 도메인 리터럴을 사용하면 두 호스트가 동시에 동일한 도메인 이름이나 IP 주소를 사용하지 않으므로 고유성을 보장할 수 있습니다.  다른 알고리즘이 작동하더라도 메시지 식별자 생성기가 해당 도메인 범위 내에서 왼쪽의 고유성을 보장할 수 있도록 오른쪽에 일부 도메인 식별자\(호스트 자체 또는 기타\)를 포함하는 것이 좋습니다. .

의미상 꺾쇠 괄호 문자는 msg-id의 일부가 아닙니다. msg-id는 두 개의 꺾쇠 괄호 문자 사이에 포함된 것입니다.

---
#### **3.6.5. Informational fields**

정보 필드는 모두 선택 사항입니다.  "키워드:" 필드에는 하나 이상의 단어 또는 인용 문자열이 쉼표로 구분된 목록이 포함되어 있습니다. "제목:" 및 "설명:" 필드는 섹션 2.2.1에 정의된 대로 구조화되지 않은 필드이므로 텍스트 또는 접는 공백을 포함할 수 있습니다.

---
# **subject         =       "Subject:" unstructured CRLF**
---
# **comments        =       "Comments:" unstructured CRLF**
---
# **keywords        =       "Keywords:" phrase *("," phrase) CRLF**

이 세 가지 필드는 메시지에 대한 정보와 함께 사람이 읽을 수 있는 콘텐츠만 포함하도록 되어 있습니다.  "제목:" 필드는 가장 일반적이며 메시지 주제를 식별하는 짧은 문자열을 포함합니다.  응답에 사용될 때 필드 본문은 문자열 "Re: "\(라틴어 "res"에서 유래\)로 시작하고 그 뒤에 원본 메시지의 "Subject:" 필드 본문 내용이 올 수 있습니다. 이 작업이 수행되면 리터럴 문자열 "Re:"의 인스턴스 하나만 사용해야 합니다. 다른 문자열을 사용하거나 둘 이상의 인스턴스를 사용하면 바람직하지 않은 결과가 발생할 수 있기 때문입니다.  "설명:" 필드에는 메시지 본문 텍스트에 대한 추가 설명이 포함됩니다.  "키워드:" 필드에는 수신자에게 유용할 수 있는 중요한 단어와 문구가 쉼표로 구분된 목록이 포함되어 있습니다.

---
#### **3.6.6. Resent fields**

재전송 필드는 사용자가 전송 시스템에 다시 도입한 모든 메시지에 추가되어야 합니다.  이 작업이 수행될 때마다 별도의 재전송 필드 세트를 추가해야 합니다.  메시지의 특정 재전송에 해당하는 모든 재전송 필드는 함께 있어야 합니다.  각각의 새로운 재전송 필드 세트가 메시지 앞에 추가됩니다. 즉, 가장 최근의 재전송 필드 집합이 메시지 앞부분에 나타납니다.  재전송 필드를 추가해도 메시지의 다른 필드는 변경되지 않습니다.

각 재전송 필드는 구문의 다른 위치에 있는 특정 필드에 해당합니다.  예를 들어, "Resent-Date:" 필드는 "Date:" 필드에 해당하고 "Resent-To:" 필드는 "To:" 필드에 해당합니다.  각 경우에 필드 본문의 구문은 해당 필드에 대해 이전에 제공된 구문과 동일합니다.

재전송 필드를 사용하는 경우 "Resent-From:" 및 "Resent-Date:" 필드를 전송해야 합니다.  "Resent-Message-ID:" 필드가 전송되어야 합니다. "Resent-Sender:"는 "Resent-Sender:"가 "Resent-From:"과 동일한 경우 사용하면 안 됩니다.

---
# **resent-date     =       "Resent-Date:" date-time CRLF**
---
# **resent-from     =       "Resent-From:" mailbox-list CRLF**
---
# **resent-sender   =       "Resent-Sender:" mailbox CRLF**
---
# **resent-to       =       "Resent-To:" address-list CRLF**
---
# **resent-cc       =       "Resent-Cc:" address-list CRLF**
---
# **resent-bcc      =       "Resent-Bcc:" (address-list / [CFWS]) CRLF**
---
# **resent-msg-id   =       "Resent-Message-ID:" msg-id CRLF**

재전송 필드는 사용자가 전송 시스템에 다시 도입한 메시지를 식별하는 데 사용됩니다.  재전송 필드를 사용하는 목적은 원래 보낸 사람이 직접 보낸 것처럼 메시지가 최종 수신자에게 나타나도록 하고 원래 필드는 모두 동일하게 유지하는 것입니다.  각 재전송 필드 세트는 특정 재전송 이벤트에 해당합니다.  즉, 메시지가 여러 번 재전송되는 경우 각 재전송 필드 집합은 각 개별 시간에 대한 식별 정보를 제공합니다.  재전송 필드는 정보 제공용입니다.  응답의 일반적인 처리 또는 메시지에 대한 기타 자동 작업에 사용해서는 안 됩니다.

참고: 전송 시스템에 메시지를 다시 도입하고 재전송 필드를 사용하는 것은 "전달"과 다른 작업입니다. "전달"에는 두 가지 의미가 있습니다. 전달의 한 가지 의미는 사용자가 메일 읽기 프로그램에 메시지 복사본을 다른 사람에게 전달하여 전달된 메시지를 새 메시지의 본문으로 만들도록 지시할 수 있다는 것입니다.  이런 의미에서 전달된 메시지는 원래 보낸 사람이 보낸 것처럼 보이지 않지만 메시지 전달자가 보낸 완전히 새로운 메시지입니다.  반면에 전달은 메일 전송 프로그램이 메시지를 받아 최종 배달을 위해 다른 대상으로 전달하는 경우를 의미하는 데에도 사용됩니다.  Resent 헤더 필드는 두 유형의 전달에 사용하기 위한 것이 아닙니다.

재전송 보낸 사람 필드는 메시지를 재전송한 사람 또는 시스템의 사서함을 나타냅니다.  일반 발신자 필드와 마찬가지로 재전송을 수행하는 개인의 사서함을 포함하는 간단한 "Resent-From:" 양식과 한 개인\("Resent-Sender: " 필드\)는 한 명 이상의 다른 사람\("Resent-From:" 필드에서 식별됨\)을 대신하여 메시지를 다시 보냅니다.

참고: 재전송된 메시지에 답장할 때 답장은 원래 "보낸 사람:"을 사용하여 다른 메시지와 마찬가지로 작동합니다.

"답장:", "메시지 ID:" 및 기타 필드.  재전송 필드는 정보 제공용일 뿐이며 정상적인 응답 처리에 사용되어서는 안 됩니다.

"Resent-Date:"는 메시지 재발신자가 재전송된 메시지를 발송한 날짜와 시간을 나타냅니다.  "날짜:" 필드와 마찬가지로 메시지가 실제로 전송된 날짜와 시간이 아닙니다.

"Resent-To:", "Resent-Cc:" 및 "Resent-Bcc:" 필드는 각각 "To:", "Cc:" 및 "Bcc:" 필드와 동일하게 작동합니다. 원본 메시지의 수신자가 아닌 재전송된 메시지의 수신자입니다.

"Resent-Message-ID:" 필드는 재전송된 메시지에 대한 고유 식별자를 제공합니다.

---
#### **3.6.7. Trace fields**

추적 필드는 선택적 "Return-Path:" 필드와 하나 이상의 "Received:" 필드로 구성된 헤더 필드 그룹입니다. "Return-Path:" 헤더 필드에는 선택적 addr-spec을 묶는 한 쌍의 꺾쇠 괄호가 포함되어 있습니다.  "Received:" 필드에는 이름/값 쌍 목록\(비어 있을 수 있음\)과 세미콜론 및 날짜-시간 사양이 포함되어 있습니다.  이름/값 쌍의 첫 번째 항목은 item-name으로 정의되고 두 번째 항목은 addr-spec,atom,domain 또는 msg-id입니다.  \[RFC2821\]과 같이 사용을 위해 제공되는 표준에 따라 추적 필드의 구문에 추가 제한이 적용될 수 있습니다.

```text
trace           =       [return]
                        1*received
```

---
# **return          =       "Return-Path:" path CRLF**

```text
path            =       ([CFWS] "<" ([CFWS] / addr-spec) ">" [CFWS]) /
                        obs-path
```

---
# **received        =       "Received:" name-val-list ";" date-time CRLF**
---
# **name-val-list   =       [CFWS] [name-val-pair *(CFWS name-val-pair)]**
---
# **name-val-pair   =       item-name CFWS item-value**
---
# **item-name       =       ALPHA *(["-"] (ALPHA / DIGIT))**

```text
item-value      =       1*angle-addr / addr-spec /
                         atom / domain / msg-id
```

추적 필드의 인터넷 메일 사용에 대한 전체 논의는 \[RFC2821\]에 포함되어 있습니다.  이 표준의 목적에 따라 추적 필드는 엄격하게 정보 제공용이며 공식적인 해석은 이 문서의 범위를 벗어납니다.

---
#### **3.6.8. Optional fields**

필드는 이 표준에서 지정되지 않은 메시지에 나타날 수 있습니다.  이는 선택 필드의 구문을 준수해야 합니다. 이는 SP와 콜론을 제외한 인쇄 가능한 US-ASCII 문자, 콜론, 구조화되지 않은 텍스트를 따르는 필드 이름입니다.

선택 필드의 필드 이름은 이 표준의 다른 곳에 지정된 필드 이름과 동일해서는 안 됩니다.

---
# **optional-field  =       field-name ":" unstructured CRLF**
---
# **field-name      =       1*ftext**

```text
ftext           =       %d33-57 /               ; Any character except
                        %d59-126                ;  controls, SP, and
                                                ;  ":".
```

이 표준의 목적에 따라 모든 선택 필드는 해석되지 않습니다.

---
## **4. Obsolete Syntax**

이 표준의 이전 버전에서는 이 버전에서 허용되는 것과 다른\(일반적으로 더 자유로운\) 구문을 허용했습니다.  또한 해석이 문서화되지 않은 인터넷 메시지에 사용된 구문 요소도 있습니다.  이러한 구문 형식 중 일부는 섹션 3의 문법에 따라 생성되어서는 안 되지만\(MUST NOT\), 이를 준수하는 수신자에 의해 허용되고 구문 분석되어야 합니다\(MUST\). 이 섹션에서는 이러한 구문 요소 중 다수를 설명합니다.  섹션 3의 문법을 취하고 이 섹션에 제시된 정의를 추가하면 메시지 해석에 사용할 문법이 생성됩니다.

참고: 이 섹션에서는 모든 구현이 합리적으로 해석해야 하는 구문 형식을 식별합니다.  그러나 이 섹션에 제공된 추가 구문조차 준수하지 않는 인터넷 메시지가 확실히 있습니다.  이 문서의 어떤 섹션에도 특정 형식이 나타나지 않는다는 사실이 컴퓨터 프로그램이 충돌하거나 잘못된 형식의 데이터가 구현에 의해 복구 불가능하게 손실되는 것을 정당화하는 것은 아닙니다.  예를 반복하자면, 이 문서에서는 메시지 줄이 998자를 넘지 않아야 하지만 자동으로

경고 없이 한 줄에서 999번째 이후의 문자를 삭제하는 것은 여전히 ​​구현에 있어 잘못된 동작입니다.  메시지를 강력하게 처리하는 것은 구현에 달려 있습니다.

더 이상 사용되지 않는\(해석하는\) 구문과 현재\(생성하는\) 구문 사이의 한 가지 중요한 차이점은 구조화된 헤더 필드 본문\(즉, 구조화된 헤더 필드의 콜론과 CRLF 사이\)에서 접는 공백을 포함한 공백 문자 및 주석입니다. 구문 토큰 사이에 자유롭게 삽입할 수 있습니다.  이는 일부 구현에서 구문 분석하기 어려운 것으로 입증된 많은 복잡한 형식을 허용합니다.

더 이상 사용되지 않는 구문과 현재 구문의 또 다른 주요 차이점은 주석에서 완전히 공백으로 구성된 줄과 접는 공백으로 구성된 섹션 3.2.3의 규칙이 적용되지 않는다는 것입니다.  아래 섹션 4.2의 공백 접기에 대한 설명을 참조하세요.

마지막으로 이전에 메시지에 허용되었던 특정 문자가 이 섹션에 나타납니다.  NUL 문자\(ASCII 값 0\)는 한때 허용되었지만 호환성상의 이유로 더 이상 허용되지 않습니다.  CR 및 LF는 CRLF 이외의 메시지에 표시되는 것이 허용되었습니다. 이 용도는 여기에도 표시되어 있습니다.

구문 및 의미 체계의 다른 차이점은 다음 섹션에 설명되어 있습니다.

---
### **4.1. Miscellaneous obsolete tokens**

이러한 구문 요소는 사용되지 않는 구문이나 기본 구문의 다른 곳에서 사용됩니다.  obs-char 및 obs-qp 요소는 각각 ASCII 값 0을 추가합니다. Bare CR 및 Bare LF는 obs-text 및 obs-utext에 추가됩니다. 마침표 문자가 obs-phrase에 추가됩니다. obs-phrase-list는 쉼표로 구분된 문구 목록에 "빈" 요소를 제공합니다.

참고: obs-phrase의 "마침표"\(또는 "마침표"\) 문자\("."\)는 이 표준이나 다른 표준의 이전 버전에서 허용된 형식이 아닙니다.  마침표\(특수 문자의 다른 문자도 포함\)는 구문과 addr-spec의 부분을 구별하는 구문 분석이 어렵기 때문에 구문에서 허용되지 않습니다\(섹션 4.4 참조\).  마침표 문자는 현재 주소의 표시 이름 부분에 있는 많은 메시지, 특히 이름의 이니셜에 사용되므로 올바르게 해석되어야 하기 때문에 여기에 나타납니다.  앞으로는 일반 구문 구문에 마침표가 나타날 수 있습니다.

---
# **obs-qp          =       "\" (%d0-127)**
---
# **obs-text        =       *LF *CR *(obs-char *LF *CR)**

```text
obs-char        =       %d0-9 / %d11 /          ; %d0-127 except CR and
                        %d12 / %d14-127         ;  LF
```

---
# **obs-utext       =       obs-text**
---
# **obs-phrase      =       word *(word / "." / CFWS)**
---
# **obs-phrase-list =       phrase / 1*([phrase] [CFWS] "," [CFWS]) [phrase]**

Bare CR과 Bare LF는 두 가지 다른 의미로 메시지에 나타납니다. 많은 경우 줄 구분 기호를 표시하기 위해 CRLF 대신 베어 CR 또는 베어 LF가 부적절하게 사용됩니다.  다른 경우에는 베어 CR 및 베어 LF가 전통적인 ASCII 의미를 갖는 ASCII 제어 문자로 단순히 사용됩니다.

---
### **4.2. Obsolete folding white space**

더 이상 사용되지 않는 구문에서는 obs-FWS 규칙이 허용되는 곳에 접는 공백을 원하는 만큼 삽입할 수 있습니다.  이는 한 줄에 두 개의 연속적인 "접기"가 있을 가능성을 생성하므로 접힌 헤더 필드를 구성하는 줄이 완전히 공백으로 구성될 가능성이 있습니다.

```text
   obs-FWS         =       1*WSP *(CRLF 1*WSP)
```

---
### **4.3. Obsolete Date and Time**

더 이상 사용되지 않는 날짜 형식의 구문은 날짜 필드에 2자리 연도를 허용하고 이 표준의 이전 버전에서 사용된 알파벳 시간대 사양 목록을 허용합니다. 또한 많은 토큰 사이에 주석과 접는 공백을 허용합니다.

---
# **obs-day-of-week =       [CFWS] day-name [CFWS]**
---
# **obs-year        =       [CFWS] 2*DIGIT [CFWS]**
---
# **obs-month       =       CFWS month-name CFWS**
---
# **obs-day         =       [CFWS] 1*2DIGIT [CFWS]**
---
# **obs-hour        =       [CFWS] 2DIGIT [CFWS]**
---
# **obs-minute      =       [CFWS] 2DIGIT [CFWS]**
---
# **obs-second      =       [CFWS] 2DIGIT [CFWS]**
---
# **obs-zone        =       "UT" / "GMT" /          ; Universal Time**

```text
                                                ; North American UT
                                                ; offsets
                        "EST" / "EDT" /         ; Eastern:  - 5/ - 4
                        "CST" / "CDT" /         ; Central:  - 6/ - 5
                        "MST" / "MDT" /         ; Mountain: - 7/ - 6
                        "PST" / "PDT" /         ; Pacific:  - 8/ - 7

                        %d65-73 /               ; Military zones - "A"
                        %d75-90 /               ; through "I" and "K"
                        %d97-105 /              ; through "Z", both
                        %d107-122               ; upper and lower case
```

날짜에 두 자리 또는 세 자리 연도가 있는 경우 연도는 다음과 같이 해석됩니다. 값이 00에서 49 사이인 두 자리 연도가 나타나면 해당 연도는 2000을 더하여 해석되어 다음 사이의 값으로 끝납니다. 2000 및 2049. 값이 50에서 99 사이인 두 자리 연도가 발견되거나 세 자리 연도가 발견되면 해당 연도는 1900을 더하여 해석됩니다.

더 이상 사용되지 않는 시간대에서 "UT"와 "GMT"는 각각 "세계시"와 "그리니치 표준시"를 나타내며 의미상 둘 다 "+0000"과 동일합니다.

나머지 세 개의 문자 영역은 미국 시간대입니다.  첫 글자 "E", "C", "M", "P"는 "Eastern", "Central", "Mountain" 및 "Pacific"을 의미합니다.  두 번째 문자는 "표준" 시간을 나타내는 "S"이거나 "일광"\(또는 여름\) 시간을 나타내는 "D"입니다.  그들의 해석은 다음과 같습니다.

EDT는 -0400과 의미상 동일 EST는 -0500과 의미상 동일 CDT는 -0500과 의미상 동일 CST는 -0600과 의미상 동일 MDT는 -0600과 의미상 동일 MST는 -0700과 의미상 동일 PDT는 의미상 -0700 PST와 동일 의미상 -0800과 동일합니다.

1문자 군사 시간대는 \[RFC822\]에서 비표준 방식으로 정의되었으므로 그 의미를 예측할 수 없습니다. 군사 구역 "A"부터 "I"까지의 원래 정의는 각각 "+0100"부터 "+0900"까지와 동일합니다. "K", "L" 및 "M"은 각각 "+1000", "+1100" 및 "+1200"과 동일합니다. "N"부터 "Y"까지는 각각 "-0100"부터 "-1200"까지와 동일합니다. "Z"는 "+0000"과 같습니다.  그러나 \[RFC822\]의 오류로 인해 해당 의미를 확인하는 대역 외 정보가 없는 한 모두 "-0000"과 동일한 것으로 간주되어야 합니다.

기타 다중 문자\(보통 3\~5자\) 알파벳 시간대가 인터넷 메시지에 사용되었습니다.  의미가 알려지지 않은 시간대는 의미를 확인하는 대역 외 정보가 없는 한 "-0000"과 동일한 것으로 간주되어야 합니다.

---
### **4.4. Obsolete Addressing**

주소 지정에는 세 가지 주요 차이점이 있습니다.  첫째, 사서함 주소는 "<" 및 "\>"로 묶인 경우 addr-spec 앞에 경로 부분을 가질 수 있습니다.  경로는 단순히 "@"이 앞에 오는 쉼표로 구분된 도메인 이름 목록이며 목록은 콜론으로 끝납니다.  둘째, 로컬 부분과 도메인의 마침표로 구분된 요소 사이에 CFWS를 허용했습니다\(즉, 도트 원자를 사용하지 않았습니다\).  또한 로컬 부분에는 원자 외에 quoted-string도 포함될 수 있습니다.  마지막으로 메일박스 목록과 주소 목록에는 "null" 멤버가 허용되었습니다.  즉, 이러한 목록에는 사이에 아무것도 없는 두 개 이상의 쉼표가 있을 수 있습니다.

---
# **obs-angle-addr  =       [CFWS] "<" [obs-route] addr-spec ">" [CFWS]**
---
# **obs-route       =       [CFWS] obs-domain-list ":" [CFWS]**
---
# **obs-domain-list =       "@" domain *(*(CFWS / "," ) [CFWS] "@" domain)**
---
# **obs-local-part  =       word *("." word)**
---
# **obs-domain      =       atom *("." atom)**
---
# **obs-mbox-list   =       1*([mailbox] [CFWS] "," [CFWS]) [mailbox]**
---
# **obs-addr-list   =       1*([address] [CFWS] "," [CFWS]) [address]**

주소를 해석할 때 경로 부분은 무시되어야 합니다.

---
### **4.5. Obsolete header fields**

구문상으로 사용되지 않는 필드 구문의 주요 차이점은 모든 필드의 다중 발생을 허용하고 임의의 순서로 발생할 수 있다는 것입니다.  또한 필드 이름 끝의 ":" 앞에는 공백이 얼마든지 허용됩니다.

```text
obs-fields      =       *(obs-return /
                        obs-received /
                        obs-orig-date /
                        obs-from /
                        obs-sender /
                        obs-reply-to /
                        obs-to /

                        obs-cc /
                        obs-bcc /
                        obs-message-id /
                        obs-in-reply-to /
                        obs-references /
                        obs-subject /
                        obs-comments /
                        obs-keywords /
                        obs-resent-date /
                        obs-resent-from /
                        obs-resent-send /
                        obs-resent-rply /
                        obs-resent-to /
                        obs-resent-cc /
                        obs-resent-bcc /
                        obs-resent-mid /
                        obs-optional)
```

대상 주소 필드\(섹션 4.5.3에 설명됨\)를 제외하고 여러 번 나타나는 필드의 해석은 지정되지 않습니다. 또한 메시지 앞에 추가된 블록에 발생하지 않는 추적 필드 및 재전송 필드의 해석도 지정되지 않습니다. 다음 섹션에서 달리 명시하지 않는 한, 다른 필드의 해석은 섹션 3의 더 이상 사용되지 않는 해당 필드의 해석과 동일합니다.

---
#### **4.5.1. Obsolete origination date field**
---
# **obs-orig-date   =       "Date" *WSP ":" date-time CRLF**
---
#### **4.5.2. Obsolete originator fields**
---
# **obs-from        =       "From" *WSP ":" mailbox-list CRLF**
---
# **obs-sender      =       "Sender" *WSP ":" mailbox CRLF**
---
# **obs-reply-to    =       "Reply-To" *WSP ":" mailbox-list CRLF**
---
#### **4.5.3. Obsolete destination address fields**
---
# **obs-to          =       "To" *WSP ":" address-list CRLF**
---
# **obs-cc          =       "Cc" *WSP ":" address-list CRLF**
---
# **obs-bcc         =       "Bcc" *WSP ":" (address-list / [CFWS]) CRLF**

메시지에서 대상 주소 필드가 여러 번 발생하는 경우 필드의 첫 번째 발생에 있는 주소 목록이 쉼표를 추가하고 연결하여 후속 발생의 주소 목록과 결합되는 것처럼 처리되어야 합니다.

---
#### **4.5.4. Obsolete identification fields**

더 이상 사용되지 않는 "In-Reply-To:" 및 "References:" 필드는 구문\(단어 또는 인용 문자열\)이 표시된다는 점에서 현재 구문과 다릅니다.  msg-id의 왼쪽과 오른쪽에 있는 더 이상 사용되지 않는 형식은 CFWS를 분산시켜 구문상 각각 로컬 부분 및 도메인과 동일하게 만듭니다.

---
# **obs-message-id  =       "Message-ID" *WSP ":" msg-id CRLF**
---
# **obs-in-reply-to =       "In-Reply-To" *WSP ":" *(phrase / msg-id) CRLF**
---
# **obs-references  =       "References" *WSP ":" *(phrase / msg-id) CRLF**
---
# **obs-id-left     =       local-part**
---
# **obs-id-right    =       domain**

해석을 위해 "In-Reply-To:" 및 "References:" 필드의 문구는 무시됩니다.

의미상 로컬 부분과 도메인을 둘러싼 선택적 CFWS는 각각 obs-id-left 및 obs-id-right의 일부가 아닙니다.

---
#### **4.5.5. Obsolete informational fields**
---
# **obs-subject     =       "Subject" *WSP ":" unstructured CRLF**
---
# **obs-comments    =       "Comments" *WSP ":" unstructured CRLF**
---
# **obs-keywords    =       "Keywords" *WSP ":" obs-phrase-list CRLF**
---
#### **4.5.6. Obsolete resent fields**

더 이상 사용되지 않는 구문은 필드 이름, 선택적 설명 및 접는 공백, 콜론 및 쉼표로 구분된 주소 목록으로 구성된 "Resent-Reply-To:" 필드를 추가합니다.

---
# **obs-resent-from =       "Resent-From" *WSP ":" mailbox-list CRLF**
---
# **obs-resent-send =       "Resent-Sender" *WSP ":" mailbox CRLF**
---
# **obs-resent-date =       "Resent-Date" *WSP ":" date-time CRLF**
---
# **obs-resent-to   =       "Resent-To" *WSP ":" address-list CRLF**
---
# **obs-resent-cc   =       "Resent-Cc" *WSP ":" address-list CRLF**

```text
obs-resent-bcc  =       "Resent-Bcc" *WSP ":"
                         (address-list / [CFWS]) CRLF
```

---
# **obs-resent-mid  =       "Resent-Message-ID" *WSP ":" msg-id CRLF**
---
# **obs-resent-rply =       "Resent-Reply-To" *WSP ":" address-list CRLF**

다른 재전송 필드와 마찬가지로 "Resent-Reply-To:" 필드는 추적 정보로만 처리됩니다.

---
#### **4.5.7. Obsolete trace fields**

obs-return 및 obs-received는 섹션 3의 return 및 received와 마찬가지로 여기에 템플릿 정의로 다시 제공됩니다. 전체 구문은 \[RFC2821\]에 제공됩니다.

---
# **obs-return      =       "Return-Path" *WSP ":" path CRLF**
---
# **obs-received    =       "Received" *WSP ":" name-val-list CRLF**
---
# **obs-path        =       obs-angle-addr**
---
#### **4.5.8. Obsolete optional fields**
---
# **obs-optional    =       field-name *WSP ":" unstructured CRLF**
---
## **5. Security Considerations**

터미널이나 터미널 에뮬레이터에 메시지를 표시할 때는 주의가 필요합니다.  강력한 터미널은 이스케이프 시퀀스 및 기타 ASCII 제어 문자 조합에 따라 다양한 결과를 초래할 수 있습니다.  키보드를 다시 매핑하거나 터미널에 대한 다른 수정을 허용하여 서비스 거부 또는 데이터 손상을 초래할 수 있습니다.  메시지가 수신자를 대신하여 명령을 실행하도록 허용할 수 있는 응답 메시지를 트리거할 수 있습니다\(때로는 프로그래밍 가능\).  또한 프린터와 같은 터미널 연결 장치의 작동에도 영향을 미칠 수 있습니다.  메시지 뷰어는 표시하기 전에 메시지에서 잠재적으로 위험한 터미널 이스케이프 시퀀스를 제거할 수 있습니다.  그러나 다른 이스케이프 시퀀스는 유용한 목적으로 메시지에 나타나므로\(\[RFC2045, RFC2046, RFC2047, RFC2048, RFC2049, ISO2022\] 참조\) 무차별적으로 제거해서는 안 됩니다.

메시지에 텍스트가 아닌 개체를 전송하면 추가적인 보안 문제가 발생합니다.  이러한 문제는 \[RFC2045, RFC2046, RFC2047, RFC2048, RFC2049\]에서 논의됩니다.

많은 구현에서는 섹션 3.6.3에 설명된 "숨은 참조:"\(숨은 참조\) 필드를 사용하여 한 명 이상의 수신자의 주소를 다른 수신자에게 공개하지 않고 수신자에게 메시지를 쉽게 보낼 수 있도록 합니다.  "Bcc:"를 잘못 사용하면 기밀 정보가 공개될 수 있으며, 특정 메일 주소의 존재 여부를 알더라도 결국 보안 문제가 발생할 수 있습니다.  예를 들어, "Bcc:" 줄이 메시지에서 제거되는 섹션 3.6.3에 설명된 첫 번째 방법을 사용하는 경우, 블라인드 수신자는 자신의 주소가 그렇지 않은 경우를 제외하고는 블라인드 사본이 전송되었다는 명시적인 표시를 갖지 않습니다. 메시지 헤더에 나타납니다.  이로 인해 비공개 수신자 중 한 명이 잠재적으로 표시된 모든 수신자에게 답장을 보낼 수 있으며 실수로 해당 메시지가 비공개 수신자에게 전달되었음을 드러낼 수 있습니다.  섹션 3.6.3의 두 번째 방법을 사용하면 비공개 수신자의 주소가 별도의 메시지 복사본의 "숨은 참조:" 필드에 나타납니다. 전송된 "숨은 참조:" 필드에 숨은 참조 주소가 모두 포함되어 있는 경우 모든 "숨은 참조:" 수신자는 각 "숨은 참조:" 수신자에게 표시됩니다.  개인의 주소만 있는 각 "Bcc:" 수신자에게 별도의 메시지가 전송되더라도 구현 시 섹션 3.6.3에 따라 메시지에 대한 응답을 처리하여 실수로 블라인드 수신자를 다른 수신자에게 공개하지 않도록 주의해야 합니다. .

---
## **6. Bibliography**

```text
   [ASCII]    American National Standards Institute (ANSI), Coded
              Character Set - 7-Bit American National Standard Code for
              Information Interchange, ANSI X3.4, 1986.

   [ISO2022] International Organization for Standardization (ISO),
              Information processing - ISO 7-bit and 8-bit coded
              character sets - Code extension techniques, Third edition
              - 1986-05-01, ISO 2022, 1986.

   [RFC822]   Crocker, D., "Standard for the Format of ARPA Internet
              Text Messages", RFC 822, August 1982.

   [RFC2045]  Freed, N. and  N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, November 1996.

   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", RFC 2046,
              November 1996.

   [RFC2047]  Moore, K., "Multipurpose Internet Mail Extensions (MIME)
              Part Three: Message Header Extensions for Non-ASCII Text",
              RFC 2047, November 1996.

   [RFC2048]  Freed, N., Klensin, J. and J. Postel, "Multipurpose
              Internet Mail Extensions (MIME) Part Four: Format of
              Internet Message Bodies", RFC 2048, November 1996.

   [RFC2049]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Five: Conformance Criteria and
              Examples", RFC 2049, November 1996.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2234]  Crocker, D., Editor, and P. Overell, "Augmented BNF for
              Syntax Specifications: ABNF", RFC 2234, November 1997.

   [RFC2821]  Klensin, J., Editor, "Simple Mail Transfer Protocol", RFC
              2821, March 2001.

   [STD3]     Braden, R., "Host Requirements", STD 3, RFC 1122 and RFC
              1123, October 1989.

   [STD12]    Mills, D., "Network Time Protocol", STD 12, RFC 1119,
              September 1989.

   [STD13]    Mockapetris, P., "Domain Name System", STD 13, RFC 1034
              and RFC 1035,  November 1987.

   [STD14]    Partridge, C., "Mail Routing and the Domain System", STD
              14, RFC 974, January 1986.
```

---
## **7. Editor's Address**

```text
   Peter W. Resnick
   QUALCOMM Incorporated
   5775 Morehouse Drive
   San Diego, CA 92121-1714
   USA

   Phone: +1 858 651 4478
   Fax:   +1 858 651 1102
   EMail: presnick@qualcomm.com
```

---
## **8. Acknowledgements**

많은 사람들이 이 문서에 기여했습니다.  여기에는 IETF\(Internet Engineering Task Force\)의 DRUMS\(메시징 표준 세부 개정 및 업데이트\) 작업 그룹에 참여한 사람들, DRUMS 의장, IETF의 지역 책임자 및 단순히 의견을 통해 의견을 보낸 사람들이 포함되었습니다. 이메일.  편집자는 그들 모두에게 깊은 빚을 지고 진심으로 감사드립니다.  아래 목록에는 이 문서와 관련하여 전자 메일을 보낸 모든 사람이 포함되어 있습니다. 기여한 모든 사람의 이름이 여기에 기재되기를 바랍니다.

```text
   Matti Aarnio              Barry Finkel           Larry Masinter
   Tanaka Akira              Erik Forsberg          Denis McKeon
   Russ Allbery              Chuck Foster           William P McQuillan
   Eric Allman               Paul Fox               Alexey Melnikov
   Harald Tveit Alvestrand   Klaus M. Frank         Perry E. Metzger
   Ran Atkinson              Ned Freed              Steven Miller
   Jos Backus                Jochen Friedrich       Keith Moore
   Bruce Balden              Randall C. Gellens     John Gardiner Myers
   Dave Barr                 Sukvinder Singh Gill   Chris Newman
   Alan Barrett              Tim Goodwin            John W. Noerenberg
   John Beck                 Philip Guenther        Eric Norman
   J. Robert von Behren      Tony Hansen            Mike O'Dell
   Jos den Bekker            John Hawkinson         Larry Osterman
   D. J. Bernstein           Philip Hazel           Paul Overell
   James Berriman            Kai Henningsen         Jacob Palme
   Norbert Bollow            Robert Herriot         Michael A. Patton
   Raj Bose                  Paul Hethmon           Uzi Paz
   Antony Bowesman           Jim Hill               Michael A. Quinlan
   Scott Bradner             Paul E. Hoffman        Eric S. Raymond
   Randy Bush                Steve Hole             Sam Roberts
   Tom Byrer                 Kari Hurtta            Hugh Sasse
   Bruce Campbell            Marco S. Hyman         Bart Schaefer
   Larry Campbell            Ofer Inbar             Tom Scola
   W. J. Carpenter           Olle Jarnefors         Wolfgang Segmuller
   Michael Chapman           Kevin Johnson          Nick Shelness
   Richard Clayton           Sudish Joseph          John Stanley
   Maurizio Codogno          Maynard Kang           Einar Stefferud
   Jim Conklin               Prabhat Keni           Jeff Stephenson
   R. Kelley Cook            John C. Klensin        Bernard Stern
   Steve Coya                Graham Klyne           Peter Sylvester
   Mark Crispin              Brad Knowles           Mark Symons
   Dave Crocker              Shuhei Kobayashi       Eric Thomas
   Matt Curtin               Peter Koch             Lee Thompson
   Michael D'Errico          Dan Kohn               Karel De Vriendt
   Cyrus Daboo               Christian Kuhtz        Matthew Wall
   Jutta Degener             Anand Kumria           Rolf Weber
   Mark Delany               Steen Larsen           Brent B. Welch

   Steve Dorner              Eliot Lear             Dan Wing
   Harold A. Driscoll        Barry Leiba            Jack De Winter
   Michael Elkins            Jay Levitt             Gregory J. Woodhouse
   Robert Elz                Lars-Johan Liman       Greg A. Woods
   Johnny Eriksson           Charles Lindsey        Kazu Yamamoto
   Erik E. Fair              Pete Loshin            Alain Zahm
   Roger Fajman              Simon Lyall            Jamie Zawinski
   Patrik Faltstrom          Bill Manning           Timothy S. Zurcher
   Claus Andre Farber        John Martin
```

---
# **Appendix A. Example messages**

이 섹션에서는 다양한 메시지를 보여줍니다.  이는 이 표준의 구현을 돕기 위한 것이지만 규범적인 것으로 간주되어서는 안 됩니다. 즉, 이 섹션의 예제를 주의 깊게 검토했지만 이러한 예제와 이 문서의 섹션 3 및 4에 설명된 구문 사이에 충돌이 발생하는 경우 해당 섹션의 구문이 올바른 것으로 간주됩니다.

```text
   Messages are delimited in this section between lines of "----".  The
   "----" lines are not part of the message itself.
```

---
### **A.1. Addressing examples**

다음은 두 개인 간에 전송될 수 있는 메시지의 예입니다.

---
#### **A.1.1. A message from one person to another with simple addressing**

이는 정식 메시지라고 할 수 있습니다.  여기에는 단일 작성자인 John Doe, 단일 수신자, Mary Smith, 제목, 날짜, 메시지 식별자 및 본문의 텍스트 메시지가 있습니다.

```text
----
From: John Doe <jdoe@machine.example>
To: Mary Smith <mary@example.net>
Subject: Saying Hello
Date: Fri, 21 Nov 1997 09:55:06 -0600
Message-ID: <1234@local.machine.example>

This is a message just to say hello.
So, "Hello".
----
```

John의 비서인 Michael이 실제로 메시지를 보낸 경우 John이 작성자이고 이 메시지에 대한 응답이 그에게 다시 전달되어야 하지만 보낸 사람 필드가 사용됩니다.

```text
----
From: John Doe <jdoe@machine.example>
Sender: Michael Jones <mjones@machine.example>
To: Mary Smith <mary@example.net>
Subject: Saying Hello
Date: Fri, 21 Nov 1997 09:55:06 -0600
Message-ID: <1234@local.machine.example>

This is a message just to say hello.
So, "Hello".
----
```

---
#### **A.1.2. Different types of mailboxes**

이 메시지에는 대상 필드에 여러 주소가 포함되어 있으며 여러 가지 다른 형태의 주소도 사용합니다.

```text
----
From: "Joe Q. Public" <john.q.public@example.com>
To: Mary Smith <mary@x.test>, jdoe@example.org, Who? <one@y.test>
Cc: <boss@nil.test>, "Giant; \"Big\" Box" <sysservices@example.net>
Date: Tue, 1 Jul 2003 10:52:37 +0200
Message-ID: <5678.21-Nov-1997@example.com>

Hi everyone.
----
```

Joe Q. Public 및 Giant의 표시 이름은 다음과 같습니다. "큰" 상자는 큰따옴표로 묶어야 합니다. 전자에는 마침표가 포함되어 있고 후자에는 세미콜론과 큰따옴표 문자\(큰따옴표 문자는 인용 쌍 구조로 표시됨\)가 모두 포함되어 있기 때문입니다.  반대로 Who?의 표시 이름은 다음과 같습니다. 물음표는 원자에서 유효하기 때문에 그것들 없이도 나타날 수 있습니다.  또한 jdoe@example.org 및 boss@nil.test에는 연결된 표시 이름이 전혀 없으며 jdoe@example.org는 꺾쇠 괄호 없이 더 간단한 주소 형식을 사용합니다.

---
#### **A.1.3. Group addresses**

```text
----
From: Pete <pete@silly.example>
To: A Group:Chris Jones <c@a.test>,joe@where.test,John <jdoe@one.test>;
Cc: Undisclosed recipients:;
Date: Thu, 13 Feb 1969 23:32:54 -0330
Message-ID: <testabcd.1234@silly.example>

Testing.
----
```

이 메시지의 "받는 사람:" 필드에는 3개의 주소가 포함된 A Group이라는 단일 그룹 수신자가 있고 "참조:" 필드에는 Undisclosed receives라는 빈 그룹 수신자가 있습니다.

---
### **A.2. Reply messages**

다음은 John과 Mary 간의 대화 스레드를 구성하는 일련의 세 가지 메시지입니다.  John은 먼저 Mary에게 메시지를 보내고, Mary는 John의 메시지에 응답하고, John은 Mary의 응답 메시지에 응답합니다.

특히 각 메시지의 "Message-ID:", "References:" 및 "In-Reply-To:" 필드에 유의하세요.

```text
----
From: John Doe <jdoe@machine.example>
To: Mary Smith <mary@example.net>
Subject: Saying Hello
Date: Fri, 21 Nov 1997 09:55:06 -0600
Message-ID: <1234@local.machine.example>

This is a message just to say hello.
So, "Hello".
----
```

답장을 보낼 때 제목 필드는 섹션 3.6.5에 설명된 대로 앞에 "Re:"가 추가되지만 유지되는 경우가 많습니다.

```text
----
From: Mary Smith <mary@example.net>
To: John Doe <jdoe@machine.example>
Reply-To: "Mary Smith: Personal Account" <smith@home.example>
Subject: Re: Saying Hello
Date: Fri, 21 Nov 1997 10:01:10 -0600
Message-ID: <3456@example.net>
In-Reply-To: <1234@local.machine.example>
References: <1234@local.machine.example>

This is a reply to your hello.
----
```

위 메시지의 "답장:" 필드를 참고하세요.  John이 위에서 Mary의 메시지에 답장을 보낼 때 답장은 '보낸 사람:' 필드의 주소 대신 '답장:' 필드의 주소로 전달되어야 합니다.

```text
----
To: "Mary Smith: Personal Account" <smith@home.example>
From: John Doe <jdoe@machine.example>
Subject: Re: Saying Hello
Date: Fri, 21 Nov 1997 11:00:00 -0600
Message-ID: <abcd.1234@local.machine.tld>
In-Reply-To: <3456@example.net>
References: <1234@local.machine.example> <3456@example.net>

This is a reply to your reply.
----
```

---
### **A.3. Resent messages**

여러 번 예제로 사용된 메시지부터 시작하세요.

```text
----
From: John Doe <jdoe@machine.example>
To: Mary Smith <mary@example.net>
Subject: Saying Hello
Date: Fri, 21 Nov 1997 09:55:06 -0600
Message-ID: <1234@local.machine.example>

This is a message just to say hello.
So, "Hello".
----
```

Mary가 이 메시지를 받은 후 \(a\) 메시지가 John에게서 직접 온 것처럼 보이도록 Jane에게 메시지 사본을 보내고 싶다고 가정해 보겠습니다. \(b\) Jane이 메시지에 응답하면 응답은 John에게 다시 전송되어야 합니다. \(c\) 메시지가 원래 Mary에게 전송된 날짜, 메시지 식별자, 원래 수신인과 같은 모든 원본 정보가 보존됩니다.  이 경우 재전송 필드가 메시지 앞에 추가됩니다.

```text
----
Resent-From: Mary Smith <mary@example.net>
Resent-To: Jane Brown <j-brown@other.example>
Resent-Date: Mon, 24 Nov 1997 14:22:01 -0800
Resent-Message-ID: <78910@example.net>
From: John Doe <jdoe@machine.example>
To: Mary Smith <mary@example.net>
Subject: Saying Hello
Date: Fri, 21 Nov 1997 09:55:06 -0600
Message-ID: <1234@local.machine.example>

This is a message just to say hello.
So, "Hello".
----
```

Jane이 이 메시지를 다른 사람에게 다시 보내고 싶다면 위의 헤더 필드 앞에 자신의 resent 헤더 필드 세트를 추가하여 보낼 것입니다.

---
### **A.4. Messages with trace fields**

\[RFC2821\]에 설명된 대로 메시지가 전송 시스템을 통해 전송되면 추적 필드가 메시지 앞에 추가됩니다.  다음은 해당 추적 필드의 모양에 대한 예입니다.  이 줄은 길 수 있으므로 첫 번째 줄에는 약간의 접히는 공백이 있습니다.

```text
----
Received: from x.y.test
   by example.net
   via TCP
   with ESMTP
   id ABC12345
   for <mary@example.net>;  21 Nov 1997 10:05:43 -0600
Received: from machine.example by x.y.test; 21 Nov 1997 10:01:22 -0600
From: John Doe <jdoe@machine.example>
To: Mary Smith <mary@example.net>
Subject: Saying Hello
Date: Fri, 21 Nov 1997 09:55:06 -0600
Message-ID: <1234@local.machine.example>

This is a message just to say hello.
So, "Hello".
----
```

---
### **A.5. White space, comments, and other oddities**

접는 공백을 포함한 공백과 주석은 여러 필드 토큰 사이에 삽입될 수 있습니다.  A.1.3의 예를 보면 공백과 주석을 모든 필드에 삽입할 수 있습니다.

```text
----
From: Pete(A wonderful \) chap) <pete(his account)@silly.test(his host)>
To:A Group(Some people)
     :Chris Jones <c@(Chris's host.)public.example>,
         joe@example.org,
  John <jdoe@one.test> (my dear friend); (the end of the group)
Cc:(Empty list)(start)Undisclosed recipients  :(nobody(that I know))  ;
Date: Thu,
      13
        Feb
          1969
      23:32
               -0330 (Newfoundland Time)
Message-ID:              <testabcd.1234@silly.test>

Testing.
----
```

위의 예는 미학적으로는 불쾌하지만 완전히 합법적입니다. 특히 \(1\) "보낸 사람:" 필드의 주석\(따옴표 쌍의 일부로 나타나는 "\)" 문자가 있는 주석 포함\)에 유의하십시오. \(2\) "To:" 필드의 ":" 뒤에 없는 공백과 그룹 이름 뒤의 코멘트 및 접는 공백, Chris Jones 주소의 코멘트에 있는 특수 문자\("."\), 그리고 "joe@example.org," 앞뒤의 접는 공백; \(3\) "참조:" 필드에 여러 개의 중첩된 주석과 "참조" 바로 뒤의 ":" 바로 뒤에 있는 주석; \(4\) 접는 공백\(끝 부분을 제외하고는 주석 없음\) 및 날짜 필드 시간의 누락된 초; \(5\) "Message-ID:" 필드의 식별자 앞\(그러나 내부는 아님\)의 공백.

---
### **A.6. Obsoleted forms**

다음은 이 문서의 섹션 4에 설명된 더 이상 사용되지 않는\(즉, "생성하면 안 됩니다"\) 구문 요소의 예입니다.

---
#### **A.6.1. Obsolete addressing**

아래 예에서는 Joe Q. Public, Mary Smith의 주소에 나타나는 경로, "받는 사람:" 필드에 나타나는 두 개의 쉼표 및 "." 주위에 나타나는 공백 주위에 따옴표가 없다는 점에 유의하십시오. jdoe 주소에 있습니다.

```text
----
From: Joe Q. Public <john.q.public@example.com>
To: Mary Smith <@machine.tld:mary@example.net>, , jdoe@test   . example
Date: Tue, 1 Jul 2003 10:52:37 +0200
Message-ID: <5678.21-Nov-1997@example.com>

Hi everyone.
----
```

---
#### **A.6.2. Obsolete dates**

다음 메시지는 숫자가 아닌 시간대와 두 자리 연도를 포함하여 더 이상 사용되지 않는 날짜 형식을 사용합니다.  요일이 누락되었더라도 이는 사용되지 않는 구문에만 해당되는 것은 아닙니다. 현재 구문에서도 선택 사항입니다.

```text
----
From: John Doe <jdoe@machine.example>
To: Mary Smith <mary@example.net>
Subject: Saying Hello
Date: 21 Nov 97 09:55:06 GMT
Message-ID: <1234@local.machine.example>

This is a message just to say hello.
So, "Hello".
----
```

---
#### **A.6.3. Obsolete white space and comments**

현재 구문보다 더 많은 요소 사이에 공백과 주석이 나타날 수 있습니다.  또한 공백으로만 구성된 접는 선은 허용됩니다.

```text
----
From  : John Doe <jdoe@machine(comment).  example>
To    : Mary Smith
__
          <mary@example.net>
Subject     : Saying Hello
Date  : Fri, 21 Nov 1997 09(comment):   55  :  06 -0600
Message-ID  : <1234   @   local(blah)  .machine .example>

This is a message just to say hello.
So, "Hello".
----
```

특히 "받는 사람:" 필드의 두 번째 줄을 주목하세요.  두 개의 공백 문자로 시작됩니다.  \("\_\_"는 공백을 나타냅니다.\) 따라서 섹션 4.2에 설명된 대로 접기의 일부로 간주됩니다.  또한 주소, 날짜 및 메시지 식별자 전체의 주석과 공백은 모두 사용되지 않는 구문의 일부입니다.

---
# **Appendix B. Differences from earlier standards**

이 부록에는 이전 표준, 특히 \[RFC822\] 및 \[STD3\]에서 인터넷 메시지 형식에 적용된 변경 사항 목록이 포함되어 있습니다.  아래 별표\(\*\)가 표시된 항목은 이 문서의 섹션 4에 나타나는 항목이므로 더 이상 생성할 수 없습니다.

1. 구식 형태의 구문에서는 기간이 허용됩니다. 2. ABNF는 문서에서 \[RFC2234\]로 이동했습니다. 3. 연도는 4자리 이상 가능합니다. 4. 헤더 필드 순서\(및 그 부족\)가 명시적으로 지정되었습니다. 5. 암호화된 헤더 필드가 제거되었습니다. 6. 모든 토큰/값 쌍을 허용하도록 수신된 구문이 느슨해졌습니다. 7. "-0000" 시간대를 구체적으로 허용하고 의미를 부여합니다. 8. 모든 토큰 사이에 공백을 접는 것은 허용되지 않습니다. 9. 대상에 대한 요구 사항이 제거되었습니다. 10. 전달 및 재전송이 재정의되었습니다. 11. 확장 헤더 필드가 더 이상 구체적으로 호출되지 않습니다. 12. ASCII 0\(널\)이 제거되었습니다.\* 13. 접는 연속 줄에는 공백만 포함될 수 없습니다.\* 14. 날짜에는 주석을 자유롭게 삽입할 수 없습니다.\* 15. 숫자가 아닌 시간대는 허용되지 않습니다.\* 16. 두 자리 연도 허용되지 않습니다.\* 17. 세 자리 연도가 해석되지만 생성이 허용되지 않습니다. 18. 주소의 경로는 허용되지 않습니다.\* 19. 로컬 부분 및 도메인 내의 CFWS는 허용되지 않습니다.\* 20. 주소 목록의 빈 구성원은 허용되지 않습니다.\*

1. 필드명과 콜론 사이에 공백을 넣을 수 없습니다.\* 22. 필드명과 콜론 사이에 주석을 달 수 없습니다. 23. 회신 대상 및 참조의 구문을 강화했습니다.\* 24. msg-id 내의 CFWS는 허용되지 않습니다.\* 25. 정보 제공용으로만 재전송 필드의 의미를 강화했습니다. 26. 재전송-응답은 허용되지 않습니다.\* 27. 필드는 여러 번 발생하지 않습니다\(재전송 및 수신 제외\).\* 28. 무료 CR 및 LF는 허용되지 않습니다.\* 29. 반환 경로의 경로는 허용되지 않습니다.\* 30. 줄 길이 지정된 한도. 31. Bcc를 더 명확하게 지정했습니다.

---
# **Appendix C. Notices**

```text
   Intellectual Property
```

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장될 수 있는 지적 재산권 또는 기타 권리의 유효성이나 범위 또는 그러한 권리에 따른 라이센스가 적용되거나 적용되지 않을 수 있는 범위에 대해 어떠한 입장도 취하지 않습니다. 사용 가능; 또한 그러한 권리를 확인하기 위해 어떠한 노력도 했다는 뜻도 아닙니다.  표준 트랙 및 표준 관련 문서의 권리와 관련된 IETF 절차에 대한 정보는 BCP-11에서 찾을 수 있습니다.  출판을 위해 제공되는 권리 주장의 사본 및 제공될 라이센스에 대한 보증, 또는 이 사양의 구현자 또는 사용자가 해당 독점 권리의 사용에 대한 일반 라이센스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. IETF 사무국에서.

---
# **Full Copyright Statement**

저작권\(C\)인터넷학회\(2001\). 판권 소유.

본 문서와 그 번역본은 다른 사람에게 복사 및 제공될 수 있으며, 본 문서에 대해 논평하거나 설명하거나 구현을 지원하는 파생 저작물은 어떤 종류의 제한 없이 전체 또는 일부를 준비, 복사, 출판 및 배포할 수 있습니다. 단, 위의 저작권 표시와 이 단락은 모든 사본과 파생물에 포함되어 있어야 합니다. 그러나 이 문서 자체는 저작권 표시를 제거하거나 인터넷 협회 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떠한 방식으로도 수정할 수 없습니다. 단, 인터넷 표준을 개발할 목적으로 필요한 경우는 제외됩니다. 이 경우 저작권에 대한 절차는 인터넷 표준 프로세스를 따라야 하거나 영어 이외의 언어로 번역하려면 필요한 대로 따라야 합니다.

위에 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회와 인터넷 엔지니어링 태스크 포스는 여기에 있는 정보의 사용으로 인해 발생하지 않는 모든 보증을 포함하되 이에 국한되지 않고 명시적이든 묵시적이든 모든 보증을 부인합니다. 특정 목적에 대한 상품성이나 적합성에 대한 권리나 묵시적인 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집 기능을 위한 자금은 현재 Internet Society에서 제공됩니다.
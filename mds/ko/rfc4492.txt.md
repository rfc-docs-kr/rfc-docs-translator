

```text
Network Working Group                                    S. Blake-Wilson
Request for Comments: 4492                                       SafeNet
Category: Informational                                       N. Bolyard
                                                        Sun Microsystems
                                                                V. Gupta
                                                                Sun Labs
                                                                 C. Hawk
                                                               Corriente
                                                              B. Moeller
                                                         Ruhr-Uni Bochum
                                                                May 2006

            Elliptic Curve Cryptography (ECC) Cipher Suites
                   for Transport Layer Security (TLS)
```

---
# **Status of This Memo**

이 메모는 인터넷 커뮤니티에 대한 정보를 제공합니다. 어떤 종류의 인터넷 표준도 지정하지 않습니다. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(2006\).

---
# **Abstract**

이 문서는 TLS\(Transport Layer Security\) 프로토콜용 ECC\(Elliptic Curve Cryptography\) 기반의 새로운 키 교환 알고리즘에 대해 설명합니다. 특히 TLS 핸드셰이크에서 ECDH\(Elliptic Curve Diffie-Hellman\) 키 계약을 사용하고 새로운 인증 메커니즘으로 ECDSA\(Elliptic Curve Digital Signature Algorithm\)를 사용하도록 지정합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................3
   2. Key Exchange Algorithms .........................................4
      2.1. ECDH_ECDSA .................................................6
      2.2. ECDHE_ECDSA ................................................6
      2.3. ECDH_RSA ...................................................7
      2.4. ECDHE_RSA ..................................................7
      2.5. ECDH_anon ..................................................7
   3. Client Authentication ...........................................8
      3.1. ECDSA_sign .................................................8
      3.2. ECDSA_fixed_ECDH ...........................................9
      3.3. RSA_fixed_ECDH .............................................9
   4. TLS Extensions for ECC ..........................................9
   5. Data Structures and Computations ...............................10
      5.1. Client Hello Extensions ...................................10
           5.1.1. Supported Elliptic Curves Extension ................12
           5.1.2. Supported Point Formats Extension ..................13
      5.2. Server Hello Extension ....................................14
      5.3. Server Certificate ........................................15
      5.4. Server Key Exchange .......................................17
      5.5. Certificate Request .......................................21
      5.6. Client Certificate ........................................22
      5.7. Client Key Exchange .......................................23
      5.8. Certificate Verify ........................................25
      5.9. Elliptic Curve Certificates ...............................26
      5.10. ECDH, ECDSA, and RSA Computations ........................26
   6. Cipher Suites ..................................................27
   7. Security Considerations ........................................28
   8. IANA Considerations ............................................29
   9. Acknowledgements ...............................................29
   10. References ....................................................30
      10.1. Normative References .....................................30
      10.2. Informative References ...................................31
   Appendix A.  Equivalent Curves (Informative) ......................32
```

---
## **1.  Introduction**

ECC\(Elliptic Curve Cryptography\)는 특히 모바일\(즉, 무선\) 환경에서 매력적인 공개 키 암호 시스템으로 부상하고 있습니다. RSA와 같은 현재 널리 사용되는 암호화 시스템과 비교할 때 ECC는 더 작은 키 크기로 동등한 보안을 제공합니다. 이것은 \[18\]에 기반한 다음 표에 설명되어 있으며, 공격을 위해 가장 잘 알려진 알고리즘을 기반으로 대칭 및 비대칭 키 암호 시스템에 대한 대략적인 비교 가능한 키 크기를 제공합니다.

```text
                    Symmetric  |   ECC   |  DH/DSA/RSA
                   ------------+---------+-------------
                        80     |   163   |     1024
                       112     |   233   |     2048
                       128     |   283   |     3072
                       192     |   409   |     7680
                       256     |   571   |    15360

                  Table 1: Comparable Key Sizes (in bits)
```

키 크기가 작을수록 전력, 메모리, 대역폭 및 계산 비용이 절약되므로 ECC는 제약된 환경에서 특히 매력적입니다.

이 문서는 TLS 버전 1.0\[2\] 및 TLS 버전 1.1\[3\] 모두에 적용되는 ECC를 지원하기 위한 TLS 추가 사항에 대해 설명합니다. 특히, 다음을 정의합니다.

o TLS 프리마스터 비밀을 설정하기 위해 장기 또는 임시 키와 함께 ECDH\(Elliptic Curve Diffie-Hellman\) 키 계약 체계 사용, 그리고

o TLS 피어 인증을 위한 고정 ECDH 인증서 및 ECDSA 사용.

이 문서의 나머지 부분은 다음과 같이 구성되어 있습니다. 섹션 2에서는 TLS를 위한 ECC 기반 키 교환 알고리즘의 개요를 제공합니다. 섹션 3에서는 클라이언트 인증을 위한 ECC 인증서 사용에 대해 설명합니다. 클라이언트가 특정 곡선 및 포인트 형식의 사용을 협상할 수 있도록 하는 TLS 확장은 섹션 4에 나와 있습니다. 섹션 5는 ECC 기반 핸드셰이크에 필요한 다양한 데이터 구조, TLS 메시지의 인코딩 및 해당 메시지 처리를 지정합니다. 섹션 6은 새로운 ECC 기반 암호화 제품군을 정의하고 이 사양의 모든 구현에 권장되는 이들 중 작은 하위 집합을 식별합니다. 섹션 7에서는 보안 고려 사항에 대해 설명합니다. 섹션 8은 이 문서에서 생성된 이름 공간에 대한 IANA 고려 사항을 설명합니다. 섹션 9는 승인을 제공합니다.

그 다음에는 이 문서에 인용된 규범적이고 유익한 참조 목록, 저자의 연락처 정보, 지적 재산권 및 저작권에 대한 설명이 나옵니다.

이 사양을 구현하려면 TLS\[2\]\[3\], TLS 확장\[4\] 및 ECC\[5\]\[6\]\[7\]\[11\]\[17\]에 익숙해야 합니다.

이 문서의 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 RFC 2119 \[1\]에 설명된 대로 해석되어야 합니다.\(MUST NOT\)

---
## **2.  Key Exchange Algorithms**

이 문서에서는 TLS를 위한 5개의 새로운 ECC 기반 키 교환 알고리즘을 소개합니다. 모두 ECDH를 사용하여 TLS premaster secret을 계산하며 ECDH 키\(장기 또는 임시\)의 수명과 이를 인증하는 데 사용되는 메커니즘\(있는 경우\)만 다릅니다. premaster secret에서 TLS master secret의 파생과 대량 암호화/MAC 키 및 초기화 벡터의 후속 생성은 키 교환 알고리즘과 독립적이며 ECC 도입의 영향을 받지 않습니다.

아래 표에는 각각 DH\_DSS, DHE\_DSS, DH\_RSA, DHE\_RSA 및 DH\_anon\(\[2\] 및 \[3\] 참조\)을 모방하는 새로운 키 교환 알고리즘이 요약되어 있습니다.

```text
          Key
          Exchange
          Algorithm           Description
          ---------           -----------
```

- ECDH\_ECDSA ECDSA 서명 인증서로 ECDH를 수정했습니다.

- ECDHE\_ECDSA ECDSA 서명이 있는 임시 ECDH.

- ECDH\_RSA RSA 서명 인증서로 ECDH를 수정했습니다.

- ECDHE\_RSA RSA 서명이 있는 임시 ECDH.

```text
          ECDH_anon           Anonymous ECDH, no signatures.

                     Table 2: ECC Key Exchange Algorithms
```

ECDHE\_ECDSA 및 ECDHE\_RSA 키 교환 메커니즘은 전방 보안을 제공합니다. ECDHE\_RSA를 사용하면 서버가 기존 RSA 인증서를 재사용하고 제한된 클라이언트의 타원 곡선 기본 설정을 쉽게 준수할 수 있습니다\(섹션 4 참조\). 그러나 계산 비용

순방향 보안을 제공하지 않는 기존 RSA 키 교환보다 ECDHE\_RSA의 경우 서버에서 발생하는 비용이 더 높습니다.

ECDH\_RSA 메커니즘은 서버가 ECC 인증서를 획득하도록 요구하지만 인증서 발급자는 여전히 서명을 위해 기존 RSA 키를 사용할 수 있습니다. 이렇게 하면 TLS 클라이언트에서 허용하는 신뢰할 수 있는 인증 기관의 키를 업데이트할 필요가 없습니다. ECDH\_ECDSA 메커니즘은 서버 및 인증 기관에 대한 ECC 키가 필요하며 RSA를 지원할 수 없는 제한된 장치에 가장 적합합니다.

익명 키 교환 알고리즘은 서버 또는 클라이언트의 인증을 제공하지 않습니다. 다른 익명 TLS 키 교환과 마찬가지로 메시지 가로채기\(man-in-the-middle\) 공격을 받을 수 있습니다. 이 알고리즘의 구현은 다른 수단으로 인증을 제공해야 합니다\(SHOULD\).\(SHOULD\)

ECDH와 ECDSA 키 사이에는 구조적 차이가 없습니다. 인증서 발급자는 X.509 v3 keyUsage 및 extendedKeyUsage 확장을 사용하여 ECC 공개 키의 사용을 특정 계산\[15\]으로 제한할 수 있습니다. 이 문서는 ECDH에서의 사용이 허용되는 경우 ECC 키를 ECDH 가능으로 지칭합니다. ECDSA 가능도 유사하게 정의됩니다.

```text
              Client                                        Server
              ------                                        ------

              ClientHello          -------->
                                                       ServerHello
                                                      Certificate*
                                                ServerKeyExchange*
                                              CertificateRequest*+
                                   <--------       ServerHelloDone
              Certificate*+
              ClientKeyExchange
              CertificateVerify*+
              [ChangeCipherSpec]
              Finished             -------->
                                                [ChangeCipherSpec]
                                   <--------              Finished

              Application Data     <------->      Application Data
```

\* 일부 조건에서는 메시지가 전송되지 않습니다.

- + 클라이언트 인증이 필요하지 않으면 메시지가 전송되지 않습니다.

```text
                 Figure 1: Message flow in a full TLS handshake
```

그림 1은 TLS 키 설정 프로토콜\(일명 전체 핸드셰이크\)과 관련된 모든 메시지를 보여줍니다. ECC 추가는 ClientHello, ServerHello, 서버의 인증서 메시지, ServerKeyExchange, ClientKeyExchange, CertificateRequest, 클라이언트의 인증서 메시지 및 CertificateVerify에만 직접적인 영향을 미칩니다. 다음으로, 이러한 메시지의 내용 및 처리 측면에서 각 ECC 키 교환 알고리즘을 자세히 설명합니다. 설명을 쉽게 하기 위해 클라이언트 인증 및 관련 메시지\(그림 1에서 +로 식별됨\)에 대한 논의는 섹션 3까지, 선택적 ECC 특정 확장\(Hello 메시지에 영향을 미침\)은 섹션 4까지 연기합니다.

---
### **2.1.  ECDH_ECDSA**

ECDH\_ECDSA에서 서버의 인증서는 ECDH 가능 공개 키를 포함하고 ECDSA로 서명되어야 합니다.\(MUST\)

ServerKeyExchange는 전송되어서는 안 됩니다\(서버의 인증서에는 클라이언트가 premaster secret에 도달하는 데 필요한 모든 필수 키 정보가 포함되어 있음\).\(MUST NOT\)

클라이언트는 서버의 장기 공개 키와 동일한 곡선에서 ECDH 키 쌍을 생성하고 공개 키를 ClientKeyExchange 메시지로 보냅니다\(클라이언트 인증 알고리즘 ECDSA\_fixed\_ECDH 또는 RSA\_fixed\_ECDH를 사용하는 경우 제외, 이 경우 섹션 3.2 또는 섹션 3.3의 수정 사항 적용하다\).

클라이언트와 서버 모두 ECDH 작업을 수행하고 결과 공유 비밀을 premaster secret으로 사용합니다. 모든 ECDH 계산은 섹션 5.10에 지정된 대로 수행됩니다.

---
### **2.2.  ECDHE_ECDSA**

ECDHE\_ECDSA에서 서버의 인증서는 ECDSA 가능 공개 키를 포함하고 ECDSA로 서명되어야 합니다.\(MUST\)

서버는 임시 ECDH 공개 키와 ServerKeyExchange 메시지의 해당 곡선 사양을 보냅니다. 이러한 매개변수는 서버 인증서의 공개 키에 해당하는 개인 키를 사용하여 ECDSA로 서명해야 합니다.\(MUST\)

클라이언트는 서버의 임시 ECDH 키와 동일한 곡선에서 ECDH 키 쌍을 생성하고 공개 키를 ClientKeyExchange 메시지로 보냅니다.

클라이언트와 서버 모두 ECDH 작업\(섹션 5.10\)을 수행하고 결과 공유 비밀을 premaster secret으로 사용합니다.

---
### **2.3.  ECDH_RSA**

이 키 교환 알고리즘은 서버의 인증서가 ECDSA가 아닌 RSA로 서명되어야 한다는 점을 제외하면 ECDH\_ECDSA와 동일합니다.\(MUST\)

---
### **2.4.  ECDHE_RSA**

이 키 교환 알고리즘은 서버의 인증서가 서명이 승인된 RSA 공개 키를 포함해야 하고 ServerKeyExchange 메시지의 서명이 해당 RSA 개인 키로 계산되어야 한다는 점을 제외하면 ECDHE\_ECDSA와 동일합니다. 서버 인증서는 RSA로 서명해야 합니다.\(MUST, MUST\)

---
### **2.5.  ECDH_anon**

ECDH\_anon에서 서버의 인증서, CertificateRequest, 클라이언트의 인증서 및 CertificateVerify 메시지는 보내서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

서버는 임시 ECDH 공개 키와 ServerKeyExchange 메시지의 해당 곡선 사양을 보내야 합니다. 이러한 매개변수는 서명되지 않아야 합니다\(MUST NOT\).\(MUST, MUST NOT\)

클라이언트는 서버의 임시 ECDH 키와 동일한 곡선에서 ECDH 키 쌍을 생성하고 공개 키를 ClientKeyExchange 메시지로 보냅니다.

클라이언트와 서버 모두 ECDH 작업을 수행하고 결과 공유 비밀을 premaster secret으로 사용합니다. 모든 ECDH 계산은 섹션 5.10에 지정된 대로 수행됩니다.

ECDH\_ECDSA, ECDHE\_ECDSA, ECDH\_RSA 및 ECDHE\_RSA 키 교환 알고리즘은 특정 서명 체계로 서명된 서버 인증서를 요구하지만 이 사양\(\[2\] 및 \[ 3\]\) 인증서 체인의 다른 곳에서 사용되는 서명 체계에 제한을 두지 않습니다. \(종종 그러한 제한이 유용할 것이며 인증 기관의 서명 관행에서 이것이 고려될 것으로 예상됩니다. 그러나 이러한 제한은 일반적으로 엄격하게 요구되지 않습니다. 클라이언트는 인증서가 체인의 중간 인증서 중 하나로 표시되는 신뢰할 수 있는 인증 기관에 의존하여 서버의 인증서를 확인할 수 있습니다.\)

---
## **3.  Client Authentication**

이 문서는 세 가지 새로운 클라이언트 인증 메커니즘을 정의합니다. 각각은 관련 클라이언트 인증서 유형에 따라 이름이 지정됩니다: ECDSA\_sign, ECDSA\_fixed\_ECDH 및 RSA\_fixed\_ECDH. ECDSA\_sign 메커니즘은 섹션 2에 설명된 모든 비익명 ECC 키 교환 알고리즘과 TLS\[2\]\[3\]에 정의된 기타 비익명\(비ECC\) 키 교환 알고리즘과 함께 사용할 수 있습니다. ECDSA\_fixed\_ECDH 및 RSA\_fixed\_ECDH 메커니즘은 ECDH\_ECDSA 및 ECDH\_RSA와 함께 사용할 수 있습니다. ECDHE\_ECDSA 및 ECDHE\_RSA와 함께 사용하는 것은 금지됩니다. 장기 ECDH 클라이언트 키를 사용하면 이러한 알고리즘의 순방향 비밀성 속성이 위태로워질 수 있기 때문입니다.

서버는 CertificateRequest 메시지에 이러한 인증서 유형 중 하나 이상을 포함하여 ECC 기반 클라이언트 인증을 요청할 수 있습니다. 서버는 협상된 키 교환 알고리즘에 대해 금지된 인증서 유형을 포함하지 않아야 합니다. 클라이언트는 서버가 제안한 방법에 적합한 인증서를 소유하고 있으며 이를 인증에 사용할 의향이 있는지 확인해야 합니다.

이러한 조건이 충족되지 않으면 클라이언트는 인증서가 없는 클라이언트 인증서 메시지를 보내야 합니다. 이 경우 ClientKeyExchange는 섹션 2에서 설명한 대로 전송되어야 하며 CertificateVerify는 전송되지 않아야 합니다. 서버에 클라이언트 인증이 필요한 경우 치명적인 핸드셰이크 실패 경고로 응답할 수 있습니다.

클라이언트가 적절한 인증서를 가지고 있고 이를 인증에 사용할 의향이 있는 경우 클라이언트의 인증서 메시지\(섹션 5.6에 따라\)에 해당 인증서를 보내고 인증된 키에 해당하는 개인 키의 소유를 증명해야 합니다. 적절한 인증서를 결정하고 소유를 증명하는 프로세스는 인증 메커니즘마다 다르며 아래에 설명되어 있습니다.

참고: 서버가 서버 인증서와 다른 유형의 클라이언트 인증서를 요청하고 클라이언트가 보내는 것이 허용됩니다.

---
### **3.1.  ECDSA_sign**

이 인증 메커니즘을 사용하려면 클라이언트는 ECDSA 가능 공개 키를 포함하고 ECDSA로 서명된 인증서를 소유해야 합니다.\(MUST\)

클라이언트는 5.8절에 설명된 대로 CertificateVerify 메시지에 서명을 포함하여 인증된 키에 해당하는 개인 키의 소유를 증명합니다.

---
### **3.2.  ECDSA_fixed_ECDH**

이 인증 메커니즘을 사용하려면 클라이언트는 ECDH 가능 공개 키가 포함된 인증서를 소유해야 하며 해당 인증서는 ECDSA로 서명해야 합니다. 또한 클라이언트의 ECDH 키는 서버의 장기\(인증된\) ECDH 키와 동일한 타원 곡선에 있어야 합니다. 이로 인해 이 메커니즘의 사용이 폐쇄된 환경으로 제한될 수 있습니다. 클라이언트가 다른 곡선에 ECC 키를 가지고 있는 상황에서는 ECDSA\_sign 또는 비ECC 메커니즘\(예: RSA\)을 사용하여 인증해야 합니다. 서버와 클라이언트 모두에 대해 고정 ECDH를 사용하는 것이 순방향 보안을 제공하는 메커니즘보다 계산적으로 더 효율적입니다.\(MUST, MUST\)

이 인증 메커니즘을 사용할 때 클라이언트는 섹션 5.7에 설명된 대로 빈 ClientKeyExchange를 보내야 하며 CertificateVerify 메시지를 보내서는 안 됩니다\(MUST NOT\). 서버가 premaster secret을 계산하는 데 필요한 클라이언트의 ECDH 공개 키가 클라이언트의 인증서 내에서 사용 가능하므로 ClientKeyExchange는 비어 있습니다. 서버와 동일한 프리마스터 시크릿에 도달하는 클라이언트의 능력\(Finished 메시지의 성공적인 교환으로 입증됨\)은 인증된 공개 키에 해당하는 개인 키의 소유를 증명하며 CertificateVerify 메시지는 불필요합니다.\(MUST NOT\)

---
### **3.3.  RSA_fixed_ECDH**

이 인증 메커니즘은 클라이언트의 인증서가 RSA로 서명되어야 한다는 점을 제외하면 ECDSA\_fixed\_ECDH와 동일합니다.\(MUST\)

ECDSA\_sign, ECDSA\_fixed\_ECDH 및 RSA\_fixed\_ECDH 클라이언트 인증 메커니즘은 특정 서명 체계로 서명된 클라이언트 인증서를 요구하지만 이 사양은 인증서 체인의 다른 곳에서 사용되는 서명 체계에 제한을 두지 않습니다. \(종종 그러한 제한이 유용할 것이며 인증 기관의 서명 관행에서 이것이 고려될 것으로 예상됩니다. 그러나 이러한 제한은 일반적으로 엄격하게 요구되지 않습니다. 서버는 체인의 중간 인증서 중 하나로 표시되는 트러스트 앵커에 의존하여 클라이언트 인증서의 유효성을 검사할 수 있습니다.\)

---
## **4.  TLS Extensions for ECC**

이 사양에는 \(i\) 지원되는 타원 곡선 확장 및 \(ii\) 지원되는 포인트 형식 확장의 두 가지 새로운 TLS 확장이 정의되어 있습니다. 이를 통해 새 세션을 시작하는 핸드셰이크 중에 특정 곡선 및 포인트 형식\(예: 각각 압축 및 비압축\)의 사용을 협상할 수 있습니다. 이러한 확장은 특히 다음과 같은 제한된 클라이언트와 관련이 있습니다.

제한된 수의 곡선 또는 점 형식만 지원합니다. 그들은 \[4\]에 요약된 일반적인 접근 방식을 따릅니다. 메시지 세부 사항은 섹션 5에 지정되어 있습니다. 클라이언트는 ClientHello 메시지에 적절한 확장을 포함하여 구문 분석할 수 있는 포인트 형식과 지원하는 곡선을 열거합니다. 서버는 ServerHello 메시지에 확장을 포함하여 구문 분석할 수 있는 포인트 형식을 유사하게 열거합니다.

ClientHello 메시지에서 ECC 암호화 제품군을 제안하는 TLS 클라이언트는 이러한 확장을 포함해야 합니다\(SHOULD\). ECC 암호화 제품군을 구현하는 서버는 이러한 확장을 지원해야 하며 클라이언트가 이러한 확장을 사용할 때 서버는 클라이언트가 지정한 곡선 및 압축 기술의 선택을 존중하면서 핸드셰이크를 완료할 수 없는 한 ECC 암호화 제품군의 사용을 협상해서는 안 됩니다\(MUST NOT\). 이렇게 하면 클라이언트가 서버의 EC 키를 처리할 수 없기 때문에 협상된 ECC 핸드셰이크가 나중에 중단될 가능성이 제거됩니다.\(SHOULD, MUST NOT\)

클라이언트는 ECC 암호화 제품군을 제안하지 않는 경우 ClientHello 메시지에 이러한 확장을 포함해서는 안 됩니다\(MUST NOT\). ECC 암호화 제품군을 제안하는 클라이언트는 이러한 확장을 포함하지 않도록 선택할 수 있습니다. 이 경우 서버는 섹션 5에 나열된 타원 곡선 또는 점 형식 중 하나를 자유롭게 선택할 수 있습니다. 해당 섹션에서는 이러한 확장의 구조 및 처리에 대해서도 자세히 설명합니다.\(MUST NOT\)

세션 재개의 경우 서버는 단순히 현재 ClientHello 메시지에 나타나는 Supported Elliptic Curves Extension 및 Supported Point Formats Extension을 무시합니다. 이러한 확장은 새 세션을 협상하는 핸드셰이크 중에만 역할을 합니다.

---
## **5.  Data Structures and Computations**

이 섹션은 섹션 2, 3 및 4에 지정된 ECC 기반 키 메커니즘에서 사용되는 데이터 구조 및 계산을 지정합니다. 여기에서 사용된 표시 언어는 TLS\[2\]\[3\]에서 사용된 것과 동일합니다. 이 사양은 TLS를 확장하므로 이러한 설명은 TLS 사양 및 TLS를 확장하는 다른 모든 설명과 병합되어야 합니다. 이는 열거형 유형이 가능한 모든 값을 지정하지 않을 수 있으며 select\(\) 절로 선택한 여러 형식의 구조가 모든 가능한 경우를 나타내지 않을 수 있음을 의미합니다.

---
### **5.1.  Client Hello Extensions**

이 섹션에서는 \[4\]에 설명된 대로 ClientHello 메시지에 포함될 수 있는 두 가지 TLS 확장인 Supported Elliptic Curves Extension과 Supported Point Formats Extension을 지정합니다.

이러한 확장이 전송될 때:

확장은 ECC 암호화 제품군을 제안하는 ClientHello 메시지와 함께 전송되어야 합니다\(SHOULD\).\(SHOULD\)

이러한 확장의 의미:

이러한 확장을 통해 클라이언트는 지원하는 타원 곡선 및/또는 구문 분석할 수 있는 포인트 형식을 열거할 수 있습니다.

이러한 확장의 구조:

TLS 확장의 일반적인 구조는 \[4\]에 설명되어 있으며 이 사양은 ExtensionType에 두 가지 새로운 유형을 추가합니다.

```text
       enum { elliptic_curves(10), ec_point_formats(11) } ExtensionType;
```

elliptic\_curves\(Supported Elliptic Curves Extension\): 클라이언트에서 지원하는 타원 곡선 집합을 나타냅니다. 이 확장의 경우 불투명 extension\_data 필드에 EllipticCurveList가 포함됩니다. 자세한 내용은 섹션 5.1.1을 참조하십시오.

ec\_point\_formats\(지원되는 포인트 형식 확장\): 클라이언트가 구문 분석할 수 있는 포인트 형식 집합을 나타냅니다. 이 확장의 경우 불투명 extension\_data 필드에 ECPointFormatList가 포함됩니다. 자세한 내용은 섹션 5.1.2를 참조하십시오.

발신자의 조치:

ClientHello 메시지에서 ECC 암호화 제품군을 제안하는 클라이언트는 지원하는 곡선과 구문 분석할 수 있는 포인트 형식을 열거하면서 이러한 확장을 추가합니다\(다른 확장과 함께\). 클라이언트는 Supported Elliptic Curves Extension과 Supported Point Formats Extension을 모두 보내야 합니다\(SHOULD\). 지원되는 포인트 형식 확장이 실제로 전송되면 포인트 형식 목록의 항목 중 하나로 값 0\(압축되지 않음\)을 포함해야 합니다.\(SHOULD, MUST\)

수신자의 조치:

이러한 확장 중 하나 또는 둘 모두를 포함하는 ClientHello를 수신하는 서버는 클라이언트의 열거 기능을 사용하여 적절한 암호화 제품군의 선택을 안내해야 합니다. 제안된 ECC 암호화 제품군 중 하나는 클라이언트가 지원하는 곡선 및 포인트 형식을 사용하는 동안 서버가 핸드셰이크를 성공적으로 완료할 수 있는 경우에만 협상되어야 합니다\(섹션 5.3 및 5.4 참조\).\(MUST\)

참고: ECDHE-ECDSA 키 교환에 참여하는 서버는 \(i\) 인증서의 ECDSA 키 및 \(ii\) ServerKeyExchange 메시지의 임시 ECDH 키에 대해 서로 다른 곡선을 사용할 수 있습니다. 서버는 두 경우 모두 확장을 고려해야 합니다.

서버가 지원되는 타원 곡선 확장을 이해하지 못하거나 지원되는 포인트 형식 확장을 이해하지 못하거나 열거된 곡선 및 포인트 형식으로 자신을 제한하면서 ECC 핸드셰이크를 완료할 수 없는 경우 ECC 암호 사용을 협상해서는 안 됩니다\(MUST NOT\). 모음곡. 클라이언트에서 제안하고 서버에서 지원하는 다른 암호 제품군에 따라 공통 암호 제품군이 없기 때문에 치명적인 핸드셰이크 실패 경고가 발생할 수 있습니다.\(MUST NOT\)

---
#### **5.1.1.  Supported Elliptic Curves Extension**

```text
        enum {
            sect163k1 (1), sect163r1 (2), sect163r2 (3),
            sect193r1 (4), sect193r2 (5), sect233k1 (6),
            sect233r1 (7), sect239k1 (8), sect283k1 (9),
            sect283r1 (10), sect409k1 (11), sect409r1 (12),
            sect571k1 (13), sect571r1 (14), secp160k1 (15),
            secp160r1 (16), secp160r2 (17), secp192k1 (18),
            secp192r1 (19), secp224k1 (20), secp224r1 (21),
            secp256k1 (22), secp256r1 (23), secp384r1 (24),
            secp521r1 (25),
            reserved (0xFE00..0xFEFF),
            arbitrary_explicit_prime_curves(0xFF01),
            arbitrary_explicit_char2_curves(0xFF02),
            (0xFFFF)
        } NamedCurve;
```

sect163k1 등: 해당 명명된 곡선 또는 명시적으로 정의된 곡선 클래스의 지원을 나타냅니다. 여기에 정의된 명명된 곡선은 SEC 2\[13\]에 지정된 곡선입니다. 이러한 곡선의 대부분은 ANSI X9.62\[7\] 및 FIPS 186-2\[11\]에서도 권장됩니다. 0xFE00에서 0xFEFF까지의 값은 개인용으로 예약되어 있습니다. 값 0xFF01 및 0xFF02는 클라이언트가 각각 임의의 프라임 및 특성 2 곡선을 지원함을 나타냅니다\(곡선 매개변수는 ECParameters에서 명시적으로 인코딩되어야 함\).

NamedCurve 네임스페이스는 IANA에서 관리합니다. 새 값 할당이 추가되는 방법에 대한 정보는 섹션 8을 참조하십시오.

```text
        struct {
            NamedCurve elliptic_curve_list<1..2^16-1>
        } EllipticCurveList;
```

elliptic\_curve\_list의 항목은 클라이언트의 기본 설정에 따라 정렬됩니다\(선호하는 항목 먼저\).

예를 들어, secp192r1\(일명 NIST P-192, 값 19 = 0x0013\) 및 secp224r1\(일명 NIST P-224, 값 21 = 0x0015\)만 지원하고 secp192r1 사용을 선호하는 클라이언트는 다음으로 구성된 TLS 확장을 포함합니다. 옥텟. 처음 두 옥텟은 확장 유형\(지원되는 타원 곡선 확장\)을 나타냅니다.

```text
        00 0A 00 06 00 04 00 13 00 15
```

임의의 명시적 특성-2 곡선\(값 0xFF02\)을 지원하는 클라이언트에는 다음 옥텟으로 구성된 확장이 포함됩니다.

```text
        00 0A 00 04 00 02 FF 02
```

---
#### **5.1.2.  Supported Point Formats Extension**

```text
        enum { uncompressed (0), ansiX962_compressed_prime (1),
               ansiX962_compressed_char2 (2), reserved (248..255)
        } ECPointFormat;

        struct {
            ECPointFormat ec_point_format_list<1..2^8-1>
        } ECPointFormatList;
```

위의 ECPointFormat 정의에는 세 가지 포인트 형식이 포함되어 있습니다. 압축되지 않은 포인트 형식은 이 문서의 구현이 지원되는 모든 곡선에 대해 지원해야 한다는 점에서 기본 형식입니다. 압축 포인트 형식은 포인트의 x 좌표와 y 좌표의 단일 비트만 포함하여 대역폭을 줄입니다. 이 문서의 구현은 ansiX962\_compressed\_prime 및 ansiX962\_compressed\_char2 형식을 지원할 수 있습니다\(MAY\). 전자는 소수 곡선에만 적용되고 후자는 특성 2 곡선에만 적용됩니다. \(이러한 형식은 \[7\]에 지정되어 있습니다.\) 248에서 255까지의 값은 개인용으로 예약되어 있습니다.\(MUST, MAY\)

ECPointFormat 네임스페이스는 IANA에서 관리합니다. 새 값 할당이 추가되는 방법에 대한 정보는 섹션 8을 참조하십시오.

ec\_point\_format\_list의 항목은 클라이언트의 기본 설정에 따라 정렬됩니다\(선호하는 항목 먼저\).

압축되지 않은 포인트 형식\(값 0\)만 구문 분석할 수 있는 클라이언트에는 다음 옥텟으로 구성된 확장이 포함됩니다. 처음 두 옥텟은 확장 유형\(지원되는 포인트 형식 확장\)을 나타냅니다.

```text
        00 0B 00 02 01 00
```

프라임 필드의 경우 압축되지 않은 형식\(값 0\)보다 압축된 형식\(ansiX962\_compressed\_prime, 값 1\)을 선호하지만 특성-2 필드의 경우 압축된 형식\(값 0\)보다 압축되지 않은 형식\(값 0\)을 선호하는 클라이언트 ansiX962\_compressed\_char2, 값 2\)는 다음 옥텟으로 구성된 확장을 포함하여 이러한 기본 설정을 나타낼 수 있습니다.

```text
        00 0B 00 04 03 01 00 02
```

---
### **5.2.  Server Hello Extension**

이 섹션은 \[4\], Supported Point Formats Extension에 설명된 대로 ServerHello 메시지에 포함될 수 있는 TLS 확장을 지정합니다.

이 확장이 전송될 때:

Supported Point Formats Extension은 ECC 암호화 제품군을 협상할 때 Supported Point Formats Extension을 포함하는 ClientHello 메시지에 대한 응답으로 ServerHello 메시지에 포함됩니다.

이 확장의 의미:

이 확장을 통해 서버는 구문 분석할 수 있는 포인트 형식을 열거할 수 있습니다\(ECDHE\_ECDSA, ECDHE\_RSA 또는 ECDH\_anon 키 교환 알고리즘을 사용할 때 ServerKeyExchange 메시지에 표시되는 곡선 또는 ECDH\_ECDSA 또는 ECDH\_RSA 키 교환 알고리즘을 사용할 때 인증서 메시지에 나타납니다.

이 확장의 구조:

서버의 Supported Point Formats Extension은 클라이언트의 Supported Point Formats Extension과 구조가 동일합니다\(섹션 5.1.2 참조\). 여기서 elliptic\_curve\_list의 항목은 서버의 기본 설정에 따라 정렬됩니다\(선호하는 항목 먼저\). 서버는 클라이언트 목록에서 찾을 수 없는 항목을 포함할 수 있습니다\(예: 서버는 클라이언트가 이 형식을 구문 분석할 수 없는 경우에도 압축 형식으로 포인트를 수신하는 것을 선호할 수 있습니다. 그럼에도 불구하고 동일한 클라이언트는 압축 형식으로 포인트를 출력할 수 있습니다. \).

발신자의 조치:

Supported Point Formats Extension을 포함하는 ClientHello 메시지에 대한 응답으로 ECC 암호화 제품군을 선택하는 서버는 이 확장을 ServerHello 메시지에 추가하여 구문 분석할 수 있는 포인트 형식을 열거합니다. Supported Point Formats Extension이 사용될 때 포인트 형식 목록의 항목 중 하나로 값 0\(압축되지 않음\)을 포함해야 합니다.\(MUST\)

수신자의 조치:

Supported Point Formats Extension이 포함된 ServerHello 메시지를 수신하는 클라이언트는 핸드셰이크 동안 서버의 포인트 형식 선택을 존중해야 합니다\(섹션 5.6 및 5.7 참조\). 지원되는 포인트 형식 확장이 ServerHello와 함께 수신되지 않는 경우 이는 비압축 포인트 형식만 허용하는 확장과 동일합니다.\(MUST\)

---
### **5.3.  Server Certificate**

이 메시지가 전송될 때:

이 메시지는 모든 비익명 ECC 기반 키 교환 알고리즘으로 전송됩니다.

이 메시지의 의미:

이 메시지는 서버의 정적 공개 키를 클라이언트에 확실하게 전달하는 데 사용됩니다. 다음 표는 각 키 교환 알고리즘에 적합한 서버 인증서 유형을 보여줍니다. ECC 공개 키는 섹션 5.9에 설명된 대로 인증서에 인코딩되어야 합니다.\(MUST\)

참고: 서버의 인증서 메시지는 일련의 인증서를 전달할 수 있습니다. 표 3에 언급된 제한 사항은 서버의 인증서\(체인의 첫 번째\)에만 적용됩니다.

```text
          Key Exchange Algorithm  Server Certificate Type
          ----------------------  -----------------------
```

ECDH\_ECDSA 인증서에는

- ECDH 가능 공개 키. ECDSA로 서명해야 합니다.\(MUST, MUST\)

ECDHE\_ECDSA 인증서에는

- ECDSA 가능 공개 키. ECDSA로 서명해야 합니다.\(MUST, MUST\)

ECDH\_RSA 인증서에는

- ECDH 가능 공개 키. RSA로 서명해야 합니다.\(MUST, MUST\)

ECDHE\_RSA 인증서에는

- 디지털 서명에 사용하도록 승인된 RSA 공개 키입니다. RSA로 서명해야 합니다.\(MUST, MUST\)

```text
                    Table 3: Server Certificate Types
```

이 메시지의 구조:

TLS 인증서 형식과 동일합니다.

발신자의 조치:

서버는 적절한 인증서 체인을 구성하고 이를 인증서 메시지로 클라이언트에 전달합니다. 클라이언트가 지원되는 타원 곡선 확장을 사용한 경우 서버 인증서의 공개 키는 클라이언트의 타원 곡선 선택을 존중해야 합니다. 특히 공개 키는 클라이언트가 적절한 유형의 명시적 곡선에 대한 지원을 표시하지 않는 한 명명된 곡선\(명시적 곡선과 동일한 곡선이 아님\)을 사용해야 합니다. 클라이언트가 Supported Point Formats Extension을 사용한 경우 서버의 공개 키 포인트와 \(명시적 곡선의 경우\) 곡선의 기준점 모두 클라이언트의 포인트 형식 선택을 존중해야 합니다. \(이러한 요구 사항을 충족할 수 없는 서버는 ServerHello 메시지에서 ECC 암호화 제품군을 선택하면 안 됩니다.\)\(MUST, MUST, MUST NOT\)

수신자의 조치:

클라이언트는 인증서 체인의 유효성을 검사하고 서버의 공개 키를 추출하며 키 유형이 협상된 키 교환 알고리즘에 적합한지 확인합니다. \(치명적인 핸드셰이크 실패의 가능한 이유는 타원 곡선 및 포인트 형식을 처리하는 클라이언트의 기능이 초과되었기 때문입니다. 섹션 5.1. 참조\)

---
### **5.4.  Server Key Exchange**

이 메시지가 전송될 때:

이 메시지는 ECDHE\_ECDSA, ECDHE\_RSA 및 ECDH\_anon 키 교환 알고리즘을 사용할 때 전송됩니다.

이 메시지의 의미:

이 메시지는 서버의 임시 ECDH 공개 키\(및 해당 타원 곡선 도메인 매개변수\)를 클라이언트에 전달하는 데 사용됩니다.

이 메시지의 구조:

```text
        enum { explicit_prime (1), explicit_char2 (2),
               named_curve (3), reserved(248..255) } ECCurveType;
```

명시적\_프라임: 타원 곡선 도메인 매개변수가 상세하게 전달되고 기본 유한 필드가 프라임 필드임을 나타냅니다.

명시적\_char2: 타원 곡선 도메인 매개변수가 상세하게 전달되고 기본 유한 필드가 특성-2 필드임을 나타냅니다.

named\_curve: 명명된 곡선이 사용됨을 나타냅니다. 이 옵션은 해당되는 경우 사용해야 합니다.\(SHOULD\)

248에서 255 사이의 값은 개인용으로 예약되어 있습니다.

ECCurveType 네임스페이스는 IANA에서 관리합니다. 새 값 할당이 추가되는 방법에 대한 정보는 섹션 8을 참조하십시오.

```text
        struct {
            opaque a <1..2^8-1>;
            opaque b <1..2^8-1>;
        } ECCurve;
```

a, b: 이 매개변수는 타원 곡선의 계수를 지정합니다. 각 값에는 ANSI X9.62\[7\]의 섹션 4.3.3에 있는 변환 루틴을 따르는 필드 요소의 바이트 문자열 표현이 포함됩니다.

```text
        struct {
            opaque point <1..2^8-1>;
        } ECPoint;
```

point: 이것은 ANSI X9.62\[7\]의 섹션 4.3.6에 있는 변환 루틴을 따르는 타원 곡선 점의 바이트 문자열 표현입니다. 이 바이트 문자열은 비압축 또는 압축 형식의 타원 곡선 점을 나타낼 수 있습니다. 이 확장이 사용된 경우 지원되는 포인트 형식 확장을 통해 클라이언트가 요청한 내용을 준수해야 합니다.\(MUST\)

```text
        enum { ec_basis_trinomial, ec_basis_pentanomial } ECBasisType;
```

ec\_basis\_trinomial: 삼항식 기반을 사용하는 특성-2 필드의 표현을 나타냅니다.

ec\_basis\_pentanomial: a의 표현을 나타냅니다.

- 펜타노미얼 기반을 사용하는 특성-2 필드.

```text
        struct {
            ECCurveType    curve_type;
            select (curve_type) {
                case explicit_prime:
                    opaque      prime_p <1..2^8-1>;
                    ECCurve     curve;
                    ECPoint     base;
                    opaque      order <1..2^8-1>;
                    opaque      cofactor <1..2^8-1>;
                case explicit_char2:
                    uint16      m;
                    ECBasisType basis;
                    select (basis) {
                        case ec_trinomial:
                            opaque  k <1..2^8-1>;
                        case ec_pentanomial:
                            opaque  k1 <1..2^8-1>;
                            opaque  k2 <1..2^8-1>;
                            opaque  k3 <1..2^8-1>;
                    };
                    ECCurve     curve;
                    ECPoint     base;
                    opaque      order <1..2^8-1>;
                    opaque      cofactor <1..2^8-1>;

                case named_curve:
                    NamedCurve namedcurve;
            };
        } ECParameters;
```

curve\_type: 타원 곡선 도메인 매개변수의 유형을 식별합니다.

prime\_p: 필드 Fp를 정의하는 홀수 소수입니다.

curve: 타원 곡선 E의 계수 a와 b를 지정합니다.

base: 타원 곡선의 기준점 G를 지정합니다.

order: 기준점의 차수 n을 지정합니다.

cofactor: cofactor h = #E\(Fq\)/n을 지정합니다. 여기서 #E\(Fq\)는 필드 Fq\(Fp 또는 F2^m\)에 대해 정의된 타원 곡선 E의 점 수를 나타냅니다.

m: 이것은 특성-2 필드 F2^m의 차수입니다.

k: 삼항식 기저 표현 x^m + x^k +1에 대한 지수 k입니다.

k1, k2, k3: 5항식 표현 x^m + x^k3 + x^k2 + x^k1 + 1의 지수\(예: k3 \> k2 \> k1\).

namedcurve: 타원 곡선 도메인 매개변수의 권장 세트를 지정합니다. 특정 곡선을 참조하는 NamedCurve의 모든 값이 허용됩니다. 명시적으로 정의된 곡선 클래스에 대한 지원을 나타내는 NamedCurve 값은 여기에서 허용되지 않습니다\(ClientHello 확장에서만 허용됨\). 이는 random\_explicit\_prime\_curves\(0xFF01\) 및 임의\_explicit\_char2\_curves\(0xFF02\)에 적용됩니다.

```text
        struct {
            ECParameters    curve_params;
            ECPoint         public;
        } ServerECDHParams;
```

curve\_params: ECDH 공개 키와 관련된 타원 곡선 도메인 매개변수를 지정합니다.

공개: 임시 ECDH 공개 키입니다.

ServerKeyExchange 메시지는 다음과 같이 확장됩니다.

```text
        enum { ec_diffie_hellman } KeyExchangeAlgorithm;
```

ec\_diffie\_hellman: ServerKeyExchange 메시지에 ECDH 공개 키가 포함되어 있음을 나타냅니다.

```text
        select (KeyExchangeAlgorithm) {
            case ec_diffie_hellman:
                ServerECDHParams    params;
                Signature           signed_params;
        } ServerKeyExchange;
```

매개변수: ECDH 공개 키 및 관련 도메인 매개변수를 지정합니다.

signed\_params: 해당 해시에 적절한 서명이 적용된 params의 해시입니다. 서명에는 서버의 인증서 메시지에 있는 인증된 공개 키에 해당하는 개인 키가 사용됩니다.

```text
          enum { ecdsa } SignatureAlgorithm;

          select (SignatureAlgorithm) {
              case ecdsa:
                  digitally-signed struct {
                      opaque sha_hash[sha_size];
                  };
          } Signature;

        ServerKeyExchange.signed_params.sha_hash
            SHA(ClientHello.random + ServerHello.random +
                                              ServerKeyExchange.params);
```

참고: SignatureAlgorithm은 ECDHE\_RSA 키 교환 알고리즘의 경우 "rsa"이고 ECDH\_anon의 경우 "익명"입니다. 이러한 경우는 TLS \[2\]\[3\]에 정의되어 있습니다. SignatureAlgorithm은 ECDHE\_ECDSA에 대해 "ecdsa"입니다. ECDSA 서명은 섹션 5.10에 설명된 대로 생성되고 확인되며, sha\_hash에 대한 위 템플릿의 SHA는 그에 따라 SHA-1 이외의 해시 알고리즘을 나타낼 수 있습니다. ANSI X9.62에 따라 ECDSA 서명은 정수 쌍 r과 s로 구성됩니다. 디지털 서명 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며, 그 내용은 다음 ASN.1 표기법\[8\]에 해당하는 DER 인코딩\[9\]입니다.

```text
           Ecdsa-Sig-Value ::= SEQUENCE {
               r       INTEGER,
               s       INTEGER
           }
```

발신자의 조치:

서버는 IEEE 1363\[6\]의 ECKAS-DH1 체계에 따라 타원 곡선 도메인 매개변수와 이러한 매개변수에 해당하는 임시 ECDH 공개 키를 선택합니다. 위에서 정의한 형식을 사용하여 ServerKeyExchange 메시지에서 이 정보를 클라이언트에 전달합니다.

수신자의 조치:

클라이언트는 서명\(있는 경우\)을 확인하고 ServerKeyExchange 메시지에서 서버의 타원 곡선 도메인 매개변수 및 임시 ECDH 공개 키를 검색합니다. \(치명적인 핸드셰이크 실패의 가능한 이유는 타원 곡선 및 포인트 형식을 처리하는 클라이언트의 기능이 초과되었기 때문입니다. 섹션 5.1. 참조\)

---
### **5.5.  Certificate Request**

이 메시지가 전송될 때:

이 메시지는 클라이언트 인증을 요청할 때 전송됩니다.

이 메시지의 의미:

서버는 이 메시지를 사용하여 허용 가능한 클라이언트 인증 방법을 제안합니다.

이 메시지의 구조:

TLS CertificateRequest 메시지는 다음과 같이 확장됩니다.

```text
        enum {
            ecdsa_sign(64), rsa_fixed_ecdh(65),
            ecdsa_fixed_ecdh(66), (255)
        } ClientCertificateType;
```

ecdsa\_sign 등. 서버가 섹션 3에 지정된 해당 클라이언트 인증 방법을 사용하려고 함을 나타냅니다.

발신자의 조치:

서버는 사용할 클라이언트 인증 방법을 결정하고 위에서 정의한 형식을 사용하여 이 정보를 클라이언트에 전달합니다.

수신자의 조치:

클라이언트는 요청된 방법과 함께 사용하기에 적합한 인증서가 있는지 여부와 클라이언트 인증을 진행할지 여부를 결정합니다.

---
### **5.6.  Client Certificate**

이 메시지가 전송될 때:

이 메시지는 클라이언트가 적합한 인증서를 가지고 있고 클라이언트 인증을 진행하기로 결정한 경우 CertificateRequest에 대한 응답으로 전송됩니다. \(서버가 지원되는 포인트 형식 확장을 사용한 경우 인증서에 지정된 공개 키 포인트가 서버의 포인트 형식 선택을 존중하는 경우 인증서는 ECDSA\_sign, RSA\_fixed\_ECDH 및 ECDSA\_fixed\_ECDH 인증 방법과 함께 사용하기에 적합한 것으로 간주될 수 있습니다. 지원되는 포인트 형식 확장이 사용되지 않은 경우 인증서는 포인트가 압축되지 않은 포인트 형식으로 표시되는 경우에만 이러한 인증 방법과 함께 사용하기에 적합한 것으로 간주될 수 있습니다.\)

이 메시지의 의미:

이 메시지는 클라이언트의 정적 공개 키를 서버에 확실하게 전달하는 데 사용됩니다. 다음 표에는 섹션 3에 설명된 ECC 기반 클라이언트 인증 메커니즘에 적합한 클라이언트 인증서 유형이 요약되어 있습니다. ECC 공개 키는 섹션 5.9에 설명된 대로 인증서에 인코딩되어야 합니다.

참고: 클라이언트의 인증서 메시지는 일련의 인증서를 전달할 수 있습니다. 표 4에 언급된 제한 사항은 클라이언트의 인증서\(체인의 첫 번째\)에만 적용됩니다.

```text
          Client
          Authentication Method   Client Certificate Type
          ---------------------   -----------------------
```

ECDSA\_sign 인증서에는 다음이 포함되어야 합니다.

- ECDSA 가능 공개 키이며 ECDSA로 서명되어야 합니다.\(MUST\)

ECDSA\_fixed\_ECDH 인증서에는

- 서버의 장기 ECDH 키와 동일한 타원 곡선에 있는 ECDH 가능 공개 키. 이 인증서는 ECDSA로 서명해야 합니다.\(MUST, MUST\)

RSA\_fixed\_ECDH 인증서에는

- 서버의 장기 ECDH 키와 동일한 타원 곡선에 있는 ECDH 가능 공개 키. 이 인증서는 RSA로 서명해야 합니다.\(MUST, MUST\)

```text
                     Table 4: Client Certificate Types
```

이 메시지의 구조:

TLS 클라이언트 인증서 형식과 동일합니다.

발신자의 조치:

클라이언트는 적절한 인증서 체인을 구성하고 이를 인증서 메시지로 서버에 전달합니다.

수신자의 조치:

TLS 서버는 인증서 체인의 유효성을 검사하고 클라이언트의 공개 키를 추출하며 키 유형이 클라이언트 인증 방법에 적합한지 확인합니다.

---
### **5.7.  Client Key Exchange**

이 메시지가 전송될 때:

이 메시지는 모든 키 교환 알고리즘에서 전송됩니다. ECDSA\_fixed\_ECDH 또는 RSA\_fixed\_ECDH를 사용한 클라이언트 인증이 사용되는 경우 이 메시지는 비어 있습니다. 그렇지 않으면 클라이언트의 임시 ECDH 공개 키가 포함됩니다.

메시지의 의미:

이 메시지는 클라이언트에 속한 키 교환과 관련된 임시 데이터\(예: 임시 ECDH 공개 키\)를 전달하는 데 사용됩니다.

이 메시지의 구조:

TLS ClientKeyExchange 메시지는 다음과 같이 확장됩니다.

```text
        enum { implicit, explicit } PublicValueEncoding;
```

암시적, 명시적: ECC 암호화 제품군의 경우 클라이언트의 ECDH 공개 키가 클라이언트의 인증서에 있는지\("암시적"\) 또는 ClientKeyExchange 메시지에서 임시 ECDH 공개 키로 제공되는지\("명시적"\)를 나타냅니다. \(클라이언트가 ECDSA\_fixed\_ECDH 또는 RSA\_fixed\_ECDH 클라이언트 인증 메커니즘을 사용하는 경우를 제외하고 이는 ECC 암호화 제품군에서 "명시적"입니다.\)

```text
        struct {
            select (PublicValueEncoding) {
                case implicit: struct { };
                case explicit: ECPoint ecdh_Yc;
            } ecdh_public;
        } ClientECDiffieHellmanPublic;
```

ecdh\_Yc: 클라이언트의 임시 ECDH 공개 키를 비압축 또는 압축 형식의 타원 곡선 점을 나타낼 수 있는 바이트 문자열 ECPoint.point로 포함합니다. 여기서 형식은 이 확장이 사용된 경우 지원되는 포인트 형식 확장을 통해 서버가 요청한 내용을 준수해야 하며 이 확장이 사용되지 않은 경우 압축을 해제해야 합니다\(MUST\).\(MUST\)

```text
        struct {
            select (KeyExchangeAlgorithm) {
                case ec_diffie_hellman: ClientECDiffieHellmanPublic;
            } exchange_keys;
        } ClientKeyExchange;
```

발신자의 조치:

클라이언트는 IEEE 1363\[6\]의 ECKAS-DH1 체계에 따라 서버로부터 받은 매개변수에 해당하는 임시 ECDH 공개 키를 선택합니다. 위에서 정의한 형식을 사용하여 ClientKeyExchange 메시지에서 이 정보를 클라이언트에 전달합니다.

수신자의 조치:

서버는 ClientKeyExchange 메시지에서 클라이언트의 임시 ECDH 공개 키를 검색하고 서버의 ECDH 키와 동일한 타원 곡선에 있는지 확인합니다.

---
### **5.8.  Certificate Verify**

이 메시지가 전송될 때:

이 메시지는 클라이언트가 디지털 서명에 사용할 수 있는 공개 키가 포함된 클라이언트 인증서를 보낼 때\(예: 클라이언트가 ECDSA\_sign 메커니즘을 사용하여 인증될 때\) 전송됩니다.

메시지의 의미:

이 메시지에는 클라이언트 인증서 메시지의 공개 키에 해당하는 개인 키의 소유를 증명하는 서명이 포함되어 있습니다.

이 메시지의 구조:

TLS CertificateVerify 메시지와 기본 서명 유형은 \[2\] 및 \[3\]에 정의되어 있으며 후자는 섹션 5.4에서 확장됩니다. ecdsa의 경우 CertificateVerify 메시지의 서명 필드에는 지금까지 교환된 핸드셰이크 메시지를 통해 계산된 ECDSA 서명이 포함되어 있으며 \[2\] 및 \[3\]의 다른 서명 알고리즘을 사용하는 CertificateVerify와 정확히 유사합니다.

```text
        CertificateVerify.signature.sha_hash
            SHA(handshake_messages);
```

ECDSA 서명은 섹션 5.10에 설명된 대로 계산되며 sha\_hash에 대한 위 템플릿의 SHA는 그에 따라 SHA-1 이외의 해시 알고리즘을 나타낼 수 있습니다. ANSI X9.62에 따라 ECDSA 서명은 정수 쌍 r과 s로 구성됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며, 그 내용은 다음 ASN.1 표기법\[8\]에 해당하는 DER 인코딩\[9\]입니다.

```text
        Ecdsa-Sig-Value ::= SEQUENCE {
            r       INTEGER,
            s       INTEGER
        }
```

발신자의 조치:

클라이언트는 client hello에서 시작하여 이 메시지를 포함하지 않고 전송되거나 수신된 모든 핸드셰이크 메시지에 대한 서명을 계산합니다. 위에서 정의한 형식으로 전달되는 서명을 계산하기 위해 인증된 공개 키에 해당하는 개인 키를 사용합니다.

수신자의 조치:

서버는 CertificateVerify 메시지에서 클라이언트의 서명을 추출하고 클라이언트의 인증서 메시지에서 받은 공개 키를 사용하여 서명을 확인합니다.

---
### **5.9.  Elliptic Curve Certificates**

ECC 공개 키를 포함하거나 ECDSA를 사용하여 서명된 X.509 인증서는 \[14\] 또는 이를 대체하거나 확장하는 다른 RFC를 준수해야 합니다. 클라이언트는 ANSI X9.62\[7\], FIPS 186-2\[11\] 및 SEC 2\[13\]에서 권장하는 타원 곡선 도메인 매개변수를 사용해야 합니다.\(MUST, SHOULD\)

---
### **5.10.  ECDH, ECDSA, and RSA Computations**

모든 ECDH 계산\(파라미터 및 키 생성 및 공유 비밀 계산 포함\)은 ID 맵을 키 파생 함수\(KDF\)로 사용하여 ECKAS-DH1 체계를 사용하여 \[6\]에 따라 수행되므로 사전 마스터 비밀은 x -옥텟 문자열로 표현되는 ECDH 공유 비밀 타원 곡선 점의 좌표. 옥텟 문자열 변환 프리미티브에 대한 필드 요소인 FE2OSP에 의해 출력되는 이 옥텟 문자열\(IEEE 1363 용어의 Z\)은 주어진 필드에 대해 일정한 길이를 가집니다. 이 옥텟 문자열에서 발견된 선행 0은 절단되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

\(ID KDF의 이러한 사용은 기술적인 문제라는 점에 유의하십시오. 전체 그림은 TLS가 마스터 비밀을 계산하는 것 이외의 용도로 사전 마스터 비밀을 직접 사용하지 않기 때문에 ECDH가 중요한 KDF와 함께 사용된다는 것입니다. TLS 1.0부터 \[2\] 및 1.1 \[3\], 이는 MD5 및 SHA-1 기반 TLS PRF가 KDF 역할을 함을 의미하며 향후 TLS 버전 또는 향후 도입되는 새로운 TLS 확장이 이 계산을 변경할 수 있음을 생각할 수 있습니다.\)

모든 ECDSA 계산은 ANSI X9.62\[7\] 또는 그 후속 항목에 따라 수행되어야 합니다. 서명/검증할 데이터는 해싱되며 결과는 추가 해싱 없이 ECDSA 알고리즘을 통해 직접 실행됩니다. 기본 해시 함수는 SHA-1\[10\]이고 sha\_size\(섹션 5.4 및 5.8 참조\)는 20입니다. 그러나 FIPS 180-2\[10\]에 지정된 새로운 SHA 해시 함수 중 하나와 같은 대체 해시 함수는 EC 공개를 포함하는 인증서가 있는 경우 대신 사용할 수 있습니다.\(MUST\)

키는 명시적으로 다른 해시 함수를 사용해야 합니다. \(필요한 해시 함수를 지정하는 메커니즘은 표준화되지 않았지만 이 조항은 그러한 표준화를 예상하고 응답으로 이 문서를 업데이트할 필요성을 제거합니다. 예를 들어 향후 PKIX RFC는 해시 함수를 지정하도록 선택할 수 있습니다. subjectPublicKeyInfo의 매개 변수 필드에 있는 공개 키입니다.\)

모든 RSA 서명은 PKCS#1 \[12\] 블록 유형 1에 따라 생성되고 검증되어야 합니다.

---
## **6.  Cipher Suites**

아래 표는 섹션 2에 지정된 키 교환 알고리즘을 사용하는 새로운 ECC 암호화 제품군을 정의합니다.

```text
     CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA           = { 0xC0, 0x01 }
     CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA        = { 0xC0, 0x02 }
     CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA   = { 0xC0, 0x03 }
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA    = { 0xC0, 0x04 }
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA    = { 0xC0, 0x05 }

     CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA          = { 0xC0, 0x06 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA       = { 0xC0, 0x07 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA  = { 0xC0, 0x08 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA   = { 0xC0, 0x09 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA   = { 0xC0, 0x0A }

     CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA             = { 0xC0, 0x0B }
     CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA          = { 0xC0, 0x0C }
     CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA     = { 0xC0, 0x0D }
     CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA      = { 0xC0, 0x0E }
     CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA      = { 0xC0, 0x0F }

     CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA            = { 0xC0, 0x10 }
     CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA         = { 0xC0, 0x11 }
     CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA    = { 0xC0, 0x12 }
     CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA     = { 0xC0, 0x13 }
     CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA     = { 0xC0, 0x14 }

     CipherSuite TLS_ECDH_anon_WITH_NULL_SHA            = { 0xC0, 0x15 }
     CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA         = { 0xC0, 0x16 }
     CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA    = { 0xC0, 0x17 }
     CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA     = { 0xC0, 0x18 }
     CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA     = { 0xC0, 0x19 }

                        Table 5: TLS ECC cipher suites
```

키 교환 방법, 암호 및 이러한 각 암호 제품군에 대한 해시 알고리즘은 이름을 검사하여 쉽게 결정됩니다. 암호\(AES 암호 이외\) 및 해시 알고리즘은 \[2\] 및 \[3\]에 정의되어 있습니다. AES 암호는 \[19\]에 정의되어 있습니다.

서버 구현은 다음 암호 그룹을 모두 지원해야 하며 클라이언트 구현은 다음 중 하나 이상을 지원해야 합니다. \_AES\_128\_CBC\_SHA.\(SHOULD\)

---
## **7.  Security Considerations**

보안 문제는 이 메모 전체에서 논의됩니다.

ECC 암호화 제품군을 사용하는 TLS 핸드셰이크의 경우 \[2\] 및 \[3\]의 부록 D.2 및 D.3에 있는 보안 고려 사항이 그에 따라 적용됩니다.

ECC와 관련된 보안 논의는 \[6\] 및 \[7\]에서 찾을 수 있습니다. 구현자와 사용자가 고려해야 하는 한 가지 중요한 문제는 타원 곡선 선택입니다. 적절한 타원 곡선 크기 선택에 대한 지침은 표 1에 나와 있습니다.

타원곡선의 크기 외에 주요 이슈는 타원곡선 구조이다. 일반적으로 가능한 대수 구조가 적은 타원 곡선을 사용하는 것이 더 보수적입니다. 따라서 랜덤 곡선은 Koblitz 곡선과 같은 특수 곡선보다 더 보수적이며, p 랜덤을 갖는 F\_p에 대한 곡선은 특수한 형태의 p를 갖는 F\_p에 대한 곡선보다 더 보수적입니다\(그리고 p 랜덤을 갖는 F\_p에 대한 곡선은 곡선보다 더 보수적인 것으로 간주될 수 있습니다. 특성 2\)에 대해 유사한 크기의 여러 필드 간에 선택이 없으므로 F\_2^m보다 큽니다. 그러나 대수적 구조는 구현 효율성으로 이어질 수도 있으므로 구현자와 사용자는 효율성 요구와 보수주의 사이에서 균형을 맞춰야 할 수 있습니다. 구체적인 공격은 초특이 곡선과 같은 극소수의 특수 곡선 클래스에 대해서만 알려져 있으며 이러한 클래스는 이 문서에서 참조하는 ECC 표준에서 제외됩니다\[6\], \[7\].

또 다른 문제는 단일 타원 곡선이 널리 사용될 때 치명적인 오류가 발생할 가능성입니다. 이 경우 타원 곡선에 대한 공격으로 인해 많은 수의 키가 손상될 수 있습니다. 다시 말하지만, 이 문제는 널리 사용되는 곡선과 관련된 효율성 및 상호 운용성 개선과 균형을 이루어야 할 수 있습니다. 타원 곡선 선택에 대한 실질적인 추가 정보는 \[5\], \[6\], \[7\] 및 \[11\]에서 찾을 수 있습니다.

구현자와 사용자는 순방향 보안이 필요한지 여부도 고려해야 합니다. Forward secrecy는 서버와 클라이언트에 속한 정적 인증 키가 손상된 경우 세션 키가 손상되지 않는 속성을 나타냅니다. ECDHE\_ECDSA 및 ECDHE\_RSA 키 교환 알고리즘은 서버 키 손상 시 전방 보안 보호를 제공하지만 ECDH\_ECDSA 및 ECDH\_RSA는 그렇지 않습니다. 마찬가지로 클라이언트가 인증된 정적 키를 제공하는 경우 ECDSA\_sign 클라이언트 인증은 클라이언트 키 손상 시 전방 보안 보호를 제공하지만 ECDSA\_fixed\_ECDH 및 RSA\_fixed\_ECDH는 그렇지 않습니다. 따라서 완전한 순방향 보안 보호를 얻으려면 키 교환에 ECDHE\_ECDSA 또는 ECDHE\_RSA를 사용해야 하며 필요한 경우 클라이언트 인증에 ECDSA\_sign을 사용해야 합니다. 여기에서 순방향 보안의 보안 이점은 다른 옵션이 제공하는 향상된 효율성과 균형을 이루어야 할 수 있습니다.

---
## **8.  IANA Considerations**

이 문서에서는 TLS 프로토콜과 함께 사용할 세 가지 새로운 이름 공간에 대해 설명합니다.

```text
   o  NamedCurve (Section 5.1)

   o  ECPointFormat (Section 5.1)

   o  ECCurveType (Section 5.4)
```

각 네임스페이스에 대해 이 문서는 초기 값 할당을 정의하고 개인용으로 예약된 256개 값\(NamedCurve\) 또는 8개 값\(ECPointFormat 및 ECCurveType\) 범위를 정의합니다. 추가 할당에는 IETF 합의 조치가 필요합니다\[16\].

---
## **9.  Acknowledgements**

저자는 Bill Anderson과 Tim Dierks에게 감사를 표합니다.

---
## **10.  References**
---
### **10.1.  Normative References**

\[1\] Bradner, S., "요구 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", RFC 2119, 1997년 3월.

\[2\] Dierks, T. 및 C. Allen, "TLS 프로토콜 버전 1.0", RFC 2246, 1999년 1월.

\[3\] Dierks, T. 및 E. Rescorla, "TLS\(전송 계층 보안\) 프로토콜 버전 1.1", RFC 4346, 2006년 4월.

\[4\] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J. 및 T. Wright, "TLS\(전송 계층 보안\) 확장", RFC 4366, 2006년 4월.

```text
   [5]   SECG, "Elliptic Curve Cryptography", SEC 1, 2000,
         <http://www.secg.org/>.
```

\[6\] IEEE, "공개 키 암호화에 대한 표준 사양", IEEE 1363, 2000.

\[7\] ANSI, "금융 서비스 산업을 위한 공개 키 암호화: 타원 곡선 디지털 서명 알고리즘\(ECDSA\)", ANSI X9.62, 1998.

\[8\] 국제 전기 통신 연합, "정보 기술 - ASN.1\(Abstract Syntax Notation One\): 기본 표기법 사양", ITU-T Recommendation X.680, 2002.

\[9\] International Telecommunication Union, "정보 기술 - ASN.1 인코딩 규칙: BER\(Basic Encoding Rules\) 사양, CER\(Canonical Encoding Rules\) 및 DER\(Distinguished Encoding Rules\)", ITU-T Recommendation X.690, 2002 .

```text
   [10]  NIST, "Secure Hash Standard", FIPS 180-2, 2002.

   [11]  NIST, "Digital Signature Standard", FIPS 186-2, 2000.

   [12]  RSA Laboratories, "PKCS#1: RSA Encryption Standard version
         1.5", PKCS 1, November 1993.

   [13]  SECG, "Recommended Elliptic Curve Domain Parameters", SEC 2,
         2000, <http://www.secg.org/>.
```

\[14\] Polk, T., Housley, R. 및 L. Bassham, "알고리즘 및

- 인터넷 X.509 공개 키 기반 구조 인증서 및 CRL\(Certificate Revocation List\) 프로필에 대한 식별자", RFC 3279, 2002년 4월.

\[15\] Housley, R., Polk, T., Ford, W. 및 D. Solo, "Internet X.509 공개 키 인프라 인증서 및 CRL\(Certificate Revocation List\) 프로필", RFC 3280, 2002년 4월.

\[16\] Narten, T. 및 H. Alvestrand, "RFC에서 IANA 고려 사항 섹션을 작성하기 위한 지침", RFC 2434, 1998년 10월.

---
### **10.2.  Informative References**

\[17\] Harper, G., Menezes, A. 및 S. Vanstone, "공개 키

- Cryptosystems with Very Small Key Lengths", Advances in Cryptology -- EUROCRYPT '92, LNCS 658, 1993.

```text
   [18]  Lenstra, A. and E. Verheul, "Selecting Cryptographic Key
         Sizes", Journal of Cryptology 14 (2001) 255-293,
         <http://www.cryptosavvy.com/>.
```

\[19\] Chown, P., "TLS\(Transport Layer Security\)를 위한 AES\(Advanced Encryption Standard\) Ciphersuites", RFC 3268, 2002년 6월.

---
# **Appendix A.  Equivalent Curves (Informative)**

모든 NIST 곡선\[11\]과 여러 ANSI 곡선\[7\]은 섹션 5.1.1에 나열된 곡선과 동일합니다. 다음 표에서 한 행의 여러 이름은 동일한 곡선의 별칭을 나타냅니다.

```text
             ------------------------------------------
                       Curve names chosen by
                  different standards organizations
             ------------+---------------+-------------
             SECG        |  ANSI X9.62   |  NIST
             ------------+---------------+-------------
             sect163k1   |               |   NIST K-163
             sect163r1   |               |
             sect163r2   |               |   NIST B-163
             sect193r1   |               |
             sect193r2   |               |
             sect233k1   |               |   NIST K-233
             sect233r1   |               |   NIST B-233
             sect239k1   |               |
             sect283k1   |               |   NIST K-283
             sect283r1   |               |   NIST B-283
             sect409k1   |               |   NIST K-409
             sect409r1   |               |   NIST B-409
             sect571k1   |               |   NIST K-571
             sect571r1   |               |   NIST B-571
             secp160k1   |               |
             secp160r1   |               |
             secp160r2   |               |
             secp192k1   |               |
             secp192r1   |  prime192v1   |   NIST P-192
             secp224k1   |               |
             secp224r1   |               |   NIST P-224
             secp256k1   |               |
             secp256r1   |  prime256v1   |   NIST P-256
             secp384r1   |               |   NIST P-384
             secp521r1   |               |   NIST P-521
             ------------+---------------+-------------
```

- 표 6: SECG, ANSI 및 NIST에서 정의한 등가 곡선

---
# **Authors' Addresses**

```text
   Simon Blake-Wilson
   SafeNet Technologies BV
   Amstelveenseweg 88-90
   1075 XJ, Amsterdam
   NL

   Phone: +31 653 899 836
   EMail: sblakewilson@safenet-inc.com

   Nelson Bolyard
   Sun Microsystems Inc.
   4170 Network Circle
   MS SCA17-201
   Santa Clara, CA  95054
   US

   Phone: +1 408 930 1443
   EMail: nelson@bolyard.com

   Vipul Gupta
   Sun Microsystems Laboratories
   16 Network Circle
   MS UMPK16-160
   Menlo Park, CA  94025
   US

   Phone: +1 650 786 7551
   EMail: vipul.gupta@sun.com

   Chris Hawk
   Corriente Networks LLC
   1563 Solano Ave., #484
   Berkeley, CA  94707
   US

   Phone: +1 510 527 0601
   EMail: chris@corriente.net

   Bodo Moeller
   Ruhr-Uni Bochum
   Horst-Goertz-Institut, Lehrstuhl fuer Kommunikationssicherheit
   IC 4/139
   44780 Bochum
   DE

   Phone: +49 234 32 26795
   EMail: bodo@openssl.org
```

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(2006\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회 및 인터넷 공학 태스크포스는 모든 명시적 또는 묵시적 보증을 부인합니다. 여기에서 구성은 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않습니다.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 IETF 행정 지원 활동\(IASA\)에서 제공합니다.


```text
Internet Engineering Task Force (IETF)                         Z. Shelby
Request for Comments: 7252                                           ARM
Category: Standards Track                                      K. Hartke
ISSN: 2070-1721                                               C. Bormann
                                                 Universitaet Bremen TZI
                                                               June 2014
```

- 제한된 애플리케이션 프로토콜\(CoAP\)

---
# **Abstract**

CoAP\(Constrained Application Protocol\)는 제한된 노드 및 제한된\(예: 저전력, 손실이 있는\) 네트워크에 사용하기 위한 특수 웹 전송 프로토콜입니다. 노드에는 소량의 ROM과 RAM을 갖춘 8비트 마이크로 컨트롤러가 있는 경우가 많지만, 6LoWPAN\(저전력 무선 개인 영역 네트워크\)을 통한 IPv6와 같은 제한된 네트워크는 종종 높은 패킷 오류율과 10kbit/s의 일반적인 처리량을 갖습니다. 이 프로토콜은 스마트 에너지 및 빌딩 자동화와 같은 M2M\(Machine-to-Machine\) 애플리케이션을 위해 설계되었습니다.

CoAP는 애플리케이션 엔드포인트 간의 요청/응답 상호 작용 모델을 제공하고, 기본 제공 서비스 및 리소스 검색을 지원하며, URI 및 인터넷 미디어 유형과 같은 웹의 주요 개념을 포함합니다. CoAP는 멀티캐스트 지원, 매우 낮은 오버헤드, 제한된 환경에 대한 단순성과 같은 특수한 요구 사항을 충족하면서 웹과의 통합을 위해 HTTP와 쉽게 인터페이스하도록 설계되었습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7252에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2014 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   5
     1.1.  Features  . . . . . . . . . . . . . . . . . . . . . . . .   5
     1.2.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   6
   2.  Constrained Application Protocol  . . . . . . . . . . . . . .  10
     2.1.  Messaging Model . . . . . . . . . . . . . . . . . . . . .  11
     2.2.  Request/Response Model  . . . . . . . . . . . . . . . . .  12
     2.3.  Intermediaries and Caching  . . . . . . . . . . . . . . .  15
     2.4.  Resource Discovery  . . . . . . . . . . . . . . . . . . .  15
   3.  Message Format  . . . . . . . . . . . . . . . . . . . . . . .  15
     3.1.  Option Format . . . . . . . . . . . . . . . . . . . . . .  17
     3.2.  Option Value Formats  . . . . . . . . . . . . . . . . . .  19
   4.  Message Transmission  . . . . . . . . . . . . . . . . . . . .  20
     4.1.  Messages and Endpoints  . . . . . . . . . . . . . . . . .  20
     4.2.  Messages Transmitted Reliably . . . . . . . . . . . . . .  21
     4.3.  Messages Transmitted without Reliability  . . . . . . . .  23
     4.4.  Message Correlation . . . . . . . . . . . . . . . . . . .  24
     4.5.  Message Deduplication . . . . . . . . . . . . . . . . . .  24
     4.6.  Message Size  . . . . . . . . . . . . . . . . . . . . . .  25
     4.7.  Congestion Control  . . . . . . . . . . . . . . . . . . .  26
     4.8.  Transmission Parameters . . . . . . . . . . . . . . . . .  27
       4.8.1.  Changing the Parameters . . . . . . . . . . . . . . .  27
       4.8.2.  Time Values Derived from Transmission Parameters  . .  28
   5.  Request/Response Semantics  . . . . . . . . . . . . . . . . .  31
     5.1.  Requests  . . . . . . . . . . . . . . . . . . . . . . . .  31
     5.2.  Responses . . . . . . . . . . . . . . . . . . . . . . . .  31
       5.2.1.  Piggybacked . . . . . . . . . . . . . . . . . . . . .  33
       5.2.2.  Separate  . . . . . . . . . . . . . . . . . . . . . .  33
       5.2.3.  Non-confirmable . . . . . . . . . . . . . . . . . . .  34
     5.3.  Request/Response Matching . . . . . . . . . . . . . . . .  34
       5.3.1.  Token . . . . . . . . . . . . . . . . . . . . . . . .  34
       5.3.2.  Request/Response Matching Rules . . . . . . . . . . .  35
     5.4.  Options . . . . . . . . . . . . . . . . . . . . . . . . .  36
       5.4.1.  Critical/Elective . . . . . . . . . . . . . . . . . .  37
       5.4.2.  Proxy Unsafe or Safe-to-Forward and NoCacheKey  . . .  38
       5.4.3.  Length  . . . . . . . . . . . . . . . . . . . . . . .  38
       5.4.4.  Default Values  . . . . . . . . . . . . . . . . . . .  38
       5.4.5.  Repeatable Options  . . . . . . . . . . . . . . . . .  39
       5.4.6.  Option Numbers  . . . . . . . . . . . . . . . . . . .  39
     5.5.  Payloads and Representations  . . . . . . . . . . . . . .  40
       5.5.1.  Representation  . . . . . . . . . . . . . . . . . . .  40
       5.5.2.  Diagnostic Payload  . . . . . . . . . . . . . . . . .  41
       5.5.3.  Selected Representation . . . . . . . . . . . . . . .  41
       5.5.4.  Content Negotiation . . . . . . . . . . . . . . . . .  41
     5.6.  Caching . . . . . . . . . . . . . . . . . . . . . . . . .  42
       5.6.1.  Freshness Model . . . . . . . . . . . . . . . . . . .  43
       5.6.2.  Validation Model  . . . . . . . . . . . . . . . . . .  43
     5.7.  Proxying  . . . . . . . . . . . . . . . . . . . . . . . .  44
       5.7.1.  Proxy Operation . . . . . . . . . . . . . . . . . . .  44
       5.7.2.  Forward-Proxies . . . . . . . . . . . . . . . . . . .  46
       5.7.3.  Reverse-Proxies . . . . . . . . . . . . . . . . . . .  46
     5.8.  Method Definitions  . . . . . . . . . . . . . . . . . . .  47
       5.8.1.  GET . . . . . . . . . . . . . . . . . . . . . . . . .  47
       5.8.2.  POST  . . . . . . . . . . . . . . . . . . . . . . . .  47
       5.8.3.  PUT . . . . . . . . . . . . . . . . . . . . . . . . .  48
       5.8.4.  DELETE  . . . . . . . . . . . . . . . . . . . . . . .  48
     5.9.  Response Code Definitions . . . . . . . . . . . . . . . .  48
       5.9.1.  Success 2.xx  . . . . . . . . . . . . . . . . . . . .  48
       5.9.2.  Client Error 4.xx . . . . . . . . . . . . . . . . . .  50
       5.9.3.  Server Error 5.xx . . . . . . . . . . . . . . . . . .  51
     5.10. Option Definitions  . . . . . . . . . . . . . . . . . . .  52
       5.10.1.  Uri-Host, Uri-Port, Uri-Path, and Uri-Query  . . . .  53
       5.10.2.  Proxy-Uri and Proxy-Scheme . . . . . . . . . . . . .  54
       5.10.3.  Content-Format . . . . . . . . . . . . . . . . . . .  55
       5.10.4.  Accept . . . . . . . . . . . . . . . . . . . . . . .  55
       5.10.5.  Max-Age  . . . . . . . . . . . . . . . . . . . . . .  55
       5.10.6.  ETag . . . . . . . . . . . . . . . . . . . . . . . .  56
       5.10.7.  Location-Path and Location-Query . . . . . . . . . .  57
       5.10.8.  Conditional Request Options  . . . . . . . . . . . .  57
       5.10.9.  Size1 Option . . . . . . . . . . . . . . . . . . . .  59
   6.  CoAP URIs . . . . . . . . . . . . . . . . . . . . . . . . . .  59
     6.1.  coap URI Scheme . . . . . . . . . . . . . . . . . . . . .  59
     6.2.  coaps URI Scheme  . . . . . . . . . . . . . . . . . . . .  60
     6.3.  Normalization and Comparison Rules  . . . . . . . . . . .  61
     6.4.  Decomposing URIs into Options . . . . . . . . . . . . . .  61
     6.5.  Composing URIs from Options . . . . . . . . . . . . . . .  62
   7.  Discovery . . . . . . . . . . . . . . . . . . . . . . . . . .  64
     7.1.  Service Discovery . . . . . . . . . . . . . . . . . . . .  64
     7.2.  Resource Discovery  . . . . . . . . . . . . . . . . . . .  64
       7.2.1.  'ct' Attribute  . . . . . . . . . . . . . . . . . . .  64
   8.  Multicast CoAP  . . . . . . . . . . . . . . . . . . . . . . .  65
     8.1.  Messaging Layer . . . . . . . . . . . . . . . . . . . . .  65
     8.2.  Request/Response Layer  . . . . . . . . . . . . . . . . .  66
       8.2.1.  Caching . . . . . . . . . . . . . . . . . . . . . . .  67
       8.2.2.  Proxying  . . . . . . . . . . . . . . . . . . . . . .  67
   9.  Securing CoAP . . . . . . . . . . . . . . . . . . . . . . . .  68
     9.1.  DTLS-Secured CoAP . . . . . . . . . . . . . . . . . . . .  69
       9.1.1.  Messaging Layer . . . . . . . . . . . . . . . . . . .  70
       9.1.2.  Request/Response Layer  . . . . . . . . . . . . . . .  71
       9.1.3.  Endpoint Identity . . . . . . . . . . . . . . . . . .  71
   10. Cross-Protocol Proxying between CoAP and HTTP . . . . . . . .  74
     10.1.  CoAP-HTTP Proxying . . . . . . . . . . . . . . . . . . .  75
       10.1.1.  GET  . . . . . . . . . . . . . . . . . . . . . . . .  76
       10.1.2.  PUT  . . . . . . . . . . . . . . . . . . . . . . . .  77
       10.1.3.  DELETE . . . . . . . . . . . . . . . . . . . . . . .  77
       10.1.4.  POST . . . . . . . . . . . . . . . . . . . . . . . .  77
     10.2.  HTTP-CoAP Proxying . . . . . . . . . . . . . . . . . . .  77
       10.2.1.  OPTIONS and TRACE  . . . . . . . . . . . . . . . . .  78
       10.2.2.  GET  . . . . . . . . . . . . . . . . . . . . . . . .  78
       10.2.3.  HEAD . . . . . . . . . . . . . . . . . . . . . . . .  79
       10.2.4.  POST . . . . . . . . . . . . . . . . . . . . . . . .  79
       10.2.5.  PUT  . . . . . . . . . . . . . . . . . . . . . . . .  79
       10.2.6.  DELETE . . . . . . . . . . . . . . . . . . . . . . .  80
       10.2.7.  CONNECT  . . . . . . . . . . . . . . . . . . . . . .  80
   11. Security Considerations . . . . . . . . . . . . . . . . . . .  80
     11.1.  Parsing the Protocol and Processing URIs . . . . . . . .  80
     11.2.  Proxying and Caching . . . . . . . . . . . . . . . . . .  81
     11.3.  Risk of Amplification  . . . . . . . . . . . . . . . . .  81
     11.4.  IP Address Spoofing Attacks  . . . . . . . . . . . . . .  83
     11.5.  Cross-Protocol Attacks . . . . . . . . . . . . . . . . .  84
     11.6.  Constrained-Node Considerations  . . . . . . . . . . . .  86
   12. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  86
     12.1.  CoAP Code Registries . . . . . . . . . . . . . . . . . .  86
       12.1.1.  Method Codes . . . . . . . . . . . . . . . . . . . .  87
       12.1.2.  Response Codes . . . . . . . . . . . . . . . . . . .  88
     12.2.  CoAP Option Numbers Registry . . . . . . . . . . . . . .  89
     12.3.  CoAP Content-Formats Registry  . . . . . . . . . . . . .  91
     12.4.  URI Scheme Registration  . . . . . . . . . . . . . . . .  93
     12.5.  Secure URI Scheme Registration . . . . . . . . . . . . .  94
     12.6.  Service Name and Port Number Registration  . . . . . . .  95
     12.7.  Secure Service Name and Port Number Registration . . . .  96
     12.8.  Multicast Address Registration . . . . . . . . . . . . .  97
   13. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  97
   14. References  . . . . . . . . . . . . . . . . . . . . . . . . .  98
     14.1.  Normative References . . . . . . . . . . . . . . . . . .  98
     14.2.  Informative References . . . . . . . . . . . . . . . . . 100
   Appendix A.  Examples . . . . . . . . . . . . . . . . . . . . . . 104
   Appendix B.  URI Examples . . . . . . . . . . . . . . . . . . . . 110
```

---
## **1.  Introduction**

인터넷에서 웹 서비스\(웹 API\)의 사용은 대부분의 애플리케이션에서 보편적으로 사용되며 웹의 기본 REST\(Representational State Transfer\) 아키텍처에 따라 달라집니다.

CoRE\(Constrained RESTful Environments\)에 대한 작업은 가장 제한된 노드\(예: RAM 및 ROM이 제한된 8비트 마이크로 컨트롤러\) 및 네트워크\(예: 6LoWPAN, \[RFC4944\]\)에 적합한 형식으로 REST 아키텍처를 실현하는 것을 목표로 합니다. 6LoWPAN과 같은 제한된 네트워크는 IPv6 패킷을 작은 링크 계층 프레임으로 조각화하는 것을 지원합니다. 그러나 이는 패킷 전달 확률을 크게 감소시킵니다. CoAP의 설계 목표 중 하나는 메시지 오버헤드를 작게 유지하여 조각화의 필요성을 제한하는 것이었습니다.

CoAP의 주요 목표 중 하나는 특히 에너지, 빌딩 자동화 및 기타 M2M\(Machine-to-Machine\) 애플리케이션을 고려하여 제한된 환경의 특별한 요구 사항에 맞는 일반 웹 프로토콜을 설계하는 것입니다. CoAP의 목표는 HTTP \[RFC2616\]를 맹목적으로 압축하는 것이 아니라 HTTP와 공통이지만 M2M 애플리케이션에 최적화된 REST의 하위 집합을 실현하는 것입니다. CoAP는 간단한 HTTP 인터페이스를 보다 컴팩트한 프로토콜로 재구성하는 데 사용될 수 있지만 더 중요한 것은 내장된 검색, 멀티캐스트 지원, 비동기 메시지 교환과 같은 M2M 기능도 제공한다는 것입니다.

이 문서에서는 기존 웹과의 통합을 위해 HTTP로 쉽게 변환하는 동시에 멀티캐스트 지원, 매우 낮은 오버헤드, 제한된 환경 및 M2M 애플리케이션에 대한 단순성과 같은 특수 요구 사항을 충족하는 CoAP\(Constrained Application Protocol\)를 지정합니다.

---
### **1.1.  Features**

CoAP의 주요 기능은 다음과 같습니다.

- 제한된 환경에서 M2M 요구 사항을 충족하는 웹 프로토콜

- 유니캐스트 및 멀티캐스트 요청을 지원하는 선택적인 신뢰성을 갖춘 UDP \[RFC0768\] 바인딩.

```text
   o  Asynchronous message exchanges.
```

- 헤더 오버헤드가 낮고 구문 분석이 복잡합니다.

- URI 및 콘텐츠 유형 지원.

- 간단한 프록시 및 캐싱 기능.

- 상태 비저장 HTTP 매핑을 통해 HTTP를 통해 CoAP 리소스에 대한 액세스를 균일한 방식으로 제공하거나 HTTP 단순 인터페이스가 CoAP를 통해 대안적으로 실현되도록 하는 프록시를 구축할 수 있습니다.

- 데이터그램 전송 계층 보안\(DTLS\) \[RFC6347\]에 대한 보안 바인딩.

---
### **1.2.  Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 모두 대문자로 나타날 때 \[RFC2119\]에 설명된 대로 해석됩니다. 이러한 단어는 규범적인 의미 없이 이 문서에 소문자로 나타날 수도 있습니다.

이 사양에서는 독자가 "리소스", "표현", "캐시" 및 "신선한"을 포함하여 \[RFC2616\]에서 논의된 모든 용어와 개념에 익숙해야 합니다. \(업데이트된 HTTP RFC 세트인 RFC 7230에서 RFC 7235까지가 사용 가능해지기 전에 완료되었으며, 이 사양은 특히 이전 버전인 RFC 2616을 참조합니다.\) 또한 이 사양에서는 다음 용어를 정의합니다.

엔드포인트 - CoAP 프로토콜에 참여하는 엔터티입니다. 구어적으로 엔드포인트는 "노드"에 존재하지만 "호스트"는 인터넷 표준 사용과 더 일치하며 UDP 포트 번호와 보안 연결을 포함할 수 있는 전송 계층 다중화 정보로 추가로 식별됩니다\(섹션 4.1\).

보낸 사람 - 메시지의 원래 끝점입니다. 특정 발신자의 식별 측면에 초점이 맞춰지면 "소스 엔드포인트"도 있습니다.

수신자 - 메시지의 대상 엔드포인트입니다. 특정 수신자의 식별 측면에 초점이 맞춰지면 "대상 엔드포인트"도 있습니다.

클라이언트 - 요청의 원래 끝점입니다. 응답의 대상 엔드포인트.

서버 - 요청의 대상 엔드포인트입니다. 응답의 원래 끝점.

원본 서버 - 특정 리소스가 상주하거나 생성될 서버입니다.

중개자 - 원본 서버에 대한 서버 및 클라이언트 역할을 모두 수행하는 CoAP 엔드포인트입니다\(추가 중개자를 통해 가능\). 중개자의 일반적인 형태는 프록시입니다. 이러한 프록시의 여러 클래스가 이 사양에서 논의됩니다.

프록시\(Proxy\) - 주로 요청을 전달하고 응답을 다시 전달하는 데 관여하며 프로세스에서 캐싱, 네임스페이스 변환 또는 프로토콜 변환을 수행하는 중개자입니다. 일반적인 의미의 중개자와 달리 프록시는 일반적으로 특정 애플리케이션 의미를 구현하지 않습니다. 요청 전달의 전체 구조에서의 위치에 따라 프록시에는 정방향 프록시와 역방향 프록시라는 두 가지 일반적인 형태가 있습니다. 어떤 경우에는 단일 엔드포인트가 원본 서버, 정방향 프록시 또는 역방향 프록시 역할을 하여 각 요청의 특성에 따라 동작을 전환할 수 있습니다.

정방향 프록시 - 클라이언트를 대신하여 요청을 수행하고 필요한 변환을 수행하기 위해 일반적으로 로컬 구성 규칙을 통해 클라이언트가 선택한 엔드포인트입니다. "coap" URI에 대한 프록시 요청과 같은 일부 변환은 최소화되는 반면, 다른 요청은 완전히 다른 애플리케이션 계층 프로토콜과의 변환이 필요할 수 있습니다.

역방향 프록시 - 하나 이상의 다른 서버를 대신하고 이를 대신하여 요청을 충족하여 필요한 변환을 수행하는 엔드포인트입니다. 정방향 프록시와 달리 클라이언트는 역방향 프록시와 통신하고 있다는 사실을 인식하지 못할 수 있습니다. 역방향 프록시는 마치 대상 리소스에 대한 원본 서버인 것처럼 요청을 받습니다.

CoAP-CoAP 프록시 - CoAP 요청을 CoAP 요청으로 매핑하는 프록시입니다. 즉, 서버 측과 클라이언트 측 모두에서 CoAP 프로토콜을 사용합니다. 교차 프록시와 대조됩니다.

교차 프록시 - 교차 프로토콜 프록시 또는 줄여서 "교차 프록시"는 CoAP-HTTP 프록시 또는 HTTP-CoAP 프록시와 같은 다양한 프로토콜 간에 변환하는 프록시입니다. 이 사양은 CoAP-CoAP 프록시에 대해 매우 구체적인 요구 사항을 제시하지만 교차 프록시에는 더 많은 변형이 가능합니다.

확인 가능한 메시지 - 일부 메시지에는 확인이 필요합니다. 이러한 메시지를 "확인 가능"이라고 합니다. 패킷이 손실되지 않으면 각 확인 가능 메시지는 확인 유형 또는 재설정 유형의 반환 메시지를 정확히 하나만 유도합니다.

확인할 수 없는 메시지 - 일부 다른 메시지에는 확인이 필요하지 않습니다. 이는 센서의 반복 판독과 같이 애플리케이션 요구 사항에 대해 정기적으로 반복되는 메시지의 경우 특히 그렇습니다.

승인 메시지 - 승인 메시지는 특정 확인 가능 메시지가 도착했음을 승인합니다. 승인 메시지 자체는 확인 가능 메시지에 캡슐화된 요청의 성공 또는 실패를 나타내지 않지만 승인 메시지는 피기백 응답\(아래 참조\)을 전달할 수도 있습니다.

메시지 재설정 - 재설정 메시지는 특정 메시지\(확인 가능 또는 확인 불가능\)가 수신되었지만 이를 적절하게 처리하기 위한 일부 컨텍스트가 누락되었음을 나타냅니다. 이 조건은 일반적으로 수신 노드가 재부팅되어 메시지를 해석하는 데 필요한 일부 상태를 잊어버린 경우 발생합니다. 재설정 메시지를 유발하는 것\(예: 빈 확인 가능 메시지 전송\)은 엔드포인트의 활성 상태를 저렴하게 확인하는 방법\("CoAP ping"\)으로도 유용합니다.

피기백 응답 - 피기백 응답은 이 응답에 대한 요청 수신을 확인하기 위해 전송되는 CoAP 승인\(ACK\) 메시지에 바로 포함됩니다\(섹션 5.2.1\).

별도의 응답 - 요청을 전달하는 확인 가능 메시지가 빈 메시지로 승인되면\(예: 서버가 즉시 응답을 갖고 있지 않기 때문에\) 별도의 메시지 교환으로 별도의 응답이 전송됩니다\(섹션 5.2.2\).

빈 메시지 - 코드가 0.00인 메시지입니다. 요청도 응답도 아닙니다. 빈 메시지에는 4바이트 헤더만 포함됩니다.

중요 옵션 - 메시지를 적절하게 처리하기 위해 궁극적으로 메시지를 수신하는 엔드포인트에서 이해해야 하는 옵션입니다\(섹션 5.4.1\). 중요 옵션의 구현은 "옵션"이라는 이름에서 알 수 있듯이 일반적으로 선택 사항입니다. 지원되지 않는 중요 옵션은 오류 응답 또는 메시지 요약 거부로 이어집니다.

선택 옵션\(Elective Option\) - 이를 이해하지 못하는 엔드포인트에서 무시하도록 의도된 옵션입니다. 옵션을 이해하지 않고도 메시지를 처리하는 것은 허용됩니다\(섹션 5.4.1\).

안전하지 않은 옵션 - 메시지를 안전하게 전달하기 위해 메시지를 수신하는 프록시가 이해해야 하는 옵션입니다\(섹션 5.4.2\). 모든 중요한 옵션이 안전하지 않은 옵션은 아닙니다.

Safe-to-Forward 옵션 - 이를 이해하지 못하는 프록시에 의한 전달이 안전하도록 고안된 옵션입니다. 옵션을 이해하지 못하더라도 메시지를 전달하는 것은 허용됩니다\(섹션 5.4.2\).

리소스 검색 - CoAP 클라이언트가 서버에 호스팅된 리소스 목록\(즉, 섹션 7에 정의된 링크\)을 쿼리하는 프로세스입니다.

Content-Format - 잠재적으로 특정 매개변수가 제공되는 인터넷 미디어 유형과 "CoAP Content-Formats" 레지스트리에 의해 정의된 숫자 식별자로 식별되는 콘텐츠 코딩\(종종 ID 콘텐츠 코딩\)의 조합입니다. 자원 표현의 이러한 특성의 조합보다 숫자 식별자에 초점이 덜 맞춰진 경우 이를 "표현 형식"이라고도 합니다.

제한된 노드와 제한된 노드 네트워크에 대한 추가 용어는 \[RFC7228\]에서 찾을 수 있습니다.

이 사양에서 "바이트"라는 용어는 현재 관례적인 의미에서 "옥텟"의 동의어로 사용됩니다.

이 프로토콜의 모든 다중 바이트 정수는 네트워크 바이트 순서로 해석됩니다.

산술이 사용되는 경우 이 사양은 연산자 "\*\*"가 지수를 의미한다는 점을 제외하고 프로그래밍 언어 C에서 익숙한 표기법을 사용합니다.

---
## **2.  Constrained Application Protocol**

CoAP의 상호작용 모델은 HTTP의 클라이언트/서버 모델과 유사합니다. 그러나 기계 간 상호 작용으로 인해 일반적으로 CoAP 구현이 클라이언트 역할과 서버 역할 모두에서 작동하게 됩니다. CoAP 요청은 HTTP 요청과 동일하며 클라이언트가 서버의 리소스\(URI로 식별됨\)에 대한 작업\(메소드 코드 사용\)을 요청하기 위해 전송합니다. 그런 다음 서버는 응답 코드와 함께 응답을 보냅니다. 이 응답에는 리소스 표현이 포함될 수 있습니다.

HTTP와 달리 CoAP는 UDP와 같은 데이터그램 중심 전송을 통해 이러한 교환을 비동기적으로 처리합니다. 이는 선택적인 신뢰성\(지수 백오프 포함\)을 지원하는 메시지 계층을 사용하여 논리적으로 수행됩니다. CoAP는 확인 가능, 확인 불가능, 승인, 재설정의 네 가지 유형의 메시지를 정의합니다. 이러한 메시지 중 일부에 포함된 메소드 코드 및 응답 코드는 해당 메시지가 요청 또는 응답을 전달하도록 합니다. 네 가지 유형의 메시지의 기본 교환은 요청/응답 상호 작용과 다소 직교합니다. 요청은 확인 가능 및 확인 불가능 메시지로 전달될 수 있으며, 응답은 승인 메시지에 피기백될 뿐만 아니라 이러한 메시지로 전달될 수 있습니다.

논리적으로 CoAP는 UDP와 상호 작용의 비동기 특성을 처리하는 데 사용되는 CoAP 메시징 계층, 메서드 및 응답 코드를 사용하는 요청/응답 상호 작용인 2계층 접근 방식을 사용하는 것으로 생각할 수 있습니다\(그림 1 참조\). 그러나 CoAP는 CoAP 헤더의 기능으로 메시징 및 요청/응답을 포함하는 단일 프로토콜입니다.

```text
                        +----------------------+
                        |      Application     |
                        +----------------------+
                        +----------------------+  \
                        |  Requests/Responses  |  |
                        |----------------------|  | CoAP
                        |       Messages       |  |
                        +----------------------+  /
                        +----------------------+
                        |          UDP         |
                        +----------------------+

                    Figure 1: Abstract Layering of CoAP
```

---
### **2.1.  Messaging Model**

CoAP 메시징 모델은 엔드포인트 간 UDP를 통한 메시지 교환을 기반으로 합니다.

CoAP는 압축 바이너리 옵션과 페이로드가 뒤따를 수 있는 짧은 고정 길이 바이너리 헤더\(4바이트\)를 사용합니다. 이 메시지 형식은 요청과 응답에 의해 공유됩니다. CoAP 메시지 형식은 섹션 3에 지정되어 있습니다. 각 메시지에는 중복을 감지하고 선택적 안정성을 위해 사용되는 메시지 ID가 포함되어 있습니다. \(메시지 ID는 컴팩트합니다. 16비트 크기를 사용하면 기본 프로토콜 매개변수를 사용하여 한 끝점에서 다른 끝점으로 초당 최대 약 250개의 메시지를 전달할 수 있습니다.\)

메시지를 확인 가능\(CON\)으로 표시하면 신뢰성이 제공됩니다. 확인 가능 메시지는 수신자가 해당 끝점에서 동일한 메시지 ID\(이 예에서는 0x7d34\)를 사용하여 승인 메시지\(ACK\)를 보낼 때까지 기본 시간 초과 및 재전송 사이의 지수 백오프를 사용하여 재전송됩니다. 그림 2를 참조하세요. 수신자가 확인 가능한 메시지를 전혀 처리할 수 없는 경우\(즉, 적절한 오류 응답을 제공할 수도 없는 경우\) 승인\(ACK\) 대신 재설정 메시지\(RST\)로 응답합니다.

```text
                        Client              Server
                           |                  |
                           |   CON [0x7d34]   |
                           +----------------->|
                           |                  |
                           |   ACK [0x7d34]   |
                           |<-----------------+
                           |                  |

                  Figure 2: Reliable Message Transmission
```

안정적인 전송이 필요하지 않은 메시지\(예: 센서 데이터 스트림의 각 단일 측정값\)는 확인 불가능 메시지\(NON\)로 전송될 수 있습니다. 이는 승인되지 않지만 여전히 중복 감지를 위한 메시지 ID\(이 예에서는 0x01a0\)를 가지고 있습니다. 그림 3을 참조하세요. 수신자가 확인 불가능 메시지를 처리할 수 없는 경우 재설정 메시지\(RST\)로 응답할 수 있습니다.

```text
                        Client              Server
                           |                  |
                           |   NON [0x01a0]   |
                           +----------------->|
                           |                  |

                 Figure 3: Unreliable Message Transmission
```

CoAP 메시지에 대한 자세한 내용은 섹션 4를 참조하세요.

CoAP는 UDP를 통해 실행되므로 멀티캐스트 IP 대상 주소 사용도 지원하여 멀티캐스트 CoAP 요청을 활성화합니다. 섹션 8에서는 멀티캐스트 주소가 포함된 CoAP 메시지의 적절한 사용과 응답 혼잡을 피하기 위한 예방 조치에 대해 논의합니다.

보안 없음부터 인증서 기반 보안까지 CoAP에 대한 여러 보안 모드가 섹션 9에 정의되어 있습니다. 이 문서는 프로토콜 보안을 위해 DTLS에 대한 바인딩을 지정합니다. CoAP와 함께 IPsec을 사용하는 방법은 \[IPsec-CoAP\]에서 논의됩니다.

---
### **2.2.  Request/Response Model**

CoAP 요청 및 응답 의미 체계는 각각 메소드 코드 또는 응답 코드를 포함하는 CoAP 메시지로 전달됩니다. URI 및 페이로드 미디어 유형과 같은 선택적\(또는 기본\) 요청 및 응답 정보는 CoAP 옵션으로 전달됩니다. 토큰은 기본 메시지와는 별도로 요청에 대한 응답을 일치시키는 데 사용됩니다\(섹션 5.3\). \(토큰은 메시지 ID와는 별개의 개념이라는 점에 유의하세요.\)

요청은 확인 가능\(CON\) 또는 확인 불가능\(NON\) 메시지로 전달되며, 즉시 사용 가능한 경우 확인 가능 메시지로 전달된 요청에 대한 응답은 결과 승인\(ACK\) 메시지로 전달됩니다. 이를 피기백 응답\(piggybacked response\)이라고 하며 섹션 5.2.1에 자세히 설명되어 있습니다. \(피기백된 응답을 전달하는 승인 메시지가 손실된 경우 클라이언트가 요청을 재전송하므로 피기백된 응답을 별도로 승인할 필요가 없습니다.\) 피기백된 응답을 포함하는 기본 GET 요청에 대한 두 가지 예가 그림 4에 나와 있습니다. 하나는 성공합니다. 4.04\(찾을 수 없음\) 응답이 발생합니다.

```text
        Client              Server       Client              Server
           |                  |             |                  |
           |   CON [0xbc90]   |             |   CON [0xbc91]   |
           | GET /temperature |             | GET /temperature |
           |   (Token 0x71)   |             |   (Token 0x72)   |
           +----------------->|             +----------------->|
           |                  |             |                  |
           |   ACK [0xbc90]   |             |   ACK [0xbc91]   |
           |   2.05 Content   |             |  4.04 Not Found  |
           |   (Token 0x71)   |             |   (Token 0x72)   |
           |     "22.5 C"     |             |   "Not found"    |
           |<-----------------+             |<-----------------+
           |                  |             |                  |

           Figure 4: Two GET Requests with Piggybacked Responses
```

서버가 확인 가능 메시지에 포함된 요청에 즉시 응답할 수 없는 경우 클라이언트가 요청 재전송을 중지할 수 있도록 단순히 빈 승인 메시지로 응답합니다. 응답이 준비되면 서버는 이를 새로운 확인 가능 메시지로 보냅니다. 그러면 클라이언트가 이를 승인해야 합니다. 그림 5에 설명되어 있고 섹션 5.2.2에 자세히 설명되어 있는 것처럼 이를 "별도 응답"이라고 합니다.

```text
                        Client              Server
                           |                  |
                           |   CON [0x7a10]   |
                           | GET /temperature |
                           |   (Token 0x73)   |
                           +----------------->|
                           |                  |
                           |   ACK [0x7a10]   |
                           |<-----------------+
                           |                  |
                           ... Time Passes  ...
                           |                  |
                           |   CON [0x23bb]   |
                           |   2.05 Content   |
                           |   (Token 0x73)   |
                           |     "22.5 C"     |
                           |<-----------------+
                           |                  |
                           |   ACK [0x23bb]   |
                           +----------------->|
                           |                  |

             Figure 5: A GET Request with a Separate Response
```

요청이 확인 불가능 메시지로 전송되면 서버가 확인 가능 메시지를 대신 보낼 수도 있지만 새로운 확인 불가능 메시지를 사용하여 응답이 전송됩니다. 이러한 유형의 교환은 그림 6에 설명되어 있습니다.

```text
                        Client              Server
                           |                  |
                           |   NON [0x7a11]   |
                           | GET /temperature |
                           |   (Token 0x74)   |
                           +----------------->|
                           |                  |
                           |   NON [0x23bc]   |
                           |   2.05 Content   |
                           |   (Token 0x74)   |
                           |     "22.5 C"     |
                           |<-----------------+
                           |                  |

       Figure 6: A Request and a Response Carried in Non-confirmable
                                 Messages
```

CoAP는 섹션 5.8에 지정된 의미를 사용하여 HTTP와 유사한 방식으로 GET, PUT, POST 및 DELETE 메서드를 사용합니다. \(CoAP 방법의 세부적인 의미는 HTTP 방법과 "거의 그러나 완전히 다르지는 않습니다"\[HHGTTG\]. HTTP 경험에서 얻은 직관은 일반적으로 잘 적용되지만 현재 내용을 실제로 읽을 가치가 있을 만큼 충분한 차이가 있습니다. 사양.\)

기본 4가지 이외의 메소드는 별도의 사양으로 CoAP에 추가할 수 있습니다. 새로운 메서드는 반드시 요청과 응답을 쌍으로 사용할 필요는 없습니다. 기존 방법의 경우에도 단일 요청은 예를 들어 멀티캐스트 요청\(섹션 8\) 또는 관찰 옵션 \[OBSERVE\]을 사용하여 여러 응답을 생성할 수 있습니다.

클라이언트가 이미 URI를 구문 분석하고 이를 호스트, 포트, 경로 및 쿼리 구성 요소로 분할하여 효율성을 위해 기본값을 사용하므로 서버의 URI 지원이 단순화됩니다. 응답 코드는 섹션 5.9에 정의된 대로 몇 가지 CoAP 관련 코드가 추가된 HTTP 상태 코드의 작은 하위 집합과 관련됩니다.

---
### **2.3.  Intermediaries and Caching**

프로토콜은 요청을 효율적으로 이행하기 위해 응답 캐싱을 지원합니다. CoAP 응답과 함께 전달되는 신선도 및 유효성 정보를 사용하여 간단한 캐싱이 활성화됩니다. 캐시는 엔드포인트나 중개자에 위치할 수 있습니다. 캐싱 기능은 섹션 5.6에 지정되어 있습니다.

프록싱은 네트워크 트래픽 제한, 성능 향상, 절전 장치의 리소스 액세스 및 보안상의 이유로 제한된 네트워크에서 유용합니다. 다른 CoAP 엔드포인트를 대신하여 요청을 프록시하는 것은 프로토콜에서 지원됩니다. 프록시를 사용하는 경우 요청하려는 리소스의 URI가 요청에 포함되며 대상 IP 주소는 프록시의 주소로 설정됩니다. 프록시 기능에 대한 자세한 내용은 섹션 5.7을 참조하세요.

CoAP는 REST 아키텍처\[REST\]에 따라 설계되어 HTTP 프로토콜과 유사한 기능을 나타내기 때문에 CoAP에서 HTTP로, HTTP에서 CoAP로 매핑하는 것이 매우 간단합니다. 이러한 매핑은 CoAP를 이용하여 HTTP REST 인터페이스를 구현하거나 HTTP와 CoAP 간 변환을 위해 사용될 수 있다. 이 변환은 메소드 또는 응답 코드, 미디어 유형 및 옵션을 해당 HTTP 기능으로 변환하는 교차 프로토콜 프록시\("교차 프록시"\)에 의해 수행될 수 있습니다. 섹션 10에서는 HTTP 매핑에 대한 자세한 내용을 제공합니다.

---
### **2.4.  Resource Discovery**

리소스 검색은 기계 간 상호 작용에 중요하며 섹션 7에서 설명한 대로 CoRE 링크 형식 \[RFC6690\]을 사용하여 지원됩니다.

---
## **3.  Message Format**

CoAP는 기본적으로 UDP를 통해 전송되는 압축 메시지 교환을 기반으로 합니다\(즉, 각 CoAP 메시지는 하나의 UDP 데이터그램의 데이터 섹션을 차지합니다\). CoAP는 DTLS\(데이터그램 전송 계층 보안\)를 통해 사용될 수도 있습니다\(섹션 9.1 참조\). 또한 SMS, TCP 또는 SCTP와 같은 다른 전송을 통해 사용될 수도 있으며 이에 대한 사양은 이 문서의 범위를 벗어납니다. \(UDP-lite \[RFC3828\] 및 UDP 제로 체크섬 \[RFC6936\]은 CoAP에서 지원되지 않습니다.\)

CoAP 메시지는 간단한 바이너리 형식으로 인코딩됩니다. 메시지 형식은 고정 크기 4바이트 헤더로 시작됩니다. 그 뒤에는 0\~8바이트 길이의 가변 길이 토큰 값이 옵니다.

토큰 값 다음에는 TLV\(Type-Length-Value\) 형식의 0개 이상의 CoAP 옵션 시퀀스가 ​​오고, 선택적으로 데이터그램의 나머지 부분을 차지하는 페이로드가 뒤따릅니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver| T |  TKL  |      Code     |          Message ID           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Token (if any, TKL bytes) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Options (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1|    Payload (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 7: Message Format
```

헤더의 필드는 다음과 같이 정의됩니다.

버전\(Ver\): 2비트 부호 없는 정수. CoAP 버전 번호를 나타냅니다. 이 사양의 구현에서는 이 필드를 1\(01 바이너리\)로 설정해야 합니다. 다른 값은 향후 버전을 위해 예약되어 있습니다. 버전 번호를 알 수 없는 메시지는 자동으로 무시되어야 합니다.

유형\(T\): 2비트 부호 없는 정수. 이 메시지의 유형이 확인 가능\(0\), 확인 불가능\(1\), 승인\(2\) 또는 재설정\(3\)인지 여부를 나타냅니다. 이러한 메시지 유형의 의미는 섹션 4에 정의되어 있습니다.

토큰 길이\(TKL\): 4비트 부호 없는 정수. 가변 길이 토큰 필드의 길이\(0-8바이트\)를 나타냅니다. 길이 9-15는 예약되어 있어 전송되어서는 안 되며 메시지 형식 오류로 처리되어야 합니다.

코드: 8비트 부호 없는 정수, 3비트 클래스\(최상위 비트\)와 5비트 세부 정보\(최하위 비트\)로 분할, "c.dd"로 문서화됨, 여기서 "c"는 0에서 7까지의 숫자임 3비트 하위 필드의 경우 "dd"는 5비트 하위 필드의 경우 00\~31 사이의 두 자리 숫자입니다. 클래스는 요청\(0\), 성공 응답\(2\), 클라이언트 오류 응답\(4\) 또는 서버 오류 응답\(5\)을 나타낼 수 있습니다. \(다른 모든 클래스 값은 예약되어 있습니다.\) 특별한 경우로 코드 0.00은 비어 있음 메시지를 나타냅니다. 요청의 경우 코드 필드는 요청 방법을 나타냅니다. 응답의 경우 응답 코드. 가능한 값은 CoAP 코드 레지스트리\(섹션 12.1\)에 유지됩니다. 요청과 응답의 의미는 섹션 5에 정의되어 있습니다.

메시지 ID: 네트워크 바이트 순서의 16비트 부호 없는 정수입니다. 메시지 중복을 감지하고 확인/재설정 유형의 메시지를 확인 가능/확인 불가능 유형의 메시지와 일치시키는 데 사용됩니다. 메시지 ID 생성 및 메시지 일치 규칙은 섹션 4에 정의되어 있습니다.

헤더 다음에는 토큰 길이 필드에 지정된 대로 0\~8바이트의 토큰 값이 옵니다. 토큰 값은 요청과 응답을 연관시키는 데 사용됩니다. 토큰을 생성하고 요청과 응답을 연관시키는 규칙은 섹션 5.3.1에 정의되어 있습니다.

헤더와 토큰 뒤에는 0개 이상의 옵션이 옵니다\(섹션 3.1\). 옵션 뒤에는 메시지 끝, 다른 옵션 또는 페이로드 마커와 페이로드가 올 수 있습니다.

헤더, 토큰 및 옵션\(있는 경우\) 뒤에는 선택적 페이로드가 옵니다. 존재하고 길이가 0이 아닌 경우 옵션의 끝과 페이로드의 시작을 나타내는 고정된 1바이트 페이로드 마커\(0xFF\)가 접두사로 붙습니다. 페이로드 데이터는 마커 뒤에서 UDP 데이터그램 끝까지 확장됩니다. 즉, 페이로드 길이는 데이터그램 크기에서 계산됩니다. 페이로드 마커가 없으면 길이가 0인 페이로드를 나타냅니다. 길이가 0인 페이로드가 뒤따르는 마커의 존재는 메시지 형식 오류로 처리되어야 합니다.

구현 참고 사항: 바이트 값 0xFF는 옵션 길이 또는 값 내에서도 발생할 수 있으므로 0xFF에 대한 간단한 바이트 단위 스캐닝은 페이로드 마커를 찾기 위한 실행 가능한 기술이 아닙니다. 바이트 0xFF는 다른 옵션의 시작이 발생할 수 있는 페이로드 마커의 의미를 갖습니다.

---
### **3.1.  Option Format**

CoAP는 메시지에 포함될 수 있는 다양한 옵션을 정의합니다. 메시지의 각 옵션 인스턴스는 정의된 CoAP 옵션의 옵션 번호, 옵션 값의 길이 및 옵션 값 자체를 지정합니다.

옵션 번호를 직접 지정하는 대신 인스턴스는 옵션 번호 순서대로 나타나야 하며 인스턴스 사이에 델타 인코딩이 사용됩니다. 각 인스턴스의 옵션 번호는 델타와 이전 인스턴스의 옵션 번호의 합으로 계산됩니다. 메시지. 메시지의 첫 번째 인스턴스의 경우 옵션 번호가 0인 이전 옵션 인스턴스가 가정됩니다. 델타 0을 사용하여 동일한 옵션의 여러 인스턴스를 포함할 수 있습니다.

옵션 번호는 "CoAP 옵션 번호" 레지스트리\(섹션 12.2\)에 유지됩니다. 이 문서에 정의된 옵션의 의미는 섹션 5.4를 참조하세요.

```text
     0   1   2   3   4   5   6   7
   +---------------+---------------+
   |               |               |
   |  Option Delta | Option Length |   1 byte
   |               |               |
   +---------------+---------------+
   \                               \
   /         Option Delta          /   0-2 bytes
   \          (extended)           \
   +-------------------------------+
   \                               \
   /         Option Length         /   0-2 bytes
   \          (extended)           \
   +-------------------------------+
   \                               \
   /                               /
   \                               \
   /         Option Value          /   0 or more bytes
   \                               \
   /                               /
   \                               \
   +-------------------------------+

                          Figure 8: Option Format
```

옵션의 필드는 다음과 같이 정의됩니다.

옵션 델타: 4비트 부호 없는 정수. 0에서 12 사이의 값은 옵션 델타를 나타냅니다. 특수 구성을 위해 세 가지 값이 예약되어 있습니다.

- 13: 8비트 부호 없는 정수는 초기 바이트 뒤에 오며 옵션 델타에서 13을 뺀 값을 나타냅니다.

- 14: 네트워크 바이트 순서의 16비트 부호 없는 정수는 초기 바이트 뒤에 오며 옵션 델타에서 269를 뺀 값을 나타냅니다.

- 15: 페이로드 마커용으로 예약되어 있습니다. 필드가 이 값으로 설정되었지만 전체 바이트가 페이로드 마커가 아닌 경우 이는 메시지 형식 오류로 처리되어야 합니다.

- 결과 옵션 델타는 이 옵션의 옵션 번호와 이전 옵션의 옵션 번호 간의 차이로 사용됩니다\(또는 첫 번째 옵션의 경우 0\). 즉, 옵션 번호는 이 옵션과 그 이전의 모든 옵션의 옵션 델타 값을 단순히 합산하여 계산됩니다.

옵션 길이: 4비트 부호 없는 정수. 0에서 12 사이의 값은 옵션 값의 길이\(바이트\)를 나타냅니다. 특수 구성을 위해 세 가지 값이 예약되어 있습니다.

- 13: 8비트 부호 없는 정수가 옵션 값 앞에 오고 옵션 길이에서 13을 뺀 값을 나타냅니다.

- 14: 네트워크 바이트 순서의 16비트 부호 없는 정수가 옵션 값 앞에 오고 옵션 길이에서 269를 뺀 값을 나타냅니다.

- 15: 향후 사용을 위해 예약되어 있습니다. 필드가 이 값으로 설정된 경우 메시지 형식 오류로 처리되어야 합니다.

값: 정확히 Option Length 바이트의 시퀀스입니다. 옵션 값의 길이와 형식은 가변 길이 값을 정의할 수 있는 각 옵션에 따라 다릅니다. 이 문서에 사용된 형식은 섹션 3.2를 참조하세요. 다른 문서에 정의된 옵션은 다른 옵션 값 형식을 사용할 수 있습니다.

---
### **3.2.  Option Value Formats**

이 문서에 정의된 옵션은 다음 옵션 값 형식을 사용합니다.

비어 있음: 길이가 0인 바이트 시퀀스입니다.

불투명: 불투명한 바이트 시퀀스입니다.

```text
   uint:     A non-negative integer that is represented in network byte
             order using the number of bytes given by the Option Length
             field.

             An option definition may specify a range of permissible
             numbers of bytes; if it has a choice, a sender SHOULD
             represent the integer with as few bytes as possible, i.e.,
             without leading zero bytes.  For example, the number 0 is
             represented with an empty option value (a zero-length
             sequence of bytes) and the number 1 by a single byte with
             the numerical value of 1 (bit combination 00000001 in most
             significant bit first notation).  A recipient MUST be
             prepared to process values with leading zero bytes.

             Implementation Note:  The exceptional behavior permitted
                for the sender is intended for highly constrained,
                templated implementations (e.g., hardware
                implementations) that use fixed-size options in the
                templates.

   string:   A Unicode string that is encoded using UTF-8 [RFC3629] in
             Net-Unicode form [RFC5198].

             Note that here, and in all other places where UTF-8
             encoding is used in the CoAP protocol, the intention is
             that the encoded strings can be directly used and compared
             as opaque byte strings by CoAP protocol implementations.
             There is no expectation and no need to perform
             normalization within a CoAP implementation (except where
             Unicode strings that are not known to be normalized are
             imported from sources outside the CoAP protocol).  Note
             also that ASCII strings (that do not make use of special
             control characters) are always valid UTF-8 Net-Unicode
             strings.
```

---
## **4.  Message Transmission**

CoAP 메시지는 CoAP 끝점 간에 비동기적으로 교환됩니다. 이는 CoAP 요청 및 응답을 전송하는 데 사용되며 그 의미는 섹션 5에 정의되어 있습니다.

CoAP는 UDP와 같은 신뢰할 수 없는 전송에 바인딩되어 있기 때문에 CoAP 메시지는 순서 없이 도착하거나, 중복된 것으로 나타나거나, 예고 없이 누락될 수 있습니다. 이러한 이유로 CoAP는 TCP와 같은 전송의 전체 기능 세트를 다시 만들지 않고 경량 신뢰성 메커니즘을 구현합니다. 다음과 같은 기능이 있습니다.

- 확인 가능한 메시지에 대한 지수 백오프 기능을 갖춘 간단한 중지 및 대기 재전송 안정성.

- 확인 가능 메시지와 확인 불가능 메시지 모두에 대한 중복 감지.

---
### **4.1.  Messages and Endpoints**

CoAP 엔드포인트는 CoAP 메시지의 소스 또는 대상입니다. 엔드포인트의 구체적인 정의는 CoAP에 사용되는 전송에 따라 다릅니다. 본 사양에 정의된 전송의 경우 엔드포인트는 사용된 보안 모드에 따라 식별됩니다\(섹션 9 참조\). 보안이 없으면 엔드포인트는 IP 주소와 UDP 포트 번호로만 식별됩니다. 다른 보안 모드를 사용하면 엔드포인트는 보안 모드에 정의된 대로 식별됩니다.

메시지에는 다양한 유형이 있습니다. 메시지 유형은 CoAP 헤더의 유형 필드에 의해 지정됩니다.

메시지 유형과 별도로 메시지는 요청, 응답을 전달하거나 비어 있을 수 있습니다. 이는 CoAP 헤더의 요청/응답 코드 필드로 표시되며 요청/응답 모델과 관련됩니다. 필드에 가능한 값은 CoAP 코드 레지스트리\(섹션 12.1\)에 유지됩니다.

비어 있음 메시지에는 코드 필드가 0.00으로 설정되어 있습니다. 토큰 길이 필드는 0으로 설정되어야 하며 메시지 ID 필드 뒤에는 데이터 바이트가 있어서는 안 됩니다. 바이트가 있으면 메시지 형식 오류로 처리되어야 합니다.

---
### **4.2.  Messages Transmitted Reliably**

CoAP 헤더에서 메시지를 확인 가능으로 표시하면 메시지의 안정적인 전송이 시작됩니다. 확인 가능 메시지는 재설정 메시지를 유도하는 데만 사용되지 않는 한 항상 요청이나 응답을 전달하며, 이 경우 비어 있습니다. 수신자는 \(a\) 확인 메시지로 확인 가능 메시지를 확인하거나 \(b\) 메시지가 비어 있고 예약된 클래스\(1\)가 있는 코드를 사용하는 상황을 포함하여 메시지를 적절하게 처리하기 위한 컨텍스트가 부족한 경우 메시지를 거부해야 합니다. , 6 또는 7\) 또는 메시지 형식 오류가 있습니다. 확인 가능 메시지 거부는 일치하는 재설정 메시지를 보내고 그렇지 않으면 이를 무시함으로써 영향을 받습니다. 승인 메시지는 확인 가능 메시지의 메시지 ID를 반영해야 하며 응답을 전달하거나 비어 있어야 합니다\(섹션 5.2.1 및 5.2.2 참조\). 재설정 메시지는 확인 가능 메시지의 메시지 ID를 반영해야 하며 비어 있어야 합니다. 승인 또는 재설정 메시지 거부\(승인이 예약된 클래스가 있는 요청이나 코드를 전달하거나 재설정 메시지가 비어 있지 않은 경우 포함\)는 이를 자동으로 무시함으로써 영향을 받습니다. 보다 일반적으로 승인 및 재설정 메시지의 수신자는 승인 또는 재설정 메시지로 응답해서는 안 됩니다.

발신자는 확인\(또는 재설정 메시지\)을 수신하거나 시도 횟수가 부족할 때까지 기하급수적으로 증가하는 간격으로 확인 가능 메시지를 재전송합니다.

재전송은 CoAP 엔드포인트가 승인\(또는 재설정\)을 기다리는 동안 전송하는 각 확인 가능 메시지에 대해 반드시 추적해야 하는 두 가지, 즉 시간 초과와 재전송 카운터에 의해 제어됩니다. 새로운 확인 가능 메시지의 경우 초기 시간 초과는 ACK\_TIMEOUT과 \(ACK\_TIMEOUT \* ACK\_RANDOM\_FACTOR\) 사이의 임의 기간\(종종 정수가 아닌 초\)으로 설정되고\(섹션 4.8 참조\) 재전송 카운터는 0으로 설정됩니다. 트리거되고 재전송 카운터가 다음보다 작습니다.

MAX\_RETRANSMIT, 메시지가 재전송되고 재전송 카운터가 증가하며 제한 시간이 두 배가 됩니다. 시간 초과 시 재전송 카운터가 MAX\_RETRANSMIT에 도달하거나 엔드포인트가 Reset 메시지를 수신하면 메시지 전송 시도가 취소되고 애플리케이션 프로세스에 실패가 통보됩니다. 반면, 엔드포인트가 시간 내에 승인을 받으면 전송이 성공한 것으로 간주됩니다.

이 사양에서는 위의 이진 지수 백오프 알고리즘을 구현하는 데 사용되는 클록의 정확성에 대해 강력한 요구 사항을 제시하지 않습니다. 특히 엔드포인트는 수면 일정으로 인해 특정 재전송에 늦을 수 있으며 다음 일정을 따라잡을 수 있습니다. 그러나 또 다른 재전송 전의 최소 간격은 ACK\_TIMEOUT이며, \(재\)전송의 전체 시퀀스는 발신자가 전송할 기회를 놓칠 수 있음을 의미하더라도 MAX\_TRANSMIT\_SPAN\(섹션 4.8.2 참조\)의 봉투에 유지되어야 합니다.

확인 가능 메시지를 보낸 CoAP 엔드포인트는 MAX\_RETRANSMIT 카운터 값에 도달하기 전에도 ACK 획득 시도를 포기할 수 있습니다. 예를 들어, 애플리케이션이 더 이상 응답이 필요하지 않기 때문에 요청을 취소했거나 CON 메시지가 도착했다는 다른 표시가 있습니다. 특히, CoAP 요청 메시지가 별도의 응답을 이끌어냈을 수 있으며, 이 경우 ACK만 손실되었으며 요청을 재전송해도 아무 소용이 없다는 것이 요청자에게 분명합니다. 그러나 응답자는 요청자의 이러한 계층 간 동작에 의존해서는 안 됩니다. 즉, 요청자가 확인 가능한 응답을 이미 승인한 경우에도 필요한 경우 요청에 대한 ACK를 생성하기 위한 상태를 유지해야 합니다.

재전송을 포기하는 또 다른 이유는 ICMP 오류 수신일 수 있습니다. ICMP 오류를 고려하여 잠재적인 스푸핑 공격을 완화하려는 경우 구현에서는 메시지 유형 및 코드, 메시지 ID와 같은 포트 번호 및 CoAP 헤더 정보를 포함하여 ICMP 메시지의 원본 데이터그램에 대한 정보를 확인하도록 주의해야 합니다\(SHOULD\). 및 토큰; UDP 서비스 API의 제한으로 인해 이것이 가능하지 않은 경우 ICMP 오류는 무시되어야 합니다. 패킷이 너무 큼 오류\[RFC4443\]\(IPv4에 대한 "조각화 필요 및 DF 세트"\[RFC0792\]\)는 제대로 발생할 수 없으며 섹션 4.6의 구현 참고 사항을 따르는 경우 무시해야 합니다. 그렇지 않으면 경로 MTU 검색 알고리즘 \[RFC4821\]에 입력해야 합니다. Source Quench 및 Time Exceeded ICMP 메시지는 무시되어야 합니다. 호스트, 네트워크, 포트 또는 프로토콜에 도달할 수 없는 오류 또는 매개변수 문제 오류는 적절한 조사 후에 애플리케이션에 전송 실패를 알리는 데 사용될 수 있습니다.

---
### **4.3.  Messages Transmitted without Reliability**

일부 메시지에는 확인이 필요하지 않습니다. 이는 최종 성공이면 충분할 센서의 반복 판독과 같이 애플리케이션 요구 사항에 대해 정기적으로 반복되는 메시지의 경우 특히 그렇습니다.

보다 가벼운 대안으로, 메시지를 확인 불가능으로 표시하면 메시지의 신뢰성이 낮아질 수 있습니다. 확인 불가능 메시지는 항상 요청 또는 응답을 전달하며 비어 있어서는 안 됩니다. 확인 불가능 메시지는 수신자가 확인해서는 안 됩니다. 메시지가 비어 있거나 예약된 클래스\(1, 6 또는 7\)가 있는 코드를 사용하거나 메시지 형식 오류가 있는 경우를 포함하여 메시지를 올바르게 처리하기 위한 컨텍스트가 부족한 경우 수신자는 메시지를 거부해야 합니다. 확인 불가능한 메시지를 거부하려면 일치하는 재설정 메시지를 보내는 것이 포함될 수 있으며, 재설정 메시지와 별도로 거부된 메시지는 자동으로 무시되어야 합니다.

CoAP 수준에서는 발신자가 확인 불가능 메시지가 수신되었는지 여부를 감지할 수 있는 방법이 없습니다. 발신자는 MAX\_TRANSMIT\_SPAN 내에서 확인 불가능한 메시지의 여러 복사본을 전송하도록 선택할 수 있습니다\(4.7항의 조항, 특히 응답이 수신되지 않는 경우 PROBING\_RATE로 제한됨\). 그렇지 않으면 네트워크가 전송 중에 메시지를 복제할 수 있습니다. 수신자가 메시지에 대해 한 번만 작동할 수 있도록 하려면 확인 불가능 메시지에도 메시지 ID를 지정합니다. \(이 메시지 ID는 확인 가능한 메시지의 메시지 ID와 동일한 숫자 공간에서 추출됩니다.\)

섹션 4.2 및 4.3을 요약하면 표 1과 같이 네 가지 메시지 유형을 사용할 수 있습니다. "\*"는 해당 조합이 일반 작업에서는 사용되지 않고 재설정 메시지\("CoAP ping"\)를 유도하는 데만 사용됨을 의미합니다.

```text
                   +----------+-----+-----+-----+-----+
                   |          | CON | NON | ACK | RST |
                   +----------+-----+-----+-----+-----+
                   | Request  | X   | X   | -   | -   |
                   | Response | X   | X   | X   | -   |
                   | Empty    | *   | -   | X   | X   |
                   +----------+-----+-----+-----+-----+

                      Table 1: Usage of Message Types
```

---
### **4.4.  Message Correlation**

Acknowledgement 또는 Reset 메시지는 해당 엔드포인트의 추가 주소 정보와 함께 메시지 ID를 통해 확인 가능한 메시지 또는 확인 불가능한 메시지와 관련됩니다. 메시지 ID는 확인 가능 또는 확인 불가능 메시지의 발신자가 생성하고 CoAP 헤더에 포함되는 16비트 부호 없는 정수입니다. 메시지 ID는 수신자의 승인 또는 재설정 메시지에 반영되어야 합니다.

동일한 메시지 ID는 EXCHANGE\_LIFETIME\(섹션 4.8.2\) 내에서 \(동일한 엔드포인트와 통신할 때\) 재사용되어서는 안 됩니다.

구현 참고 사항: 메시지 ID 생성을 위해 여러 구현 전략을 사용할 수 있습니다. 가장 간단한 경우, CoAP 엔드포인트는 대상 주소나 포트에 관계없이 새로운 확인 가능 또는 확인 불가능 메시지가 전송될 때마다 변경되는 단일 메시지 ID 변수를 유지하여 메시지 ID를 생성합니다. 많은 수의 트랜잭션을 처리하는 엔드포인트는 예를 들어 접두사 또는 대상 주소별로 여러 메시지 ID 변수를 유지할 수 있습니다. \(일부 수신 엔드포인트는 자신에게 전달된 유니캐스트 패킷과 멀티캐스트 패킷을 구별하지 못할 수 있으므로 메시지 ID를 생성하는 엔드포인트는 이러한 패킷이 겹치지 않도록 해야 합니다.\) 변수의 초기 값\(예: 시작\)을 무작위로 지정하여 프로토콜에 대한 경로를 벗어난 공격이 성공할 가능성을 줄입니다.

승인 또는 재설정 메시지가 확인 가능 또는 확인 불가능 메시지와 일치하려면 승인 또는 재설정 메시지의 메시지 ID 및 소스 엔드포인트가 확인 가능 또는 확인 불가능 메시지의 메시지 ID 및 대상 엔드포인트와 일치해야 합니다.

---
### **4.5.  Message Deduplication**

수신자는 EXCHANGE\_LIFETIME\(섹션 4.8.2\) 내에 동일한 확인 가능 메시지\(메시지 ID 및 소스 엔드포인트로 표시됨\)를 여러 번 수신할 수 있습니다. 예를 들어 승인이 누락되었거나 첫 번째 메시지 이전에 원래 발신자에게 도달하지 못한 경우입니다. 시간 초과. 수신자는 동일한 확인 또는 재설정 메시지를 사용하여 확인 가능 메시지의 각 중복 사본을 확인해야 하지만 메시지의 요청 또는 응답을 한 번만 처리해야 합니다. 확인 가능 메시지가 멱등성\(섹션 5.1 참조\)인 요청을 전송하거나 멱등성 방식으로 처리될 수 있는 경우 이 규칙은 완화될 수 있습니다. 완화된 메시지 중복 제거의 예:

- 서버는 메시지 ID에 대한 상태를 유지할 필요가 없도록 동일한 응답\(섹션 4.2\)으로 멱등성 요청의 모든 재전송에 응답해야 하는 요구 사항을 완화할 수 있습니다. 예를 들어, 중복 처리로 인해 발생하는 노력이 이전 응답을 추적하는 것보다 비용이 덜 드는 경우 구현에서는 GET, PUT 또는 DELETE 요청의 중복 전송을 별도의 요청으로 처리하기를 원할 수 있습니다.

- 제한된 서버는 애플리케이션 의미론이 이러한 절충안을 유리하게 만드는 경우 특정 비멱등성 요청에 대해 이 요구 사항을 완화하기를 원할 수도 있습니다. 예를 들어, POST 요청의 결과가 서버에서 일시적인 상태를 생성하는 것이라면 동일한 요청의 이전 전송 여부를 추적하는 것보다 요청에 대해 이러한 노력을 여러 번 수행하는 것이 더 저렴할 수 있습니다. 이미 처리되었습니다.

수신자는 NON\_LIFETIME\(섹션 4.8.2\) 내에 동일한 확인 불가능 메시지\(메시지 ID 및 소스 엔드포인트로 표시됨\)를 여러 번 수신할 수 있습니다. 메시지의 특정 의미에 따라 완화될 수 있는 일반 규칙에 따라 수신자는 확인 불가능한 중복 메시지를 자동으로 무시해야 하며 메시지의 요청이나 응답을 한 번만 처리해야 합니다.

---
### **4.6.  Message Size**

특정 링크 계층에서는 CoAP 메시지를 링크 계층 패킷에 맞도록 작게 유지하는 것이 유리하지만\(섹션 1 참조\) 이는 구현 품질의 문제입니다. CoAP 사양 자체는 메시지 크기에 대한 상한선만 제공합니다. IP 패킷보다 큰 메시지는 바람직하지 않은 패킷 조각화를 초래합니다. 적절하게 캡슐화된 CoAP 메시지는 단일 IP 패킷 내에 맞아야 하며\(즉, IP 조각화 방지\) \(하나의 UDP 페이로드에 맞춰서\) 분명히 단일 IP 데이터그램 내에 맞아야 합니다. 대상에 대한 경로 MTU를 알 수 없는 경우 1280바이트의 IP MTU를 가정해야 합니다. 헤더 크기에 대해 알려진 바가 없는 경우 적절한 상한은 메시지 크기의 경우 1152바이트이고 페이로드 크기의 경우 1024바이트입니다.

구현 참고 사항: CoAP의 메시지 크기 매개변수 선택은 IPv6 및 오늘날 대부분의 IPv4 경로에서 잘 작동합니다. \(그러나 IPv4를 사용하면 IP 단편화가 없음을 절대적으로 보장하기가 더 어렵습니다. 비정상적인 네트워크에서 IPv4 지원을 고려하는 경우 구현에서는 \[RFC0791\]에 따라 576바이트와 같은 보다 보수적인 IPv4 데이터그램 크기로 제한할 수 있습니다. , IPv4에 대한 IP MTU의 절대 최소값은 68바이트만큼 낮습니다. 이는 UDP 페이로드에 대한 보안 오버헤드를 뺀 40바이트만 남게 됩니다. 이 문제 세트에 극도로 초점을 맞춘 구현은 IPv4 DF 비트를 설정하고 일부 수행을 수행할 수도 있습니다.

- 경로 MTU 검색 형식 \[RFC4821\] 그러나 이는 일반적으로 CoAP의 현실적인 사용 사례에서는 불필요합니다. 제한된 많은 네트워크에서 더 중요한 종류의 조각화는 적응 계층에서의 조각화입니다\(예: 6LoWPAN L2 패킷은 다양한 오버헤드를 포함하여 127바이트로 제한됩니다\). 이는 구현이 패킷 크기를 절약하고 3자리 메시지 크기에 접근할 때 블록 단위 전송\[BLOCK\]으로 이동하도록 동기를 부여할 수 있습니다.

- 메시지 크기는 제한된 노드에서의 구현에도 상당히 중요합니다. 많은 구현에서는 수신 메시지에 대한 버퍼를 할당해야 합니다. 구현이 너무 제한되어 위에서 언급한 상한을 할당할 수 없는 경우 DTLS 보안을 사용하지 않는 메시지에 대해 다음 구현 전략을 적용할 수 있습니다. 너무 작은 버퍼에 데이터그램을 수신하는 구현은 일반적으로 후행 데이터그램의 일부가 삭제되어 초기 부분을 검색합니다. 따라서 페이로드 전부는 아니더라도 적어도 CoAP 헤더와 옵션은 버퍼 내에 들어갈 가능성이 높습니다. 따라서 서버는 요청을 완전히 해석하고 페이로드가 잘린 경우 4.13\(요청 엔터티가 너무 큼, 섹션 5.9.2.9 참조\) 응답 코드를 반환할 수 있습니다. 멱등성 요청을 보내고 버퍼에 맞는 것보다 큰 응답을 받는 클라이언트는 차단 옵션 \[BLOCK\]에 적합한 값을 사용하여 요청을 반복할 수 있습니다.

---
### **4.7.  Congestion Control**

CoAP의 기본 혼잡 제어는 섹션 4.2의 지수 백오프 메커니즘에 의해 제공됩니다.

정체를 유발하지 않으려면 클라이언트\(프록시 포함\)는 지정된 서버\(프록시 포함\)에 대해 유지 관리하는 동시에 처리되지 않은 상호 작용 수를 NSTART로 엄격하게 제한해야 합니다. 처리되지 않은 상호작용은 ACK가 아직 수신되지 않았지만 여전히 예상되는 CON\(메시지 계층\) 또는 응답이나 승인 메시지가 아직 수신되지 않았지만 여전히 예상되는 요청\(둘 다 발생할 수 있음\)입니다. 동시에 하나의 뛰어난 상호작용으로 계산됩니다\). 이 사양의 NSTART 기본값은 1입니다.

향후 혼잡 제어 최적화 및 고려 사항이 추가로 예상되며, 예를 들어 섹션 4.8에 정의된 CoAP 전송 매개변수의 자동 초기화를 제공하여 NSTART에 1보다 큰 값을 허용할 수 있습니다.

EXCHANGE\_LIFETIME 이후 클라이언트는 승인 메시지가 수신되지 않은 확인 가능 요청에 대한 응답을 기대하지 않습니다.

클라이언트가 승인된 확인 가능 요청 또는 확인 불가능 요청에 대한 응답을 "기대"하기 위해 중지하는 특정 알고리즘은 정의되지 않습니다. 이것이 추가적인 혼잡 제어 최적화에 의해 수정되지 않는 한, 엔드포인트가 응답하지 않는 다른 엔드포인트로 전송할 때 평균 데이터 속도 PROBING\_RATE를 초과하지 않는 방식으로 선택되어야 합니다.

참고: CoAP는 혼잡 제어의 책임을 주로 클라이언트에 둡니다. 그러나 클라이언트는 예를 들어 증폭 공격을 수행하기 위해 오작동하거나 실제로 공격자가 될 수 있습니다\(11.3절\). 네트워크 및 자체 에너지 자원에 대한 피해를 제한하려면 서버는 애플리케이션 요구 사항에 대한 합리적인 가정을 기반으로 응답 전송에 대한 일부 속도 제한을 구현해야 합니다. 이는 오작동하는 엔드포인트에만 비율 제한을 적용할 수 있는 경우 가장 유용합니다.

---
### **4.8.  Transmission Parameters**

메시지 전송은 다음 매개변수로 제어됩니다.

```text
                   +-------------------+---------------+
                   | name              | default value |
                   +-------------------+---------------+
                   | ACK_TIMEOUT       | 2 seconds     |
                   | ACK_RANDOM_FACTOR | 1.5           |
                   | MAX_RETRANSMIT    | 4             |
                   | NSTART            | 1             |
                   | DEFAULT_LEISURE   | 5 seconds     |
                   | PROBING_RATE      | 1 byte/second |
                   +-------------------+---------------+

                     Table 2: CoAP Protocol Parameters
```

---
#### **4.8.1.  Changing the Parameters**

ACK\_TIMEOUT, ACK\_RANDOM\_FACTOR, MAX\_RETRANSMIT, NSTART, DEFAULT\_LEISURE\(8.2절\) 및 PROBING\_RATE의 값은 애플리케이션 환경에 특정한 값\(동적으로 조정된 값 포함\)으로 구성될 수 있습니다. 그러나 구성 방법은 이 문서의 범위를 벗어납니다. 애플리케이션 환경에서는 이러한 매개변수에 대해 일관된 값을 사용하는 것이 좋습니다. 애플리케이션 환경에서 일관되지 않은 값으로 작동할 경우의 구체적인 효과는 본 사양의 범위를 벗어납니다.

전송 매개변수는 혼잡이 있을 때 인터넷에서 안전한 동작을 달성하기 위해 선택되었습니다. 구성에서 다른 값을 사용하려는 경우 책임은 다음과 같습니다.

이러한 혼잡 제어 속성이 위반되지 않도록 구성합니다. 특히 ACK\_TIMEOUT을 1초 미만으로 줄이면 \[RFC5405\]의 지침을 위반하게 됩니다. \(\[RTO-CONSIDER\]는 몇 가지 추가 배경 정보를 제공합니다.\) CoAP는 RTT\(왕복 시간\) 측정을 유지하지 않는 구현을 가능하게 하도록 설계되었습니다. 그러나 ACK\_TIMEOUT을 크게 줄이거나 NSTART를 늘리려는 경우에는 이러한 측정을 유지할 때만 안전하게 수행할 수 있습니다. 구성은 구성이나 향후 표준 문서에 정의된 혼잡 제어 안전을 보장하는 메커니즘을 사용하지 않고 ACK\_TIMEOUT을 줄이거나 NSTART를 늘려서는 안 됩니다.

ACK\_RANDOM\_FACTOR는 1.0 미만으로 감소해서는 안 되며 동기화 효과로부터 일부 보호를 제공하기 위해 1.0과 충분히 다른 값을 가져야 합니다.

MAX\_RETRANSMIT는 자유롭게 조정할 수 있지만 값이 너무 작으면 확인 가능 메시지가 실제로 수신될 확률이 줄어들고 여기에 제공된 것보다 큰 값은 시간 값을 추가로 조정해야 합니다\(섹션 4.8.2 참조\).

전송 매개변수의 선택으로 인해 파생된 시간 값이 증가하는 경우\(섹션 4.8.2 참조\), 구성 메커니즘은 조정된 값이 통신에 사용되는 모든 엔드포인트에서도 조정된 값을 사용할 수 있도록 보장해야 합니다.

---
#### **4.8.2.  Time Values Derived from Transmission Parameters**

ACK\_TIMEOUT, ACK\_RANDOM\_FACTOR 및 MAX\_RETRANSMIT의 조합은 재전송 타이밍에 영향을 미치며, 이는 결국 구현 시 특정 정보 항목을 보관해야 하는 기간에 영향을 줍니다. 이러한 파생된 시간 값을 명확하게 참조할 수 있도록 다음과 같이 이름을 지정합니다.

- MAX\_TRANSMIT\_SPAN은 확인 가능 메시지의 첫 번째 전송부터 마지막 ​​재전송까지의 최대 시간입니다. 기본 전송 매개변수의 경우 값은 \(2+4+8+16\)\*1.5 = 45초 또는 더 일반적으로는 다음과 같습니다.

```text
         ACK_TIMEOUT * ((2 ** MAX_RETRANSMIT) - 1) * ACK_RANDOM_FACTOR
```

- MAX\_TRANSMIT\_WAIT는 확인 가능 메시지의 첫 번째 전송부터 보낸 사람이 확인 또는 재설정 수신을 포기할 때까지의 최대 시간입니다. 기본 전송 매개변수의 경우 값은 \(2+4+8+16+32\)\*1.5 = 93초 또는 더 일반적으로는 다음과 같습니다.

```text
         ACK_TIMEOUT * ((2 ** (MAX_RETRANSMIT + 1)) - 1) *
         ACK_RANDOM_FACTOR
```

또한 네트워크와 노드의 특성에 대해 몇 가지 가정이 필요합니다.

- MAX\_LATENCY는 데이터그램이 전송 시작부터 수신 완료까지 걸릴 것으로 예상되는 최대 시간입니다. 이 상수는 "임의로 2분으로 정의"된 \[RFC0793\]의 MSL\(Maximum Segment Lifetime\)과 관련이 있습니다\(\[RFC0793\] 용어집, 81페이지\). MAX\_LATENCY는 프로토콜이 잘 작동하는 상황을 설명하기 위한 것이 아니라 프로토콜이 보호해야 하는 최악의 상황을 설명하기 위한 것이므로 이 값이 반드시 MAX\_TRANSMIT\_WAIT보다 작을 필요는 없습니다. 또한 MAX\_LATENCY를 임의로 100초로 정의합니다. 대량 구성에 대해 합리적으로 현실적일 뿐만 아니라 TCP에 대한 역사적 선택에 가깝다는 점 외에도 이 값을 사용하면 메시지 ID 수명 타이머를 8비트\(초 단위로 측정 시\)로 표시할 수 있습니다. 이러한 계산에서는 전송 방향이 관련이 없다는 가정\(즉, 네트워크가 대칭이라는 가정\)이 없습니다. 단지 동일한 값이 양방향의 최대값으로 합리적으로 사용될 수 있다는 가정이 있을 뿐입니다. 그렇지 않은 경우 다음 계산은 약간 더 복잡해집니다.

- PROCESSING\_DELAY는 노드가 확인 가능 메시지를 승인으로 바꾸는 데 걸리는 시간입니다. 송신자가 시간 초과되기 전에 노드가 ACK 전송을 시도한다고 가정하므로 보수적으로 가정하여 ACK\_TIMEOUT과 동일하게 설정합니다.

- MAX\_RTT는 최대 왕복 시간입니다.

```text
         (2 * MAX_LATENCY) + PROCESSING_DELAY
```

이러한 값에서 프로토콜 작업과 관련된 다음 값을 파생할 수 있습니다.

- EXCHANGE\_LIFETIME은 확인 가능 메시지 전송 시작부터 승인이 더 이상 예상되지 않는 시간까지의 시간입니다. 즉, 메시지 교환에 대한 메시지 계층 정보가 제거될 수 있습니다. EXCHANGE\_LIFETIME에는 MAX\_TRANSMIT\_SPAN, MAX\_LATENCY 전달, PROCESSING\_DELAY 및 MAX\_LATENCY가 포함됩니다.

- 돌아 오는 길에. 마지막 대기 기간\(ACK\_TIMEOUT \* \(2 \*\* MAX\_RETRANSMIT\) 또는 MAX\_TRANSMIT\_SPAN과 MAX\_TRANSMIT\_WAIT의 차이\)이 MAX\_LATENCY보다 작도록 구성을 선택한 경우 MAX\_TRANSMIT\_WAIT를 고려할 필요가 없습니다. 이는 다음과 같이 선택 가능성이 높습니다. MAX\_LATENCY는 현실 세계에서 충족될 가능성이 없는 최악의 경우 값입니다. 이 경우 EXCHANGE\_LIFETIME은 다음과 같이 단순화됩니다.

```text
         MAX_TRANSMIT_SPAN + (2 * MAX_LATENCY) + PROCESSING_DELAY
```

- 또는 기본 전송 매개변수의 경우 247초입니다.

- NON\_LIFETIME은 확인 불가능한 메시지를 보낸 시점부터 해당 메시지 ID를 안전하게 재사용할 수 있는 시점까지의 시간입니다. NON 메시지의 다중 전송을 사용하지 않는 경우 해당 값은 MAX\_LATENCY, 즉 100초입니다. 그러나 CoAP 발신자는 특히 멀티캐스트 애플리케이션의 경우 NON 메시지를 여러 번 보낼 수 있습니다. 재사용 기간은 사양에 의해 제한되지 않지만 수신기에서 신뢰할 수 있는 중복 감지에 대한 기대는 MAX\_TRANSMIT\_SPAN의 시간 척도에 있습니다. 따라서 이 목적을 위해서는 다음 값을 사용하는 것이 더 안전합니다.

```text
         MAX_TRANSMIT_SPAN + MAX_LATENCY
```

- 또는 기본 전송 매개변수의 경우 145초입니다. 그러나 메시지 ID를 폐기하기 위해 단일 시간 초과 값을 사용하려는 구현에서는 EXCHANGE\_LIFETIME에 대해 더 큰 값을 안전하게 사용할 수 있습니다.

표 3에는 이 하위 섹션에 소개된 파생 매개변수와 기본값이 나열되어 있습니다.

```text
                   +-------------------+---------------+
                   | name              | default value |
                   +-------------------+---------------+
                   | MAX_TRANSMIT_SPAN |          45 s |
                   | MAX_TRANSMIT_WAIT |          93 s |
                   | MAX_LATENCY       |         100 s |
                   | PROCESSING_DELAY  |           2 s |
                   | MAX_RTT           |         202 s |
                   | EXCHANGE_LIFETIME |         247 s |
                   | NON_LIFETIME      |         145 s |
                   +-------------------+---------------+

                   Table 3: Derived Protocol Parameters
```

---
## **5.  Request/Response Semantics**

CoAP는 HTTP와 유사한 요청/응답 모델에 따라 작동합니다. "클라이언트" 역할의 CoAP 끝점은 하나 이상의 CoAP 요청을 "서버"에 보내고, 서버는 CoAP 응답을 보내 요청을 처리합니다. HTTP와 달리 요청과 응답은 이전에 설정된 연결을 통해 전송되지 않고 CoAP 메시지를 통해 비동기적으로 교환됩니다.

---
### **5.1.  Requests**

CoAP 요청은 리소스에 적용할 메서드, 리소스 식별자, 페이로드 및 인터넷 미디어 유형\(있는 경우\), 요청에 대한 선택적 메타데이터로 구성됩니다.

CoAP는 HTTP에 쉽게 매핑되는 GET, POST, PUT, DELETE의 기본 메서드를 지원합니다. 이는 HTTP와 동일한 안전\(검색만\) 및 멱등성\(동일한 효과로 여러 번 호출할 수 있음\) 속성을 갖습니다\(\[RFC2616\]의 섹션 9.1 참조\). GET 방법은 안전합니다. 따라서 검색 이외의 리소스에 대한 다른 작업을 수행해서는 안 됩니다. GET, PUT 및 DELETE 메소드는 멱등성이 있는 방식으로 수행되어야 합니다. POST의 효과는 원본 서버에 의해 결정되고 대상 리소스에 따라 달라지기 때문에 멱등성이 아닙니다. 일반적으로 새 리소스가 생성되거나 대상 리소스가 업데이트됩니다.

확인 가능 또는 확인 불가능 메시지의 CoAP 헤더에 있는 코드 필드를 메소드 코드로 설정하고 요청 정보를 포함하여 요청이 시작됩니다.

요청에 사용되는 방법은 섹션 5.8에 자세히 설명되어 있습니다.

---
### **5.2.  Responses**

요청을 수신하고 해석한 후 서버는 클라이언트 생성 토큰을 통해 요청과 일치하는 CoAP 응답으로 응답합니다\(섹션 5.3\). 이는 확인 가능한 메시지를 해당 승인과 일치시키는 메시지 ID와 다르다는 점에 유의하세요.

응답은 CoAP 헤더의 코드 필드가 응답 코드로 설정되어 식별됩니다. HTTP 상태 코드와 마찬가지로 CoAP 응답 코드는 요청을 이해하고 만족시키려는 시도의 결과를 나타냅니다. 이러한 코드는 섹션 5.9에 완전히 정의되어 있습니다. CoAP 헤더의 Code 필드에 설정되는 응답 코드 번호는 CoAP 응답 코드 레지스트리\(12.1.2절\)에 유지됩니다.

```text
                              0
                              0 1 2 3 4 5 6 7
                             +-+-+-+-+-+-+-+-+
                             |class|  detail |
                             +-+-+-+-+-+-+-+-+

                  Figure 9: Structure of a Response Code
```

8비트 응답 코드 번호의 상위 3비트는 응답 클래스를 정의합니다. 하위 5개 비트에는 분류 역할이 없습니다. 이는 전체 클래스에 대한 추가 세부 정보를 제공합니다\(그림 9\).

사양 및 프로토콜 진단을 사람이 읽을 수 있는 표기법으로 응답 코드를 포함한 CoAP 코드 번호가 "c.dd" 형식으로 문서화됩니다. 여기서 "c"는 클래스를 10진수로 나타내고 "dd"는 세부 사항을 2로 나타냅니다. -자리 십진수. 예를 들어, "Forbidden"은 4.03으로 기록됩니다. 이는 16진수 0x83\(4\*0x20+3\) 또는 10진수 131\(4\*32+3\)의 8비트 코드 값을 나타냅니다.

응답 코드에는 3가지 클래스가 있습니다.

2 - 성공: 요청이 성공적으로 수신되고 이해되었으며 수락되었습니다.

4 - 클라이언트 오류: 요청에 잘못된 구문이 포함되어 있거나 처리할 수 없습니다.

5 - 서버 오류: 서버가 명백히 유효한 요청을 이행하지 못했습니다.

응답 코드는 확장 가능하도록 설계되었습니다. 엔드포인트에서 인식되지 않는 클라이언트 오류 또는 서버 오류 클래스의 응답 코드는 해당 클래스의 일반 응답 코드\(각각 4.00 및 5.00\)와 동등한 것으로 처리됩니다. 그러나 성공을 나타내는 일반 응답 코드가 없으므로 끝점에서 인식되지 않는 Success 클래스의 응답 코드는 추가 세부 정보 없이 요청이 성공했는지 확인하는 데만 사용할 수 있습니다.

가능한 응답 코드는 섹션 5.9에 자세히 설명되어 있습니다.

응답은 다음 하위 섹션에 정의된 여러 가지 방법으로 보낼 수 있습니다.

---
#### **5.2.1.  Piggybacked**

가장 기본적인 경우 응답은 요청을 확인하는 승인 메시지에 직접 전달됩니다\(요청이 확인 가능 메시지에 전달되어야 함\). 이것을 "피기백 응답"이라고 합니다.

응답이 성공 또는 실패를 나타내는지 여부에 관계없이 승인 메시지에 응답이 반환됩니다. 실제로 응답은 승인 메시지에 피기백되며 응답을 반환하는 데 별도의 메시지가 필요하지 않습니다.

구현 참고 사항: 프로토콜은 응답을 피기백할지\(즉, 별도의 응답을 보낼지 여부\) 결정을 서버에 맡깁니다. 클라이언트는 둘 중 하나를 받을 준비가 되어 있어야 합니다. 구현 품질 수준에서는 서버가 가능할 때마다 피기백 코드를 구현하여 네트워크와 클라이언트 및 서버 모두에서 리소스를 절약할 것이라는 강한 기대가 있습니다.

---
#### **5.2.2.  Separate**

모든 경우에 피기백 응답을 반환하는 것이 불가능할 수도 있습니다. 예를 들어, 서버는 클라이언트가 요청 메시지를 반복적으로 재전송할 위험 없이 승인 메시지를 다시 보내기 위해 기다릴 수 있는 것보다 요청된 리소스의 표현을 얻는 데 더 오랜 시간이 필요할 수 있습니다\(섹션 4.8.2의 PROCESSING\_DELAY에 대한 논의도 참조\). 확인 불가능 메시지에 포함된 요청에 대한 응답은 항상 별도로 전송됩니다\(승인 메시지가 없기 때문에\).

서버에서 이를 구현하는 한 가지 방법은 리소스 표현을 얻으려는 시도를 시작하고 진행 중인 동안 승인 타이머를 시간 초과하는 것입니다. 피기백된 응답이 없을 것임을 미리 알고 있는 경우 서버는 즉시 승인을 보낼 수도 있습니다. 두 경우 모두 사실상 승인은 해당 요청이 나중에 실행될 것이라는 약속입니다.

서버가 마침내 리소스 표현을 얻으면 응답을 보냅니다. 이 메시지가 손실되지 않기를 바라는 경우 서버에서 클라이언트로 확인 가능한 메시지로 전송되고 클라이언트는 승인으로 응답하여 서버가 선택한 새 메시지 ID를 에코합니다. \(확인할 수 없는 메시지로 전송될 수도 있습니다. 섹션 5.2.3을 참조하세요.\)

서버가 별도의 응답을 사용하기로 선택하면 확인 가능 요청에 대한 승인을 비어 있음 메시지로 보냅니다. 서버가 빈 승인\(Empty Acknowledgement\)을 다시 보내면 다시 보내서는 안 됩니다.

클라이언트가 또 다른 동일한 요청을 재전송하더라도 다른 승인의 응답입니다. 재전송된 요청이 수신되면\(원래 승인이 지연되었기 때문에\) 또 다른 빈 승인이 전송되고 모든 응답은 별도의 응답으로 전송되어야 합니다.

그런 다음 서버가 확인 가능 응답을 보내는 경우 해당 응답에 대한 클라이언트의 승인도 빈 메시지\(요청이나 응답을 전달하지 않는 메시지\)여야 합니다. 서버는 일치하는 승인\(응답 코드 또는 페이로드를 자동으로 무시\) 또는 재설정 메시지에 대한 응답 재전송을 중지해야 합니다.

구현 참고 사항: 기본 데이터그램 전송이 순서를 보존하지 않을 수 있으므로 응답을 전달하는 확인 가능 메시지가 실제로 요청에 대한 승인 메시지 전후에 도착할 수 있습니다. 재전송 시퀀스를 종료할 목적으로 이는 승인 역할도 합니다. 또한 CoAP 프로토콜 자체는 여기에서 특별한 요구를 하지 않지만, 애플리케이션 관점에서 합리적인 시간 내에 응답이 올 것으로 기대됩니다. 연결 유지 메커니즘을 실행하도록 지시할 수 있는 기본 전송 프로토콜이 없기 때문에 요청자는 서버가 파괴되거나 응답을 보낼 수 없는 경우 CoAP의 재전송 타이머와 관련 없는 시간 제한을 설정하려고 할 수 있습니다.

---
#### **5.2.3.  Non-confirmable**

요청 메시지가 확인 불가능인 경우 응답도 확인 불가능 메시지로 반환되어야 합니다. 그러나 엔드포인트는 확인 가능 요청에 대한 응답으로 확인 불가능 응답\(빈 승인 메시지 앞 또는 뒤\)을 수신하거나 확인 불가능 요청에 대한 응답으로 확인 가능 응답을 수신할 준비가 되어 있어야 합니다.

---
### **5.3.  Request/Response Matching**

응답이 전송되는 방식에 관계없이 클라이언트가 요청에 포함하는 토큰과 해당 엔드포인트의 추가 주소 정보를 통해 요청과 일치됩니다.

---
#### **5.3.1.  Token**

토큰은 응답을 요청과 일치시키는 데 사용됩니다. 토큰 값은 0\~8바이트의 시퀀스입니다. \(모든 메시지는 길이가 0이더라도 토큰을 전달합니다.\) 모든 요청은 서버가 결과 응답에 \(수정 없이\) 반드시 반영해야 하는 클라이언트 생성 토큰을 전달합니다.

토큰은 동시 요청을 구별하기 위한 클라이언트-로컬 식별자로 사용하기 위한 것입니다\(섹션 5.3 참조\). "요청 ID"라고 불릴 수도 있습니다.

클라이언트는 주어진 소스/대상 엔드포인트 쌍에 현재 사용 중인 토큰이 고유한 방식으로 토큰을 생성해야 합니다\(SHOULD\). \(클라이언트 구현은 매번 다른 엔드포인트\(예: 다른 소스 포트 번호\)를 사용하는 경우 모든 요청에 ​​대해 동일한 토큰을 사용할 수 있습니다.\) 예를 들어 대상에 사용 중인 다른 토큰이 없는 경우 빈 토큰 값이 적합합니다. 또는 요청이 대상별로 순차적으로 이루어지고 피기백된 응답을 받는 경우입니다. 그러나 이를 충족하기 위한 여러 가능한 구현 전략이 있습니다.

전송 계층 보안\(섹션 9\)을 사용하지 않고 요청을 보내는 클라이언트는 응답 스푸핑\(섹션 11.4\)을 방지하기 위해 중요하지 않은 무작위 토큰을 사용해야 합니다. 이러한 토큰의 보호적 사용으로 인해 최대 8바이트 크기가 허용됩니다. 토큰에 사용되는 무작위 구성 요소의 실제 크기는 클라이언트의 보안 요구 사항과 응답 스푸핑으로 인한 위협 수준에 따라 다릅니다. 일반 인터넷에 연결된 클라이언트는 최소 32비트의 임의성을 사용해야 하며, 인터넷에 직접 연결되지 않는다고 해서 반드시 스푸핑에 대한 충분한 보호가 되지는 않는다는 점을 명심해야 합니다. \(메시지 ID는 일반적으로 순차적으로 할당되므로\(예: 추측 가능하고 별도의 응답을 스푸핑하여 우회할 수 있으므로\) 보호 기능을 거의 추가하지 않습니다.\) 토큰 길이를 최적화하려는 클라이언트는 진행 중인 공격 수준을 추가로 감지하기를 원할 수 있습니다. \(예: 수신 메시지의 최근 토큰 불일치를 집계하여\) 토큰 길이를 적절하게 상향 조정합니다. \[RFC4086\]에서는 보안에 대한 무작위성 요구 사항을 논의합니다.

자신이 생성하지 않은 토큰을 수신하는 엔드포인트는 토큰을 불투명한 것으로 처리해야 하며 해당 콘텐츠나 구조에 대해 어떤 가정도 하지 않아야 합니다.

---
#### **5.3.2.  Request/Response Matching Rules**

요청에 대한 응답을 일치시키는 정확한 규칙은 다음과 같습니다.

1. 응답의 소스 엔드포인트는 원래 요청의 대상 엔드포인트와 동일해야 합니다.

1. 피기백 응답에서는 확인 가능한 요청의 메시지 ID와 승인이 일치해야 하며, 응답의 토큰과 원래 요청이 일치해야 합니다. 별도의 응답에서는 응답과 원래 요청의 토큰만 일치해야 합니다.

응답을 전달하는 메시지가 예상치 못한 경우\(클라이언트가 식별된 엔드포인트, 주소가 지정된 엔드포인트 및/또는 지정된 토큰을 사용하여 응답을 기다리고 있지 않은 경우\) 응답이 거부됩니다\(섹션 4.2 및 4.3\).

구현 참고 사항: CON 메시지로 응답을 받은 클라이언트는 ACK를 보낸 직후 메시지 상태를 정리할 수 있습니다. 해당 ACK가 손실되고 서버가 CON을 재전송하는 경우 클라이언트는 더 이상 이 응답을 연관시킬 수 있는 상태가 없어 재전송이 예상치 못한 메시지가 될 수 있습니다. 클라이언트는 더 이상 재전송을 받지 않도록 재설정 메시지를 보낼 가능성이 높습니다. 이 동작은 정상적인 현상이며 오류가 아닙니다. \(상태 메모리 사용이 적극적으로 최적화되지 않은 클라이언트는 여전히 두 번째 CON을 재전송으로 식별하는 메시지 상태를 갖게 됩니다. 실제로 서버 \[OBSERVE\]에서 더 많은 메시지를 기대하는 클라이언트는 어떤 경우에도 상태를 유지해야 합니다.\)

---
### **5.4.  Options**

요청과 응답 모두 하나 이상의 옵션 목록을 포함할 수 있습니다. 예를 들어 요청의 URI는 여러 옵션으로 전송되며 HTTP의 HTTP 헤더에 전달되는 메타데이터도 옵션으로 제공됩니다.

CoAP는 요청과 응답 모두에 사용되는 단일 옵션 세트를 정의합니다.

```text
   o  Content-Format

   o  ETag

   o  Location-Path

   o  Location-Query

   o  Max-Age

   o  Proxy-Uri

   o  Proxy-Scheme

   o  Uri-Host

   o  Uri-Path

   o  Uri-Port

   o  Uri-Query

   o  Accept

   o  If-Match

   o  If-None-Match

   o  Size1
```

해당 속성과 함께 이러한 옵션의 의미는 섹션 5.10에 자세히 정의되어 있습니다.

모든 옵션과 모든 메소드 및 응답 코드에 사용하도록 정의된 것은 아닙니다. 방법 및 응답 코드에 대해 가능한 옵션은 각각 섹션 5.8 및 5.9에 정의되어 있습니다. 메소드 또는 응답 코드에 대해 옵션이 정의되지 않은 경우 발신자가 이를 포함해서는 안 되며 수신자가 인식할 수 없는 옵션처럼 취급해야 합니다.

---
#### **5.4.1.  Critical/Elective**

옵션은 "필수" 또는 "선택"이라는 두 가지 클래스 중 하나로 분류됩니다. 이들 간의 차이점은 엔드포인트에서 인식되지 않는 옵션을 처리하는 방법입니다.

- 수신 시 인식되지 않는 "선택" 클래스 옵션은 자동으로 무시되어야 합니다.

- 확인 가능한 요청에서 발생하는 "중요" 클래스의 인식되지 않은 옵션은 4.02\(잘못된 옵션\) 응답의 반환을 유발해야 합니다. 이 응답에는 인식할 수 없는 옵션을 설명하는 진단 페이로드가 포함되어야 합니다\(섹션 5.5.2 참조\).

- 확인 가능한 응답에서 발생하거나 승인에 피기백된 클래스 "중요"의 인식되지 않은 옵션은 응답이 거부되도록 해야 합니다\(섹션 4.2\).

- 확인 불가능 메시지에서 발생하는 "중요" 클래스의 인식되지 않은 옵션은 메시지가 거부되도록 해야 합니다\(섹션 4.3\).

중요하든 선택적이든 옵션은 결코 "필수"가 아닙니다\(항상 선택 사항임\). 이러한 규칙은 구현이 이해하지 못하거나 구현하지 않는 옵션 처리를 중지할 수 있도록 정의됩니다.

비프록시 엔드포인트에는 중요/선택 규칙이 적용됩니다. 프록시는 섹션 5.7에 정의된 대로 Unsafe/Safe-to-Forward 클래스를 기반으로 옵션을 처리합니다.

---
#### **5.4.2.  Proxy Unsafe or Safe-to-Forward and NoCacheKey**

옵션이 중요 또는 선택으로 표시되는 것 외에도 프록시가 옵션을 인식하지 못하는 경우 옵션을 처리하는 방법에 따라 옵션이 분류됩니다. 이 목적을 위해 옵션은 전달하기에 안전하지 않음\(UnSafe가 설정됨\) 또는 전달하기에 안전함\(UnSafe가 지워짐\)으로 간주될 수 있습니다.

또한 Safe-to-Forward로 표시된 옵션의 경우 옵션 번호는 요청 시 캐시 키\(섹션 5.6\)의 일부로 포함될 것인지 여부를 나타냅니다. NoCacheKey 비트 중 일부가 0이면 0입니다. 모든 NoCacheKey 비트가 1이면 그렇지 않습니다\(섹션 5.4.6 참조\).

참고: 캐시 키 표시는 지정된 옵션을 요청 옵션으로 구현하지 않고 대신 안전하지 않음/전달 안전 표시에만 의존하는 프록시에만 관련됩니다. 예를 들어, ETag의 경우 요청 옵션을 Cache-Key의 일부로 실제로 사용하는 것은 매우 비효율적이지만, ETag가 프록시에 의해 구현되지 않은 경우 할 수 있는 최선의 방법입니다. 요청 옵션의 존재. ETag 요청 옵션을 구현하는 더 유용한 프록시는 ETag를 Cache-Key의 일부로 사용하지 않는 것입니다.

- NoCacheKey는 8개 코드 포인트 중 1개만 NoCacheKey로 인증되도록 3비트로 표시되며, 8개 코드 포인트 중 7개는 가능성이 더 높은 것으로 보입니다.

이러한 클래스와 관련된 프록시 동작은 섹션 5.7에 정의되어 있습니다.

---
#### **5.4.3.  Length**

옵션 값은 종종 상한 및 하한의 형태로 특정 길이를 갖도록 정의됩니다. 요청의 옵션 값 길이가 정의된 범위를 벗어나는 경우 해당 옵션은 인식할 수 없는 옵션처럼 처리되어야 합니다\(섹션 5.4.1 참조\).

---
#### **5.4.4.  Default Values**

옵션은 기본값을 갖도록 정의될 수 있습니다. 옵션 값이 이 기본값이 되도록 의도된 경우 해당 옵션은 메시지에 포함되어서는 안 됩니다. 옵션이 없으면 기본값을 가정해야 합니다.

중요한 옵션에 기본값이 있는 경우 이는 중요한 옵션을 인식하지 못하는 구현과 이 부재를 기본값의 존재로 해석하는 구현 모두에서 메시지에 옵션이 없는 경우 적절하게 처리될 수 있는 방식으로 선택됩니다. 옵션에 대한 값입니다.

---
#### **5.4.5.  Repeatable Options**

일부 옵션의 정의는 해당 옵션이 반복 가능함을 지정합니다. 반복 가능한 옵션은 메시지에 한 번 이상 포함될 수 있습니다. 반복할 수 없는 옵션은 메시지에 두 번 이상 포함되어서는 안 됩니다.

메시지에 해당 옵션이 정의된 것보다 더 많이 발생하는 옵션이 포함되어 있는 경우 메시지에 나중에 나타나는 각 추가 옵션 발생은 인식할 수 없는 옵션처럼 처리되어야 합니다\(섹션 5.4.1 참조\).

---
#### **5.4.6.  Option Numbers**

옵션은 몇 가지 추가적인 의미 정보를 제공하는 옵션 번호로 식별됩니다. 예를 들어 홀수는 중요한 옵션을 나타내고 짝수는 선택 옵션을 나타냅니다. 이는 단순한 관례가 아니라 프로토콜의 기능입니다. 옵션이 선택적인지 중요한지는 해당 옵션 번호가 짝수인지 홀수인지에 따라 전적으로 결정됩니다.

보다 일반적으로 말하면, 옵션 번호는 옵션이 중요하거나 선택적이거나, 안전하지 않거나 전달하기에 안전한지 여부를 나타내고, 전달하기에 안전한 경우에는 캐시 키 표시를 제공하기 위해 비트 마스크로 구성됩니다. 다음 그림과 같이. 다음 텍스트에서 비트 마스크는 부호 없는 정수 표현에서 옵션 번호의 최하위 바이트에 적용되는 단일 바이트로 표현됩니다. 비트 7\(최하위 비트\)이 1이면 옵션은 중요\(0이면 선택\)입니다. 비트 6이 1인 경우 옵션은 안전하지 않습니다\(0인 경우에도 Safe-to-Forward\). 비트 6이 0일 때, 즉 옵션이 안전하지 않은 경우, 비트 3-5가 모두 1로 설정된 경우에만 캐시 키\(NoCacheKey\)가 아닙니다. 다른 모든 비트 조합은 실제로 캐시 키임을 의미합니다. 이러한 옵션 클래스는 다음 섹션에서 설명됩니다.

```text
                       0   1   2   3   4   5   6   7
                     +---+---+---+---+---+---+---+---+
                     |           | NoCacheKey| U | C |
                     +---+---+---+---+---+---+---+---+

          Figure 10: Option Number Mask (Least Significant Byte)
```

엔드포인트는 옵션 번호 "onum"의 특성을 도출하기 위해 그림 11의 C 코드와 동등한 코드를 사용할 수 있습니다.

```text
   Critical = (onum & 1);
   UnSafe = (onum & 2);
   NoCacheKey = ((onum & 0x1e) == 0x1c);

       Figure 11: Determining Characteristics from an Option Number
```

이 문서에 정의된 옵션의 옵션 번호는 "CoAP 옵션 번호" 레지스트리\(섹션 12.2\)에 나열되어 있습니다.

---
### **5.5.  Payloads and Representations**

요청과 응답 모두 각각 메서드 또는 응답 코드에 따라 페이로드를 포함할 수 있습니다. 메소드 또는 응답 코드가 페이로드를 갖도록 정의되지 않은 경우 발신자는 이를 포함해서는 안 되며 수신자는 이를 무시해야 합니다.

---
#### **5.5.1.  Representation**

성공을 나타내는 요청 또는 응답의 페이로드는 일반적으로 리소스 표현\("리소스 표현"\) 또는 요청된 작업의 결과\("작업 결과"\)입니다. 해당 형식은 Content-Format 옵션에서 제공하는 인터넷 미디어 유형 및 콘텐츠 코딩에 따라 지정됩니다. 이 옵션이 없으면 기본값이 가정되지 않으며 형식은 애플리케이션에서\(예: 애플리케이션 컨텍스트에서\) 추론되어야 합니다. 페이로드 "스니핑"은 콘텐츠 유형이 지정되지 않은 경우에만 시도해야 합니다.

구현 참고 사항: 구현 품질 수준에서는 가능할 때마다 Content-Format 표시가 리소스 표현과 함께 제공될 것이라는 강한 기대가 있습니다. 이는 프로토콜 요구 사항이 아니기 때문에 "SHOULD" 수준 요구 사항이 아니며, 이 기대 사항이 위반될 수 있는 경우를 정확히 설명하는 것도 어렵습니다.

클라이언트 또는 서버 오류를 나타내는 응답의 경우 페이로드는 Content-Format 옵션이 제공된 경우에만 요청된 작업의 결과를 나타내는 것으로 간주됩니다. 이 옵션이 없으면 페이로드는 진단 페이로드입니다\(섹션 5.5.2\).

---
#### **5.5.2.  Diagnostic Payload**

Content-Format 옵션이 지정되지 않은 경우 클라이언트 또는 서버 오류를 나타내는 응답 페이로드는 오류 상황을 설명하는 사람이 읽을 수 있는 간단한 진단 메시지입니다. 이 진단 메시지는 UTF-8 \[RFC3629\], 특히 Net-Unicode 형식 \[RFC5198\]을 사용하여 인코딩되어야 합니다.

메시지는 HTTP 상태 표시줄의 Reason-Phrase와 유사합니다. 이는 최종 사용자를 위한 것이 아니라 디버깅 중에 현재 영어 사양의 맥락에서 해석해야 하는 소프트웨어 엔지니어를 위한 것입니다. 따라서 언어 태그 지정을 위한 메커니즘이 필요하거나 제공되지 않습니다. HTTP에서 일반적인 것과는 달리, 응답 코드 외에 추가 정보가 없으면 페이로드는 비어 있어야 합니다.

---
#### **5.5.3.  Selected Representation**

모든 응답이 요청에 의해 처리된 리소스의 표현을 제공하는 페이로드를 전달하는 것은 아닙니다. 그러나 실제로 포함되었는지 여부에 관계없이 응답과 관련하여 그러한 표현을 참조할 수 있는 것이 때로는 유용합니다.

해당 요청이 GET 메서드를 사용하고 모든 조건부 요청 옵션을 제외했다면 성공적인 응답에서 선택되었을 대상 리소스의 현재 표현을 참조하기 위해 "선택된 표현"이라는 용어를 사용합니다\(섹션 5.10.8\).

특정 응답 옵션은 선택한 표현에 대한 메타데이터를 제공하며, 이는 일부 상태 변경 메서드에 대한 응답에 대한 메시지에 포함된 표현과 다를 수 있습니다. 본 사양에 정의된 응답 옵션 중 ETag 응답 옵션\(Section 5.10.6\)만 선택한 표현에 대한 메타데이터로 정의됩니다.

---
#### **5.5.4.  Content Negotiation**

서버는 여러 표현 형식 중 하나로 리소스에 대한 표현을 제공할 수 있습니다. 고객으로부터 추가 정보가 없으면 고객이 선호하는 형식으로 표현을 제공합니다.

요청에서 Accept 옵션\(섹션 5.10.4\)을 사용하여 클라이언트는 수신을 선호하는 콘텐츠 형식을 나타낼 수 있습니다.

---
### **5.6.  Caching**

CoAP 엔드포인트는 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄이기 위해 응답을 캐시할 수 있습니다.

CoAP에서 캐싱의 목표는 이전 응답 메시지를 재사용하여 현재 요청을 만족시키는 것입니다. 어떤 경우에는 네트워크 요청 없이 저장된 응답을 재사용하여 대기 시간과 네트워크 왕복 시간을 줄일 수 있습니다. 이 목적을 위해 "신선도" 메커니즘이 사용됩니다\(섹션 5.6.1 참조\). 새로운 요청이 필요한 경우에도 요청을 충족하기 위해 이전 응답의 페이로드를 재사용하는 것이 가능한 경우가 많으므로 네트워크 대역폭 사용량이 줄어듭니다. 이 목적을 위해 "검증" 메커니즘이 사용됩니다\(섹션 5.6.2 참조\).

HTTP와 달리 CoAP 응답의 캐시 가능성은 요청 방법에 따라 달라지지 않고 응답 코드에 따라 달라집니다. 각 응답 코드의 캐시 가능성은 섹션 5.9의 응답 코드 정의에 따라 정의됩니다. 성공을 나타내며 엔드포인트에서 인식되지 않는 응답 코드는 캐시되어서는 안 됩니다.

제시된 요청의 경우 CoAP 엔드포인트는 다음을 제외하고 저장된 응답을 사용해서는 안 됩니다.

- 제시된 요청 방법과 저장된 응답 일치를 얻는 데 사용된 방법,

- 제시된 요청의 옵션과 저장된 응답\(요청 URI 포함\)을 얻는 데 사용된 요청의 옵션 간의 모든 옵션이 일치합니다. 단, NoCacheKey\(섹션 5.4\)로 표시된 요청 옵션이 일치할 필요는 없습니다. 캐시에 의해 인식되고 지정된 캐시 동작\(예: 섹션 5.10.6에 설명된 ETag 요청 옵션, 섹션 5.4.2 참조\)과 관련하여 완전히 해석됩니다.

- 저장된 응답은 아래 정의된 대로 신선하거나 성공적으로 검증되었습니다.

캐시 항목 일치에 사용되는 요청 옵션 세트를 집합적으로 "캐시 키"라고도 합니다. coap 및 coap 이외의 URI 체계의 경우 요청 URI를 구성하는 옵션의 일치는 URI 체계에 특정한 규칙에 따라 수행될 수 있습니다.

---
#### **5.6.1.  Freshness Model**

캐시에서 응답이 "신선한" 경우 원본 서버에 연결하지 않고도 후속 요청을 충족하는 데 사용할 수 있으므로 효율성이 향상됩니다.

신선도를 결정하는 메커니즘은 원본 서버가 Max-Age 옵션\(섹션 5.10.5 참조\)을 사용하여 향후 명시적인 만료 시간을 제공하는 것입니다. Max-Age 옵션은 응답의 수명이 지정된 시간\(초\)보다 길어지면 응답이 최신이 아닌 것으로 간주됨을 나타냅니다.

Max-Age 옵션의 기본값은 60입니다. 따라서 캐시 가능한 응답에 이 옵션이 없으면 응답 기간이 60초를 초과하면 응답이 최신이 아닌 것으로 간주됩니다. 원본 서버가 캐싱을 방지하려는 경우 값이 0초인 Max-Age 옵션을 명시적으로 포함해야 합니다.

클라이언트에 새로 저장된 응답이 있고 저장된 응답에 대한 요청과 일치하는 새 요청을 생성하는 경우 새 응답은 이전 응답을 무효화합니다.

---
#### **5.6.2.  Validation Model**

엔드포인트에 GET 요청에 대한 하나 이상의 저장된 응답이 있지만 그 중 어떤 것도 사용할 수 없는 경우\(예: 최신이 아니기 때문에\) GET 요청에서 ETag 옵션\(섹션 5.10.6\)을 사용하여 원본을 제공할 수 있습니다. 서버는 사용할 저장된 응답을 선택하고 최신 상태로 업데이트할 수 있는 기회를 제공합니다. 이 프로세스를 저장된 응답의 "검증" 또는 "재검증"이라고 합니다.

그러한 요청을 보낼 때 엔드포인트는 적용 가능한 각 저장된 응답의 엔터티 태그를 지정하는 ETag 옵션을 추가해야 합니다.

2.03\(유효\) 응답은 응답의 ETag 옵션에 제공된 엔터티 태그로 식별된 저장된 응답이 섹션 5.9.1.3에 설명된 대로 업데이트 후 재사용될 수 있음을 나타냅니다.

다른 응답 코드는 요청에 지정된 저장된 응답 중 어느 것도 적합하지 않음을 나타냅니다. 대신, 응답은 요청을 만족시키는 데 사용되어야 하며 저장된 응답을 대체할 수 있습니다.

---
### **5.7.  Proxying**

프록시는 CoAP 클라이언트가 대신 요청을 수행하도록 작업할 수 있는 CoAP 엔드포인트입니다. 예를 들어, 요청을 할 수 없는 경우 또는 응답 시간과 네트워크 대역폭 또는 에너지 소비를 줄이기 위해 캐시에서 응답을 서비스하는 경우에 유용할 수 있습니다.

제한된 RESTful 환경의 전체 아키텍처에서 프록시는 상당히 다른 용도로 사용될 수 있습니다. 프록시는 클라이언트가 명시적으로 선택할 수 있으며, 이 역할을 "전달 프록시"라고 합니다. 원본 서버를 대신하기 위해 프록시를 삽입할 수도 있는데, 이 역할을 "역방향 프록시"라고 합니다. 이러한 구별과 직교하여 프록시는 CoAP 요청에서 CoAP 요청으로 매핑하거나\(CoAP-CoAP 프록시\) 다른 프로토콜 간에 변환할 수 있습니다\("교차 프록시"\). 이러한 용어의 전체 정의는 섹션 1.2에 나와 있습니다.

참고: 이 사양의 용어는 더 넓은 웹 애플리케이션 환경에서 사용되는 용어와 문화적으로 호환되도록 선택되었으며 모든 세부 사항이 일치할 필요는 없습니다\(제한된 RESTful 환경과 관련이 없을 수도 있음\). 용어의 구성 요소\(예: "정방향", "역방향" 또는 "교차"\)에 너무 많은 의미를 부여해서는 안 됩니다.

- HTTP 프록시는 HTTP 프록시 역할을 하는 것 외에도 종종 전송 프로토콜 프록시 기능\("CONNECT"\)을 제공하여 프록시를 통해 종단 간 전송 계층 보안을 활성화합니다. 제한된 RESTful 환경에서는 UDP 패킷 전달이 큰 가치가 없을 가능성이 높기 때문에 이 사양에서는 CoAP-CoAP 프록시에 대해 그러한 기능이 정의되지 않았습니다. 교차 프록시의 경우 섹션 10.2.7을 참조하세요.

클라이언트가 보안 URI 체계\(예: "coaps" 또는 "https"\)를 사용하는 요청을 만들기 위해 프록시를 사용하는 경우, 프록시에 대한 요청은 동등한 하위 계층 보안이 사용되는 경우를 제외하고 DTLS를 사용하여 전송되어야 합니다. 클라이언트와 프록시 사이의 다리.

---
#### **5.7.1.  Proxy Operation**

일반적으로 프록시에는 클라이언트로부터 받은 요청을 기반으로 대상에 보내는 요청에 대한 잠재적인 요청 매개 변수를 결정하는 방법이 필요합니다. 이 방법은 정방향 프록시에 대해 완전히 지정되어 있지만 역방향 프록시에 대한 특정 구성에 따라 달라질 수 있습니다. 특히 역방향 프록시의 클라이언트는 일반적으로 대상에 대한 위치 지정자를 나타내지 않습니다.

역방향 프록시에서는 어떤 형태로든 네임스페이스 변환이 필요합니다. 그러나 프록시 작동의 일부 측면은 모든 형태에 공통됩니다.

프록시가 캐시를 사용하지 않는 경우 번역된 요청을 결정된 대상으로 전달하기만 하면 됩니다. 그렇지 않고, 캐시를 사용하지만 번역된 요청과 일치하고 새로운 것으로 간주되는 저장된 응답이 없으면 섹션 5.6에 따라 캐시를 새로 고쳐야 합니다. 프록시가 인식하는 요청 옵션의 경우 해당 옵션이 캐시된 값을 찾는 데 사용되는 키의 일부로 작동하도록 의도되었는지 여부를 알고 있습니다. 예를 들어, 서로 다른 Uri-Path 값에 대한 요청은 서로 다른 리소스를 다루기 때문에 Uri-Path 값은 항상 Cache-Key의 일부인 반면, Token 값은 결코 Cache-Key의 일부가 아닙니다. 프록시가 인식하지 못하지만 옵션 번호에 Safe-to-Forward로 표시된 옵션의 경우 옵션은 Cache-Key에 포함할지\(NoCacheKey가 모두 설정되지 않음\) 여부\(NoCacheKey가 모두 설정됨\)도 나타냅니다. 세트\). \(인식되지 않고 안전하지 않음으로 표시된 옵션은 4.02 잘못된 옵션으로 이어집니다.\)

대상에 대한 요청이 시간 초과되면 5.04\(게이트웨이 시간 초과\) 응답이 반환되어야 합니다. 대상에 대한 요청이 프록시에서 처리할 수 없는 응답을 반환하는 경우\(예: 인식할 수 없는 중요 옵션 또는 메시지 형식 오류로 인해\) 5.02\(잘못된 게이트웨이\) 응답이 반환되어야 합니다. 그렇지 않으면 프록시가 클라이언트에 응답을 반환합니다.

응답이 캐시에서 생성된 경우 생성된\(또는 묵시적인\) Max-Age 옵션은 리소스 표현이 캐시에서 소비한 시간을 고려하여 서버가 원래 설정한 max-age를 확장해서는 안 됩니다. 예를 들어 Max-Age 옵션은 다음 공식을 사용하여 각 응답에 대한 프록시로 조정될 수 있습니다.

```text
      proxy-max-age = original-max-age - cache-age
```

예를 들어, 20초 전에 새로 고쳐졌고 원래 Max-Age가 60초인 프록시 리소스에 대한 요청이 이루어진 경우 해당 리소스의 프록시 최대 수명은 이제 40초입니다. 원본 서버에서 오는 도중에 발생할 수 있는 네트워크 지연을 고려하여 프록시는 제공된 max-age 값을 보수적으로 유지해야 합니다.

프록시 요청에 있는 모든 옵션은 반드시 프록시에서 처리되어야 합니다. 프록시에서 인식되지 않는 요청의 안전하지 않은 옵션은 프록시에서 반환되는 4.02\(잘못된 옵션\) 응답으로 이어져야 합니다. CoAP-CoAP 프록시는 인식하지 못하는 모든 Safe-to-Forward 옵션을 원본 서버에 전달해야 합니다. 비슷하게,

CoAP-CoAP 프록시 서버에서 인식되지 않는 응답의 안전하지 않은 옵션은 5.02\(잘못된 게이트웨이\) 응답으로 이어져야 합니다. 다시 말하지만, 인식되지 않은 Safe-to-Forward 옵션은 반드시 전달되어야 합니다.

CoAP와 HTTP 간의 교차 프로토콜 프록시에 대한 추가 고려 사항은 섹션 10에서 논의됩니다.

---
#### **5.7.2.  Forward-Proxies**

CoAP는 원본 서버에 대한 요청과 전달 프록시를 통해 이루어진 요청을 구별합니다. 전달 프록시에 대한 CoAP 요청은 전달 프록시 엔드포인트에 대한 일반적인 확인 가능 또는 확인 불가능 요청으로 이루어지지만 요청 URI를 다른 방식으로 지정합니다. 프록시 요청의 요청 URI는 프록시에서 문자열로 지정됩니다. -Uri 옵션\(섹션 5.10.2 참조\), 원본 서버에 대한 요청의 요청 URI는 Uri-Host, Uri-Port, Uri-Path 및 Uri-Query 옵션\(섹션 5.10.1 참조\)으로 분할됩니다. . 또는 프록시 요청의 URI를 프록시 구성표 옵션과 언급된 분할 옵션에서 조합할 수 있습니다.

엔드포인트에 프록시 요청이 이루어지고 엔드포인트가 요청 URI에 대한 프록시 역할을 할 의사가 없거나 작동할 수 없는 경우 5.05\(프록시 지원 안 됨\) 응답을 반환해야 합니다. 권한\(호스트 및 포트\)이 프록시 끝점 자체를 식별하는 것으로 인식되면\(섹션 5.10.2 참조\) 요청은 로컬\(프록시되지 않은\) 요청으로 처리되어야 합니다.

프록시 요청을 다른 프록시로 전달하도록 프록시가 구성되지 않은 한, 요청을 다음과 같이 변환해야 합니다. 요청 URI의 체계는 발신 프로토콜과 세부 정보를 정의합니다\(예: CoAP는 "coap" 체계에 대해 UDP를 통해 사용되며 CoAP-CoAP 프록시의 경우 원본 서버의 IP 주소와 포트는 요청 URI의 권한 구성 요소에 의해 결정되고 요청 URI는 디코딩되어 Uri-Host로 분할됩니다. , Uri-Port, Uri-Path 및 Uri-Query 옵션. 이는 Proxy-Uri 또는 Proxy-Scheme 옵션을 사용하므로 원본 서버로 전달되지 않습니다.

---
#### **5.7.3.  Reverse-Proxies**

역방향 프록시는 Proxy-Uri 또는 Proxy-Scheme 옵션을 사용하지 않지만 요청 정보 및 구성 정보에서 요청 대상\(다음 홉\)을 결정해야 합니다. 예를 들어 역방향 프록시는 리소스 검색을 통해 리소스의 존재를 알게 된 후 다양한 리소스를 자신의 리소스인 것처럼 제공할 수 있습니다. 역방향 프록시는 이러한 리소스를 식별하는 URI에 대한 네임스페이스를 자유롭게 구축할 수 있습니다. 역방향 프록시는 클라이언트에게 더 많은 것을 제공하는 네임스페이스를 구축할 수도 있습니다.

예를 들어 제공되는 리소스의 URI 경로에 호스트 식별자와 포트 번호를 삽입하여 요청이 어디로 가는지 제어합니다.

응답을 처리할 때 역방향 프록시는 클라이언트에 제공되는 하나의 리소스에서 서로 다른 소스의 ETag 옵션 값이 혼합되지 않도록 주의해야 합니다. 대부분의 경우 ETag는 변경되지 않고 전달될 수 있습니다. 역방향 프록시에서 제공하는 리소스와 다양한 원본 서버에서 제공하는 리소스의 매핑이 고유하지 않은 경우 역방향 프록시는 새 ETag를 생성하여 이 옵션의 의미가 제대로 유지되는지 확인해야 할 수 있습니다.

---
### **5.8.  Method Definitions**

이 섹션에서는 각 메서드와 해당 동작이 정의됩니다. 인식되지 않거나 지원되지 않는 메소드 코드가 있는 요청은 4.05\(허용되지 않는 메소드\) 피기백 응답을 생성해야 합니다.

---
#### **5.8.1.  GET**

GET 메서드는 요청 URI로 식별된 리소스에 현재 해당하는 정보에 대한 표현을 검색합니다. 요청에 Accept 옵션이 포함된 경우 이는 선호하는 응답 콘텐츠 형식을 나타냅니다. 요청에 ETag 옵션이 포함된 경우 GET 메서드는 ETag의 유효성을 검사하고 유효성 검사에 실패한 경우에만 표현이 전송되도록 요청합니다. 성공하면 2.05\(콘텐츠\) 또는 2.03\(유효\) 응답 코드가 응답에 있어야 합니다.

GET 메서드는 안전하고 멱등성을 갖습니다.

---
#### **5.8.2.  POST**

POST 메소드는 요청에 포함된 표현이 처리되도록 요청합니다. POST 메소드에 의해 수행되는 실제 기능은 원본 서버에 의해 결정되며 대상 리소스에 따라 달라집니다. 일반적으로 새 리소스가 생성되거나 대상 리소스가 업데이트됩니다.

서버에서 리소스가 생성된 경우 서버에서 반환된 응답은 2.01\(생성됨\) 응답 코드를 가져야 하며 하나 이상의 위치 경로 및/또는 위치 쿼리 시퀀스에 새 리소스의 URI를 포함해야 합니다. 옵션\(섹션 5.10.7\). POST가 성공했지만 서버에 새 리소스가 생성되지 않는 경우 응답에는 2.04\(변경된\) 응답 코드가 있어야 합니다. POST가 성공하고 대상 리소스가 삭제되는 경우 응답에는 2.02\(삭제됨\) 응답 코드가 있어야 합니다. POST는 안전하지도 멱등성도 아닙니다.

---
#### **5.8.3.  PUT**

PUT 메서드는 요청 URI로 식별된 리소스가 포함된 표현으로 업데이트되거나 생성되도록 요청합니다. 표현 형식은 제공된 경우 Content-Format 옵션에 제공된 미디어 유형 및 콘텐츠 코딩에 의해 지정됩니다.

요청 URI에 리소스가 존재하는 경우 동봉된 표현은 해당 리소스의 수정된 버전으로 간주되어야 하며 2.04\(변경된\) 응답 코드가 반환되어야 합니다. 리소스가 존재하지 않으면 서버는 해당 URI를 사용하여 새 리소스를 생성하여 2.01\(생성됨\) 응답 코드를 생성할 수 있습니다. 리소스를 생성하거나 수정할 수 없는 경우 적절한 오류 응답 코드가 전송되어야 합니다.

요청에 If-Match\(섹션 5.10.8.1 참조\) 또는 If-None-Match\(섹션 5.10.8.2 참조\) 옵션을 포함하여 PUT에 대한 추가 제한을 적용할 수 있습니다.

PUT은 안전하지 않지만 멱등성을 갖습니다.

---
#### **5.8.4.  DELETE**

DELETE 메소드는 요청 URI로 식별된 리소스를 삭제하도록 요청합니다. 2.02\(삭제\) 응답 코드는 성공 시 또는 요청 전에 리소스가 존재하지 않은 경우에 사용해야 합니다.

DELETE는 안전하지 않지만 멱등적입니다.

---
### **5.9.  Response Code Definitions**

응답에 필요한 옵션을 포함하여 각 응답 코드는 아래에 설명되어 있습니다. 적절한 경우 HTTP \[RFC2616\]의 관련 응답 코드와 관련하여 일부 코드가 지정됩니다. 이는 그러한 관계가 섹션 10에 지정된 HTTP 매핑을 수정한다는 의미는 아닙니다.

---
#### **5.9.1.  Success 2.xx**

이 응답 코드 클래스는 클라이언트 요청이 성공적으로 수신되고, 이해되고, 수락되었음을 나타냅니다.

---
##### **5.9.1.1.  2.01 Created**

HTTP 201 "Created"와 비슷하지만 POST 및 PUT 요청에 대한 응답으로만 사용됩니다. 응답과 함께 반환된 페이로드는 작업 결과를 나타냅니다.

응답에 하나 이상의 위치 경로 및/또는 위치 쿼리 옵션이 포함된 경우 이러한 옵션의 값은 리소스가 생성된 위치를 지정합니다. 그렇지 않으면 리소스가 요청 URI에서 생성되었습니다. 이 응답을 수신하는 캐시는 생성된 리소스에 대해 저장된 모든 응답을 최신이 아닌 것으로 표시해야 합니다.

이 응답은 캐시할 수 없습니다.

---
##### **5.9.1.2.  2.02 Deleted**

이 응답 코드는 HTTP 204 "콘텐츠 없음"과 유사하지만 DELETE 및 특정 상황에서는 POST와 같이 리소스 사용을 중단시키는 요청에 대한 응답으로만 사용됩니다. 응답과 함께 반환된 페이로드는 작업 결과를 나타냅니다.

이 응답은 캐시할 수 없습니다. 그러나 캐시는 삭제된 리소스에 대해 저장된 응답을 최신이 아닌 것으로 표시해야 합니다.

---
##### **5.9.1.3.  2.03 Valid**

이 응답 코드는 HTTP 304 "수정되지 않음"과 관련되어 있지만 포함된 ETag 옵션에 의해 식별된 엔터티 태그로 식별된 응답이 유효함을 나타내는 데만 사용됩니다. 따라서 응답은 ETag 옵션을 포함해야 하며 페이로드를 포함해서는 안 됩니다.

ETag 응답 옵션을 인식하고 처리하는 캐시가 2.03\(유효\) 응답을 수신하면 응답에 포함된 Max-Age 옵션 값으로 저장된 응답을 업데이트해야 합니다\(명시적으로 또는 묵시적으로 기본값으로; 참조\). 섹션 5.6.2\). 응답에 있는 각 유형의 Safe-to-Forward 옵션에 대해 저장된 응답에 있는 이 유형의 옵션 세트\(아마도 비어 있을 수 있음\)는 수신된 응답에 있는 이 유형의 옵션 세트로 대체되어야 합니다. \(안전하지 않은 옵션은 옵션에 정의된 것과 유사한 옵션별 처리를 트리거할 수 있습니다.\)

---
##### **5.9.1.4.  2.04 Changed**

이 응답 코드는 HTTP 204 "콘텐츠 없음"과 유사하지만 POST 및 PUT 요청에 대한 응답에만 사용됩니다. 응답과 함께 반환된 페이로드는 작업 결과를 나타냅니다.

이 응답은 캐시할 수 없습니다. 그러나 캐시는 변경된 리소스에 대해 저장된 모든 응답을 최신이 아닌 것으로 표시해야 합니다.

---
##### **5.9.1.5.  2.05 Content**

이 응답 코드는 HTTP 200 "OK"와 비슷하지만 GET 요청에 대한 응답으로만 사용됩니다.

응답과 함께 반환된 페이로드는 대상 리소스를 나타냅니다.

이 응답은 캐시 가능합니다. 캐시는 Max-Age 옵션을 사용하여 신선도를 결정하고\(섹션 5.6.1 참조\) 검증을 위한 ETag 옵션\(섹션 5.6.2 참조\)을 사용할 수 있습니다.

---
#### **5.9.2.  Client Error 4.xx**

이 응답 코드 클래스는 클라이언트가 오류를 범한 것으로 보이는 경우를 위한 것입니다. 이러한 응답 코드는 모든 요청 방법에 적용 가능합니다.

서버는 섹션 5.5.2에 설명된 조건에 따라 진단 페이로드를 포함해야 합니다.

이 클래스의 응답은 캐시 가능합니다. 캐시는 Max-Age 옵션을 사용하여 신선도를 결정할 수 있습니다\(섹션 5.6.1 참조\). 유효성을 검사할 수 없습니다.

---
##### **5.9.2.1.  4.00 Bad Request**

이 응답 코드는 HTTP 400 "잘못된 요청"과 같습니다.

---
##### **5.9.2.2.  4.01 Unauthorized**

클라이언트는 요청된 작업을 수행할 권한이 없습니다. 클라이언트는 먼저 서버에 대한 인증 상태를 개선하지 않고 요청을 반복해서는 안 됩니다. 이를 위해 어떤 특정 메커니즘을 사용할 수 있는지는 이 문서의 범위를 벗어납니다. 섹션 9도 참조하세요.

---
##### **5.9.2.3.  4.02 Bad Option**

하나 이상의 인식할 수 없거나 형식이 잘못된 옵션으로 인해 서버에서 요청을 이해할 수 없습니다. 클라이언트는 수정 없이 요청을 반복해서는 안 됩니다.

---
##### **5.9.2.4.  4.03 Forbidden**

이 응답 코드는 HTTP 403 "금지됨"과 같습니다.

---
##### **5.9.2.5.  4.04 Not Found**

이 응답 코드는 HTTP 404 "찾을 수 없음"과 같습니다.

---
##### **5.9.2.6.  4.05 Method Not Allowed**

이 응답 코드는 HTTP 405 "Method Not Allowed"와 비슷하지만 "Allow" 헤더 필드와 유사하지 않습니다.

---
##### **5.9.2.7.  4.06 Not Acceptable**

이 응답 코드는 HTTP 406 "허용되지 않음"과 유사하지만 응답 엔터티가 없습니다.

---
##### **5.9.2.8.  4.12 Precondition Failed**

이 응답 코드는 HTTP 412 "전제 조건 실패"와 같습니다.

---
##### **5.9.2.9.  4.13 Request Entity Too Large**

이 응답 코드는 HTTP 413 "요청 엔터티가 너무 큼"과 같습니다.

응답에는 서버가 이 정보를 제공할 수 있는 위치에 있지 않는 한 서버가 처리할 수 있고 처리할 의향이 있는 요청 엔터티의 최대 크기를 나타내는 Size1 옵션\(섹션 5.10.9\)이 포함되어야 합니다.

---
##### **5.9.2.10.  4.15 Unsupported Content-Format**

이 응답 코드는 HTTP 415 "지원되지 않는 미디어 유형"과 같습니다.

---
#### **5.9.3.  Server Error 5.xx**

이 응답 코드 클래스는 서버가 오류가 발생했거나 요청을 수행할 수 없음을 인식하는 경우를 나타냅니다. 이러한 응답 코드는 모든 요청 방법에 적용 가능합니다.

서버는 섹션 5.5.2에 설명된 조건에 따라 진단 페이로드를 포함해야 합니다.

이 클래스의 응답은 캐시 가능합니다. 캐시는 Max-Age 옵션을 사용하여 신선도를 결정할 수 있습니다\(섹션 5.6.1 참조\). 유효성을 검사할 수 없습니다.

---
##### **5.9.3.1.  5.00 Internal Server Error**

이 응답 코드는 HTTP 500 "내부 서버 오류"와 같습니다.

---
##### **5.9.3.2.  5.01 Not Implemented**

이 응답 코드는 HTTP 501 "구현되지 않음"과 같습니다.

---
##### **5.9.3.3.  5.02 Bad Gateway**

이 응답 코드는 HTTP 502 "잘못된 게이트웨이"와 같습니다.

---
##### **5.9.3.4.  5.03 Service Unavailable**

이 응답 코드는 HTTP 503 "서비스를 사용할 수 없음"과 비슷하지만 "Retry-After" 헤더 필드 대신 Max-Age 옵션을 사용하여 재시도할 시간\(초\)을 나타냅니다.

---
##### **5.9.3.5.  5.04 Gateway Timeout**

이 응답 코드는 HTTP 504 "게이트웨이 시간 초과"와 같습니다.

---
##### **5.9.3.6.  5.05 Proxying Not Supported**

서버는 Proxy-Uri 옵션에 지정되거나 Proxy-Scheme\(섹션 5.10.2 참조\)을 사용하여 지정된 URI에 대한 전달 프록시 역할을 할 수 없거나 수행할 의사가 없습니다.

---
### **5.10.  Option Definitions**

개별 CoAP 옵션은 표 4에 요약되어 있으며 이 섹션의 하위 섹션에서 설명됩니다.

이 표에서 C, U 및 N 열은 각각 Critical, UnSafe 및 NoCacheKey 속성을 나타냅니다. NoCacheKey는 전달 안전\(Unsafe로 표시되지 않음\) 옵션에 대해서만 의미를 갖기 때문에 열은 UnSafe 옵션에 대해 대시로 채워집니다.

```text
   +-----+---+---+---+---+----------------+--------+--------+----------+
   | No. | C | U | N | R | Name           | Format | Length | Default  |
   +-----+---+---+---+---+----------------+--------+--------+----------+
   |   1 | x |   |   | x | If-Match       | opaque | 0-8    | (none)   |
   |   3 | x | x | - |   | Uri-Host       | string | 1-255  | (see     |
   |     |   |   |   |   |                |        |        | below)   |
   |   4 |   |   |   | x | ETag           | opaque | 1-8    | (none)   |
   |   5 | x |   |   |   | If-None-Match  | empty  | 0      | (none)   |
   |   7 | x | x | - |   | Uri-Port       | uint   | 0-2    | (see     |
   |     |   |   |   |   |                |        |        | below)   |
   |   8 |   |   |   | x | Location-Path  | string | 0-255  | (none)   |
   |  11 | x | x | - | x | Uri-Path       | string | 0-255  | (none)   |
   |  12 |   |   |   |   | Content-Format | uint   | 0-2    | (none)   |
   |  14 |   | x | - |   | Max-Age        | uint   | 0-4    | 60       |
   |  15 | x | x | - | x | Uri-Query      | string | 0-255  | (none)   |
   |  17 | x |   |   |   | Accept         | uint   | 0-2    | (none)   |
   |  20 |   |   |   | x | Location-Query | string | 0-255  | (none)   |
   |  35 | x | x | - |   | Proxy-Uri      | string | 1-1034 | (none)   |
   |  39 | x | x | - |   | Proxy-Scheme   | string | 1-255  | (none)   |
   |  60 |   |   | x |   | Size1          | uint   | 0-4    | (none)   |
   +-----+---+---+---+---+----------------+--------+--------+----------+

             C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable

                             Table 4: Options
```

---
#### **5.10.1.  Uri-Host, Uri-Port, Uri-Path, and Uri-Query**

Uri-Host, Uri-Port, Uri-Path 및 Uri-Query 옵션은 CoAP 원본 서버에 대한 요청의 대상 리소스를 지정하는 데 사용됩니다. 옵션은 옵션 값에 백분율 인코딩이 표시되지 않고 관련 엔드포인트에서 전체 URI가 재구성될 수 있는 방식으로 요청 URI의 다양한 구성 요소를 인코딩합니다. CoAP URI의 구문은 섹션 6에 정의되어 있습니다.

URI를 옵션으로 구문 분석하는 단계는 섹션 6.4에 정의되어 있습니다. 이러한 단계를 수행하면 요청에 0개 이상의 Uri-Host, Uri-Port, Uri-Path 및 Uri-Query 옵션이 포함되며, 각 옵션에는 다음 값이 포함됩니다.

- Uri-Host 옵션은 요청되는 리소스의 인터넷 호스트를 지정합니다.

- Uri-Port 옵션은 리소스의 전송 계층 포트 번호를 지정합니다.

- 각 Uri-Path 옵션은 리소스에 대한 절대 경로의 한 세그먼트를 지정합니다.

- 각 Uri-Query 옵션은 리소스를 매개 변수화하는 하나의 인수를 지정합니다.

참고: 조각\(\[RFC3986\], 섹션 3.5\)은 요청 URI의 일부가 아니므로 CoAP 요청에서 전송되지 않습니다.

Uri-Host 옵션의 기본값은 요청 메시지의 대상 IP 주소를 나타내는 IP 리터럴입니다. 마찬가지로 Uri-Port 옵션의 기본값은 대상 UDP 포트입니다. Uri-Host 및 Uri-Port 옵션의 기본값은 대부분의 서버에 대한 요청에 충분합니다. 명시적 Uri-Host 및 Uri-Port 옵션은 일반적으로 엔드포인트가 여러 가상 서버를 호스팅할 때 사용됩니다.

Uri-Path 및 Uri-Query 옵션에는 모든 문자 시퀀스가 ​​포함될 수 있습니다. 퍼센트 인코딩은 수행되지 않습니다. Uri-Path 옵션의 값은 "."가 아니어야 합니다. 또는 ".."\(요청 URI를 옵션으로 구문 분석하기 전에 확인해야 하므로\).

옵션에서 요청 URI를 구성하는 단계는 섹션 6.5에 정의되어 있습니다. 구현 시 반드시 URI를 구성할 필요는 없습니다. 개별 옵션을 검사하여 대상 리소스를 간단히 조회할 수 있습니다.

예제는 부록 B에서 찾을 수 있습니다.

---
#### **5.10.2.  Proxy-Uri and Proxy-Scheme**

Proxy-Uri 옵션은 전달 프록시에 요청하는 데 사용됩니다\(섹션 5.7 참조\). 전달 프록시는 요청을 전달하거나 유효한 캐시에서 이를 서비스하고 응답을 반환하도록 요청됩니다.

옵션 값은 절대 URI\(\[RFC3986\], 섹션 4.3\)입니다.

전달 프록시는 요청을 다른 프록시로 전달하거나 절대 URI에 의해 지정된 서버로 직접 전달할 수 있습니다. 요청 루프를 피하기 위해 프록시는 별칭, 로컬 변형 및 숫자 IP 주소를 포함하여 모든 서버 이름을 인식할 수 있어야 합니다.

요청에 대한 전달 프록시 역할을 할 수 없거나 작동할 의사가 없는 Proxy-Uri 옵션이 있는 요청을 수신하는 엔드포인트는 5.05\(프록시 지원 안 됨\) 응답을 반환해야 합니다.

Proxy-Uri 옵션은 Uri-Host, Uri-Port, Uri-Path 또는 Uri-Query 옵션보다 우선해야 합니다\(각 옵션은 Proxy-Uri 옵션을 포함하는 요청에 포함되어서는 안 됩니다\).

많은 프록시 클라이언트를 단순화하기 위한 특별한 경우로 Uri-\* 옵션에서 절대 URI를 구성할 수 있습니다. Proxy-Scheme 옵션이 있는 경우 절대 URI는 다음과 같이 구성됩니다. CoAP URI는 섹션 6.5에 정의된 Uri-\* 옵션에서 구성됩니다. 결과 URI에서 다음 콜론까지\(포함하지 않음\)의 초기 체계는 프록시 체계 옵션의 콘텐츠로 대체됩니다. 이 경우는 스키마 구성 요소가 아닌 원하는 URI의 구성 요소가 실제로 Uri-\* 옵션을 사용하여 표현될 수 있는 경우에만 적용 가능합니다. 예를 들어 기관에 userinfo 구성 요소가 포함된 URI를 나타내려면 Proxy-Uri만 사용할 수 있습니다.

---
#### **5.10.3.  Content-Format**

Content-Format 옵션은 메시지 페이로드의 표현 형식을 나타냅니다. 표현 형식은 "CoAP 콘텐츠 형식" 레지스트리\(12.3절\)에 정의된 숫자 콘텐츠 형식 식별자로 제공됩니다. 옵션이 없으면 기본값이 가정되지 않습니다. 즉, 표현 메시지 페이로드의 표현 형식이 불확실합니다\(Section 5.5\).

---
#### **5.10.4.  Accept**

CoAP Accept 옵션은 클라이언트가 어떤 Content-Format을 허용하는지 나타내는 데 사용될 수 있습니다. 표현 형식은 "CoAP Content-Formats" 레지스트리\(12.3절\)에 정의된 숫자 Content-Format 식별자로 제공됩니다. Accept 옵션이 제공되지 않으면 클라이언트는 기본 설정을 표현하지 않습니다\(따라서 기본값이 가정되지 않습니다\). 클라이언트는 서버가 반환한 표현이 표시된 Content-Format인 것을 선호합니다. 서버는 가능한 경우 선호하는 Content-Format을 반환합니다. 선호하는 콘텐츠 형식을 반환할 수 없는 경우 이 응답에 대해 다른 오류 코드가 우선하지 않는 한 4.06 "허용되지 않음"을 응답으로 전송해야 합니다.

---
#### **5.10.5.  Max-Age**

Max-Age 옵션은 응답이 신선하지 않은 것으로 간주되기 전에 응답이 캐시될 수 있는 최대 시간을 나타냅니다\(섹션 5.6.1 참조\).

옵션 값은 0과 2\*\*32-1 사이의 정수\(약 136.1년\)입니다. 응답에 옵션이 없으면 기본값 60초가 가정됩니다.

이 값은 전송 당시의 최신 값입니다. Max-Age 값에 대해 엄격한 허용 오차를 갖는 리소스를 제공하는 서버는 각 재전송 전에 값을 업데이트해야 합니다. \(섹션 5.7.1도 참조하세요.\)

---
#### **5.10.6.  ETag**

엔터티 태그는 시간이 지남에 따라 달라지는 동일한 리소스의 표현을 구별하기 위한 리소스-로컬 식별자로 사용하기 위한 것입니다. 이는 버전, 체크섬, 해시 또는 시간을 포함하여 다양한 방법으로 생성할 수 있는 리소스를 제공하는 서버에 의해 생성됩니다. 엔터티 태그를 수신하는 엔드포인트는 이를 불투명한 것으로 처리해야 하며 해당 내용이나 구조에 대해 어떤 가정도 하지 않아야 합니다. \(엔티티 태그를 생성하는 엔드포인트는 특히 여러 ETag 값을 저장하려는 클라이언트 및 중개자와 관련하여 가능한 가장 간결한 표현을 사용하는 것이 좋습니다.\)

---
##### **5.10.6.1.  ETag as a Response Option**

응답의 ETag 옵션은 "태그된 표현"에 대한 엔터티 태그의 현재 값\(즉, 요청이 처리된 후\)을 제공합니다. Location-\* 옵션이 없으면 태그된 표현은 대상 리소스의 선택된 표현\(섹션 5.5.3\)입니다. 하나 이상의 Location-\* 옵션이 존재하여 위치 URI가 표시되는 경우\(5.10.7절\) 태그 표시는 위치 URI에 대한 GET 요청에 의해 검색되는 표현입니다.

ETag 응답 옵션은 태그된 표현이 있는 모든 응답에 포함될 수 있습니다\(예: 4.04 또는 4.00 응답에서는 의미가 없습니다\). ETag 옵션은 응답에서 두 번 이상 발생하면 안 됩니다.

ETag 옵션에는 기본값이 없습니다. 응답에 존재하지 않으면 서버는 태그된 표현에 대한 엔터티 태그에 대해 어떠한 설명도 하지 않습니다.

---
##### **5.10.6.2.  ETag as a Request Option**

GET 요청에서 이전에 리소스에서 얻은 하나 이상의 표현이 있고 이를 통해 ETag 응답 옵션을 얻은 엔드포인트는 저장된 응답 중 하나 이상에 대해 ETag 옵션 인스턴스를 지정할 수 있습니다.

제공된 ETag 중 하나가 현재 표현에 대한 엔터티 태그인 경우, 즉 유효한 경우 서버는 2.05 콘텐츠 응답 대신 2.03 유효한 응답\(섹션 5.9.1.3\)을 발행할 수 있습니다. 2.03 유효한 응답은 응답 옵션에 이 특정 ETag를 반영합니다.

실제로 클라이언트는 다시 전송할 필요 없이 저장된 표현 중 최신 표현\(섹션 5.6.2 참조\)이 있는지 확인할 수 있습니다.

ETag 옵션은 요청에서 0회, 1회 또는 여러 번 발생할 수 있습니다.

---
#### **5.10.7.  Location-Path and Location-Query**

위치 경로 및 위치 쿼리 옵션은 함께 절대 경로, 쿼리 문자열 또는 둘 다로 구성된 상대 URI를 나타냅니다. 이러한 옵션의 조합은 POST 요청의 결과로 생성된 리소스의 위치를 ​​나타내기 위해 2.01\(생성됨\) 응답에 포함됩니다\(섹션 5.8.2 참조\). 위치는 요청 URI를 기준으로 확인됩니다.

하나 이상의 위치 경로 및/또는 위치 쿼리 옵션이 있는 응답이 이러한 옵션을 해석하는 캐시를 통과하고 묵시적인 URI가 현재 저장된 하나 이상의 응답을 식별하는 경우 해당 항목은 최신이 아닌 것으로 표시되어야 합니다.

각 위치 경로 옵션은 리소스에 대한 절대 경로의 한 세그먼트를 지정하고, 각 위치 쿼리 옵션은 리소스를 매개 변수화하는 하나의 인수를 지정합니다. 위치 경로 및 위치 쿼리 옵션에는 모든 문자 시퀀스가 ​​포함될 수 있습니다. 퍼센트 인코딩은 수행되지 않습니다. 위치 경로 옵션의 값은 "."가 되어서는 안 됩니다. 또는 "..".

옵션에서 위치 URI를 구성하는 단계는 처음 5개 단계를 건너뛰고 결과가 요청 URI를 기준으로 해석되는 상대 URI 참조라는 점을 제외하면 섹션 6.5와 유사합니다. 이런 방식으로 구성된 상대 URI 참조에는 항상 절대 경로가 포함됩니다\(예: Location-Path를 생략하고 Location-Query를 제공하는 것은 URI의 경로 구성 요소가 "/"임을 의미함\).

상대 URI 참조를 계산하는 데 사용되는 옵션을 통칭하여 Location-\* 옵션이라고 합니다. Location-Path 및 Location-Query 외에도 더 많은 Location-\* 옵션이 향후 정의될 수 있으며 예약된 옵션 번호 128, 132, 136 및 140입니다. 이러한 예약된 옵션 번호 중 하나라도 Location-Path 및 Location-Path 및 /또는 위치 쿼리가 지원되지 않으면 4.02\(잘못된 옵션\) 오류가 반환되어야 합니다.

---
#### **5.10.8.  Conditional Request Options**

조건부 요청 옵션을 사용하면 클라이언트는 옵션에 지정된 특정 조건이 충족되는 경우에만 서버에 요청을 수행하도록 요청할 수 있습니다.

이러한 각 옵션에 대해 주어진 조건이 충족되지 않으면 서버는 요청된 방법을 수행해서는 안 됩니다. 대신 서버는 4.12\(전제 조건 실패\) 응답 코드로 응답해야 합니다.

조건이 충족되면 서버는 조건부 요청 옵션이 없는 것처럼 요청 방법을 수행합니다.

조건부 요청 옵션 없이 요청이 2.xx 또는 4.12 응답 코드 이외의 결과를 낳는 경우 모든 조건부 요청 옵션은 무시될 수 있습니다.

---
##### **5.10.8.1.  If-Match**

If-Match 옵션은 대상 리소스의 하나 이상의 표현에 대한 ETag의 현재 존재 또는 값에 대한 조건부 요청을 만드는 데 사용될 수 있습니다. If-Match는 일반적으로 여러 클라이언트가 동일한 리소스에 대해 병렬로 작동할 때 실수로 덮어쓰는 것을 방지하기 위한 수단으로 PUT 요청과 같은 리소스 업데이트 요청에 유용합니다\(예: "업데이트 손실" 문제\).

If-Match 옵션의 값은 ETag이거나 빈 문자열입니다. ETag가 있는 If-Match 옵션은 정확한 ETag가 있는 표현과 일치합니다. 값이 비어 있는 If-Match 옵션은 기존 표현과 일치합니다\(즉, 대상 리소스에 대한 현재 표현의 존재에 대한 전제 조건을 설정합니다\).

If-Match 옵션은 여러 번 발생할 수 있습니다. 옵션 중 하나라도 일치하면 조건이 충족됩니다.

하나 이상의 If-Match 옵션이 있지만 일치하는 옵션이 없으면 조건이 충족되지 않습니다.

---
##### **5.10.8.2.  If-None-Match**

If-None-Match 옵션은 대상 리소스가 존재하지 않는다는 조건부 요청을 만드는 데 사용될 수 있습니다. If-None-Match는 여러 클라이언트가 동일한 리소스에 대해 병렬로 작동할 때 실수로 덮어쓰는 것을 방지하기 위한 수단으로 PUT 요청과 같은 리소스 생성 요청에 유용합니다. If-None-Match 옵션은 값을 전달하지 않습니다.

대상 리소스가 존재하는 경우 조건이 충족되지 않습니다.

\(If-Match 옵션과 If-None-Match 옵션을 하나의 요청에 결합하는 것은 조건이 결코 충족되지 않기 때문에 별로 유용하지 않습니다.\)

---
#### **5.10.9.  Size1 Option**

Size1 옵션은 요청의 리소스 표현에 대한 크기 정보를 제공합니다. 옵션 값은 정수 바이트 수입니다. 주요 용도는 블록 단위 전송 \[BLOCK\]입니다. 본 사양에서는 서버가 처리할 수 있고 처리하려는 요청 엔터티의 최대 크기를 나타내기 위해 4.13 응답\(Section 5.9.2.9\)에서 사용됩니다.

---
## **6.  CoAP URIs**

CoAP는 CoAP 리소스를 식별하고 리소스를 찾는 수단을 제공하기 위해 "coap" 및 "coaps" URI 체계를 사용합니다. 리소스는 계층적으로 구성되며 특정 UDP 포트에서 CoAP 요청\("coap"\) 또는 DTLS 보안 CoAP 요청\("coaps"\)을 수신하는 잠재적인 CoAP 원본 서버에 의해 관리됩니다. CoAP 서버는 호스트 구성 요소와 선택적 UDP 포트 번호를 포함하는 일반 구문의 권한 구성 요소를 통해 식별됩니다. URI의 나머지 부분은 CoAP 프로토콜에 정의된 방법으로 작동할 수 있는 리소스를 식별하는 것으로 간주됩니다. 따라서 "coap" 및 "coaps" URI 체계는 각각 "http" 및 "https" URI 체계와 비교할 수 있습니다.

"coap" 및 "coaps" URI 체계의 구문은 ABNF\(Augmented Backus-Naur Form\) \[RFC5234\]의 이 섹션에 지정되어 있습니다. "host", "port", "path-abempty", "query", "segment", "IP-literal", "IPv4address" 및 "reg-name"의 정의는 \[RFC3986\]에서 채택되었습니다.

구현 참고 사항: 불행하게도 시간이 지남에 따라 URI 형식은 상당히 복잡해졌습니다. 구현자는 \[RFC3986\]을 면밀히 조사하는 것이 좋습니다. 예를 들어 IPv6 주소의 ABNF는 예상보다 더 복잡합니다. 또한 구현자는 URI에서 디코딩된 구성 요소로 또는 그 반대로 가는 도중에 퍼센트 디코딩 또는 퍼센트 인코딩 처리를 정확히 한 번 수행하도록 주의해야 합니다. 퍼센트 인코딩은 데이터 투명성을 위해 중요하지만 경로 구성 요소에 슬래시 문자와 같은 비정상적인 결과가 발생할 수 있습니다.

---
### **6.1.  coap URI Scheme**

```text
   coap-URI = "coap:" "//" host [ ":" port ] path-abempty [ "?" query ]
```

호스트 구성 요소가 IP 리터럴 또는 IPv4 주소로 제공되면 해당 IP 주소에서 CoAP 서버에 연결할 수 있습니다. 호스트가 등록된 이름인 경우 해당 이름은 간접 식별자로 간주되며 끝점은 DNS와 같은 이름 확인 서비스를 사용하여 해당 호스트의 주소를 찾을 수 있습니다. 호스트는 비어 있어서는 안 됩니다. URI인 경우

권한이 없거나 빈 호스트와 함께 수신된 경우 유효하지 않은 것으로 간주되어야 합니다. 포트 하위 구성 요소는 CoAP 서버가 있는 UDP 포트를 나타냅니다. 비어 있거나 제공되지 않으면 기본 포트 5683이 가정됩니다.

경로는 호스트 및 포트 범위 내의 리소스를 식별합니다. 이는 슬래시 문자\(U+002F SOLIDUS "/"\)로 구분된 일련의 경로 세그먼트로 구성됩니다.

쿼리는 리소스를 추가로 매개변수화하는 데 사용됩니다. 이는 앰퍼샌드 문자\(U+0026 AMPERSAND "&"\)로 구분된 일련의 인수로 구성됩니다. 인수는 "키=값" 쌍 형식인 경우가 많습니다.

"coap" URI 체계는 호스트 네임스페이스의 "잘 알려진 위치"에 대해 \[RFC5785\]에서 정의한 경로 접두사 "/.well-known/"을 지원합니다. 이를 통해 호스팅된 리소스와 같은 호스트에 대한 정책이나 기타 정보\("사이트 전체 메타데이터"\)를 검색할 수 있습니다\(섹션 7 참조\).

애플리케이션 디자이너는 짧지만 설명이 포함된 URI를 사용하는 것이 좋습니다. CoAP가 사용되는 환경은 일반적으로 대역폭과 에너지가 제한되어 있기 때문에 이 두 가지 품질 사이의 균형은 설명성을 무시하지 않고 짧은 쪽으로 치우쳐야 합니다.

---
### **6.2.  coaps URI Scheme**

```text
   coaps-URI = "coaps:" "//" host [ ":" port ] path-abempty
               [ "?" query ]
```

"coap" 구성표에 대해 위에 나열된 모든 요구 사항은 "coaps" 구성표에 대한 요구 사항이기도 합니다. 단, 포트 하위 구성 요소가 비어 있거나 제공되지 않은 경우 기본 UDP 포트 5684가 가정되고 UDP 데이터그램은 다음을 통해 보호되어야 합니다. 섹션 9.1에 설명된 대로 DTLS 사용.

"coaps" 식별 요청에 대한 응답 캐싱에 대한 고려사항은 섹션 11.2에서 논의됩니다.

"coaps" 구성표를 통해 사용 가능한 리소스는 해당 리소스 식별자가 동일한 권한\(동일한 UDP 포트를 수신하는 동일한 호스트\)을 나타내더라도 "coap" 구성표와 공유 ID가 없습니다. 이들은 별개의 네임스페이스이며 별개의 원본 서버로 간주됩니다.

---
### **6.3.  Normalization and Comparison Rules**

"coap" 및 "coaps" 체계는 URI 일반 구문을 따르기 때문에 이러한 URI는 각 체계에 대해 위에 설명된 기본값을 사용하여 \[RFC3986\], 섹션 6에 정의된 알고리즘에 따라 정규화되고 비교됩니다.

포트가 구성표의 기본 포트와 동일한 경우 일반적인 형식은 포트 하위 구성 요소를 제거하는 것입니다. 마찬가지로 빈 경로 구성 요소는 "/"의 절대 경로와 동일하므로 대신 "/" 경로를 제공하는 것이 일반적인 형식입니다. 구성표와 호스트는 대소문자를 구분하지 않으며 일반적으로 소문자로 제공됩니다. IP 리터럴은 권장 형식 \[RFC5952\]입니다. 다른 모든 구성요소는 대소문자를 구분하여 비교됩니다. "예약된" 세트에 있는 문자 이외의 문자는 백분율로 인코딩된 바이트와 동일합니다\(\[RFC3986\], 섹션 2.1 참조\). 일반적인 형식은 이를 인코딩하지 않는 것입니다.

예를 들어 다음 세 가지 URI는 동일하며 CoAP 메시지에 동일한 옵션 및 옵션 값이 표시됩니다.

```text
   coap://example.com:5683/~sensors/temp.xml
   coap://EXAMPLE.com/%7Esensors/temp.xml
   coap://EXAMPLE.com:/%7esensors/temp.xml
```

---
### **6.4.  Decomposing URIs into Options**

문자열 |url|에서 요청 옵션을 구문 분석하는 단계 다음과 같다. 이러한 단계를 수행하면 Uri-Host, Uri-Port, Uri-Path 및 Uri-Query 옵션 중 0개 이상이 요청에 포함되거나 실패합니다.

1. |url| 문자열이 절대 URI\(\[RFC3986\]\)가 아니면 이 알고리즘이 실패합니다.

1. |url|을 해결하세요. \[RFC3986\]에 정의된 참조 확인 프로세스를 사용하는 문자열입니다. 이 단계에서는 디코딩된 구성 요소가 5, 8, 9단계 후에 UTF-8\[RFC3629\]로 해석되더라도 URL은 ASCII 인코딩\[RFC0020\]입니다.

- 참고: 현재로서는 절대 URL임을 이미 알고 있으므로 무엇을 기준으로 해결되는지는 중요하지 않습니다.

1. 만약 |url| ASCII 소문자로 변환할 때 값이 "coap" 또는 "coaps"인 <scheme\> 구성 요소가 없으면 이 알고리즘이 실패합니다.

1. 만약 |url| <fragment\> 구성 요소가 있으면 이 알고리즘이 실패합니다.

1. |url|의 <host\> 구성요소인 경우 요청의 대상 IP 주소를 IP 리터럴 또는 IPv4 주소로 나타내지 않으며 Uri-Host 옵션을 포함하고 해당 옵션의 값을 |url|의 <host\> 구성 요소 값으로 두고 ASCII 소문자로 변환한 다음 모두 변환합니다. 퍼센트 인코딩\("%" 다음에 2개의 16진수 숫자\)을 해당 문자에 적용합니다.

- 참고: 요청의 대상 IP 주소가 호스트 부분에서 파생되는 일반적인 경우 Uri-Host 옵션은 regname 형식의 <host\> 구성 요소에만 사용됩니다.

1. 만약 |url| <port\> 구성요소가 있으면 |port| 해당 구성 요소의 값은 십진 정수로 해석됩니다. 그렇지 않으면 |port| 구성표의 기본 포트가 됩니다.

1. 만약 |포트| 요청의 대상 UDP 포트와 같지 않으면 Uri-Port 옵션을 포함하고 해당 옵션의 값을 |port|로 둡니다.

1. |url|의 <path\> 구성 요소 값이 비어 있거나 단일 슬래시 문자\(U+002F SOLIDUS "/"\)로 구성되면 다음 단계로 이동합니다.

- 그렇지 않은 경우 <path\> 구성 요소의 각 세그먼트에 대해 Uri-Path 옵션을 포함하고 각 백분율 인코딩\("%" 다음에 두 개의 16진수 숫자가 오는\)을 변환한 후 해당 옵션의 값을 세그먼트\(구분 슬래시 문자 제외\)로 둡니다. \)을 해당 바이트로 이동합니다.

1. 만약 |url| <query\> 구성 요소가 있는 경우 <query\> 구성 요소의 각 인수에 대해 Uri-Query 옵션을 포함하고 각 백분율을 변환한 후 해당 옵션의 값을 인수\(물음표 및 구분 앰퍼샌드 문자 제외\)로 둡니다. 해당 바이트로 인코딩합니다.

이러한 규칙은 백분율 인코딩을 완전히 해결합니다.

---
### **6.5.  Composing URIs from Options**

요청 옵션에서 URI를 구성하는 단계는 다음과 같습니다. 이러한 단계에서는 URI가 생성되거나 실패합니다. 이 단계에서 문자를 퍼센트 인코딩한다는 것은 각 \(UTF-8 인코딩\) 바이트를 "%" 문자로 바꾸고 바이트를 나타내는 두 개의 16진수 숫자로 바꾸는 것을 의미합니다. 여기서 숫자 A-F는 대문자입니다\(섹션 2.1에 정의됨\). \[RFC3986\]의 변동성을 줄이기 위해 CoAP URI의 백분율 인코딩에 대한 16진수 표기법은 대문자를 사용해야 합니다. "예약되지 않은" 및 "하위 구분"의 정의는 \[RFC3986\]에서 채택되었습니다.

1. 요청이 DTLS를 사용하여 보호되는 경우 |url| "coaps://" 문자열이어야 합니다. 그렇지 않으면 |url| 문자열 "coap://"이어야 합니다.

1. 요청에 Uri-Host 옵션이 포함된 경우 |host| ASCII가 아닌 문자는 해당 백분율 인코딩으로 대체되는 해당 옵션의 값이 됩니다. |호스트| 유효한 등록 이름, IP 리터럴 또는 IPv4 주소가 아닌 경우 알고리즘이 실패합니다. 요청에 Uri-Host 옵션이 포함되어 있지 않으면 |host| 요청의 대상 IP 주소를 나타내는 IP 리터럴\(\[RFC5952\] 규칙 사용\) 또는 IPv4address여야 합니다.

1. |호스트|를 추가하세요. |url|로.

1. 요청에 Uri-Port 옵션이 포함된 경우 |port| 해당 옵션의 값이 됩니다. 그렇지 않으면 |port| 요청의 대상 UDP 포트입니다.

1. 만약 |포트| 이 구성표의 기본 포트가 아닌 경우 단일 U+003A 콜론 문자\(:\)와 |port|의 10진수 표현을 추가합니다. |url|로.

1. |리소스 이름| 빈 문자열이 됩니다. 요청의 각 Uri-Path 옵션에 대해 단일 문자 U+002F SOLIDUS\(/\)와 옵션 값을 |리소스 이름|에 추가합니다. sub-delims" 세트, U+003A COLON\(:\) 문자 또는 U+0040 COMMERCIAL AT\(@\) 문자를 퍼센트 인코딩 형식으로 설정합니다.

1. |리소스 이름| 빈 문자열인 경우 단일 문자 U+002F SOLIDUS\(/\)로 설정합니다.

1. 요청의 각 Uri-Query 옵션에 대해 단일 문자 U+003F QUESTION MARK\(?\)\(첫 번째 옵션\) 또는 U+0026 AMPERSAND\(&\)\(후속 옵션\) 뒤에 옵션 값을 |resource name|에 추가합니다. , "예약되지 않은" 집합, "하위 구분 기호" 집합\(U+0026 AMPERSAND\(&\) 제외\), U+003A COLON\(:\), U+0040 COMMERCIAL AT에 없는 문자를 변환한 후 \(@\), U+002F SOLIDUS\(/\) 또는 U+003F 물음표\(?\) 문자를 퍼센트 인코딩 형식으로 변환합니다.

1. |리소스 이름|을 추가하세요. |url|로.

```text
   10.  Return |url|.
```

이러한 단계는 일반 형식의 URI로 연결되도록 설계되었습니다\(섹션 6.3 참조\).

---
## **7.  Discovery**
---
### **7.1.  Service Discovery**

CoAP 서버가 제공하는 서비스를 검색하는 과정의 일환으로 클라이언트는 서버가 사용하는 엔드포인트에 대해 알아야 합니다.

서버는 서버의 네임스페이스에 있는 리소스를 참조하는 URI를 알고 있거나 학습하는 클라이언트에 의해 검색됩니다. 또는 클라이언트는 멀티캐스트 CoAP\(섹션 8 참조\) 및 "모든 CoAP 노드" 멀티캐스트 주소를 사용하여 CoAP 서버를 찾을 수 있습니다.

"coap" 또는 "coaps" URI의 포트 하위 구성 요소가 CoAP 서버가 있는 UDP 포트를 나타내지 않는 한 서버는 기본 포트에서 연결할 수 있는 것으로 간주됩니다.

CoAP 기본 포트 번호 5683은 리소스 검색을 위한 리소스를 제공하는 서버에서 지원해야 하며\(아래 섹션 7.2 참조\) 다른 리소스에 대한 액세스를 제공하기 위해 지원되어야 합니다. DTLS 보안 CoAP의 기본 포트 번호 5684는 리소스 검색 및 다른 리소스에 대한 액세스 제공을 위해 서버에서 지원될 수 있습니다. 또한 다른 엔드포인트는 동적 포트 공간과 같은 다른 포트에서 호스팅될 수 있습니다.

구현 참고 사항: CoAP 서버가 6LoWPAN 노드에 의해 호스팅되는 경우 \[RFC4944\] 및 \[RFC6282\]에 정의된 61616-61631 압축 UDP 포트 공간의 포트 번호도 지원하면 헤더 압축 효율성이 향상됩니다. \(UDP 포트가 기본 포트와 다르므로 기본 포트의 서버와 엔드포인트도 다릅니다.\)

---
### **7.2.  Resource Discovery**

CoAP 엔드포인트에서 제공하는 리소스 검색은 루프에 사람이 없고 정적 인터페이스로 인해 취약한 M2M\(Machine-to-Machine\) 애플리케이션에서 매우 중요합니다. CoRE 환경에서 상호 운용성을 최대화하려면 CoAP 엔드포인트는 완전 수동 구성이 필요한 경우를 제외하고 \[RFC6690\]에 설명된 대로 검색 가능한 리소스의 CoRE 링크 형식을 지원해야 합니다. 검색 가능한 리소스\(있는 경우\)는 서버에 달려 있습니다.

---
#### **7.2.1.  'ct' Attribute**

이 섹션에서는 \[RFC6690\]과 함께 사용할 새로운 웹 링크 \[RFC5988\] 속성을 정의합니다. Content-Format 코드 "ct" 속성은 이 리소스가 반환하는 Content-Format에 대한 힌트를 제공합니다. 이는 단지 힌트일 뿐이며 다음의 Content-Format 옵션을 재정의하지 않습니다.

실제로 자원의 표현을 요청하여 얻은 CoAP 응답입니다. 값은 CoAP 식별자 코드 형식의 10진수 ASCII 정수이며 0\~65535\(16비트 부호 없는 정수\) 범위에 있어야 합니다. 예를 들어, "application/xml"은 "ct=41"로 표시됩니다. Content-Format 코드 속성이 없으면 유형에 대해 아무 것도 가정할 수 없습니다. Content-Format 코드 속성은 여러 콘텐츠 형식이 사용 가능함을 나타내는 공백으로 구분된 Content-Format 코드 시퀀스를 포함할 수 있습니다. 속성 값의 구문은 그림 12의 생성 "ct-value"에 요약되어 있으며, 여기서 "cardinal", "SP" 및 "DQUOTE"는 \[RFC6690\]에서와 같이 정의됩니다.

```text
      ct-value =  cardinal
               /  DQUOTE cardinal *( 1*SP cardinal ) DQUOTE

                                 Figure 12
```

---
## **8.  Multicast CoAP**

CoAP는 IP 멀티캐스트 그룹에 대한 요청을 지원합니다. 이는 유니캐스트 CoAP에 대한 일련의 델타로 정의됩니다. CoAP를 사용한 그룹 통신에 대한 보다 일반적인 논의는 \[GROUPCOMM\]에 있습니다.

다른 엔드포인트가 멀티캐스트 서비스 검색을 사용하여 찾을 수 있도록 하는 서비스를 제공하는 CoAP 엔드포인트는 하나 이상의 적절한 전체 CoAP 노드 멀티캐스트 주소\(섹션 12.8\)에 가입하고 기본 CoAP 포트에서 수신 대기합니다. 엔드포인트는 모든 노드 IPv6 주소\(또는 IPv4의 브로드캐스트를 통해\)를 포함하여 다른 멀티캐스트 주소에서 멀티캐스트 요청을 수신할 수 있습니다. 따라서 엔드포인트는 그러한 메시지를 수신할 준비가 되어 있어야 하지만 멀티캐스트 서비스 검색이 바람직하지 않은 경우 이를 무시할 수 있습니다.

---
### **8.1.  Messaging Layer**

멀티캐스트 요청은 CoAP 끝점 대신 IP 멀티캐스트 주소로 주소가 지정되는 CoAP 메시지로 전송되는 것이 특징입니다. 이러한 멀티캐스트 요청은 확인 불가능해야 합니다.

서버는 가능한 경우 IPV6\_RECVPKTINFO \[RFC3542\]와 같은 최신 API를 사용하여 멀티캐스트를 통해 요청이 도착했음을 인식해야 합니다.

오류 응답의 파열을 피하기 위해 서버는 요청이 멀티캐스트를 통해 도착했음을 인식할 때 확인 불가능 메시지에 대한 응답으로 재설정 메시지를 반환해서는 안 됩니다. 인식하지 못하는 경우 평소와 같이 확인 불가능 메시지에 대한 응답으로 재설정 메시지를 반환할 수 있습니다. 이러한 재설정 메시지는 다음과 동일하게 보입니다.

발신자로부터 유니캐스트 메시지를 수신하는 경우 발신자는 멀티캐스트 메시지를 수신할 수 있는 유니캐스트 끝점과 함께 이 끝점에서 여전히 활성 상태인 메시지 ID를 사용하지 않아야 합니다.

이 글을 쓰는 시점에서 멀티캐스트 메시지는 DTLS가 아닌 UDP로만 전달될 수 있습니다. 이는 본 문서에서 CoAP에 대해 정의된 보안 모드가 멀티캐스트에 적용되지 않음을 의미합니다.

---
### **8.2.  Request/Response Layer**

서버가 멀티캐스트를 통해 요청이 도착했음을 인식하면 서버는 항상 요청을 무시할 수 있습니다. 특히 응답하는 데 유용한 것이 없는 경우\(예: 빈 페이로드 또는 오류 응답만 있는 경우\). 이에 대한 결정은 애플리케이션에 따라 달라질 수 있습니다. \(예를 들어, \[RFC6690\]에 설명된 쿼리 필터링에서 필터가 일치하지 않으면 서버는 멀티캐스트 요청에 응답해서는 안 됩니다. 더 많은 예는 \[GROUPCOMM\]에 있습니다.\)

서버가 멀티캐스트 요청에 응답하기로 결정한 경우 즉시 응답해서는 안 됩니다. 대신, 응답하려는 기간에 대한 기간을 선택해야 합니다. 이 설명의 목적상 우리는 이 기간을 여가라고 부릅니다. 이 레저의 구체적인 가치는 애플리케이션에 따라 달라지거나 아래 설명된 대로 파생될 수 있습니다. 그런 다음 서버는 선택한 여가 기간 내에서 임의의 시점을 선택하여 멀티캐스트 요청에 대한 유니캐스트 응답을 다시 보내야 합니다. 동일한 멀티캐스트 주소 멤버십을 기반으로 추가 응답을 보내야 하는 경우, 이전 여가 기간이 끝난 후 가장 빠른 시점에 새로운 여가 기간이 시작됩니다.

여가 값을 계산하려면 서버에는 그룹 크기 추정 G, 목표 데이터 전송 속도 R\(둘 다 보수적으로 선택해야 함\) 및 추정 응답 크기 S가 있어야 합니다. 여가에 대한 대략적인 하한은 다음과 같이 계산될 수 있습니다.

```text
                          lb_Leisure = S * G / R
```

예를 들어, 2.4GHz IEEE 802.15.4\(6LoWPAN\) 네트워크에서 링크-로컬 범위의 멀티캐스트 요청의 경우 G는 \(상대적으로 보수적으로\) 100, S는 100바이트, 대상 속도는 8kbit/s로 설정될 수 있습니다. = 1KB/초. 결과적으로 레저의 하한은 10초입니다.

CoAP 엔드포인트에 레저 값을 계산하는 데 적합한 데이터가 없는 경우 DEFAULT\_LEISURE를 사용할 수 있습니다.

멀티캐스트 요청에 대한 응답을 일치시킬 때 토큰만 일치해야 합니다. 응답의 소스 엔드포인트는 원래 요청의 대상 엔드포인트와 동일할 필요가 없으며 동일하지도 않습니다.

Location-\* 옵션과 표현에 포함된 모든 링크를 해석하기 위해 요청 URI\(즉, 응답이 해석되는 기준이 되는 기본 URI\)는 원래 요청의 호스트 구성 요소에 있는 멀티캐스트 주소를 대체하여 형성됩니다. 실제로 응답하는 엔드포인트의 리터럴 IP 주소에 따른 URI입니다.

---
#### **8.2.1.  Caching**

클라이언트가 멀티캐스트 요청을 할 때 항상 멀티캐스트 그룹에 새로운 요청을 보냅니다\(그 동안 가입한 새 그룹 구성원이 있거나 이전 요청을 받지 못한 구성원이 있을 수 있기 때문\). 수신된 응답으로 캐시를 업데이트할 수 있습니다. 그런 다음 요청의 결과로 캐시된 여전히 신선한 응답과 새 응답을 모두 사용합니다.

멀티캐스트 그룹에 대한 GET 요청에 대한 응답으로 수신된 응답은 관련 유니캐스트 요청 URI에 대한 후속 요청을 만족시키는 데 사용될 수 있습니다. 유니캐스트 요청 URI는 요청 URI의 권한 부분을 응답 메시지의 전송 계층 소스 주소로 대체하여 얻습니다.

캐시는 관련 유니캐스트 요청 URI에 대해 GET 요청을 하여 응답을 재검증할 수 있습니다.

멀티캐스트 그룹에 대한 GET 요청에는 ETag 옵션이 포함되어서는 안 됩니다. 클라이언트가 이미 가지고 있는 응답을 억제하는 메커니즘은 추가 연구로 남겨져 있습니다.

---
#### **8.2.2.  Proxying**

전달 프록시가 멀티캐스트 주소를 나타내는 Proxy-Uri 또는 Proxy-Scheme에서 구성된 URI를 사용하여 요청을 받으면 프록시는 위에서 설명한 대로 응답 집합을 얻고 모든 응답\(캐시된 여전히 새로운 응답과 새 응답 모두\)을 보냅니다. 원래 클라이언트로 돌아갑니다.

이 사양은 전달된 응답에서 유니캐스트 수정 요청 URI\(기본 URI\)를 표시하는 방법을 제공하지 않습니다. 멀티캐스트 요청 프록싱에 대해서는 \[GROUPCOMM\]에서 자세히 설명합니다. 기본 URI 문제를 해결하기 위한 제안 중 하나는 \[CoAP-MISC\]의 섹션 3에서 찾을 수 있습니다.

---
## **9.  Securing CoAP**

이 섹션에서는 CoAP에 대한 DTLS 바인딩을 정의합니다.

프로비저닝 단계에서 CoAP 장치에는 키 자료 및 액세스 제어 목록을 포함하여 필요한 보안 정보가 제공됩니다. 이 사양은 섹션 9.1.3.2.1의 RawPublicKey 모드에 대한 프로비저닝을 정의합니다. 프로비저닝 단계가 끝나면 장치는 해당 모드에 대한 다음 정보를 포함하는 4가지 보안 모드 중 하나가 됩니다. 이 사양을 구현하려면 NoSec 및 RawPublicKey 모드가 필수입니다.

NoSec: 프로토콜 수준 보안이 없습니다\(DTLS가 비활성화됨\). 적절한 경우 하위 계층 보안을 제공하는 대체 기술을 사용해야 합니다. IPsec의 사용은 \[IPsec-CoAP\]에서 논의됩니다. 제한된 노드와 함께 사용되는 특정 링크 계층은 적절한 키 관리에 적합할 수 있는 링크 계층 보안도 제공합니다.

PreSharedKey: DTLS가 활성화되고 사전 공유 키 목록\[RFC4279\]이 있으며 각 키에는 섹션 9.1.3.1에 설명된 대로 통신하는 데 사용할 수 있는 노드 목록이 포함됩니다. 극단적으로, 이 CoAP 노드가 통신해야 하는 각 노드마다 하나의 키가 있을 수 있습니다\(1:1 노드/키 비율\). 반대로, 두 개 이상의 엔터티가 특정 사전 공유 키를 공유하는 경우 이 키를 사용하면 엔터티가 특정 피어가 아닌 해당 그룹의 구성원으로만 인증할 수 있습니다.

RawPublicKey: DTLS가 활성화되고 장치에는 섹션 9.1.3.2에 설명된 대로 대역 외 메커니즘\[RFC7250\]을 사용하여 유효성이 검사되는 인증서\(원시 공개 키\) 없이 비대칭 키 쌍이 있습니다. 또한 장치에는 공개 키에서 계산된 ID와 통신할 수 있는 노드의 ID 목록이 있습니다.

인증서: DTLS가 활성화되고 장치에는 섹션 9.1.3.3에 설명된 대로 주체에 바인딩되고 일부 공통 신뢰 루트에 의해 서명되는 X.509 인증서\[RFC5280\]가 있는 비대칭 키 쌍이 있습니다. 장치에는 인증서 검증에 사용할 수 있는 루트 신뢰 앵커 목록도 있습니다.

"NoSec" 모드에서 시스템은 단순히 IP를 통한 일반 UDP를 통해 패킷을 전송하며 "coap" 구성표와 CoAP 기본 포트로 표시됩니다. 공격자가 CoAP 노드를 사용하여 네트워크에서 패킷을 보내거나 받을 수 없도록 방지함으로써만 시스템이 보호됩니다. 이 접근법의 추가적인 복잡성에 대해서는 섹션 11.5를 참조하십시오.

다른 세 가지 보안 모드는 DTLS를 사용하여 구현되며 "coaps" 체계와 DTLS 보안 CoAP 기본 포트로 표시됩니다. 결과적으로 보안 모델의 한계 내에서 인증하고 이 인증을 기반으로 통신 파트너에게 권한을 부여하는 데 사용할 수 있는 보안 연결이 생성됩니다. CoAP 자체는 인증이나 권한 부여를 위한 프로토콜 기본 요소를 제공하지 않습니다. 이것이 필요한 경우 통신 보안\(예: IPsec 또는 DTLS\) 또는 객체 보안\(페이로드 내\)을 통해 제공될 수 있습니다. 특정 작업에 대한 인증이 필요한 장치에는 이러한 두 가지 보안 형식 중 하나가 필요할 것으로 예상됩니다. 필연적으로 중개자가 관련된 경우 통신 보안은 해당 중개자가 신뢰 관계의 일부일 때만 작동합니다. CoAP는 클라이언트가 중개자를 통해 가질 수 있는 다양한 수준의 인증을 추가 중개자 또는 원본 서버로 전달하는 방법을 제공하지 않습니다. 따라서 첫 번째 중개자에서 모든 인증을 수행해야 할 수도 있습니다.

---
### **9.1.  DTLS-Secured CoAP**

HTTP가 TCP를 통한 TLS\(전송 계층 보안\)를 사용하여 보호되는 것처럼 CoAP는 UDP를 통한 데이터그램 TLS\(DTLS\) \[RFC6347\]를 사용하여 보호됩니다\(그림 13 참조\). 이 섹션에서는 제한된 환경에 적합한 최소한의 필수 구현 구성과 함께 DTLS에 대한 CoAP 바인딩을 정의합니다. 바인딩은 유니캐스트 CoAP에 대한 일련의 델타로 정의됩니다. 실제로 DTLS는 UDP 전송의 불안정한 특성을 처리하기 위해 기능이 추가된 TLS입니다.

```text
                         +----------------------+
                         |      Application     |
                         +----------------------+
                         +----------------------+
                         |  Requests/Responses  |
                         |----------------------|  CoAP
                         |       Messages       |
                         +----------------------+
                         +----------------------+
                         |         DTLS         |
                         +----------------------+
                         +----------------------+
                         |          UDP         |
                         +----------------------+

             Figure 13: Abstract Layering of DTLS-Secured CoAP
```

일부 제한된 노드\(제한된 플래시 및/또는 RAM\) 및 네트워크\(제한된 대역폭 또는 높은 확장성 요구 사항\)에서는 사용 중인 특정 암호화 제품군에 따라 DTLS의 모든 모드가 적용되지 않을 수 있습니다. 일부 DTLS 암호화 제품군은 보안 연결을 설정할 때 필요한 일부 초기 핸드셰이크 오버헤드뿐만 아니라 상당한 구현 복잡성을 추가할 수 있습니다. 초기 핸드셰이크가 완료되면 DTLS는 초기화 벡터/nonce\(예: TLS\_PSK\_WITH\_AES\_128\_CCM\_8 \[RFC6655\]의 8바이트\), 무결성 검사 값\(예: TLS\_PSK\_WITH\_AES\_128\_CCM\_8의 8바이트\)을 포함하지 않고 약 13바이트의 제한된 데이터그램별 오버헤드를 추가합니다. RFC6655\]\) 및 암호 제품군에 필요한 패딩입니다. 특정 DTLS 모드의 사용이 CoAP 기반 애플리케이션에 적용 가능한지 여부는 적용 가능한 특정 암호화 제품군, 세션 유지 관리를 통해 애플리케이션 흐름과 호환되는지 여부, 그리고 충분한 리소스를 사용할 수 있는지 여부를 신중하게 고려해야 합니다. 제한된 노드와 추가된 네트워크 오버헤드. \(DTLS를 사용하는 일부 모드의 경우 이 사양은 필수 구현 암호 제품군을 식별합니다. 이는 이러한 암호 제품군이 실제로 적절한 경우 상호 운용성을 최대화하기 위한 구현 요구 사항입니다. 애플리케이션의 특정 보안 정책에 따라 실제 보안 정책이 결정될 수 있습니다. 사용할 수 있는 암호 제품군 집합입니다.\) DTLS는 그룹 키잉\(멀티캐스트 통신\)에 적용할 수 없습니다. 그러나 이는 향후 그룹 키 관리 프로토콜의 구성 요소가 될 수 있습니다.

---
#### **9.1.1.  Messaging Layer**

CoAP 클라이언트 역할을 하는 엔드포인트는 DTLS 클라이언트 역할도 해야 합니다. 적절한 포트에서 서버에 대한 세션을 시작해야 합니다. DTLS 핸드셰이크가 완료되면 클라이언트는 첫 번째 CoAP 요청을 시작할 수 있습니다. 모든 CoAP 메시지는 DTLS "애플리케이션 데이터"로 전송되어야 합니다.

승인 메시지 또는 재설정 메시지를 확인 가능 메시지에 일치시키거나 재설정 메시지를 확인 불가능 메시지에 일치시키기 위해 다음 규칙이 추가됩니다. DTLS 세션은 동일해야 하며 에포크는 동일해야 합니다.

동일한 DTLS 세션, 동일한 에포크 내에서 전송되고 동일한 메시지 ID를 갖는 메시지는 동일합니다.

참고: 확인 가능 메시지가 재전송되면 CoAP 메시지 ID가 동일하게 유지되더라도 각 시도마다 새로운 DTLS 시퀀스\_번호가 사용됩니다. 따라서 수신자는 여전히 섹션 4.5에 설명된 대로 중복 제거를 수행해야 합니다. 재전송은 여러 시대에 걸쳐 수행되어서는 안 됩니다.

RawPublicKey 및 인증서 모드의 DTLS 연결은 상호 인증을 사용하여 설정되므로 연결을 유지하고 향후 어느 방향에서든 메시지 교환에 재사용할 수 있습니다. 장치는 리소스를 복구해야 할 때 DTLS 연결을 닫을 수 있지만 일반적으로 가능한 한 오랫동안 연결을 유지해야 합니다. 모든 CoAP 메시지 교환 후에 DTLS 연결을 닫는 것은 매우 비효율적입니다.

---
#### **9.1.2.  Request/Response Layer**

요청에 대한 응답을 일치시키기 위해 다음 규칙이 추가됩니다. DTLS 세션은 동일해야 하며 에포크는 동일해야 합니다.

이는 DTLS 보안 요청에 대한 응답이 항상 동일한 보안 세션 및 에포크를 사용하여 DTLS 보안을 받아야 함을 의미합니다. DTLS 요청에 NoSec 응답을 제공하려는 모든 시도는 단순히 요청과 일치하지 않으므로 반드시 거부되어야 합니다\(관련되지 않은 NoSec 요청과 일치하지 않는 한\).

---
#### **9.1.3.  Endpoint Identity**

장치는 \[RFC6066\]의 섹션 3에 정의된 대로 SNI HostName 필드에서 해당 권한을 나타내기 위해 SNI\(서버 이름 표시\)를 지원해야 합니다. 이는 여러 기관에 대한 가상 서버 역할을 하는 호스트가 새로운 DTLS 연결을 수신할 때 DTLS 세션에 사용할 키를 알기 위해 필요합니다.

---
##### **9.1.3.1.  Pre-Shared Keys**

새로운 노드에 연결을 형성할 때 시스템은 도달하려는 노드에 따라 적절한 키를 선택한 후 DTLS의 PSK\(Pre-Shared Key\) 모드를 사용하여 DTLS 세션을 형성합니다. 이러한 모드의 구현은 \[RFC6655\]에 지정된 대로 구현 필수 암호 제품군 TLS\_PSK\_WITH\_AES\_128\_CCM\_8을 지원해야 합니다.

커미셔닝 모델에 따라 애플리케이션은 PSK 신원 힌트 사용을 활성화하기 위해 신원 힌트\(\[RFC4279\]의 섹션 5.2에서 필요하고 자세히 설명된 대로\)에 대한 애플리케이션 프로필을 정의해야 할 수 있습니다.

\[RFC4279\] 섹션 7의 보안 고려사항이 적용됩니다. 특히 애플리케이션은 PFS\(Perfect Forward Secrecy\)가 필요한지 여부를 신중하게 평가하고 적절한 암호화 제품군을 선택해야 합니다\(\[RFC4279\]의 섹션 7.1\). PSK의 엔트로피는 무차별 대입 및 \(PSK가 무작위로 선택되지 않고 사람에 의해 선택되는 경우\) 사전 공격\(\[RFC4279\]의 섹션 7.2\)을 완화하기에 충분해야 합니다. 클라이언트 ID의 일반 텍스트 통신은 데이터를 유출하거나 개인정보를 침해할 수 있습니다\(\[RFC4279\]의 섹션 7.3\).

---
##### **9.1.3.2.  Raw Public Key Certificates**

이 모드에서는 장치에 비대칭 키 쌍이 있지만 X.509 인증서\(원시 공개 키라고 함\)는 없습니다. 예를 들어 비대칭 키 쌍은 제조업체에서 생성하여 장치에 설치합니다\(섹션 11.6 참조\). 장치는 여러 개의 원시 공개 키로 구성될 수 있습니다. 원시 공개 키의 유형과 길이는 사용된 암호 제품군에 따라 다릅니다. RawPublicKey 모드의 구현은 \[RFC7251\], \[RFC5246\] 및 \[RFC4492\]에 지정된 대로 구현 필수 암호 제품군 TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CCM\_8을 지원해야 합니다\(MUST\). 사용되는 키는 ECDSA를 지원해야 합니다. 곡선 secp256r1은 \[RFC4492\]를 지원해야 합니다. 이 곡선은 NIST P-256 곡선과 동일합니다. 해시 알고리즘은 SHA-256입니다. 구현은 지원되는 타원 곡선 및 지원되는 포인트 형식 확장 \[RFC4492\]을 사용해야 합니다. 압축되지 않은 포인트 형식이 지원되어야 합니다. 구현 방법으로는 \[RFC6090\]을 사용할 수 있다. 이 암호 제품군의 구현과 관련된 일부 지침은 \[W3CXMLSEC\]에서 찾을 수 있습니다. TLS와 함께 원시 공개 키를 사용하는 메커니즘은 \[RFC7250\]에 지정되어 있습니다.

구현 참고 사항: 특히 이는 그림 14에 나열된 확장과 최소한 나열된 값이 DTLS 핸드셰이크에 존재함을 의미합니다.

```text
   Extension: elliptic_curves
    Type: elliptic_curves (0x000a)
    Length: 4
    Elliptic Curves Length: 2
    Elliptic curves (1 curve)
      Elliptic curve: secp256r1 (0x0017)

   Extension: ec_point_formats
    Type: ec_point_formats (0x000b)
    Length: 2
    EC point formats Length: 1
    Elliptic curves point formats (1)
      EC point format: uncompressed (0)

   Extension: signature_algorithms
    Type: signature_algorithms (0x000d)
    Length: 4
    Data (4 bytes): 00 02 04 03
      HashAlgorithm: sha256 (4)
      SignatureAlgorithm: ecdsa (3)

                  Figure 14: DTLS Extensions Present for
                    TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8
```

---
###### **9.1.3.2.1.  Provisioning**

RawPublicKey 모드는 M2M 배포에서 쉽게 프로비저닝되도록 설계되었습니다. 각 장치에는 적절한 비대칭 공개 키 쌍이 설치되어 있다고 가정합니다. 식별자는 \[RFC6920\]의 섹션 2에 설명된 대로 공개 키의 엔드포인트에 의해 계산됩니다. RawPublicKey ID 확인을 지원하는 모든 구현은 최소한 sha-256-120 모드\(SHA-256이 120비트로 잘림\)를 지원해야 합니다. 구현은 더 긴 길이의 식별자도 지원해야 하며\(SHOULD\) 더 짧은 길이를 지원할 수도 있습니다\(MAY\). 길이가 짧을수록 공격에 대한 보안이 덜 제공되므로 사용이 권장되지 않습니다.

이를 확인하는 시스템에 식별자가 제공되는 방식에 따라 URI, 바이너리 및/또는 사람이 말할 수 있는 형식\[RFC6920\]에 대한 지원을 구현해야 합니다. 모든 구현은 바이너리 모드를 지원해야 하며\(SHOULD\) 사용자 인터페이스가 있는 구현은 사람이 말할 수 있는 형식도 지원해야 합니다\(SHOULD\).

프로비저닝 중에 각 노드의 식별자는 장치 외부의 바코드를 읽거나 미리 컴파일된 식별자 목록을 얻는 등의 방식으로 수집됩니다. 그런 다음 이러한 식별자는 M2M 데이터 수집 서버와 같은 해당 엔드포인트에 설치됩니다. 식별자는 엔드포인트를 추가 장치 정보와 연결하고 액세스 제어를 수행하는 두 가지 목적으로 사용됩니다. \(초기 및 진행 중인\) 프로비저닝 중에 장치가 DTLS 세션을 시작할 수 있는 식별자의 액세스 제어 목록도 설치 및 유지되어야 합니다.

---
##### **9.1.3.3.  X.509 Certificates**

인증서 모드의 구현은 \[RFC7251\], \[RFC5246\] 및 \[RFC4492\]에 지정된 대로 구현 필수 암호 제품군 TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CCM\_8을 지원해야 합니다. 즉, 인증서에는 명명된 곡선 secp256r1 \[RFC5480\]을 사용하여 id-ecPublicKey의 알고리즘을 나타내는 SubjectPublicKeyInfo가 포함되어 있습니다. 공개 키 형식은 압축되지 않습니다 \[RFC5480\]. 해시 알고리즘은 SHA-256입니다. 포함된 경우 키 사용 확장은 digitalSignature를 나타냅니다. 인증서는 secp256r1을 사용하여 ECDSA로 서명해야 하며 서명은 SHA-256을 사용해야 합니다. 사용되는 키는 ECDSA를 지원해야 합니다. 곡선 secp256r1은 \[RFC4492\]를 지원해야 합니다. 이 곡선은 NIST P-256 곡선과 동일합니다. 해시 알고리즘은 SHA-256입니다. 구현은 지원되는 타원 곡선 및 지원되는 포인트 형식 확장 \[RFC4492\]을 사용해야 합니다. 압축되지 않은 포인트 형식이 지원되어야 합니다. 구현 방법으로는 \[RFC6090\]을 사용할 수 있다.

인증서의 제목은 EUI-64 \[EUI64\]와 같은 장치의 장기 고유 식별자로 구성됩니다. 제목은 CoAP URI의 호스트 부분으로 사용된 FQDN\(정규화된 도메인 이름\)을 기반으로 할 수도 있습니다. 그러나 장치의 IP 주소는 시간이 지남에 따라 변경되므로 일반적으로 제목으로 사용해서는 안 됩니다. 시스템에서 사용되는 검색 프로세스는 지정된 장치의 IP 주소와 각 장치의 주체 간의 매핑을 구축합니다. 일부 장치에는 둘 이상의 주제가 있을 수 있으며 단일 인증서 이상이 필요할 수 있습니다.

새로운 연결이 형성되면 원격 장치의 인증서를 확인해야 합니다. CoAP 노드에 절대 시간 소스가 있는 경우 노드는 인증서의 유효 날짜가 범위 내에 있는지 확인해야 합니다. 인증서는 \[RFC5280\]의 섹션 6에 지정된 알고리즘과 동등한 기능을 사용하여 보안 요구 사항에 적합한지 검증되어야 합니다. 인증서에 SubjectAltName이 포함된 경우 요청 URI의 권한은 SubjectAltName 집합의 URI 유형 필드에 있는 CoAP URI의 권한 중 최소한 하나와 일치해야 합니다. 인증서에 SubjectAltName이 없으면 요청 URI의 기관은 와일드카드가 있는 인증서가 허용되지 않는다는 점을 제외하고 \[RFC3280\]에 정의된 일치 규칙을 사용하여 인증서에 있는 CN\(일반 이름\)과 일치해야 합니다.

인증서 상태 확인을 위한 CoRE 지원에는 추가 연구가 필요합니다. CoAP에 대한 온라인 인증서 상태 프로토콜\(OCSP\) \[RFC6960\]의 매핑은 현재 정의되어 있지 않으며 OCSP도 모든 환경에 쉽게 적용할 수 없기 때문에 대체 접근 방식은 TLS 인증서 상태 요청 확장\(\[의 섹션 8\)을 사용하는 것입니다. RFC6066\]; "OCSP 스테이플링"이라고도 함\) 또는 가능한 경우 다중 인증서 상태 확장\(\[RFC6961\]\)을 사용하는 것이 좋습니다.

시스템에 인증서 외에 공유 키가 있는 경우 TLS\_ECDHE\_PSK\_WITH\_AES\_128\_CBC\_SHA \[RFC5489\]와 같은 공유 키를 포함하는 암호 제품군을 사용해야 합니다.

---
## **10.  Cross-Protocol Proxying between CoAP and HTTP**

CoAP는 HTTP 기능의 제한된 하위 집합을 지원하므로 HTTP에 대한 크로스 프로토콜 프록싱이 간단합니다. 예를 들어 두 프로토콜 중 하나를 통해 사용할 웹 인터페이스를 설계할 때 또는 CoAP-HTTP 프록시를 실현할 때 CoAP와 HTTP 간 프록싱을 수행하는 데는 여러 가지 이유가 있을 수 있습니다. 마찬가지로 CoAP는 XMPP \[RFC6120\] 또는 SIP \[RFC3264\]와 같은 다른 프로토콜에도 동일하게 프록시될 수 있습니다. 이러한 메커니즘의 정의는 이 사양의 범위를 벗어납니다.

정방향 프록시를 통해 리소스에 액세스하는 데는 두 가지 가능한 방향이 있습니다.

CoAP-HTTP 프록싱: CoAP 클라이언트가 중개자를 통해 HTTP 서버의 리소스에 액세스할 수 있도록 합니다. 이는 CoAP-HTTP 프록시에 대한 CoAP 요청에 "http" 또는 "https" URI와 함께 Proxy-Uri 또는 Proxy-Scheme 옵션을 포함함으로써 시작됩니다.

HTTP-CoAP 프록싱: HTTP 클라이언트가 중개자를 통해 CoAP 서버의 리소스에 액세스할 수 있도록 합니다. 이는 HTTP-CoAP 프록시에 대한 HTTP 요청의 요청 라인에 "coap" 또는 "coaps" URI를 지정하여 시작됩니다.

어느 쪽이든 CoAP의 요청/응답 모델만 HTTP에 매핑됩니다. 확인 가능 또는 확인 불가능 메시지 등의 기본 모델은 보이지 않으며 프록시 기능에 영향을 미치지 않아야 합니다. 다음 섹션에서는 정방향 프록시에 대한 요청 처리에 대해 설명합니다. 프록시 기능은 마치 원본 서버인 것처럼 작동하는 프록시를 사용하여 클라이언트에 투명하므로 역방향 프록시는 지정되지 않습니다. 그러나 역방향 프록시에도 순방향 프록시와 유사한 고려 사항이 적용되며 일반적으로 역방향 프록시가 순방향 프록시와 유사한 방식으로 작동할 것으로 예상됩니다. 구현 참고 사항으로, HTTP 클라이언트 라이브러리는 HTTP 요청 라인에 CoAP URI를 배치하는 방법을 제공하지 않음으로써 HTTP-CoAP 전달 프록시를 작동하기 어렵게 만들 수 있습니다. 따라서 역방향 프록시를 사용하면 프록시를 더 광범위하게 적용할 수 있습니다. 별도의 사양에서는 HTTP-CoAP 역방향 프록시 \[MAPPING\] 등을 작동하는 URI에 대한 규칙을 정의할 수 있습니다.

---
### **10.1.  CoAP-HTTP Proxying**

요청에 'http' 또는 'https' URI가 있는 Proxy-Uri 또는 Proxy-Scheme 옵션이 포함되어 있는 경우 \[RFC2616\] 수신 CoAP 엔드포인트\(이후 "프록시"라고 함\)는 요청에 지정된 작업을 수행하도록 요청됩니다. 표시된 HTTP 리소스에 메서드를 적용하고 결과를 클라이언트에 반환합니다. \(보안 요구 사항을 포함하여 프록시에 대한 요청이 어떻게 구성되는지에 대해서는 섹션 5.7을 참조하십시오.\)

이 섹션에서는 모든 CoAP 요청에 대해 프록시가 클라이언트에 반환해야 하는 CoAP 응답을 지정합니다. 프록시가 실제로 요청을 충족하는 방법은 구현 세부 사항이지만 일반적인 경우는 프록시가 요청을 변환하여 HTTP 원본 서버로 전달하는 것으로 예상됩니다.

HTTP와 CoAP는 기본 요청 방법 세트를 공유하므로 HTTP 리소스에 대해 CoAP 요청을 수행하는 것은 CoAP 리소스에 대해 수행하는 것과 크게 다르지 않습니다. HTTP 리소스에서 수행될 때 개별 CoAP 메서드의 의미는 이 섹션의 하위 섹션에서 설명됩니다.

프록시가 HTTP URI를 사용하여 요청을 처리할 수 없거나 처리할 의사가 없는 경우 5.05\(프록시 지원 안 됨\) 응답이 클라이언트에 반환됩니다. 프록시가 제3자\(예: HTTP 원본 서버\)와 상호 작용하여 요청을 처리하고 합리적인 시간 내에 결과를 얻을 수 없는 경우 5.04\(게이트웨이 시간 초과\) 응답이 반환됩니다. 결과를 얻을 수 있지만 이해할 수 없는 경우 5.02\(잘못된 게이트웨이\) 응답이 반환됩니다.

---
#### **10.1.1.  GET**

GET 메서드는 요청 URI로 식별되는 HTTP 리소스 표현을 반환하도록 프록시에 요청합니다.

성공하면 2.05\(콘텐츠\) 응답 코드가 반환되어야 합니다. 응답의 페이로드는 대상 HTTP 리소스의 표현이어야 하며 이에 따라 Content-Format 옵션을 설정해야 합니다. 응답은 표현이 새로운 것으로 간주될 수 있는 남은 시간보다 크지 않은 Max-Age 값을 나타내야 합니다. HTTP 엔터티에 엔터티 태그가 있는 경우 프록시는 응답에 ETag 옵션을 포함해야 하며 아래 설명된 대로 요청에 ETag 옵션을 처리해야 합니다.

클라이언트는 다음 옵션을 포함하여 GET 요청 처리에 영향을 미칠 수 있습니다.

수락: 요청에는 선호하는 응답 콘텐츠 형식을 식별하는 수락 옵션이 포함될 수 있습니다.

ETag: 요청에는 클라이언트가 저장한 응답을 식별하는 하나 이상의 ETag 옵션이 포함될 수 있습니다. 이는 프록시가 요청된 세트의 엔터티 태그와 함께 2.05\(콘텐츠\) 응답을 보낼 때마다 2.03\(유효\) 응답을 보내도록 요청합니다. CoAP ETag는 HTTP 측면에서 항상 강력한 ETag입니다. CoAP에는 HTTP 약한 ETag와 동등한 기능이 없으며 크로스 프록시에서 이를 활용할 수 있는 좋은 방법이 없습니다.

---
#### **10.1.2.  PUT**

PUT 메서드는 포함된 표현이 포함된 요청 URI로 식별되는 HTTP 리소스를 업데이트하거나 생성하도록 프록시에 요청합니다.

요청 URI에서 새 리소스가 생성되면 2.01\(생성됨\) 응답이 클라이언트에 반환되어야 합니다. 기존 리소스가 수정된 경우 요청이 성공적으로 완료되었음을 나타내기 위해 2.04\(변경됨\) 응답이 반환되어야 합니다.

---
#### **10.1.3.  DELETE**

DELETE 메소드는 HTTP 원본 서버에서 요청 URI로 식별되는 HTTP 리소스를 삭제하도록 프록시에 요청합니다.

2.02\(삭제됨\) 응답은 성공 시 또는 요청 시 리소스가 존재하지 않는 경우 클라이언트에 반환되어야 합니다.

---
#### **10.1.4.  POST**

POST 메소드는 요청에 포함된 표현이 HTTP 원본 서버에서 처리되도록 프록시에 요청합니다. POST 메서드에 의해 수행되는 실제 기능은 원본 서버에 의해 결정되며 요청 URI로 식별되는 리소스에 따라 달라집니다.

POST 메서드에 의해 수행된 작업으로 인해 URI로 식별할 수 있는 리소스가 생성되지 않으면 2.04\(변경됨\) 응답이 클라이언트에 반환되어야 합니다. 원본 서버에서 리소스가 생성된 경우 2.01\(Created\) 응답이 반환되어야 합니다.

---
### **10.2.  HTTP-CoAP Proxying**

HTTP 요청에 "coap" 또는 "coaps" URI가 있는 Request-URI가 포함된 경우 수신 HTTP 엔드포인트\(이후 "프록시"라고 함\)는 표시된 CoAP 리소스에 대한 요청 메서드에 의해 지정된 작업을 수행하도록 요청되고 결과를 클라이언트에 반환합니다.

이 섹션에서는 모든 HTTP 요청에 대해 프록시가 클라이언트에 반환해야 하는 HTTP 응답을 지정합니다. 달리 명시하지 않는 한, 작성된 모든 진술은 권장되는 동작입니다. 일부 매우 제한된 구현에서는 지름길을 사용해야 할 수도 있습니다. 프록시가 실제로 요청을 충족하는 방법은 구현 세부 사항이지만 일반적인 경우는 프록시가 요청을 변환하여 CoAP 원본 서버로 전달하는 것으로 예상됩니다. CoAP 리소스에서 수행될 때 개별 HTTP 메서드의 의미는 이 섹션의 하위 섹션에서 설명됩니다.

프록시가 CoAP URI를 사용하여 요청을 처리할 수 없거나 처리할 의사가 없는 경우 501\(구현되지 않음\) 응답이 클라이언트에 반환됩니다. 프록시가 제3자\(예: CoAP 원본 서버\)와 상호 작용하여 요청을 처리하고 합리적인 시간 내에 결과를 얻을 수 없는 경우 504\(Gateway Timeout\) 응답이 반환됩니다. 결과를 얻을 수 있지만 이해할 수 없는 경우 502\(잘못된 게이트웨이\) 응답이 반환됩니다.

---
#### **10.2.1.  OPTIONS and TRACE**

OPTIONS 및 TRACE 메서드는 CoAP에서 지원되지 않으므로 501\(구현되지 않음\) 오류가 클라이언트에 반환되어야 합니다.

---
#### **10.2.2.  GET**

GET 메소드는 요청-URI에 의해 식별된 CoAP 리소스의 표현을 반환하도록 프록시에 요청합니다.

성공하면 200\(OK\) 응답이 반환됩니다. 응답의 페이로드는 대상 CoAP 리소스의 표현이어야 하며 Content-Type 및 Content-Encoding 헤더 필드는 그에 따라 설정되어야 합니다. 응답은 표현이 새로운 것으로 간주될 수 있는 남은 시간보다 크지 않은 값을 나타내는 max-age 지시어를 나타내야 합니다. CoAP 응답에 ETag 옵션이 있는 경우 프록시는 응답에 ETag 헤더 필드를 포함해야 합니다.

클라이언트는 다음 옵션을 포함하여 GET 요청 처리에 영향을 미칠 수 있습니다.

Accept: 요청에서 HTTP Accept 헤더 필드의 가장 선호되는 미디어 유형이 CoAP Accept 옵션에 매핑됩니다. HTTP Accept 미디어 유형 범위, 매개변수 및 확장은 CoAP Accept 옵션에서 지원되지 않습니다. 프록시가 결합된 Accept 필드 값에 따라 허용되는 응답을 보낼 수 없는 경우 프록시는 406\(허용되지 않음\) 응답을 보냅니다. 그런 다음 프록시는 HTTP Accept 헤더 필드의 추가 미디어 유형으로 요청을 재시도할 수 있습니다.

조건부 GET: "If-Match" 또는 "If-None-Match" 요청 헤더 필드를 포함하는 조건부 HTTP GET 요청은 해당 CoAP 요청에 매핑될 수 있습니다. "If-Modified-Since" 및 "If- Unmodified-Since" 요청 헤더 필드는 CoAP에서 직접 지원되지 않지만 캐싱 프록시에 의해 로컬로 구현됩니다.

---
#### **10.2.3.  HEAD**

HEAD 메소드는 서버가 응답에서 메시지 본문을 반환해서는 안 된다는 점을 제외하면 GET과 동일합니다.

CoAP에는 HTTP의 HEAD 메서드와 직접적으로 동등한 것이 없지만 HTTP-CoAP 프록시는 CoAP 리소스에 대한 HEAD 요청에 응답하고 HTTP 헤더는 메시지 본문 없이 반환됩니다.

구현 참고 사항: HTTP-CoAP 프록시는 실제로 전송되는 데이터의 양을 최소화하기 위해 블록 단위 전송 옵션 \[BLOCK\]을 사용하려고 할 수 있지만 원본 서버가 블록 단위를 지원하지 않는 경우에 대비해야 합니다. 전송.

---
#### **10.2.4.  POST**

POST 메서드는 요청에 포함된 표현이 CoAP 원본 서버에서 처리되도록 프록시에 요청합니다. POST 메서드에 의해 수행되는 실제 기능은 원본 서버에 의해 결정되며 요청 URI로 식별되는 리소스에 따라 달라집니다.

POST 메서드에 의해 수행된 작업으로 인해 URI로 식별할 수 있는 리소스가 생성되지 않으면 200\(OK\) 또는 204\(No Content\) 응답이 클라이언트에 반환되어야 합니다. 원본 서버에서 리소스가 생성된 경우 201\(Created\) 응답이 반환되어야 합니다.

CoAP 응답에 Location-\* 옵션이 있으면 이러한 옵션 값으로 구성된 Location 헤더 필드가 반환됩니다.

---
#### **10.2.5.  PUT**

PUT 메서드는 포함된 표현을 사용하여 요청-URI로 식별된 CoAP 리소스를 업데이트하거나 생성하도록 프록시에 요청합니다.

Request-URI에서 새 리소스가 생성되면 201\(Created\) 응답이 클라이언트에 반환됩니다. 기존 리소스가 수정되면 요청이 성공적으로 완료되었음을 나타내기 위해 200\(정상\) 또는 204\(콘텐츠 없음\) 응답 코드가 전송됩니다.

---
#### **10.2.6.  DELETE**

DELETE 메소드는 CoAP 원본 서버에서 Request-URI로 식별된 CoAP 리소스를 삭제하도록 프록시에 요청합니다.

응답에 상태를 설명하는 엔터티가 포함된 경우 성공적인 응답은 200\(OK\)이고 작업이 실행되었지만 응답에 엔터티가 포함되지 않은 경우 204\(콘텐츠 없음\)입니다.

---
#### **10.2.7.  CONNECT**

TLS에서 DTLS로의 터널링이 아직 지정되지 않았기 때문에 이 방법은 현재 HTTP-CoAP 프록시 기능으로 충족될 수 없습니다. 현재는 501\(구현되지 않음\) 오류가 클라이언트에 반환됩니다.

---
## **11.  Security Considerations**

이 섹션에서는 프로토콜에 대한 가능한 위협을 분석합니다. 이 문서에 설명된 대로 프로토콜 및 애플리케이션 개발자에게 CoAP의 보안 제한 사항을 알리기 위한 것입니다. CoAP는 HTTP/1.1 기능의 하위 집합을 실현하므로 \[RFC2616\] 섹션 15의 보안 고려 사항도 CoAP와 관련이 있습니다. 이 섹션에서는 CoAP와 관련된 제한 사항을 중점적으로 설명합니다.

---
### **11.1.  Parsing the Protocol and Processing URIs**

네트워크 연결 애플리케이션은 수신 패킷에 대한 처리 논리에 취약성을 나타낼 수 있습니다. 복잡한 파서는 원격으로 노드를 충돌시키거나 원격으로 임의 코드를 실행하는 기능과 같은 취약점의 소스로 잘 알려져 있습니다. CoAP는 파서 복잡성을 줄이고, 가능한 경우 인코딩 가능한 값의 전체 범위에 의미를 부여하고, 동일한 것을 의미하는 여러 표현 간의 불필요한 선택으로 인해 종종 발생하는 복잡성을 공격적으로 줄임으로써 이러한 취약점이 도입될 기회를 줄이려고 시도합니다. 대부분의 URI 처리가 클라이언트로 이동되어 서버에 취약점이 유입될 가능성이 더욱 줄어듭니다. 그럼에도 불구하고 CoAP 구현의 URI 처리 코드는 남아 있는 취약점의 큰 원인이 될 수 있으므로 특별한 주의를 기울여 구현해야 합니다. CoAP 액세스 제어 구현은 URI에서 액세스 제어 결정을 도출하는 코드와 최종적으로 URI에 의해 주소 지정된 리소스를 제공하는 코드 간의 불일치로 인해 취약점이 발생하지 않도록 해야 합니다. 남은 가장 복잡한 파서는 CoRE 링크 형식용 파서일 수 있지만 이 파서는 구현 복잡성을 줄이기 위한 목적으로 설계되었습니다\[RFC6690\]. \(\[RFC2616\]의 섹션 15.2도 참조하세요.\)

---
### **11.2.  Proxying and Caching**

\[RFC2616\]의 섹션 15.7에서 언급했듯이 프록시는 본질적으로 중간자 역할을 하며 직접 CoAP 메시지 교환이 가질 수 있는 IPsec 또는 DTLS 보호를 깨뜨립니다. 따라서 CoAP 메시지 교환의 기밀성 또는 무결성을 깨뜨릴 수 있는 흥미로운 대상입니다. \[RFC2616\]에서 언급했듯이 가용성을 깨뜨리는 흥미로운 대상이기도 합니다.

요청/응답 데이터의 기밀성과 무결성에 대한 위협은 프록시도 캐시하는 경우 증폭됩니다. CoAP는 민감한 데이터를 더 잘 보호하기 위해 HTTP/1.1이 제공하는 캐시 억제 캐시 제어 옵션을 정의하지 않습니다.

캐싱 구현의 경우 캐시 항목을 생성하는 요청을 만드는 데 적용되는 모든 액세스 제어 고려 사항도 캐시의 값에 적용되어야 합니다. 이는 여러 보안 도메인을 구현하는 클라이언트뿐만 아니라 여러 클라이언트에 서비스를 제공할 수 있는 프록시에도 관련됩니다. 또한 캐싱 프록시는 처음에 프록시가 요청 전달을 수행하는 데 필요한 전송 보안 속성보다 낮은 전송 보안 속성을 가진 요청에 캐시된 값을 사용할 수 있도록 해서는 안 됩니다.

"coap" 방식과 달리 "coaps" 식별 요청에 대한 응답은 결코 "공개"가 아니므로 캐시가 캐시된 항목으로 이어진 것과 동일한 액세스 제어 결정을 내릴 수 없는 한 공유 캐싱에 재사용되어서는 안 됩니다. 그러나 메시지가 CoAP에서 기본적으로 캐시 가능한 경우 개인 캐시에서 재사용할 수 있습니다.

마지막으로, 여러 원래 요청자에게 별도의 응답\(피기백 응답과 반대\)을 전달하는 프록시는 추가 증폭을 제공할 수 있습니다\(섹션 11.3 참조\).

---
### **11.3.  Risk of Amplification**

CoAP 서버는 일반적으로 응답 패킷으로 요청 패킷에 응답합니다. 이 응답 패킷은 요청 패킷보다 상당히 클 수 있습니다. 공격자는 CoAP 노드를 사용하여 작은 공격 패킷을 더 큰 공격 패킷으로 전환할 수 있습니다. 이러한 접근 방식을 증폭이라고 합니다. 따라서 CoAP 노드가 프로토콜의 증폭 속성을 사용하여 서비스 거부\(DoS\) 공격에 연루될 위험이 있습니다. 공격자는 피해자에게 과부하를 시도하지만 생성할 수 있는 트래픽 양이 제한되어 있습니다. 증폭을 사용하여 더 많은 양의 트래픽을 생성할 수 있습니다.

UDP 프로토콜은 요청 패킷에 제공된 소스 주소를 확인할 수 있는 방법을 제공하지 않기 때문에 NoSec 액세스를 활성화하고 공격자로부터 액세스 가능하며 잠재적인 피해자\(예: 일반 인터넷\)에 액세스할 수 있는 노드에서 특히 문제가 됩니다. 공격자는 피해자를 향한 더 큰 패킷을 생성하기 위해 피해자의 IP 주소를 적절한 요청 패킷의 소스 주소에 배치하기만 하면 됩니다.

완화 요소로, 제한된 많은 네트워크는 소량의 트래픽만 생성할 수 있으므로 CoAP 노드가 이 공격에 덜 매력적일 수 있습니다. 그러나 제한된 네트워크의 제한된 용량으로 인해 네트워크 자체가 증폭 공격의 피해자가 될 가능성이 높습니다.

따라서 요청이 인증되지 않은 경우 응답에 큰 증폭 요소를 제공해서는 안 됩니다. CoAP 서버는 CoAP \[BLOCK\]의 슬라이싱/차단 모드를 사용하고 상대적으로 작은 조각에서만 큰 리소스 표현을 제공함으로써 공격자에게 제공하는 증폭의 양을 줄일 수 있습니다. 예를 들어, 1000바이트 리소스의 경우 10바이트 요청으로 인해 1016바이트 응답 대신 80바이트 응답\(64바이트 블록 포함\)이 발생하여 제공되는 증폭이 상당히 줄어들 수 있습니다.

CoAP는 요청 시 M2M의 중요한 요구 사항인 멀티캐스트 IP 주소 사용도 지원합니다. 멀티캐스트 CoAP 요청은 특히 제한된 네트워크에서 우발적이거나 고의적인 DoS 공격의 원인이 될 수 있습니다. 이 사양은 응답이 반환되는 시기를 제한하여 멀티캐스트 요청의 증폭 효과를 줄이려고 시도합니다. 악의적인 사용 가능성을 제한하기 위해 CoAP 서버는 암호화 방식이나 잠재적 소스를 제한하는 일부 멀티캐스트 경계로 인증할 수 없는 멀티캐스트 요청을 수락해서는 안 됩니다. 가능하다면 CoAP 서버는 멀티캐스트 요청 지원을 기능이 필요한 특정 리소스로 제한해야 합니다.

POSIX 스타일 API \[IEEE1003.1\]를 제공하는 일부 범용 운영 체제에서는 수신된 패킷이 멀티캐스트 주소로 지정되었는지 여부를 확인하는 것이 간단하지 않습니다. 많은 구현에서는 멀티캐스트 그룹에 가입했는지 여부를 알지만 이는 모든 IPv6 노드에서 수신되는 FF0x::1 형식의 멀티캐스트 주소로 주소가 지정된 패킷에 문제를 야기합니다. 구현 시에는 IPV6\_RECVPKTINFO \[RFC3542\]와 같은 최신 API를 사용하여 이러한 결정을 내려야 합니다.

---
### **11.4.  IP Address Spoofing Attacks**

UDP에는 핸드셰이크가 없기 때문에 제한된 네트워크\(예: 노드/키 비율이 1:1보다 큰 NoSec 또는 PreSharedKey 배포\)에서 전달되는 메시지를 자유롭게 읽고 쓸 수 있는 악성 엔드포인트가 단일 엔드포인트를 쉽게 공격할 수 있습니다. 엔드포인트, 엔드포인트 그룹 및 전체 네트워크. 예:

1. 확인 가능 메시지 또는 확인 불가능 메시지에 대한 응답으로 재설정 메시지를 스푸핑하여 엔드포인트를 "귀머거리"로 만듭니다. 또는

1. CON 메시지에 대한 응답으로 ACK를 스푸핑하여 잠재적으로 CON 메시지 발신자의 재전송을 방지하고 실제 응답을 익사시킵니다. 또는

1. 위조된 페이로드/옵션으로 전체 응답을 스푸핑\(이것은 단일 응답 중단부터 지원 인프라에 대한 훨씬 더 대담한 공격\(예: 프록시 캐시 중독 또는 리소스 디렉터리의 검증/조회 인터페이스 속임\)까지 다양한 수준의 영향을 미칩니다. 보다 일반적으로 글로벌 네트워크 상태를 저장하고 CoAP를 메시징 기능으로 사용하여 상태 설정 또는 업데이트를 처리하는 모든 구성 요소가 잠재적인 대상입니다.\) 또는

1. 대상 노드에 대한 멀티캐스트 요청을 스푸핑합니다. 이로 인해 네트워크 정체/붕괴, 피해자에 대한 DoS 공격 또는 강제로 잠에서 깨어날 수 있습니다. 또는

```text
   5.  spoofing observe messages, etc.
```

요청에서 중요하지 않은 무작위 토큰을 선택하면 전송 계층 보안 없이도 경로를 벗어난 공격자에 의한 응답 스푸핑을 감지하고 완화할 수 있습니다\(섹션 5.3.1\). \[RFC4086\]에서는 보안에 대한 무작위성 요구 사항을 논의합니다.

원칙적으로 다른 종류의 스푸핑은 속인 끝점에서 오는 예기치 않은 승인 또는 재설정 메시지로 인해 확인 가능한 메시지 의미 체계가 사용되는 경우에만 CoAP에서 감지할 수 있습니다. 그러나 이렇게 하려면 사용된 메시지 ID를 추적해야 하는데 이것이 항상 가능한 것은 아니며, 게다가 일반적으로 손상이 이미 발생한 후에 탐지가 가능해집니다. 이러한 종류의 공격은 NoSec 이외의 보안 모드를 사용하여 방지할 수 있습니다.

소스 주소 스푸핑이 있든 없든 클라이언트는 서버에 요청\(가급적이면 복잡한 요청\)을 보내 서버에 과부하를 주려고 시도할 수 있습니다. 주소 스푸핑으로 인해 이 공격을 추적하고 차단하는 것이 더 어려워집니다. CON 요청 비용이 적다는 점을 고려하면 이 공격은 쉽게 실행될 수 있습니다. 이 공격을 받으면 제한된 노드가

사용 가능한 총 에너지가 제한되어 있으면 해당 에너지가 계획보다 훨씬 빨리 소모될 수 있습니다\(배터리 고갈 공격\). 또한 클라이언트가 확인 가능한 메시지를 사용하고 서버가 응답하지 않는 \(스푸핑되었을 수 있는\) 주소에 대해 확인 가능한 별도의 응답으로 응답하는 경우 서버는 MAX\_TRANSMIT\_SPAN이 소진될 때까지 각 응답에 대해 버퍼 및 재전송 논리를 할당해야 합니다. 합법적인 트래픽을 처리하기 위한 리소스가 부족해질 가능성이 높아집니다. 후자의 문제는 섹션 4.7에서 논의된 대로 응답 속도를 제한함으로써 어느 정도 완화될 수 있습니다. 공격자는 합법적인 클라이언트의 주소를 스푸핑할 수도 있습니다. 이로 인해 서버가 별도의 응답을 사용하는 경우 NSTART=1로 인해 해당 클라이언트에 대한 합법적인 응답을 차단할 수 있습니다. 이러한 모든 공격은 NoSec 이외의 보안 모드를 사용하여 방지할 수 있으므로 보안 프로토콜에 대한 공격만 남습니다.

---
### **11.5.  Cross-Protocol Attacks**

CoAP 엔드포인트를 유도하여 가짜 소스 주소로 패킷을 보내는 기능은 증폭뿐만 아니라 특정 주소\(IP 주소 및 포트\)에서 UDP 패킷을 듣고 있는 피해자에 대한 교차 프로토콜 공격에도 사용할 수 있습니다. 이는 다음과 같이 발생합니다.

- 공격자는 주어진 주소를 가짜 소스 주소로 하여 CoAP 엔드포인트로 메시지를 보냅니다.

- CoAP 엔드포인트는 지정된 소스 주소에 메시지로 응답합니다.

- 주어진 주소의 피해자는 다른 프로토콜의 규칙에 따라 해석되는 UDP 패킷을 받습니다.

이는 공격자가 피해자에게 직접 통신하는 것을 방지하지만 CoAP 엔드포인트\(다른 프로토콜에서 유효한 역할을 호스팅할 수도 있음\)에서 피해자로의 통신을 허용하는 방화벽 규칙을 우회하는 데 사용될 수 있습니다.

또한 CoAP 엔드포인트는 DNS와 같은 다른 UDP 기반 프로토콜의 엔드포인트를 통해 생성된 프로토콜 간 공격의 피해자가 될 수도 있습니다. 두 경우 모두 엔드포인트의 보안 속성이 IP 주소 확인\(및 가짜 IP 주소를 사용하여 외부에서 전송되는 직접 공격을 방화벽으로 차단\)에 의존하는 경우 공격이 가능합니다. 일반적으로 UDP 기반 프로토콜은 컨텍스트가 부족하기 때문에 프로토콜 간 공격의 대상이 되기 쉽습니다.

마지막으로, 다른 수단으로 전송된 CoAP URI는 클라이언트가 다른 프로토콜의 엔드포인트에 메시지를 보내도록 유도하는 데 사용될 수 있습니다.

교차 프로토콜 공격에 대한 한 가지 완화 방법은 수신된 패킷의 구문을 엄격하게 검사하고 구문의 충분한 차이를 결합하는 것입니다. 예를 들어 CoAP 엔드포인트의 검사를 통과하는 DNS 응답을 보내도록 DNS 서버를 유도하는 것이 어려운 경우 도움이 될 수 있습니다. 불행하게도 DNS 응답의 처음 2바이트는 공격자가 선택할 수 있고 CoAP 헤더의 관심 있는 부분에 매핑되는 ID이며, 다음 2바이트는 CoAP의 메시지 ID로 해석됩니다\(즉, 모든 값은 허용\). DNS 카운트 단어는 \(존재하지 않지만 선택적인\) CoAP 옵션 0의 여러 인스턴스 또는 토큰으로 해석될 수 있습니다. 에코된 쿼리는 CoAP 엔드포인트에서 원하는 효과를 얻기 위해 공격자가 최종적으로 제조할 수 있습니다. 서버에서 추가한 응답\(있는 경우\)은 추가된 페이로드로 해석될 수 있습니다.

```text
                                   1  1  1  1  1  1
     0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                      ID                       | T, TKL, code
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   | Message ID
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                    QDCOUNT                    | (options 0)
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                    ANCOUNT                    | (options 0)
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                    NSCOUNT                    | (options 0)
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                    ARCOUNT                    | (options 0)
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

     Figure 15: DNS Header ([RFC1035], Section 4.1.1) vs. CoAP Message
```

일반적으로 프로토콜 쌍에 대해 프로토콜 중 하나는 공격자가 다른 프로토콜의 메시지처럼 보이는 응답을 생성할 수 있도록 설계되었을 수 있습니다. 아직 공격이 완전히 가능하지는 않지만 좀 더 창의적인 사람에 의해 추가로 개발될 수 있는 사례를 생성하는 것보다 실행 가능한 공격이 없음을 확인하거나 증명하는 것이 훨씬 더 어려운 경우가 많습니다. 따라서 교차 프로토콜 공격은 엔드포인트가 패킷의 소스 IP 주소 신뢰를 기반으로 공격자가 원하는 작업을 승인하지 않는 경우에만 완전히 완화될 수 있습니다. 반대로, CoAP 보안을 위해 방화벽에 전적으로 의존하는 NoSec 환경은 CoAP 엔드포인트뿐만 아니라 다른 UDP 기반 프로토콜을 사용하여 UDP 메시지를 CoAP 엔드포인트로 보내도록 유도될 수 있는 다른 모든 엔드포인트도 방화벽으로 차단해야 합니다.

위의 고려 사항 외에도 프로토콜 간 공격과 관련하여 DTLS에 대한 보안 고려 사항이 적용됩니다. 예를 들어 동일한 DTLS 보안 연결\("연결"\)을 사용하여 여러 프로토콜의 데이터를 전달하는 경우 DTLS는 더 이상 이러한 프로토콜 간의 프로토콜 간 공격에 대한 보호를 제공하지 않습니다.

---
### **11.6.  Constrained-Node Considerations**

제한된 노드의 구현자는 좋은 엔트로피 소스\[RFC4086\]가 없는 경우가 많습니다. 이 경우 노드는 키 생성과 같이 양호한 엔트로피가 필요한 프로세스에 사용되어서는 안 됩니다. 대신, 키는 외부에서 생성되어 제조 또는 시운전 중에 장치에 추가되어야 합니다.

처리 능력이 낮기 때문에 제한된 노드는 특히 타이밍 공격에 취약합니다. 암호화 기본 요소를 구현할 때는 특별한 주의를 기울여야 합니다.

다수의 제한된 노드가 노출된 환경에 설치되며 키 자료 복구를 포함한 변조에 대한 저항력이 거의 없습니다. 할당된 자격 증명의 범위를 정의할 때 이 점을 고려해야 합니다. 특히, 노드 그룹에 공유 키를 할당하면 제한된 단일 노드가 전체 그룹을 전복시키는 대상이 될 수 있습니다.

---
## **12.  IANA Considerations**
---
### **12.1.  CoAP Code Registries**

이 문서는 "CoRE\(제약된 RESTful 환경\) 매개변수" 레지스트리\(이하 "CoRE 매개변수" 레지스트리라고 함\) 내 CoAP 헤더의 코드 필드 값에 대한 두 개의 하위 레지스트리를 정의합니다.

두 하위 레지스트리의 값은 첫 번째 숫자와 두 번째 숫자 사이에 마침표로 구분된 세 개의 십진수 c.dd로 표시된 8비트 값입니다. 첫 번째 숫자 c는 0에서 7 사이이며 코드 클래스를 나타냅니다. 두 번째와 세 번째 숫자 dd는 세부사항에 대한 00에서 31 사이의 십진수를 나타냅니다.

모든 코드 값은 다음 범위에 따라 하위 레지스트리에 의해 할당됩니다.

0.00 빈 메시지를 나타냅니다\(섹션 4.1 참조\).

```text
   0.01-0.31 Indicates a request.  Values in this range are assigned by
             the "CoAP Method Codes" sub-registry (see Section 12.1.1).

   1.00-1.31 Reserved

   2.00-5.31 Indicates a response.  Values in this range are assigned by
             the "CoAP Response Codes" sub-registry (see
             Section 12.1.2).

   6.00-7.31 Reserved
```

---
#### **12.1.1.  Method Codes**

하위 레지스트리의 이름은 "CoAP Method Codes"입니다.

하위 레지스트리의 각 항목에는 0.01-0.31 범위의 메소드 코드, 메소드 이름, 메소드 문서에 대한 참조가 포함되어야 합니다.

이 하위 레지스트리의 초기 항목은 다음과 같습니다.

```text
                       +------+--------+-----------+
                       | Code | Name   | Reference |
                       +------+--------+-----------+
                       | 0.01 | GET    | [RFC7252] |
                       | 0.02 | POST   | [RFC7252] |
                       | 0.03 | PUT    | [RFC7252] |
                       | 0.04 | DELETE | [RFC7252] |
                       +------+--------+-----------+

                        Table 5: CoAP Method Codes
```

다른 모든 방법 코드는 할당되지 않습니다.

이 하위 레지스트리에 대한 향후 추가에 대한 IANA 정책은 \[RFC5226\]에 설명된 대로 "IETF 검토 또는 IESG 승인"입니다.

메소드 코드 문서에서는 다음 속성을 포함하여 해당 코드를 사용하여 요청의 의미를 지정해야 합니다.

- 성공 사례에서 메서드가 반환하는 응답 코드입니다.

- 메서드가 멱등성인지, 안전한지 또는 둘 다인지 여부입니다.

---
#### **12.1.2.  Response Codes**

하위 레지스트리의 이름은 "CoAP 응답 코드"입니다.

하위 레지스트리의 각 항목에는 2.00-5.31 범위의 응답 코드, 응답 코드에 대한 설명 및 응답 코드 문서에 대한 참조가 포함되어야 합니다.

이 하위 레지스트리의 초기 항목은 다음과 같습니다.

```text
            +------+------------------------------+-----------+
            | Code | Description                  | Reference |
            +------+------------------------------+-----------+
            | 2.01 | Created                      | [RFC7252] |
            | 2.02 | Deleted                      | [RFC7252] |
            | 2.03 | Valid                        | [RFC7252] |
            | 2.04 | Changed                      | [RFC7252] |
            | 2.05 | Content                      | [RFC7252] |
            | 4.00 | Bad Request                  | [RFC7252] |
            | 4.01 | Unauthorized                 | [RFC7252] |
            | 4.02 | Bad Option                   | [RFC7252] |
            | 4.03 | Forbidden                    | [RFC7252] |
            | 4.04 | Not Found                    | [RFC7252] |
            | 4.05 | Method Not Allowed           | [RFC7252] |
            | 4.06 | Not Acceptable               | [RFC7252] |
            | 4.12 | Precondition Failed          | [RFC7252] |
            | 4.13 | Request Entity Too Large     | [RFC7252] |
            | 4.15 | Unsupported Content-Format   | [RFC7252] |
            | 5.00 | Internal Server Error        | [RFC7252] |
            | 5.01 | Not Implemented              | [RFC7252] |
            | 5.02 | Bad Gateway                  | [RFC7252] |
            | 5.03 | Service Unavailable          | [RFC7252] |
            | 5.04 | Gateway Timeout              | [RFC7252] |
            | 5.05 | Proxying Not Supported       | [RFC7252] |
            +------+------------------------------+-----------+

                       Table 6: CoAP Response Codes
```

응답 코드 3.00-3.31은 향후 사용을 위해 예약되어 있습니다. 다른 모든 응답 코드는 할당되지 않습니다.

이 하위 레지스트리에 대한 향후 추가에 대한 IANA 정책은 \[RFC5226\]에 설명된 대로 "IETF 검토 또는 IESG 승인"입니다.

응답 코드 문서에서는 다음 속성을 포함하여 해당 코드로 응답의 의미를 지정해야 합니다.

- 응답 코드가 적용되는 메소드입니다.

- 페이로드가 필수인지, 선택 사항인지, 허용되지 않는지 여부입니다.

- 페이로드의 의미. 예를 들어 2.05\(콘텐츠\) 응답의 페이로드는 대상 리소스를 나타냅니다. 오류 응답의 페이로드는 사람이 읽을 수 있는 진단 페이로드입니다.

- 페이로드의 형식입니다. 예를 들어, 2.05\(콘텐츠\) 응답의 형식은 Content-Format 옵션으로 표시됩니다. 오류 응답의 페이로드 형식은 항상 Net-Unicode 텍스트입니다.

- 신선도 모델에 따라 응답을 캐시할 수 있는지 여부입니다.

- 검증 모델에 따라 응답을 검증할 수 있는지 여부.

- 응답으로 인해 캐시가 요청 URI에 대해 저장된 응답을 최신이 아닌 것으로 표시하는지 여부.

---
### **12.2.  CoAP Option Numbers Registry**

이 문서는 "CoRE 매개변수" 레지스트리 내의 CoAP 옵션에 사용되는 옵션 번호에 대한 하위 레지스트리를 정의합니다. 하위 레지스트리의 이름은 "CoAP 옵션 번호"입니다.

하위 레지스트리의 각 항목에는 옵션 번호, 옵션 이름 및 옵션 문서에 대한 참조가 포함되어야 합니다.

이 하위 레지스트리의 초기 항목은 다음과 같습니다.

```text
                 +--------+------------------+-----------+
                 | Number | Name             | Reference |
                 +--------+------------------+-----------+
                 |      0 | (Reserved)       | [RFC7252] |
                 |      1 | If-Match         | [RFC7252] |
                 |      3 | Uri-Host         | [RFC7252] |
                 |      4 | ETag             | [RFC7252] |
                 |      5 | If-None-Match    | [RFC7252] |
                 |      7 | Uri-Port         | [RFC7252] |
                 |      8 | Location-Path    | [RFC7252] |
                 |     11 | Uri-Path         | [RFC7252] |
                 |     12 | Content-Format   | [RFC7252] |
                 |     14 | Max-Age          | [RFC7252] |
                 |     15 | Uri-Query        | [RFC7252] |
                 |     17 | Accept           | [RFC7252] |
                 |     20 | Location-Query   | [RFC7252] |
                 |     35 | Proxy-Uri        | [RFC7252] |
                 |     39 | Proxy-Scheme     | [RFC7252] |
                 |     60 | Size1            | [RFC7252] |
                 |    128 | (Reserved)       | [RFC7252] |
                 |    132 | (Reserved)       | [RFC7252] |
                 |    136 | (Reserved)       | [RFC7252] |
                 |    140 | (Reserved)       | [RFC7252] |
                 +--------+------------------+-----------+

                       Table 7: CoAP Option Numbers
```

이 하위 레지스트리에 대한 향후 추가를 위한 IANA 정책은 다음과 같이 세 가지 계층으로 나뉩니다. 0..255 범위는 IETF\(IETF 검토 또는 IESG 승인\)에 의해 정의된 옵션용으로 예약되어 있습니다. 256..2047 범위는 공개 사양\(사양 필수\)에서 일반적으로 사용되는 옵션용으로 예약되어 있습니다. 2048..64999의 범위는 옵션 의미 체계가 올바르게 정의되었는지 확인하는 데 도움이 되는 지정 전문가 검토를 거치는 개인 또는 공급업체별 옵션을 포함한 다른 모든 옵션에 대한 것입니다. 65000에서 65535 사이의 옵션 번호는 실험용으로 예약되어 있습니다. 어떤 종류의 벤더별 사용을 위한 것이 아니며 운영 배포에 사용해서는 안 됩니다.

```text
          +-------------+---------------------------------------+
          |       Range | Registration Procedures               |
          +-------------+---------------------------------------+
          |       0-255 | IETF Review or IESG Approval          |
          |    256-2047 | Specification Required                |
          |  2048-64999 | Expert Review                         |
          | 65000-65535 | Experimental use (no operational use) |
          +-------------+---------------------------------------+

           Table 8: CoAP Option Numbers: Registration Procedures
```

옵션 번호의 문서에서는 다음 속성을 포함하여 해당 번호가 있는 옵션의 의미를 지정해야 합니다.

- 요청에 있는 옵션의 의미.

- 응답에서 옵션의 의미.

- 옵션 번호에 따라 결정되는 옵션이 필수인지 선택인지 여부입니다.

- 옵션이 Safe-to-Forward인지 여부, 그리고 그렇다면 옵션 번호에 따라 결정되는 캐시 키의 일부인지 여부\(섹션 5.4.2 참조\).

- 옵션 값의 형식과 길이입니다.

- 옵션이 최대 한 번 발생해야 하는지 아니면 여러 번 발생할 수 있는지 여부입니다.

- 기본값\(있는 경우\)입니다. 기본값이 있는 중요 옵션의 경우 기본값이 중요 옵션을 지원하지 않는 구현에 의한 처리를 어떻게 가능하게 하는지에 대한 논의입니다\(섹션 5.4.4\).

---
### **12.3.  CoAP Content-Formats Registry**

인터넷 미디어 유형은 "application/xml" \[RFC2046\]과 같은 문자열로 식별됩니다. 페이로드 형식을 표시하기 위해 이러한 미디어 유형을 사용하는 오버헤드를 최소화하기 위해 이 문서는 CoAP에서 사용할 인터넷 미디어 유형의 하위 집합에 대한 하위 레지스트리를 정의하고 콘텐츠 코딩과 함께 각각을 할당합니다. 숫자 식별자. 하위 레지스트리의 이름은 "CoRE 매개변수" 레지스트리 내의 "CoAP Content-Formats"입니다.

하위 레지스트리의 각 항목에는 IANA에 등록된 미디어 유형, CoAP에서 해당 미디어 유형에 사용할 0-65535 범위의 숫자 식별자, 이 식별자와 관련된 콘텐츠 코딩 및 문서에 대한 참조가 포함되어야 합니다. 해당 미디어 유형의 페이로드가 의미적으로 무엇을 의미하는지 설명합니다.

CoAP에는 요청이나 응답과 함께 콘텐츠 인코딩 정보를 전달하는 별도의 방법이 포함되어 있지 않으므로 콘텐츠 인코딩도 각 식별자\(있는 경우\)에 대해 지정됩니다. 여러 콘텐츠 인코딩이 미디어 유형과 함께 사용되는 경우 각각에 대해 별도의 콘텐츠 형식 식별자가 등록됩니다. 마찬가지로 CoAP Content-Format 항목에 대해 레벨과 같은 인터넷 미디어 유형과 관련된 다른 매개변수를 정의할 수 있습니다.

이 하위 레지스트리의 초기 항목은 다음과 같습니다.

```text
   +--------------------------+----------+----+------------------------+
   | Media type               | Encoding | ID | Reference              |
   +--------------------------+----------+----+------------------------+
   | text/plain;              | -        |  0 | [RFC2046] [RFC3676]    |
   | charset=utf-8            |          |    | [RFC5147]              |
   | application/link-format  | -        | 40 | [RFC6690]              |
   | application/xml          | -        | 41 | [RFC3023]              |
   | application/octet-stream | -        | 42 | [RFC2045] [RFC2046]    |
   | application/exi          | -        | 47 | [REC-exi-20140211]     |
   | application/json         | -        | 50 | [RFC7159]              |
   +--------------------------+----------+----+------------------------+

                       Table 9: CoAP Content-Formats
```

65000에서 65535 사이의 식별자는 실험용으로 예약되어 있습니다. 어떤 종류의 벤더별 사용을 위한 것이 아니며 운영 배포에 사용해서는 안 됩니다. 256에서 9999 사이의 식별자는 IETF 사양\(IETF 검토 또는 IESG 승인\)에서 향후 사용을 위해 예약되어 있습니다. 다른 모든 식별자는 할당되지 않습니다.

단일 바이트 식별자의 네임스페이스가 너무 작기 때문에 하위 레지스트리에 포함된 0-255 범위의 향후 추가에 대한 IANA 정책은 \[RFC5226\]에 설명된 "전문가 검토"입니다. 10000-64999 범위의 추가에 대한 IANA 정책은 \[RFC5226\]에 설명된 대로 "선착순"입니다. 이는 다음 표에 요약되어 있습니다.

```text
          +-------------+---------------------------------------+
          |       Range | Registration Procedures               |
          +-------------+---------------------------------------+
          |       0-255 | Expert Review                         |
          |    256-9999 | IETF Review or IESG Approval          |
          | 10000-64999 | First Come First Served               |
          | 65000-65535 | Experimental use (no operational use) |
          +-------------+---------------------------------------+

          Table 10: CoAP Content-Formats: Registration Procedures
```

M2M\(Machine-to-Machine\) 애플리케이션에서는 text/plain, application/xml 또는 application/octet-stream과 같은 일반 인터넷 미디어 유형이 장기적으로 실제 애플리케이션에 유용할 것으로 예상되지 않습니다. CoAP를 사용하는 M2M 애플리케이션은 페이로드를 생성하거나 구문 분석하는 방법에 대한 의미 정보를 나타내는 새로운 인터넷 미디어 유형을 IANA에 요청하는 것이 좋습니다. 예를 들어, XML로 전달되는 Smart Energy 애플리케이션 페이로드는 application/se+xml 또는 application/se-exi와 같은 보다 구체적인 유형을 요청할 수 있습니다.

---
### **12.4.  URI Scheme Registration**

이 문서에는 URI\(Uniform Resource Identifier\) ​​체계 "coap" 등록 요청이 포함되어 있습니다. 등록 요청은 \[RFC4395\]를 준수합니다.

```text
   URI scheme name.
      coap

   Status.
      Permanent.
```

URI 체계 구문. - \[RFC7252\]의 섹션 6.1에 정의되어 있습니다.

URI 체계 의미론. - "coap" URI 체계는 CoAP\(제약된 애플리케이션 프로토콜\)를 통해 잠재적으로 액세스할 수 있는 리소스를 식별하는 방법을 제공합니다. 관리하는 CoAP 서버에 접속하여 리소스를 찾을 수 있으며 서버에 CoAP 요청을 보내 작동할 수 있습니다. 따라서 이 체계는 "http" URI 체계 \[RFC2616\]와 비교될 수 ​​있습니다. 작업에 대한 자세한 내용은 \[RFC7252\]의 섹션 6을 참조하세요.

인코딩 고려 사항. - 인코딩 방식은 \[RFC3986\]에서 URI에 대해 설정된 인코딩 규칙을 따릅니다. 즉, 국제화 문자와 예약 문자는 UTF-8 기반의 백분율 인코딩을 사용하여 표현됩니다.

이 URI 체계 이름을 사용하는 애플리케이션/프로토콜입니다. - 이 체계는 CoAP 끝점에서 CoAP 리소스에 액세스하는 데 사용됩니다.

```text
   Interoperability considerations.
      None.
```

보안 고려 사항. - \[RFC7252\]의 섹션 11.1을 참조하세요.

```text
   Contact.
      IETF Chair <chair@ietf.org>

   Author/Change controller.
      IESG <iesg@ietf.org>

   References.
      [RFC7252]
```

---
### **12.5.  Secure URI Scheme Registration**

이 문서에는 URI\(Uniform Resource Identifier\) ​​체계 "coaps" 등록 요청이 포함되어 있습니다. 등록 요청은 \[RFC4395\]를 준수합니다.

```text
   URI scheme name.
      coaps

   Status.
      Permanent.
```

URI 체계 구문. - \[RFC7252\]의 섹션 6.2에 정의되어 있습니다.

URI 체계 의미론. - "coaps" URI 체계는 전송 보안을 위해 DTLS\(데이터그램 전송 계층 보안\)를 사용하여 CoAP\(제약된 애플리케이션 프로토콜\)를 통해 잠재적으로 액세스할 수 있는 리소스를 식별하는 방법을 제공합니다. 관리하는 CoAP 서버에 접속하여 리소스를 찾을 수 있으며 서버에 CoAP 요청을 보내 작동할 수 있습니다. 따라서 이 체계는 "https" URI 체계 \[RFC2616\]와 비교할 수 있습니다. 작업에 대한 자세한 내용은 \[RFC7252\]의 섹션 6을 참조하세요.

인코딩 고려 사항. - 인코딩 방식은 \[RFC3986\]에서 URI에 대해 설정된 인코딩 규칙을 따릅니다. 즉, 국제화 문자와 예약 문자는 UTF-8 기반의 백분율 인코딩을 사용하여 표현됩니다.

이 URI 체계 이름을 사용하는 애플리케이션/프로토콜입니다. - 이 체계는 CoAP 엔드포인트에서 DTLS를 사용하여 CoAP 리소스에 액세스하는 데 사용됩니다.

```text
   Interoperability considerations.
      None.
```

보안 고려 사항. - \[RFC7252\]의 섹션 11.1을 참조하세요.

```text
   Contact.
      IETF Chair <chair@ietf.org>

   Author/Change controller.
      IESG <iesg@ietf.org>

   References.
      [RFC7252]
```

---
### **12.6.  Service Name and Port Number Registration**

CoAP의 기능 중 하나는 리소스 검색입니다. CoAP 클라이언트는 CoAP 서버에 제공되는 리소스에 대해 요청할 수 있습니다\(섹션 7 참조\). IP 주소 지식만을 기반으로 리소스 검색을 활성화하려면 리소스 검색을 위한 CoAP 포트를 표준화해야 합니다.

IANA는 \[RFC6335\]에 따라 포트 번호 5683과 서비스 이름 "coap"을 할당했습니다.

유니캐스트 외에도 CoAP는 멀티캐스트와 애니캐스트 모두에서 사용할 수 있습니다.

```text
   Service Name.
      coap

   Transport Protocol.
      udp

   Assignee.
      IESG <iesg@ietf.org>

   Contact.
      IETF Chair <chair@ietf.org>

   Description.
      Constrained Application Protocol (CoAP)

   Reference.
      [RFC7252]

   Port Number.
      5683
```

---
### **12.7.  Secure Service Name and Port Number Registration**

CoAP 리소스 검색은 DTLS 보안 CoAP "coaps" 방식을 사용하여 제공될 수도 있습니다. 따라서 보안 자원 검색을 위한 CoAP 포트를 표준화해야 합니다.

IANA는 \[RFC6335\]에 따라 포트 번호 5684와 서비스 이름 "coaps"를 할당했습니다.

유니캐스트 외에도 DTLS 보안 CoAP를 애니캐스트와 함께 사용할 수 있습니다.

```text
   Service Name.
      coaps

   Transport Protocol.
      udp

   Assignee.
      IESG <iesg@ietf.org>

   Contact.
      IETF Chair <chair@ietf.org>

   Description.
      DTLS-secured CoAP

   Reference.
      [RFC7252]

   Port Number.
      5684
```

---
### **12.8.  Multicast Address Registration**

섹션 8, "멀티캐스트 CoAP"에서는 멀티캐스트 사용을 정의합니다. IANA는 CoAP 노드에서 사용할 수 있도록 다음과 같은 멀티캐스트 주소를 할당했습니다.

IPv4 -- "IPv4 멀티캐스트 주소 공간 레지스트리"의 "모든 CoAP 노드" 주소 224.0.1.187. 주소는 단일 네트워크 이상으로 확장될 수 있는 검색에 사용되므로 Internetwork Control Block\(224.0.1.x, RFC 5771\)에서 가져왔습니다.

IPv6 - "가변 범위 멀티캐스트 주소" 공간\(RFC 3307\)에 있는 "IPv6 멀티캐스트 주소 공간 레지스트리"의 "모든 CoAP 노드" 주소 FF0X::FD. 관심 있는 CoAP 노드가 수신해야 하는 각 범위마다 고유한 멀티캐스트 주소가 있습니다. CoAP에는 링크-로컬 및 사이트-로컬 범위만 필요합니다.

---
## **13.  Acknowledgements**

Brian Frank는 이 사양의 초기 버전에 기여하고 공동 저자였습니다.

수많은 상세한 검토와 토론과 함께 문서의 아이디어와 텍스트에 상당한 기여를 한 Peter Bigot, Esko Dijk 및 Cullen Jennings에게 특별히 감사드립니다.

Floris Van den Abeele, Anthony Baire, Ed Beroset, Berta Carballido, Angelo P. Castellani, Gilbert Clark, Robert Cragie, Pierre David, Esko Dijk, Lisa Dusseault, Mehmet Ersue, Thomas Fossati, Tobias Gondrom, Bert Greevenbosch, Tom Herbst에게 감사드립니다. , Jeroen Hoebeke, Richard Kelsey, Sye Loong Keoh, Ari Keranen, Matthias Kovatsch, Avi Lior, Stephan Lohse, Salvatore Loreto, Kerry Lynn, Andrew McGregor, Alexey Melnikov, Guido Moritz, Petri Mutka, Colin O'Flynn, Charles Palmer, Adriano Pezzuto, Thomas Poetsch, Robert Quattlebaum, Akbar Rahman, Eric Rescorla, Dan Romascanu, David Ryan, Peter Saint-Andre, Szymon Sasin, Michael Scharf, Dale Seed, Robby Simpson, Peter van der Stok, Michael Stuber, Linyi Tian, ​​Gilman Tolle , Matthieu Vial, Maciej Wasilak, Fan Xianyou 및 Alper Yegin은 문서를 형성하는 데 도움이 되는 의견과 토론을 해주신 분들입니다. 또한 완료 당시 IETF 지역 책임자인 Barry Leiba와 IESG 검토자인 Adrian Farrel, Martin Stiemerling, Pete Resnick, Richard Barnes, Sean Turner, Spencer Dawkins, Stephen Farrell 및 Ted Lemon에게 특별히 감사드립니다. 심층적인 리뷰.

일부 텍스트는 IETF HTTPBIS 작업 그룹의 작업 문서에서 차용되었습니다.

---
## **14.  References**
---
### **14.1.  Normative References**

```text
   [RFC0768]  Postel, J., "User Datagram Protocol", STD 6, RFC 768,
              August 1980.

   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, November 1996.

   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", RFC 2046,
              November 1996.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

   [RFC3023]  Murata, M., St. Laurent, S., and D. Kohn, "XML Media
              Types", RFC 3023, January 2001.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, November 2003.

   [RFC3676]  Gellens, R., "The Text/Plain Format and DelSp Parameters",
              RFC 3676, February 2004.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, RFC
              3986, January 2005.

   [RFC4279]  Eronen, P. and H. Tschofenig, "Pre-Shared Key Ciphersuites
              for Transport Layer Security (TLS)", RFC 4279, December
              2005.

   [RFC4395]  Hansen, T., Hardie, T., and L. Masinter, "Guidelines and
              Registration Procedures for New URI Schemes", BCP 35, RFC
              4395, February 2006.

   [RFC5147]  Wilde, E. and M. Duerst, "URI Fragment Identifiers for the
              text/plain Media Type", RFC 5147, April 2008.

   [RFC5198]  Klensin, J. and M. Padlipsky, "Unicode Format for Network
              Interchange", RFC 5198, March 2008.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.

   [RFC5234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234, January 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Elliptic Curve Cryptography Subject Public Key
              Information", RFC 5480, March 2009.

   [RFC5785]  Nottingham, M. and E. Hammer-Lahav, "Defining Well-Known
              Uniform Resource Identifiers (URIs)", RFC 5785, April
              2010.

   [RFC5952]  Kawamura, S. and M. Kawashima, "A Recommendation for IPv6
              Address Text Representation", RFC 5952, August 2010.

   [RFC5988]  Nottingham, M., "Web Linking", RFC 5988, October 2010.

   [RFC6066]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", RFC 6066, January 2011.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, January 2012.

   [RFC6690]  Shelby, Z., "Constrained RESTful Environments (CoRE) Link
              Format", RFC 6690, August 2012.

   [RFC6920]  Farrell, S., Kutscher, D., Dannewitz, C., Ohlman, B.,
              Keranen, A., and P. Hallam-Baker, "Naming Things with
              Hashes", RFC 6920, April 2013.

   [RFC7250]  Wouters, P., Tschofenig, H., Gilmore, J., Weiler, S., and
              T. Kivinen, "Using Raw Public Keys in Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", RFC 7250, June 2014.

   [RFC7251]  McGrew, D., Bailey, D., Campagna, M., and R. Dugal, "AES-
              CCM Elliptic Curve Cryptography (ECC) Cipher Suites for
              Transport Layer Security (TLS)", RFC 7251, June 2014.
```

---
### **14.2.  Informative References**

```text
   [BLOCK]    Bormann, C. and Z. Shelby, "Blockwise transfers in CoAP",
              Work in Progress, October 2013.

   [CoAP-MISC]
              Bormann, C. and K. Hartke, "Miscellaneous additions to
              CoAP", Work in Progress, December 2013.

   [EUI64]    IEEE Standards Association, "Guidelines for 64-bit Global
              Identifier (EUI-64 (TM))", Registration Authority
              Tutorials, April 2010, <http://standards.ieee.org/regauth/
              oui/tutorials/EUI64.html>.

   [GROUPCOMM]
              Rahman, A. and E. Dijk, "Group Communication for CoAP",
              Work in Progress, December 2013.

   [HHGTTG]   Adams, D., "The Hitchhiker's Guide to the Galaxy", Pan
              Books ISBN 3320258648, 1979.

   [IEEE1003.1]
              IEEE and The Open Group, "Portable Operating System
              Interface (POSIX)", The Open Group Base Specifications
              Issue 7, IEEE 1003.1, 2013 Edition,
              <http://pubs.opengroup.org/onlinepubs/9699919799/>.

   [IPsec-CoAP]
              Bormann, C., "Using CoAP with IPsec", Work in Progress,
              December 2012.

   [MAPPING]  Castellani, A., Loreto, S., Rahman, A., Fossati, T., and
              E. Dijk, "Guidelines for HTTP-CoAP Mapping
              Implementations", Work in Progress, February 2014.

   [OBSERVE]  Hartke, K., "Observing Resources in CoAP", Work in
              Progress, April 2014.

   [REC-exi-20140211]
              Schneider, J., Kamiya, T., Peintner, D., and R. Kyusakov,
              "Efficient XML Interchange (EXI) Format 1.0 (Second
              Edition)", W3C Recommendation REC-exi-20140211, February
              2014, <http://www.w3.org/TR/2014/REC-exi-20140211/>.

   [REST]     Fielding, R., "Architectural Styles and the Design of
              Network-based Software Architectures", Ph.D. Dissertation,
              University of California, Irvine, 2000,
              <http://www.ics.uci.edu/~fielding/pubs/dissertation/
              fielding_dissertation.pdf>.

   [RFC0020]  Cerf, V., "ASCII format for network interchange", RFC 20,
              October 1969.

   [RFC0791]  Postel, J., "Internet Protocol", STD 5, RFC 791, September
              1981.

   [RFC0792]  Postel, J., "Internet Control Message Protocol", STD 5,
              RFC 792, September 1981.

   [RFC0793]  Postel, J., "Transmission Control Protocol", STD 7, RFC
              793, September 1981.

   [RFC1035]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, RFC 1035, November 1987.

   [RFC3264]  Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model
              with Session Description Protocol (SDP)", RFC 3264, June
              2002.

   [RFC3280]  Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
              X.509 Public Key Infrastructure Certificate and
              Certificate Revocation List (CRL) Profile", RFC 3280,
              April 2002.

   [RFC3542]  Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei,
              "Advanced Sockets Application Program Interface (API) for
              IPv6", RFC 3542, May 2003.

   [RFC3828]  Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., and
              G. Fairhurst, "The Lightweight User Datagram Protocol
              (UDP-Lite)", RFC 3828, July 2004.

   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, "Randomness
              Requirements for Security", BCP 106, RFC 4086, June 2005.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, "Internet Control
              Message Protocol (ICMPv6) for the Internet Protocol
              Version 6 (IPv6) Specification", RFC 4443, March 2006.

   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", RFC 4492, May 2006.

   [RFC4821]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, March 2007.

   [RFC4944]  Montenegro, G., Kushalnagar, N., Hui, J., and D. Culler,
              "Transmission of IPv6 Packets over IEEE 802.15.4
              Networks", RFC 4944, September 2007.

   [RFC5405]  Eggert, L. and G. Fairhurst, "Unicast UDP Usage Guidelines
              for Application Designers", BCP 145, RFC 5405, November
              2008.

   [RFC5489]  Badra, M. and I. Hajjeh, "ECDHE_PSK Cipher Suites for
              Transport Layer Security (TLS)", RFC 5489, March 2009.

   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic
              Curve Cryptography Algorithms", RFC 6090, February 2011.

   [RFC6120]  Saint-Andre, P., "Extensible Messaging and Presence
              Protocol (XMPP): Core", RFC 6120, March 2011.

   [RFC6282]  Hui, J. and P. Thubert, "Compression Format for IPv6
              Datagrams over IEEE 802.15.4-Based Networks", RFC 6282,
              September 2011.

   [RFC6335]  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.
              Cheshire, "Internet Assigned Numbers Authority (IANA)
              Procedures for the Management of the Service Name and
              Transport Protocol Port Number Registry", BCP 165, RFC
              6335, August 2011.

   [RFC6655]  McGrew, D. and D. Bailey, "AES-CCM Cipher Suites for
              Transport Layer Security (TLS)", RFC 6655, July 2012.

   [RFC6936]  Fairhurst, G. and M. Westerlund, "Applicability Statement
              for the Use of IPv6 UDP Datagrams with Zero Checksums",
              RFC 6936, April 2013.

   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, "X.509 Internet Public Key
              Infrastructure Online Certificate Status Protocol - OCSP",
              RFC 6960, June 2013.

   [RFC6961]  Pettersen, Y., "The Transport Layer Security (TLS)
              Multiple Certificate Status Request Extension", RFC 6961,
              June 2013.

   [RFC7159]  Bray, T., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, March 2014.

   [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, "Terminology for
              Constrained-Node Networks", RFC 7228, May 2014.

   [RTO-CONSIDER]
              Allman, M., "Retransmission Timeout Considerations", Work
              in Progress, May 2012.

   [W3CXMLSEC]
              Wenning, R., "Report of the XML Security PAG", W3C XML
              Security PAG, October 2012,
              <http://www.w3.org/2011/xmlsec-pag/pagreport.html>.
```

---
# **Appendix A.  Examples**

이 섹션에서는 GET 요청에 대한 메시지 흐름이 포함된 여러 가지 간단한 예를 제공합니다. 이 예에서는 기본 작업, 재전송 시 작업 및 멀티캐스트를 보여줍니다.

그림 16은 피기백 응답을 유발하는 기본 GET 요청을 보여줍니다. 클라이언트는 메시지 ID 0x7d34를 사용하여 coap://server/temp 리소스에 대한 확인 가능한 GET 요청을 서버에 보냅니다. 요청에는 하나의 Uri-Path 옵션\(델타 0 + 11 = 11, 길이 11, 값 "온도"\)이 포함됩니다. 토큰은 비어 있습니다. 이 요청의 길이는 총 16바이트입니다. 확인 가능 요청을 승인하는 승인 메시지에 2.05\(콘텐츠\) 응답이 반환되며 메시지 ID 0x7d34와 빈 토큰 값이 모두 반영됩니다. 응답에는 "22.3 C"의 페이로드가 포함되어 있으며 길이는 11바이트입니다.

```text
   Client  Server
      |      |
      |      |
      +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d34)
      | GET  |   Uri-Path: "temperature"
      |      |
      |      |
      |<-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d34)
      | 2.05 |    Payload: "22.3 C"
      |      |

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 1 | 0 |   0   |     GET=1     |          MID=0x7d34           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  11   |  11   |      "temperature" (11 B) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 1 | 2 |   0   |    2.05=69    |          MID=0x7d34           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1|      "22.3 C" (6 B) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

           Figure 16: Confirmable Request; Piggybacked Response
```

그림 17은 유사한 예를 보여 주지만 요청과 응답에 비어 있지 않은 토큰\(값 0x20\)을 포함하여 크기가 각각 17바이트와 12바이트로 증가합니다.

```text
   Client  Server
      |      |
      |      |
      +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d35)
      | GET  |      Token: 0x20
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |<-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d35)
      | 2.05 |      Token: 0x20
      |      |    Payload: "22.3 C"
      |      |

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 1 | 0 |   1   |     GET=1     |          MID=0x7d35           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     0x20      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  11   |  11   |      "temperature" (11 B) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 1 | 2 |   1   |    2.05=69    |          MID=0x7d35           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     0x20      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1| "22.3 C" (6 B) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

           Figure 17: Confirmable Request; Piggybacked Response
```

그림 18에서는 확인 가능한 GET 요청이 손실되었습니다. ACK\_TIMEOUT 초 후에 클라이언트는 요청을 재전송하여 이전 예와 같이 피기백 응답을 얻습니다.

```text
   Client  Server
      |      |
      |      |
      +----X |     Header: GET (T=CON, Code=0.01, MID=0x7d36)
      | GET  |      Token: 0x31
      |      |   Uri-Path: "temperature"
   TIMEOUT   |
      |      |
      +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d36)
      | GET  |      Token: 0x31
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |<-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d36)
      | 2.05 |      Token: 0x31
      |      |    Payload: "22.3 C"
      |      |

   Figure 18: Confirmable Request (Retransmitted); Piggybacked Response
```

그림 19에서는 서버에서 클라이언트로 전달되는 첫 번째 승인 메시지가 손실되었습니다. ACK\_TIMEOUT초 후에 클라이언트는 요청을 재전송합니다.

```text
   Client  Server
      |      |
      |      |
      +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d37)
      | GET  |      Token: 0x42
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      | X----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d37)
      | 2.05 |      Token: 0x42
      |      |    Payload: "22.3 C"
   TIMEOUT   |
      |      |
      +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d37)
      | GET  |      Token: 0x42
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |<-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d37)
      | 2.05 |      Token: 0x42
      |      |    Payload: "22.3 C"
      |      |

   Figure 19: Confirmable Request; Piggybacked Response (Retransmitted)
```

그림 20에서 서버는 확인 가능 요청을 승인하고 확인 가능 메시지에 별도로 2.05\(콘텐츠\) 응답을 보냅니다. 승인 메시지와 확인 가능 응답이 반드시 전송된 순서대로 도착할 필요는 없습니다. 클라이언트는 확인 가능 응답을 확인합니다.

```text
   Client  Server
      |      |
      |      |
      +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d38)
      | GET  |      Token: 0x53
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |<- - -+     Header: (T=ACK, Code=0.00, MID=0x7d38)
      |      |
      |      |
      |<-----+     Header: 2.05 Content (T=CON, Code=2.05, MID=0xad7b)
      | 2.05 |      Token: 0x53
      |      |    Payload: "22.3 C"
      |      |
      |      |
      +- - ->|     Header: (T=ACK, Code=0.00, MID=0xad7b)
      |      |

             Figure 20: Confirmable Request; Separate Response
```

그림 21은 클라이언트가 확인 가능 요청을 보낸 직후 상태\(예: 충돌 및 재부팅\)를 잃어서 얼마 후 도착하는 별도의 응답이 예기치 않게 오는 예를 보여줍니다. 이 경우 클라이언트는 재설정 메시지와 함께 확인 가능 응답을 거부합니다. 예상치 못한 ACK는 자동으로 무시됩니다.

```text
   Client  Server
      |      |
      |      |
      +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d39)
      | GET  |      Token: 0x64
      |      |   Uri-Path: "temperature"
    CRASH    |
      |      |
      |<- - -+     Header: (T=ACK, Code=0.00, MID=0x7d39)
      |      |
      |      |
      |<-----+     Header: 2.05 Content (T=CON, Code=2.05, MID=0xad7c)
      | 2.05 |      Token: 0x64
      |      |    Payload: "22.3 C"
      |      |
      |      |
      +- - ->|     Header: (T=RST, Code=0.00, MID=0xad7c)
      |      |

      Figure 21: Confirmable Request; Separate Response (Unexpected)
```

그림 22는 요청과 응답이 확인 불가능하여 둘 다 예고 없이 손실될 수 있는 기본 GET 요청을 보여줍니다.

```text
   Client  Server
      |      |
      |      |
      +----->|     Header: GET (T=NON, Code=0.01, MID=0x7d40)
      | GET  |      Token: 0x75
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |<-----+     Header: 2.05 Content (T=NON, Code=2.05, MID=0xad7d)
      | 2.05 |      Token: 0x75
      |      |    Payload: "22.3 C"
      |      |

       Figure 22: Non-confirmable Request; Non-confirmable Response
```

그림 23에서 클라이언트는 확인 불가능한 GET 요청을 멀티캐스트 주소\(링크 로컬 범위의 모든 노드\)로 보냅니다. 링크에는 A, B, C라는 3개의 서버가 있습니다. 서버 A와 B에는 일치하는 리소스가 있으므로 확인 불가능 2.05\(콘텐츠\) 응답을 다시 보냅니다. B가 보낸 응답이 손실되었습니다. C에는 일치하는 응답이 없으므로 확인 불가능한 4.04\(찾을 수 없음\) 응답을 보냅니다.

```text
   Client  ff02::1  A  B  C
      |       |     |  |  |
      |       |     |  |  |
      +------>|     |  |  |  Header: GET (T=NON, Code=0.01, MID=0x7d41)
      |  GET  |     |  |  |   Token: 0x86
      |             |  |  |   Uri-Path: "temperature"
      |             |  |  |
      |             |  |  |
      |<------------+  |  |  Header: 2.05 (T=NON, Code=2.05, MID=0x60b1)
      |      2.05   |  |  |   Token: 0x86
      |             |  |  |   Payload: "22.3 C"
      |             |  |  |
      |             |  |  |
      |   X------------+  |  Header: 2.05 (T=NON, Code=2.05, MID=0x01a0)
      |      2.05   |  |  |   Token: 0x86
      |             |  |  |   Payload: "20.9 C"
      |             |  |  |
      |             |  |  |
      |<------------------+  Header: 4.04 (T=NON, Code=4.04, MID=0x952a)
      |      4.04   |  |  |   Token: 0x86
      |             |  |  |

      Figure 23: Non-confirmable Request (Multicast); Non-confirmable
                                 Response
```

---
# **Appendix B.  URI Examples**

다음 예에서는 다양한 Uri 옵션 집합과 해당 옵션에서 URI를 구성한 후의 결과를 보여줍니다. 옵션 외에도 섹션 6.5에서는 대상 IP 주소 및 포트를 참조하지만 알고리즘의 모든 경로가 대상 IP 주소 및 포트를 URI에 포함시키는 것은 아닙니다.

```text
   o  Input:

         Destination IP Address = [2001:db8::2:1]
         Destination UDP Port = 5683

      Output:

         coap://[2001:db8::2:1]/

   o  Input:

         Destination IP Address = [2001:db8::2:1]
         Destination UDP Port = 5683
         Uri-Host = "example.net"

      Output:

         coap://example.net/

   o  Input:

         Destination IP Address = [2001:db8::2:1]
         Destination UDP Port = 5683
         Uri-Host = "example.net"
         Uri-Path = ".well-known"
         Uri-Path = "core"

      Output:

         coap://example.net/.well-known/core

   o  Input:
```

- 대상 IP 주소 = \[2001:db8::2:1\] 대상 UDP 포트 = 5683 Uri-Host = "xn--18j4d.example" Uri-Path = 유니코드 문자로 구성된 문자열 U+3053 U+3093 U +306b U+3061 U+306f, 일반적으로 UTF-8에서 E38193E38293E381ABE381A1E381AF 16진수로 표시됩니다.

```text
      Output:

         coap://xn--18j4d.example/
         %E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF
```

- \(가독성을 위해 줄 바꿈을 삽입했습니다. 이는 URI의 일부가 아닙니다.\)

```text
   o  Input:

         Destination IP Address = 198.51.100.1
         Destination UDP Port = 61616
         Uri-Path = ""
         Uri-Path = "/"
         Uri-Path = ""
         Uri-Path = ""
         Uri-Query = "//"
         Uri-Query = "?&"

      Output:

         coap://198.51.100.1:61616//%2F//?%2F%2F&?%26
```

---
# **Authors' Addresses**

```text
   Zach Shelby
   ARM
   150 Rose Orchard
   San Jose, CA  95134
   USA

   Phone: +1-408-203-9434
   EMail: zach.shelby@arm.com

   Klaus Hartke
   Universitaet Bremen TZI
   Postfach 330440
   Bremen  D-28359
   Germany

   Phone: +49-421-218-63905
   EMail: hartke@tzi.org

   Carsten Bormann
   Universitaet Bremen TZI
   Postfach 330440
   Bremen  D-28359
   Germany

   Phone: +49-421-218-63921
   EMail: cabo@tzi.org
```
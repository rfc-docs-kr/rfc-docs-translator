   텍스트에 설명된 알고리즘과 RIP와 같은 실제 프로토콜에 사용되는 알고리즘 사이에는 또 다른 차이점이 있습니다. 위의 설명에서는 각 엔터티가 자체 항목을 포함하여 거리가 0임을 표시합니다. 실제로 이것은 일반적으로 수행되지 않습니다. 네트워크의 모든 엔터티는 일반적으로 네트워크에 대한 단일 항목으로 요약됩니다. 네트워크 A에 연결된 호스트 또는 게이트웨이 G의 상황을 고려하십시오. C는 네트워크 A 사용 비용을 나타냅니다(일반적으로 1의 메트릭). (네트워크의 내부 구조는 IP에 표시되지 않으므로 네트워크의 두 엔터티 간 이동 비용은 동일하다고 가정합니다.) 원칙적으로 G는 다른 모든 엔터티 H로부터 메시지를 받아야 합니다. 네트워크 A는 해당 엔터티에서 자체로 이동하는 데 드는 비용이 0임을 보여줍니다. 그런 다음 G는 H까지의 거리로 C + 0을 계산합니다. G가 이러한 동일한 메시지를 모두 보도록 하는 대신 테이블에 네트워크 A에 대한 항목을 만들고 C의 메트릭을 할당하는 것으로 시작합니다. 이 항목은 네트워크 A의 경우 네트워크 A의 다른 모든 엔터티에 대한 항목을 요약하는 것으로 생각해야 합니다. 공통 항목으로 요약할 수 없는 A의 유일한 엔터티는 G 자체입니다. G에서 G로 이동하는 비용은 0이기 때문입니다. C는 아닙니다. 그러나 우리는 0 항목이 필요하지 않기 때문에 네트워크 A에 대한 단일 항목만으로 안전하게 작업할 수 있습니다. 이 전략의 또 다른 의미에 유의하십시오. 게이트웨이로 작동하지 않으며 업데이트 메시지를 보낼 필요가 없습니다. 분명히 게이트웨이로 기능하지 않는 호스트(즉, 하나의 네트워크에만 연결된 호스트)는 자신의 항목 D(i,i) = 0 외에 기여할 유용한 정보를 가질 수 없습니다. 인터페이스가 하나만 있기 때문에 이를 통해 다른 네트워크로의 경로가 해당 인터페이스로 들어갔다가 곧바로 다시 나오는 것을 쉽게 알 수 있습니다. 따라서 이러한 경로의 비용은 최소 C 만큼 최고 비용보다 커집니다. 0 항목이 필요하지 않기 때문에 게이트웨이가 아닌 사용자는 라우팅 프로토콜에 전혀 참여할 필요가 없습니다.
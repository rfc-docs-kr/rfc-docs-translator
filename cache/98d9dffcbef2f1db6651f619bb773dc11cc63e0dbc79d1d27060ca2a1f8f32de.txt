다양한 조건에서 이 계획의 동작을 조사합니다.
이는 이 계획이 모든 경우에 작동한다는 것을 보여줍니다. 그만큼
조사할 첫 번째 사례는 우리가 해결하고 싶었던 사례입니다.
문자 지향 Telnet 연결. 다음과 같이 가정해보자.
사용자는 200ms마다 TCP에 새 문자를 보내고 있으며
왕복 시간이 포함된 이더넷을 통해 연결됩니다.
50ms의 소프트웨어 처리. 막을 수단도 없이
작은 패킷 혼잡이 발생하면 각 문자마다 하나의 패킷이 전송됩니다.
ter, 그리고 응답은 최적일 것입니다. 오버헤드는 4000%이지만
이는 이더넷에서 허용됩니다. 고전적인 타이머 구성표,
초당 2개의 패킷으로 제한되어 있으므로 2~3개의 패킷이 발생합니다.
패킷당 전송되는 문자입니다. 그러면 응답성이 저하됩니다.
비록 고대역폭 이더넷에서는 이것은 불필요합니다.
오버헤드는 1500%로 떨어지지만 이더넷에서는 이는 좋지 않습니다.
거래. 우리의 계획을 사용하면 사용자가 입력하는 모든 문자가
유휴 연결이 있는 TCP를 찾으면 문자가 전송됩니다.
통제가 없는 경우와 마찬가지로 한 번에. 사용자에게 아니요가 표시됩니다.
눈에 띄는 지연. 따라서 우리의 계획은 no-와 마찬가지로 수행됩니다.
제어 방식 및 타이머보다 더 나은 응답성을 제공합니다.
계획.